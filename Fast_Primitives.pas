unit Fast_Primitives;

{This file contains some routines for fast drawing of primitives like a line,
rectangle,circle,rhombus and their miscellaneous variations, filters, blitters,
sprites processing etc.}

{$mode objfpc}{$H+,R-,Q-}{$modeswitch advancedrecords}

interface

uses

  {$ifdef Windows}Windows,{$endif}Graphics, FPCanvas, GraphType, Math, Types, TypInfo, SysUtils, GL;

const

  DEFAULT_SCL_MUL    =6/5;
  DEFAULT_SCL_MUL_INV=5/6;
  FULL_ROT           =pi/180;
  ONE_DIV_BY_FULL_ROT=1/FULL_ROT;
  MAX_SPRITE_WIDTH   =4096;
  MAX_SPRITE_HEIGHT  =4096;

type

  {Forward Declarations********************************************************}
  TFastActorSet     =class;
  TFastActor        =class;
  TFastImage        =class;
  TFastSpline       =class;
  {****************************************************************************}



  {Miscellaneous Types ********************************************************}
  {Direction Type}
  TMovingDirection  =(mdLeft,mdRight,mdUp,mdDown,mdLeftUp,mdRightUp,mdLeftDown,mdRightDown,mdNone);
  PMovingDirection  =^TMovingDirection;

  {Drawing Style}
  TDrawingStyle     =(dsMonochrome,dsAdditive,dsAlphablend,dsInverse,dsHighlight,dsDarken,dsGrayscaleR,dsGrayscaleG,dsGrayscaleB,dsMononoise);
  PDrawingStyle     =^TDrawingStyle;

  {Spline Type}
  TSplineType       =(stLinear,stBezier,stFormula,stPrimitives);
  PSplineType       =^TSplineType;

  {Spline Mode}
  TSplineMode       =(smContinuous,smDiscrete);
  PSplineMode       =^TSplineMode;

  {Selection}
  TSubgraphOp       =(soSub,soAdd);
  PSubgraphOp       =^TSubgraphOp;

  {Clipping}
  TClipStyle        =(csRemoveEdges,csClippedEdges1,csClippedEdges2,csAdvancedClip,csResilientEdges);
  PClipStyle        =^TClipStyle;

  {Blur}
  TBorderFilter     =(efNotTiled,efTiled);
  PBorderFilter     =^TBorderFilter;

  {SplineFormula}
  TSplineFormula    =(sfCycloid,sfEpicycloid,sfHypocycloid,sfRose,sfSpiral,sfSuperellipse);
  PSplineFormula    =^TSplineFormula;

  PByteBool         =^boolean;

  TParamType        =(ptLeft,ptTop);
  PParamType        =^TParamType;

  TSclDir           =(sdUp,sdDown);
  PSclDir           =^TSclDir;

  TColor            =-$7FFFFFFF-1..$7FFFFFFF;
  PColor            =^TColor;

  TEnum0            =0..3;
  PEnum0            =^TEnum0;

  TEnum1            =0..4;
  PEnum1            =^TEnum1;

  TEnum0Arr         =packed array of TEnum0;
  PEnum0Arr         =^TEnum0Arr;

  TEnum1Arr         =packed array of TEnum1;
  PEnum1Arr         =^TEnum1Arr;

  TEnum2Arr         =array[0..3] of integer;
  PEnum2Arr         =^TEnum2Arr;

  T1IntrArr         =array of integer;
  P1IntrArr         =^T1IntrArr;

  T1ByteArr         =array of byte;
  P1ByteArr         =^T1ByteArr;

  TFunc0Args        =packed record {$region -fold}
    r      :byte;
    g      :byte;
    b      :byte;
    alpha  :byte;
    d_alpha:byte;
    pow    :byte;
    d      :smallint;
  end; {$endregion}
  PFunc0Args        =^TFunc0Args;

  TObjSel           =packed record {$region -fold}
    // kind   of selected object(spline, sprite, etc.,...)
    obj_kind:integer;
    // number of selected object inside array of this kind
    obj_id  :integer;
  end; {$endregion}
  PObjSel           =^TObjSel;

  TPtRect           =packed record {$region -fold}
    left  : integer;
    top   : integer;
    width : integer;
    height: integer;
    right : integer;
    bottom: integer;
  end; {$endregion}
  PPtRect           =^TPtRect;

  TPtRectF          =packed record {$region -fold}
    left  : double;
    top   : double;
    width : double;
    height: double;
    right : double;
    bottom: double;
  end; {$endregion}
  PPtRectF          =^TPtRectF;

  TPtRectB          =packed record {$region -fold}
    pt_rct  : TPtRect;
    b_left  : boolean;
    b_top   : boolean;
    b_right : boolean;
    b_bottom: boolean;
  end; {$endregion}
  PPtRectB          =^TPtRectB;

  TPtPos            =packed record {$region -fold}
    x,y: integer;
  end; {$endregion}
  PPtPos            =^TPtPos;

  TPtPos2           =packed record {$region -fold}
    arr        : array[0..5] of word;
    obj_ind    : integer;
    dup_pts_cnt: integer;
    weight     : integer;
    class operator    =(r1,r2      :TPtPos2): boolean; inline; {$ifdef Linux}[local];{$endif}
    class operator    *(r1,r2      :TPtPos2): boolean; inline; {$ifdef Linux}[local];{$endif}
    procedure SetEqual0(var      r1:TPtPos2;
                        constref r2:TPtPos2);          inline; {$ifdef Linux}[local];{$endif}
    procedure SetEqual1(var      r1:TPtPos2;
                        constref r2:TPtPos2);          inline; {$ifdef Linux}[local];{$endif}
    procedure SetEqual2(var      r1:TPtPos2;
                        constref r2:TPtPos2);          inline; {$ifdef Linux}[local];{$endif}
    function  IsEqual  (         r1,
                                 r2:TPtPos2): boolean; inline; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PPtPos2           =^TPtPos2;

  TPtPosF           =packed record {$region -fold}
    x,y: double{single};
    class operator =(r1,r2:TPtPosF): boolean; inline; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PPtPosF           =^TPtPosF;

  TCrPos            =packed record {$region -fold}
    x,y,r: integer;
  end; {$endregion}
  PCrPos            =^TCrPos;

  TCrPosF           =packed record {$region -fold}
    x,y,r: double;
  end; {$endregion}
  PCrPosF           =^TCrPosF;

  TLnPos            =packed record {$region -fold}
    x0,y0,x1,y1: integer;
  end; {$endregion}
  PLnPos            =^TLnPos;

  TLnPosF           =packed record {$region -fold}
    x0,y0,x1,y1: double;
  end; {$endregion}
  PLnPosF           =^TLnPosF;

  TEdge             =packed record {$region -fold}
    first_point: integer;
    last_point : integer;
    obj_ind    : integer;
  end; {$endregion}
  PEdge             =^TEdge;

  TFX               =packed record {$region -fold}
    nt_value_proc_ind: byte;
    pt_value_proc_ind: byte;
    rep_cnt          : byte;
    {Type of Surface-------} {$region -fold}
    // [0..001]
    // 0 - nothing;
    // 1 - src. image;
    nt_pix_srf_type: byte;
    pt_pix_srf_type: byte; {$endregion}
    {Type of Color Effect--} {$region -fold}
    // [0..255]
    // 00 - monochrome;
    // 01 - additive;
    // 02 - alphablend;
    // 03 - inverse;
    // 04 - highlight;
    // 05 - darken;
    // 06 - grayscale r;
    // 07 - grayscale g;
    // 08 - grayscale b;
    // 09 - monochrome noise;
    // 10 - colorize r(minus);
    // 11 - colorize r(plus);
    // 12 - colorize g(minus)
    // 13 - colorize g(plus);
    // 14 - colorize b(minus)
    // 15 - colorize b(plus);
    nt_pix_cfx_type: byte;
    pt_pix_cfx_type: byte; {$endregion}
    {Type of Image Changing} {$region -fold}
    // [0..001]
    // 0 - constant;
    // 1 - fading;
    nt_pix_cng_type: byte;
    pt_pix_cng_type: byte; {$endregion}
  end; {$endregion}
  PFX               =^TFX;

  TByteDstFld       =packed record {$region -fold}
    v0,v1: byte
  end; {$endregion}
  PByteDstFld       =^TByteDstFld;

  TBckgdStngs       =packed record {$region -fold}
    // outer(clipping) rectangle:
    rct_clp       :TPtRect;
    // handle of drawing destination surface(background):
    bmp_dst_ptr   :PInteger;
    // width of drawing destination surface(background):
    bmp_dst_width :integer;
    // height of drawing destination surface(background):
    bmp_dst_height:integer;
  end; {$endregion}
  PBckgdStngs       =^TBckgdStngs;
  {****************************************************************************}



  {Anti-Aliasing **************************************************************}
  TFastAALine       =packed record {$region -fold}
    first_pt_x: integer;
    first_pt_y: integer;
    line_shift: integer;
    line_kind : byte;
    // 00 - horizontal line: 2 points from left to right;
    // 01 - horizontal line: 2 points from right to left;
    // 02 - horizontal line: outer line from ends to middle;
    // 03 - horizontal line: inner line from middle to ends;
    // 04 - horizontal line: const fill;

    // 05 - vertical   line: 2 points from top to bottom;
    // 06 - vertical   line: 2 points from bottom to top;
    // 07 - vertical   line: inner line from ends to middle;
    // 08 - vertical   line: outer line from middle to ends;
    // 09 - vertical   line: const fill;

    // 10 - 1 point;
  end; {$endregion}
  PFastAALine       =^TFastAALine;
  {****************************************************************************}



  {Miscellaneous Array Types **************************************************}
  TFastImageArr     =array of TFastImage;
  PFastImageArr     =^TFastImageArr;

  T1PictArr         =array of TPicture;
  P1PictArr         =^T1PictArr;

  T1AALnArr         =array of TFastAALine;
  P1AALnArr         =^T1AALnArr;

  T1ObjSelArr       =array of TObjSel;
  P1ObjSelArr       =^T1ObjSelArr;

  T1RectArr         =array of TRect;
  P1RectArr         =^T1RectArr;

  T1PtPosFArr       =array of TPtPosF;
  P1PtPosFArr       =^T1PtPosFArr;

  T1PtPosArr        =array of TPtPos;
  P1PtPosArr        =^T1PtPosArr;

  T1PtPos2Arr       =array of TPtPos2;
  P1PtPos2Arr       =^T1PtPos2Arr;

  T1EdgeArr         =array of TEdge;
  P1EdgeArr         =^T1EdgeArr;

  TRctValArr        =array[0..4] of integer;
  PRctValArr        =^TRctValArr;

  TFXArr            =array[byte] of TFX;
  PFXArr            =^TFXArr;

  T1Byte2Arr        =array[byte] of byte;
  P1Byte2Arr        =^T1Byte2Arr;

  TByteDstFldArr    =array of TByteDstFld;
  PByteDstFldArr    =^TByteDstFldArr;

  T2ByteArr         =array of array of byte;
  P2ByteArr         =^T2ByteArr;

  T1DublArr         =array of double;
  P1DublArr         =^T1DublArr;

  T1SmIntArr        =array of smallint;
  P1SmIntArr        =^T1SmIntArr;

  T1ShIntArr        =array of shortint;
  P1ShIntArr        =^T1ShIntArr;

  T1LWordArr        =array of longword;
  P1LWordArr        =^T1LWordArr;

  T1WordArr         =array of word;
  P1WordArr         =^T1WordArr;

  T1BoolArr         =array of boolean;
  P1BoolArr         =^T1BoolArr;
  {****************************************************************************}



  {Procedure Types ************************************************************}
  TProc0            =procedure of object;
  PProc0            =^TProc0;

  TProc1            =procedure(         index        :integer;
                                        image        :TCustomBitmap) of object;
  PProc1            =^TProc1;

  TProc2            =procedure(var      arr_dst      :T1IntrArr;
                               constref arr_dst_width:integer;
                               constref val          :integer) of object;
  PProc2            =^TProc2;

  TProc3            =procedure(constref x0,y0,x1,y1  :integer;
                               constref proc_ptr_a   :TProc0;
                               constref proc_ptr_b   :TProc0) of object;
  PProc3            =^TProc3;

  TProc4            =procedure(constref bmp_dst_ptr  :PInteger;
                               constref rct_dst      :TPtRect;
                               constref bmp_dst_width:integer);
  PProc4            =^TProc4;

  TProc5            =procedure(constref arr0         :T1ByteArr;
                               constref bmp_ptr      :PInteger;
                               constref bmp_width,
                                        bmp_height   :integer;
                               constref rct_dst      :TPtRect;
                               constref col          :TColor;
                               constref alpha        :byte=120);
  PProc5            =^TProc5;

  TProc6            =procedure(constref bmp_dst_ptr  :PInteger;
                               constref rct_dst      :TPtRect;
                               constref bmp_dst_width:integer);
  PProc6            =^TProc6;

  TProc7            =procedure(constref x,y          :integer) of object;
  PProc7            =^TProc7;

  TFunc0            =function (         pixel        :integer;
                               constref r            :byte    =0;
                               constref g            :byte    =0;
                               constref b            :byte    =0;
                               constref alpha        :byte    =0;
                               constref d_alpha      :byte    =255;
                               constref pow          :byte    =64;
                               constref d            :smallint=0): integer;
  PFunc0            =^TFunc0;

  TFunc1            =function (         pixel        :integer;
                               constref alpha_fade   :byte;
                               constref d            :smallint): integer;
  PFunc1            =^TFunc1;

  TFunc2            =function (         pixel        :integer;
                               constref r,g,b        :byte;
                                        alpha,d_alpha:byte;
                               constref alpha_fade   :byte;
                               constref pow          :byte;
                               constref d            :smallint): integer;
  PFunc2            =^TFunc2;
  {****************************************************************************}



  {Spline Properties(Attributes) **********************************************}
  TCurveProp        =packed record {$region -fold}
    // duplicated
    dup_pts_id            : TPtPos2;
    // global spline object index:
    curve_obj_ind         : integer;
    // spline points count:
    pts_cnt               : integer;
    //
    pts_cnt_val           : integer;
    //edges simplification angle:
    eds_smpl_angle        : single;
    //
    eds_col_ptr           : PColor;
    //edges  color:
    eds_col               : integer;
    //edges  color(inverted):
    eds_col_inv           : integer;
    //edges  color(random):
    eds_col_rnd           : boolean;
    //edges color(fall-off):
    eds_col_fall_off      : boolean;
    eds_col_fall_off_inc  : byte;
    //edges width:
    eds_width             : longword;
    //edges width half:
    eds_width_half        : longword;
    //edges width parity:
    eds_width_odd         : longword;
    //edges anti-aliasing:
    eds_aa                : boolean;
    //points color pointer:

    pts_col_ptr           : PInteger;
    //points color:
    pts_col               : integer;
    //points color(inverted):
    pts_col_inv           : integer;
    //points color(random):
    pts_col_rnd           : boolean;
    //points color(fall-off):
    pts_col_fall_off      : boolean;
    pts_col_fall_off_inc  : byte;

    //point width:
    pts_width             : longword;
    //point width  half:
    pts_width__half       : longword;
    //point width parity:
    pts_width__odd        : longword;
    //point height:
    pts_height            : longword;
    //point height half:
    pts_height_half       : longword;
    //point height parity:
    pts_height_odd        : longword;

    {Custom Point-Rectangle}
    rct_val_arr           : TRctValArr;
    //point rectangle width:
    pts_rct_width         : longword;
    //point rectangle width half:
    pts_rct_width__half   : longword;
    //point rectangle width parity:
    pts_rct_width__odd    : longword;
    //point rectangle height:
    pts_rct_height        : longword;
    //point rectangle height half:
    pts_rct_height_half   : longword;
    //point rectangle height parity:
    pts_rct_height_odd    : longword;
    //point rectangle thickness left:
    pts_rct_tns_left      : longword;
    //point rectangle thickness top:
    pts_rct_tns_top       : longword;
    //point rectangle thickness right:
    pts_rct_tns_right     : longword;
    //point rectangle thickness bottom:
    pts_rct_tns_bottom    : longword;
    //point rectangle inner width:
    pts_rct_inn_width     : longword;
    //point rectangle inner width parity:
    pts_rct_inn_width__odd: longword;
    //point rectangle inner height:
    pts_rct_inn_height    : longword;
    //point rectangle inner height parity:
    pts_rct_inn_height_odd: longword;

    {Custom Point-Circle}
    //point inner radius:
    pts_crc_diam_inn      : longword;
    //point inner radius half:
    pts_crc_diam_inn_half : longword;
    //point outer radius:
    pts_crc_diam_out      : longword;
    //point outer radius half:
    pts_crc_diam_out_half : longword;

    {Custom Point-Polygon}
    //point polygon width:
    pts_plg_diam          : longword;
    //point polygon width half:
    pts_plg_diam_half     : longword;
    //point polygon angles count:
    pts_plg_ang_cnt       : longword;

    {Custom Point-Sprite}
    //point sprite width:
    pts_srt_width         : longword;
    //point sprite height:
    pts_srt_height        : longword;

    //points drawing frequance:
    sln_pts_frq           : word;
    //spline type:
    sln_type              : TSplineType;
    //spline mode:
    sln_mode              : TSplineMode;
    //edges  blending:
    eds_bld_stl           : TDrawingStyle;
    //points blending:
    pts_bld_stl           : TDrawingStyle;
    //edges clipping:
    clp_stl               : TClipStyle;
    //edges level of details:
    eds_lod               : boolean;
    // hidden-line elimination:
    hid_ln_elim           : boolean;
    // lazy_repaint:
    lazy_repaint          : boolean;
    lazy_repaint_prev     : boolean;
    //edges bounding rectangle:
    rct_eds_show          : boolean;
    //points bounding rectangle:
    rct_pts_show          : boolean;
    //edges  visibility:
    eds_show              : boolean;
    //points visibility:
    pts_show              : boolean;
    //connect ends:
    cnc_ends              : boolean;
    //invert points indices order:
    pts_ord_inv           : boolean;
    // is object out of window:
    is_out_of_wnd         : boolean;

    // formula type:
    fml_type              : TSplineFormula;

    {Cycloid}
    // loop radius:
    cycloid_loop_rad      : double;
    // loops count:
    cycloid_loop_cnt      : integer;
    // points count:
    cycloid_pts_cnt       : integer;
    // curvature:
    cycloid_curvature     : double;
    // curve direction on axis x:
    cycloid_dir_x         : TMovingDirection;
    // curve direction on axis y:
    cycloid_dir_y         : TMovingDirection;

    {Epicycloid}
    // cut on angle:
    epicycloid_angle      : double;
    // rotation angle:
    epicycloid_rot        : double;
    // curve radius:
    epicycloid_rad        : integer;
    // petals count:
    epicycloid_petals_cnt : integer;
    // points count:
    epicycloid_pts_cnt    : integer;

    {Rose}

    {Spiral}

    {Superellipse}

  end; {$endregion}
  PCurveProp        =^TCurveProp;
  {****************************************************************************}



  {Color Information **********************************************************}
  TEquidistantCurve =packed record {$region -fold}
    pts     : T1IntrArr;

    //...
  end; {$endregion}
  PEquidistantCurve =^TEquidistantCurve;
  {****************************************************************************}



  {Color Information **********************************************************}
  TColorInfo        =packed record {$region -fold}
    pix_col : integer;
    r,g,b   : byte;
      alpha1: byte;
    d_alpha1: byte;
      alpha2: byte;
    d_alpha2: byte;
  end; {$endregion}
  PColorInfo        =^TColorInfo;
  {****************************************************************************}



  {Color Transform Information ************************************************}
  TColTransInfo     =packed record {$region -fold}
    // monochrome        value:
    monochrome_val       : integer;
    // red channel       value:
    r_val                : byte;
    // green channel     value:
    g_val                : byte;
    // blue channel      value:
    b_val                : byte;
    {// additive          value:
    additive_val         : byte;
    // alphablend        value:
    alpha_val,d_alpha_val: byte;
    // inverse           value:
    inverse_val          : byte;
    // highlight         value:
    highlight_val        : byte;
    // darken            value:
    darken_val           : byte;
    // grayscale r       value:
    grayscale_r_val      : byte;
    // grayscale g       value:
    grayscale_g_val      : byte;
    // grayscale b       value:
    grayscale_b_val      : byte;
    // noise             value:
    mononoise_val        : byte;
    // colorize r(minus) value:
    colorize_r_m_val     : byte;
    // colorize r(plus)  value:
    colorize_r_p_val     : byte;
    // colorize g(minus) value:
    colorize_g_m_val     : byte;
    // colorize g(plus)  value:
    colorize_g_p_val     : byte;
    // colorize b(minus) value:
    colorize_b_m_val     : byte;
    // colorize b(plus)  value:
    colorize_b_p_val     : byte;}
  end; {$endregion}
  PColTransInfo     =^TColTransInfo;

  TColTransInfo2    =packed record {$region -fold}
    // monochrome        value:
    monochrome_val       : integer;
    // red channel       value:
    r_val                : integer;
    // green channel     value:
    g_val                : integer;
    // blue channel      value:
    b_val                : integer;
    {// additive          value:
    additive_val         : integer;
    // alphablend        value:
    alpha_val,d_alpha_val: integer;
    // inverse           value:
    inverse_val          : integer;
    // highlight         value:
    highlight_val        : integer;
    // darken            value:
    darken_val           : integer;
    // grayscale r       value:
    grayscale_r_val      : integer;
    // grayscale g       value:
    grayscale_g_val      : integer;
    // grayscale b       value:
    grayscale_b_val      : integer;
    // noise             value:
    mononoise_val        : integer;
    // colorize r(minus) value:
    colorize_r_m_val     : integer;
    // colorize r(plus)  value:
    colorize_r_p_val     : integer;
    // colorize g(minus) value:
    colorize_g_m_val     : integer;
    // colorize g(plus)  value:
    colorize_g_p_val     : integer;
    // colorize b(minus) value:
    colorize_b_m_val     : integer;
    // colorize b(plus)  value:
    colorize_b_p_val     : integer;}
  end; {$endregion}
  PColTransInfo2    =^TColTransInfo2;
  {****************************************************************************}



  {Fast Actors Container ******************************************************}
  TFastActorSet     =class {$region -fold}
    // list of actors:
    act_arr       : array of TFastActor;
    // dummy icon:
    d_icon        : TFastImage;
    // array of actors positions:
    act_pos_arr   : T1PtPosFArr;
    // selection field:
    sel_fld       : T1IntrArr;
    sel_fld_ptr   : PInteger;
    // actors count:
    act_cnt       : longword;
    // first frame rect:
    first_frm_rect: TPtRect;
    // init. part:
    constructor Create(constref bckgd_ptr         :PInteger;
                       constref bckgd_width,
                                bckgd_height      :integer;
                       var      rct_clp           :TPtRect;
                       constref bmp_src_rct       :TPtRect;
                       constref location          :string='';
                       constref ImgLstGetBmp      :TProc1=Nil;
                       constref d_icon_img_lst_ind:integer=0); {$ifdef Linux}[local];{$endif}
    destructor  Destroy;                             override; {$ifdef Linux}[local];{$endif}
    // add actor;
    procedure AddActor(x,y                        :integer);   {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PFastActorSet     =^TFastActorSet;
  {****************************************************************************}



  {Fast Image Container *******************************************************}
  TFastActorInstInfo=packed record {$region -fold}
    frm_ind         : integer;
    bmp_ftimg_left  : integer;
    bmp_ftimg_top   : integer;
    bmp_ftimg_right : integer;
    bmp_ftimg_bottom: integer;
    col_trans_var   : TColTransInfo;
    fx_arr          : TFXArr;
    fx_cnt          : byte;
    {Type of Image Drawing-------} {$region -fold}
    // 0 - color;
    // 1 - value;
    // 2 - color
    // and value;
    pix_drw_type    : byte; {$endregion}
    {Type of Surface-------------} {$region -fold}
    // 0 - nothing;
    // 1 - src. image;
    // 2 - dst. background;
    nt_pix_srf_type : byte;
    pt_pix_srf_type : byte; {$endregion}
    {Type of Color Effect--------} {$region -fold}
    // 0 - monochrome;
    // 1 - additive;
    // 2 - alphablend;
    nt_pix_cfx_type : byte;
    pt_pix_cfx_type : byte; {$endregion}
    {Type of Image Clipping------} {$region -fold}
    // 0 - not clippped;
    // 1 - top-bottom clippped;
    // 2 - left-right-top-bottom clippped;
    nt_pix_clp_type : byte;
    pt_pix_clp_type : byte; {$endregion}
    {Type of Image Changing------} {$region -fold}
    // 0 - constant;
    // 1 - fading;
    nt_pix_cng_type : byte;
    pt_pix_cng_type : byte; {$endregion}
  end; {$endregion}
  PFastActorInstInfo=^TFastActorInstInfo;

  TFastActor        =class {$region -fold}
    // list of frames
    frm_arr      : array of TFastImage;
    // list of instances:
    act_inst_arr : array of array of TFastActorInstInfo;
    // list of paths for actor:
    path_ind_arr : T1IntrArr;
    //
    src_img_color: TBitmap;
    // frames count;
    frm_cnt      : longword;
    constructor Create;              {$ifdef Linux}[local];{$endif}
    destructor  Destroy; override;   {$ifdef Linux}[local];{$endif}
    {Turn One Image          Into Frames}
    //procedure ImgToFrames;           {$ifdef Linux}[local];{$endif}
    {Turn     Image Sequance Into Frames}
    //procedure SqcToFrames;           {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PFastActor        =^TFastActor;
  {****************************************************************************}



  {Fast Image *****************************************************************}
  PFastImage        =^TFastImage;
  TFastImage        =class {$region -fold}

    type
      TRenderType=(rtDynamic,rtStatic);

    {Proc. Table-----------------} {$region -fold}
    public
      var
        // Image Compression:
        CmpProc               : array[0..012] of TProc0;

        // Image Drawing:
        // NT - not transparent pixels:
        NTValueProc           : array[0..255] of TProc0;
        NTColorProc           : array[0..029] of TProc0;
        NTBeginProc           : array[0..002] of TProc0;
        nt_pix_intr_arr_ptr   : PInteger;
        // PT - partly transparent pixels:
        PTValueProc           : array[0..255] of TProc0;
        PTColorProc           : array[0..029] of TProc0;
        PTBeginProc           : array[0..002] of TProc0;
        pt_pix_intr_arr_ptr   : PInteger;

        // Proc.Indices:
        // NT - not transparent pixels:
        nt_begin_proc_ind     : byte;
        nt_color_proc_ind     : byte;
        nt_value_proc_ind     : byte;
        // PT - partly transparent pixels:
        pt_begin_proc_ind     : byte;
        pt_color_proc_ind     : byte;
        pt_value_proc_ind     : byte;

        // Shader Type Proc. Table:
        SdrType               : array[0..038] of TProc0;
        sdr_type_ind          : byte;

        // Shader Uber Proc. Table:
        SdrProc               : array[0..003] of TProc0;
        sdr_proc_ind          : byte; {$endregion}

    {Color Info------------------} {$region -fold}
    public
      var
        col_trans_var         : TColTransInfo;
        col_trans_arr         : T1Byte2Arr; {$endregion}

    {Color/Alpha of Current Layer} {$region -fold}
    {protected} public
      var
        // NT - not transparent pixels:
        nt_pix_intr_ccl_arr   : T1IntrArr;

        // PT - partly transparent pixels:
        // color channel:
        pt_pix_intr_ccl_arr   : T1IntrArr;
        // alpha channel:
        pt_pix_byte_acl_arr   : T1ByteArr; {$endregion}

    {Color       of Lower   Layer} {$region -fold}
    {protected} public
      var
        // NT - not transparent pixels:
        nt_pix_intr_cll_arr   : T1IntrArr;

        // PT - partly transparent pixels:
        pt_pix_intr_cll_arr   : T1IntrArr; {$endregion}

    {Value       of Current Layer} {$region -fold}
    {protected} public
      var
        // NT - not transparent pixels:
        nt_pix_intr_val_arr   : T1IntrArr;

        // PT - partly transparent pixels; reserved:
        pt_pix_intr_val_arr   : T1IntrArr; {$endregion}

    {Counts of Items in Rows-----} {$region -fold}
    {protected} public
      var
        // NT - not transparent pixels:
        nt_pix_intr_cnt_arr   : T1LWordArr;

        // PT - partly transparent pixels:
        pt_pix_intr_cnt_arr   : T1LWordArr; {$endregion}

    {Items Shifts----------------} {$region -fold}
    {protected} public
      var
        // NT - not transparent pixels:
        nt_pix_intr_sht_arr   : T1IntrArr;

        // PT - partly transparent pixels:
        pt_pix_intr_sht_arr   : T1IntrArr; {$endregion}

    {Image Kind------------------} {$region -fold}
    public
      var
        img_kind              : byte;
        {
        ----------------Image Has Alpha Channel And Color Channel---------------
        0:
        image has:  not monochrome alpha channel,
                    not monochrome color channel,
        count of    not transparent pixels>0;
        count of partly transparent pixels>0;

        1:
        image has:  not monochrome alpha channel,
                    not monochrome color channel,
        count of    not transparent pixels>0;
        count of partly transparent pixels=0;

        2:
        image has:  not monochrome alpha channel,
                    not monochrome color channel,
        count of    not transparent pixels=0;
        count of partly transparent pixels>0;

        3:
        image has:      monochrome alpha channel(white, not transparent),
                    not monochrome color channel,
        count of    not transparent pixels>0;
        count of partly transparent pixels=0;

        4:
        image has:      monochrome alpha channel(transparent),
                    not monochrome color channel,
        count of    not transparent pixels=0;
        count of partly transparent pixels>0;


        ----------------------Image Has Only Alpha Channel----------------------
        5:
        image has:  not monochrome alpha channel,
                                no color channel,
        count of    not transparent pixels>0;
        count of partly transparent pixels>0;

        6:
        image has:  not monochrome alpha channel,
                                no color channel,
        count of    not transparent pixels>0;
        count of partly transparent pixels=0;

        7:
        image has:  not monochrome alpha channel,
                                no color channel,
        count of    not transparent pixels=0;
        count of partly transparent pixels>0;

        8:
        image has:      monochrome alpha channel(white, not transparent),
                                no color channel,
        count of    not transparent pixels>0;
        count of partly transparent pixels=0;

        9:
        image has:      monochrome alpha channel(transparent),
                                no color channel,
        count of    not transparent pixels=0;
        count of partly transparent pixels>0;


        --------------Image Has No Alpha Channel And Color Channel--------------
        10:
        image has:      no alpha channel(black, invisible),
                        no color channel,
        count of    not transparent pixels=0;
        count of partly transparent pixels=0;

        --------------------------Image is Value Array--------------------------
        11:
        count of    not transparent pixels>0;
        count of partly transparent pixels>0;

        ------------------------------Image is Mask-----------------------------
        12:
        count of    not transparent pixels>0;
        count of partly transparent pixels=0;
        } {$endregion}

    {Image Metrics---------------} {$region -fold}
    public
      var
        //
        bmp_src_rct_clp        : TPtRect;
        // pointer to background image(where all sprites are drawn):
        bmp_bckgd_ptr          : PInteger;
        // background image width:
        bmp_bckgd_width        : integer;
        // background image height:
        bmp_bckgd_height       : integer;
        //
        bmp_color_ptr          : PInteger;
        //
        bmp_alpha_ptr          : PInteger;
        //
        bmp_value_ptr          : PInteger;
        //
        bmp_ftimg_width_origin : integer;
        bmp_ftimg_width        : integer;
        //
        bmp_ftimg_height_origin: integer;
        bmp_ftimg_height       : integer;
        //
        bmp_ftimg_left         : integer;
        //
        bmp_ftimg_top          : integer;
        //
        bmp_ftimg_right        : integer;
        //
        bmp_ftimg_bottom       : integer;
        //
        nt_pix_arr_row_mrg_top : longword;
        //
        nt_pix_arr_row_mrg_btm : longword;
        //
        pt_pix_arr_row_mrg_top : longword;
        //
        pt_pix_arr_row_mrg_btm : longword;
        //
        width_parity           : boolean;
        //
        height_parity          : boolean;
        //
        mask_template_calc     : boolean;
        //
        render_type            : TRenderType; {$endregion}

    {Image Clipping--------------} {$region -fold}
    public
      var
        {Precalculated Table of Counts Vertically(Image Clipping)}
        // NT - not transparent pixels:
        nt_cnt_ind_arr        : T1IntrArr;
        // PT - partly transparent pixels:  array
        pt_cnt_ind_arr        : T1IntrArr;
        //
        rct_clp_ptr           : PPtRect;
        //
        rct_src               : TPtRect;
        //
        rct_dst               : TPtRectB;
        //
        arr_src_sht           : integer;
        //
        rct_clp_mrg           : integer; {$endregion}

    {Post-Processing-------------} {$region -fold}
    public
      var
        // effects param.s array:
        fx_arr                : TFXArr;
        // count of effects:
        fx_cnt                : byte; {$endregion}

    {Tiles Copying---------------} {$region -fold}
    public
      var
        // array of tiles bounding rectangles inside one bitmap:
        rect_src_arr          : array of TPtRect;
        // tiles count:
        tiles_cnt             : longword; {$endregion}

    {Total Count of Pixels-------} {$region -fold}
    public{protected}
      var
        // all pixels:
        al_pix_cnt            : longword;
        // not    transparent pixels count:
        nt_pix_cnt            : longword;
        // partly transparent pixels count:
        pt_pix_cnt            : longword;
        // count of zero(black) color pixels:
        zr_pix_cnt            : integer;
        // count of pixels which are equal to first pixel:
        pt_pix_cng_cnt        : integer; {$endregion}

    {Type of Image Drawing-------} {$region -fold}
    public
      var
        // 0 - color:
        // 1 - value:
        // 2 - color
        // and value:
        pix_drw_type          : byte; {$endregion}

    {Type of Surface-------------} {$region -fold}
    public
      var
        // 0 - nothing;
        // 1 - src. image;
        // 2 - dst. background;
        nt_pix_srf_type       : byte;
        pt_pix_srf_type       : byte; {$endregion}

    {Type of Color Effect--------} {$region -fold}
    public
      var
        // 0 - Monochrome;
        // 1 - Additive;
        // 2 - Alphablend;
        // 3 - Inverse;
        // 4 - Highlight;
        // 5 - Darken;
        // 6 - GrayscaleR;
        // 7 - GrayscaleG;
        // 8 - GrayscaleB;
        // 9 - Monochrome Noise;
        nt_pix_cfx_type       : byte;
        pt_pix_cfx_type       : byte; {$endregion}

    {Type of Image Clipping------} {$region -fold}
    public
      var

        // Clipping Proc. Table:
        NTUselessProc         : array[0..002] of TProc2;
        PTUselessProc         : array[0..002] of TProc2;

        // 0 - not clippped;
        // 1 - top-bottom clippped;
        // 2 - left-right-top-bottom clippped;
        nt_pix_clp_type       : byte;
        pt_pix_clp_type       : byte; {$endregion}

    {Type of Image Changing------} {$region -fold}
    public
      var
        // 0 - constant;
        // 1 - fading;
        nt_pix_cng_type       : byte;
        pt_pix_cng_type       : byte; {$endregion}

    {Type of Image Processing----} {$region -fold}
    public
      var
        // 0 - not to draw image(exclude shader);
        // 1 -        draw image(include shader);
        nt_useless            : byte;
        pt_useless            : byte; {$endregion}

    {Mask Template---------------} {$region -fold}
    public
      var
        //width and height of sprite at mask:
        tilemap_sprite_ptr    : PFastImage;
        //width and height of sprite at mask:
        tilemap_sprite_w_h    : TPtPos; {$endregion}

    {Image Processing------------} {$region -fold}

    {Clear Arrays-----------------------------------------} {$region -fold}
    procedure ClrArr(arr_clear_val:word); inline; {$ifdef Linux}[local];{$endif} {$endregion}

    {Define Image Kind------------------------------------} {$region -fold}
    procedure DetImageKind; {$ifdef Linux}[local];{$endif} {$endregion}

    {Create Array    of Items Counts  in Rows from Bitmap-} {$region -fold}
    //** color and alpha are in separate bitmaps
    // NT - not transparent pixels:
    procedure CrtNTCountBmpS; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure CrtPTCountBmpS; {$ifdef Linux}[local];{$endif}
    //** color and alpha are in one bitmap
    // NT - not transparent pixels:
    procedure CrtNTCountBmpO; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure CrtPTCountBmpO; {$ifdef Linux}[local];{$endif} {$endregion}

    {Create Array    of Items Counts  in Rows from Array--} {$region -fold}
    // NT - not transparent pixels:
    procedure CrtNTCountArrA; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure CrtPTCountArrA; {$ifdef Linux}[local];{$endif} {$endregion}

    {Create Array    of Items Shifts  in Rows from Bitmap-} {$region -fold}
    //** color and alpha are in separate bitmaps
    // NT - not transparent pixels:
    procedure CrtNTShiftBmpS; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure CrtPTShiftBmpS; {$ifdef Linux}[local];{$endif}
    //** color and alpha are in one bitmap
    // NT - not transparent pixels:
    procedure CrtNTShiftBmpO; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure CrtPTShiftBmpO; {$ifdef Linux}[local];{$endif} {$endregion}

    {Create Array    of Items Shifts  in Rows from Array--} {$region -fold}
    // NT - not transparent pixels:
    procedure CrtNTShiftArrA; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure CrtPTShiftArrA; {$ifdef Linux}[local];{$endif} {$endregion}

    {Store Color     of Current Layer         from Bmp/Arr} {$region -fold}
    // NT - not transparent pixels:
    {store color channel}
    procedure StrNTColorBmpA; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    {store color channel}
    procedure StrPTColorBmpA; {$ifdef Linux}[local];{$endif}
    //** color and alpha are in separate bitmaps
    {store alpha channel into byte array---}
    procedure StrPTAlphaArrS; {$ifdef Linux}[local];{$endif}
    {store alpha channel into color channel}
    procedure StrPTAlphaBmpS; {$ifdef Linux}[local];{$endif}
    //** color and alpha are in one bitmap
    {store alpha channel into byte array---}
    procedure StrPTAlphaArrO; {$ifdef Linux}[local];{$endif}
    {store alpha channel into color channel}
    procedure StrPTAlphaBmpO; {$ifdef Linux}[local];{$endif} {$endregion}

    {Store Color     of Lower   Layer         from Bitmap-} {$region -fold}
    // NT - not transparent pixels:
    procedure StrNTLowerBmpA; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure StrPTLowerBmpA; {$ifdef Linux}[local];{$endif}
    // store alpha from byte array:
    procedure StrPTLowerArrA; {$ifdef Linux}[local];{$endif} {$endregion}

    {Store Value     of Current Layer         from Array--} {$region -fold}
    procedure StrNTValueArrA; {$ifdef Linux}[local];{$endif} {$endregion}

    {Set Chess Order of Alpha Channel in Rows from Bitmap-} {$region -fold}
    // calculation of image sides parity
    procedure CalcSidesParity; {$ifdef Linux}[local];{$endif}
    // color and alpha are in separate bitmaps
    // NT - not transparent pixels:
    procedure SetNTChessBmpS0; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure SetPTChessBmpS0; {$ifdef Linux}[local];{$endif}
    // color and alpha are in one bitmap
    // NT - not transparent pixels:
    procedure SetNTChessBmpO0; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure SetPTChessBmpO0; {$ifdef Linux}[local];{$endif} {$endregion}

    {Create Array of Tiles Bounding Rectangles------------} {$region -fold}
    procedure CrtRectArr; inline; {$ifdef Linux}[local];{$endif} {$endregion}

    {Full Image Compression-------------------------------} {$region -fold}
    // img. kind: 000:
    procedure CmpProc000;  inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 001:
    procedure CmpProc001;  inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 002:
    procedure CmpProc002;  inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 003:
    procedure CmpProc003;  inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 004:
    procedure CmpProc004;  inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 005:
    procedure CmpProc005;  inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 006:
    procedure CmpProc006;  inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 007:
    procedure CmpProc007;  inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 008:
    procedure CmpProc008;  inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 009:
    procedure CmpProc009;  inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 010:
    procedure CmpProc010;  inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 011:
    procedure CmpProc011;  inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 012:
    procedure CmpProc012;  inline; {$ifdef Linux}[local];{$endif}

    procedure CmpProcInit; inline; {$ifdef Linux}[local];{$endif}
    procedure ImgToCImg;   inline; {$ifdef Linux}[local];{$endif} {$endregion}

    {Fill Transparent Image on Background-----------------} {$region -fold}

    // NT - not transparent pixels:

    // not clippped:
    procedure FilNTProc0_0(constref args:TFunc0Args; Func0:TFunc0); {$ifdef Linux}[local];{$endif}
    // top-bottom clippped:
    procedure FilNTProc0_2(constref args:TFunc0Args; Func0:TFunc0); {$ifdef Linux}[local];{$endif}
    // left-right-top-bottom clippped:
    procedure FilNTProc0_4(constref args:TFunc0Args; Func0:TFunc0); {$ifdef Linux}[local];{$endif}

    {Empty}
    procedure FilNTValue009; {$ifdef Linux}[local];{$endif}
    {Empty}
    procedure FilNTColor009; {$ifdef Linux}[local];{$endif}

    {Monochrome}
    // (constant) not clipped:
    procedure FilNTValue000; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue002; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue004; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue006; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Additive}
    // (constant) not clipped:
    procedure FilNTValue010; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue012; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue014; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue016; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilNTValue011; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilNTValue013; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilNTValue015; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure FilNTValue017; {$ifdef Linux}[local];{$endif}

    {Alphablend}
    // (constant) not clipped:
    procedure FilNTValue020; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue022; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue024; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue026; {$ifdef Linux}[local];{$endif}
    // (fading)
    //same;

    {Inverse}
    // (constant) not clipped:
    procedure FilNTValue030; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue032; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue034; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue036; {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure FilNTValue031; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilNTValue033; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilNTValue035; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure FilNTValue037; {$ifdef Linux}[local];{$endif}

    {Highlight}
    // (constant) not clipped:
    procedure FilNTValue040; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue042; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue044; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue046; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Darken}
    // (constant) not clipped:
    procedure FilNTValue050; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue052; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue054; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue056; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleR}
    // (constant) not clipped:
    procedure FilNTValue060; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue062; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue064; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue066; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilNTValue061; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilNTValue063; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilNTValue065; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure FilNTValue067; {$ifdef Linux}[local];{$endif}

    {GrayscaleG}
    // (constant) not clipped:
    procedure FilNTValue070; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue072; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue074; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue076; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilNTValue071; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilNTValue073; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilNTValue075; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure FilNTValue077; {$ifdef Linux}[local];{$endif}

    {GrayscaleB}
    // (constant) not clipped:
    procedure FilNTValue080; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue082; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue084; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue086; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilNTValue081; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilNTValue083; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilNTValue085; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure FilNTValue087; {$ifdef Linux}[local];{$endif}

    {Monochrome Noise}
    // (constant) not clipped:
    procedure FilNTValue090; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue092; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue094; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue096; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilNTValue091; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilNTValue093; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilNTValue095; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure FilNTValue097; {$ifdef Linux}[local];{$endif}

    {Color of Curent Layer}
    // (constant) not clipped:
    procedure FilNTColor000; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTColor002; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTColor004; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTColor006; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Color of Curent Layer(Additive)}
    // (constant) not clipped:
    procedure FilNTColor010; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTColor012; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTColor014; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTColor016; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilNTColor011; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilNTColor013; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilNTColor015; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure FilNTColor017; {$ifdef Linux}[local];{$endif}

    {Color of Curent Layer(AlphaBlend)}
    // (constant) not clipped:
    procedure FilNTColor020; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTColor022; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTColor024; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTColor026; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    // PT - partly transparent pixels;

    {Empty}
    procedure FilPTValue009; {$ifdef Linux}[local];{$endif}
    {Empty}
    procedure FilPTColor009; {$ifdef Linux}[local];{$endif}

    {Monochrome}
    // (constant) not clipped:
    procedure FilPTValue000; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue002; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped :
    procedure FilPTValue004; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Additive}
    // (constant) not clipped:
    procedure FilPTValue010; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue012; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue014; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilPTValue011; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilPTValue013; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilPTValue015; {$ifdef Linux}[local];{$endif}

    {Alphablend}
    // (constant) not clipped:
    procedure FilPTValue020; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue022; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue024; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Inverse}
    // (constant) not clipped:
    procedure FilPTValue030; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue032; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue034; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilPTValue031; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilPTValue033; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilPTValue035; {$ifdef Linux}[local];{$endif}

    {Highlight}
    // (constant) not clipped:
    procedure FilPTValue040; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue042; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue044; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Darken}
    // (constant) not clipped:
    procedure FilPTValue050; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue052; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue054; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleR}
    // (constant) not clipped:
    procedure FilPTValue060; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue062; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue064; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilPTValue061; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilPTValue063; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilPTValue065; {$ifdef Linux}[local];{$endif}

    {GrayscaleG}
    // (constant) not clipped:
    procedure FilPTValue070; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue072; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue074; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilPTValue071; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilPTValue073; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilPTValue075; {$ifdef Linux}[local];{$endif}

    {GrayscaleB}
    // (constant) not clipped:
    procedure FilPTValue080; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue082; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue084; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilPTValue081; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilPTValue083; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilPTValue085; {$ifdef Linux}[local];{$endif}

    {Monochrome Noise}
    // (constant) not clipped:
    procedure FilPTValue090; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue092; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue094; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilPTValue091; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilPTValue093; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilPTValue095; {$ifdef Linux}[local];{$endif}

    {Color of Curent Layer}
    // (constant) not clipped:
    procedure FilPTColor000; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTColor002; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTColor004; {$ifdef Linux}[local];{$endif}
    // (constant) image has transparent alpha channel:
    procedure FilPTColor006; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Color of Curent Layer(Additive)}
    // (constant) not clipped:
    procedure FilPTColor010; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTColor012; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTColor014; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilPTColor016; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilPTColor011; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilPTColor013; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilPTColor015; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    // same as (constant);

    {Color of Curent Layer(AlphaBlend)}
    // (constant) not clipped:
    procedure FilPTColor020; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTColor022; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTColor024; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Fill Array at Specified Rectangle with Specified Value}
    procedure FilNTValueArr(var      arr_src         :T1IntrArr;
                            constref bmp_ftimg_width_:integer;
                            constref val             :integer=0); {$ifdef Linux}[local];{$endif}

    {Restore Source Image from Compressed Image}
    procedure ResNTValueArr(var      arr_src         :T1IntrArr;
                            constref bmp_ftimg_width_:integer);   {$ifdef Linux}[local];{$endif}

    // NT - not transparent pixels:
    procedure SetNTNilToPtr; {$ifdef Linux}[local];{$endif}
    procedure SetNTCCLToPtr; {$ifdef Linux}[local];{$endif}
    procedure SetNTCLLToPtr; {$ifdef Linux}[local];{$endif}

    // PT - partly transparent pixels:
    procedure SetPTNilToPtr; {$ifdef Linux}[local];{$endif}
    procedure SetPTCCLToPtr; {$ifdef Linux}[local];{$endif}
    procedure SetPTCLLToPtr; {$ifdef Linux}[local];{$endif}

    // Procedures Table Init.:
    procedure FilProcInit; {$ifdef Linux}[local];{$endif}

    // Table of Counts Vertically Init.(Image Clipping):
    procedure CrtNTCntIndArr; {$ifdef Linux}[local];{$endif}
    procedure CrtPTCntIndArr; {$ifdef Linux}[local];{$endif}

    // Mask Template Drawing:
    // Fill Mask With Random Color:
    procedure FilMaskTemplate0; {$ifdef Linux}[local];{$endif}
    // Fill Mask With Specified Sprite:
    procedure FilMaskTemplate1; {$ifdef Linux}[local];{$endif}

    // Full Image Drawing:
    procedure ShaderInfo;  inline; {$ifdef Linux}[local];{$endif}
    procedure SetSdrType;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrTypeInit; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType000;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType001;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType002;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType003;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType004;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType005;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType006;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType007;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType008;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType009;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType010;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType011;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType012;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType013;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType014;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType015;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType016;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType017;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType018;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType019;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType020;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType021;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType022;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType023;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType024;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType025;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType026;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType027;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType028;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType029;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType030;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType031;  inline; {$ifdef Linux}[local];{$endif}
    procedure ShaderType;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrProcInit; inline; {$ifdef Linux}[local];{$endif}
    procedure UberShader0; inline; {$ifdef Linux}[local];{$endif}
    procedure UberShader1; inline; {$ifdef Linux}[local];{$endif}
    procedure UberShader2; inline; {$ifdef Linux}[local];{$endif}
    procedure UberShader3; inline; {$ifdef Linux}[local];{$endif}

    // Clear Background from Image:
    procedure ClrBkgnd; inline; {$ifdef Linux}[local];{$endif} {$endregion}

    {Create Border Around the Image-----------------------} {$region -fold}
    procedure CrtBorderBmp   (constref arr_src      :T1IntrArr;
                              var arr_dst           :T1ObjSelArr;
                              constref arr_src_width,
                                       arr_dst_width:integer;
                              constref rect_left,
                                       rect_top,
                                       rect_width,
                                       rect_height  :longword;
                              var brdr_pix_cnt      :integer;
                              constref obj_kind,
                                       obj_id       :integer); {$ifdef Linux}[local];{$endif}  {$endregion} {$endregion}

    {Image Clipping--------------} {$region -fold}
    procedure UlsProcInit;                                        {$ifdef Linux}[local];{$endif}
    procedure NTUseless0(var      arr_dst      :T1IntrArr;
                         constref arr_dst_width:integer;
                         constref val          :integer);         {$ifdef Linux}[local];{$endif}
    procedure NTUseless1(var      arr_dst      :T1IntrArr;
                         constref arr_dst_width:integer;
                         constref val          :integer);         {$ifdef Linux}[local];{$endif}
    procedure NTUseless2(var      arr_dst      :T1IntrArr;
                         constref arr_dst_width:integer;
                         constref val          :integer);         {$ifdef Linux}[local];{$endif}
    procedure PTUseless0(var      arr_dst      :T1IntrArr;
                         constref arr_dst_width:integer;
                         constref val          :integer);         {$ifdef Linux}[local];{$endif}
    procedure PTUseless1(var      arr_dst      :T1IntrArr;
                         constref arr_dst_width:integer;
                         constref val          :integer);         {$ifdef Linux}[local];{$endif}
    procedure PTUseless2(var      arr_dst      :T1IntrArr;
                         constref arr_dst_width:integer;
                         constref val          :integer);         {$ifdef Linux}[local];{$endif}
    function  Useless: byte;                              inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctPos (         rct          :TPtRect); inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctPos (         x,y,w,h      :integer); inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctPos (         x,y          :integer); inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctPos (         pvt          :TPtPosF); inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctDst;                                  inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctSrc;                                  inline; {$ifdef Linux}[local];{$endif} {$endregion}

    {Init. Part------------------} {$region -fold}
    constructor Create  (constref bckgd_ptr     :PInteger;
                         constref bckgd_width,
                                  bckgd_height  :integer;
                         var      rct_clp       :TPtRect;
                         constref bmp_src_rct   :TPtRect;
                         constref empty         :integer=0);                 {$ifdef Linux}[local];{$endif}
    constructor Create  (constref bckgd_ptr     :PInteger;
                         constref bckgd_width,
                                  bckgd_height  :integer;
                         var      rct_clp       :TPtRect;
                         constref bmp_src_rct   :TPtRect;
                         constref location      :string  ='';
                         constref ImgLstGetBmp  :TProc1  =Nil;
                         constref img_ind       :integer =0;
                         constref mask_tpl_calc :boolean =False;
                         constref pic_src       :TPicture=Nil);              {$ifdef Linux}[local];{$endif}
    destructor  Destroy; override;                                           {$ifdef Linux}[local];{$endif}
    procedure SetBckgd  (constref bckgd_ptr     :PInteger;
                         constref bckgd_width,
                                  bckgd_height  :integer);           inline; {$ifdef Linux}[local];{$endif}
    procedure SetClpRct (constref rct_clp       :TPtRect);           inline; {$ifdef Linux}[local];{$endif}
    procedure SetValInfo(constref bmp_color_ptr_,
                                  bmp_alpha_ptr_,
                                  bmp_value_ptr_:PInteger;
                         constref ftimg_width,
                                  ftimg_height  :integer);           inline; {$ifdef Linux}[local];{$endif}
    procedure SetPPInfo (         val           :integer=$00434D3E); inline; {$ifdef Linux}[local];{$endif}
    procedure SrcDestroy(         bmp_src       :TPicture         ); inline; {$ifdef Linux}[local];{$endif}
    procedure SrcDestroy(         bmp_src       :TBitmap          ); inline; {$ifdef Linux}[local];{$endif}
    procedure SrcDestroy(         arr_src       :T1IntrArr        ); inline; {$ifdef Linux}[local];{$endif}
    procedure SrcDestroy(         arr_src       :T1LWordArr       ); inline; {$ifdef Linux}[local];{$endif}
    procedure SrcDestroy(         arr_src       :T1WordArr        ); inline; {$ifdef Linux}[local];{$endif}
    procedure SrcDestroy(         arr_src       :T1ByteArr        ); inline; {$ifdef Linux}[local];{$endif} {$endregion}

  end; {$endregion}
  {****************************************************************************}



  {Fast Spline ****************************************************************}
  TFastSpline       =class {$region -fold}

    {Misc. Types------------------------------------} {$region -fold}
    type
      TGCDGrid={type} packed record
        f_ln_kind,a,b,c,d: integer;
      end;
      TGCDArr =array of TGCDGrid; {$endregion}

    {State Machine for Line Drawing Routines--------} {$region -fold}
    protected
      var
        LineProc: array[0..39] of TProc0; {$endregion}

    {Edges and Points Pixels Buffers----------------} {$region -fold}
    public
      var
        {spline sprite}
        fst_img              : TFastImage;

        {static edges buffer : for "vertical"   lines}
        ln_arr2              : T2ByteArr;

        {static edges buffer : for "regular"    lines}
        ln_arr1              : T1IntrArr;

        {static edges buffer : for "horizontal" lines}
        ln_arr0              : T1ByteArr;

        {destination bitmap(background)}
        bmp_dst_ptr          : PInteger;
        bmp_dst_width        : integer;
        bmp_dst_height       : integer;

        {source array}
        ln_arr1_ptr          : PInteger;
        ln_arr0_ptr          : PByte;
        ln_arr_width         : integer;
        ln_arr_height        : integer;

        {line kind pointer}
        ln_kind_ptr          : PInteger; {$endregion}

    {Misc. Variables: Line Drawing------------------} {$region -fold}
    protected
      var
        dx,dy,a,b,c,m1,m2: integer;
        r0,p0,r1,p1,g    : integer; {$endregion}

    {Hidden-Pixel Elimination-----------------------} {$region -fold}
    public
     {is line visible array:
      0 - line is invisible;
      1 - line is   visible}
      useless_arr: T1ByteArr;
     {hidden lines count}
      hid_ln_cnt : integer; {$endregion}

    {Misc. Variables: Clipping----------------------} {$region -fold}
    public
      ln_pos    : TLnPos;
      color_info: TColorInfo;
      pix_cnt   : integer; {$endregion}

    {Resilient Line---------------------------------} {$region -fold}
    res_ln_pts_cnt: T1IntrArr; {$endregion}

    {Precalculated Table of Greatest Common Divisors} {$region -fold}
    public
      {class} var
        {array of greatest common divisors}
        gcd_arr    : TGCDArr;
        {precision of calculation}
        grid_pt_rad: integer; {$endregion}

    {Spline Local Properties------------------------} {$region -fold}
    public
      var
        local_prop: TCurveProp; {$endregion}

    {Bounding Rectangles of Spline Object-----------} {$region -fold}
    public
      var
        {spline entire rectangle}
        rct_ent: TRect;
        {spline visible(clipped by inner window) rectangle}
        rct_vis: TRect;
        {spline window(inner window) rectangle}
        rct_wnd: TRect; {$endregion}

    {Post-Processing--------------------------------} {$region -fold}
    args             : TFunc0Args;
    pp_dec_2_proc_ind: byte; {$endregion}

    {Edge Anti-Aliasing-----------------------------} {$region -fold}
    public
      var
        {alpha border of anti-aliased spline}
        aa_arr2              : T1AALnArr;
        {alpha border of anti-aliased spline}
        aa_arr1              : T1ByteArr;
        {antialiased lines count}
        aa_line_count        : integer;
        aa_nz_arr_items_count: integer; {$endregion}

    {Misc. Routines---------------------------------} {$region -fold}
    public
      constructor Create;                                                           {$ifdef Linux}[local];{$endif}
      destructor  Destroy; override;                                                {$ifdef Linux}[local];{$endif}
      procedure GCCArrInit;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure SplineInit        (         w,h            :integer;
                                            ln_arr0_init   :boolean;
                                            ln_arr1_init   :boolean;
                                            ln_arr2_init   :boolean;
                                            aa_buff_init   :boolean);       inline; {$ifdef Linux}[local];{$endif}
      procedure SetBckgd          (constref bmp_dst_ptr_   :PInteger;
                                   constref bmp_dst_width_,
                                            bmp_dst_height_:integer);       inline; {$ifdef Linux}[local];{$endif}
      procedure MinimizeArrs      (         aa_buff_clear  :boolean);       inline; {$ifdef Linux}[local];{$endif}
      {Fast Line Grid Precalculation}
    {class} procedure LinePrecalc (         w,h            :integer);               {$ifdef Linux}[local];{$endif}
      {Solid Line Initialization}
      procedure LineSInit;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL00;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL01;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL10;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL11;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL20;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL21;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL30;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL31;                                                  inline; {$ifdef Linux}[local];{$endif}

    protected
      {Right Bottom Corner}
      {0°..-45°}
      procedure LineS00;                                                    inline; {$ifdef Linux}[local];{$endif}
      procedure LineS01RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS02RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS03RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS04RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS05RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS06RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS07RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS08RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS09RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      {-45°..-90°}
      procedure LineS10;                                                    inline; {$ifdef Linux}[local];{$endif}
      procedure LineS11RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS12RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS13RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS14RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS15RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS16RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS17RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS18RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS19RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      {Left Bottom Corner}
      {-135°..-180°}
      procedure LineS20;                                                    inline; {$ifdef Linux}[local];{$endif}
      procedure LineS21LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS22LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS23LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS24LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS25LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS26LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS27LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS28LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS29LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      {-90°..-135°}
      procedure LineS30;                                                    inline; {$ifdef Linux}[local];{$endif}
      procedure LineS31LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS32LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS33LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS34LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS35LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS36LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS37LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS38LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS39LBC;                                                 inline; {$ifdef Linux}[local];{$endif}

    public
      {Solid Line Drawing}
      {Fast Line Solid Mode Normal}
      procedure LineSMN           (constref x0,y0,x1,y1    :integer);       inline; {$ifdef Linux}[local];{$endif}
      {Fast Line Solid Mode Extended}
      procedure LineSME           (constref x0,y0,x1,y1    :integer;
                                   constref proc_ptr_a     :TProc0;
                                   constref proc_ptr_b     :TProc0);        inline; {$ifdef Linux}[local];{$endif}
      {Fast Line Po-Han Lin}
      procedure LinePHL           (constref x0,y0,x1,y1    :integer;
                                   constref proc_ptr_a     :TProc0;
                                   constref proc_ptr_b     :TProc0);        inline; {$ifdef Linux}[local];{$endif}
      {Solid Horizontal Line Drawing}
      procedure LineSHL00;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LineSHL10;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LineSHL20;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LineSHL30;                                                  inline; {$ifdef Linux}[local];{$endif}
      {Solid Vertical Line Drawing}
      procedure LineSVL00;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LineSVL10;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LineSVL20;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LineSVL30;                                                  inline; {$ifdef Linux}[local];{$endif}
      {Fast Line Clipping}
      procedure ClippedLine1      (         x0,y0,x1,y1    :integer;
                                   const    rct_clp        :TPtRect;
                                   constref proc1          :TProc3;
                                   constref proc2          :TProc0;
                                   constref proc3          :TProc0);                {$ifdef Linux}[local];{$endif}
      procedure ClippedLine2      (         x0,y0,x1,y1    :integer;
                                   const    rct_clp        :TPtRect;
                                   constref proc1          :TProc3;
                                   constref proc2          :TProc0;
                                   constref proc3          :TProc0);                {$ifdef Linux}[local];{$endif}
      procedure ClippedLine2      (         x0,y0,x1,y1    :integer;
                                   const    rct_clp        :TPtRect);               {$ifdef Linux}[local];{$endif} {$endregion}

  end; {$endregion}
  PFastSpline       =^TFastSpline;
  {****************************************************************************}



{Color Transform}
function Red                    (         pixel              :integer): byte;          inline; {$ifdef Linux}[local];{$endif}
function Green                  (         pixel              :integer): byte;          inline; {$ifdef Linux}[local];{$endif}
function Blue                   (         pixel              :integer): byte;          inline; {$ifdef Linux}[local];{$endif}
function RGB                    (         r,g,b              :byte): TColor;           inline; {$ifdef Linux}[local];{$endif}
function SetColorInv            (         pixel              :integer;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): integer;    inline; {$ifdef Linux}[local];{$endif}
function Additive               (         pixel              :integer;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): integer;    inline; {$ifdef Linux}[local];{$endif}
procedure AlphaBlend            (         pixel_ptr          :PInteger;
                                 constref r,g,b              :byte;
                                 constref d_alpha            :byte);                   inline; {$ifdef Linux}[local];{$endif}
function AlphaBlend             (         pixel              :integer;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): integer;    inline; {$ifdef Linux}[local];{$endif}
function Inverse                (         pixel              :integer): integer;       inline; {$ifdef Linux}[local];{$endif}
function Highlight              (         pixel              :integer;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): integer;    inline; {$ifdef Linux}[local];{$endif}
function Darken                 (         pixel              :integer;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): integer;    inline; {$ifdef Linux}[local];{$endif}
function GrayscaleR             (         pixel              :integer;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): integer;    inline; {$ifdef Linux}[local];{$endif}
function GrayscaleG             (         pixel              :integer;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): integer;    inline; {$ifdef Linux}[local];{$endif}
function GrayscaleB             (         pixel              :integer;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): integer;    inline; {$ifdef Linux}[local];{$endif}
function ColorizeRM             (         pixel              :integer;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): integer;    inline; {$ifdef Linux}[local];{$endif}
function ColorizeRP             (         pixel              :integer;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): integer;    inline; {$ifdef Linux}[local];{$endif}
function ColorizeGM             (         pixel              :integer;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): integer;    inline; {$ifdef Linux}[local];{$endif}
function ColorizeGP             (         pixel              :integer;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): integer;    inline; {$ifdef Linux}[local];{$endif}
function ColorizeBM             (         pixel              :integer;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): integer;    inline; {$ifdef Linux}[local];{$endif}
function ColorizeBP             (         pixel              :integer;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): integer;    inline; {$ifdef Linux}[local];{$endif}
function AdditiveDec            (         pixel              :integer;
                                 constref r,g,b              :byte;
                                 constref alpha_fade         :byte): integer;          inline; {$ifdef Linux}[local];{$endif}
function AdditiveDec2           (         pixel              :integer;
                                 constref r,g,b              :byte;
                                          alpha,d_alpha      :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): integer;      inline; {$ifdef Linux}[local];{$endif}
function AlphaBlendDec          (         pixel              :integer;
                                 constref r,g,b              :byte;
                                          alpha,d_alpha      :byte;
                                 constref alpha_fade         :byte): integer;          inline; {$ifdef Linux}[local];{$endif}
function AlphaBlendDec2         (         pixel              :integer;
                                 constref r,g,b              :byte;
                                          alpha,d_alpha      :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): integer;      inline; {$ifdef Linux}[local];{$endif}
function InverseDec             (         pixel              :integer;
                                 constref alpha_fade         :byte): integer;          inline; {$ifdef Linux}[local];{$endif}
function InverseDec2            (         pixel              :integer;
                                 constref r,g,b              :byte;
                                          alpha,d_alpha      :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): integer;      inline; {$ifdef Linux}[local];{$endif}
function HighlightDec           (         pixel              :integer;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte=64): integer;       inline; {$ifdef Linux}[local];{$endif}
function HighlightDec2          (         pixel              :integer;
                                 constref r,g,b              :byte;
                                          alpha,d_alpha      :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): integer;      inline; {$ifdef Linux}[local];{$endif}
function DarkenDec              (         pixel              :integer;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte=64): integer;       inline; {$ifdef Linux}[local];{$endif}
function DarkenDec2             (         pixel              :integer;
                                 constref r,g,b              :byte;
                                          alpha,d_alpha      :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): integer;      inline; {$ifdef Linux}[local];{$endif}
function GrayscaleRDec          (         pixel              :integer;
                                 constref alpha_fade         :byte): integer;          inline; {$ifdef Linux}[local];{$endif}
function GrayscaleRDec2         (         pixel              :integer;
                                 constref r,g,b              :byte;
                                          alpha,d_alpha      :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): integer;      inline; {$ifdef Linux}[local];{$endif}
function GrayscaleGDec          (         pixel              :integer;
                                 constref alpha_fade         :byte): integer;          inline; {$ifdef Linux}[local];{$endif}
function GrayscaleGDec2         (         pixel              :integer;
                                 constref r,g,b              :byte;
                                          alpha,d_alpha      :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): integer;      inline; {$ifdef Linux}[local];{$endif}
function GrayscaleBDec          (         pixel              :integer;
                                 constref alpha_fade         :byte): integer;          inline; {$ifdef Linux}[local];{$endif}
function GrayscaleBDec2         (         pixel              :integer;
                                 constref r,g,b              :byte;
                                          alpha,d_alpha      :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): integer;      inline; {$ifdef Linux}[local];{$endif}
function ColorizeRMDec          (         pixel              :integer;
                                 constref alpha_fade         :byte;
                                 constref d                  :smallint): integer;      inline; {$ifdef Linux}[local];{$endif}
function ColorizeRMDec2         (         pixel              :integer;
                                 constref r,g,b              :byte;
                                          alpha,d_alpha      :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): integer;      inline; {$ifdef Linux}[local];{$endif}
function ColorizeRPDec          (         pixel              :integer;
                                 constref alpha_fade         :byte;
                                 constref d                  :smallint): integer;      inline; {$ifdef Linux}[local];{$endif}
function ColorizeRPDec2         (         pixel              :integer;
                                 constref r,g,b              :byte;
                                          alpha,d_alpha      :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): integer;      inline; {$ifdef Linux}[local];{$endif}
function ColorizeGMDec          (         pixel              :integer;
                                 constref alpha_fade         :byte;
                                 constref d                  :smallint): integer;      inline; {$ifdef Linux}[local];{$endif}
function ColorizeGMDec2         (         pixel              :integer;
                                 constref r,g,b              :byte;
                                          alpha,d_alpha      :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): integer;      inline; {$ifdef Linux}[local];{$endif}
function ColorizeGPDec          (         pixel              :integer;
                                 constref alpha_fade         :byte;
                                 constref d                  :smallint): integer;      inline; {$ifdef Linux}[local];{$endif}
function ColorizeGPDec2         (         pixel              :integer;
                                 constref r,g,b              :byte;
                                          alpha,d_alpha      :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): integer;      inline; {$ifdef Linux}[local];{$endif}
function ColorizeBMDec          (         pixel              :integer;
                                 constref alpha_fade         :byte;
                                 constref d                  :smallint): integer;      inline; {$ifdef Linux}[local];{$endif}
function ColorizeBMDec2         (         pixel              :integer;
                                 constref r,g,b              :byte;
                                          alpha,d_alpha      :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): integer;      inline; {$ifdef Linux}[local];{$endif}
function ColorizeBPDec          (         pixel              :integer;
                                 constref alpha_fade         :byte;
                                 constref d                  :smallint): integer;      inline; {$ifdef Linux}[local];{$endif}
function ColorizeBPDec2         (         pixel              :integer;
                                 constref r,g,b              :byte;
                                          alpha,d_alpha      :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): integer;      inline; {$ifdef Linux}[local];{$endif}

{Misc. Routines}
function GetEnumVal             (         enum               :TDrawingStyle): integer; inline; {$ifdef Linux}[local];{$endif}
function Min                    (constref a1,a2              :double ): double ;       inline; {$ifdef Linux}[local];{$endif}
function Min                    (constref a1,a2              :integer): integer;       inline; {$ifdef Linux}[local];{$endif}
function Min                    (constref arr                :T1IntrArr;
                                 constref max_item_val       :integer;
                                 constref item_cnt           :integer): integer;       inline; {$ifdef Linux}[local];{$endif}
function Min                    (constref arr                :T1IntrArr;
                                 constref max_item_val       :integer;
                                 constref item_cnt           :integer;
                                 constref b                  :boolean): integer;       inline; {$ifdef Linux}[local];{$endif}
function Min                    (constref arr                :T1EdgeArr;
                                 constref max_item_val       :integer;
                                 constref item_cnt           :integer): integer;       inline; {$ifdef Linux}[local];{$endif}
function Max                    (constref a1,a2              :double ): double ;       inline; {$ifdef Linux}[local];{$endif}
function Max                    (constref a1,a2              :integer): integer;       inline; {$ifdef Linux}[local];{$endif}
function Max                    (constref arr                :T1IntrArr;
                                 constref min_item_val       :integer;
                                 constref item_cnt           :integer): integer;       inline; {$ifdef Linux}[local];{$endif}
function Max                    (constref arr                :T1IntrArr;
                                 constref min_item_val       :integer;
                                 constref item_cnt           :integer;
                                 constref b                  :boolean): integer;       inline; {$ifdef Linux}[local];{$endif}
function Max                    (constref arr                :T1EdgeArr;
                                 constref min_item_val       :integer;
                                 constref item_cnt           :integer): integer;       inline; {$ifdef Linux}[local];{$endif}
function InvSqrt                (constref x                  :single): single;         inline; {$ifdef Linux}[local];{$endif}
procedure PtrInit               (var      ptr                :PInteger;
                                 constref arr                :T1IntrArr);              inline; {$ifdef Linux}[local];{$endif}
procedure MaxSpriteWHRctInit    (var      rct                :TPtRect);                inline; {$ifdef Linux}[local];{$endif}
function ArcTan4                (constref x0,y0,x1,y1        :double): double;         inline; {$ifdef Linux}[local];{$endif}

// (Binary Search) Бинарный поиск:
function BinarySearch           (constref n                  :integer;
                                 constref arr_item_ptr       :PInteger;
                                 constref right_border       :integer):integer;        inline; {$ifdef Linux}[local];{$endif}

{Store Color Channel into Integer Array}
procedure BmpToArr              (constref bmp_src_ptr        :PInteger;
                                 var      bmp_dst_ptr        :PInteger;
                                 var      arr_dst            :T1IntrArr;
                                 constref bmp_src_rct        :TPtRect;
                                 constref bmp_src_width,
                                          bmp_src_height     :integer;
                                 var      bmp_dst_width,
                                          bmp_dst_height     :integer);                inline; {$ifdef Linux}[local];{$endif}

{Store Alpha Channel into Byte Array}
//...

(******************************* Bitmap Loading *******************************)

function CrtTPicInstFromHDDSrc  (constref location           :string): TPicture;       inline; {$ifdef Linux}[local];{$endif}
function CrtTBmpInstFromImgLst  (constref ImgLstGetBmp       :TProc1;
                                 constref img_ind            :integer=0): TBitmap;     inline; {$ifdef Linux}[local];{$endif}
function CrtTBmpInst            (constref bmp_src            :TBitmap;
                                 var      bmp_dst_ptr        :PInteger): TBitmap;      inline; {$ifdef Linux}[local];{$endif}
function CrtTBmpInst            (constref bmp_dst_width,
                                          bmp_dst_height     :integer;
                                 var      bmp_src_ptr        :PInteger): TBitmap;      inline; {$ifdef Linux}[local];{$endif}

{Arrays Addition}
procedure ArrAdd                (constref arr_src1,
                                          arr_src2           :T1ByteArr;
                                 var      arr_dst            :T1IntrArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :longword);                       {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (constref arr_src1,
                                          arr_src2           :T1DublArr;
                                 var      arr_dst            :T1DublArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :longword);                       {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (constref arr_src1,
                                          arr_src2           :T1IntrArr;
                                 var      arr_dst            :T1IntrArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :longword);                       {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (constref arr_src1,
                                          arr_src2           :T1LWordArr;
                                 var      arr_dst            :T1LWordArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :longword);                       {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (constref arr_src1,
                                          arr_src2           :T1WordArr;
                                 var      arr_dst            :T1WordArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :longword);                       {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (constref arr_src1,
                                          arr_src2           :T1ByteArr;
                                 var      arr_dst            :T1ByteArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :longword);                       {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (constref arr_src1           :T1IntrArr;
                                 constref arr_src2           :T1ByteArr;
                                 constref width,height       :longword;
                                 constref val                :integer);                        {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (constref arr_src1           :T1ByteArr;
                                 constref arr_src2           :T2ByteArr;
                                 constref arr_dst            :T1IntrArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :longword);                       {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (constref arr_src1           :T1ByteArr;
                                 constref arr_src2           :T2ByteArr;
                                 constref arr_dst            :T1ByteArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :longword);                       {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (var      arr_src1           :T1ByteArr;
                                 constref arr_src2           :T2ByteArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :longword);                       {$ifdef Linux}[local];{$endif}

{Arrays Subtraction}
procedure ArrSub                (constref arr_src1,
                                          arr_src2           :T1DublArr;
                                 var      arr_dst            :T1DublArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :longword);                       {$ifdef Linux}[local];{$endif}
procedure ArrSub                (constref arr_src1,
                                          arr_src2           :T1IntrArr;
                                 var      arr_dst            :T1IntrArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :longword);                       {$ifdef Linux}[local];{$endif}
procedure ArrSub                (constref arr_src1,
                                          arr_src2           :T1LWordArr;
                                 var      arr_dst            :T1LWordArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :longword);                       {$ifdef Linux}[local];{$endif}
procedure ArrSub                (constref arr_src1,
                                          arr_src2           :T1WordArr;
                                 var      arr_dst            :T1WordArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :longword);                       {$ifdef Linux}[local];{$endif}
procedure ArrSub                (constref arr_src1,
                                          arr_src2           :T1ByteArr;
                                 var      arr_dst            :T1ByteArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :longword);                       {$ifdef Linux}[local];{$endif}
procedure ArrSub                (constref arr_src            :T1ByteArr;
                                 constref arr_dst            :T1IntrArr;
                                 constref width,height       :longword;
                                 constref val                :integer);                        {$ifdef Linux}[local];{$endif}

{2D Array to 1D Array}
procedure Arr2DTo1D             (constref arr_src            :T2ByteArr;
                                 var      arr_dst            :T1ByteArr;
                                 constref arr_src_width,
                                          arr_src_height     :longword);                       {$ifdef Linux}[local];{$endif}

{Minimize Arrays}
procedure MinimizeArr           (var      arr_src            :T1AALnArr);                      {$ifdef Linux}[local];{$endif}
procedure MinimizeArr           (var      arr_src            :T2ByteArr);                      {$ifdef Linux}[local];{$endif}
procedure MinimizeArr           (var      arr_src            :T1IntrArr);                      {$ifdef Linux}[local];{$endif}
procedure MinimizeArr           (var      arr_src            :T1WordArr);                      {$ifdef Linux}[local];{$endif}
procedure MinimizeArr           (var      arr_src            :T1ByteArr);                      {$ifdef Linux}[local];{$endif}

{Clear Arrays}
procedure BmpClear              (         bmp                :Graphics.TBitmap);       inline; {$ifdef Linux}[local];{$endif}
procedure ArrClear              (         arr1_ptr           :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref arr_width          :integer;
                                 constref val                :integer=0);              inline; {$ifdef Linux}[local];{$endif}
procedure ArrClear              (var      arr0               :T1ByteArr;
                                 constref rct_dst            :TPtRect;
                                 constref arr_width          :integer;
                                 constref val                :byte=0);                 inline; {$ifdef Linux}[local];{$endif}
procedure ArrClear              (var      arr1               :T1IntrArr;
                                 constref rct_dst            :TPtRect;
                                 constref arr_width          :integer;
                                 constref val                :integer=0);              inline; {$ifdef Linux}[local];{$endif}
procedure ArrClear              (var      arr2               :T2ByteArr;
                                 constref rct_dst            :TPtRect;
                                 constref val                :byte=0);                 inline; {$ifdef Linux}[local];{$endif}
procedure ArrClear              (var      arr3               :T1PtPos2Arr;
                                 constref rct_dst            :TPtRect;
                                 constref arr_width          :integer);                inline; {$ifdef Linux}[local];{$endif}

{Fill Arrays On Bitmap}
procedure ArrFillProc0          (constref arr0               :T1ByteArr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :integer;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc1          (constref arr0               :T1ByteArr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :integer;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc2          (constref arr0               :T1ByteArr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :integer;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc3          (constref arr0               :T1ByteArr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :integer;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc4          (constref arr0               :T1ByteArr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :integer;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc5          (constref arr0               :T1ByteArr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :integer;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc6          (constref arr0               :T1ByteArr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :integer;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc7          (constref arr0               :T1ByteArr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :integer;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc8          (constref arr0               :T1ByteArr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :integer;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc9          (constref arr0               :T1ByteArr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :integer;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFill               (constref arr0               :T1IntrArr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :integer;
                                 constref rct_dst            :TPtrect;
                                 constref col                :integer);
procedure ArrFill               (constref arr0               :T1PtPos2Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :integer;
                                 constref rct_dst            :TPtrect;
                                 constref col                :integer);
procedure ArrFill               (constref arr0               :T1PtPos2Arr;
                                 constref bmp_width,
                                          bmp_height         :integer;
                                 constref rct_dst            :TPtrect);
procedure ArrFill               (constref arr0               :T1ByteArr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :integer;
                                 constref rct_dst            :TPtrect);
procedure ArrFillTest           (constref arr0               :T1ByteArr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :integer;
                                 constref rct_dst            :TPtrect;
                                 constref col                :integer);
procedure ArrFillTest           (constref arr0               :T1IntrArr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :integer;
                                 constref rct_dst            :TPtrect;
                                 constref col                :integer);

// Non-Zero Items Count:
function ArrNzItCnt             (constref arr                :T1ByteArr): integer;             {$ifdef Linux}[local];{$endif}

{Edge Antialiasing}

procedure BorderCalc0           (constref arr_src_ptr        :PInteger;
                                 var      arr_dst            :T1ByteArr;
                                 constref arr_src_width,
                                          arr_dst_width      :integer;
                                 constref rct_dst            :TPtRect;
                                 var      aa_nz_arr_it_cnt   :integer;
                                 constref background_color   :integer);                        {$ifdef Linux}[local];{$endif}
procedure BorderCalc1           (constref arr_src_ptr        :PInteger;
                                 var      arr_dst            :T1ByteArr;
                                 constref arr_src_width,
                                          arr_dst_width      :integer;
                                 constref rct_dst            :TPtRect;
                                 var      aa_nz_arr_it_cnt   :integer);                        {$ifdef Linux}[local];{$endif}
procedure BorderCalc1           (constref arr_src            :T1IntrArr;
                                 var      arr_dst            :T1ByteArr;
                                 constref arr_src_width,
                                          arr_dst_width      :integer;
                                 constref rct_dst            :TPtRect;
                                 var      aa_nz_arr_it_cnt   :integer);                        {$ifdef Linux}[local];{$endif}
procedure BorderCalc1           (constref arr_src            :T1ByteArr;
                                 var      arr_dst            :T1ByteArr;
                                 constref arr_src_width,
                                          arr_dst_width      :integer;
                                 constref rct_dst            :TPtRect;
                                 var      aa_nz_arr_it_cnt   :integer);                        {$ifdef Linux}[local];{$endif}
procedure BorderCalc2           (constref arr_src_ptr        :PInteger;
                                 var      arr_dst            :T1ByteArr;
                                 var      arr_alpha          :T1AALnArr;
                                 constref arr_src_width,
                                          arr_dst_width      :integer;
                                 constref rct_dst            :TPtRect;
                                 out      line_count         :integer);                        {$ifdef Linux}[local];{$endif}
procedure BorderCalc2           (constref arr_src            :T1IntrArr;
                                 var      arr_dst            :T1ByteArr;
                                 var      arr_alpha          :T1AALnArr;
                                 constref arr_src_width,
                                          arr_dst_width      :integer;
                                 constref rct_dst            :TPtRect;
                                 out      line_count         :integer);                        {$ifdef Linux}[local];{$endif}
procedure BorderCalc2           (constref arr_src            :T1ByteArr;
                                 var      arr_dst            :T1ByteArr;
                                 var      arr_alpha          :T1AALnArr;
                                 constref arr_src_width,
                                          arr_dst_width      :integer;
                                 constref rct_dst            :TPtRect;
                                 out      line_count         :integer);                        {$ifdef Linux}[local];{$endif}

procedure BorderFill            (constref arr_src            :T1AALnArr;
                                 constref rct_dst_left,
                                          rct_dst_top        :integer;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width          :integer;
                                 constref line_count         :integer;
                                 constref col                :TColor;
                                          args               :TFunc0Args;
                                          Func2              :TFunc2);

// Border Blur:
procedure BorderBlur            (constref arr_src_ptr        :PInteger;
                                 var      arr_dst            :T1ByteArr;
                                 constref arr_src_width,
                                          arr_dst_width      :integer;
                                 constref rct_dst            :TPtRect;
                                 constref background_color   :integer);                        {$ifdef Linux}[local];{$endif}

// One-Pixel Border-Blur Calculation:
procedure BorderPixCh           (         arr_src_ptr        :PInteger;
                                 constref arr_src_width      :integer;
                                 constref background_color   :integer);                inline; {$ifdef Linux}[local];{$endif}

(****************************** Points Transform ******************************)

// (Align Points to horizontal line, from left to right): Выровнять точки по горизонтали, слева направо:
procedure PtsRawH               (var      pts                :T1PtPosFArr;
                                 constref start_ind,
                                          end_ind            :integer;
                                 constref pts_dist           :longword);                       {$ifdef Linux}[local];{$endif}

// (Align Points to vertical line, from top to bottom): Выровнять точки по вертикали, сверху вниз:
procedure PtsRawV               (var      pts                :T1PtPosFArr;
                                 constref start_ind,
                                          end_ind            :integer;
                                 constref pts_dist           :longword);                       {$ifdef Linux}[local];{$endif}

// (Reset Points Position): Восстановить позицию точек:
procedure PtsRes                (constref fst_pt_ptr1,
                                          fst_pt_ptr2        :PPtPosF;
                                 constref pts_cnt            :integer;
                                 constref pt_pos_curr,
                                          pt_pos_prev        :TPtPosF);                        {$ifdef Linux}[local];{$endif}

// (Points Pivot) Ось точек:
procedure PtsPvt                (var      pvt                :TPtPosF;
                                 var      pts                :T1PtPosFArr;
                                 constref pts_cnt            :integer);                        {$ifdef Linux}[local];{$endif}

// (Points Moving) Перемещение точек:
procedure PtsMov                (constref pvt                :TPtPos;
                                 var      pts                :T1PtPosFArr;
                                 constref pts_cnt            :integer;
                                 constref fst_ind            :integer);                        {$ifdef Linux}[local];{$endif}
procedure PtsMov                (constref pvt                :TPtPos;
                                 var      pts                :T1PtPosFArr;
                                 constref pts_cnt            :integer);                        {$ifdef Linux}[local];{$endif}
procedure PtsMov                (constref pvt                :TPtPos;
                                 var      rct                :TPtRect);                        {$ifdef Linux}[local];{$endif}
procedure PtsMov                (constref pvt                :TPtPos;
                                 var      rct                :TRect);                          {$ifdef Linux}[local];{$endif}

procedure WndSht                (constref outer_rect         :TPtRect;
                                 constref inner_rect         :T1PtPosFArr;
                                 var      shift_power        :integer;
                                 constref mul                :integer);                        {$ifdef Linux}[local];{$endif}
procedure MDCalc                (var      rct                :TRect;
                                 constref mov_dir            :TMovingDirection;
                                 constref shift_power        :integer);                        {$ifdef Linux}[local];{$endif}

// (Points Scaling) Масштабирование точек:
procedure PtsScl                (constref pvt                :TPtPosF;
                                 var      pts                :T1PtPosFArr;
                                 constref pts_cnt            :integer;
                                          scl_mul            :TPtPosF;
                                 constref scl_dir            :TSclDir;
                                 constref fst_ind            :integer);                        {$ifdef Linux}[local];{$endif}
procedure PtsScl                (constref pvt                :TPtPosF;
                                 var      pts                :T1PtPosFArr;
                                 constref pts_cnt            :integer;
                                          scl_mul            :TPtPosF;
                                 constref scl_dir            :TSclDir);                        {$ifdef Linux}[local];{$endif}
procedure PtsScl                (constref pvt                :TPtPosF;
                                 var      rct                :TPtRectF;
                                 constref pts_cnt            :integer;
                                          scl_mul            :TPtPosF;
                                 constref scl_dir            :TSclDir);                        {$ifdef Linux}[local];{$endif}
procedure PtsScl                (constref pvt                :TPtPosF;
                                 var      rct                :TRect;
                                 constref pts_cnt            :integer;
                                          scl_mul            :TPtPosF;
                                 constref scl_dir            :TSclDir);                        {$ifdef Linux}[local];{$endif}

// (Points Rotation) Вращение точек:
{TODO}

(************************** Miscellaneous Primitives **************************)

// Color Info:
procedure SetColorInfo          (constref pix_col            :integer;
                                 var      color_info         :TColorInfo);             inline; {$ifdef Linux}[local];{$endif}

// Line Segment: Отрезок:
function  LineS                 (constref v0,w0,v1,w1,r0,r1  :double): TLnPosF;        inline; {$ifdef Linux}[local];{$endif}
function  LineS                 (constref v0,w0,v1,w1,r      :double): TPtPosF;        inline; {$ifdef Linux}[local];{$endif}
function  LineS                 (constref v0,w0,v1,w1,r      :double;
                                 constref dir_x,dir_y        :shortint): TPtPosF;      inline; {$ifdef Linux}[local];{$endif}

// Line Direction: Направление линии:
procedure LineD                 (constref v0,w0,v1,w1        :double;
                                 var      dir_x,dir_y        :shortint);               inline; {$ifdef Linux}[local];{$endif}

// Monochrome Line:
procedure Line                  (         x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref color_info         :TColorInfo);             inline; {$ifdef Linux}[local];{$endif}
procedure Line                  (         x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref val                :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure Line                  (         x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :integer;
                                 constref val                :byte);                   inline; {$ifdef Linux}[local];{$endif}
// Line Segments Intersection:
function  LineSI                (         x0,y0,x1,y1,
                                          v0,w0,v1,w1        :double ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  LineSI                (         x0,y0,x1,y1,
                                          v0,w0,v1,w1        :integer): boolean;       inline; {$ifdef Linux}[local];{$endif}

// Line Clipping:
function  LineC                 (var      x0,y0,x1,y1        :integer;
                                 constref rct_clp            :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}

// Monochrome Antialiased Line(Width - 1 pixel):
procedure LineA                 (         x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref color_info         :TColorInfo);             inline; {$ifdef Linux}[local];{$endif}
procedure LineAC                (var      x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref color_info         :TColorInfo;
                                 constref rct_clp            :TPtRect);                inline; {$ifdef Linux}[local];{$endif}

// Monochrome Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineABC               (constref pts                :T1PtPosFArr;
                                 constref start_ind,end_ind  :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref color_info         :TColorInfo;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}

// Gradient(Highlight) Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineABCG              (constref pts                :T1PtPosFArr;
                                 constref start_ind,end_ind  :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 var      color_info         :TColorInfo;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}

// Equidistant Line(Width - 1 pixel):
function  LineE1                (constref v0,w0,v1,w1,rad    :double): TLnPosF;        inline; {$ifdef Linux}[local];{$endif}
function  LineE2                (constref v0,w0,v1,w1,rad    :double): TLnPosF;        inline; {$ifdef Linux}[local];{$endif}

// Equidistant Curve for Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineABCE              (constref pts                :T1PtPosFArr;
                                 constref start_ind,end_ind  :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref color_info         :TColorInfo;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :integer;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}

// Equidistant Curve for Not Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineBCE               (constref pts                :T1PtPosFArr;
                                 constref start_ind,end_ind  :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref color_info         :TColorInfo;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :integer;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE               (constref pts                :T1PtPosFArr;
                                 constref start_ind,end_ind  :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref val                :integer;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :integer;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE               (constref pts                :T1PtPosFArr;
                                 constref start_ind,end_ind  :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :integer;
                                 constref val                :byte;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :integer;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE               (constref pts                :T1PtPosFArr;
                                 constref start_ind,end_ind  :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :integer;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}

// Equidistant Curve for Not Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineBCE2              (constref pts                :T1PtPosFArr;
                                 constref start_ind,end_ind  :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref color_info         :TColorInfo;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :integer;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE2              (constref pts                :T1PtPosFArr;
                                 constref start_ind,end_ind  :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref val                :integer;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :integer;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE2              (constref pts                :T1PtPosFArr;
                                 constref start_ind,end_ind  :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :integer;
                                 constref val                :byte;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :integer;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE2              (constref pts                :T1PtPosFArr;
                                 constref start_ind,end_ind  :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :integer;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}

// Equidistant Curve for Not Antialiased Broken Clipped Line(Width - 3 pixel):
procedure LineBCE3              (constref pts                :T1PtPosFArr;
                                 constref start_ind,end_ind  :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref color_info         :TColorInfo;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :integer;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE3              (constref pts                :T1PtPosFArr;
                                 constref start_ind,end_ind  :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :integer;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}

// Resilient Line(Width - 1 pixel):
procedure LineR                 (constref x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref color_info         :TColorInfo;
                                 constref seg_cnt            :integer);                inline; {$ifdef Linux}[local];{$endif}

// Monochrome Horizontal Line(Width - 1 pixel):
function  LineHC                (var      x0,y0,x1           :integer;
                                 constref rct_clp            :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
procedure LineH                 (         x0,y0,x1           :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref color_info         :TColorInfo);             inline; {$ifdef Linux}[local];{$endif}
procedure LineH                 (         x0,y0,x1           :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref val                :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure LineH                 (         x0,y0,x1           :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :integer;
                                 constref val                :byte);                   inline; {$ifdef Linux}[local];{$endif}

// Monochrome Vertical Line(Width - 1 pixel):
function  LineVC                (var      x0,y0,y1           :integer;
                                 constref rct_clp            :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
procedure LineV                 (         x0,y0,y1           :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref color_info         :TColorInfo);             inline; {$ifdef Linux}[local];{$endif}
procedure LineV                 (         x0,y0,y1           :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref val                :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure LineV                 (         x0,y0,y1           :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :integer;
                                 constref val                :byte);                   inline; {$ifdef Linux}[local];{$endif}

// Point
procedure Point                 (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref color_info         :TColorInfo);             inline; {$ifdef Linux}[local];{$endif}
procedure Point                 (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref color_info         :TColorInfo;
                                 constref clip_rect          :TPtRect);                inline; {$ifdef Linux}[local];{$endif}

// Point Collisin Drawing on Array
function PointCollDraw          (constref x,y                :integer;
                                 constref arr_src_width      :integer;
                                 var      arr_src            :T1ByteArr;
                                 constref clip_rect          :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
function PointCollDraw          (constref x,y                :integer;
                                 constref arr_src_width      :integer;
                                 constref arr_src            :T1ByteArr;
                                 constref clip_rect          :TPtRect;
                                 constref b                  :byte   ): boolean;       inline; {$ifdef Linux}[local];{$endif}

// Rectangle
procedure SetRctDupId           (var      sln_prop_var       :TCurveProp);             inline; {$ifdef Linux}[local];{$endif}
procedure SetEdsWidth           (var      sln_prop_var       :TCurveProp);             inline; {$ifdef Linux}[local];{$endif}
procedure SetRctWidth           (var      sln_prop_var       :TCurveProp);             inline; {$ifdef Linux}[local];{$endif}
procedure SetRctHeight          (var      sln_prop_var       :TCurveProp);             inline; {$ifdef Linux}[local];{$endif}
procedure SetRctValues          (var      sln_prop_var       :TCurveProp);             inline; {$ifdef Linux}[local];{$endif}
procedure Rectangle             (constref x,y                :integer;
                                 constref arr_dst_ptr        :PInteger;
                                 constref arr_dst_width,
                                          arr_dst_height     :integer;
                                 constref rct_dst            :TPtRect;
                                 constref sln_prop_var       :TCurveProp;
                                 constref col                :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure Rectangle             (constref x,y                :integer;
                                 constref arr_dst_ptr        :PInteger;
                                 constref arr_dst_width,
                                          arr_dst_height     :integer;
                                 constref rct_dst            :TPtRect;
                                 constref sln_prop_var       :TCurveProp;
                                 constref PPFloodFillProc    :TProc4);                 inline; {$ifdef Linux}[local];{$endif}

// Rhombus:
procedure Rombus                (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref color_info         :TColorInfo);             inline; {$ifdef Linux}[local];{$endif}

// Circle Drawing(Midpoint Algorithm):
procedure Circle                (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref color_info         :TColorInfo);             inline; {$ifdef Linux}[local];{$endif}
procedure Circle                (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref val                :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure Circle                (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :integer;
                                 constref val                :byte);                   inline; {$ifdef Linux}[local];{$endif}
procedure CircleC               (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref rct_clp            :TPtRect;
                                 constref bmp_dst_width      :integer;
                                 constref color_info         :TColorInfo);             inline; {$ifdef Linux}[local];{$endif}
procedure CircleC               (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref rct_clp            :TPtRect;
                                 constref bmp_dst_width      :integer;
                                 constref val                :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure CircleC               (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref rct_clp            :TPtRect;
                                 constref bmp_dst_width      :integer;
                                 constref val                :byte);                   inline; {$ifdef Linux}[local];{$endif}

// Wave Search:
function CircleW                (constref x0,y0,rad          :integer;
                                 constref arr_dst            :T1PtPos2Arr;
                                 constref arr_dst_width      :integer;
                                 var      pt                 :TPtPosF): boolean;       inline; {$ifdef Linux}[local];{$endif}
function CircleWC               (constref x0,y0,rad          :integer;
                                 constref arr_dst            :T1PtPos2Arr;
                                 constref rct_clp            :TPtRect;
                                 constref arr_dst_width      :integer;
                                 var      pt                 :TPtPosF): boolean;       inline; {$ifdef Linux}[local];{$endif}

// Circle FloodFill:
procedure CircleFloodFill       (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref outer_rect         :TPtRect;
                                 constref bmp_dst_width      :integer;
                                 constref color_info         :TColorInfo;
                                 constref diam               :longword;
                                 constref pow                :byte);                   inline; {$ifdef Linux}[local];{$endif}

// SpotLight
procedure CircleHighlight       (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref outer_rect         :TPtRect;
                                 constref bmp_dst_width      :integer;
                                 constref color_info         :TColorInfo;
                                 constref diam               :longword;
                                 constref pow                :byte);                   inline; {$ifdef Linux}[local];{$endif}

// Text
procedure SetTextInfo           (constref dst_canvas         :TCanvas;
                                 constref height_            :integer      =27;
                                 constref font_color         :TColor       =$006C754A;
                                 constref font_name          :string       ='AR CENA';
                                 constref font_charset       :TFontCharSet =ANSI_CHARSET;
                                 constref font_quality       :TFontQuality =fqAntialiased;
                                 constref pen_mode           :TFPPenMode   =pmXor;
                                 constref brush_style        :TFPBrushStyle=bsClear);  inline; {$ifdef Linux}[local];{$endif}
procedure Text                  (constref x,y                :integer;
                                 constref dst_canvas         :TCanvas;
                                 constref text_              :string);                 inline; {$ifdef Linux}[local];{$endif}

(***************************** Some Basic Routines ****************************)

// (Set Point) Установить точку:
function PtPos                  (constref pt                 :TPtPosF): TPtPos;        inline; {$ifdef Linux}[local];{$endif}
function PtPos                  (constref pos_x,
                                          pos_y              :integer): TPtPos;        inline; {$ifdef Linux}[local];{$endif}
function PtPosF                 (constref pt                 :TPtPos ): TPtPosF;       inline; {$ifdef Linux}[local];{$endif}
function PtPosF                 (constref pos_x,
                                          pos_y              :double ): TPtPosF;       inline; {$ifdef Linux}[local];{$endif}

// (Bounding Rectangle of Points Set) Ограничиваюший прямоугольник множества точек:
function PtsRngRctCalc          (constref pts                :T1PtPosFArr;
                                 var      rct_bnd_ind_arr    :TEnum2Arr;
                                 constref start_pts_ind      :integer=0;
                                 constref end_pts_ind        :integer=0): TRect;               {$ifdef Linux}[local];{$endif}
function PtsRngIndsRctCalc      (constref pts                :T1PtPosFArr;
                                 constref sel_pts_inds       :T1IntrArr;
                                 constref pts_cnt            :integer): TRect;                 {$ifdef Linux}[local];{$endif}

// (Set Rectangle) Установить прямоугольник:
procedure PtRct                 (constref pts                :T1PtPosFArr;
                                 constref rct_bnd_ind_arr    :TEnum2Arr;
                                 var      rct                :TRect);                  inline; {$ifdef Linux}[local];{$endif}
function PtRctB                 (constref rct_left,
                                          rct_top,
                                          rct_right,
                                          rct_bottom         :integer    ): TPtRectB;  inline; {$ifdef Linux}[local];{$endif}
function PtRct                  (constref rct_left,
                                          rct_top,
                                          rct_right,
                                          rct_bottom         :integer    ): TPtRect;   inline; {$ifdef Linux}[local];{$endif}
function PtRct                  (constref rct                :TRect      ): TPtRect;   inline; {$ifdef Linux}[local];{$endif}
function PtRct                  (constref rct                :TPtRectF   ): TPtRect;   inline; {$ifdef Linux}[local];{$endif}
function PtRct                  (constref rct                :T1PtPosFArr): TPtRect;   inline; {$ifdef Linux}[local];{$endif}
function PtBounds               (constref rct_left,
                                          rct_top,
                                          rct_width,
                                          rct_height         :integer    ): TPtRect;   inline; {$ifdef Linux}[local];{$endif}
function PtBounds               (constref rct                :TRect      ): TPtRect;   inline; {$ifdef Linux}[local];{$endif}
function PtBoundsF              (constref rct_left,
                                          rct_top,
                                          rct_width,
                                          rct_height         :integer    ): TPtRectF;  inline; {$ifdef Linux}[local];{$endif}

// (Inner Clipped Rectangle) Внутренний обрезанный прямоугольник:
function ClippedRctB            (constref outer_rect,
                                          inner_rect         :TPtRect;
                                 var      nt_pix_clp_type,
                                          pt_pix_clp_type    :byte)    : TPtRectB;     inline; {$ifdef Linux}[local];{$endif}
function ClippedRctB            (constref outer_rect,
                                          inner_rect         :TPtRect) : TPtRectB;     inline; {$ifdef Linux}[local];{$endif}
function ClippedRct             (constref outer_rect,
                                          inner_rect         :TPtRect) : TPtRect;      inline; {$ifdef Linux}[local];{$endif}
function ClippedRct             (constref outer_rect         :TPtRect;
                                 constref inner_rect         :TPtRectF): TPtRect;      inline; {$ifdef Linux}[local];{$endif}
function ClippedRct             (constref outer_rect,
                                          inner_rect         :TRect)   : TPtRect;      inline; {$ifdef Linux}[local];{$endif}
function ClippedRct             (constref outer_rect         :TPtRect;
                                 constref inner_rect         :TRect)   : TPtRect;      inline; {$ifdef Linux}[local];{$endif}
function ClippedRct             (constref outer_rect         :TPtRect;
                                 constref inner_rect         :TRect;
                                          b                  :boolean) : TRect;        inline; {$ifdef Linux}[local];{$endif}
function ClippedRct             (constref outer_rect,
                                          inner_rect         :TRect;
                                          b                  :boolean) : TRect;        inline; {$ifdef Linux}[local];{$endif}
function ClippedArr             (constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRectB;
                                 constref arr_src_width      :longword): integer;      inline; {$ifdef Linux}[local];{$endif}

// (Find Rectangle Which Has Not Coprime Width and Height(GCD(src_rect.Width,src_rect.Height)<>1) for source rectangle src_rect) Находит прямоугольник с не взаимно простыми сторонами(GCD(src_rect.Width,src_rect.Height)<>1) для исходного прямоугольника src_rect:
function NCSRectCalc            (constref rct_src            :TRect;
                                 constref bucket_width,
                                          bucket_heigth      :integer): TRect;         inline; {$ifdef Linux}[local];{$endif}

// (Two Rectangles Bounding Rectangle 1) Ограничивающий прямоугольник для двух заданных прямоугольников:
function TwoRctsBoundingRct     (constref rct1,
                                          rct2               :TRect)  : TRect;         inline; {$ifdef Linux}[local];{$endif}
function TwoRctsBoundingRct     (constref rct1,
                                          rct2               :TPtRect): TPtRect;       inline; {$ifdef Linux}[local];{$endif}

// (Rectangle in Rectangle) Прямоугольник в прямоугольнике:
function IsRct1InRct2           (constref rct1,
                                          rct2               :TRect)  : boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsRct1InRct2           (constref rct1,
                                          rct2               :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsRct1InRct2           (constref rct1               :TRect;
                                 constref rct2               :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}

// (Rectangle out of Rectangle) Прямоугольник вне прямоугольника:
function IsRct1OutOfRct2        (constref rct1,
                                          rct2               :TRect)  : boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsRct1OutOfRct2        (constref rct1,
                                          rct2               :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsRct1OutOfRct2        (constref rct1               :TRect;
                                 constref rct2               :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}

// (Point in Rectangle) Точка в прямоугольнике:
function IsPtInRct              (constref x,y                :integer;
                                 constref rct_dst            :TRect)  : boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInRct              (constref x,y                :integer;
                                 constref rct_dst            :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInRct              (constref pt                 :TPtPos;
                                 constref rct_dst            :TRect)  : boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInRct              (constref pt                 :TPtPos;
                                 constref rct_dst            :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInRct              (constref pt                 :TPtPosF;
                                 constref rct_dst            :TRect)  : boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInRct              (constref pt                 :TPtPosF;
                                 constref rct_dst            :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInRct              (constref pt                 :TPtPosF;
                                 constref rct_dst            :TPtRect;
                                 constref rad                :integer): boolean;       inline; {$ifdef Linux}[local];{$endif}

// (Point in Circle) Точка в окружности:
function IsPtInCrc              (constref x,y,prec           :integer;
                                 constref crc_dst            :TCrPos): boolean;        inline; {$ifdef Linux}[local];{$endif}
function IsPtInCrc              (constref x,y,prec           :integer;
                                 constref crc_dst            :TCrPosF): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInCrc              (constref x,y                :double;
                                 constref prec               :integer;
                                 constref crc_dst            :TCrPosF): boolean;       inline; {$ifdef Linux}[local];{$endif}

// (Distance Between Two Points) Расстояние между двумя точками:
function PtDist                 (constref x0,y0,x1,y1        :integer): double ;       inline; {$ifdef Linux}[local];{$endif}
function PtDist                 (constref x0,y0,x1,y1        :double ): double ;       inline; {$ifdef Linux}[local];{$endif}
function PtDistSqr              (constref x0,y0,x1,y1        :integer): integer;       inline; {$ifdef Linux}[local];{$endif}
function PtDistSqr              (constref x0,y0,x1,y1        :integer): double ;       inline; {$ifdef Linux}[local];{$endif}
function PtDistSqr              (constref x0,y0,x1,y1        :double ): double ;       inline; {$ifdef Linux}[local];{$endif}

// (Line-Line Intersection Point) Точка пересечение двух линий:
function LineLineIntPt          (constref x0,y0,x1,y1,
                                          v0,w0,v1,w1        :double):TPtPosF;         inline; {$ifdef Linux}[local];{$endif}

// (Line-Circle Intersection Point) Точка пересечение линии и окружности:
function LineCircIntPt          (constref x0,y0,x1,y1        :double;
                                 constref crc_dst            :TCrPosF): TLnPosF;       inline; {$ifdef Linux}[local];{$endif}
function LineCircIntPt          (constref x0,y0,x1,y1        :double;
                                 constref x,y,r              :double ): TLnPosF;       inline; {$ifdef Linux}[local];{$endif}
function CrPosF                 (constref x,y,r              :double ): TCrPosF;       inline; {$ifdef Linux}[local];{$endif}

(********************************** Blitters **********************************)

function  GetBmpHandle          (         bmp                :TBitmap): pointer;       inline;
procedure GLBitmapToRect        (         texture_id         :longint;
                                          bmp                :Graphics.TBitmap;
                                          b                  :boolean);                inline;
procedure CnvToCnv              (         rct_dst            :TPtRect;
                                          cnv_dst,
                                          cnv_src            :TCanvas;
                                          copy_mode          :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure BitBlt1               (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst_left,
                                          rct_dst_top,
                                          bmp_src_width,
                                          bmp_dst_width      :integer);
procedure BitBlt1               (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src_left,
                                          rct_src_top,
                                          rct_src_width,
                                          rct_src_height,
                                          rct_dst_left,
                                          rct_dst_top,
                                          bmp_src_width,
                                          bmp_dst_width      :integer);
procedure BitBlt1               (var      arr_src            :T1IntrArr;
                                 constref rct_src_width,
                                          rct_src_height,
                                          rct_dst_left,
                                          rct_dst_top        :integer);                        {$ifdef Linux}[local];{$endif}
procedure BitBlt2               (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst_left,
                                          rct_dst_top,
                                          bmp_src_width,
                                          bmp_dst_width      :integer);
procedure BitBlt2               (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src_left,
                                          rct_src_top,
                                          rct_src_width,
                                          rct_src_height,
                                          rct_dst_left,
                                          rct_dst_top,
                                          bmp_src_width,
                                          bmp_dst_width      :integer);
procedure BitBlt3               (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst_left,
                                          rct_dst_top,
                                          bmp_src_width,
                                          bmp_dst_width      :integer;
                                          transparent_color  :integer);
procedure BitBlt3               (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src_left,
                                          rct_src_top,
                                          rct_src_width,
                                          rct_src_height,
                                          rct_dst_left,
                                          rct_dst_top,
                                          bmp_src_width,
                                          bmp_dst_width      :integer;
                                          transparent_color  :integer);                        {$ifdef Linux}[local];{$endif}

(******************************* Image Transform ******************************)

// Scale:
procedure ITScaleDown           (constref bmp_src_ptr        :PInteger;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width,
                                          bmp_dst_height     :integer;
                                 constref ker_w,ker_h        :integer);                inline; {$ifdef Linux}[local];{$endif}

(******************************* Post-Processing ******************************)

procedure PPDec2ProcInit;                                                                      {$ifdef Linux}[local];{$endif}
procedure ArrFillProcInit;                                                                     {$ifdef Linux}[local];{$endif}
procedure PPBlurProcInit;                                                                      {$ifdef Linux}[local];{$endif}

// (Flood Fill) Заливка:
procedure PPFloodFillAdd        (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer);
procedure PPFloodFillSub        (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer);
procedure PPFloodFill           (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer;
                                 constref col                :integer);
procedure PPFloodFill           (constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :integer;
                                 constref rct_dst_width,
                                          rct_dst_height,
                                          first_pix_pos      :integer;
                                 constref col                :TColor);
procedure PPFloodFill           (constref bmp_dst            :Graphics.TBitmap;
                                 constref col                :TColor);                         {$ifdef Linux}[local];{$endif}

// (Additive) Аддитивное смешивание:
procedure PPAdditive            (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer;
                                 constref col                :TColor);
procedure PPAdditive            (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRectB;
                                 constref bmp_src_width,
                                          bmp_dst_width      :integer);
procedure PPAdditiveDec         (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer;
                                 constref col                :TColor;
                                 constref pow                :byte=64);
procedure PPAdditiveDec         (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRectB;
                                 constref bmp_src_width,
                                          bmp_dst_width      :integer;
                                 constref pow                :byte=64);

// (AlphaBlend) Полупрозрачность:
procedure PPAlphaBlend          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer;
                                 constref col                :TColor;
                                 constref pow                :byte=64);
procedure PPAlphaBlend          (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRectB;
                                 constref bmp_src_width,
                                          bmp_dst_width      :integer;
                                 constref pow                :byte=64);

// (Inverse) Инверсия:
procedure PPInverse             (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer);
procedure PPInverseDec          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer;
                                 constref pow                :byte=64);

// (HighLight) Подсветка:
procedure PPHighlight           (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer;
                                 constref pow                :byte=64);

// (Darken) Затемнение:
procedure PPDarken              (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer;
                                 constref pow                :byte=64);

// (GrayscaleR) Оттенок серого: красный канал:
procedure PPGrayscaleR          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer);
procedure PPGrayscaleRDec       (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer;
                                 constref pow                :byte=64);

// (GrayscaleG) Оттенок серого: красный канал:
procedure PPGrayscaleG          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer);
procedure PPGrayscaleGDec       (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer;
                                 constref pow                :byte=64);

// (GrayscaleB) Оттенок серого: красный канал:
procedure PPGrayscaleB          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer);
procedure PPGrayscaleBDec       (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer;
                                 constref pow                :byte=64);

// (Monochrome Noise) Монохромный шум:
procedure PPMonoNoise           (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer;
                                 constref col                :TColor);
procedure PPMonoNoiseDec        (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer;
                                 constref col                :TColor;
                                 constref pow                :byte=64);

// (Colorize) Окраска:
procedure PPColorCorrectionM0   (         ColorizeM          :TFunc0;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer;
                                 constref pow                :byte=32);
procedure PPColorCorrectionP0   (         ColorizeP          :TFunc0;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer;
                                 constref pow                :byte=32);
procedure PPColorCorrectionM0   (         ColorizeM          :TFunc0;
                                 constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRectB;
                                 constref bmp_src_width,
                                          bmp_dst_width      :integer;
                                 constref pow                :byte=32);
procedure PPColorCorrectionP0   (         ColorizeP          :TFunc0;
                                 constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRectB;
                                 constref bmp_src_width,
                                          bmp_dst_width      :integer;
                                 constref pow                :byte=32);
procedure PPColorCorrectionM1   (         ColorizeM          :TFunc1;
                                 constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRectB;
                                 constref bmp_src_width,
                                          bmp_dst_width      :integer;
                                 constref pow                :byte=32);
procedure PPColorCorrectionP1   (         ColorizeP          :TFunc1;
                                 constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRectB;
                                 constref bmp_src_width,
                                          bmp_dst_width      :integer;
                                 constref pow                :byte=32);

// (Blur) Размытие:
procedure PPBlurProc00          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer);
procedure PPBlurProc01          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer);
procedure PPBlurProc02          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer);
procedure PPBlurProc03          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer);
procedure PPBlurProc04          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer);
procedure PPBlurProc05          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer);
procedure PPBlurProc06          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer);
procedure PPBlurProc07          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer);
procedure PPBlurProc08          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer);
procedure PPBlurProc09          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer);
procedure PPBlurProc10          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer);
procedure PPBlurProc11          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer);
procedure PPBlur                (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :integer;
                                 constref blur_type          :byte=0;
                                 constref border_filter      :TBorderFilter=efNotTiled);
procedure PPBlur                (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRectB;
                                 constref bmp_src_width,
                                          bmp_dst_width      :integer;
                                 constref blur_type          :byte=0);

var

  PPDec2Proc : array[0..09] of TFunc2;
  ArrFillProc: array[0..09] of TProc5;
  PPBlurProc : array[0..11] of TProc6;

implementation

class operator TPtPosF.=(r1,r2:TPtPosF): boolean;                                                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(r1.x=r2.x) and (r1.y=r2.y);
end;  {$endregion}
class operator TPtPos2.=(r1,r2:TPtPos2): boolean;                                                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(r1*r2) and (r1.obj_ind=r2.obj_ind) and (r1.dup_pts_cnt=r2.dup_pts_cnt);
end;  {$endregion}
class operator TPtPos2.*(r1,r2:TPtPos2): boolean;                                                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(r1.arr[0]=r2.arr[0]) and
          (r1.arr[1]=r2.arr[1]) and
          (r1.arr[2]=r2.arr[2]) and
          (r1.arr[3]=r2.arr[3]) and
          (r1.arr[4]=r2.arr[4]) and
          (r1.arr[5]=r2.arr[5]);
end;  {$endregion}
procedure      TPtPos2.SetEqual0(var r1:TPtPos2; constref r2:TPtPos2);                                                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  r1.dup_pts_cnt:=r2.dup_pts_cnt;
  r1.arr[0]     :=r2.arr[0];
  r1.arr[1]     :=r2.arr[1];
  r1.arr[2]     :=r2.arr[2];
  r1.arr[3]     :=r2.arr[3];
  r1.arr[4]     :=r2.arr[4];
  r1.arr[5]     :=r2.arr[5];
  //SetEqual2(r1,r2);
end; {$endregion}
procedure      TPtPos2.SetEqual1(var r1:TPtPos2; constref r2:TPtPos2);                                                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  r1.obj_ind    :=-1{r2.obj_ind};
  r1.dup_pts_cnt:=r2.dup_pts_cnt;
  r1.arr[0]     :=r2.arr[0];
  r1.arr[1]     :=r2.arr[1];
  r1.arr[2]     :=r2.arr[2];
  r1.arr[3]     :=r2.arr[3];
  r1.arr[4]     :=r2.arr[4];
  r1.arr[5]     :=r2.arr[5];
  //SetEqual2(r1,r2);
end; {$endregion}
procedure      TPtPos2.SetEqual2(var r1:TPtPos2; constref r2:TPtPos2);                                                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  r1.arr[0]:=r2.arr[0];
  r1.arr[1]:=r2.arr[1];
  r1.arr[2]:=r2.arr[2];
  r1.arr[3]:=r2.arr[3];
  r1.arr[4]:=r2.arr[4];
  r1.arr[5]:=r2.arr[5];
end; {$endregion}
function       TPtPos2.IsEqual  (r1,r2 :TPtPos2): boolean;                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=
  (r1.arr[0]=r2.arr[0]) and
  (r1.arr[1]=r2.arr[1]) and
  (r1.arr[2]=r2.arr[2]) and
  (r1.arr[3]=r2.arr[3]) and
  (r1.arr[4]=r2.arr[4]) and
  (r1.arr[5]=r2.arr[5]);
end; {$endregion}
function GetEnumVal(enum:TDrawingStyle): integer;                                                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=GetEnumValue(TypeInfo(enum),GetEnumName(TypeInfo(enum),Ord(enum)));
end; {$endregion}
function Min(constref a1,a2:double                                                                               ): double ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if a1<a2 then
    Result:=a1
  else
    Result:=a2;
end; {$endregion}
function Min(constref a1,a2:integer                                                                              ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if a1<a2 then
    Result:=a1
  else
    Result:=a2;
end; {$endregion}
function Min(constref arr:T1IntrArr; constref max_item_val:integer; constref item_cnt:integer                    ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=max_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]<=Result) then
      Result:=arr[i];
end; {$endregion}
function Min(constref arr:T1IntrArr; constref max_item_val:integer; constref item_cnt:integer; constref b:boolean): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,a: integer;
begin
  Min:=0;
  a  :=max_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]<=a) then
      begin
        a  :=arr[i];
        Min:=i;
      end;
end; {$endregion}
function Min(constref arr:T1EdgeArr; constref max_item_val:integer; constref item_cnt:integer                    ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=max_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i].obj_ind<=Result) then
      Result:=arr[i].obj_ind;
end; {$endregion}
function Max(constref a1,a2:double                                                                               ): double ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if a1>a2 then
    Result:=a1
  else
    Result:=a2;
end; {$endregion}
function Max(constref a1,a2:integer                                                                              ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if a1>a2 then
    Result:=a1
  else
    Result:=a2;
end; {$endregion}
function Max(constref arr:T1IntrArr; constref min_item_val:integer; constref item_cnt:integer                    ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=min_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]>=Result) then
      Result:=arr[i];
end; {$endregion}
function Max(constref arr:T1IntrArr; constref min_item_val:integer; constref item_cnt:integer; constref b:boolean): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,a: integer;
begin
  Max:=0;
  a  :=min_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]>=a) then
      begin
        a  :=arr[i];
        Max:=i;
      end;
end; {$endregion}
function Max(constref arr:T1EdgeArr; constref min_item_val:integer; constref item_cnt:integer                    ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=min_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i].obj_ind>=Result) then
      Result:=arr[i].obj_ind;
end; {$endregion}
function InvSqrt(constref x:single): single;                                                                                 inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  result_as_int: UInt32 absolute Result;
begin
  Result       :=x;
  result_as_int:=$5F3759DF-(result_as_int>>1);
  Result       *=(1.5-(x*0.5*Result*Result));
end; {$endregion}
procedure PtrInit(var ptr:PInteger; constref arr:T1IntrArr);                                                                 inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (Length(arr)<>0) then
    ptr:=@arr[0];
end; {$endregion}
procedure MaxSpriteWHRctInit(var rct:TPtRect);                                                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  rct:=PtBounds
  (
    0,
    0,
    MAX_SPRITE_WIDTH,
    MAX_SPRITE_HEIGHT
  )
end; {$endregion}
function ArcTan4(constref x0,y0,x1,y1:double): double;                                                                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v1,w1,k,b,dx: double;
  angle       : double;
begin
  if (x1=x0) then
    begin
      Result:=pi/2;
      Exit;
    end;
  if (y1=y0) then
    begin
      Result:=0;
      Exit;
    end;
  angle:=Abs(ArcTan((y1-y0)/(x1-x0)));
  if ((y1>y0) and (x1>x0)) or
     ((y1<y0) and (x1<x0)) then
    Result:=angle
  else
  if ((y1>y0) and (x1<x0)) or
     ((y1<y0) and (x1>x0)) then
    Result:=pi-angle;
end; {$endregion}

// (Binary Search) Бинарный поиск:
function BinarySearch(constref n:integer; constref arr_item_ptr:PInteger; constref right_border:integer):integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  a,b: integer;
begin
  a:=0;
  b:=n-1;
  Result:=(a+b)>>1;
  while ((b-a)>1) do
    begin
      if ((arr_item_ptr+Result)^<right_border) then
        a:=Result
      else
        b:=Result;
      Result:=(a+b)>>1;
    end;
end; {$endregion}

// (Interpolation search) Интерполирующий поиск:
{TODO}

// Store Color Channel into Integer Array:
procedure BmpToArr(constref bmp_src_ptr:PInteger; var bmp_dst_ptr:PInteger; var arr_dst:T1IntrArr; constref bmp_src_rct:TPtRect; constref bmp_src_width,bmp_src_height:integer; var bmp_dst_width,bmp_dst_height:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  bmp_src_rct_clp: TPtRect;
begin
  with bmp_src_rct_clp do
    begin
      bmp_src_rct_clp:=ClippedRct(PtBounds(0,0,bmp_src_width,bmp_src_height),bmp_src_rct);
      SetLength(arr_dst,width*height);
      bmp_dst_ptr:=Unaligned(@arr_dst[0]);
      if (width=bmp_src_width) and (height=bmp_src_height) then
        Move(bmp_src_ptr^,(@arr_dst[0])^,(width*height)<<2)
      else
        BitBlt2(bmp_src_ptr,bmp_dst_ptr,bmp_src_rct_clp,0,0,bmp_src_width,width);
      bmp_dst_width :=width;
      bmp_dst_height:=height;
    end;
end; {$endregion}

// Store Alpha Channel into Byte Array:
{TODO}



(****************************** Color Transform *******************************)

function Red           (pixel:integer): byte;   inline; {$ifdef Linux}[local]; {$endif} {$region -fold}
begin
  Result:=(pixel>>00) and $000000ff;
end; {$endregion}
function Green         (pixel:integer): byte;   inline; {$ifdef Linux}[local]; {$endif} {$region -fold}
begin
  Result:=(pixel>>08) and $000000ff;
end; {$endregion}
function Blue          (pixel:integer): byte;   inline; {$ifdef Linux}[local]; {$endif} {$region -fold}
begin
  Result:=(pixel>>16) and $000000ff;
end; {$endregion}
function RGB           (r,g,b:byte   ): TColor; inline; {$ifdef Linux}[local]; {$endif} {$region -fold}
begin
  Result:=(b<<16) or (g<<08) or r;
end; {$endregion}

// Regular Effect:
function SetColorInv   (pixel:integer; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Blue (pixel),
              Green(pixel),
              Red  (pixel));
end; {$endregion}
function Additive      (pixel:integer; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Min(Red  (pixel)+b,255),
              Min(Green(pixel)+g,255),
              Min(Blue (pixel)+r,255));
end; {$endregion}
procedure AlphaBlend   (pixel_ptr:PInteger; constref r,g,b:byte;                                                       constref d_alpha:byte                                                 );          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=(((Blue (pixel_ptr^)-r)*d_alpha)>>8+r)<<16+
              (((Green(pixel_ptr^)-g)*d_alpha)>>8+g)<<08+
              (((Red  (pixel_ptr^)-b)*d_alpha)>>8+b)<<00;
end; {$endregion}
function AlphaBlend    (pixel:integer; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=   (((Blue (pixel)-r)*d_alpha)>>8+r)<<16+
             (((Green(pixel)-g)*d_alpha)>>8+g)<<08+
             (((Red  (pixel)-b)*d_alpha)>>8+b)<<00;
         {RGB(((Red  (pixel)-b)*d_alpha+b<<8-b)>>8,
              ((Green(pixel)-g)*d_alpha+g<<8-g)>>8,
              ((Blue (pixel)-r)*d_alpha+r<<8-r)>>8);}
         {RGB(((Red  (pixel)-b)*d_alpha)>>8+b,
              ((Green(pixel)-g)*d_alpha)>>8+g,
              ((Blue (pixel)-r)*d_alpha)>>8+r);}
         {RGB((Red  (pixel)*d_alpha+b*alpha)>>8,
              (Green(pixel)*d_alpha+g*alpha)>>8,
              (Blue (pixel)*d_alpha+r*alpha)>>8);}
end; {$endregion}
function Inverse       (pixel:integer                                                                                                                                                        ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=Integer($ffffffff-pixel);
end; {$endregion}
function Highlight     (pixel:integer; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Min(Red  (pixel)+pow,255),
              Min(Green(pixel)+pow,255),
              Min(Blue (pixel)+pow,255));
end; {$endregion}
function Darken        (pixel:integer; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Max(Red  (pixel)-pow,0),
              Max(Green(pixel)-pow,0),
              Max(Blue (pixel)-pow,0));
end; {$endregion}
function GrayscaleR    (pixel:integer; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Red(pixel),
              Red(pixel),
              Red(pixel));
end; {$endregion}
function GrayscaleG    (pixel:integer; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Green(pixel),
              Green(pixel),
              Green(pixel));
end; {$endregion}
function GrayscaleB    (pixel:integer; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Blue(pixel),
              Blue(pixel),
              Blue(pixel));
end; {$endregion}
function ColorizeRM    (pixel:integer; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
begin
  v:=Red(pixel)+d;
  if (v<000) then
    Result:=pixel-Blue(pixel)<<16
  else
    Result:=pixel-Blue(pixel)<<16+Byte(v)<<16;
end; {$endregion}
function ColorizeRP    (pixel:integer; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
begin
  v:=Red(pixel)+d;
  if (v>255) then
    Result:=pixel-Blue(pixel)<<16+255<<16
  else
    Result:=pixel-Blue(pixel)<<16+Byte(v)<<16;
end; {$endregion}
function ColorizeGM    (pixel:integer; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
begin
  v:=Green(pixel)+d;
  if (v<000) then
    Result:=pixel-Green(pixel)<<08
  else
    Result:=pixel-Green(pixel)<<08+Byte(v)<<08;
end; {$endregion}
function ColorizeGP    (pixel:integer; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
begin
  v:=Green(pixel)+d;;
  if (v>255) then
    Result:=pixel-Green(pixel)<<08+255<<08
  else
    Result:=pixel-Green(pixel)<<08+Byte(v)<<08;
end; {$endregion}
function ColorizeBM    (pixel:integer; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
begin
  v:=Blue(pixel)+d;
  if (v<000) then
    Result:=pixel-Red(pixel)<<00
  else
    Result:=pixel-Red(pixel)<<00+Byte(v)<<00;
end; {$endregion}
function ColorizeBP    (pixel:integer; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
begin
  v:=Blue(pixel)+d;
  if (v>255) then
    Result:=pixel-Red(pixel)<<00+255<<00
  else
    Result:=pixel-Red(pixel)<<00+Byte(v)<<00;
end; {$endregion}

// Decrease Effect:
function AdditiveDec   (pixel:integer; constref r,g,b:byte;                     constref alpha_fade:byte                                        ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin

  if   (Min(Red  (pixel)+b,255)>Red(pixel)) then
    r_:=Min(Red  (pixel)+b,255)-((alpha_fade*(Abs(Min(Red  (pixel)+b,255)-Red  (pixel))))>>8)
  else
    r_:=Min(Red  (pixel)+b,255)+((alpha_fade*(Abs(Min(Red  (pixel)+b,255)-Red  (pixel))))>>8);

  if   (Min(Green(pixel)+g,255)>Green(pixel)) then
    g_:=Min(Green(pixel)+g,255)-((alpha_fade*(Abs(Min(Green(pixel)+g,255)-Green(pixel))))>>8)
  else
    g_:=Min(Green(pixel)+g,255)+((alpha_fade*(Abs(Min(Green(pixel)+g,255)-Green(pixel))))>>8);

  if   (Min(Blue (pixel)+r,255)>Blue (pixel)) then
    b_:=Min(Blue (pixel)+r,255)-((alpha_fade*(Abs(Min(Blue (pixel)+r,255)-Blue (pixel))))>>8)
  else
    b_:=Min(Blue (pixel)+r,255)+((alpha_fade*(Abs(Min(Blue (pixel)+r,255)-Blue (pixel))))>>8);

  Result:=RGBToColor(r_,g_,b_);

end; {$endregion}
function AdditiveDec2  (pixel:integer; constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin

  if   (Min(Red  (pixel)+b,255)>Red(pixel)) then
    r_:=Min(Red  (pixel)+b,255)-((alpha_fade*(Abs(Min(Red  (pixel)+b,255)-Red  (pixel))))>>8)
  else
    r_:=Min(Red  (pixel)+b,255)+((alpha_fade*(Abs(Min(Red  (pixel)+b,255)-Red  (pixel))))>>8);

  if   (Min(Green(pixel)+g,255)>Green(pixel)) then
    g_:=Min(Green(pixel)+g,255)-((alpha_fade*(Abs(Min(Green(pixel)+g,255)-Green(pixel))))>>8)
  else
    g_:=Min(Green(pixel)+g,255)+((alpha_fade*(Abs(Min(Green(pixel)+g,255)-Green(pixel))))>>8);

  if   (Min(Blue (pixel)+r,255)>Blue (pixel)) then
    b_:=Min(Blue (pixel)+r,255)-((alpha_fade*(Abs(Min(Blue (pixel)+r,255)-Blue (pixel))))>>8)
  else
    b_:=Min(Blue (pixel)+r,255)+((alpha_fade*(Abs(Min(Blue (pixel)+r,255)-Blue (pixel))))>>8);

  Result:=RGBToColor(r_,g_,b_);

end; {$endregion}
function AlphaBlendDec (pixel:integer; constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte                                        ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  alpha  :=Max(alpha-alpha_fade,0);
  d_alpha:=255-alpha;
  Result:=(((Blue (pixel)-r)*d_alpha)>>8+r)<<16+
          (((Green(pixel)-g)*d_alpha)>>8+g)<<08+
          (((Red  (pixel)-b)*d_alpha)>>8+b)<<00;
       {RGB((b*alpha+d_alpha*Red  (pixel))>>8,
            (g*alpha+d_alpha*Green(pixel))>>8,
            (r*alpha+d_alpha*Blue (pixel))>>8);}
end; {$endregion}
function AlphaBlendDec2(pixel:integer; constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  alpha  :=Max(alpha-Byte(d){alpha_fade},0);
  d_alpha:=255-alpha;
  Result:=(((Blue (pixel)-r)*d_alpha)>>8+r)<<16+
          (((Green(pixel)-g)*d_alpha)>>8+g)<<08+
          (((Red  (pixel)-b)*d_alpha)>>8+b)<<00;
       {RGB((b*alpha+d_alpha*Red  (pixel))>>8,
            (g*alpha+d_alpha*Green(pixel))>>8,
            (r*alpha+d_alpha*Blue (pixel))>>8);}
end; {$endregion}
function InverseDec    (pixel:integer;                                          constref alpha_fade:byte                                        ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r,g,b: byte;
begin

  if  (255>Red  (pixel)<<1) then
    r:=255-Red  (pixel)-((alpha_fade*(Abs(255-Red  (pixel)<<1)))>>8)
  else
    r:=255-Red  (pixel)+((alpha_fade*(Abs(255-Red  (pixel)<<1)))>>8);

  if  (255>Green(pixel)<<1) then
    g:=255-Green(pixel)-((alpha_fade*(Abs(255-Green(pixel)<<1)))>>8)
  else
    g:=255-Green(pixel)+((alpha_fade*(Abs(255-Green(pixel)<<1)))>>8);

  if  (255>Blue (pixel)<<1) then
    b:=255-Blue (pixel)-((alpha_fade*(Abs(255-Blue (pixel)<<1)))>>8)
  else
    b:=255-Blue (pixel)+((alpha_fade*(Abs(255-Blue (pixel)<<1)))>>8);

  Result:=RGB(r,g,b);

end; {$endregion}
function InverseDec2   (pixel:integer; constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin

  if   (255>Red  (pixel)<<1) then
    r_:=255-Red  (pixel)-((alpha_fade*(Abs(255-Red  (pixel)<<1)))>>8)
  else
    r_:=255-Red  (pixel)+((alpha_fade*(Abs(255-Red  (pixel)<<1)))>>8);

  if   (255>Green(pixel)<<1) then
    g_:=255-Green(pixel)-((alpha_fade*(Abs(255-Green(pixel)<<1)))>>8)
  else
    g_:=255-Green(pixel)+((alpha_fade*(Abs(255-Green(pixel)<<1)))>>8);

  if   (255>Blue (pixel)<<1) then
    b_:=255-Blue (pixel)-((alpha_fade*(Abs(255-Blue (pixel)<<1)))>>8)
  else
    b_:=255-Blue (pixel)+((alpha_fade*(Abs(255-Blue (pixel)<<1)))>>8);

  Result:=RGB(r_,g_,b_);

end; {$endregion}
function HighlightDec  (pixel:integer;                                          constref alpha_fade:byte; constref pow:byte=64                  ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r,g,b: byte;
begin

  if  (Min(Red  (pixel)+pow,255)>Red(pixel)) then
    r:=Min(Red  (pixel)+pow,255)-((alpha_fade*(Abs(Min(Red  (pixel)+pow,255)-Red  (pixel))))>>8)
  else
    r:=Min(Red  (pixel)+pow,255)+((alpha_fade*(Abs(Min(Red  (pixel)+pow,255)-Red  (pixel))))>>8);

  if  (Min(Green(pixel)+pow,255)>Green(pixel)) then
    g:=Min(Green(pixel)+pow,255)-((alpha_fade*(Abs(Min(Green(pixel)+pow,255)-Green(pixel))))>>8)
  else
    g:=Min(Green(pixel)+pow,255)+((alpha_fade*(Abs(Min(Green(pixel)+pow,255)-Green(pixel))))>>8);

  if  (Min(Blue (pixel)+pow,255)>Blue (pixel)) then
    b:=Min(Blue (pixel)+pow,255)-((alpha_fade*(Abs(Min(Blue (pixel)+pow,255)-Blue (pixel))))>>8)
  else
    b:=Min(Blue (pixel)+pow,255)+((alpha_fade*(Abs(Min(Blue (pixel)+pow,255)-Blue (pixel))))>>8);

  Result:=RGB(r,g,b);

end; {$endregion}
function HighlightDec2 (pixel:integer; constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin

  if   (Min(Red  (pixel)+pow,255)>Red(pixel)) then
    r_:=Min(Red  (pixel)+pow,255)-((alpha_fade*(Abs(Min(Red  (pixel)+pow,255)-Red  (pixel))))>>8)
  else
    r_:=Min(Red  (pixel)+pow,255)+((alpha_fade*(Abs(Min(Red  (pixel)+pow,255)-Red  (pixel))))>>8);

  if   (Min(Green(pixel)+pow,255)>Green(pixel)) then
    g_:=Min(Green(pixel)+pow,255)-((alpha_fade*(Abs(Min(Green(pixel)+pow,255)-Green(pixel))))>>8)
  else
    g_:=Min(Green(pixel)+pow,255)+((alpha_fade*(Abs(Min(Green(pixel)+pow,255)-Green(pixel))))>>8);

  if   (Min(Blue (pixel)+pow,255)>Blue (pixel)) then
    b_:=Min(Blue (pixel)+pow,255)-((alpha_fade*(Abs(Min(Blue (pixel)+pow,255)-Blue (pixel))))>>8)
  else
    b_:=Min(Blue (pixel)+pow,255)+((alpha_fade*(Abs(Min(Blue (pixel)+pow,255)-Blue (pixel))))>>8);

  Result:=RGB(r_,g_,b_);

end; {$endregion}
function DarkenDec     (pixel:integer;                                          constref alpha_fade:byte; constref pow:byte=64                  ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r,g,b: byte;
begin

  if  (Max(Red  (pixel)-pow,0)>Red(pixel)) then
    r:=Max(Red  (pixel)-pow,0)-((alpha_fade*(Abs(Max(Red  (pixel)-pow,0)-Red  (pixel))))>>8)
  else
    r:=Max(Red  (pixel)-pow,0)+((alpha_fade*(Abs(Max(Red  (pixel)-pow,0)-Red  (pixel))))>>8);

  if  (Max(Green(pixel)-pow,0)>Green(pixel)) then
    g:=Max(Green(pixel)-pow,0)-((alpha_fade*(Abs(Max(Green(pixel)-pow,0)-Green(pixel))))>>8)
  else
    g:=Max(Green(pixel)-pow,0)+((alpha_fade*(Abs(Max(Green(pixel)-pow,0)-Green(pixel))))>>8);

  if  (Max(Blue (pixel)-pow,0)>Blue (pixel)) then
    b:=Max(Blue (pixel)-pow,0)-((alpha_fade*(Abs(Max(Blue (pixel)-pow,0)-Blue (pixel))))>>8)
  else
    b:=Max(Blue (pixel)-pow,0)+((alpha_fade*(Abs(Max(Blue (pixel)-pow,0)-Blue (pixel))))>>8);

  Result:=RGB(r,g,b);

end; {$endregion}
function DarkenDec2    (pixel:integer; constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin

  if   (Max(Red  (pixel)-pow,0)>Red(pixel)) then
    r_:=Max(Red  (pixel)-pow,0)-((alpha_fade*(Abs(Max(Red  (pixel)-pow,0)-Red  (pixel))))>>8)
  else
    r_:=Max(Red  (pixel)-pow,0)+((alpha_fade*(Abs(Max(Red  (pixel)-pow,0)-Red  (pixel))))>>8);

  if   (Max(Green(pixel)-pow,0)>Green(pixel)) then
    g_:=Max(Green(pixel)-pow,0)-((alpha_fade*(Abs(Max(Green(pixel)-pow,0)-Green(pixel))))>>8)
  else
    g_:=Max(Green(pixel)-pow,0)+((alpha_fade*(Abs(Max(Green(pixel)-pow,0)-Green(pixel))))>>8);

  if   (Max(Blue (pixel)-pow,0)>Blue (pixel)) then
    b_:=Max(Blue (pixel)-pow,0)-((alpha_fade*(Abs(Max(Blue (pixel)-pow,0)-Blue (pixel))))>>8)
  else
    b_:=Max(Blue (pixel)-pow,0)+((alpha_fade*(Abs(Max(Blue (pixel)-pow,0)-Blue (pixel))))>>8);

  Result:=RGB(r_,g_,b_);

end; {$endregion}
function GrayscaleRDec (pixel:integer;                                          constref alpha_fade:byte                                        ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r,g,b: byte;
begin

    r:=Red  (pixel);

  if  (Green(pixel)>Red(pixel)) then
    g:=Green(pixel)-((alpha_fade*(Abs(Green(pixel)-Red(pixel))))>>8)
  else
    g:=Green(pixel)+((alpha_fade*(Abs(Green(pixel)-Red(pixel))))>>8);

  if  (Blue (pixel)>Red(pixel)) then
    b:=Blue (pixel)-((alpha_fade*(Abs(Blue (pixel)-Red(pixel))))>>8)
  else
    b:=Blue (pixel)+((alpha_fade*(Abs(Blue (pixel)-Red(pixel))))>>8);

  Result:=RGB(r,g,b);

end; {$endregion}
function GrayscaleRDec2(pixel:integer; constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin

    r_:=Red  (pixel);

  if   (Green(pixel)>Red(pixel)) then
    g_:=Green(pixel)-((d*(Abs(Green(pixel)-Red(pixel))))>>8)
  else
    g_:=Green(pixel)+((d*(Abs(Green(pixel)-Red(pixel))))>>8);

  if   (Blue (pixel)>Red(pixel)) then
    b_:=Blue (pixel)-((d*(Abs(Blue (pixel)-Red(pixel))))>>8)
  else
    b_:=Blue (pixel)+((d*(Abs(Blue (pixel)-Red(pixel))))>>8);

  Result:=RGB(r_,g_,b_);

end; {$endregion}
function GrayscaleGDec (pixel:integer;                                          constref alpha_fade:byte                                        ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r,g,b: byte;
begin

  if  (Red  (pixel)>Green(pixel)) then
    r:=Red  (pixel)-((alpha_fade*(Abs(Red  (pixel)-Green(pixel))))>>8)
  else
    r:=Red  (pixel)+((alpha_fade*(Abs(Red  (pixel)-Green(pixel))))>>8);

    g:=Green(pixel);

  if  (Blue (pixel)>Green(pixel)) then
    b:=Blue (pixel)-((alpha_fade*(Abs(Blue (pixel)-Green(pixel))))>>8)
  else
    b:=Blue (pixel)+((alpha_fade*(Abs(Blue (pixel)-Green(pixel))))>>8);

  Result:=RGB(r,g,b);

end; {$endregion}
function GrayscaleGDec2(pixel:integer; constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin

  if   (Red  (pixel)>Green(pixel)) then
    r_:=Red  (pixel)-((alpha_fade*(Abs(Red  (pixel)-Green(pixel))))>>8)
  else
    r_:=Red  (pixel)+((alpha_fade*(Abs(Red  (pixel)-Green(pixel))))>>8);

    g_:=Green(pixel);

  if   (Blue (pixel)>Green(pixel)) then
    b_:=Blue (pixel)-((alpha_fade*(Abs(Blue (pixel)-Green(pixel))))>>8)
  else
    b_:=Blue (pixel)+((alpha_fade*(Abs(Blue (pixel)-Green(pixel))))>>8);

  Result:=RGB(r_,g_,b_);

end; {$endregion}
function GrayscaleBDec (pixel:integer;                                          constref alpha_fade:byte                                        ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r,g,b: byte;
begin

  if  (Red  (pixel)>Blue(pixel)) then
    r:=Red  (pixel)-((alpha_fade*(Abs(Red  (pixel)-Blue(pixel))))>>8)
  else
    r:=Red  (pixel)+((alpha_fade*(Abs(Red  (pixel)-Blue(pixel))))>>8);

  if  (Green(pixel)>Blue(pixel)) then
    g:=Green(pixel)-((alpha_fade*(Abs(Green(pixel)-Blue(pixel))))>>8)
  else
    g:=Green(pixel)+((alpha_fade*(Abs(Green(pixel)-Blue(pixel))))>>8);

    b:=Blue (pixel);

  Result:=RGB(r,g,b);

end; {$endregion}
function GrayscaleBDec2(pixel:integer; constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin

  if   (Red  (pixel)>Blue(pixel)) then
    r_:=Red  (pixel)-((alpha_fade*(Abs(Red  (pixel)-Blue(pixel))))>>8)
  else
    r_:=Red  (pixel)+((alpha_fade*(Abs(Red  (pixel)-Blue(pixel))))>>8);

  if   (Green(pixel)>Blue(pixel)) then
    g_:=Green(pixel)-((alpha_fade*(Abs(Green(pixel)-Blue(pixel))))>>8)
  else
    g_:=Green(pixel)+((alpha_fade*(Abs(Green(pixel)-Blue(pixel))))>>8);

    b_:=Blue (pixel);

  Result:=RGB(r_,g_,b_);

end; {$endregion}
function ColorizeRMDec (pixel:integer;                                          constref alpha_fade:byte;                    constref d:smallint): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
  b: byte;
begin
  v:=Red(pixel)+d;
  if (v<000) then
    b:=(alpha_fade*Blue(pixel))>>8
  else
    begin
      if  (Byte(v)>Blue(pixel)) then
        b:=Byte(v)-(alpha_fade*(Abs(Byte(v)-Blue(pixel))))>>8
      else
        b:=Byte(v)+(alpha_fade*(Abs(Byte(v)-Blue(pixel))))>>8;
    end;
  Result:=pixel-Blue(pixel)<<16+b<<16;
end; {$endregion}
function ColorizeRMDec2(pixel:integer; constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
  b_: byte;
begin
  v:=Red(pixel)+d;
  if (v<000) then
    b_:=(alpha_fade*Blue(pixel))>>8
  else
    begin
      if  (Byte(v)>Blue(pixel)) then
        b_:=Byte(v)-(alpha_fade*(Abs(Byte(v)-Blue(pixel))))>>8
      else
        b_:=Byte(v)+(alpha_fade*(Abs(Byte(v)-Blue(pixel))))>>8;
    end;
  Result:=pixel-Blue(pixel)<<16+b_<<16;
end; {$endregion}
function ColorizeRPDec (pixel:integer;                                          constref alpha_fade:byte;                    constref d:smallint): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
  b: byte;
begin
  v:=Red(pixel)+d;
  if (v>255) then
    begin
      if  (255>Blue(pixel)) then
        b:=255-(alpha_fade*(Abs(255-Blue(pixel))))>>8
      else
        b:=255+(alpha_fade*(Abs(255-Blue(pixel))))>>8
    end
  else
    begin
      if  (Byte(v)>Blue(pixel)) then
        b:=Byte(v)-(alpha_fade*(Abs(Byte(v)-Blue(pixel))))>>8
      else
        b:=Byte(v)+(alpha_fade*(Abs(Byte(v)-Blue(pixel))))>>8;
    end;
  Result:=pixel-Blue(pixel)<<16+b<<16;
end; {$endregion}
function ColorizeRPDec2(pixel:integer; constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
  b_: byte;
begin
  v:=Red(pixel)+d;
  if (v>255) then
    begin
      if  (255>Blue(pixel)) then
        b_:=255-(alpha_fade*(Abs(255-Blue(pixel))))>>8
      else
        b_:=255+(alpha_fade*(Abs(255-Blue(pixel))))>>8
    end
  else
    begin
      if  (Byte(v)>Blue(pixel)) then
        b_:=Byte(v)-(alpha_fade*(Abs(Byte(v)-Blue(pixel))))>>8
      else
        b_:=Byte(v)+(alpha_fade*(Abs(Byte(v)-Blue(pixel))))>>8;
    end;
  Result:=pixel-Blue(pixel)<<16+b_<<16;
end; {$endregion}
function ColorizeGMDec (pixel:integer;                                          constref alpha_fade:byte;                    constref d:smallint): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
  g: byte;
begin
  v:=Green(pixel)+d;
  if (v<000) then
    g:=(alpha_fade*Green(pixel))>>8
  else
    begin
      if  (Byte(v)>Green(pixel)) then
        g:=Byte(v)-(alpha_fade*(Abs(Byte(v)-Green(pixel))))>>8
      else
        g:=Byte(v)+(alpha_fade*(Abs(Byte(v)-Green(pixel))))>>8;
    end;
  Result:=pixel-Green(pixel)<<08+g<<08;
end; {$endregion}
function ColorizeGMDec2(pixel:integer; constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
  g_: byte;
begin
  v:=Green(pixel)+d;
  if (v<000) then
    g_:=(alpha_fade*Green(pixel))>>8
  else
    begin
      if  (Byte(v)>Green(pixel)) then
        g_:=Byte(v)-(alpha_fade*(Abs(Byte(v)-Green(pixel))))>>8
      else
        g_:=Byte(v)+(alpha_fade*(Abs(Byte(v)-Green(pixel))))>>8;
    end;
  Result:=pixel-Green(pixel)<<08+g_<<08;
end; {$endregion}
function ColorizeGPDec (pixel:integer;                                          constref alpha_fade:byte;                    constref d:smallint): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
  g: byte;
begin
  v:=Green(pixel)+d;
  if (v>255) then
    begin
      if  (255>Green(pixel)) then
        g:=255-(alpha_fade*(Abs(255-Green(pixel))))>>8
      else
        g:=255+(alpha_fade*(Abs(255-Green(pixel))))>>8;
    end
  else
    begin
      if  (Byte(v)>Green(pixel)) then
        g:=Byte(v)-(alpha_fade*(Abs(Byte(v)-Green(pixel))))>>8
      else
        g:=Byte(v)+(alpha_fade*(Abs(Byte(v)-Green(pixel))))>>8;
    end;
  Result:=pixel-Green(pixel)<<08+g<<08;
end; {$endregion}
function ColorizeGPDec2(pixel:integer; constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
  g_: byte;
begin
  v:=Green(pixel)+d;
  if (v>255) then
    begin
      if  (255>Green(pixel)) then
        g_:=255-(alpha_fade*(Abs(255-Green(pixel))))>>8
      else
        g_:=255+(alpha_fade*(Abs(255-Green(pixel))))>>8;
    end
  else
    begin
      if  (Byte(v)>Green(pixel)) then
        g_:=Byte(v)-(alpha_fade*(Abs(Byte(v)-Green(pixel))))>>8
      else
        g_:=Byte(v)+(alpha_fade*(Abs(Byte(v)-Green(pixel))))>>8;
    end;
  Result:=pixel-Green(pixel)<<08+g_<<08;
end; {$endregion}
function ColorizeBMDec (pixel:integer;                                          constref alpha_fade:byte;                    constref d:smallint): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
  r: byte;
begin
  v:=Blue(pixel)+d;
  if (v<000) then
    r:=(alpha_fade*Red(pixel))>>8
  else
    begin
      if  (Byte(v)>Red(pixel)) then
        r:=Byte(v)-(alpha_fade*(Abs(Byte(v)-Red(pixel))))>>8
      else
        r:=Byte(v)+(alpha_fade*(Abs(Byte(v)-Red(pixel))))>>8;
    end;
  Result:=pixel-Red(pixel)<<00+r<<00;
end; {$endregion}
function ColorizeBMDec2(pixel:integer; constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
  r_: byte;
begin
  v:=Blue(pixel)+d;
  if (v<000) then
    r_:=(alpha_fade*Red(pixel))>>8
  else
    begin
      if  (Byte(v)>Red(pixel)) then
        r_:=Byte(v)-(alpha_fade*(Abs(Byte(v)-Red(pixel))))>>8
      else
        r_:=Byte(v)+(alpha_fade*(Abs(Byte(v)-Red(pixel))))>>8;
    end;
  Result:=pixel-Red(pixel)<<00+r_<<00;
end; {$endregion}
function ColorizeBPDec (pixel:integer;                                          constref alpha_fade:byte;                    constref d:smallint): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
  r: byte;
begin
  v:=Blue(pixel)+d;
  if (v>255) then
    begin
      if  (255>Red(pixel)) then
        r:=255-(alpha_fade*(Abs(255-Red(pixel))))>>8
      else
        r:=255+(alpha_fade*(Abs(255-Red(pixel))))>>8
    end
  else
    begin
      if  (Byte(v)>Red(pixel)) then
        r:=Byte(v)-(alpha_fade*(Abs(Byte(v)-Red(pixel))))>>8
      else
        r:=Byte(v)+(alpha_fade*(Abs(Byte(v)-Red(pixel))))>>8;
    end;
  Result:=pixel-Red(pixel)<<00+r<<00;
end; {$endregion}
function ColorizeBPDec2(pixel:integer; constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
  r_: byte;
begin
  v:=Blue(pixel)+d;
  if (v>255) then
    begin
      if  (255>Red(pixel)) then
        r_:=255-(alpha_fade*(Abs(255-Red(pixel))))>>8
      else
        r_:=255+(alpha_fade*(Abs(255-Red(pixel))))>>8
    end
  else
    begin
      if  (Byte(v)>Red(pixel)) then
        r_:=Byte(v)-(alpha_fade*(Abs(Byte(v)-Red(pixel))))>>8
      else
        r_:=Byte(v)+(alpha_fade*(Abs(Byte(v)-Red(pixel))))>>8;
    end;
  Result:=pixel-Red(pixel)<<00+r_<<00;
end; {$endregion}



(****************************** Array Operation *******************************)

// Arrays Addition:
procedure ArrAdd(constref arr_src1,arr_src2:T1ByteArr ;                         var arr_dst:T1IntrArr ; constref arr_dst_width,arr_dst_height:longword); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PByte;
  arr_src2_ptr: PByte;
  arr_dst_ptr : PInteger;
  i,w_h_mul   : integer;
begin
  w_h_mul     :=arr_dst_width*arr_dst_height;
  SetLength(arr_dst,w_h_mul);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to w_h_mul-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^+arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrAdd(constref arr_src1,arr_src2:T1DublArr ;                         var arr_dst:T1DublArr ; constref arr_dst_width,arr_dst_height:longword); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PDouble;
  arr_src2_ptr: PDouble;
  arr_dst_ptr : PDouble;
  i,w_h_mul   : integer;
begin
  w_h_mul     :=arr_dst_width*arr_dst_height;
  SetLength(arr_dst,w_h_mul);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to w_h_mul-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^+arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrAdd(constref arr_src1,arr_src2:T1IntrArr ;                         var arr_dst:T1IntrArr ; constref arr_dst_width,arr_dst_height:longword); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PInteger;
  arr_src2_ptr: PInteger;
  arr_dst_ptr : PInteger;
  i,w_h_mul   : integer;
begin
  w_h_mul     :=arr_dst_width*arr_dst_height;
  SetLength(arr_dst,w_h_mul);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to w_h_mul-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^+arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrAdd(constref arr_src1,arr_src2:T1LWordArr;                         var arr_dst:T1LWordArr; constref arr_dst_width,arr_dst_height:longword); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PLongWord;
  arr_src2_ptr: PLongWord;
  arr_dst_ptr : PLongWord;
  i,w_h_mul   : integer;
begin
  w_h_mul     :=arr_dst_width*arr_dst_height;
  SetLength(arr_dst,w_h_mul);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to w_h_mul-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^+arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrAdd(constref arr_src1,arr_src2:T1WordArr ;                         var arr_dst:T1WordArr ; constref arr_dst_width,arr_dst_height:longword); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PWord;
  arr_src2_ptr: PWord;
  arr_dst_ptr : PWord;
  i,w_h_mul   : integer;
begin
  w_h_mul     :=arr_dst_width*arr_dst_height;
  SetLength(arr_dst,w_h_mul);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to w_h_mul-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^+arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrAdd(constref arr_src1,arr_src2:T1ByteArr ;                         var arr_dst:T1ByteArr ; constref arr_dst_width,arr_dst_height:longword); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PByte;
  arr_src2_ptr: PByte;
  arr_dst_ptr : PByte;
  i,w_h_mul   : integer;
begin
  w_h_mul     :=arr_dst_width*arr_dst_height;
  SetLength(arr_dst,w_h_mul);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to w_h_mul-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^+arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrAdd(constref arr_src1:T1IntrArr; constref arr_src2:T1ByteArr; constref width,height:longword; constref val:integer);                        {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PInteger;
  arr_src2_ptr: PByte;
  i           : integer;
begin
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  for i:=0 to width*height-1 do
    begin
      if (arr_src2_ptr^<>0) then
        arr_src1_ptr^+=val;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
    end;
end; {$endregion}
procedure ArrAdd(constref arr_src1:T1ByteArr; constref arr_src2:T2ByteArr; constref arr_dst:T1IntrArr;  constref arr_dst_width,arr_dst_height:longword); {$ifdef Linux}[local];{$endif} {$region -fold}
var
 {arr_dst_ptr : PInteger;
  arr_src1_ptr: PByte;
  arr_src2_ptr: PByte;}
 {ptr10,ptr11 : PInteger;
  ptr20,ptr21 : PByte;}
  x,y,v       : integer;
begin
  v:=0;
  for y:=0 to arr_dst_height-1 do
    begin
      for x:=0 to arr_dst_width-1 do
        begin
          {Prefetch(arr_dst );
          Prefetch(arr_src1);
          Prefetch(arr_src2);}
          arr_dst[x+v]:=arr_src1[x+v]+arr_src2[x,y];
        end;
      Inc(v,arr_dst_width);
    end;
 {for x:=0 to arr_dst_width-1 do
    begin
      arr_dst_ptr :=@arr_dst [x];
      arr_src1_ptr:=@arr_src1[x];
      arr_src2_ptr:=@arr_src2[x,0];
      for y:=0 to arr_dst_height-1 do
        begin
          arr_dst_ptr^:=arr_src1_ptr^+arr_src2_ptr^;
          Inc(arr_dst_ptr ,arr_dst_width);
          Inc(arr_src1_ptr,arr_dst_width);
          Inc(arr_src2_ptr);
        end;
    end;}
 {ptr11:=@arr_dst [0];
  ptr21:=@arr_src1[0];
  for x:=0 to arr_dst_width-1 do
    begin
      ptr10:=ptr11;
      ptr20:=ptr21;
      arr_src2_ptr:=@arr_src2[x,0];
      for y:=0 to arr_dst_height-1 do
        begin
          ptr10^:=ptr20^+arr_src2_ptr^;
          Inc(ptr10,arr_dst_width);
          Inc(ptr20,arr_dst_width);
          Inc(arr_src2_ptr);
        end;
      Inc(ptr11);
      Inc(ptr21);
    end;}
end; {$endregion}
procedure ArrAdd(constref arr_src1:T1ByteArr; constref arr_src2:T2ByteArr; constref arr_dst:T1ByteArr;  constref arr_dst_width,arr_dst_height:longword); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,v: integer;
begin
  v:=0;
  for y:=0 to arr_dst_height-1 do
    begin
      for x:=0 to arr_dst_width-1 do
        begin
          {Prefetch(arr_dst );
          Prefetch(arr_src1);
          Prefetch(arr_src2);}
          arr_dst[x+v]:=arr_src1[x+v]+arr_src2[x,y];
        end;
      Inc(v,arr_dst_width);
    end;
end; {$endregion}
procedure ArrAdd(var      arr_src1:T1ByteArr; constref arr_src2:T2ByteArr;                              constref arr_dst_width,arr_dst_height:longword); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,v: integer;
begin
  v:=0;
  for y:=0 to arr_dst_height-1 do
    begin
      for x:=0 to arr_dst_width-1 do
        begin
          {Prefetch(arr_src1);
          Prefetch(arr_src2);}
          arr_src1[x+v]+=arr_src2[x,y];
        end;
      Inc(v,arr_dst_width);
    end;
end; {$endregion}

// Arrays Subtraction:
procedure ArrSub(constref arr_src1,arr_src2:T1DublArr ; var arr_dst:T1DublArr ; constref arr_dst_width,arr_dst_height:longword);       {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PDouble;
  arr_src2_ptr: PDouble;
  arr_dst_ptr : PDouble;
  i           : integer;
begin
  SetLength(arr_dst,arr_dst_width*arr_dst_height);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to arr_dst_width*arr_dst_height-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^-arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrSub(constref arr_src1,arr_src2:T1IntrArr ; var arr_dst:T1IntrArr ; constref arr_dst_width,arr_dst_height:longword);       {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PInteger;
  arr_src2_ptr: PInteger;
  arr_dst_ptr : PInteger;
  i           : integer;
begin
  SetLength(arr_dst,arr_dst_width*arr_dst_height);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to arr_dst_width*arr_dst_height-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^-arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrSub(constref arr_src1,arr_src2:T1LWordArr; var arr_dst:T1LWordArr; constref arr_dst_width,arr_dst_height:longword);       {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PLongWord;
  arr_src2_ptr: PLongWord;
  arr_dst_ptr : PLongWord;
  i           : integer;
begin
  SetLength(arr_dst,arr_dst_width*arr_dst_height);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to arr_dst_width*arr_dst_height-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^-arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrSub(constref arr_src1,arr_src2:T1WordArr ; var arr_dst:T1WordArr ; constref arr_dst_width,arr_dst_height:longword);       {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PWord;
  arr_src2_ptr: PWord;
  arr_dst_ptr : PWord;
  i           : integer;
begin
  SetLength(arr_dst,arr_dst_width*arr_dst_height);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to arr_dst_width*arr_dst_height-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^-arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrSub(constref arr_src1,arr_src2:T1ByteArr ; var arr_dst:T1ByteArr ; constref arr_dst_width,arr_dst_height:longword);       {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PByte;
  arr_src2_ptr: PByte;
  arr_dst_ptr : PByte;
  i           : integer;
begin
  SetLength(arr_dst,arr_dst_width*arr_dst_height);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to arr_dst_width*arr_dst_height-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^-arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrSub(constref arr_src:T1ByteArr;       constref arr_dst:T1IntrArr ; constref width,height:longword; constref val:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_dst_ptr: PInteger;
  arr_src_ptr: PByte;
  i           : integer;
begin
  arr_dst_ptr:=Unaligned(@arr_dst[0]);
  arr_src_ptr:=Unaligned(@arr_src[0]);
  for i:=0 to width*height-1 do
    begin
      if (arr_src_ptr^<>0) then
        arr_dst_ptr^-=val;
      Inc(arr_dst_ptr);
      Inc(arr_src_ptr);
    end;
end; {$endregion}

// 2D Array to 1D Array:
procedure Arr2DTo1D(constref arr_src:T2ByteArr; var arr_dst:T1ByteArr ; constref arr_src_width,arr_src_height:longword); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr: PByte;
  arr_dst_ptr: PByte;
  x,y        : integer;
begin
  SetLength(arr_dst,arr_src_width*arr_src_height);
  for x:=0 to arr_src_width-1 do
    begin
      arr_src_ptr:=Unaligned(@arr_src[x,0]);
      arr_dst_ptr:=Unaligned(@arr_dst[x  ]);
      for y:=0 to arr_src_height-1 do
        begin
          arr_dst_ptr^:=arr_src_ptr^;
          Inc(arr_dst_ptr,arr_src_width);
          Inc(arr_src_ptr);
        end;
    end;
end; {$endregion}

// Minimize Arrays:
procedure MinimizeArr(var arr_src:T1AALnArr); {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(arr_src,0);
end; {$endregion}
procedure MinimizeArr(var arr_src:T2ByteArr); {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(arr_src,0);
end; {$endregion}
procedure MinimizeArr(var arr_src:T1IntrArr); {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(arr_src,0);
end; {$endregion}
procedure MinimizeArr(var arr_src:T1WordArr); {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(arr_src,0);
end; {$endregion}
procedure MinimizeArr(var arr_src:T1ByteArr); {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(arr_src,0);
end; {$endregion}

// Clear Arrays:
procedure BmpClear(bmp:Graphics.TBitmap);                                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  //PatBlt(bmp.Canvas.Handle,0,0,bmp.width,bmp.height,WHITENESS);
  bmp.Canvas.Clear;
end; {$endregion}
procedure ArrClear(    arr1_ptr:PInteger;    constref rct_dst:TPtRect; constref arr_width:integer; constref val:integer=0); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to rct_dst.height-1 do
    begin
      FillByte(arr1_ptr^,rct_dst.width,val);
      Inc(arr1_ptr,arr_width);
    end;
end; {$endregion}
procedure ArrClear(var arr0    :T1ByteArr;   constref rct_dst:TPtRect; constref arr_width:integer; constref val:byte   =0); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p: PByte;
  i: integer;
begin
  p:=Unaligned(@arr0[rct_dst.left+arr_width*rct_dst.top]);
  for i:=0 to rct_dst.height-1 do
    begin
      FillByte(p^,rct_dst.width,val);
      Inc(p,arr_width);
    end;
end; {$endregion}
procedure ArrClear(var arr1    :T1IntrArr;   constref rct_dst:TPtRect; constref arr_width:integer; constref val:integer=0); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p: PInteger;
  i: integer;
begin
  p:=Unaligned(@arr1[rct_dst.left+arr_width*rct_dst.top]);
  for i:=0 to rct_dst.height-1 do
    begin
      FillDWord(p^,rct_dst.width,val);
      Inc(p,arr_width);
    end;
end; {$endregion}
procedure ArrClear(var arr2    :T2ByteArr;   constref rct_dst:TPtRect;                             constref val:byte   =0); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to rct_dst.width-1 do
    FillByte(arr2[rct_dst.left+i,rct_dst.top],rct_dst.height,val);
end; {$endregion}
procedure ArrClear(var arr3    :T1PtPos2Arr; constref rct_dst:TPtRect; constref arr_width:integer                        ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p      : PPtPos2;
  i,j    : integer;
  d_width: integer;
begin
  d_width:=arr_width-rct_dst.width;
  p      :=Unaligned(@arr3[rct_dst.left+arr_width*rct_dst.top]);
  for j:=0 to rct_dst.height-1 do
    begin
      for i:=0 to rct_dst.width-1 do
        begin
          if (p^.obj_ind<>-1) then
            p^.SetEqual1(p^,Default(TPtPos2));
          Inc(p);
        end;
      Inc(p,d_width);
    end;
end; {$endregion}

// Fill Arrays On Bitmap:
procedure ArrFillProc0(constref arr0:T1ByteArr;   constref bmp_ptr:PInteger; constref bmp_width,bmp_height:integer; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
//pixel_ptr0 : PInteger;
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : integer;
begin
  pix_color  :=RGB(Blue(col),Green(col),Red(col));
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
//pixel_ptr0 :=pixel_ptr;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
  {chess order}
  {for y:=0 to Trunc(rct_dst.height/2)-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
          if Odd(PInteger(pixel_ptr+x+1)-PInteger(pixel_ptr0)) then
            (pixel_ptr+x)^:=pix_color;
      Inc(pixel_ptr  ,bmp_width);
      Inc(f_arr_0_ptr,bmp_width);
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
          if Odd(PInteger(pixel_ptr+x)-PInteger(pixel_ptr0)) then
            (pixel_ptr+x)^:=pix_color;
      Inc(pixel_ptr  ,bmp_width);
      Inc(f_arr_0_ptr,bmp_width);
    end;}
end; {$endregion}
procedure ArrFillProc1(constref arr0:T1ByteArr;   constref bmp_ptr:PInteger; constref bmp_width,bmp_height:integer; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
  r,g,b      : byte;
begin
  r          :=Red  (col);
  g          :=Green(col);
  b          :=Blue (col);
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:={Additive(pixel_ptr^,r,g,b);} RGB(Min(Red  (pixel_ptr^)+b,255),
                                                          Min(Green(pixel_ptr^)+g,255),
                                                          Min(Blue (pixel_ptr^)+r,255));
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFillProc2(constref arr0:T1ByteArr;   constref bmp_ptr:PInteger; constref bmp_width,bmp_height:integer; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
  r,g,b      : byte;
    alpha1   : byte;
  d_alpha1   : byte;
begin
  r          :=Red  (col);
  g          :=Green(col);
  b          :=Blue (col);
  alpha1     :=alpha;
  d_alpha1   :=255-alpha1;
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:=AlphaBlend(pixel_ptr^,r,g,b,d_alpha1,alpha1);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFillProc3(constref arr0:T1ByteArr;   constref bmp_ptr:PInteger; constref bmp_width,bmp_height:integer; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:=Inverse(pixel_ptr^);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFillProc4(constref arr0:T1ByteArr;   constref bmp_ptr:PInteger; constref bmp_width,bmp_height:integer; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:=Highlight(pixel_ptr^);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFillProc5(constref arr0:T1ByteArr;   constref bmp_ptr:PInteger; constref bmp_width,bmp_height:integer; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:=Darken(pixel_ptr^);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFillProc6(constref arr0:T1ByteArr;   constref bmp_ptr:PInteger; constref bmp_width,bmp_height:integer; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:=GrayscaleR(pixel_ptr^);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFillProc7(constref arr0:T1ByteArr;   constref bmp_ptr:PInteger; constref bmp_width,bmp_height:integer; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:=GrayscaleG(pixel_ptr^);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFillProc8(constref arr0:T1ByteArr;   constref bmp_ptr:PInteger; constref bmp_width,bmp_height:integer; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:=GrayscaleB(pixel_ptr^);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFillProc9(constref arr0:T1ByteArr;   constref bmp_ptr:PInteger; constref bmp_width,bmp_height:integer; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
  pix_color  : integer;
begin
  pix_color  :=RGB(Blue(col),Green(col),Red(col));
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) and Odd(pixel_ptr^) then
            pixel_ptr^:=pix_color;
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFill     (constref arr0:T1IntrArr;   constref bmp_ptr:PInteger; constref bmp_width,bmp_height:integer; constref rct_dst:TPtrect; constref col:integer);                         {$region -fold}
var
  pixel_ptr: PInteger;
  arr0_ptr : PInteger;
  x,y      : integer;
  pix_color: integer;
begin
  pix_color:=RGB(Blue(col),Green(col),Red(col));
  pixel_ptr:=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  arr0_ptr :=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((arr0_ptr +x)^ <>0) then
            (pixel_ptr+x)^:=pix_color;
      Inc(arr0_ptr ,bmp_width);
      Inc(pixel_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFill     (constref arr0:T1PtPos2Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:integer; constref rct_dst:TPtrect; constref col:integer);                         {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PPtPos2;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^.obj_ind<>-1) then
            pixel_ptr^:=col;
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFill     (constref arr0:T1PtPos2Arr;                            constref bmp_width,bmp_height:integer; constref rct_dst:TPtrect);                                               {$region -fold}
var
  f_arr_0_ptr: PPtPos2;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  f_arr_0_ptr:=Unaligned(@arr0[rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          f_arr_0_ptr^.obj_ind:=-1;
          Inc(f_arr_0_ptr);
        end;
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFill     (constref arr0:T1ByteArr;   constref bmp_ptr:PInteger; constref bmp_width,bmp_height:integer; constref rct_dst:TPtrect);                                               {$region -fold}
var
  pixel_ptr: PInteger;
  d_width  : integer;
  x,y      : integer;
begin
  d_width  :=bmp_width-rct_dst.width;
  pixel_ptr:=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (pixel_ptr^<>0) then
            arr0[pixel_ptr^-1]:=1;
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFillTest (constref arr0:T1ByteArr;   constref bmp_ptr:PInteger; constref bmp_width,bmp_height:integer; constref rct_dst:TPtrect; constref col:integer);                         {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
begin
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^=1) then
          (pixel_ptr+x)^:=col;
      Inc (pixel_ptr  ,bmp_width);
      Inc (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFillTest (constref arr0:T1IntrArr;   constref bmp_ptr:PInteger; constref bmp_width,bmp_height:integer; constref rct_dst:TPtrect; constref col:integer);                         {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PInteger;
  x,y        : integer;
begin
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^=1) then
          (pixel_ptr+x)^:=col;
      Inc (pixel_ptr  ,bmp_width);
      Inc (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}

// Non-Zero Items Count:
function ArrNzItCnt(constref arr:T1ByteArr): integer; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_ptr: PByte;
  i      : integer;
begin
  Result :=0;
  arr_ptr:=Unaligned(@arr[0]);
  for i:=0 to Length(arr)-1 do
    begin
      if (arr_ptr^=1) then
        Inc(Result);
      Inc(arr_ptr);
    end;
end; {$endregion}



(****************************** Edge Antialiasing *****************************)
{
procedure BorderCalc0(constref arr_src    :T1IntrArr; var arr_dst:T1ByteArr;                          constref arr_src_width,arr_dst_width:integer; constref rct_dst:TPtRect; var aa_nz_arr_it_cnt:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr          : PInteger;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
  pix_cnt_btw_pts      : integer;
begin
  pix_cnt_btw_pts      :=0;
  aa_nz_arr_it_cnt     :=0;
  d_width1             :=                                arr_src_width- rct_dst.width;
  d_width2             :=                                arr_dst_width- rct_dst.width;
  arr_src_ptr          :=Unaligned(@arr_src[rct_dst.left+arr_src_width*(rct_dst.top+1)]);
  arr_dst_ptr          :=Unaligned(@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr^<>0) then
            begin
              arr_dst_ptr^:=3;
              Inc(pix_cnt_btw_pts);
              while (arr_dst_ptr^<>3) do
                begin
                  if ((arr_src_ptr+arr_src_width-1)^<>0) then
                    begin
                      arr_src_ptr +=arr_src_width-1;
                      arr_dst_ptr +=arr_dst_width-1;
                      arr_dst_ptr^:=1;
                      Inc(pix_cnt_btw_pts);
                    end
                  else
                  if ((arr_src_ptr+arr_src_width)^<>0) then
                    begin
                      arr_src_ptr +=arr_src_width;
                      arr_dst_ptr +=arr_dst_width;
                      arr_dst_ptr^:=1;
                      Inc(pix_cnt_btw_pts);
                    end
                  else
                  if ((arr_src_ptr+arr_src_width+1)^<>0) then
                    begin
                      arr_src_ptr +=arr_src_width+1;
                      arr_dst_ptr +=arr_dst_width+1;
                      arr_dst_ptr^:=1;
                      Inc(pix_cnt_btw_pts);
                    end
                  else
                  if ((arr_src_ptr+1)^<>0) then
                    begin
                      arr_src_ptr +=1;
                      arr_dst_ptr +=1;
                      arr_dst_ptr^:=1;
                      Inc(pix_cnt_btw_pts);
                    end
                  else
                  if ((arr_src_ptr-arr_src_width+1)^<>0) then
                    begin
                      arr_src_ptr -=arr_src_width+1;
                      arr_dst_ptr -=arr_dst_width+1;
                      arr_dst_ptr^:=1;
                      Inc(pix_cnt_btw_pts);
                    end
                  else
                  if ((arr_src_ptr+arr_src_width)^<>0) then
                    begin
                      arr_src_ptr -=arr_src_width;
                      arr_dst_ptr -=arr_dst_width;
                      arr_dst_ptr^:=1;
                      Inc(pix_cnt_btw_pts);
                    end
                  else
                  if ((arr_src_ptr-arr_src_width-1)^<>0) then
                    begin
                      arr_src_ptr -=arr_src_width-1;
                      arr_dst_ptr -=arr_dst_width-1;
                      arr_dst_ptr^:=1;
                      Inc(pix_cnt_btw_pts);
                    end
                  else
                  if ((arr_src_ptr-1)^<>0) then
                    begin
                      arr_src_ptr -=1;
                      arr_dst_ptr -=1;
                      arr_dst_ptr^:=1;
                      Inc(pix_cnt_btw_pts);
                    end;
                end;
            end;
          Inc(arr_src_ptr);
          Inc(arr_dst_ptr);
        end;
      Inc(arr_src_ptr,d_width1);
      Inc(arr_dst_ptr,d_width2);
    end;
end; {$endregion}
procedure BorderCalc0(constref arr_src    :T1ByteArr; var arr_dst:T1ByteArr;                          constref arr_src_width,arr_dst_width:integer; constref rct_dst:TPtRect; var aa_nz_arr_it_cnt:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr          : PByte;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
  pix_cnt_btw_pts      : integer;
  p                    : byte=0;
label
  l1;
begin
  pix_cnt_btw_pts      :=0;
  aa_nz_arr_it_cnt     :=0;
  d_width1             :=                                arr_src_width- rct_dst.width;
  d_width2             :=                                arr_dst_width- rct_dst.width;
  arr_src_ptr          :=Unaligned(@arr_src[rct_dst.left+arr_src_width*(rct_dst.top+1)]);
  arr_dst_ptr          :=Unaligned(@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr^<>0) then
            goto l1;
          Inc(arr_src_ptr);
          Inc(arr_dst_ptr);
        end;
      Inc(arr_src_ptr,d_width1);
      Inc(arr_dst_ptr,d_width2);
    end;
  l1:
  arr_dst_ptr^:=3;

  //Inc(pix_cnt_btw_pts);
  while (arr_dst_ptr^<>3) and (p=1) do//repeat
    begin
      {0 0 0
       1 0 0
       0 0 0}
      if ((arr_src_ptr-1)^<>0) and ((arr_dst_ptr-1)^=0) then
        begin
          arr_src_ptr +=arr_src_width-1;
          arr_dst_ptr +=arr_dst_width-1;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {0 0 0
       0 0 0
       1 0 0}
      if ((arr_src_ptr+arr_src_width-1)^<>0) and ((arr_dst_ptr+arr_src_width-1)^=0) then
        begin
          arr_src_ptr +=arr_src_width-1;
          arr_dst_ptr +=arr_dst_width-1;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {0 0 0
       0 0 0
       0 1 0}
      if ((arr_src_ptr+arr_src_width)^<>0) and ((arr_dst_ptr+arr_src_width)^=0) then
        begin
          arr_src_ptr +=arr_src_width;
          arr_dst_ptr +=arr_dst_width;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {0 0 0
       0 0 0
       0 0 1}
      if ((arr_src_ptr+arr_src_width+1)^<>0) and ((arr_dst_ptr+arr_src_width+1)^=0) then
        begin
          arr_src_ptr +=arr_src_width+1;
          arr_dst_ptr +=arr_dst_width+1;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {0 0 0
       0 0 1
       0 0 0}
      if ((arr_src_ptr+1)^<>0) and ((arr_dst_ptr+1)^=0) then
        begin
          arr_src_ptr +=1;
          arr_dst_ptr +=1;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {0 0 1
       0 0 0
       0 0 0}
      if ((arr_src_ptr-arr_src_width+1)^<>0) and ((arr_dst_ptr-arr_src_width+1)^=0) then
        begin
          arr_src_ptr -=arr_src_width+1;
          arr_dst_ptr -=arr_dst_width+1;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {0 1 0
       0 0 0
       0 0 0}
      if ((arr_src_ptr-arr_src_width)^<>0) and ((arr_dst_ptr-arr_src_width)^=0) then
        begin
          arr_src_ptr -=arr_src_width;
          arr_dst_ptr -=arr_dst_width;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {1 0 0
       0 0 0
       0 0 0}
      if ((arr_src_ptr-arr_src_width-1)^<>0) and ((arr_dst_ptr-arr_src_width-1)^=0) then
        begin
          arr_src_ptr -=arr_src_width-1;
          arr_dst_ptr -=arr_dst_width-1;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end;
    end;
    //until (arr_dst_ptr^<>3);
end; {$endregion}
}
procedure BorderCalc0(constref arr_src_ptr:PInteger ; var arr_dst:T1ByteArr;                          constref arr_src_width,arr_dst_width:integer; constref rct_dst:TPtRect; var aa_nz_arr_it_cnt:integer; constref background_color:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2         : PInteger;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
begin
  aa_nz_arr_it_cnt:=0;
  d_width1        :=                                    arr_src_width- rct_dst.width   ;
  d_width2        :=                                    arr_dst_width- rct_dst.width   ;
  arr_src_ptr2    :=Unaligned( arr_src_ptr+rct_dst.left+arr_src_width*(rct_dst.top+1) );
  arr_dst_ptr     :=Unaligned(@arr_dst    [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  Prefetch(arr_src_ptr2);
  Prefetch(arr_dst_ptr );
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr2^<>background_color) then
            begin
              if ((arr_src_ptr2-arr_src_width)^=background_color) then
                begin
                  (arr_dst_ptr-arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr2+arr_src_width)^=background_color) then
                begin
                  (arr_dst_ptr+arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr2-1)^=background_color) then
                begin
                  (arr_dst_ptr-1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr2+1)^=background_color) then
                begin
                  (arr_dst_ptr+1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
            end;
          Inc(arr_src_ptr2);
          Inc(arr_dst_ptr );
        end;
      Inc(arr_src_ptr2,d_width1);
      Inc(arr_dst_ptr ,d_width2);
    end;
end; {$endregion}
procedure BorderCalc1(constref arr_src_ptr:PInteger ; var arr_dst:T1ByteArr;                          constref arr_src_width,arr_dst_width:integer; constref rct_dst:TPtRect; var aa_nz_arr_it_cnt:integer                                   ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2         : PInteger;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
begin
  aa_nz_arr_it_cnt     :=0;
  d_width1             :=                                    arr_src_width- rct_dst.width   ;
  d_width2             :=                                    arr_dst_width- rct_dst.width   ;
  arr_src_ptr2         :=Unaligned( arr_src_ptr+rct_dst.left+arr_src_width*(rct_dst.top+1) );
  arr_dst_ptr          :=Unaligned(@arr_dst    [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  Prefetch(arr_src_ptr2);
  Prefetch(arr_dst_ptr );
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr2^<>0) then
            begin
              if ((arr_src_ptr2-arr_src_width)^=0) then
                begin
                  (arr_dst_ptr-arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr2+arr_src_width)^=0) then
                begin
                  (arr_dst_ptr+arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr2-1)^=0) then
                begin
                  (arr_dst_ptr-1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr2+1)^=0) then
                begin
                  (arr_dst_ptr+1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
            end;
          Inc(arr_src_ptr2);
          Inc(arr_dst_ptr );
        end;
      Inc(arr_src_ptr2,d_width1);
      Inc(arr_dst_ptr ,d_width2);
    end;
end; {$endregion}
procedure BorderCalc1(constref arr_src    :T1IntrArr; var arr_dst:T1ByteArr;                          constref arr_src_width,arr_dst_width:integer; constref rct_dst:TPtRect; var aa_nz_arr_it_cnt:integer                                   ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr          : PInteger;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
begin
  aa_nz_arr_it_cnt     :=0;
  d_width1             :=                                arr_src_width- rct_dst.width;
  d_width2             :=                                arr_dst_width- rct_dst.width;
  arr_src_ptr          :=Unaligned(@arr_src[rct_dst.left+arr_src_width*(rct_dst.top+1)]);
  arr_dst_ptr          :=Unaligned(@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  Prefetch(arr_src_ptr);
  Prefetch(arr_dst_ptr);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr^<>0) then
            begin
              if ((arr_src_ptr-arr_src_width)^=0) then
                begin
                  (arr_dst_ptr-arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr+arr_src_width)^=0) then
                begin
                  (arr_dst_ptr+arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr-1)^=0) then
                begin
                  (arr_dst_ptr-1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr+1)^=0) then
                begin
                  (arr_dst_ptr+1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
            end;
          Inc(arr_src_ptr);
          Inc(arr_dst_ptr);
        end;
      Inc(arr_src_ptr,d_width1);
      Inc(arr_dst_ptr,d_width2);
    end;
end; {$endregion}
procedure BorderCalc1(constref arr_src    :T1ByteArr; var arr_dst:T1ByteArr;                          constref arr_src_width,arr_dst_width:integer; constref rct_dst:TPtRect; var aa_nz_arr_it_cnt:integer                                   ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr          : PByte;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
begin
  aa_nz_arr_it_cnt     :=0;
  d_width1             :=                                arr_src_width- rct_dst.width;
  d_width2             :=                                arr_dst_width- rct_dst.width;
  arr_src_ptr          :=Unaligned(@arr_src[rct_dst.left+arr_src_width*(rct_dst.top+1)]);
  arr_dst_ptr          :=Unaligned(@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  Prefetch(arr_src_ptr);
  Prefetch(arr_dst_ptr);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr^<>0) then
            begin
              if ((arr_src_ptr-arr_src_width)^=0) then
                begin
                  (arr_dst_ptr-arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr+arr_src_width)^=0) then
                begin
                  (arr_dst_ptr+arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr-1)^=0) then
                begin
                  (arr_dst_ptr-1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr+1)^=0) then
                begin
                  (arr_dst_ptr+1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
            end;
          Inc(arr_src_ptr);
          Inc(arr_dst_ptr);
        end;
      Inc(arr_src_ptr,d_width1);
      Inc(arr_dst_ptr,d_width2);
    end;
end; {$endregion}
procedure BorderCalc2(constref arr_src_ptr:PInteger ; var arr_dst:T1ByteArr; var arr_alpha:T1AALnArr; constref arr_src_width,arr_dst_width:integer; constref rct_dst:TPtRect; out line_count      :integer                                   ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Horizontal Line-} {$region -fold}
              if ((arr_dst_ptr+1)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr);
                    end;
                  arr_alpha_ptr^.line_shift:=arr_dst_ptr-line_first_pt_ptr;
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=arr_dst_ptr      -arr_dst_left_ptr+d0;
                  line_kind_arr[3]         :=((arr_src_ptr+d1-1)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2  )^<>0);
                  {line_kind=2----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=2;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=0,1,3} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1  -arr_src_width)^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2  -arr_src_width)^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1+arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1  +arr_src_width)^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2  +arr_src_width)^<>0);
                      case line_kind of
                        {line_kind=0} {$region -fold}
                        {can be rolled to line_kind=1}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001,
                        {00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000,
                        {00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000,
                        {00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001,
                        {00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000,
                        {00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001,
                        {01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000,
                        {01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001,
                        {01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001,
                        {01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000,
                        {01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000,
                        {01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001,
                        {01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000,
                        {01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001,
                        {01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000,
                        {11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000,
                        {10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000,
                        {11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000,
                        {10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001:
                          begin
                            arr_alpha_ptr^.line_kind :=0;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=1} {$region -fold}
                        {can be rolled to line_kind=0}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000,
                        {01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000,
                        {01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000,
                        {11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000,
                        {01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000,
                        {11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000,
                        {01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000,
                        {11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000,
                        {10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000,
                        {00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000,
                        {00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000,
                        {10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000,
                        {00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000,
                        {10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000,
                        {01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000,
                        {00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001,
                        {01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001,
                        {00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001,
                        {11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001:
                          begin
                            arr_alpha_ptr^.line_kind :=1;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=3} {$region -fold}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000:
                        if ((arr_src_ptr+d2-arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000:
                        if ((arr_src_ptr+d2+arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill Vertical Line---} {$region -fold}
              else
              if ((arr_dst_ptr+arr_dst_width)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr,arr_dst_width);
                    end;
                  arr_alpha_ptr^.line_shift:=Trunc((arr_dst_ptr-line_first_pt_ptr)/arr_dst_width);
                  Dec(arr_dst_ptr,arr_dst_ptr-line_first_pt_ptr);
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=d1+arr_src_width*arr_alpha_ptr^.line_shift;
                  line_kind_arr[3]         :=((arr_src_ptr+d1 -arr_src_width)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2               )^<>0);
                  {line_kind=7----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=7;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=5,6,8} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1+1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1+1              )^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2+1              )^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1-1              )^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2-1              )^<>0);
                      case line_kind of
                        {line_kind=5} {$region -fold}
                        {can be rolled to line_kind=6}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001,
                        {00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000,
                        {00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000,
                        {00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001,
                        {00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000,
                        {00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001,
                        {01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000,
                        {01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001,
                        {01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001,
                        {01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000,
                        {01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000,
                        {01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001,
                        {01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000,
                        {01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001,
                        {01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000,
                        {11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000,
                        {10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000,
                        {11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000,
                        {10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001:
                          begin
                            arr_alpha_ptr^.line_kind :=5;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=6} {$region -fold}
                        {can be rolled to line_kind=5}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000,
                        {01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000,
                        {01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000,
                        {11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000,
                        {01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000,
                        {11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000,
                        {01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000,
                        {11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000,
                        {10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000,
                        {00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000,
                        {00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000,
                        {10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000,
                        {00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000,
                        {10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000,
                        {01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000,
                        {00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001,
                        {01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001,
                        {00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001,
                        {11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001:
                          begin
                            arr_alpha_ptr^.line_kind :=6;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=8} {$region -fold}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000:
                        if ((arr_src_ptr+d2+1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000:
                        if ((arr_src_ptr+d2-1-arr_src_width)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill One Pixel-------} {$region -fold}
              else
              if (((arr_dst_ptr-arr_dst_width)^<>1) and ((arr_dst_ptr-1)^<>1)) or
                 (((arr_dst_ptr+arr_dst_width)^<>1) and ((arr_dst_ptr+1)^<>1)) then
                begin
                  arr_dst_ptr^             :=2;
                  arr_alpha_ptr^.line_kind :=10;
                  arr_alpha_ptr^.first_pt_x:=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end; {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_count:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
procedure BorderCalc2(constref arr_src    :T1IntrArr; var arr_dst:T1ByteArr; var arr_alpha:T1AALnArr; constref arr_src_width,arr_dst_width:integer; constref rct_dst:TPtRect; out line_count      :integer                                   ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_src_ptr           : PInteger;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_src_ptr     :=Unaligned(@arr_src  [000000000000000000000000000000000000000000]);
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Horizontal Line-} {$region -fold}
              if ((arr_dst_ptr+1)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr);
                    end;
                  arr_alpha_ptr^.line_shift:=arr_dst_ptr-line_first_pt_ptr;
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=arr_dst_ptr      -arr_dst_left_ptr+d0;
                  line_kind_arr[3]         :=((arr_src_ptr+d1-1)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2  )^<>0);
                  {line_kind=2----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=2;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=0,1,3} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1  -arr_src_width)^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2  -arr_src_width)^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1+arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1  +arr_src_width)^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2  +arr_src_width)^<>0);
                      case line_kind of
                        {line_kind=0} {$region -fold}
                        {can be rolled to line_kind=1}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001,
                        {00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000,
                        {00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000,
                        {00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001,
                        {00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000,
                        {00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001,
                        {01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000,
                        {01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001,
                        {01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001,
                        {01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000,
                        {01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000,
                        {01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001,
                        {01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000,
                        {01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001,
                        {01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000,
                        {11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000,
                        {10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000,
                        {11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000,
                        {10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001:
                          begin
                            arr_alpha_ptr^.line_kind :=0;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=1} {$region -fold}
                        {can be rolled to line_kind=0}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000,
                        {01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000,
                        {01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000,
                        {11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000,
                        {01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000,
                        {11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000,
                        {01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000,
                        {11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000,
                        {10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000,
                        {00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000,
                        {00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000,
                        {10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000,
                        {00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000,
                        {10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000,
                        {01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000,
                        {00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001,
                        {01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001,
                        {00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001,
                        {11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001:
                          begin
                            arr_alpha_ptr^.line_kind :=1;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=3} {$region -fold}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000:
                        if ((arr_src_ptr+d2-arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000:
                        if ((arr_src_ptr+d2+arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill Vertical Line---} {$region -fold}
              else
              if ((arr_dst_ptr+arr_dst_width)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr,arr_dst_width);
                    end;
                  arr_alpha_ptr^.line_shift:=Trunc((arr_dst_ptr-line_first_pt_ptr)/arr_dst_width);
                  Dec(arr_dst_ptr,arr_dst_ptr-line_first_pt_ptr);
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=d1+arr_src_width*arr_alpha_ptr^.line_shift;
                  line_kind_arr[3]         :=((arr_src_ptr+d1 -arr_src_width)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2               )^<>0);
                  {line_kind=7----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=7;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=5,6,8} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1+1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1+1              )^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2+1              )^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1-1              )^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2-1              )^<>0);
                      case line_kind of
                        {line_kind=5} {$region -fold}
                        {can be rolled to line_kind=6}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001,
                        {00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000,
                        {00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000,
                        {00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001,
                        {00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000,
                        {00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001,
                        {01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000,
                        {01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001,
                        {01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001,
                        {01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000,
                        {01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000,
                        {01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001,
                        {01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000,
                        {01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001,
                        {01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000,
                        {11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000,
                        {10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000,
                        {11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000,
                        {10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001:
                          begin
                            arr_alpha_ptr^.line_kind :=5;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=6} {$region -fold}
                        {can be rolled to line_kind=5}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000,
                        {01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000,
                        {01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000,
                        {11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000,
                        {01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000,
                        {11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000,
                        {01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000,
                        {11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000,
                        {10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000,
                        {00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000,
                        {00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000,
                        {10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000,
                        {00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000,
                        {10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000,
                        {01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000,
                        {00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001,
                        {01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001,
                        {00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001,
                        {11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001:
                          begin
                            arr_alpha_ptr^.line_kind :=6;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=8} {$region -fold}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000:
                        if ((arr_src_ptr+d2+1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000:
                        if ((arr_src_ptr+d2-1-arr_src_width)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill One Pixel-------} {$region -fold}
              else
              if (((arr_dst_ptr-arr_dst_width)^<>1) and ((arr_dst_ptr-1)^<>1)) or
                 (((arr_dst_ptr+arr_dst_width)^<>1) and ((arr_dst_ptr+1)^<>1)) then
                begin
                  arr_dst_ptr^             :=2;
                  arr_alpha_ptr^.line_kind :=10;
                  arr_alpha_ptr^.first_pt_x:=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end; {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_count:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
procedure BorderCalc2(constref arr_src    :T1ByteArr; var arr_dst:T1ByteArr; var arr_alpha:T1AALnArr; constref arr_src_width,arr_dst_width:integer; constref rct_dst:TPtRect; out line_count      :integer                                   ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_src_ptr           : PByte;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_src_ptr     :=Unaligned(@arr_src  [000000000000000000000000000000000000000000]);
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Horizontal Line-} {$region -fold}
              if ((arr_dst_ptr+1)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr);
                    end;
                  arr_alpha_ptr^.line_shift:=arr_dst_ptr-line_first_pt_ptr;
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=arr_dst_ptr      -arr_dst_left_ptr+d0;
                  line_kind_arr[3]         :=((arr_src_ptr+d1-1)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2  )^<>0);
                  {line_kind=2----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=2;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=0,1,3} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1  -arr_src_width)^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2  -arr_src_width)^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1+arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1  +arr_src_width)^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2  +arr_src_width)^<>0);
                      case line_kind of
                        {line_kind=0} {$region -fold}
                        {can be rolled to line_kind=1}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001,
                        {00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000,
                        {00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000,
                        {00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001,
                        {00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000,
                        {00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001,
                        {01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000,
                        {01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001,
                        {01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001,
                        {01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000,
                        {01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000,
                        {01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001,
                        {01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000,
                        {01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001,
                        {01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000,
                        {11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000,
                        {10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000,
                        {11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000,
                        {10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001:
                          begin
                            arr_alpha_ptr^.line_kind :=0;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=1} {$region -fold}
                        {can be rolled to line_kind=0}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000,
                        {01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000,
                        {01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000,
                        {11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000,
                        {01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000,
                        {11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000,
                        {01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000,
                        {11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000,
                        {10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000,
                        {00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000,
                        {00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000,
                        {10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000,
                        {00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000,
                        {10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000,
                        {01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000,
                        {00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001,
                        {01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001,
                        {00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001,
                        {11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001:
                          begin
                            arr_alpha_ptr^.line_kind :=1;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=3} {$region -fold}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000:
                        if ((arr_src_ptr+d2-arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000:
                        if ((arr_src_ptr+d2+arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill Vertical Line---} {$region -fold}
              else
              if ((arr_dst_ptr+arr_dst_width)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr,arr_dst_width);
                    end;
                  arr_alpha_ptr^.line_shift:=Trunc((arr_dst_ptr-line_first_pt_ptr)/arr_dst_width);
                  Dec(arr_dst_ptr,arr_dst_ptr-line_first_pt_ptr);
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=d1+arr_src_width*arr_alpha_ptr^.line_shift;
                  line_kind_arr[3]         :=((arr_src_ptr+d1 -arr_src_width)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2               )^<>0);
                  {line_kind=7----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=7;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=5,6,8} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1+1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1+1              )^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2+1              )^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1-1              )^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2-1              )^<>0);
                      case line_kind of
                        {line_kind=5} {$region -fold}
                        {can be rolled to line_kind=6}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001,
                        {00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000,
                        {00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000,
                        {00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001,
                        {00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000,
                        {00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001,
                        {01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000,
                        {01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001,
                        {01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001,
                        {01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000,
                        {01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000,
                        {01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001,
                        {01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000,
                        {01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001,
                        {01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000,
                        {11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000,
                        {10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000,
                        {11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000,
                        {10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001:
                          begin
                            arr_alpha_ptr^.line_kind :=5;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=6} {$region -fold}
                        {can be rolled to line_kind=5}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000,
                        {01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000,
                        {01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000,
                        {11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000,
                        {01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000,
                        {11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000,
                        {01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000,
                        {11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000,
                        {10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000,
                        {00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000,
                        {00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000,
                        {10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000,
                        {00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000,
                        {10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000,
                        {01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000,
                        {00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001,
                        {01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001,
                        {00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001,
                        {11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001:
                          begin
                            arr_alpha_ptr^.line_kind :=6;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=8} {$region -fold}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000:
                        if ((arr_src_ptr+d2+1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000:
                        if ((arr_src_ptr+d2-1-arr_src_width)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill One Pixel-------} {$region -fold}
              else
              if (((arr_dst_ptr-arr_dst_width)^<>1) and ((arr_dst_ptr-1)^<>1)) or
                 (((arr_dst_ptr+arr_dst_width)^<>1) and ((arr_dst_ptr+1)^<>1)) then
                begin
                  arr_dst_ptr^             :=2;
                  arr_alpha_ptr^.line_kind :=10;
                  arr_alpha_ptr^.first_pt_x:=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end; {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_count:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
procedure BorderFill (constref arr_src    :T1AALnArr;                                                                                               constref rct_dst_left,rct_dst_top:integer; constref bmp_ptr:PInteger; constref bmp_width:integer; constref line_count:integer; constref col:TColor; args:TFunc0Args; Func2:TFunc2); {$region -fold}
var
  arr_src_ptr : PFastAALine;
  pixel_ptr   : Pinteger;
  i,j         : integer;
  alpha_shift3: integer;
  alpha_shift2: integer;
  alpha_shift1: byte;
    alpha1    : byte;
  d_alpha1    : byte;
    alpha2    : byte;
  d_alpha2    : byte;
begin
  if (line_count=0) then
    Exit;
  with args do
    begin
      r           :=Red  (col);
      g           :=Green(col);
      b           :=Blue (col);
      alpha1      :=alpha;
      d_alpha1    :=255-alpha1;
      alpha_shift1:=255-alpha;
      arr_src_ptr :=Unaligned(@arr_src[0]);
      Prefetch(arr_src_ptr);
      for i:=0 to line_count-1 do
        begin
          pixel_ptr:=Unaligned(bmp_ptr+arr_src_ptr^.first_pt_x+rct_dst_left+bmp_width*(arr_src_ptr^.first_pt_y+rct_dst_top));
          case arr_src_ptr^.line_kind of
            00{00 - horizontal line: 2 points from left to right---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=alpha1+j*alpha_shift3;
                    d_alpha2  :=255-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clFuchsia);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                    Inc  (alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            01{01 - horizontal line: 2 points from right to left---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=255-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=255-alpha_shift3-j*alpha_shift3;
                    d_alpha2  :=255-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clBlue);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                    Dec  (alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            02{02 - horizontal line: outer line from ends to middle}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=alpha1+j*alpha_shift3;
                    d_alpha2  :=255-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                    Inc  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                    alpha2    :=255-alpha_shift3;
                    d_alpha2  :=    alpha_shift3;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                  end;
                alpha2:=255-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=255-j*alpha_shift3;
                    d_alpha2  :=255-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                    Dec  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=
                  //SetColorInv({clGreen}clPurple);
                  Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
              end; {$endregion}
            03{03 - horizontal line: inner line from middle to ends}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=255-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=255-j*alpha_shift3;
                    d_alpha2  :=255-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clWhite);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                    Dec  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                    alpha2    :=255+alpha_shift3;
                    d_alpha2  :=   -alpha_shift3;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                  end;
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=alpha1+j*alpha_shift3;
                    d_alpha2  :=255-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clWhite);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                    Inc  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=
                  //SetColorInv({clGreen}clWhite);
                  Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
              end; {$endregion}
            04{04 - horizontal line: const fill--------------------}: {$region -fold}
              begin

              end; {$endregion}
            05{05 - vertical   line: 2 points from top to bottom---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=alpha1+j*alpha_shift3;
                    d_alpha2  :=255-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clFuchsia);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                    Inc  (alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            06{06 - vertical   line: 2 points from bottom to top---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=255-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=255-alpha_shift3-j*alpha_shift3;
                    d_alpha2  :=255-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clBlue);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                    Dec  (alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            07{07 - vertical   line: inner line from ends to middle}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                    //alpha2    :=alpha1+j*alpha_shift3;
                    d_alpha2  :=255-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                    Inc  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                    alpha2    :=255-alpha_shift3;
                    d_alpha2  :=    alpha_shift3;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                  end;
                alpha2:=255-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                    //alpha2    :=255-j*alpha_shift3;
                    d_alpha2  :=255-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                    Dec  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=
                  //SetColorInv({clGreen}clPurple);
                  Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
              end; {$endregion}
            08{08 - vertical   line: outer line from middle to ends}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=255-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                    //alpha2    :=255-j*alpha_shift3;
                    d_alpha2  :=255-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clWhite);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                    Dec  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                    alpha2    :=255+alpha_shift3;
                    d_alpha2  :=   -alpha_shift3;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                  end;
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                    //alpha2    :=alpha1+j*alpha_shift3;
                    d_alpha2  :=255-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clWhite);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                    Inc  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=
                  //SetColorInv({clGreen}clWhite);
                  Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
              end; {$endregion}
            09{09 - vertical   line: const fill--------------------}: {$region -fold}
              begin

              end; {$endregion}
            10{10 - 1 point----------------------------------------}: {$region -fold}
              begin
                pixel_ptr^:=
                //SetColorInv(clRed);
                Func2(pixel_ptr^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
              end; {$endregion}
          end;
          Inc(arr_src_ptr);
        end;
    end;
end; {$endregion}

// Border Blur:
procedure BorderBlur (constref arr_src_ptr:PInteger ; var arr_dst:T1ByteArr;                          constref arr_src_width,arr_dst_width:integer; constref rct_dst:TPtRect;                               constref background_color:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2         : PInteger;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
begin
  d_width1        :=                                    arr_src_width- rct_dst.width   ;
  d_width2        :=                                    arr_dst_width- rct_dst.width   ;
  arr_src_ptr2    :=Unaligned( arr_src_ptr+rct_dst.left+arr_src_width*(rct_dst.top+1) );
  arr_dst_ptr     :=Unaligned(@arr_dst    [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  Prefetch(arr_src_ptr2);
  Prefetch(arr_dst_ptr );
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_dst_ptr^=1) then
            BorderPixCh(arr_src_ptr2,arr_src_width,background_color);
          Inc(arr_src_ptr2);
          Inc(arr_dst_ptr );
        end;
      Inc(arr_src_ptr2,d_width1);
      Inc(arr_dst_ptr ,d_width2);
    end;
end; {$endregion}

// One-Pixel Border-Blur Calculation:
procedure BorderPixCh(arr_src_ptr:PInteger; constref arr_src_width:integer; constref background_color:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2              : PInteger;
  non_zero_pix_cnt          : byte=0;
  r0,r1,r2,r3,r4,r5,r6,r7,r8: byte;
  g0,g1,g2,g3,g4,g5,g6,g7,g8: byte;
  b0,b1,b2,b3,b4,b5,b6,b7,b8: byte;
begin
  // pixel-border scheme:
  // 012
  // 345
  // 678
  // 4 - arr_src_ptr;
  // 0,1,2,3,5,6,7,8 - pixel-border;
  arr_src_ptr2:=arr_src_ptr-arr_src_width-1;
  if (arr_src_ptr2^<>background_color) then
    begin
      r0:=arr_src_ptr2^{shr 00};
      g0:=arr_src_ptr2^ shr 08 ;
      b0:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r0:=0;
      g0:=0;
      b0:=0;
    end;
  arr_src_ptr2:=arr_src_ptr-arr_src_width;
  if (arr_src_ptr2^<>background_color) then
    begin
      r1:=arr_src_ptr2^{shr 00};
      g1:=arr_src_ptr2^ shr 08 ;
      b1:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r1:=0;
      g1:=0;
      b1:=0;
    end;
  arr_src_ptr2:=arr_src_ptr-arr_src_width+1;
  if (arr_src_ptr2^<>background_color) then
    begin
      r2:=arr_src_ptr2^{shr 00};
      g2:=arr_src_ptr2^ shr 08 ;
      b2:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r2:=0;
      g2:=0;
      b2:=0;
    end;
  arr_src_ptr2:=arr_src_ptr-1;
  if (arr_src_ptr2^<>background_color) then
    begin
      r3:=arr_src_ptr2^{shr 00};
      g3:=arr_src_ptr2^ shr 08 ;
      b3:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r3:=0;
      g3:=0;
      b3:=0;
    end;
  if (arr_src_ptr^<>background_color) then
    begin
      r4:=arr_src_ptr^{shr 00};
      g4:=arr_src_ptr^ shr 08 ;
      b4:=arr_src_ptr^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r4:=0;
      g4:=0;
      b4:=0;
    end;
  arr_src_ptr2:=arr_src_ptr+1;
  if (arr_src_ptr2^<>background_color) then
    begin
      r5:=arr_src_ptr2^{shr 00};
      g5:=arr_src_ptr2^ shr 08 ;
      b5:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r5:=0;
      g5:=0;
      b5:=0;
    end;
  arr_src_ptr2:=arr_src_ptr+arr_src_width-1;
  if (arr_src_ptr2^<>background_color) then
    begin
      r6:=arr_src_ptr2^{shr 00};
      g6:=arr_src_ptr2^ shr 08 ;
      b6:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r6:=0;
      g6:=0;
      b6:=0;
    end;
  arr_src_ptr2:=arr_src_ptr+arr_src_width;
  if (arr_src_ptr2^<>background_color) then
    begin
      r7:=arr_src_ptr2^{shr 00};
      g7:=arr_src_ptr2^ shr 08 ;
      b7:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r7:=0;
      g7:=0;
      b7:=0;
    end;
  arr_src_ptr2:=arr_src_ptr+arr_src_width+1;
  if (arr_src_ptr2^<>background_color) then
    begin
      r8:=arr_src_ptr2^{shr 00};
      g8:=arr_src_ptr2^ shr 08 ;
      b8:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r8:=0;
      g8:=0;
      b8:=0;
    end;
  arr_src_ptr^:={clRed}RGB(Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/non_zero_pix_cnt),
                           Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/non_zero_pix_cnt),
                           Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/non_zero_pix_cnt));
end; {$endregion}



(******************************* Bitmap Loading *******************************)

function CrtTPicInstFromHDDSrc(constref location:string): TPicture;                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=TPicture.Create;
  Result.LoadFromFile(location);
end; {$endregion}
function CrtTBmpInstFromImgLst(constref ImgLstGetBmp:TProc1; constref img_ind:integer=0): TBitmap;                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=TBitmap.Create;
  ImgLstGetBmp(img_ind,Result);
end; {$endregion}
function CrtTBmpInst          (constref bmp_src:TBitmap; var bmp_dst_ptr:PInteger): TBitmap;                      inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      Result     :=TBitmap.Create;
      Width      :=bmp_src.width;
      Height     :=bmp_src.height;
      bmp_dst_ptr:=GetBmpHandle(Result);
      Canvas.Draw(0,0,bmp_src);
    end;
end; {$endregion}
function CrtTBmpInst          (constref bmp_dst_width,bmp_dst_height:integer; var bmp_src_ptr:PInteger): TBitmap; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      Result     :=TBitmap.Create;
      PixelFormat:=pf32bit;
      Width      :=bmp_dst_width;
      Height     :=bmp_dst_height;
      bmp_src_ptr:=GetBmpHandle(Result);
    end;
end; {$endregion}



(************************* Transparent Image Routines *************************)

{Clear All Specified Buffers--------------------------} {$region -fold}
procedure TFastImage.ClrArr(arr_clear_val:word); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  {Color/Alpha of Current Layer} {$region -fold}

  // NT - not transparent pixels;
  if Odd(arr_clear_val>>10) then
    begin
      nt_pix_intr_ccl_arr:=Nil;
      {SetLength(nt_pix_intr_ccl_arr,1);
      nt_pix_intr_ccl_arr[0]:=0;}
    end;

  // PT - partly transparent pixels;
  // color channel;
  if Odd(arr_clear_val>>09) then
    begin
      pt_pix_intr_ccl_arr:=Nil;
      {SetLength(pt_pix_intr_ccl_arr,1);
      pt_pix_intr_ccl_arr[0]:=0;}
    end;
  // alpha channel
  if Odd(arr_clear_val>>08) then
    begin
      pt_pix_byte_acl_arr:=Nil;
      {SetLength(pt_pix_byte_acl_arr,1);
      pt_pix_byte_acl_arr[0]:=0;}
    end; {$endregion}

  {Color       of Lower   Layer} {$region -fold}

  // NT - not transparent pixels;
  if Odd(arr_clear_val>>07) then
    begin
      nt_pix_intr_cll_arr:=Nil;
      {SetLength(nt_pix_intr_cll_arr,1);
      nt_pix_intr_cll_arr[0]:=0;}
    end;

  // PT - partly transparent pixels;
  if Odd(arr_clear_val>>06) then
    begin
      pt_pix_intr_cll_arr:=Nil;
      {SetLength(pt_pix_intr_cll_arr,1);
      pt_pix_intr_cll_arr[0]:=0;}
    end; {$endregion}

  {Value       of Current Layer} {$region -fold}

  // NT - not transparent pixels;
  if Odd(arr_clear_val>>05) then
    begin
      nt_pix_intr_val_arr:=Nil;
      {SetLength(nt_pix_intr_val_arr,1);
      nt_pix_intr_val_arr[0]:=0;}
    end;

  // PT - partly transparent pixels; reserved;
  if Odd(arr_clear_val>>04) then
    begin
      pt_pix_intr_val_arr:=Nil;
      {SetLength(pt_pix_intr_val_arr,1);
      pt_pix_intr_val_arr[0]:=0;}
    end; {$endregion}

  {Counts of Items in Rows-----} {$region -fold}

  // NT - not transparent pixels;
  if Odd(arr_clear_val>>03) then
    begin
      nt_pix_intr_cnt_arr:=Nil;
      {SetLength(nt_pix_intr_cnt_arr,1);
      nt_pix_intr_cnt_arr[0]:=0;}
    end;

  // PT - partly transparent pixels;
  if Odd(arr_clear_val>>02) then
    begin
      pt_pix_intr_cnt_arr:=Nil;
      {SetLength(pt_pix_intr_cnt_arr,1);
      pt_pix_intr_cnt_arr[0]:=0;}
    end; {$endregion}

  {Items Shifts----------------} {$region -fold}

  // NT - not transparent pixels;
  if Odd(arr_clear_val>>01) then
    begin
      nt_pix_intr_sht_arr:=Nil;
      {SetLength(nt_pix_intr_sht_arr,1);
      nt_pix_intr_sht_arr[0]:=0;}
    end;

  // PT - partly transparent pixels;
  if Odd(arr_clear_val>>00) then
    begin
      pt_pix_intr_sht_arr:=Nil;
      {SetLength(pt_pix_intr_sht_arr,1);
      pt_pix_intr_sht_arr[0]:=0;}
    end; {$endregion}

end; {$endregion} {$endregion}

{Define Image Kind------------------------------------} {$region -fold}
procedure TFastImage.DetImageKind; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr  : PInteger;
  first_pix_alpha: integer;
  x,y            : integer;
  d_width        : integer;
begin

  if (bmp_ftimg_width =0) or (bmp_src_rct_clp.width =0) or
     (bmp_ftimg_height=0) or (bmp_src_rct_clp.height=0) then
    begin
      nt_pix_cnt:=0;
      pt_pix_cnt:=0;
      img_kind  :=10;
      Exit;
    end;

  if (img_kind=11) then
    begin
      nt_pix_cnt:=0;
      pt_pix_cnt:=0;
      Exit;
    end;

  if mask_template_calc then
    begin
      nt_pix_cnt:=0;
      pt_pix_cnt:=0;
      img_kind  :=12;
      Exit;
    end;

  d_width        := bmp_ftimg_width-bmp_src_rct_clp.width;
  pix_color_ptr  :=@bmp_color_ptr  [bmp_src_rct_clp.left+
                    bmp_ftimg_width*bmp_src_rct_clp.top];
  first_pix_alpha:=pix_color_ptr^>>24;
  zr_pix_cnt     :=0;
  pt_pix_cng_cnt :=0;
  nt_pix_cnt     :=0;
  pt_pix_cnt     :=0;
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_color_ptr^<<08=000) then
            Inc(zr_pix_cnt);
          if (pix_color_ptr^>>24=255) then
            Inc(nt_pix_cnt);
          if (pix_color_ptr^>>24>000) and (pix_color_ptr^>>24<255) then
            begin
              if (pix_color_ptr^>>24=first_pix_alpha) then
                Inc(pt_pix_cng_cnt);
              Inc(pt_pix_cnt);
            end;
          Inc(pix_color_ptr);
        end;
      Inc(pix_color_ptr,d_width)
    end;

  if (pt_pix_cng_cnt<>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (zr_pix_cnt    <>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (nt_pix_cnt     >0)                                            and
     (pt_pix_cnt     >0)                                            then
    img_kind:=0;

  if (pt_pix_cng_cnt<>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (zr_pix_cnt    <>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (nt_pix_cnt     >0)                                            and
     (pt_pix_cnt     =0)                                            then
    img_kind:=1;

  if (pt_pix_cng_cnt<>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (zr_pix_cnt    <>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (nt_pix_cnt     =0)                                            and
     (pt_pix_cnt     >0)                                            then
    img_kind:=2;

  if (pt_pix_cng_cnt<>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (zr_pix_cnt    <>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
    ((nt_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) or
     (nt_pix_cnt     =0))                                           and
     (pt_pix_cnt     =0)                                            then
    img_kind:=3;

  if (pt_pix_cng_cnt =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (zr_pix_cnt    <>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (nt_pix_cnt     =0)                                            and
     (pt_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) then
    begin
      col_trans_arr[2]:=first_pix_alpha;
      img_kind:=4;
    end;

  if (pt_pix_cng_cnt<>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (zr_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (nt_pix_cnt     >0)                                            and
     (pt_pix_cnt     >0)                                            then
    img_kind:=5;

  if (pt_pix_cng_cnt<>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (zr_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (nt_pix_cnt     >0)                                            and
     (pt_pix_cnt     =0)                                            then
    img_kind:=6;

  if (pt_pix_cng_cnt<>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (zr_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (nt_pix_cnt     =0)                                            and
     (pt_pix_cnt     >0)                                            then
    img_kind:=7;

  if (pt_pix_cng_cnt =0)                                            and
     (zr_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (nt_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (pt_pix_cnt     =0)                                            then
    img_kind:=8;

  if (pt_pix_cng_cnt =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (zr_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (nt_pix_cnt     =0)                                            and
     (pt_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) then
    img_kind:=9;

  if (pt_pix_cng_cnt =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (zr_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (nt_pix_cnt     =0)                                            and
     (pt_pix_cnt     =0)                                            then
    img_kind:=10;

  nt_pix_cnt:=0;
  pt_pix_cnt:=0;

end; {$endregion} {$endregion}

{Create Array    of Items Counts  in Rows from Bitmap-} {$region -fold}
// color and alpha are in separate bitmaps
// NT - not transparent pixels;
procedure TFastImage.CrtNTCountBmpS; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr             : PInteger;
  nt_pix_cnt_arr_ptr        : PInteger;
  nt_pix_arr_row_mrg_btm_ptr: PInteger;
  nt_pix_cnt_row            : integer=0;
  x,y,i                     : integer;
  d_width                   : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    Exit;
  SetLength(nt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
  d_width           :=bmp_ftimg_width-bmp_src_rct_clp.width;
  nt_pix_cnt        :=0;
  nt_pix_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000];
  pix_alpha_ptr     :=@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top];
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_alpha_ptr^=$FFFFFF) then
            Inc(nt_pix_cnt_row);
          Inc(pix_alpha_ptr);
        end;
      if (nt_pix_cnt_row<>0) then
        begin
          nt_pix_cnt_arr_ptr^:=nt_pix_cnt_row;
          nt_pix_cnt         +=nt_pix_cnt_row;
          nt_pix_cnt_row     :=0;
        end;
      Inc(nt_pix_cnt_arr_ptr);
      Inc(pix_alpha_ptr,d_width);
    end;
  if (nt_pix_cnt=0) then
    Exit;

  {Find Top Margin Value}
  nt_pix_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[0];
  for i:=0 to bmp_src_rct_clp.height-1 do
    begin
      if (nt_pix_cnt_arr_ptr^<>0) then
        Break;
      Inc(nt_pix_cnt_arr_ptr);
    end;
  nt_pix_arr_row_mrg_top:=PInteger(nt_pix_cnt_arr_ptr)-PInteger(@nt_pix_intr_cnt_arr[0]);

  {Find Bottom Margin Value}
  if (nt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
    begin
      nt_pix_arr_row_mrg_btm_ptr:=@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top];
      nt_pix_cnt_arr_ptr        :=@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top];
      for i:=0 to Abs(bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-2) do
        begin
          if (nt_pix_cnt_arr_ptr^<>0) then
            nt_pix_arr_row_mrg_btm_ptr:=nt_pix_cnt_arr_ptr;
          Inc(nt_pix_cnt_arr_ptr);
        end;
      if (nt_pix_cnt_arr_ptr^<>0) then
        nt_pix_arr_row_mrg_btm_ptr:=nt_pix_cnt_arr_ptr;
      nt_pix_arr_row_mrg_btm:=PInteger(@nt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-PInteger(nt_pix_arr_row_mrg_btm_ptr);
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImage.CrtPTCountBmpS; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr             : PInteger;
  pt_pix_cnt_arr_ptr        : PInteger;
  pt_pix_arr_row_mrg_btm_ptr: PInteger;
  pt_pix_cnt_row            : integer=0;
  x,y,i                     : integer;
  d_width                   : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    Exit;
  SetLength(pt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
  d_width           :=bmp_ftimg_width-bmp_src_rct_clp.width;
  pt_pix_cnt        :=0;
  pt_pix_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000];
  pix_alpha_ptr     :=@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top];
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<255) then
            Inc(pt_pix_cnt_row);
          Inc(pix_alpha_ptr,4);
        end;
      if (pt_pix_cnt_row<>0) then
        begin
          pt_pix_cnt_arr_ptr^:=pt_pix_cnt_row;
          pt_pix_cnt         +=pt_pix_cnt_row;
          pt_pix_cnt_row     :=0;
        end;
      Inc(pt_pix_cnt_arr_ptr);
      Inc(pix_alpha_ptr,d_width<<2);
    end;
  if (pt_pix_cnt=0) then
    Exit;

  {Find Top Margin Value}
  pt_pix_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[0];
  for i:=0 to bmp_src_rct_clp.height-1 do
    begin
      if (pt_pix_cnt_arr_ptr^<>0) then
        Break;
      Inc(pt_pix_cnt_arr_ptr);
    end;
  pt_pix_arr_row_mrg_top:=PInteger(pt_pix_cnt_arr_ptr)-PInteger(@pt_pix_intr_cnt_arr[0]);

  {Find Bottom Margin Value}
  if (pt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
    begin
      pt_pix_arr_row_mrg_btm_ptr:=@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top];
      pt_pix_cnt_arr_ptr        :=@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top];
      for i:=0 to Abs(bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-2) do
        begin
          if (pt_pix_cnt_arr_ptr^<>0) then
            pt_pix_arr_row_mrg_btm_ptr:=pt_pix_cnt_arr_ptr;
          Inc(pt_pix_cnt_arr_ptr);
        end;
      if (pt_pix_cnt_arr_ptr^<>0) then
        pt_pix_arr_row_mrg_btm_ptr:=pt_pix_cnt_arr_ptr;
      pt_pix_arr_row_mrg_btm:=PInteger(@pt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-PInteger(pt_pix_arr_row_mrg_btm_ptr);
    end;
end; {$endregion}
// color and alpha are in one bitmap
// NT - not transparent pixels;
procedure TFastImage.CrtNTCountBmpO; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr             : PInteger;
  nt_pix_cnt_arr_ptr        : PInteger;
  nt_pix_arr_row_mrg_btm_ptr: PInteger;
  nt_pix_cnt_row            : integer=0;
  x,y,i                     : integer;
  d_width                   : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    Exit;
  SetLength(nt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
  d_width           :=bmp_ftimg_width-bmp_src_rct_clp.width;
  nt_pix_cnt        :=0;
  nt_pix_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000];
  pix_color_ptr     :=@bmp_color_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top];
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_color_ptr^>>24=255) then
            Inc(nt_pix_cnt_row);
          Inc(pix_color_ptr);
        end;
      if (nt_pix_cnt_row<>0) then
        begin
          nt_pix_cnt_arr_ptr^:=nt_pix_cnt_row;
          nt_pix_cnt         +=nt_pix_cnt_row;
          nt_pix_cnt_row     :=0;
        end;
      Inc(nt_pix_cnt_arr_ptr);
      Inc(pix_color_ptr,d_width);
    end;
  if (nt_pix_cnt=0) then
    Exit;

  {Find Top Margin Value}
  nt_pix_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[0];
  for i:=0 to bmp_src_rct_clp.height-1 do
    begin
      if (nt_pix_cnt_arr_ptr^<>0) then
        Break;
      Inc(nt_pix_cnt_arr_ptr);
    end;
  nt_pix_arr_row_mrg_top:=PInteger(nt_pix_cnt_arr_ptr)-PInteger(@nt_pix_intr_cnt_arr[0]);

  {Find Bottom Margin Value}
  if (nt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
    begin
      nt_pix_arr_row_mrg_btm_ptr:=@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top];
      nt_pix_cnt_arr_ptr        :=@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top];
      for i:=0 to Abs(bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-2) do
        begin
          if (nt_pix_cnt_arr_ptr^<>0) then
            nt_pix_arr_row_mrg_btm_ptr:=nt_pix_cnt_arr_ptr;
          Inc(nt_pix_cnt_arr_ptr);
        end;
      if (nt_pix_cnt_arr_ptr^<>0) then
        nt_pix_arr_row_mrg_btm_ptr:=nt_pix_cnt_arr_ptr;
      nt_pix_arr_row_mrg_btm:=PInteger(@nt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-PInteger(nt_pix_arr_row_mrg_btm_ptr);
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImage.CrtPTCountBmpO; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr             : PInteger;
  pt_pix_cnt_arr_ptr        : PInteger;
  pt_pix_arr_row_mrg_btm_ptr: PInteger;
  pt_pix_cnt_row            : integer=0;
  x,y,i                     : integer;
  d_width                   : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    Exit;
  SetLength(pt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
  d_width           :=bmp_ftimg_width-bmp_src_rct_clp.width;
  pt_pix_cnt        :=0;
  pt_pix_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000];
  pix_color_ptr     :=@bmp_color_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top];
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_color_ptr^>>24>0) and (pix_color_ptr^>>24<255) then
            Inc(pt_pix_cnt_row);
          Inc(pix_color_ptr);
        end;
      if (pt_pix_cnt_row<>0) then
        begin
          pt_pix_cnt_arr_ptr^:=pt_pix_cnt_row;
          pt_pix_cnt         +=pt_pix_cnt_row;
          pt_pix_cnt_row     :=0;
        end;
      Inc(pt_pix_cnt_arr_ptr);
      Inc(pix_color_ptr,d_width);
    end;
  if (pt_pix_cnt=0) then
    Exit;

  {Find Top Margin Value}
  pt_pix_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[0];
  for i:=0 to bmp_src_rct_clp.height-1 do
    begin
      if (pt_pix_cnt_arr_ptr^<>0) then
        Break;
      Inc(pt_pix_cnt_arr_ptr);
    end;
  pt_pix_arr_row_mrg_top:=PInteger(pt_pix_cnt_arr_ptr)-PInteger(@pt_pix_intr_cnt_arr[0]);

  {Find Bottom Margin Value}
  if (pt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
    begin
      pt_pix_arr_row_mrg_btm_ptr:=@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top];
      pt_pix_cnt_arr_ptr        :=@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top];
      for i:=0 to Abs(bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-2) do
        begin
          if (pt_pix_cnt_arr_ptr^<>0) then
            pt_pix_arr_row_mrg_btm_ptr:=pt_pix_cnt_arr_ptr;
          Inc(pt_pix_cnt_arr_ptr);
        end;
      if (pt_pix_cnt_arr_ptr^<>0) then
        pt_pix_arr_row_mrg_btm_ptr:=pt_pix_cnt_arr_ptr;
      pt_pix_arr_row_mrg_btm:=PInteger(@pt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-PInteger(pt_pix_arr_row_mrg_btm_ptr);
    end;
end; {$endregion} {$endregion}

{Create Array    of Items Counts  in Rows from Array--} {$region -fold}
// NT - not transparent pixels;
procedure TFastImage.CrtNTCountArrA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr             : PInteger;
  nt_pix_cnt_arr_ptr        : PInteger;
  nt_pix_arr_row_mrg_btm_ptr: PInteger;
  nt_pix_cnt_row            : integer=0;
  x,y,i,n                   : integer;
  d_width                   : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    Exit;
  //SetLength(nt_pix_intr_cnt_arr,0);
  SetLength(nt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
  d_width           :=bmp_ftimg_width-bmp_src_rct_clp.width;
  nt_pix_cnt        :=0;
  nt_pix_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000];
  pix_alpha_ptr     :=@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top];
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_alpha_ptr^{>}<>0) then
            Inc(nt_pix_cnt_row);
          Inc(pix_alpha_ptr);
        end;
      if (nt_pix_cnt_row<>0) then
        begin
          nt_pix_cnt_arr_ptr^:=nt_pix_cnt_row;
          nt_pix_cnt         +=nt_pix_cnt_row;
          nt_pix_cnt_row     :=0;
        end;
      Inc(nt_pix_cnt_arr_ptr);
      Inc(pix_alpha_ptr,d_width);
    end;
  if (nt_pix_cnt=0) then
    Exit;

  {Find Top Margin Value}
  nt_pix_arr_row_mrg_top:=0;
  nt_pix_cnt_arr_ptr    :=@nt_pix_intr_cnt_arr[0];
  for i:=0 to bmp_src_rct_clp.height-1 do
    begin
      if (nt_pix_cnt_arr_ptr^<>0) then
        Break;
      Inc(nt_pix_cnt_arr_ptr);
    end;
  nt_pix_arr_row_mrg_top:=PInteger(nt_pix_cnt_arr_ptr)-PInteger(@nt_pix_intr_cnt_arr[0]);

  {Find Bottom Margin Value}
  if (nt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
    begin
      nt_pix_arr_row_mrg_btm    :=0;
      nt_pix_arr_row_mrg_btm_ptr:=@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top];
      nt_pix_cnt_arr_ptr        :=@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top];
      for i:=0 to Abs(bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-2) do
        begin
          if (nt_pix_cnt_arr_ptr^<>0) then
            nt_pix_arr_row_mrg_btm_ptr:=nt_pix_cnt_arr_ptr;
          Inc(nt_pix_cnt_arr_ptr);
        end;
      if (nt_pix_cnt_arr_ptr^<>0) then
        nt_pix_arr_row_mrg_btm_ptr:=nt_pix_cnt_arr_ptr;
      n:=PInteger(@nt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-PInteger(nt_pix_arr_row_mrg_btm_ptr);
      if (n>0) then
        nt_pix_arr_row_mrg_btm:=n;
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImage.CrtPTCountArrA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr             : PInteger;
  pt_pix_cnt_arr_ptr        : PInteger;
  pt_pix_arr_row_mrg_btm_ptr: PInteger;
  pt_pix_cnt_row            : integer=0;
  x,y,i,p                   : integer;
  d_width                   : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    Exit;
  //SetLength(pt_pix_intr_cnt_arr,0);
  SetLength(pt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
  d_width           :=bmp_ftimg_width-bmp_src_rct_clp.width;
  pt_pix_cnt        :=0;
  pt_pix_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000];
  pix_alpha_ptr     :=@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top];
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_alpha_ptr^{>}<>0) then
            Inc(pt_pix_cnt_row);
          Inc(pix_alpha_ptr);
        end;
      if (pt_pix_cnt_row<>0) then
        begin
          pt_pix_cnt_arr_ptr^:=pt_pix_cnt_row;
          pt_pix_cnt         +=pt_pix_cnt_row;
          pt_pix_cnt_row     :=0;
        end;
      Inc(pt_pix_cnt_arr_ptr);
      Inc(pix_alpha_ptr,d_width);
    end;
  if (pt_pix_cnt=0) then
    Exit;

  {Find Top Margin Value}
  pt_pix_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[0];
  for i:=0 to bmp_src_rct_clp.height-1 do
    begin
      if (pt_pix_cnt_arr_ptr^<>0) then
        Break;
      Inc(pt_pix_cnt_arr_ptr);
    end;
  pt_pix_arr_row_mrg_top:=PInteger(pt_pix_cnt_arr_ptr)-PInteger(@pt_pix_intr_cnt_arr[0]);

  {Find Bottom Margin Value}
  if (pt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
    begin
      pt_pix_arr_row_mrg_btm_ptr:=@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top];
      pt_pix_cnt_arr_ptr        :=@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top];
      for i:=0 to Abs(bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-2) do
        begin
          if (pt_pix_cnt_arr_ptr^<>0) then
            pt_pix_arr_row_mrg_btm_ptr:=pt_pix_cnt_arr_ptr;
          Inc(pt_pix_cnt_arr_ptr);
        end;
      if (pt_pix_cnt_arr_ptr^<>0) then
        pt_pix_arr_row_mrg_btm_ptr:=pt_pix_cnt_arr_ptr;
      p:=PInteger(@pt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-PInteger(pt_pix_arr_row_mrg_btm_ptr);
      if (p>0) then
        pt_pix_arr_row_mrg_btm:=p;
    end;
end; {$endregion}{$endregion}

{Create Array    of Items Shifts  in Rows from Bitmap-} {$region -fold}
// color and alpha are in separate bitmaps
// NT - not transparent pixels;
procedure TFastImage.CrtNTShiftBmpS; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_sht_arr_ptr: PInteger;
  pix_alpha_ptr          : PInteger;
  x,y                    : integer;
  d_width                : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    Exit;
  if (nt_pix_cnt=0) then
    Exit;
  SetLength(nt_pix_intr_sht_arr,nt_pix_cnt);
  d_width                :=bmp_ftimg_width-bmp_src_rct_clp.width;
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000];
  pix_alpha_ptr          :=@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top];
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_alpha_ptr^=$FFFFFF) then
            begin
                  nt_pix_intr_sht_arr_ptr^:=x;
              Inc(nt_pix_intr_sht_arr_ptr);
            end;
          Inc(pix_alpha_ptr);
        end;
      Inc(pix_alpha_ptr,d_width);
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImage.CrtPTShiftBmpS; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_intr_sht_arr_ptr: PInteger;
  pix_alpha_ptr          : PByte;
  x,y                    : integer;
  d_width                : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    Exit;
  if (pt_pix_cnt=0) then
    Exit;
  SetLength(pt_pix_intr_sht_arr,pt_pix_cnt);
  d_width                :=bmp_ftimg_width-bmp_src_rct_clp.width;
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000];
  pix_alpha_ptr          :=@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top];
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<255) then
            begin
                  pt_pix_intr_sht_arr_ptr^:=x;
              Inc(pt_pix_intr_sht_arr_ptr);
            end;
          Inc(pix_alpha_ptr,4);
        end;
      Inc(pix_alpha_ptr,d_width<<2);
    end;
end; {$endregion}
// color and alpha are in one bitmap
// NT - not transparent pixels;
procedure TFastImage.CrtNTShiftBmpO; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_sht_arr_ptr: PInteger;
  pix_color_ptr          : PInteger;
  x,y                    : integer;
  d_width                : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    Exit;
  if (nt_pix_cnt=0) then
    Exit;
  SetLength(nt_pix_intr_sht_arr,nt_pix_cnt);
  d_width                :=bmp_ftimg_width-bmp_src_rct_clp.width;
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000];
  pix_color_ptr          :=@bmp_color_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top];
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_color_ptr^>>24=255) then
            begin
                  nt_pix_intr_sht_arr_ptr^:=x{+bmp_src_rct_clp.left};
              Inc(nt_pix_intr_sht_arr_ptr);
            end;
          Inc(pix_color_ptr);
        end;
      Inc(pix_color_ptr,d_width);
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImage.CrtPTShiftBmpO; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_intr_sht_arr_ptr: PInteger;
  pix_color_ptr          : PInteger;
  x,y                    : integer;
  d_width                : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    Exit;
  if (pt_pix_cnt=0) then
    Exit;
  SetLength(pt_pix_intr_sht_arr,pt_pix_cnt);
  d_width                :=bmp_ftimg_width-bmp_src_rct_clp.width;
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000];
  pix_color_ptr          :=@bmp_color_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top];
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_color_ptr^>>24>0) and (pix_color_ptr^>>24<255) then
            begin
                  pt_pix_intr_sht_arr_ptr^:=x{+bmp_src_rct_clp.left};
              Inc(pt_pix_intr_sht_arr_ptr);
            end;
          Inc(pix_color_ptr);
        end;
      Inc(pix_color_ptr,d_width);
    end;
end; {$endregion} {$endregion}

{Create Array    of Items Shifts  in Rows from Array--} {$region -fold}
// NT - not transparent pixels;
procedure TFastImage.CrtNTShiftArrA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_sht_arr_ptr: PInteger;
  pix_alpha_ptr          : PInteger;
  x,y                    : integer;
  d_width                : integer;
begin

  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    Exit;

  if (nt_pix_cnt=0) then
    Exit;

  //SetLength(nt_pix_intr_sht_arr,0);
  SetLength(nt_pix_intr_sht_arr,nt_pix_cnt);
  d_width                :=bmp_ftimg_width-bmp_src_rct_clp.width;
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000];
  pix_alpha_ptr          :=@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top];
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_alpha_ptr^{>}<>0) then
            begin
                  nt_pix_intr_sht_arr_ptr^:=x;
              Inc(nt_pix_intr_sht_arr_ptr);
            end;
          Inc(pix_alpha_ptr);
        end;
      Inc(pix_alpha_ptr,d_width);
    end;

end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImage.CrtPTShiftArrA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_intr_sht_arr_ptr: PInteger;
  pix_alpha_ptr          : PInteger;
  x,y                    : integer;
  d_width                : integer;
begin

  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    Exit;

  if (pt_pix_cnt=0) then
    Exit;

  //SetLength(pt_pix_intr_sht_arr,0);
  SetLength(pt_pix_intr_sht_arr,pt_pix_cnt);
  d_width                :=bmp_ftimg_width-bmp_src_rct_clp.width;
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000];
  pix_alpha_ptr          :=@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top];
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_alpha_ptr^{>}<>0) then
            begin
                  pt_pix_intr_sht_arr_ptr^:=x;
              Inc(pt_pix_intr_sht_arr_ptr);
            end;
          Inc(pix_alpha_ptr);
        end;
      Inc(pix_alpha_ptr,d_width);
    end;

end; {$endregion} {$endregion}

{Store Color     of Current Layer         from Bmp/Arr} {$region -fold}
// NT - not transparent pixels;
{store color channel}
procedure TFastImage.StrNTColorBmpA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (nt_pix_cnt=0) then
    Exit;
  SetLength(nt_pix_intr_ccl_arr,nt_pix_cnt);
  first_row_pix_ptr      :=@bmp_color_ptr      [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000];
  nt_pix_intr_ccl_arr_ptr:=@nt_pix_intr_ccl_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
              nt_pix_intr_ccl_arr_ptr^:=(pix_color_ptr+nt_pix_intr_sht_arr_ptr^)^;
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_ccl_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_ftimg_width);
    end;
end; {$endregion}
// PT - partly transparent pixels;
{store color channel}
procedure TFastImage.StrPTColorBmpA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (pt_pix_cnt=0) then
    Exit;
  SetLength(pt_pix_intr_ccl_arr,pt_pix_cnt);
  first_row_pix_ptr      :=@bmp_color_ptr      [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_intr_ccl_arr_ptr:=@pt_pix_intr_ccl_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
              pt_pix_intr_ccl_arr_ptr^:=(pix_color_ptr+pt_pix_intr_sht_arr_ptr^)^;
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_ccl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_ftimg_width);
    end;
end; {$endregion}
//** color and alpha are in separate bitmaps
{store alpha channel into byte array---}
procedure TFastImage.StrPTAlphaArrS; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr          : PByte;
  first_row_pix_ptr      : PByte;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (pt_pix_cnt=0) then
    Exit;
  SetLength(pt_pix_byte_acl_arr,pt_pix_cnt);
  first_row_pix_ptr      :=@bmp_alpha_ptr      [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_alpha_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
              pt_pix_byte_acl_arr_ptr^:=(pix_alpha_ptr+pt_pix_intr_sht_arr_ptr^<<2)^;
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_ftimg_width<<2);
    end;
end; {$endregion}
{store alpha channel into color channel}
procedure TFastImage.StrPTAlphaBmpS; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr          : PByte;
  first_row_pix_ptr      : PByte;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (pt_pix_cnt=0) then
    Exit;
  first_row_pix_ptr      :=@bmp_alpha_ptr      [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_intr_ccl_arr_ptr:=@pt_pix_intr_ccl_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_alpha_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
              pt_pix_intr_ccl_arr_ptr^+=(pix_alpha_ptr+pt_pix_intr_sht_arr_ptr^<<2)^<<24;
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_ccl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_ftimg_width<<2);
    end;
end; {$endregion}
//** color and alpha are in one bitmap
{store alpha channel into byte array---}
procedure TFastImage.StrPTAlphaArrO; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (pt_pix_cnt=0) then
    Exit;
  SetLength(pt_pix_byte_acl_arr,pt_pix_cnt);
  first_row_pix_ptr      :=@bmp_color_ptr      [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
              pt_pix_byte_acl_arr_ptr^:=(pix_color_ptr+pt_pix_intr_sht_arr_ptr^)^>>24;
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_ftimg_width);
    end;
end; {$endregion}
{store alpha channel into color channel}
procedure TFastImage.StrPTAlphaBmpO; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (pt_pix_cnt=0) then
    Exit;
  first_row_pix_ptr      :=@bmp_color_ptr      [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_intr_ccl_arr_ptr:=@pt_pix_intr_ccl_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
              pt_pix_intr_ccl_arr_ptr^:=(pix_color_ptr+pt_pix_intr_sht_arr_ptr^)^;
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_ccl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_ftimg_width);
    end;
end; {$endregion} {$endregion}

{Store Color     of Lower   Layer         from Bitmap-} {$region -fold}
// NT - not transparent pixels;
procedure TFastImage.StrNTLowerBmpA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_cll_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (nt_pix_cnt=0) then
    Exit;
  //SetLength(nt_pix_intr_cll_arr,0);
  SetLength(nt_pix_intr_cll_arr,nt_pix_cnt);
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(nt_pix_arr_row_mrg_top+{bmp_src_rct_clp.top}bmp_ftimg_top)*bmp_bckgd_width+{bmp_src_rct_clp.left}bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000];
  nt_pix_intr_cll_arr_ptr:=@nt_pix_intr_cll_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
              nt_pix_intr_cll_arr_ptr^:=(pix_color_ptr+nt_pix_intr_sht_arr_ptr^)^;
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_cll_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImage.StrPTLowerBmpA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_cll_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (pt_pix_cnt=0) then
    Exit;
  SetLength(pt_pix_intr_cll_arr,pt_pix_cnt);
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_intr_cll_arr_ptr:=@pt_pix_intr_cll_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
              pt_pix_intr_cll_arr_ptr^:=(pix_color_ptr+pt_pix_intr_sht_arr_ptr^)^;
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_cll_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// store alpha from byte array;
procedure TFastImage.StrPTLowerArrA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_intr_cll_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  i                      : integer;
begin
  pt_pix_intr_cll_arr_ptr:=@pt_pix_intr_cll_arr[0];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[0];
  for i:=0 to pt_pix_cnt-1 do
    begin
          pt_pix_intr_cll_arr_ptr^+=pt_pix_byte_acl_arr_ptr^<<24;
      Inc(pt_pix_intr_cll_arr_ptr);
      Inc(pt_pix_byte_acl_arr_ptr);
    end;
end; {$endregion} {$endregion}

{Store Value     of Current Layer         from Array--} {$region -fold}
procedure TFastImage.StrNTValueArrA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_value_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_val_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (nt_pix_cnt=0) then
    Exit;
  //SetLength(nt_pix_intr_val_arr,0);
  SetLength(nt_pix_intr_val_arr,nt_pix_cnt);
  first_row_pix_ptr      :=@bmp_value_ptr      [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000];
  nt_pix_intr_val_arr_ptr:=@nt_pix_intr_val_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_value_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
              nt_pix_intr_val_arr_ptr^:=(pix_value_ptr+nt_pix_intr_sht_arr_ptr^)^;
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_val_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_ftimg_width);
    end;
end; {$endregion} {$endregion}

{Set Chess Order of Alpha Channel in Rows from Bitmap-} {$region -fold}
// calculation of image sides Parity}
procedure TFastImage.CalcSidesParity; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  if Odd(bmp_src_rct_clp.width) then
    width_parity:=False
  else
    width_parity:=True;

  if Odd(bmp_src_rct_clp.height) then
    height_parity:=False
  else
    height_parity:=True;

end; {$endregion}
// color and alpha are in separate bitmaps
// NT - not transparent pixels;
procedure TFastImage.SetNTChessBmpS0; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr: PInteger;
  x,y,w,h      : integer;
  d_width      : integer;
begin

  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (bmp_src_rct_clp.width*bmp_src_rct_clp.height<6) then
    Exit;

  w            :=Trunc(bmp_src_rct_clp.width /2)-1;
  h            :=Trunc(bmp_src_rct_clp.height/2)-1;
  d_width      :=bmp_ftimg_width-bmp_src_rct_clp.width;
  pix_alpha_ptr:=@bmp_alpha_ptr[bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top];

  if width_parity then
    begin
      if height_parity then
        for y:=0 to h do
          begin
            for x:=0 to w do
              begin
                if (pix_alpha_ptr^=$FFFFFF) then
                  pix_alpha_ptr^:=$000000;
                Inc(pix_alpha_ptr,2);
              end;
            Inc(pix_alpha_ptr,d_width);
            Dec(pix_alpha_ptr);
            for x:=0 to w do
              begin
                if (pix_alpha_ptr^=$FFFFFF) then
                  pix_alpha_ptr^:=$000000;
                Inc(pix_alpha_ptr,2);
              end;
            Inc(pix_alpha_ptr,d_width);
            Inc(pix_alpha_ptr);
          end
      else
        begin
          for x:=0 to w do
            begin
              if (pix_alpha_ptr^=$FFFFFF) then
                pix_alpha_ptr^:=$000000;
              Inc(pix_alpha_ptr,2);
            end;
          Inc(pix_alpha_ptr,d_width);
        end;
    end
  else
    for y:=0 to bmp_src_rct_clp.height-1 do
      begin
        for x:=0 to w do
          begin
            if (pix_alpha_ptr^=$FFFFFF) then
              pix_alpha_ptr^:=$000000;
            Inc(pix_alpha_ptr,2);
          end;
        Inc(pix_alpha_ptr,d_width);
      end;

end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImage.SetPTChessBmpS0; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr: PByte;
  x,y,w,h      : integer;
  d_width      : integer;
begin

  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (bmp_src_rct_clp.width*bmp_src_rct_clp.height<6) then
    Exit;

  w            :=Trunc(bmp_src_rct_clp.width /2)-1;
  h            :=Trunc(bmp_src_rct_clp.height/2)-1;
  d_width      :=bmp_ftimg_width-bmp_src_rct_clp.width;
  pix_alpha_ptr:=@bmp_alpha_ptr[bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top];

  if width_parity then
    begin
      if height_parity then
        for y:=0 to h do
          begin
            for x:=0 to w do
              begin
                if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<255) then
                  pix_alpha_ptr^:=$000000;
                Inc(pix_alpha_ptr,8);
              end;
            Inc(pix_alpha_ptr,d_width<<2);
            Dec(pix_alpha_ptr,4);
            for x:=0 to w do
              begin
                if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<255) then
                  pix_alpha_ptr^:=$000000;
                Inc(pix_alpha_ptr,8);
              end;
            Inc(pix_alpha_ptr,d_width<<2);
            Inc(pix_alpha_ptr,4);
          end
      else
        begin
          for x:=0 to w do
            begin
              if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<255) then
                pix_alpha_ptr^:=$000000;
              Inc(pix_alpha_ptr,8);
            end;
          Inc(pix_alpha_ptr,d_width<<2);
        end;
    end
  else
    for y:=0 to bmp_src_rct_clp.height-1 do
      begin
        for x:=0 to w do
          begin
            if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<255) then
              pix_alpha_ptr^:=$000000;
            Inc(pix_alpha_ptr,8);
          end;
        Inc(pix_alpha_ptr,d_width<<2);
      end;

end; {$endregion}
// color and alpha are in one bitmap
// NT - not transparent pixels;
procedure TFastImage.SetNTChessBmpO0; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr: PInteger;
  x,y,w,h      : integer;
  d_width      : integer;
begin

  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (bmp_src_rct_clp.width*bmp_src_rct_clp.height<6) then
    Exit;

  w            :=Trunc(bmp_src_rct_clp.width /2)-1;
  h            :=Trunc(bmp_src_rct_clp.height/2)-1;
  d_width      :=bmp_ftimg_width-bmp_src_rct_clp.width;
  pix_alpha_ptr:=@bmp_color_ptr[bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top];

  if width_parity then
    begin
      if height_parity then
        for y:=0 to h do
          begin
            for x:=0 to w do
              begin
                if (pix_alpha_ptr^>>24=255) then
                  pix_alpha_ptr^:=0;
                Inc(pix_alpha_ptr,2);
              end;
            Inc(pix_alpha_ptr,d_width);
            Dec(pix_alpha_ptr);
            for x:=0 to w do
              begin
                if (pix_alpha_ptr^>>24=255) then
                  pix_alpha_ptr^:=0;
                Inc(pix_alpha_ptr,2);
              end;
            Inc(pix_alpha_ptr,d_width);
            Inc(pix_alpha_ptr);
          end
      else
        begin
          for x:=0 to w do
            begin
              if (pix_alpha_ptr^>>24=255) then
                pix_alpha_ptr^:=0;
              Inc(pix_alpha_ptr,2);
            end;
          Inc(pix_alpha_ptr,d_width);
        end;
    end
  else
    for y:=0 to bmp_src_rct_clp.height-1 do
      begin
        for x:=0 to w do
          begin
            if (pix_alpha_ptr^>>24=255) then
              pix_alpha_ptr^:=0;
            Inc(pix_alpha_ptr,2);
          end;
        Inc(pix_alpha_ptr,d_width);
      end;

end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImage.SetPTChessBmpO0; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr: PInteger;
  x,y,w,h      : integer;
  d_width      : integer;
begin

  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (bmp_src_rct_clp.width*bmp_src_rct_clp.height<6) then
    Exit;

  w            :=Trunc(bmp_src_rct_clp.width /2)-1;
  h            :=Trunc(bmp_src_rct_clp.height/2)-1;
  d_width      :=bmp_ftimg_width-bmp_src_rct_clp.width;
  pix_alpha_ptr:=@bmp_color_ptr[bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top];

  if width_parity then
    begin
      if height_parity then
        for y:=0 to h do
          begin
            for x:=0 to w do
              begin
                if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<255) then
                  pix_alpha_ptr^:=0;
                Inc(pix_alpha_ptr,2);
              end;
            Inc(pix_alpha_ptr,d_width);
            Dec(pix_alpha_ptr);
            for x:=0 to w do
              begin
                if (pix_alpha_ptr^>>24>0) and (pix_alpha_ptr^>>24<255) then
                  pix_alpha_ptr^:=0;
                Inc(pix_alpha_ptr,2);
              end;
            Inc(pix_alpha_ptr,d_width);
            Inc(pix_alpha_ptr);
          end
      else
        begin
          for x:=0 to w do
            begin
              if (pix_alpha_ptr^>>24>0) and (pix_alpha_ptr^>>24<255) then
                pix_alpha_ptr^:=0;
              Inc(pix_alpha_ptr,2);
            end;
          Inc(pix_alpha_ptr,d_width);
        end;
    end
  else
    for y:=0 to bmp_src_rct_clp.height-1 do
      begin
        for x:=0 to w do
          begin
            if (pix_alpha_ptr^>>24>0) and (pix_alpha_ptr^>>24<255) then
              pix_alpha_ptr^:=0;
            Inc(pix_alpha_ptr,2);
          end;
        Inc(pix_alpha_ptr,d_width);
      end;

end; {$endregion} {$endregion}

{Create Array of Tiles Bounding Rectangles------------} {$region -fold}
procedure TFastImage.CrtRectArr; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(rect_src_arr,tiles_cnt);
end; {$endregion} {$endregion}

{Full Image Compression-------------------------------} {$region -fold}
// img. kind: 000:
procedure TFastImage.CmpProc000;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // NT - not transparent pixels;
  CrtNTCountBmpO;
  CrtNTCntIndArr;
  CrtNTShiftBmpO;
  StrNTColorBmpA;
  // PT - partly transparent pixels;
  CrtPTCountBmpO;
  CrtPTCntIndArr;
  CrtPTShiftBmpO;
  StrPTColorBmpA;
  // store alpha channel;
  StrPTAlphaArrO;
end; {$endregion}
// img. kind: 001:
procedure TFastImage.CmpProc001;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // NT - not transparent pixels;
  CrtNTCountBmpO;
  CrtNTCntIndArr;
  CrtNTShiftBmpO;
  StrNTColorBmpA;
end; {$endregion}
// img. kind: 002:
procedure TFastImage.CmpProc002;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // PT - partly transparent pixels;
  CrtPTCountBmpO;
  CrtPTCntIndArr;
  CrtPTShiftBmpO;
  StrPTColorBmpA;
  // store alpha channel;
  StrPTAlphaArrO;
end; {$endregion}
// img. kind: 003: empty:
procedure TFastImage.CmpProc003;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {do nothing}
end; {$endregion}
// img. kind: 004: empty:
procedure TFastImage.CmpProc004;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {do nothing}
end; {$endregion}
// img. kind: 005:
procedure TFastImage.CmpProc005;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // NT - not transparent pixels;
  CrtNTCountBmpO;
  CrtNTCntIndArr;
  CrtNTShiftBmpO;
  // PT - partly transparent pixels;
  CrtPTCountBmpO;
  CrtPTCntIndArr;
  CrtPTShiftBmpO;
  // store alpha channel;
  StrPTAlphaArrO;
end; {$endregion}
// img. kind: 006:
procedure TFastImage.CmpProc006;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // NT - not transparent pixels;
  CrtNTCountBmpO;
  CrtNTCntIndArr;
  CrtNTShiftBmpO;
end; {$endregion}
// img. kind: 007:
procedure TFastImage.CmpProc007;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // PT - partly transparent pixels;
  CrtPTCountBmpO;
  CrtPTCntIndArr;
  CrtPTShiftBmpO;
  // store alpha channel;
  StrPTAlphaArrO;
end; {$endregion}
// img. kind: 008: empty:
procedure TFastImage.CmpProc008;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {do nothing}
end; {$endregion}
// img. kind: 009:
procedure TFastImage.CmpProc009;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {do nothing}
end; {$endregion}
// img. kind: 010:
procedure TFastImage.CmpProc010;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {do nothing}
end; {$endregion}
// img. kind: 011:
procedure TFastImage.CmpProc011;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // NT - not transparent pixels;
  CrtNTCountArrA;
  CrtNTCntIndArr;
  CrtNTShiftArrA;
  StrNTValueArrA;
  //StrNTLowerBmpA;
  {// PT - partly transparent pixels;
  CrtPTCountArrA;
  CrtPTCntIndArr;
  CrtPTShiftArrA;
  // store alpha channel;
  StrPTAlphaArrO;}
end; {$endregion}
// img. kind: 012:
procedure TFastImage.CmpProc012;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // NT - not transparent(not black!) pixels;
  CrtNTCountArrA;
  CrtNTCntIndArr;
  CrtNTShiftArrA;
end; {$endregion}
// Procedures Table Init.:
procedure TFastImage.CmpProcInit; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  {Image Description} {$region -fold}
  {
    ----------------Image Has Alpha Channel And Color Channel---------------
    0:
    image has:  not monochrome alpha channel,
                not monochrome color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels>0;

    1:
    image has:  not monochrome alpha channel,
                not monochrome color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;

    2:
    image has:  not monochrome alpha channel,
                not monochrome color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels>0;

    3:
    image has:      monochrome alpha channel(white, not transparent),
                not monochrome color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;

    4:
    image has:      monochrome alpha channel(transparent),
                not monochrome color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels>0;


    ----------------------Image Has Only Alpha Channel----------------------
    5:
    image has:  not monochrome alpha channel,
                            no color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels>0;

    6:
    image has:  not monochrome alpha channel,
                            no color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;

    7:
    image has:  not monochrome alpha channel,
                            no color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels>0;

    8:
    image has:      monochrome alpha channel(white, not transparent),
                            no color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;

    9:
    image has:      monochrome alpha channel(transparent),
                            no color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels>0;


    --------------Image Has No Alpha Channel And Color Channel--------------
    10:
    image has:      no alpha channel(black, invisible),
                    no color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels=0;


    --------------------------Image is Value Array--------------------------
    11:
    count of    not transparent pixels>0;
    count of partly transparent pixels>0;

    --------------------------Image is Mask--------------------------
    12:
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;
  } {$endregion}

  // img. kind: 000:
  CmpProc[000]:=@CmpProc000;
  // img. kind: 001:
  CmpProc[001]:=@CmpProc001;
  // img. kind: 002:
  CmpProc[002]:=@CmpProc002;
  // img. kind: 003:
  CmpProc[003]:=@CmpProc003;
  // img. kind: 004:
  CmpProc[004]:=@CmpProc004;
  // img. kind: 005:
  CmpProc[005]:=@CmpProc005;
  // img. kind: 006:
  CmpProc[006]:=@CmpProc006;
  // img. kind: 007:
  CmpProc[007]:=@CmpProc007;
  // img. kind: 008:
  CmpProc[008]:=@CmpProc008;
  // img. kind: 009:
  CmpProc[009]:=@CmpProc009;
  // img. kind: 010:
  CmpProc[010]:=@CmpProc010;
  // img. kind: 011:
  CmpProc[011]:=@CmpProc011;
  // img. kind: 012:
  CmpProc[012]:=@CmpProc012;

end; {$endregion}

// Final image Compression:
procedure TFastImage.ImgToCImg;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  DetImageKind;
  CmpProc[img_kind];
  SetSdrType;
end; {$endregion} {$endregion}

{Drawing of Compressed Image on Background------------} {$region -fold}

// NT - not transparent pixels:

// not clippped:
procedure TFastImage.FilNTProc0_0(constref args:TFunc0Args; Func0:TFunc0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with args do
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=Func0((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,r,g,b,alpha,d_alpha,pow,d);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// top-bottom clippped:
procedure TFastImage.FilNTProc0_2(constref args:TFunc0Args; Func0:TFunc0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with args do
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=Func0((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,r,g,b,alpha,d_alpha,pow,d);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// left-right-top-bottom clippped:
procedure TFastImage.FilNTProc0_4(constref args:TFunc0Args; Func0:TFunc0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                  with args do
                     (nt_pix_intr_sht_arr_ptr^+v)^:=Func0((nt_pix_intr_sht_arr_ptr^+v)^,r,g,b,alpha,d_alpha,pow,d);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                  with args do
                     (nt_pix_intr_sht_arr_ptr^+v)^:=Func0((nt_pix_intr_sht_arr_ptr^+v)^,r,g,b,alpha,d_alpha,pow,d);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                  with args do
                     (nt_pix_intr_sht_arr_ptr^+v)^:=Func0((nt_pix_intr_sht_arr_ptr^+v)^,r,g,b,alpha,d_alpha,pow,d);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  with args do
                     (nt_pix_intr_sht_arr_ptr^+v)^:=Func0((nt_pix_intr_sht_arr_ptr^+v)^,r,g,b,alpha,d_alpha,pow,d);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}

{Empty}
procedure TFastImage.FilNTValue009; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

end; {$endregion}
{Empty}
procedure TFastImage.FilNTColor009; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

end; {$endregion}

{Monochrome}
// (constant) not clippped:
procedure TFastImage.FilNTValue000; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=col_trans_var.monochrome_val;
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue002; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=col_trans_var.monochrome_val;
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue004; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=col_trans_var.monochrome_val;
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=col_trans_var.monochrome_val;
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=col_trans_var.monochrome_val;
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=col_trans_var.monochrome_val;
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue006; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPFloodFill(bmp_bckgd_ptr,
              rct_dst.pt_rct,
              bmp_bckgd_width,
              col_trans_var.monochrome_val);
end; {$endregion}
// (fading):
// same;

{Additive}
// (constant) not clippped:
procedure TFastImage.FilNTValue010; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.r:=col_trans_var.r_val;
  args.g:=col_trans_var.g_val;
  args.b:=col_trans_var.b_val;
  FilNTProc0_0(args,@Additive);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue012; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.r:=col_trans_var.r_val;
  args.g:=col_trans_var.g_val;
  args.b:=col_trans_var.b_val;
  FilNTProc0_2(args,@Additive);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue014; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.r:=col_trans_var.r_val;
  args.g:=col_trans_var.g_val;
  args.b:=col_trans_var.b_val;
  FilNTProc0_4(args,@Additive);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue016; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPAdditive(bmp_bckgd_ptr,
             rct_dst.pt_rct,
             bmp_bckgd_width,
             col_trans_var.monochrome_val);
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilNTValue011; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDec((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,r_val,g_val,b_val,col_trans_arr[1]);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilNTValue013; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDec((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,r_val,g_val,b_val,col_trans_arr[1]);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue015; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                  with col_trans_var do
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec((nt_pix_intr_sht_arr_ptr^+v)^,
                                                                r_val,
                                                                g_val,
                                                                b_val,
                                                                col_trans_arr[1]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                  with col_trans_var do
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec((nt_pix_intr_sht_arr_ptr^+v)^,
                                                                r_val,
                                                                g_val,
                                                                b_val,
                                                                col_trans_arr[1]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                  with col_trans_var do
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec((nt_pix_intr_sht_arr_ptr^+v)^,
                                                                r_val,
                                                                g_val,
                                                                b_val,
                                                                col_trans_arr[1]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  with col_trans_var do
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec((nt_pix_intr_sht_arr_ptr^+v)^,
                                                                r_val,
                                                                g_val,
                                                                b_val,
                                                                col_trans_arr[1]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImage.FilNTValue017; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPAdditiveDec(bmp_bckgd_ptr,
                rct_dst.pt_rct,
                bmp_bckgd_width,
                col_trans_var.monochrome_val,
                col_trans_arr[1]);
end; {$endregion}

{Alphablend}
// (constant) not clippped:
procedure TFastImage.FilNTValue020; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  d_alpha                : byte;
begin
  d_alpha                :=255-col_trans_arr[2];
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlend((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,r_val,g_val,b_val,d_alpha,col_trans_arr[2]);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue022; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  d_alpha                : byte;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  d_alpha                :=255-col_trans_arr[2];
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlend((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,r_val,g_val,b_val,d_alpha,col_trans_arr[2]);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue024; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  d_alpha                : byte;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  d_alpha                :=255-col_trans_arr[2];
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                  with col_trans_var do
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend((nt_pix_intr_sht_arr_ptr^+v)^,
                                                               r_val,
                                                               g_val,
                                                               b_val,
                                                               d_alpha,
                                                               col_trans_arr[2]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                  with col_trans_var do
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend((nt_pix_intr_sht_arr_ptr^+v)^,
                                                               r_val,
                                                               g_val,
                                                               b_val,
                                                               d_alpha,
                                                               col_trans_arr[2]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                  with col_trans_var do
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend((nt_pix_intr_sht_arr_ptr^+v)^,
                                                               r_val,
                                                               g_val,
                                                               b_val,
                                                               d_alpha,
                                                               col_trans_arr[2]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  with col_trans_var do
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend((nt_pix_intr_sht_arr_ptr^+v)^,
                                                               r_val,
                                                               g_val,
                                                               b_val,
                                                               d_alpha,
                                                               col_trans_arr[2]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue026; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPAlphaBlend(bmp_bckgd_ptr,
               rct_dst.pt_rct,
               bmp_bckgd_width,
               col_trans_var.monochrome_val,
               col_trans_arr[2]);
end; {$endregion}
// (fading):
// same;

{Inverse}
// (constant) not clippped:
procedure TFastImage.FilNTValue030; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  {first_row_pix_ptr      :=@bmp_bckgd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=Inverse((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;}
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue032; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=Inverse((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue034; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=Inverse((nt_pix_intr_sht_arr_ptr^+v)^);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=Inverse((nt_pix_intr_sht_arr_ptr^+v)^);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=Inverse((nt_pix_intr_sht_arr_ptr^+v)^);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=Inverse((nt_pix_intr_sht_arr_ptr^+v)^);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue036; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPInverse(bmp_bckgd_ptr,
            rct_dst.pt_rct,
            bmp_bckgd_width);
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilNTValue031; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=InverseDec((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,col_trans_arr[3]);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilNTValue033; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=InverseDec((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,col_trans_arr[3]);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue035; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=InverseDec((nt_pix_intr_sht_arr_ptr^+v)^,
                                                               col_trans_arr[3]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=InverseDec((nt_pix_intr_sht_arr_ptr^+v)^,
                                                               col_trans_arr[3]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=InverseDec((nt_pix_intr_sht_arr_ptr^+v)^,
                                                               col_trans_arr[3]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=InverseDec((nt_pix_intr_sht_arr_ptr^+v)^,
                                                               col_trans_arr[3]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImage.FilNTValue037; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPInverseDec(bmp_bckgd_ptr,
               rct_dst.pt_rct,
               bmp_bckgd_width,
               col_trans_arr[3]);
end; {$endregion}

{Highlight}
// (constant) not clippped:
procedure TFastImage.FilNTValue040; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.pow:=col_trans_arr[4];
  FilNTProc0_0(args,@Highlight);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue042; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.pow:=col_trans_arr[4];
  FilNTProc0_2(args,@Highlight);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue044; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.pow:=col_trans_arr[4];
  FilNTProc0_4(args,@Highlight);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue046; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPHighlight(bmp_bckgd_ptr,
              rct_dst.pt_rct,
              bmp_bckgd_width,
              col_trans_arr[4]);
end; {$endregion}
// (fading):
// same;

{Darken}
// (constant) not clippped:
procedure TFastImage.FilNTValue050; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.pow:=col_trans_arr[5];
  FilNTProc0_0(args,@Darken);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue052; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.pow:=col_trans_arr[5];
  FilNTProc0_2(args,@Darken);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue054; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.pow:=col_trans_arr[5];
  FilNTProc0_4(args,@Darken);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue056; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPDarken(bmp_bckgd_ptr,
           rct_dst.pt_rct,
           bmp_bckgd_width,
           col_trans_arr[5]);
end; {$endregion}
// (fading):
// same;

{GrayscaleR}
// (constant) not clippped:
procedure TFastImage.FilNTValue060; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc0_0(Default(TFunc0Args),@GrayscaleR);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue062; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc0_2(Default(TFunc0Args),@GrayscaleR);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue064; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc0_4(Default(TFunc0Args),@GrayscaleR);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue066; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPGrayscaleR(bmp_bckgd_ptr,
               rct_dst.pt_rct,
               bmp_bckgd_width);
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilNTValue061; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  d_grayscale_r          : byte;
begin
  d_grayscale_r          :=255-col_trans_arr[6];
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleRDec((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,d_grayscale_r);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilNTValue063; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  d_grayscale_r          : byte;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  d_grayscale_r          :=255-col_trans_arr[6];
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleRDec((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,d_grayscale_r);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue065; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  d_grayscale_r          : byte;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  d_grayscale_r          :=255-col_trans_arr[6];
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleRDec((nt_pix_intr_sht_arr_ptr^+v)^,
                                                                  d_grayscale_r);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleRDec((nt_pix_intr_sht_arr_ptr^+v)^,
                                                                  d_grayscale_r);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleRDec((nt_pix_intr_sht_arr_ptr^+v)^,
                                                                  d_grayscale_r);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleRDec((nt_pix_intr_sht_arr_ptr^+v)^,
                                                                  d_grayscale_r);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImage.FilNTValue067; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPGrayscaleRDec(bmp_bckgd_ptr,
                  rct_dst.pt_rct,
                  bmp_bckgd_width,
                  col_trans_arr[6]);
end; {$endregion}

{GrayscaleG}
// (constant) not clippped:
procedure TFastImage.FilNTValue070; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc0_0(Default(TFunc0Args),@GrayscaleG);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue072; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc0_2(Default(TFunc0Args),@GrayscaleG);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue074; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc0_4(Default(TFunc0Args),@GrayscaleG);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue076; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPGrayscaleG(bmp_bckgd_ptr,
               rct_dst.pt_rct,
               bmp_bckgd_width);
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilNTValue071; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  d_grayscale_g          : byte;
begin
  d_grayscale_g          :=255-col_trans_arr[7];
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleGDec((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,d_grayscale_g);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilNTValue073; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  d_grayscale_g          : byte;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  d_grayscale_g          :=255-col_trans_arr[7];
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleGDec((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,d_grayscale_g);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue075; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  d_grayscale_g          : byte;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  d_grayscale_g          :=255-col_trans_arr[7];
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleGDec((nt_pix_intr_sht_arr_ptr^+v)^,
                                                                  d_grayscale_g);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleGDec((nt_pix_intr_sht_arr_ptr^+v)^,
                                                                  d_grayscale_g);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleGDec((nt_pix_intr_sht_arr_ptr^+v)^,
                                                                  d_grayscale_g);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleGDec((nt_pix_intr_sht_arr_ptr^+v)^,
                                                                  d_grayscale_g);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImage.FilNTValue077; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPGrayscaleGDec(bmp_bckgd_ptr,
                  rct_dst.pt_rct,
                  bmp_bckgd_width,
                  col_trans_arr[7]);
end; {$endregion}

{GrayscaleB}
// (constant) not clippped:
procedure TFastImage.FilNTValue080; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc0_0(Default(TFunc0Args),@GrayscaleB);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue082; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc0_2(Default(TFunc0Args),@GrayscaleB);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue084; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc0_4(Default(TFunc0Args),@GrayscaleB);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue086; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPGrayscaleB(bmp_bckgd_ptr,
               rct_dst.pt_rct,
               bmp_bckgd_width);
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilNTValue081; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  d_grayscale_b          : byte;
begin
  d_grayscale_b          :=255-col_trans_arr[8];
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleBDec((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,d_grayscale_b);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilNTValue083; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  d_grayscale_b          : byte;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  d_grayscale_b          :=255-col_trans_arr[8];
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleBDec((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,d_grayscale_b);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue085; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  d_grayscale_b          : byte;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  d_grayscale_b          :=255-col_trans_arr[8];
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleBDec((nt_pix_intr_sht_arr_ptr^+v)^,
                                                                  d_grayscale_b);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleBDec((nt_pix_intr_sht_arr_ptr^+v)^,
                                                                  d_grayscale_b);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleBDec((nt_pix_intr_sht_arr_ptr^+v)^,
                                                                  d_grayscale_b);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleBDec((nt_pix_intr_sht_arr_ptr^+v)^,
                                                                  d_grayscale_b);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImage.FilNTValue087; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPGrayscaleBDec(bmp_bckgd_ptr,
                  rct_dst.pt_rct,
                  bmp_bckgd_width,
                  col_trans_arr[8]);
end; {$endregion}

{Monochrome Noise}
// (constant) not clippped:
procedure TFastImage.FilNTValue090; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
          if Odd((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=col_trans_var.monochrome_val;
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue092; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
          if Odd((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=col_trans_var.monochrome_val;
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue094; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                  if Odd((nt_pix_intr_sht_arr_ptr^+v)^) then
                         (nt_pix_intr_sht_arr_ptr^+v)^:=col_trans_var.monochrome_val;
                  Inc    (nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                  if Odd((nt_pix_intr_sht_arr_ptr^+v)^) then
                         (nt_pix_intr_sht_arr_ptr^+v)^:=col_trans_var.monochrome_val;
                  Inc    (nt_pix_intr_sht_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                  if Odd((nt_pix_intr_sht_arr_ptr^+v)^) then
                         (nt_pix_intr_sht_arr_ptr^+v)^:=col_trans_var.monochrome_val;
                  Inc    (nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  if Odd((nt_pix_intr_sht_arr_ptr^+v)^) then
                         (nt_pix_intr_sht_arr_ptr^+v)^:=col_trans_var.monochrome_val;
                  Inc    (nt_pix_intr_sht_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue096; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPMonoNoise(bmp_bckgd_ptr,
              rct_dst.pt_rct,
              bmp_bckgd_width,
              col_trans_var.monochrome_val);
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilNTValue091; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  d_mononoise            : byte;
begin
  d_mononoise            :=255-col_trans_arr[9];
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
          if Odd((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
            with col_trans_var do
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlend((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,r_val,g_val,b_val,d_mononoise,col_trans_arr[9]);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilNTValue093; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  d_mononoise            : byte;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  d_mononoise            :=255-col_trans_arr[9];
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
          if Odd((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
            with col_trans_var do
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlend((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,r_val,g_val,b_val,d_mononoise,col_trans_arr[9]);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue095; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  d_mononoise            : byte;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  d_mononoise            :=255-col_trans_arr[9];
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                  with col_trans_var do
                    if Odd((nt_pix_intr_sht_arr_ptr^+v)^) then
                           (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend((nt_pix_intr_sht_arr_ptr^+v)^,
                                                                     r_val,
                                                                     g_val,
                                                                     b_val,
                                                                     d_mononoise,
                                                                     col_trans_arr[9]);
                  Inc      (nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                  with col_trans_var do
                    if Odd((nt_pix_intr_sht_arr_ptr^+v)^) then
                           (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend((nt_pix_intr_sht_arr_ptr^+v)^,
                                                                     r_val,
                                                                     g_val,
                                                                     b_val,
                                                                     d_mononoise,
                                                                     col_trans_arr[9]);
                  Inc      (nt_pix_intr_sht_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                  with col_trans_var do
                    if Odd((nt_pix_intr_sht_arr_ptr^+v)^) then
                           (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend((nt_pix_intr_sht_arr_ptr^+v)^,
                                                                     r_val,
                                                                     g_val,
                                                                     b_val,
                                                                     d_mononoise,
                                                                     col_trans_arr[9]);
                  Inc      (nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  with col_trans_var do
                    if Odd((nt_pix_intr_sht_arr_ptr^+v)^) then
                           (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend((nt_pix_intr_sht_arr_ptr^+v)^,
                                                                     r_val,
                                                                     g_val,
                                                                     b_val,
                                                                     d_mononoise,
                                                                     col_trans_arr[9]);
                  Inc      (nt_pix_intr_sht_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImage.FilNTValue097; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPMonoNoiseDec(bmp_bckgd_ptr,
                 rct_dst.pt_rct,
                 bmp_bckgd_width,
                 col_trans_var.monochrome_val,
                 col_trans_arr[9]);
end; {$endregion}

{Color of Curent Layer}
// (constant) not clippped:
procedure TFastImage.FilNTColor000; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  nt_pix_intr_ccl_arr_ptr:= nt_pix_intr_arr_ptr;
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=nt_pix_intr_ccl_arr_ptr^;
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_ccl_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTColor002; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  nt_pix_intr_ccl_arr_ptr:=@nt_pix_intr_arr_ptr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=nt_pix_intr_ccl_arr_ptr^;
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_ccl_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTColor004; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  nt_pix_intr_ccl_arr_ptr:=@nt_pix_intr_arr_ptr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              Inc(nt_pix_intr_ccl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=nt_pix_intr_ccl_arr_ptr^;
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              Inc(nt_pix_intr_ccl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=nt_pix_intr_ccl_arr_ptr^;
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=nt_pix_intr_ccl_arr_ptr^;
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=nt_pix_intr_ccl_arr_ptr^;
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTColor006; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  BitBlt1(bmp_color_ptr,
          bmp_bckgd_ptr,
          rct_src,
          rct_dst.pt_rct.left,
          rct_dst.pt_rct.top,
          bmp_ftimg_width_origin{bmp_ftimg_width},
          bmp_bckgd_width);
end; {$endregion}
// (fading):
// same;

{Color of Curent Layer(Additive)}
// (constant) not clippped:
procedure TFastImage.FilNTColor010; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  nt_pix_intr_ccl_arr_ptr:= nt_pix_intr_arr_ptr;
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=Additive(     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                 Blue (nt_pix_intr_ccl_arr_ptr^),
                                                                 Green(nt_pix_intr_ccl_arr_ptr^),
                                                                 Red  (nt_pix_intr_ccl_arr_ptr^));
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_ccl_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTColor012; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  nt_pix_intr_ccl_arr_ptr:=@nt_pix_intr_arr_ptr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=Additive(     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                 Blue (nt_pix_intr_ccl_arr_ptr^),
                                                                 Green(nt_pix_intr_ccl_arr_ptr^),
                                                                 Red  (nt_pix_intr_ccl_arr_ptr^));
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_ccl_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTColor014; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  nt_pix_intr_ccl_arr_ptr:=@nt_pix_intr_arr_ptr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              Inc(nt_pix_intr_ccl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=Additive(     (nt_pix_intr_sht_arr_ptr^+v)^,
                                                             Blue (nt_pix_intr_ccl_arr_ptr^),
                                                             Green(nt_pix_intr_ccl_arr_ptr^),
                                                             Red  (nt_pix_intr_ccl_arr_ptr^));
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              Inc(nt_pix_intr_ccl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=Additive(     (nt_pix_intr_sht_arr_ptr^+v)^,
                                                             Blue (nt_pix_intr_ccl_arr_ptr^),
                                                             Green(nt_pix_intr_ccl_arr_ptr^),
                                                             Red  (nt_pix_intr_ccl_arr_ptr^));
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=Additive(     (nt_pix_intr_sht_arr_ptr^+v)^,
                                                             Blue (nt_pix_intr_ccl_arr_ptr^),
                                                             Green(nt_pix_intr_ccl_arr_ptr^),
                                                             Red  (nt_pix_intr_ccl_arr_ptr^));
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=Additive(     (nt_pix_intr_sht_arr_ptr^+v)^,
                                                             Blue (nt_pix_intr_ccl_arr_ptr^),
                                                             Green(nt_pix_intr_ccl_arr_ptr^),
                                                             Red  (nt_pix_intr_ccl_arr_ptr^));
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTColor016; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPAdditive(bmp_color_ptr,
             bmp_bckgd_ptr,
             rct_src,
             rct_dst,
             bmp_ftimg_width_origin{bmp_ftimg_width},
             bmp_bckgd_width);
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilNTColor011; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  nt_pix_intr_ccl_arr_ptr:= nt_pix_intr_arr_ptr;
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDec(     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                    Blue (nt_pix_intr_ccl_arr_ptr^),
                                                                    Green(nt_pix_intr_ccl_arr_ptr^),
                                                                    Red  (nt_pix_intr_ccl_arr_ptr^),
                                                                    col_trans_arr[1]);
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_ccl_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilNTColor013; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  nt_pix_intr_ccl_arr_ptr:=@nt_pix_intr_arr_ptr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDec(     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                    Blue (nt_pix_intr_ccl_arr_ptr^),
                                                                    Green(nt_pix_intr_ccl_arr_ptr^),
                                                                    Red  (nt_pix_intr_ccl_arr_ptr^),
                                                                    col_trans_arr[1]);
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_ccl_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilNTColor015; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  nt_pix_intr_ccl_arr_ptr:=@nt_pix_intr_arr_ptr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              Inc(nt_pix_intr_ccl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(     (nt_pix_intr_sht_arr_ptr^+v)^,
                                                                Blue (nt_pix_intr_ccl_arr_ptr^),
                                                                Green(nt_pix_intr_ccl_arr_ptr^),
                                                                Red  (nt_pix_intr_ccl_arr_ptr^),
                                                                col_trans_arr[1]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              Inc(nt_pix_intr_ccl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(     (nt_pix_intr_sht_arr_ptr^+v)^,
                                                                Blue (nt_pix_intr_ccl_arr_ptr^),
                                                                Green(nt_pix_intr_ccl_arr_ptr^),
                                                                Red  (nt_pix_intr_ccl_arr_ptr^),
                                                                col_trans_arr[1]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(     (nt_pix_intr_sht_arr_ptr^+v)^,
                                                                Blue (nt_pix_intr_ccl_arr_ptr^),
                                                                Green(nt_pix_intr_ccl_arr_ptr^),
                                                                Red  (nt_pix_intr_ccl_arr_ptr^),
                                                                col_trans_arr[1]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(     (nt_pix_intr_sht_arr_ptr^+v)^,
                                                                Blue (nt_pix_intr_ccl_arr_ptr^),
                                                                Green(nt_pix_intr_ccl_arr_ptr^),
                                                                Red  (nt_pix_intr_ccl_arr_ptr^),
                                                                col_trans_arr[1]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImage.FilNTColor017; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPAdditiveDec(bmp_color_ptr,
                bmp_bckgd_ptr,
                rct_src,
                rct_dst,
                bmp_ftimg_width_origin{bmp_ftimg_width},
                bmp_bckgd_width,
                col_trans_arr[1]);
end; {$endregion}

{Color of Curent Layer(Alphablend)}
// (constant) not clippped:
procedure TFastImage.FilNTColor020; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
  d_alpha                : byte;
begin
  d_alpha                :=255-col_trans_arr[2];
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  nt_pix_intr_ccl_arr_ptr:= nt_pix_intr_arr_ptr;
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlend(     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                   Blue (nt_pix_intr_ccl_arr_ptr^),
                                                                   Green(nt_pix_intr_ccl_arr_ptr^),
                                                                   Red  (nt_pix_intr_ccl_arr_ptr^),
                                                                   d_alpha,
                                                                   col_trans_arr[2]);
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_ccl_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTColor022; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
  d_alpha                : byte;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  d_alpha                :=255-col_trans_arr[2];
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  nt_pix_intr_ccl_arr_ptr:=@nt_pix_intr_arr_ptr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlend(     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                   Blue (nt_pix_intr_ccl_arr_ptr^),
                                                                   Green(nt_pix_intr_ccl_arr_ptr^),
                                                                   Red  (nt_pix_intr_ccl_arr_ptr^),
                                                                   d_alpha,
                                                                   col_trans_arr[2]);
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_ccl_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTColor024; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  d_alpha                : byte;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  d_alpha                :=255-col_trans_arr[2];
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  nt_pix_intr_ccl_arr_ptr:=@nt_pix_intr_arr_ptr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              Inc(nt_pix_intr_ccl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(     (nt_pix_intr_sht_arr_ptr^+v)^,
                                                               Blue (nt_pix_intr_ccl_arr_ptr^),
                                                               Green(nt_pix_intr_ccl_arr_ptr^),
                                                               Red  (nt_pix_intr_ccl_arr_ptr^),
                                                               d_alpha,
                                                               col_trans_arr[2]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              Inc(nt_pix_intr_ccl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(     (nt_pix_intr_sht_arr_ptr^+v)^,
                                                               Blue (nt_pix_intr_ccl_arr_ptr^),
                                                               Green(nt_pix_intr_ccl_arr_ptr^),
                                                               Red  (nt_pix_intr_ccl_arr_ptr^),
                                                               d_alpha,
                                                               col_trans_arr[2]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(     (nt_pix_intr_sht_arr_ptr^+v)^,
                                                               Blue (nt_pix_intr_ccl_arr_ptr^),
                                                               Green(nt_pix_intr_ccl_arr_ptr^),
                                                               Red  (nt_pix_intr_ccl_arr_ptr^),
                                                               d_alpha,
                                                               col_trans_arr[2]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(     (nt_pix_intr_sht_arr_ptr^+v)^,
                                                               Blue (nt_pix_intr_ccl_arr_ptr^),
                                                               Green(nt_pix_intr_ccl_arr_ptr^),
                                                               Red  (nt_pix_intr_ccl_arr_ptr^),
                                                               d_alpha,
                                                               col_trans_arr[2]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTColor026; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPAlphaBlend(bmp_color_ptr,
               bmp_bckgd_ptr,
               rct_src,
               rct_dst,
               bmp_ftimg_width_origin{bmp_ftimg_width},
               bmp_bckgd_width,
               col_trans_arr[2]);
end; {$endregion}
// (fading):
// same;

// PT - partly transparent pixels:

{Empty}
procedure TFastImage.FilPTValue009; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
{Empty}
procedure TFastImage.FilPTColor009; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Monochrome}
// (constant) not clippped:
procedure TFastImage.FilPTValue000; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlend((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                   r_val,
                                                                   g_val,
                                                                   b_val,
                                                                       pt_pix_byte_acl_arr_ptr^,
                                                                   255-pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue002; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlend((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                   r_val,
                                                                   g_val,
                                                                   b_val,
                                                                       pt_pix_byte_acl_arr_ptr^,
                                                                   255-pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue004; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                  with col_trans_var do
                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend((pt_pix_intr_sht_arr_ptr^+v)^,
                                                              r_val,
                                                              g_val,
                                                              b_val,
                                                                  pt_pix_byte_acl_arr_ptr^,
                                                              255-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                  with col_trans_var do
                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend((pt_pix_intr_sht_arr_ptr^+v)^,
                                                              r_val,
                                                              g_val,
                                                              b_val,
                                                                  pt_pix_byte_acl_arr_ptr^,
                                                              255-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                  with col_trans_var do
                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend((pt_pix_intr_sht_arr_ptr^+v)^,
                                                              r_val,
                                                              g_val,
                                                              b_val,
                                                                  pt_pix_byte_acl_arr_ptr^,
                                                              255-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend((pt_pix_intr_sht_arr_ptr^+v)^,
                                                               r_val,
                                                               g_val,
                                                               b_val,
                                                                   pt_pix_byte_acl_arr_ptr^,
                                                               255-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading):
// same;

{Additive}
// (constant) not clippped:
procedure TFastImage.FilPTValue010; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                    r_val,
                                                                    g_val,
                                                                    b_val,
                                                                    255-pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue012; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                    r_val,
                                                                    g_val,
                                                                    b_val,
                                                                    255-pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue014; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                  with col_trans_var do
                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                                               r_val,
                                                               g_val,
                                                               b_val,
                                                               255-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                  with col_trans_var do
                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                                               r_val,
                                                               g_val,
                                                               b_val,
                                                               255-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                  with col_trans_var do
                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                                               r_val,
                                                               g_val,
                                                               b_val,
                                                               255-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                                                r_val,
                                                                g_val,
                                                                b_val,
                                                                255-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilPTValue011; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                    r_val,
                                                                    g_val,
                                                                    b_val,
                                                                    255-Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[1],0));
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilPTValue013; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                    r_val,
                                                                    g_val,
                                                                    b_val,
                                                                    255-Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[1],0));
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue015; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                  with col_trans_var do
                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                                               r_val,
                                                               g_val,
                                                               b_val,
                                                               255-Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[1],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                  with col_trans_var do
                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                                               r_val,
                                                               g_val,
                                                               b_val,
                                                               255-Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[1],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                  with col_trans_var do
                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                                               r_val,
                                                               g_val,
                                                               b_val,
                                                               255-Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[1],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                                                r_val,
                                                                g_val,
                                                                b_val,
                                                                255-Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[1],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}

{Alphablend}
// (constant) not clippped:
procedure TFastImage.FilPTValue020; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendDec(   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                      r_val,
                                                                      g_val,
                                                                      b_val,
                                                                          pt_pix_byte_acl_arr_ptr^,
                                                                      255-pt_pix_byte_acl_arr_ptr^,
                                                                      col_trans_arr[2]);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue022; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendDec(   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                      r_val,
                                                                      g_val,
                                                                      b_val,
                                                                          pt_pix_byte_acl_arr_ptr^,
                                                                      255-pt_pix_byte_acl_arr_ptr^,
                                                                      col_trans_arr[2]);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue024; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                  with col_trans_var do
                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                 r_val,
                                                                 g_val,
                                                                 b_val,
                                                                     pt_pix_byte_acl_arr_ptr^,
                                                                 255-pt_pix_byte_acl_arr_ptr^,
                                                                 col_trans_arr[2]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                  with col_trans_var do
                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                 r_val,
                                                                 g_val,
                                                                 b_val,
                                                                     pt_pix_byte_acl_arr_ptr^,
                                                                 255-pt_pix_byte_acl_arr_ptr^,
                                                                 col_trans_arr[2]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                  with col_trans_var do
                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                 r_val,
                                                                 g_val,
                                                                 b_val,
                                                                     pt_pix_byte_acl_arr_ptr^,
                                                                 255-pt_pix_byte_acl_arr_ptr^,
                                                                 col_trans_arr[2]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                  r_val,
                                                                  g_val,
                                                                  b_val,
                                                                      pt_pix_byte_acl_arr_ptr^,
                                                                  255-pt_pix_byte_acl_arr_ptr^,
                                                                  col_trans_arr[2]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading):
// same;

{Inverse}
// (constant) not clippped:
procedure TFastImage.FilPTValue030; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=InverseDec(   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                   255-pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue032; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=InverseDec(   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                   255-pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue034; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                  with col_trans_var do
                    (pt_pix_intr_sht_arr_ptr^+v)^:=InverseDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                              255-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                  with col_trans_var do
                    (pt_pix_intr_sht_arr_ptr^+v)^:=InverseDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                              255-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                  with col_trans_var do
                    (pt_pix_intr_sht_arr_ptr^+v)^:=InverseDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                              255-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=InverseDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                               255-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilPTValue031; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=InverseDec(       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                   255-Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[3],0));
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilPTValue033; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=InverseDec(       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                   255-Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[3],0));
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue035; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=InverseDec(       (pt_pix_intr_sht_arr_ptr^+v)^,
                                                               255-Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[3],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=InverseDec(       (pt_pix_intr_sht_arr_ptr^+v)^,
                                                               255-Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[3],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=InverseDec(       (pt_pix_intr_sht_arr_ptr^+v)^,
                                                               255-Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[3],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=InverseDec(       (pt_pix_intr_sht_arr_ptr^+v)^,
                                                               255-Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[3],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}

{Highlight}
// (constant) not clippped:
procedure TFastImage.FilPTValue040; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=HighlightDec(   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                     255-pt_pix_byte_acl_arr_ptr^,
                                                                     col_trans_arr[4]);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue042; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=HighlightDec(   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                     255-pt_pix_byte_acl_arr_ptr^,
                                                                     col_trans_arr[4]);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue044; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=HighlightDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                 255-pt_pix_byte_acl_arr_ptr^,
                                                                 col_trans_arr[4]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=HighlightDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                 255-pt_pix_byte_acl_arr_ptr^,
                                                                 col_trans_arr[4]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=HighlightDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                 255-pt_pix_byte_acl_arr_ptr^,
                                                                 col_trans_arr[4]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=HighlightDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                 255-pt_pix_byte_acl_arr_ptr^,
                                                                 col_trans_arr[4]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading):
// same;

{Darken}
// (constant) not clippped:
procedure TFastImage.FilPTValue050; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=DarkenDec(   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                  255-pt_pix_byte_acl_arr_ptr^,
                                                                  col_trans_arr[5]);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue052; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=DarkenDec(   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                  255-pt_pix_byte_acl_arr_ptr^,
                                                                  col_trans_arr[5]);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue054; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=DarkenDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                              255-pt_pix_byte_acl_arr_ptr^,
                                                              col_trans_arr[5]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=DarkenDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                              255-pt_pix_byte_acl_arr_ptr^,
                                                              col_trans_arr[5]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=DarkenDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                              255-pt_pix_byte_acl_arr_ptr^,
                                                              col_trans_arr[5]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=DarkenDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                              255-pt_pix_byte_acl_arr_ptr^,
                                                              col_trans_arr[5]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading):
// same;

{GrayscaleR}
// (constant) not clippped:
procedure TFastImage.FilPTValue060; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleRDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                       pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue062; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleRDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                       pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue064; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleRDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                                                   pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleRDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                                                   pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleRDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                                                   pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleRDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                                                   pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilPTValue061; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleRDec(   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                      Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[6],0));
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilPTValue063; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleRDec(   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                      Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[6],0));
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue065; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleRDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                  Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[6],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleRDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                  Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[6],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleRDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                  Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[6],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleRDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                  Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[6],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}

{GrayscaleG}
// (constant) not clippped:
procedure TFastImage.FilPTValue070; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleGDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                       pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue072; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleGDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                       pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue074; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleGDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                                                   pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleGDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                                                   pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleGDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                                                   pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleGDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                                                   pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilPTValue071; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleGDec(   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                      Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[7],0));
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilPTValue073; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleGDec(   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                      Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[7],0));
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue075; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleGDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                  Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[7],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleGDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                  Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[7],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleGDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                  Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[7],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleGDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                  Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[7],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}

{GrayscaleB}
// (constant) not clippped:
procedure TFastImage.FilPTValue080; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleBDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                       pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue082; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleBDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                       pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue084; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleBDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                                                   pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleBDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                                                   pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleBDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                                                   pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleBDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                                                   pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilPTValue081; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleBDec(   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                      Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[8],0));
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilPTValue083; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleBDec(   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                      Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[8],0));
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue085; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleBDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                  Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[8],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleBDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                  Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[8],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleBDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                  Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[8],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleBDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                  Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[8],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}

{Monochrome Noise}
// (constant) not clippped:
procedure TFastImage.FilPTValue090; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
            if Odd((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
                   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlend(   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                         r_val,
                                                                         g_val,
                                                                         b_val,
                                                                             pt_pix_byte_acl_arr_ptr^,
                                                                         255-pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue092; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
            if Odd((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
                   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlend(   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                         r_val,
                                                                         g_val,
                                                                         b_val,
                                                                             pt_pix_byte_acl_arr_ptr^,
                                                                         255-pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue094; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                  with col_trans_var do
                    if Odd((pt_pix_intr_sht_arr_ptr^+v)^) then
                           (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                     r_val,
                                                                     g_val,
                                                                     b_val,
                                                                         pt_pix_byte_acl_arr_ptr^,
                                                                     255-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                  with col_trans_var do
                    if Odd((pt_pix_intr_sht_arr_ptr^+v)^) then
                           (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                     r_val,
                                                                     g_val,
                                                                     b_val,
                                                                         pt_pix_byte_acl_arr_ptr^,
                                                                     255-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                  with col_trans_var do
                    if Odd((pt_pix_intr_sht_arr_ptr^+v)^) then
                           (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                     r_val,
                                                                     g_val,
                                                                     b_val,
                                                                         pt_pix_byte_acl_arr_ptr^,
                                                                     255-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  with col_trans_var do
                    if Odd((pt_pix_intr_sht_arr_ptr^+v)^) then
                           (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                     r_val,
                                                                     g_val,
                                                                     b_val,
                                                                         pt_pix_byte_acl_arr_ptr^,
                                                                     255-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilPTValue091; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
            if Odd((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
                   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendDec(   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                            r_val,
                                                                            g_val,
                                                                            b_val,
                                                                                pt_pix_byte_acl_arr_ptr^,
                                                                            255-pt_pix_byte_acl_arr_ptr^,
                                                                            col_trans_arr[9]);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilPTValue093; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
            if Odd((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
                   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendDec(   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                            r_val,
                                                                            g_val,
                                                                            b_val,
                                                                                pt_pix_byte_acl_arr_ptr^,
                                                                            255-pt_pix_byte_acl_arr_ptr^,
                                                                            col_trans_arr[9]);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue095; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  pt_pix_byte_acl_arr_ptr:=@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                  with col_trans_var do
                    if Odd((pt_pix_intr_sht_arr_ptr^+v)^) then
                           (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                        r_val,
                                                                        g_val,
                                                                        b_val,
                                                                            pt_pix_byte_acl_arr_ptr^,
                                                                        255-pt_pix_byte_acl_arr_ptr^,
                                                                        col_trans_arr[9]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                  with col_trans_var do
                    if Odd((pt_pix_intr_sht_arr_ptr^+v)^) then
                           (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                        r_val,
                                                                        g_val,
                                                                        b_val,
                                                                            pt_pix_byte_acl_arr_ptr^,
                                                                        255-pt_pix_byte_acl_arr_ptr^,
                                                                        col_trans_arr[9]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                  with col_trans_var do
                    if Odd((pt_pix_intr_sht_arr_ptr^+v)^) then
                           (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                        r_val,
                                                                        g_val,
                                                                        b_val,
                                                                            pt_pix_byte_acl_arr_ptr^,
                                                                        255-pt_pix_byte_acl_arr_ptr^,
                                                                        col_trans_arr[9]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  with col_trans_var do
                    if Odd((pt_pix_intr_sht_arr_ptr^+v)^) then
                           (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDec(   (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                        r_val,
                                                                        g_val,
                                                                        b_val,
                                                                            pt_pix_byte_acl_arr_ptr^,
                                                                        255-pt_pix_byte_acl_arr_ptr^,
                                                                        col_trans_arr[9]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}

{Color of Curent Layer}
// (constant) not clippped:
procedure TFastImage.FilPTColor000; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_intr_ccl_arr_ptr:= pt_pix_intr_arr_ptr;
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlend(     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                   Blue (pt_pix_intr_ccl_arr_ptr^   ),
                                                                   Green(pt_pix_intr_ccl_arr_ptr^   ),
                                                                   Red  (pt_pix_intr_ccl_arr_ptr^   ),
                                                                         pt_pix_intr_ccl_arr_ptr^>>24,
                                                                     255-pt_pix_intr_ccl_arr_ptr^>>24);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_ccl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTColor002; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  pt_pix_intr_ccl_arr_ptr:=@pt_pix_intr_arr_ptr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlend(     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                   Blue (pt_pix_intr_ccl_arr_ptr^   ),
                                                                   Green(pt_pix_intr_ccl_arr_ptr^   ),
                                                                   Red  (pt_pix_intr_ccl_arr_ptr^   ),
                                                                         pt_pix_intr_ccl_arr_ptr^>>24,
                                                                     255-pt_pix_intr_ccl_arr_ptr^>>24);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_ccl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTColor004; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.left>bmp_ftimg_width -1) then
    Exit;
  if (rct_src.top >bmp_ftimg_height-1) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  pt_pix_intr_ccl_arr_ptr:=@pt_pix_intr_arr_ptr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_intr_ccl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                               Blue (pt_pix_intr_ccl_arr_ptr^   ),
                                                               Green(pt_pix_intr_ccl_arr_ptr^   ),
                                                               Red  (pt_pix_intr_ccl_arr_ptr^   ),
                                                                     pt_pix_intr_ccl_arr_ptr^>>24,
                                                                 255-pt_pix_intr_ccl_arr_ptr^>>24);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc(pt_pix_intr_ccl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_intr_ccl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_intr_ccl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                               Blue (pt_pix_intr_ccl_arr_ptr^),
                                                               Green(pt_pix_intr_ccl_arr_ptr^),
                                                               Red  (pt_pix_intr_ccl_arr_ptr^),
                                                                     pt_pix_intr_ccl_arr_ptr^>>24,
                                                                 255-pt_pix_intr_ccl_arr_ptr^>>24);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_intr_ccl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                               Blue (pt_pix_intr_ccl_arr_ptr^),
                                                               Green(pt_pix_intr_ccl_arr_ptr^),
                                                               Red  (pt_pix_intr_ccl_arr_ptr^),
                                                                     pt_pix_intr_ccl_arr_ptr^>>24,
                                                                 255-pt_pix_intr_ccl_arr_ptr^>>24);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc(pt_pix_intr_ccl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                               Blue (pt_pix_intr_ccl_arr_ptr^),
                                                               Green(pt_pix_intr_ccl_arr_ptr^),
                                                               Red  (pt_pix_intr_ccl_arr_ptr^),
                                                                     pt_pix_intr_ccl_arr_ptr^>>24,
                                                                 255-pt_pix_intr_ccl_arr_ptr^>>24);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) image has transparent alpha channel:
procedure TFastImage.FilPTColor006; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPAlphaBlend(bmp_color_ptr,
               bmp_bckgd_ptr,
               rct_src,
               rct_dst,
               bmp_ftimg_width_origin{bmp_ftimg_width},
               bmp_bckgd_width,
               col_trans_arr[2]);
end; {$endregion}
// (fading):
// same;

{Color of Curent Layer(Additive)}
// (constant) not clippped:
procedure TFastImage.FilPTColor010; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_intr_ccl_arr_ptr:= pt_pix_intr_arr_ptr;
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDec(     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                    Blue (pt_pix_intr_ccl_arr_ptr^),
                                                                    Green(pt_pix_intr_ccl_arr_ptr^),
                                                                    Red  (pt_pix_intr_ccl_arr_ptr^),
                                                                      255-pt_pix_intr_ccl_arr_ptr^>>24);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_ccl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTColor012; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  pt_pix_intr_ccl_arr_ptr:=@pt_pix_intr_arr_ptr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDec(     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                    Blue (pt_pix_intr_ccl_arr_ptr^),
                                                                    Green(pt_pix_intr_ccl_arr_ptr^),
                                                                    Red  (pt_pix_intr_ccl_arr_ptr^),
                                                                      255-pt_pix_intr_ccl_arr_ptr^>>24);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_ccl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTColor014; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  pt_pix_intr_ccl_arr_ptr:=@pt_pix_intr_arr_ptr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_intr_ccl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                Blue (pt_pix_intr_ccl_arr_ptr^),
                                                                Green(pt_pix_intr_ccl_arr_ptr^),
                                                                Red  (pt_pix_intr_ccl_arr_ptr^),
                                                                  255-pt_pix_intr_ccl_arr_ptr^>>24);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc(pt_pix_intr_ccl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_intr_ccl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_intr_ccl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                Blue (pt_pix_intr_ccl_arr_ptr^),
                                                                Green(pt_pix_intr_ccl_arr_ptr^),
                                                                Red  (pt_pix_intr_ccl_arr_ptr^),
                                                                  255-pt_pix_intr_ccl_arr_ptr^>>24);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_intr_ccl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                Blue (pt_pix_intr_ccl_arr_ptr^),
                                                                Green(pt_pix_intr_ccl_arr_ptr^),
                                                                Red  (pt_pix_intr_ccl_arr_ptr^),
                                                                  255-pt_pix_intr_ccl_arr_ptr^>>24);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc(pt_pix_intr_ccl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                Blue (pt_pix_intr_ccl_arr_ptr^),
                                                                Green(pt_pix_intr_ccl_arr_ptr^),
                                                                Red  (pt_pix_intr_ccl_arr_ptr^),
                                                                  255-pt_pix_intr_ccl_arr_ptr^>>24);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilPTColor016; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPAdditiveDec(bmp_color_ptr,
                bmp_bckgd_ptr,
                rct_src,
                rct_dst,
                bmp_ftimg_width_origin{bmp_ftimg_width},
                bmp_bckgd_width,
                col_trans_arr[1]);
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilPTColor011; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_intr_ccl_arr_ptr:= pt_pix_intr_arr_ptr;
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDec(       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                    Blue   (pt_pix_intr_ccl_arr_ptr^),
                                                                    Green  (pt_pix_intr_ccl_arr_ptr^),
                                                                    Red    (pt_pix_intr_ccl_arr_ptr^),
                                                                    255-Max(pt_pix_intr_ccl_arr_ptr^>>
                                                                    024-col_trans_arr[1],0));
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_ccl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilPTColor013; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  pt_pix_intr_ccl_arr_ptr:=@pt_pix_intr_arr_ptr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDec(       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                    Blue   (pt_pix_intr_ccl_arr_ptr^),
                                                                    Green  (pt_pix_intr_ccl_arr_ptr^),
                                                                    Red    (pt_pix_intr_ccl_arr_ptr^),
                                                                    255-Max(pt_pix_intr_ccl_arr_ptr^>>
                                                                    024-col_trans_arr[1],0));
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_ccl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilPTColor015; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  pt_pix_intr_ccl_arr_ptr:=@pt_pix_intr_arr_ptr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_intr_ccl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(       (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                Blue   (pt_pix_intr_ccl_arr_ptr^),
                                                                Green  (pt_pix_intr_ccl_arr_ptr^),
                                                                Red    (pt_pix_intr_ccl_arr_ptr^),
                                                                255-Max(pt_pix_intr_ccl_arr_ptr^>>
                                                                024-col_trans_arr[1],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc(pt_pix_intr_ccl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_intr_ccl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_intr_ccl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(       (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                Blue   (pt_pix_intr_ccl_arr_ptr^),
                                                                Green  (pt_pix_intr_ccl_arr_ptr^),
                                                                Red    (pt_pix_intr_ccl_arr_ptr^),
                                                                255-Max(pt_pix_intr_ccl_arr_ptr^>>
                                                                024-col_trans_arr[1],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_intr_ccl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(       (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                Blue   (pt_pix_intr_ccl_arr_ptr^),
                                                                Green  (pt_pix_intr_ccl_arr_ptr^),
                                                                Red    (pt_pix_intr_ccl_arr_ptr^),
                                                                255-Max(pt_pix_intr_ccl_arr_ptr^>>
                                                                024-col_trans_arr[1],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc(pt_pix_intr_ccl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(       (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                Blue   (pt_pix_intr_ccl_arr_ptr^),
                                                                Green  (pt_pix_intr_ccl_arr_ptr^),
                                                                Red    (pt_pix_intr_ccl_arr_ptr^),
                                                                255-Max(pt_pix_intr_ccl_arr_ptr^>>
                                                                024-col_trans_arr[1],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading) image has monochrome color channel
// same as (constant)

{Color of Curent Layer(Alphablend)}
// (constant) not clippped:
procedure TFastImage.FilPTColor020; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000];
  pt_pix_intr_ccl_arr_ptr:= pt_pix_intr_arr_ptr;
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendDec(     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                      Blue (pt_pix_intr_ccl_arr_ptr^),
                                                                      Green(pt_pix_intr_ccl_arr_ptr^),
                                                                      Red  (pt_pix_intr_ccl_arr_ptr^),
                                                                            pt_pix_intr_ccl_arr_ptr^>>24,
                                                                        255-pt_pix_intr_ccl_arr_ptr^>>24,
                                                                      col_trans_arr[2]);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_ccl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTColor022; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  pt_pix_intr_ccl_arr_ptr:=@pt_pix_intr_arr_ptr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendDec(     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                                      Blue (pt_pix_intr_ccl_arr_ptr^),
                                                                      Green(pt_pix_intr_ccl_arr_ptr^),
                                                                      Red  (pt_pix_intr_ccl_arr_ptr^),
                                                                            pt_pix_intr_ccl_arr_ptr^>>24,
                                                                        255-pt_pix_intr_ccl_arr_ptr^>>24,
                                                                      col_trans_arr[2]);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_ccl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTColor024; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=@bmp_bckgd_ptr      [rct_dst.pt_rct.top*bmp_bckgd_width+rct_dst.pt_rct.left];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000];
  pt_pix_intr_sht_arr_ptr:=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  pt_pix_intr_ccl_arr_ptr:=@pt_pix_intr_arr_ptr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000];
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_intr_ccl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to (c2+1)-(c1+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDec(     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                  Blue (pt_pix_intr_ccl_arr_ptr^),
                                                                  Green(pt_pix_intr_ccl_arr_ptr^),
                                                                  Red  (pt_pix_intr_ccl_arr_ptr^),
                                                                        pt_pix_intr_ccl_arr_ptr^>>24,
                                                                    255-pt_pix_intr_ccl_arr_ptr^>>24,
                                                                  col_trans_arr[2]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc(pt_pix_intr_ccl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_intr_ccl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_intr_ccl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDec(     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                  Blue (pt_pix_intr_ccl_arr_ptr^),
                                                                  Green(pt_pix_intr_ccl_arr_ptr^),
                                                                  Red  (pt_pix_intr_ccl_arr_ptr^),
                                                                        pt_pix_intr_ccl_arr_ptr^>>24,
                                                                    255-pt_pix_intr_ccl_arr_ptr^>>24,
                                                                  col_trans_arr[2]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_intr_ccl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDec(     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                  Blue (pt_pix_intr_ccl_arr_ptr^),
                                                                  Green(pt_pix_intr_ccl_arr_ptr^),
                                                                  Red  (pt_pix_intr_ccl_arr_ptr^),
                                                                        pt_pix_intr_ccl_arr_ptr^>>24,
                                                                    255-pt_pix_intr_ccl_arr_ptr^>>24,
                                                                  col_trans_arr[2]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc(pt_pix_intr_ccl_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDec(     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                                  Blue (pt_pix_intr_ccl_arr_ptr^),
                                                                  Green(pt_pix_intr_ccl_arr_ptr^),
                                                                  Red  (pt_pix_intr_ccl_arr_ptr^),
                                                                        pt_pix_intr_ccl_arr_ptr^>>24,
                                                                    255-pt_pix_intr_ccl_arr_ptr^>>24,
                                                                  col_trans_arr[2]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width);
    end;
end; {$endregion}
// (fading):
// same;

{Fill Array at Specified Rectangle with Specified Value}
procedure TFastImage.FilNTValueArr(var arr_src:T1IntrArr; constref bmp_ftimg_width_:integer; constref val:integer=0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_value_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_val_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (nt_pix_cnt=0) then
    Exit;
  first_row_pix_ptr      :=@arr_src            [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width_+bmp_src_rct_clp.left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000000];
  nt_pix_intr_val_arr_ptr:=@nt_pix_intr_val_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_value_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_value_ptr)^:=val;
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_val_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_ftimg_width_);
    end;
end; {$endregion}

{Restore Source Image from Compressed Image}
procedure TFastImage.ResNTValueArr(var arr_src:T1IntrArr; constref bmp_ftimg_width_:integer);                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_value_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_val_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (nt_pix_cnt=0) then
    Exit;
  first_row_pix_ptr      :=@arr_src            [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width_+bmp_src_rct_clp.left];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr:=@nt_pix_intr_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000000];
  nt_pix_intr_val_arr_ptr:=@nt_pix_intr_val_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_value_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_value_ptr)^:=nt_pix_intr_val_arr_ptr^;
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_val_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_ftimg_width_);
    end;
end; {$endregion}

// NT - not transparent pixels:
procedure TFastImage.SetNTNilToPtr; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TFastImage.SetNTCCLToPtr; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  nt_pix_intr_arr_ptr:=@nt_pix_intr_ccl_arr[0];
end; {$endregion}
procedure TFastImage.SetNTCLLToPtr; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  nt_pix_intr_arr_ptr:=@nt_pix_intr_cll_arr[0];
end; {$endregion}

// PT - partly transparent pixels:
procedure TFastImage.SetPTNilToPtr; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TFastImage.SetPTCCLToPtr; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pt_pix_intr_arr_ptr:=@pt_pix_intr_ccl_arr[0];
end; {$endregion}
procedure TFastImage.SetPTCLLToPtr; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pt_pix_intr_arr_ptr:=@pt_pix_intr_cll_arr[0];
end; {$endregion}

// Procedures Table Init.:
procedure TFastimage.FilProcInit; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  // NT - not transparent pixels;
  NTBeginProc[000]:=Unaligned(@SetNTNilToPtr);
  NTBeginProc[001]:=Unaligned(@SetNTCCLToPtr);
  NTBeginProc[002]:=Unaligned(@SetNTCLLToPtr);

  // PT - partly transparent pixels;
  PTBeginProc[000]:=Unaligned(@SetPTNilToPtr);
  PTBeginProc[001]:=Unaligned(@SetPTCCLToPtr);
  PTBeginProc[002]:=Unaligned(@SetPTCLLToPtr);

  // NT - not transparent pixels;

  {Empty}
  NTValueProc[009]:=Unaligned(@FilNTValue009);
  {Empty}
  NTColorProc[009]:=Unaligned(@FilNTColor009);

  {Monochrome}
  // (constant) not clippped
  NTValueProc[000]:=Unaligned(@FilNTValue000);
  // (constant) top-bottom clippped
  NTValueProc[002]:=Unaligned(@FilNTValue002);
  // (constant) left-right-top-bottom clippped
  NTValueProc[004]:=Unaligned(@FilNTValue004);
  // (constant) image has monochrome color channel
  NTValueProc[006]:=Unaligned(@FilNTValue006);
  // (fading) not clippped
  NTValueProc[001]:=Unaligned(@FilNTValue000);
  // (fading) top-bottom clippped
  NTValueProc[003]:=Unaligned(@FilNTValue002);
  // (fading) left-right-top-bottom clippped
  NTValueProc[005]:=Unaligned(@FilNTValue004);
  // (fading) image has monochrome color channel
  NTValueProc[007]:=Unaligned(@FilNTValue006);

  {Additive}
  // (constant) not clippped
  NTValueProc[010]:=Unaligned(@FilNTValue010);
  // (constant) top-bottom clippped
  NTValueProc[012]:=Unaligned(@FilNTValue012);
  // (constant) left-right-top-bottom clippped
  NTValueProc[014]:=Unaligned(@FilNTValue014);
  // (constant) image has monochrome color channel
  NTValueProc[016]:=Unaligned(@FilNTValue016);
  // (fading) not clippped
  NTValueProc[011]:=Unaligned(@FilNTValue011);
  // (fading) top-bottom clippped
  NTValueProc[013]:=Unaligned(@FilNTValue013);
  // (fading) left-right-top-bottom clippped
  NTValueProc[015]:=Unaligned(@FilNTValue015);
  // (fading) image has monochrome color channel
  NTValueProc[017]:=Unaligned(@FilNTValue017);

  {Alphablend}
  // (constant) not clippped
  NTValueProc[020]:=Unaligned(@FilNTValue020);
  // (constant) top-bottom clippped
  NTValueProc[022]:=Unaligned(@FilNTValue022);
  // (constant) left-right-top-bottom clippped
  NTValueProc[024]:=Unaligned(@FilNTValue024);
  // (constant) image has monochrome color channel
  NTValueProc[026]:=Unaligned(@FilNTValue026);
  // (fading) not clippped
  NTValueProc[021]:=Unaligned(@FilNTValue020);
  // (fading) top-bottom clippped
  NTValueProc[023]:=Unaligned(@FilNTValue022);
  // (fading) left-right-top-bottom clippped
  NTValueProc[025]:=Unaligned(@FilNTValue024);
  // (fading) image has monochrome color channel
  NTValueProc[027]:=Unaligned(@FilNTValue026);

  {Inverse}
  // (constant) not clippped
  NTValueProc[030]:=Unaligned(@FilNTValue030);
  // (constant) top-bottom clippped
  NTValueProc[032]:=Unaligned(@FilNTValue032);
  // (constant) left-right-top-bottom clippped
  NTValueProc[034]:=Unaligned(@FilNTValue034);
  // (constant) image has monochrome color channel
  NTValueProc[036]:=Unaligned(@FilNTValue036);
  // (fading) not clippped
  NTValueProc[031]:=Unaligned(@FilNTValue031);
  // (fading) top-bottom clippped
  NTValueProc[033]:=Unaligned(@FilNTValue033);
  // (fading) left-right-top-bottom clippped
  NTValueProc[035]:=Unaligned(@FilNTValue035);
  // (fading) image has monochrome color channel
  NTValueProc[037]:=Unaligned(@FilNTValue037);

  {Highlight}
  // (constant) not clippped
  NTValueProc[040]:=Unaligned(@FilNTValue040);
  // (constant) top-bottom clippped
  NTValueProc[042]:=Unaligned(@FilNTValue042);
  // (constant) left-right-top-bottom clippped
  NTValueProc[044]:=Unaligned(@FilNTValue044);
  // (constant) image has monochrome color channel
  NTValueProc[046]:=Unaligned(@FilNTValue046);
  // (fading) not clippped
  NTValueProc[041]:=Unaligned(@FilNTValue040);
  // (fading) top-bottom clippped
  NTValueProc[043]:=Unaligned(@FilNTValue042);
  // (fading) left-right-top-bottom clippped
  NTValueProc[045]:=Unaligned(@FilNTValue044);
  // (fading) image has monochrome color channel
  NTValueProc[047]:=Unaligned(@FilNTValue046);

  {Darken}
  // (constant) not clippped
  NTValueProc[050]:=Unaligned(@FilNTValue050);
  // (constant) top-bottom clippped
  NTValueProc[052]:=Unaligned(@FilNTValue052);
  // (constant) left-right-top-bottom clippped
  NTValueProc[054]:=Unaligned(@FilNTValue054);
  // (constant) image has monochrome color channel
  NTValueProc[056]:=Unaligned(@FilNTValue056);
  // (fading) not clippped
  NTValueProc[051]:=Unaligned(@FilNTValue050);
  // (fading) top-bottom clippped
  NTValueProc[053]:=Unaligned(@FilNTValue052);
  // (fading) left-right-top-bottom clippped
  NTValueProc[055]:=Unaligned(@FilNTValue054);
  // (fading) image has monochrome color channel
  NTValueProc[057]:=Unaligned(@FilNTValue056);

  {GrayscaleR}
  // (constant) not clippped
  NTValueProc[060]:=Unaligned(@FilNTValue060);
  // (constant) top-bottom clippped
  NTValueProc[062]:=Unaligned(@FilNTValue062);
  // (constant) left-right-top-bottom clippped
  NTValueProc[064]:=Unaligned(@FilNTValue064);
  // (constant) image has monochrome color channel
  NTValueProc[066]:=Unaligned(@FilNTValue066);
  // (fading) not clippped
  NTValueProc[061]:=Unaligned(@FilNTValue061);
  // (fading) top-bottom clippped
  NTValueProc[063]:=Unaligned(@FilNTValue063);
  // (fading) left-right-top-bottom clippped
  NTValueProc[065]:=Unaligned(@FilNTValue065);
  // (fading) image has monochrome color channel
  NTValueProc[067]:=Unaligned(@FilNTValue067);

  {GrayscaleG}
  // (constant) not clippped
  NTValueProc[070]:=Unaligned(@FilNTValue070);
  // (constant) top-bottom clippped
  NTValueProc[072]:=Unaligned(@FilNTValue072);
  // (constant) left-right-top-bottom clippped
  NTValueProc[074]:=Unaligned(@FilNTValue074);
  // (constant) image has monochrome color channel
  NTValueProc[076]:=Unaligned(@FilNTValue076);
  // (fading) not clippped
  NTValueProc[071]:=Unaligned(@FilNTValue071);
  // (fading) top-bottom clippped
  NTValueProc[073]:=Unaligned(@FilNTValue073);
  // (fading) left-right-top-bottom clippped
  NTValueProc[075]:=Unaligned(@FilNTValue075);
  // (fading) image has monochrome color channel
  NTValueProc[077]:=Unaligned(@FilNTValue077);

  {GrayscaleB}
  // (constant) not clippped
  NTValueProc[080]:=Unaligned(@FilNTValue080);
  // (constant) top-bottom clippped
  NTValueProc[082]:=Unaligned(@FilNTValue082);
  // (constant) left-right-top-bottom clippped
  NTValueProc[084]:=Unaligned(@FilNTValue084);
  // (constant) image has monochrome color channel
  NTValueProc[086]:=Unaligned(@FilNTValue086);
  // (fading) not clippped
  NTValueProc[081]:=Unaligned(@FilNTValue081);
  // (fading) top-bottom clippped
  NTValueProc[083]:=Unaligned(@FilNTValue083);
  // (fading) left-right-top-bottom clippped
  NTValueProc[085]:=Unaligned(@FilNTValue085);
  // (fading) image has monochrome color channel
  NTValueProc[087]:=Unaligned(@FilNTValue087);

  {Monochrome Noise}
  // (constant) not clippped
  NTValueProc[090]:=Unaligned(@FilNTValue090);
  // (constant) top-bottom clippped
  NTValueProc[092]:=Unaligned(@FilNTValue092);
  // (constant) left-right-top-bottom clippped
  NTValueProc[094]:=Unaligned(@FilNTValue094);
  // (constant) image has monochrome color channel
  NTValueProc[096]:=Unaligned(@FilNTValue096);
  // (fading) not clippped
  NTValueProc[091]:=Unaligned(@FilNTValue091);
  // (fading) top-bottom clippped
  NTValueProc[093]:=Unaligned(@FilNTValue093);
  // (fading) left-right-top-bottom clippped
  NTValueProc[095]:=Unaligned(@FilNTValue095);
  // (fading) image has monochrome color channel
  NTValueProc[097]:=Unaligned(@FilNTValue097);

  {Color of Curent Layer}
  // (constant) not clippped
  NTColorProc[000]:=Unaligned(@FilNTColor000);
  // (constant) top-bottom clippped
  NTColorProc[002]:=Unaligned(@FilNTColor002);
  // (constant) left-right-top-bottom clippped
  NTColorProc[004]:=Unaligned(@FilNTColor004);
  // (constant) image has monochrome color channel
  NTColorProc[006]:=Unaligned(@FilNTColor006);
  // (fading) not clippped
  NTColorProc[001]:=Unaligned(@FilNTColor000);
  // (fading) top-bottom clippped
  NTColorProc[003]:=Unaligned(@FilNTColor002);
  // (fading) left-right-top-bottom clippped
  NTColorProc[005]:=Unaligned(@FilNTColor004);
  // (fading) image has monochrome color channel
  NTColorProc[007]:=Unaligned(@FilNTColor006);

  {Color of Curent Layer(Additive)}
  // (constant) not clippped
  NTColorProc[010]:=Unaligned(@FilNTColor010);
  // (constant) top-bottom clippped
  NTColorProc[012]:=Unaligned(@FilNTColor012);
  // (constant) left-right-top-bottom clippped
  NTColorProc[014]:=Unaligned(@FilNTColor014);
  // (constant) image has monochrome color channel
  NTColorProc[016]:=Unaligned(@FilNTColor016);
  // (fading) not clippped
  NTColorProc[011]:=Unaligned(@FilNTColor011);
  // (fading) top-bottom clippped
  NTColorProc[013]:=Unaligned(@FilNTColor013);
  // (fading) left-right-top-bottom clippped
  NTColorProc[015]:=Unaligned(@FilNTColor015);
  // (fading) image has monochrome color channel
  NTColorProc[017]:=Unaligned(@FilNTColor017);

  {Color of Curent Layer(Alphablend)}
  // (constant) not clippped
  NTColorProc[020]:=Unaligned(@FilNTColor020);
  // (constant) top-bottom clippped
  NTColorProc[022]:=Unaligned(@FilNTColor022);
  // (constant) left-right-top-bottom clippped
  NTColorProc[024]:=Unaligned(@FilNTColor024);
  // (constant) image has monochrome color channel
  NTColorProc[026]:=Unaligned(@FilNTColor026);
  // (fading) not clippped
  NTColorProc[021]:=Unaligned(@FilNTColor020);
  // (fading) top-bottom clippped
  NTColorProc[023]:=Unaligned(@FilNTColor022);
  // (fading) left-right-top-bottom clippped
  NTColorProc[025]:=Unaligned(@FilNTColor024);
  // (fading) image has monochrome color channel
  NTColorProc[027]:=Unaligned(@FilNTColor026);

  // PT - partly transparent pixels;

  {Empty}
  PTValueProc[009]:=Unaligned(@FilPTValue009);
  {Empty}
  PTColorProc[009]:=Unaligned(@FilPTColor009);

  {Monochrome}
  // (constant) not clippped
  PTValueProc[000]:=Unaligned(@FilPTValue000);
  // (constant) top-bottom clippped
  PTValueProc[002]:=Unaligned(@FilPTValue002);
  // (constant) left-right-top-bottom clippped
  PTValueProc[004]:=Unaligned(@FilPTValue004);
  // (fading) not clippped
  PTValueProc[001]:=Unaligned(@FilPTValue000);
  // (fading) top-bottom clippped
  PTValueProc[003]:=Unaligned(@FilPTValue002);
  // (fading) left-right-top-bottom clippped
  PTValueProc[005]:=Unaligned(@FilPTValue004);

  {Additive}
  // (constant) not clippped
  PTValueProc[010]:=Unaligned(@FilPTValue010);
  // (constant) top-bottom clippped
  PTValueProc[012]:=Unaligned(@FilPTValue012);
  // (constant) left-right-top-bottom clippped
  PTValueProc[014]:=Unaligned(@FilPTValue014);
  // (fading) not clippped
  PTValueProc[011]:=Unaligned(@FilPTValue011);
  // (fading) top-bottom clippped
  PTValueProc[013]:=Unaligned(@FilPTValue013);
  // (fading) left-right-top-bottom clippped
  PTValueProc[015]:=Unaligned(@FilPTValue015);

  {Alphablend}
  // (constant) not clippped
  PTValueProc[020]:=Unaligned(@FilPTValue020);
  // (constant) top-bottom clippped
  PTValueProc[022]:=Unaligned(@FilPTValue022);
  // (constant) left-right-top-bottom clippped
  PTValueProc[024]:=Unaligned(@FilPTValue024);
  // (fading) not clippped
  PTValueProc[021]:=Unaligned(@FilPTValue020);
  // (fading) top-bottom clippped
  PTValueProc[023]:=Unaligned(@FilPTValue022);
  // (fading) left-right-top-bottom clippped
  PTValueProc[025]:=Unaligned(@FilPTValue024);

  {Inverse}
  // (constant) not clippped
  PTValueProc[030]:=Unaligned(@FilPTValue030);
  // (constant) top-bottom clippped
  PTValueProc[032]:=Unaligned(@FilPTValue032);
  // (constant) left-right-top-bottom clippped
  PTValueProc[034]:=Unaligned(@FilPTValue034);
  // (fading) not clippped
  PTValueProc[031]:=Unaligned(@FilPTValue031);
  // (fading) top-bottom clippped
  PTValueProc[033]:=Unaligned(@FilPTValue033);
  // (fading) left-right-top-bottom clippped
  PTValueProc[035]:=Unaligned(@FilPTValue035);

  {Highlighted}
  // (constant) not clippped
  PTValueProc[040]:=Unaligned(@FilPTValue040);
  // (constant) top-bottom clippped
  PTValueProc[042]:=Unaligned(@FilPTValue042);
  // (constant) left-right-top-bottom clippped
  PTValueProc[044]:=Unaligned(@FilPTValue044);
  // (fading) not clippped
  PTValueProc[041]:=Unaligned(@FilPTValue040);
  // (fading) top-bottom clippped
  PTValueProc[043]:=Unaligned(@FilPTValue042);
  // (fading) left-right-top-bottom clippped
  PTValueProc[045]:=Unaligned(@FilPTValue044);

  {Darkened}
  // (constant) not clippped
  PTValueProc[050]:=Unaligned(@FilPTValue050);
  // (constant) top-bottom clippped
  PTValueProc[052]:=Unaligned(@FilPTValue052);
  // (constant) left-right-top-bottom clippped
  PTValueProc[054]:=Unaligned(@FilPTValue054);
  // (fading) not clippped
  PTValueProc[051]:=Unaligned(@FilPTValue050);
  // (fading) top-bottom clippped
  PTValueProc[053]:=Unaligned(@FilPTValue052);
  // (fading) left-right-top-bottom clippped
  PTValueProc[055]:=Unaligned(@FilPTValue054);

  {GrayscaleR}
  // (constant) not clippped
  PTValueProc[060]:=Unaligned(@FilPTValue060);
  // (constant) top-bottom clippped
  PTValueProc[062]:=Unaligned(@FilPTValue062);
  // (constant) left-right-top-bottom clippped
  PTValueProc[064]:=Unaligned(@FilPTValue064);
  // (fading) not clippped
  PTValueProc[061]:=Unaligned(@FilPTValue061);
  // (fading) top-bottom clippped
  PTValueProc[063]:=Unaligned(@FilPTValue063);
  // (fading) left-right-top-bottom clippped
  PTValueProc[065]:=Unaligned(@FilPTValue065);

  {GrayscaleG}
  // (constant) not clippped
  PTValueProc[070]:=Unaligned(@FilPTValue070);
  // (constant) top-bottom clippped
  PTValueProc[072]:=Unaligned(@FilPTValue072);
  // (constant) left-right-top-bottom clippped
  PTValueProc[074]:=Unaligned(@FilPTValue074);
  // (fading) not clippped
  PTValueProc[071]:=Unaligned(@FilPTValue071);
  // (fading) top-bottom clippped
  PTValueProc[073]:=Unaligned(@FilPTValue073);
  // (fading) left-right-top-bottom clippped
  PTValueProc[075]:=Unaligned(@FilPTValue075);

  {GrayscaleB}
  // (constant) not clippped
  PTValueProc[080]:=Unaligned(@FilPTValue080);
  // (constant) top-bottom clippped
  PTValueProc[082]:=Unaligned(@FilPTValue082);
  // (constant) left-right-top-bottom clippped
  PTValueProc[084]:=Unaligned(@FilPTValue084);
  // (fading) not clippped
  PTValueProc[081]:=Unaligned(@FilPTValue081);
  // (fading) top-bottom clippped
  PTValueProc[083]:=Unaligned(@FilPTValue083);
  // (fading) left-right-top-bottom clippped
  PTValueProc[085]:=Unaligned(@FilPTValue085);

  {Monochrome Noise}
  // (constant) not clippped
  PTValueProc[090]:=Unaligned(@FilPTValue090);
  // (constant) top-bottom clippped
  PTValueProc[092]:=Unaligned(@FilPTValue092);
  // (constant) left-right-top-bottom clippped
  PTValueProc[094]:=Unaligned(@FilPTValue094);
  // (fading) not clippped
  PTValueProc[091]:=Unaligned(@FilPTValue091);
  // (fading) top-bottom clippped
  PTValueProc[093]:=Unaligned(@FilPTValue093);
  // (fading) left-right-top-bottom clippped
  PTValueProc[095]:=Unaligned(@FilPTValue095);

  {Color of Curent Layer}
  // (constant) not clippped
  PTColorProc[000]:=Unaligned(@FilPTColor000);
  // (constant) top-bottom clippped
  PTColorProc[002]:=Unaligned(@FilPTColor002);
  // (constant) left-right-top-bottom clippped
  PTColorProc[004]:=Unaligned(@FilPTColor004);
  // (constant) image has transparent alpha channel
  PTColorProc[006]:=Unaligned(@FilPTColor006);
  // (fading) not clippped
  PTColorProc[001]:=Unaligned(@FilPTColor000);
  // (fading) top-bottom clippped
  PTColorProc[003]:=Unaligned(@FilPTColor002);
  // (fading) left-right-top-bottom clippped
  PTColorProc[005]:=Unaligned(@FilPTColor004);
  // (fading) image has transparent alpha channel
  PTColorProc[007]:=Unaligned(@FilPTColor006);

  {Color of Curent Layer(Additive)}
  // (constant) not clippped
  PTColorProc[010]:=Unaligned(@FilPTColor010);
  // (constant) top-bottom clippped
  PTColorProc[012]:=Unaligned(@FilPTColor012);
  // (constant) left-right-top-bottom clippped
  PTColorProc[014]:=Unaligned(@FilPTColor014);
  // (constant) image has monochrome color channel
  PTColorProc[016]:=Unaligned(@FilPTColor016);
  // (fading) not clippped
  PTColorProc[011]:=Unaligned(@FilPTColor011);
  // (fading) top-bottom clippped
  PTColorProc[013]:=Unaligned(@FilPTColor013);
  // (fading) left-right-top-bottom clippped
  PTColorProc[015]:=Unaligned(@FilPTColor015);
  // (fading) image has monochrome color channel
  PTColorProc[017]:=Unaligned(@FilPTColor016);

  {Color of Curent Layer(Alphablend)}
  // (constant) not clippped
  PTColorProc[020]:=Unaligned(@FilPTColor020);
  // (constant) top-bottom clippped
  PTColorProc[022]:=Unaligned(@FilPTColor022);
  // (constant) left-right-top-bottom clippped
  PTColorProc[024]:=Unaligned(@FilPTColor024);
  // (constant) image has transparent alpha channel
  PTColorProc[026]:=Unaligned(@FilPTColor006);
  // (fading) not clippped
  PTColorProc[021]:=Unaligned(@FilPTColor020);
  // (fading) top-bottom clippped
  PTColorProc[023]:=Unaligned(@FilPTColor022);
  // (fading) left-right-top-bottom clippped
  PTColorProc[025]:=Unaligned(@FilPTColor024);
  // (fading) image has transparent alpha channel
  PTColorProc[027]:=Unaligned(@FilPTColor006);

end; {$endregion}

// Table of Counts Vertically Init.(Image Clipping):
procedure TFastimage.CrtNTCntIndArr; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_cnt_ind_arr_ptr     : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  i                      : integer;
  s                      : longword;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    Exit;
  if (nt_pix_cnt=0) then
    Exit;
  SetLength(nt_cnt_ind_arr,0);
  SetLength(nt_cnt_ind_arr,bmp_src_rct_clp.height);
  nt_cnt_ind_arr_ptr     :=@nt_cnt_ind_arr     [0];
  nt_pix_intr_cnt_arr_ptr:=@nt_pix_intr_cnt_arr[0];
  s:=0;
  for i:=0 to bmp_src_rct_clp.height-1 do
    begin
          nt_cnt_ind_arr_ptr^:=s;
      Inc(nt_cnt_ind_arr_ptr);
      s+= nt_pix_intr_cnt_arr_ptr^;
      Inc(nt_pix_intr_cnt_arr_ptr);
    end;
end; {$endregion}
procedure TFastimage.CrtPTCntIndArr; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_cnt_ind_arr_ptr     : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  i                      : integer;
  s                      : longword;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    Exit;
  if (pt_pix_cnt=0) then
    Exit;
  SetLength(pt_cnt_ind_arr,0);
  SetLength(pt_cnt_ind_arr,bmp_src_rct_clp.height);
  pt_cnt_ind_arr_ptr     :=@pt_cnt_ind_arr     [0];
  pt_pix_intr_cnt_arr_ptr:=@pt_pix_intr_cnt_arr[0];
  s:=0;
  for i:=0 to bmp_src_rct_clp.height-1 do
    begin
          pt_cnt_ind_arr_ptr^:=s;
      Inc(pt_cnt_ind_arr_ptr);
      s+=pt_pix_intr_cnt_arr_ptr^;
      Inc(pt_pix_intr_cnt_arr_ptr);
    end;
end; {$endregion}

// Mask Template Drawing:
// Fill Mask With Random Color:
procedure TFastImage.FilMaskTemplate0; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst_0,rct_dst_1,rct_dst_2: TPtRect;
  bmp_bckgd_ptr2               : PInteger;
  pix_color_ptr                : PInteger;
  first_row_pix_ptr            : PInteger;
  nt_pix_intr_cnt_arr_ptr      : PInteger;
  nt_pix_intr_sht_arr_ptr      : PInteger;
  nt_pix_intr_sht_arr_ptr_mul  : integer;
  x,y,bmp_bckgd_width_mul_y    : integer;
begin
  rct_dst_0                    :=PtBounds(bmp_ftimg_left,bmp_ftimg_top+nt_pix_arr_row_mrg_top*tilemap_sprite_w_h.y,tilemap_sprite_w_h.x,tilemap_sprite_w_h.y);
  rct_dst_1                    :=rct_dst_0;
  bmp_bckgd_width_mul_y        :=bmp_bckgd_width*tilemap_sprite_w_h.y;
  bmp_bckgd_ptr2               :=@bmp_bckgd_ptr      [000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000];
  first_row_pix_ptr            :=@bmp_bckgd_ptr      [(nt_pix_arr_row_mrg_top*tilemap_sprite_w_h.y+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left];
  nt_pix_intr_cnt_arr_ptr      :=@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000000000000];
  nt_pix_intr_sht_arr_ptr      :=@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000];
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      rct_dst_1    :=rct_dst_0;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
          nt_pix_intr_sht_arr_ptr_mul:=nt_pix_intr_sht_arr_ptr^*tilemap_sprite_w_h.x;
          rct_dst_1.left             :=rct_dst_0.left +nt_pix_intr_sht_arr_ptr_mul;
          rct_dst_1.right            :=rct_dst_0.right+nt_pix_intr_sht_arr_ptr_mul;
          rct_dst_2                  :=ClippedRct(rct_clp_ptr^,rct_dst_1);
          PPFloodFill(bmp_bckgd_ptr2,rct_dst_2,bmp_bckgd_width,Random($FFFFFF));
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width_mul_y);
      Inc(rct_dst_0.top    ,tilemap_sprite_w_h .y);
      Inc(rct_dst_0.bottom ,tilemap_sprite_w_h .y);
    end;
end; {$endregion}
// Fill Mask With Specified Sprite:
procedure TFastImage.FilMaskTemplate1; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst_0,rct_dst_1,rct_dst_2: TPtRect;
  bmp_bckgd_ptr2               : PInteger;
  pix_color_ptr                : PInteger;
  first_row_pix_ptr            : PInteger;
  nt_pix_intr_cnt_arr_ptr      : PInteger;
  nt_pix_intr_sht_arr_ptr      : PInteger;
  nt_pix_intr_sht_arr_ptr_mul  : integer;
  i,j,bmp_bckgd_width_mul_y    : integer;
begin
  with tilemap_sprite_w_h do
    begin
      rct_dst_0                    :=PtBounds(bmp_ftimg_left,bmp_ftimg_top+nt_pix_arr_row_mrg_top*y,x,y);
      rct_dst_1                    :=rct_dst_0;
      bmp_bckgd_width_mul_y        :=bmp_bckgd_width*y;
      bmp_bckgd_ptr2               :=Unaligned(@bmp_bckgd_ptr      [00000000000000000000000000000000000000000000000000000000000000000000000]);
      first_row_pix_ptr            :=Unaligned(@bmp_bckgd_ptr      [(nt_pix_arr_row_mrg_top*y+bmp_ftimg_top)*bmp_bckgd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr      :=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+00000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr      :=Unaligned(@nt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000000000000000000]);
      for j:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          rct_dst_1    :=rct_dst_0;
          for i:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              nt_pix_intr_sht_arr_ptr_mul:=nt_pix_intr_sht_arr_ptr^*x;
              rct_dst_1.left             :=rct_dst_0.left +nt_pix_intr_sht_arr_ptr_mul;
              rct_dst_1.right            :=rct_dst_0.right+nt_pix_intr_sht_arr_ptr_mul;
              with tilemap_sprite_ptr^ do
                begin
                  SetRctPos(rct_dst_1.left,rct_dst_1.top);
                  SdrProc[3];
                end;
              Inc(nt_pix_intr_sht_arr_ptr);
            end;
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bckgd_width_mul_y);
          Inc(rct_dst_0.top    ,                    y);
          Inc(rct_dst_0.bottom ,                    y);
        end;
    end;
end; {$endregion}

// Full Image Drawing:
procedure TFastimage.ShaderInfo;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  pix_drw_type             :=0; //must be in range of [0..002]

  fx_cnt                   :=0; //must be in range of [0..255]

  fx_arr[0].rep_cnt        :=1; //must be in range of [0..255]

  fx_arr[0].nt_pix_srf_type:=0{1}; //must be in range of [0..001]
  fx_arr[0].nt_pix_cfx_type:=9; //must be in range of [0..255]
  fx_arr[0].nt_pix_cng_type:=1; //must be in range of [0..001]

  fx_arr[0].pt_pix_srf_type:=0{1}; //must be in range of [0..001]
  fx_arr[0].pt_pix_cfx_type:=9; //must be in range of [0..255]
  fx_arr[0].pt_pix_cng_type:=1; //must be in range of [0..001]

  fx_arr[1].rep_cnt        :=1; //must be in range of [0..255]

  fx_arr[1].nt_pix_srf_type:=1; //must be in range of [0..001]
  fx_arr[1].nt_pix_cfx_type:=4; //must be in range of [0..255]
  fx_arr[1].nt_pix_cng_type:=1; //must be in range of [0..001]

  fx_arr[1].pt_pix_srf_type:=1; //must be in range of [0..001]
  fx_arr[1].pt_pix_cfx_type:=4; //must be in range of [0..255]
  fx_arr[1].pt_pix_cng_type:=1; //must be in range of [0..001]

  nt_pix_srf_type          :=1; //must be in range of [0..002]
  nt_pix_cfx_type          :=0; //must be in range of [0..002]
  nt_pix_cng_type          :=0; //must be in range of [0..001]

  pt_pix_srf_type          :=1; //must be in range of [0..002]
  pt_pix_cfx_type          :=0; //must be in range of [0..002]
  pt_pix_cng_type          :=0; //must be in range of [0..001]

end; {$endregion}
procedure TFastimage.SetSdrType;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  sdr_type_ind:=3*img_kind+pix_drw_type;
end; {$endregion}
procedure TFastimage.SdrTypeInit; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType[000]:=Unaligned(@SdrType000);
  SdrType[001]:=Unaligned(@SdrType001);
  SdrType[002]:=Unaligned(@SdrType002);
  SdrType[003]:=Unaligned(@SdrType003);
  SdrType[004]:=Unaligned(@SdrType004);
  SdrType[005]:=Unaligned(@SdrType005);
  SdrType[006]:=Unaligned(@SdrType006);
  SdrType[007]:=Unaligned(@SdrType007);
  SdrType[008]:=Unaligned(@SdrType008);
  SdrType[009]:=Unaligned(@SdrType009);
  SdrType[010]:=Unaligned(@SdrType010);
  SdrType[011]:=Unaligned(@SdrType011);
  SdrType[012]:=Unaligned(@SdrType012);
  SdrType[013]:=Unaligned(@SdrType013);
  SdrType[014]:=Unaligned(@SdrType014);
  SdrType[015]:=Unaligned(@SdrType015);
  SdrType[016]:=Unaligned(@SdrType016);
  SdrType[017]:=Unaligned(@SdrType017);
  SdrType[018]:=Unaligned(@SdrType018);
  SdrType[019]:=Unaligned(@SdrType019);
  SdrType[020]:=Unaligned(@SdrType020);
  SdrType[021]:=Unaligned(@SdrType021);
  SdrType[022]:=Unaligned(@SdrType022);
  SdrType[023]:=Unaligned(@SdrType023);
  SdrType[024]:=Unaligned(@SdrType024);
  SdrType[025]:=Unaligned(@SdrType025);
  SdrType[026]:=Unaligned(@SdrType026);
  SdrType[027]:=Unaligned(@SdrType027);
  SdrType[028]:=Unaligned(@SdrType028);
  SdrType[029]:=Unaligned(@SdrType029);
  SdrType[030]:=Unaligned(@SdrType030);
  SdrType[031]:=Unaligned(@SdrType030);
  SdrType[032]:=Unaligned(@SdrType030);
  SdrType[033]:=Unaligned(@SdrType030);
  SdrType[034]:=Unaligned(@SdrType030);
  SdrType[035]:=Unaligned(@SdrType030);
  SdrType[036]:=Unaligned(@SdrType009);
  SdrType[037]:=Unaligned(@SdrType010);
  SdrType[038]:=Unaligned(@SdrType011);
end; {$endregion}
procedure TFastimage.SdrType000;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (nt_pix_srf_type<>0) then
    begin
      nt_begin_proc_ind:=((nt_pix_srf_type));
      nt_color_proc_ind:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_clp_type<<1+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
    end
  else
    begin
      nt_begin_proc_ind:=0;
      nt_color_proc_ind:=9;
    end;
  if (pt_pix_srf_type<>0) then
    begin
      pt_begin_proc_ind:=((pt_pix_srf_type));
      pt_color_proc_ind:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_clp_type<<1+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
    end
  else
    begin
      pt_begin_proc_ind:=0;
      pt_color_proc_ind:=9;
    end;
  fx_cnt:=0;
end; {$endregion}
procedure TFastimage.SdrType001;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
    end;
end; {$endregion}
procedure TFastimage.SdrType002;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  if (nt_pix_srf_type<>0) then
    begin
      nt_begin_proc_ind:=((nt_pix_srf_type));
      nt_color_proc_ind:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_clp_type<<1+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
    end
  else
    begin
      nt_begin_proc_ind:=0;
      nt_color_proc_ind:=9;
    end;
  if (pt_pix_srf_type<>0) then
    begin
      pt_begin_proc_ind:=((pt_pix_srf_type));
      pt_color_proc_ind:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_clp_type<<1+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
    end
  else
    begin
      pt_begin_proc_ind:=0;
      pt_color_proc_ind:=9;
    end;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
    end;
end; {$endregion}
procedure TFastimage.SdrType003;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  if (nt_pix_srf_type<>0) then
    begin
      nt_begin_proc_ind:=((nt_pix_srf_type));
      nt_color_proc_ind:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_clp_type<<1+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
    end
  else
    begin
      nt_begin_proc_ind:=0;
      nt_color_proc_ind:=9;
    end;
  fx_cnt:=0;
end; {$endregion}
procedure TFastimage.SdrType004;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=9;
    end;
end; {$endregion}
procedure TFastimage.SdrType005;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  if (nt_pix_srf_type<>0) then
    begin
      nt_begin_proc_ind:=((nt_pix_srf_type));
      nt_color_proc_ind:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_clp_type<<1+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
    end
  else
    begin
      nt_begin_proc_ind:=0;
      nt_color_proc_ind:=9;
    end;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=9;
    end;
end; {$endregion}
procedure TFastimage.SdrType006;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  if (pt_pix_srf_type<>0) then
    begin
      pt_begin_proc_ind:=((pt_pix_srf_type));
      pt_color_proc_ind:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_clp_type<<1+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
    end
  else
    begin
      pt_begin_proc_ind:=0;
      pt_color_proc_ind:=9;
    end;
  fx_cnt:=0;
end; {$endregion}
procedure TFastimage.SdrType007;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=9;
      fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
    end;
end; {$endregion}
procedure TFastimage.SdrType008;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  if (pt_pix_srf_type<>0) then
    begin
      pt_begin_proc_ind:=((pt_pix_srf_type));
      pt_color_proc_ind:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_clp_type<<1+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
    end
  else
    begin
      pt_begin_proc_ind:=0;
      pt_color_proc_ind:=9;
    end;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=9;
      fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
    end;
end; {$endregion}
procedure TFastimage.SdrType009;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  nt_pix_clp_type  :=3;
  nt_begin_proc_ind:=0;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  if (nt_pix_srf_type<>0) then
    nt_color_proc_ind:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_clp_type<<1+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9
  else
    nt_color_proc_ind:=9;
  fx_cnt:=0;
end; {$endregion}
procedure TFastimage.SdrType010;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_pix_clp_type  :=3;
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=9;
    end;
end; {$endregion}
procedure TFastimage.SdrType011;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_pix_clp_type  :=3;
  nt_begin_proc_ind:=0;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  if (nt_pix_srf_type<>0) then
    nt_color_proc_ind:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_clp_type<<1+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9
  else
    nt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=9;
    end;
end; {$endregion}
procedure TFastimage.SdrType012;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pt_pix_clp_type  :=3;
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  if (pt_pix_srf_type<>0) then
    pt_color_proc_ind:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_clp_type<<1+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9
  else
    pt_color_proc_ind:=9;
  fx_cnt:=0;
end; {$endregion}
procedure TFastimage.SdrType013;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  pt_pix_clp_type  :=3;
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=9;
    end;
end; {$endregion}
procedure TFastimage.SdrType014;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  pt_pix_clp_type  :=3;
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  if (pt_pix_srf_type<>0) then
    pt_color_proc_ind:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_clp_type<<1+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9
  else
    pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=9;
    end;
end; {$endregion}
procedure TFastimage.SdrType015;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  fx_cnt           :=0;
end; {$endregion}
procedure TFastimage.SdrType016;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
    end;
end; {$endregion}
procedure TFastimage.SdrType017;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
    end;
end; {$endregion}
procedure TFastimage.SdrType018;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  fx_cnt           :=0;
end; {$endregion}
procedure TFastimage.SdrType019;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=9;
    end;
end; {$endregion}
procedure TFastimage.SdrType020;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=9;
    end;
end; {$endregion}
procedure TFastimage.SdrType021;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  fx_cnt           :=0;
end; {$endregion}
procedure TFastimage.SdrType022;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=9;
      fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
    end;
end; {$endregion}
procedure TFastimage.SdrType023;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=9;
      fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
    end;
end; {$endregion}
procedure TFastimage.SdrType024;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  nt_pix_clp_type  :=3;
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  fx_cnt           :=0;
end; {$endregion}
procedure TFastimage.SdrType025;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_pix_clp_type  :=3;
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=9;
    end;
end; {$endregion}
procedure TFastimage.SdrType026;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_pix_clp_type  :=3;
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=9;
    end;
end; {$endregion}
procedure TFastimage.SdrType027;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  nt_pix_clp_type  :=3;
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  fx_cnt           :=0;
end; {$endregion}
procedure TFastimage.SdrType028;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_pix_clp_type  :=3;
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=9;
    end;
end; {$endregion}
procedure TFastimage.SdrType029;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_pix_clp_type  :=3;
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=9;
    end;
end; {$endregion}
procedure TFastimage.SdrType030;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  fx_cnt           :=0;
end; {$endregion}
procedure TFastimage.SdrType031;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {empty}
end; {$endregion}
procedure TFastimage.ShaderType;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin

  {Image Description} {$region -fold}
  {
    ----------------Image Has Alpha Channel And Color Channel---------------
    0:
    image has:  not monochrome alpha channel,
                not monochrome color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels>0;

    1:
    image has:  not monochrome alpha channel,
                not monochrome color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;

    2:
    image has:  not monochrome alpha channel,
                not monochrome color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels>0;

    3:
    image has:      monochrome alpha channel(white, not transparent),
                not monochrome color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;

    4:
    image has:      monochrome alpha channel(transparent),
                not monochrome color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels>0;


    ----------------------Image Has Only Alpha Channel----------------------
    5:
    image has:  not monochrome alpha channel,
                            no color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels>0;

    6:
    image has:  not monochrome alpha channel,
                            no color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;

    7:
    image has:  not monochrome alpha channel,
                            no color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels>0;

    8:
    image has:      monochrome alpha channel(white, not transparent),
                            no color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;

    9:
    image has:      monochrome alpha channel(transparent),
                            no color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels>0;


    --------------Image Has No Alpha Channel And Color Channel--------------
    10:
    image has:      no alpha channel(black, invisible),
                    no color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels=0;

    --------------------------Image is Value Array--------------------------
    11:
    count of    not transparent pixels>0;
    count of partly transparent pixels>0;

    --------------------------Image is Mask--------------------------
    12:
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;
  } {$endregion}

  {case img_kind of
    00   : {$region -fold}
      case pix_drw_type of
        0:
          begin
            if (nt_pix_srf_type<>0) then
              begin
                nt_begin_proc_ind:=((nt_pix_srf_type));
                nt_color_proc_ind:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_clp_type<<1+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
              end
            else
              begin
                nt_begin_proc_ind:=0;
                nt_color_proc_ind:=9;
              end;
            if (pt_pix_srf_type<>0) then
              begin
                pt_begin_proc_ind:=((pt_pix_srf_type));
                pt_color_proc_ind:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_clp_type<<1+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
              end
            else
              begin
                pt_begin_proc_ind:=0;
                pt_color_proc_ind:=9;
              end;
            fx_cnt:=0;
            Exit;
          end;
        1:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
              end;
            Exit;
          end;
        2:
          begin
            if (nt_pix_srf_type<>0) then
              begin
                nt_begin_proc_ind:=((nt_pix_srf_type));
                nt_color_proc_ind:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_clp_type<<1+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
              end
            else
              begin
                nt_begin_proc_ind:=0;
                nt_color_proc_ind:=9;
              end;
            if (pt_pix_srf_type<>0) then
              begin
                pt_begin_proc_ind:=((pt_pix_srf_type));
                pt_color_proc_ind:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_clp_type<<1+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
              end
            else
              begin
                pt_begin_proc_ind:=0;
                pt_color_proc_ind:=9;
              end;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
              end;
            Exit;
          end;
      end; {$endregion}
    01   : {$region -fold}
      case pix_drw_type of
        0:
          begin
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            if (nt_pix_srf_type<>0) then
              begin
                nt_begin_proc_ind:=((nt_pix_srf_type));
                nt_color_proc_ind:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_clp_type<<1+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
              end
            else
              begin
                nt_begin_proc_ind:=0;
                nt_color_proc_ind:=9;
              end;
            fx_cnt:=0;
            Exit;
          end;
        1:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=9;
              end;
            Exit;
          end;
        2:
          begin
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            if (nt_pix_srf_type<>0) then
              begin
                nt_begin_proc_ind:=((nt_pix_srf_type));
                nt_color_proc_ind:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_clp_type<<1+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
              end
            else
              begin
                nt_begin_proc_ind:=0;
                nt_color_proc_ind:=9;
              end;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=9;
              end;
            Exit;
          end;
      end; {$endregion}
    02   : {$region -fold}
      case pix_drw_type of
        0:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            if (pt_pix_srf_type<>0) then
              begin
                pt_begin_proc_ind:=((pt_pix_srf_type));
                pt_color_proc_ind:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_clp_type<<1+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
              end
            else
              begin
                pt_begin_proc_ind:=0;
                pt_color_proc_ind:=9;
              end;
            fx_cnt:=0;
            Exit;
          end;
        1:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=9;
                fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
              end;
            Exit;
          end;
        2:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            if (pt_pix_srf_type<>0) then
              begin
                pt_begin_proc_ind:=((pt_pix_srf_type));
                pt_color_proc_ind:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_clp_type<<1+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
              end
            else
              begin
                pt_begin_proc_ind:=0;
                pt_color_proc_ind:=9;
              end;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=9;
                fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
              end;
            Exit;
          end;
      end; {$endregion}
    03,12: {$region -fold}
      case pix_drw_type of
        0:
          begin
            nt_pix_clp_type  :=3;
            nt_begin_proc_ind:=0;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            if (nt_pix_srf_type<>0) then
              nt_color_proc_ind:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_clp_type<<1+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9
            else
              nt_color_proc_ind:=9;
            fx_cnt:=0;
            Exit;
          end;
        1:
          begin
            nt_pix_clp_type  :=3;
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=9;
              end;
            Exit;
          end;
        2:
          begin
            nt_pix_clp_type  :=3;
            nt_begin_proc_ind:=0;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            if (nt_pix_srf_type<>0) then
              nt_color_proc_ind:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_clp_type<<1+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9
            else
              nt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=9;
              end;
            Exit;
          end;
      end; {$endregion}
    04   : {$region -fold}
      case pix_drw_type of
        0:
          begin
            pt_pix_clp_type  :=3;
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            if (pt_pix_srf_type<>0) then
              pt_color_proc_ind:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_clp_type<<1+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9
            else
              pt_color_proc_ind:=9;
            fx_cnt:=0;
            Exit;
          end;
        1:
          begin
            pt_pix_clp_type  :=3;
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=9;
              end;
            Exit;
          end;
        2:
          begin
            pt_pix_clp_type  :=3;
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            if (pt_pix_srf_type<>0) then
              pt_color_proc_ind:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_clp_type<<1+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9
            else
              pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=9;
              end;
            Exit;
          end;
      end; {$endregion}
    05   : {$region -fold}
      case pix_drw_type of
        0:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            fx_cnt           :=0;
            Exit;
          end;
        1:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
              end;
            Exit;
          end;
        2:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
              end;
            Exit;
          end;
      end; {$endregion}
    06   : {$region -fold}
      case pix_drw_type of
        0:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            fx_cnt           :=0;
            Exit;
          end;
        1:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=9;
              end;
            Exit;
          end;
        2:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=9;
              end;
            Exit;
          end;
      end; {$endregion}
    07   : {$region -fold}
      case pix_drw_type of
        0:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            fx_cnt           :=0;
            Exit;
          end;
        1:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=9;
                fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
              end;
            Exit;
          end;
        2:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=9;
                fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
              end;
            Exit;
          end;
      end; {$endregion}
    08   : {$region -fold}
      case pix_drw_type of
        0:
          begin
            nt_pix_clp_type  :=3;
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            fx_cnt           :=0;
            Exit;
          end;
        1:
          begin
            nt_pix_clp_type  :=3;
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=9;
              end;
            Exit;
          end;
        2:
          begin
            nt_pix_clp_type  :=3;
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=9;
              end;
            Exit;
          end;
      end; {$endregion}
    09   : {$region -fold}
      case pix_drw_type of
        0:
          begin
            nt_pix_clp_type  :=3;
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            fx_cnt           :=0;
            Exit;
          end;
        1:
          begin
            nt_pix_clp_type  :=3;
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=9;
              end;
            Exit;
          end;
        2:
          begin
            nt_pix_clp_type  :=3;
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=9;
              end;
            Exit;
          end;
      end; {$endregion}
    10,11: {$region -fold}
      begin
        nt_begin_proc_ind:=0;
        nt_color_proc_ind:=9;
        pt_begin_proc_ind:=0;
        pt_color_proc_ind:=9;
        fx_cnt           :=0;
      end; {$endregion}
  end;}

  case sdr_type_ind of
    000: SdrType000;
    001: SdrType001;
    002: SdrType002;
    003: SdrType003;
    004: SdrType004;
    005: SdrType005;
    006: SdrType006;
    007: SdrType007;
    008: SdrType008;
    009: SdrType009;
    010: SdrType010;
    011: SdrType011;
    012: SdrType012;
    013: SdrType013;
    014: SdrType014;
    015: SdrType015;
    016: SdrType016;
    017: SdrType017;
    018: SdrType018;
    019: SdrType019;
    020: SdrType020;
    021: SdrType021;
    022: SdrType022;
    023: SdrType023;
    024: SdrType024;
    025: SdrType025;
    026: SdrType026;
    027: SdrType027;
    028: SdrType028;
    029: SdrType029;
    030: SdrType030;
    031: SdrType030;
    032: SdrType030;
    033: SdrType030;
    034: SdrType030;
    035: SdrType030;
    036: SdrType009;
    037: SdrType010;
    038: SdrType011;
  end;

end; {$endregion}
procedure TFastimage.SdrProcInit; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrProc[0]:=@UberShader0;
  SdrProc[1]:=@UberShader1;
  SdrProc[2]:=@UberShader2;
  SdrProc[3]:=@UberShader3;
end; {$endregion}
procedure TFastimage.UberShader0; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TFastimage.UberShader1; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  fx_arr_ptr: PFX;
  i,j       : shortint;
begin

  {Sprite Bounding Rectangles}
  SetRctDst;
  SetRctSrc;

  {Sprite Shader Type}
  {SdrType   [sdr_type_ind     ];} ShaderType;

  {Sprite Drawing}
  NTBeginProc[nt_begin_proc_ind];
  NTColorProc[nt_color_proc_ind];

  {Sprite Post-Processing}
  fx_arr_ptr:=Unaligned(@fx_arr[0]);
  for i:=0 to fx_cnt-1 do
    begin
      for j:=0 to fx_arr_ptr^.rep_cnt-1 do
        begin
          {Sprite Settings}

          {Sprite Drawing}
          NTValueProc[fx_arr_ptr^.nt_value_proc_ind];
        end;
      Inc(fx_arr_ptr);
    end;

end; {$endregion}
procedure TFastimage.UberShader2; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  fx_arr_ptr: PFX;
  i,j       : shortint;
begin

  {Sprite Bounding Rectangles}
  SetRctDst;
  SetRctSrc;

  {Sprite Shader Type}
  {SdrType   [sdr_type_ind     ];} ShaderType;

  {Sprite Drawing}
  PTBeginProc[pt_begin_proc_ind];
  PTColorProc[pt_color_proc_ind];

  {Sprite Post-Processing}
  fx_arr_ptr:=Unaligned(@fx_arr[0]);
  for i:=0 to fx_cnt-1 do
    begin
      for j:=0 to fx_arr_ptr^.rep_cnt-1 do
        begin
          {Sprite Settings}

          {Sprite Drawing}
          PTValueProc[fx_arr_ptr^.pt_value_proc_ind];
        end;
      Inc(fx_arr_ptr);
    end;

end; {$endregion}
procedure TFastimage.UberShader3; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  fx_arr_ptr: PFX;
  i,j       : shortint;
begin

  {Sprite Bounding Rectangles}
  SetRctDst;
  SetRctSrc;

  {Sprite Shader Type}
  {SdrType   [sdr_type_ind     ];} ShaderType;

  {Sprite Drawing}
  NTBeginProc[nt_begin_proc_ind];
  NTColorProc[nt_color_proc_ind];
  PTBeginProc[pt_begin_proc_ind];
  PTColorProc[pt_color_proc_ind];

  {Sprite Post-Processing}
  fx_arr_ptr:=Unaligned(@fx_arr[0]);
  for i:=0 to fx_cnt-1 do
    begin
      for j:=0 to fx_arr_ptr^.rep_cnt-1 do
        begin
          {Sprite Settings}

          {Sprite Drawing}
          NTValueProc[fx_arr_ptr^.nt_value_proc_ind];
          PTValueProc[fx_arr_ptr^.pt_value_proc_ind];
        end;
      Inc(fx_arr_ptr);
    end;

end; {$endregion}

// Clear Background from Image:
procedure TFastimage.ClrBkgnd; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  NTBeginProc[2];
  NTColorProc[0];
end; {$endregion} {$endregion}

{Create Border Around the Image-----------------------} {$region -fold}
procedure TFastImage.CrtBorderBmp(constref arr_src:T1IntrArr; var arr_dst:T1ObjSelArr; constref arr_src_width,arr_dst_width:integer; constref rect_left,rect_top,rect_width,rect_height:longword; var brdr_pix_cnt:integer; constref obj_kind,obj_id:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr      : PInteger;
  arr_dst_ptr      : PObjSel;
  d_width1,d_width2: integer;
  x_,y_            : integer;
begin
  brdr_pix_cnt     :=0;
  d_width1         :=                   arr_src_width- rect_width;
  d_width2         :=                   arr_dst_width- rect_width;
  arr_src_ptr      :=@arr_src[rect_left+arr_src_width*(rect_top+1)];
  arr_dst_ptr      :=@arr_dst[rect_left+arr_dst_width*(rect_top+1)];
  for y_:=0 to rect_height-3 do
    begin
      for x_:=0 to rect_width-1 do
        begin
          if (arr_src_ptr^<>0) then
            begin
              if ((arr_src_ptr-arr_src_width)^=0) then
                if ((arr_dst_ptr-arr_dst_width)^.obj_kind<>obj_kind) then
                  begin
                    (arr_dst_ptr-arr_dst_width)^.obj_kind:=obj_kind;
                    (arr_dst_ptr-arr_dst_width)^.obj_id  :=obj_id  ;
                    Inc(brdr_pix_cnt);
                  end;
              if ((arr_src_ptr+arr_src_width)^=0) then
                if ((arr_dst_ptr+arr_dst_width)^.obj_kind<>obj_kind) then
                  begin
                    (arr_dst_ptr+arr_dst_width)^.obj_kind:=obj_kind;
                    (arr_dst_ptr+arr_dst_width)^.obj_id  :=obj_id  ;
                    Inc(brdr_pix_cnt);
                  end;
            end;
          Inc(arr_src_ptr);
          Inc(arr_dst_ptr);
        end;
      Inc(arr_src_ptr,d_width1);
      Inc(arr_dst_ptr,d_width2);
    end;
end; {$endregion} {$endregion}

{Image Clipping---------------------------------------} {$region -fold}
procedure TFastImage.UlsProcInit;                                                                             {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  NTUselessProc[0]:=Unaligned(@NTUseless0);
  NTUselessProc[1]:=Unaligned(@NTUseless1);
  NTUselessProc[2]:=Unaligned(@NTUseless2);
  PTUselessProc[0]:=Unaligned(@PTUseless0);
  PTUselessProc[1]:=Unaligned(@PTUseless1);
  PTUselessProc[2]:=Unaligned(@PTUseless2);
end; {$endregion}
procedure TFastImage.NTUseless0(var arr_dst:T1IntrArr; constref arr_dst_width:integer; constref val:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_cnt_arr_ptr   : PInteger;
  nt_pix_intr_sht_arr_ptr   : PInteger;
  first_row_item_arr_dst_ptr: PInteger;
  arr_dst_ptr               : PInteger;
  nt_z_item_cnt             : integer;
  x,y                       : integer;
begin
  if (nt_pix_cnt<>0) then
    begin
      nt_z_item_cnt             :=0;
      first_row_item_arr_dst_ptr:=@arr_dst            [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*arr_dst_width+bmp_ftimg_left];
      nt_pix_intr_cnt_arr_ptr   :=@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000];
      nt_pix_intr_sht_arr_ptr   :=@nt_pix_intr_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000];
      for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          arr_dst_ptr:=first_row_item_arr_dst_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              if ((nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                begin
                  (nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                  Inc(nt_z_item_cnt);
                end;
              Inc (nt_pix_intr_sht_arr_ptr);
            end;
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_item_arr_dst_ptr,arr_dst_width);
        end;
    end;
  if (nt_z_item_cnt=0) then
    nt_useless:=0
  else
    nt_useless:=1;
  //if (img_kind=3) then
end; {$endregion}
procedure TFastImage.NTUseless1(var arr_dst:T1IntrArr; constref arr_dst_width:integer; constref val:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_cnt_arr_ptr   : PInteger;
  nt_pix_intr_sht_arr_ptr   : PInteger;
  first_row_item_arr_dst_ptr: PInteger;
  arr_dst_ptr               : PInteger;
  nt_z_item_cnt             : integer;
  x,y                       : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr=Nil) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    begin
      nt_useless:=0;
      Exit;
    end;
  if (nt_pix_cnt<>0) then
    begin
      nt_z_item_cnt             :=0;
      first_row_item_arr_dst_ptr:=@arr_dst            [(rct_src.top+bmp_ftimg_top)*arr_dst_width+bmp_ftimg_left];
      nt_pix_intr_cnt_arr_ptr   :=@nt_pix_intr_cnt_arr[ rct_src.top+0000000000000000000000000000000000000000000];
      nt_pix_intr_sht_arr_ptr   :=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+0000000000000000000000000000];
      for y:=0 to rct_src.height-1 do
        begin
          arr_dst_ptr:=first_row_item_arr_dst_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              if ((nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                begin
                  (nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                  Inc(nt_z_item_cnt);
                end;
              Inc (nt_pix_intr_sht_arr_ptr);
            end;
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_item_arr_dst_ptr,arr_dst_width);
        end;
    end;
  if (nt_z_item_cnt=0) then
    nt_useless:=0
  else
    nt_useless:=1;
  //if (img_kind=3) then
end; {$endregion}
procedure TFastImage.NTUseless2(var arr_dst:T1IntrArr; constref arr_dst_width:integer; constref val:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_cnt_arr_ptr   : PInteger;
  nt_pix_intr_sht_arr_ptr   : PInteger;
  first_row_item_arr_dst_ptr: PInteger;
  arr_dst_ptr               : PInteger;
  first_sht_pix_ptr         : PInteger;
  nt_z_item_cnt             : integer;
  x,y                       : integer;
  c,c1,c2                   : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr=Nil) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    begin
      nt_useless:=0;
      Exit;
    end;
  if (nt_pix_cnt<>0) then
    begin
      nt_z_item_cnt             :=0;
      first_row_item_arr_dst_ptr:=@arr_dst            [rct_dst.pt_rct.top*arr_dst_width+rct_dst.pt_rct.left];
      nt_pix_intr_cnt_arr_ptr   :=@nt_pix_intr_cnt_arr[rct_src.top+0000000000000000000000000000000000000000];
      nt_pix_intr_sht_arr_ptr   :=@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000];
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              arr_dst_ptr:=first_row_item_arr_dst_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc(nt_pix_intr_sht_arr_ptr,c1+1);
                  for x:=0 to (c2+1)-(c1+1)-1 do
                    begin
                      if ((nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                        begin
                          (nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                          Inc(nt_z_item_cnt);
                        end;
                      Inc(nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc(nt_pix_intr_sht_arr_ptr,c+1);
                  for x:=0 to nt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                    begin
                      if ((nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                        begin
                          (nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                          Inc(nt_z_item_cnt);
                        end;
                      Inc(nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
                  for x:=0 to c do
                    begin
                      if ((nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                        begin
                          (nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                          Inc(nt_z_item_cnt);
                        end;
                      Inc(nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                  begin
                    if ((nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                      begin
                        (nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                        Inc(nt_z_item_cnt);
                      end;
                    Inc(nt_pix_intr_sht_arr_ptr);
                  end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_item_arr_dst_ptr,arr_dst_width);
        end;
    end;
  if (nt_z_item_cnt=0) then
    nt_useless:=0
  else
    nt_useless:=1;
  //if (img_kind=3) then
end; {$endregion}
procedure TFastImage.PTUseless0(var arr_dst:T1IntrArr; constref arr_dst_width:integer; constref val:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_intr_cnt_arr_ptr   : PInteger;
  pt_pix_intr_sht_arr_ptr   : PInteger;
  first_row_item_arr_dst_ptr: PInteger;
  arr_dst_ptr               : PInteger;
  pt_z_item_cnt             : integer;
  x,y                       : integer;
begin
  if (pt_pix_cnt<>0) then
    begin
      pt_z_item_cnt             :=0;
      first_row_item_arr_dst_ptr:=@arr_dst            [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*arr_dst_width+bmp_ftimg_left];
      pt_pix_intr_cnt_arr_ptr   :=@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000];
      pt_pix_intr_sht_arr_ptr   :=@pt_pix_intr_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000];
      for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          arr_dst_ptr:=first_row_item_arr_dst_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              if ((pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                begin
                  (pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                  Inc(pt_z_item_cnt);
                end;
              Inc (pt_pix_intr_sht_arr_ptr);
            end;
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_item_arr_dst_ptr,arr_dst_width);
        end;
    end;
  if (pt_z_item_cnt=0) then
    pt_useless:=0
  else
    pt_useless:=1;
  //if (img_kind=3) then
end; {$endregion}
procedure TFastImage.PTUseless1(var arr_dst:T1IntrArr; constref arr_dst_width:integer; constref val:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_intr_cnt_arr_ptr   : PInteger;
  pt_pix_intr_sht_arr_ptr   : PInteger;
  first_row_item_arr_dst_ptr: PInteger;
  arr_dst_ptr               : PInteger;
  pt_z_item_cnt             : integer;
  x,y                       : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr=Nil) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    begin
      pt_useless:=0;
      Exit;
    end;
  if (pt_pix_cnt<>0) then
    begin
      pt_z_item_cnt             :=0;
      first_row_item_arr_dst_ptr:=@arr_dst            [(rct_src.top+bmp_ftimg_top)*arr_dst_width+bmp_ftimg_left];
      pt_pix_intr_cnt_arr_ptr   :=@pt_pix_intr_cnt_arr[ rct_src.top+0000000000000000000000000000000000000000000];
      pt_pix_intr_sht_arr_ptr   :=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+0000000000000000000000000000];
      for y:=0 to rct_src.height-1 do
        begin
          arr_dst_ptr:=first_row_item_arr_dst_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              if ((pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                begin
                  (pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                  Inc(pt_z_item_cnt);
                end;
              Inc (pt_pix_intr_sht_arr_ptr);
            end;
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_item_arr_dst_ptr,arr_dst_width);
        end;
    end;
  if (pt_z_item_cnt=0) then
    pt_useless:=0
  else
    pt_useless:=1;
  //if (img_kind=3) then
end; {$endregion}
procedure TFastImage.PTUseless2(var arr_dst:T1IntrArr; constref arr_dst_width:integer; constref val:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_intr_cnt_arr_ptr   : PInteger;
  pt_pix_intr_sht_arr_ptr   : PInteger;
  first_row_item_arr_dst_ptr: PInteger;
  arr_dst_ptr               : PInteger;
  first_sht_pix_ptr         : PInteger;
  pt_z_item_cnt             : integer;
  x,y                       : integer;
  c,c1,c2                   : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr=Nil) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    begin
      pt_useless:=0;
      Exit;
    end;
  if (pt_pix_cnt<>0) then
    begin
      pt_z_item_cnt             :=0;
      first_row_item_arr_dst_ptr:=@arr_dst            [rct_dst.pt_rct.top*arr_dst_width+rct_dst.pt_rct.left];
      pt_pix_intr_cnt_arr_ptr   :=@pt_pix_intr_cnt_arr[rct_src.top+0000000000000000000000000000000000000000];
      pt_pix_intr_sht_arr_ptr   :=@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000];
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              arr_dst_ptr:=first_row_item_arr_dst_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc(pt_pix_intr_sht_arr_ptr,c1+1);
                  for x:=0 to (c2+1)-(c1+1)-1 do
                    begin
                      if ((pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                        begin
                          (pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                          Inc(pt_z_item_cnt);
                        end;
                      Inc(pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc(pt_pix_intr_sht_arr_ptr,c+1);
                  for x:=0 to pt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                    begin
                      if ((pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                        begin
                          (pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                          Inc(pt_z_item_cnt);
                        end;
                      Inc(pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
                  for x:=0 to c do
                    begin
                      if ((pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                        begin
                          (pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                          Inc(pt_z_item_cnt);
                        end;
                      Inc(pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                  begin
                    if ((pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                      begin
                        (pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                        Inc(pt_z_item_cnt);
                      end;
                    Inc(pt_pix_intr_sht_arr_ptr);
                  end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_item_arr_dst_ptr,arr_dst_width);
        end;
    end;
  if (pt_z_item_cnt=0) then
    pt_useless:=0
  else
    pt_useless:=1;
  //if (img_kind=3) then
end; {$endregion}
function  TFastImage.Useless: byte;                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (nt_useless=0) and (pt_useless=0) then
    Result:=0;
  if (nt_useless=1) and (pt_useless=0) then
    Result:=1;
  if (nt_useless=0) and (pt_useless=1) then
    Result:=2;
  if (nt_useless=1) and (pt_useless=1) then
    Result:=3;
end; {$endregion}
procedure TFastImage.SetRctPos (rct    :TPtRect);                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct do
    begin
      bmp_ftimg_left  :=left  ;
      bmp_ftimg_top   :=top   ;
      bmp_ftimg_width :=width ;
      bmp_ftimg_height:=height;
      bmp_ftimg_right :=right ;
      bmp_ftimg_bottom:=bottom;
    end;
end; {$endregion}
procedure TFastImage.SetRctPos (x,y,w,h:integer);                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  bmp_ftimg_left  :=x;
  bmp_ftimg_top   :=y;
  bmp_ftimg_width :=w;
  bmp_ftimg_height:=h;
  bmp_ftimg_right :=bmp_ftimg_left+bmp_ftimg_width ;
  bmp_ftimg_bottom:=bmp_ftimg_top +bmp_ftimg_height;
end; {$endregion}
procedure TFastImage.SetRctPos (x,y    :integer);                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  bmp_ftimg_left  :=x;
  bmp_ftimg_top   :=y;
  bmp_ftimg_right :=bmp_ftimg_left+bmp_ftimg_width ;
  bmp_ftimg_bottom:=bmp_ftimg_top +bmp_ftimg_height;
end; {$endregion}
procedure TFastImage.SetRctPos (pvt    :TPtPosF);                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  bmp_ftimg_left  :=Trunc(pvt.x);
  bmp_ftimg_top   :=Trunc(pvt.y);
  bmp_ftimg_right :=bmp_ftimg_left+bmp_ftimg_width ;
  bmp_ftimg_bottom:=bmp_ftimg_top +bmp_ftimg_height;
end; {$endregion}
procedure TFastImage.SetRctDst;                                                                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  rct_dst:=PtRctB(bmp_ftimg_left,bmp_ftimg_top,bmp_ftimg_right,bmp_ftimg_bottom);
  rct_dst:=ClippedRctB(PtRct(rct_clp_ptr^.left  +rct_clp_mrg,
                             rct_clp_ptr^.top   +rct_clp_mrg,
                             rct_clp_ptr^.right -rct_clp_mrg,
                             rct_clp_ptr^.bottom-rct_clp_mrg),
                       rct_dst.pt_rct,
                       nt_pix_clp_type,
                       pt_pix_clp_type);
end; {$endregion}
procedure TFastImage.SetRctSrc;                                                                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  rct_src:=PtBounds(rct_dst.pt_rct.left  -bmp_ftimg_left,
                    rct_dst.pt_rct.top   -bmp_ftimg_top,
                    rct_dst.pt_rct.right -rct_dst.pt_rct.left,
                    rct_dst.pt_rct.bottom-rct_dst.pt_rct.top);
end; {$endregion} {$endregion}

{Init. Part-------------------------------------------} {$region -fold}
constructor TFastImage.Create  (constref bckgd_ptr:PInteger; constref bckgd_width,bckgd_height:integer; var rct_clp:TPtRect; constref bmp_src_rct:TPtRect; constref empty:integer=0);                                                                                                                                       {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  {Set Drawing Surface(Background)} {$region -fold}
  SetBckgd(bckgd_ptr,bckgd_width,bckgd_height); {$endregion}

  {Misc. Precalc. Settings--------} {$region -fold}
  CmpProcInit;
  FilProcInit;
  SdrProcInit;
  UlsProcInit;
  SdrTypeInit;
  ShaderInfo;
  SetPPInfo; {$endregion}

  {Set Drawing Surface(Background)} {$region -fold}
  {SetBckgd(bckgd_ptr,bckgd_width,bckgd_height);} {$endregion}

  {Set Clipping Rectangle---------} {$region -fold}
  SetClpRct(rct_clp); {$endregion}

end; {$endregion}
constructor TFastImage.Create  (constref bckgd_ptr:PInteger; constref bckgd_width,bckgd_height:integer; var rct_clp:TPtRect; constref bmp_src_rct:TPtRect; constref location:string=''; constref ImgLstGetBmp:TProc1=Nil; constref img_ind:integer=0; constref mask_tpl_calc:boolean=False; constref pic_src:TPicture=Nil); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  icn_src_pic       : TPicture=Nil;
  icn_src0          : TBitmap =Nil;
  icn_src           : TBitmap =Nil;
  icn_src_ptr       : PInteger=Nil;
  icn_src_pic_is_nil: boolean =True;
  icn_src0_is_nil   : boolean =True;
begin

  {Is Spite a Mask Template-------} {$region -fold}
  mask_template_calc:=mask_tpl_calc; {$endregion}

  {Set Drawing Surface(Background)} {$region -fold}
  SetBckgd(bckgd_ptr,bckgd_width,bckgd_height); {$endregion}

  {Misc. Precalc. Settings--------} {$region -fold}
  CmpProcInit;
  FilProcInit;
  SdrProcInit;
  UlsProcInit;
  SdrTypeInit;
  ShaderInfo;
  SetPPInfo; {$endregion}

  {Load Sprite--------------------} {$region -fold}
  if (pic_src<>Nil) then
    begin
      icn_src        :=CrtTBmpInst(pic_src.Bitmap,icn_src_ptr);
      icn_src0_is_nil:=False;
    end
  else
  if FileExists(location) then
    begin
      icn_src_pic       :=CrtTPicInstFromHDDSrc(location);
      icn_src           :=CrtTBmpInst(icn_src_pic.Bitmap,icn_src_ptr);
      icn_src_pic_is_nil:=False;
    end
  else
  if (ImgLstGetBmp<>Nil) then
    begin
      icn_src0       :=CrtTBmpInstFromImgLst(ImgLstGetBmp,img_ind);
      icn_src        :=CrtTBmpInst(icn_src0,icn_src_ptr);
      icn_src0_is_nil:=False;
    end;
  if (icn_src_ptr=Nil) then
    Exit; {$endregion}

  {Compress Sprite----------------} {$region -fold}
  SetValInfo(icn_src_ptr,icn_src_ptr,icn_src_ptr,icn_src.width,icn_src.height);
  bmp_src_rct_clp :=ClippedRct(PtBounds(0,0,icn_src.width,icn_src.height),bmp_src_rct);
  ImgToCImg;
  bmp_ftimg_width :=bmp_src_rct_clp.width;
  bmp_ftimg_height:=bmp_src_rct_clp.height; {$endregion}

  {Set Drawing Surface(Background)} {$region -fold}
  {SetBckgd(bckgd_ptr,bckgd_width,bckgd_height);} {$endregion}

  {Set Clipping Rectangle---------} {$region -fold}
  SetClpRct(rct_clp); {$endregion}

  {Clear Resources----------------} {$region -fold}
  DeleteObject(icn_src.Canvas.Handle);
  //DeleteObject(icn_src.Handle);
  //SrcDestroy  (icn_src);
  if (not icn_src_pic_is_nil) then
    SrcDestroy(icn_src_pic);
  if (not icn_src0_is_nil) then
    SrcDestroy(icn_src0);
  icn_src_ptr:=Nil; {$endregion}

end; {$endregion}
destructor  TFastImage.Destroy;                                                                                  {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  self.Free;
  inherited Destroy;
end; {$endregion}
procedure TFastImage.SetBckgd  (constref bckgd_ptr:PInteger; constref bckgd_width,bckgd_height:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  bmp_bckgd_ptr   :=bckgd_ptr   ;
  bmp_bckgd_width :=bckgd_width ;
  bmp_bckgd_height:=bckgd_height;
end; {$endregion}
procedure TFastImage.SetClpRct (constref rct_clp:TPtRect);                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  rct_clp_ptr:=@rct_clp;
end; {$endregion}
procedure TFastImage.SetValInfo(constref bmp_color_ptr_,bmp_alpha_ptr_,bmp_value_ptr_:PInteger; constref ftimg_width,ftimg_height:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  bmp_color_ptr          :=bmp_color_ptr_;
  bmp_alpha_ptr          :=bmp_alpha_ptr_;
  bmp_value_ptr          :=bmp_value_ptr_;
  bmp_ftimg_width        :=ftimg_width ;
  bmp_ftimg_height       :=ftimg_height;
  bmp_ftimg_width_origin :=ftimg_width ;
  bmp_ftimg_height_origin:=ftimg_height;
end; {$endregion}
procedure TFastImage.SetPPInfo (val:integer=$00434D3E);                                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with col_trans_var do
    begin
      // set monochrome          value;
      monochrome_val    :=val;
      // set red   channel       value;
      r_val             :=Red  (monochrome_val);
      // set green channel       value;
      g_val             :=Green(monochrome_val);
      // set blue  channel       value;
      b_val             :=Blue (monochrome_val);
      // set monochrome noise    value;
      monochrome_val    :=RGB  (b_val,g_val,r_val);
    end;
end; {$endregion}
procedure TFastImage.SrcDestroy(bmp_src:TPicture  );                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  bmp_src.Free;
end; {$endregion}
procedure TFastImage.SrcDestroy(bmp_src:TBitmap   );                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  bmp_src.Free;
end; {$endregion}
procedure TFastImage.SrcDestroy(arr_src:T1IntrArr );                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(arr_src,0);
  Finalize (arr_src);
end; {$endregion}
procedure TFastImage.SrcDestroy(arr_src:T1LWordArr);                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(arr_src,0);
  Finalize (arr_src);
end; {$endregion}
procedure TFastImage.SrcDestroy(arr_src:T1WordArr );                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(arr_src,0);
  Finalize (arr_src);
end; {$endregion}
procedure TFastImage.SrcDestroy(arr_src:T1ByteArr );                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(arr_src,0);
  Finalize (arr_src);
end; {$endregion} {$endregion}



(**************************** Fast Actor Container ****************************)

constructor TFastActorSet.Create(constref bckgd_ptr:PInteger; constref bckgd_width,bckgd_height:integer; var rct_clp:TPtRect; constref bmp_src_rct:TPtRect; constref location:string=''; constref ImgLstGetBmp:TProc1=Nil; constref d_icon_img_lst_ind:integer=0); {$region -fold}
begin

  {Default Icon---} {$region -fold}
  d_icon:=TFastImage.Create(bckgd_ptr,
                            bckgd_width,
                            bckgd_height,
                            rct_clp,
                            bmp_src_rct,
                            location,
                            ImgLstGetBmp,
                            d_icon_img_lst_ind); {$endregion}

  {Selection Field} {$region -fold}
  SetLength(sel_fld,bckgd_width*bckgd_height);
  PtrInit  (sel_fld_ptr,sel_fld); {$endregion}

end; {$endregion}
destructor TFastActorSet.Destroy; {$region -fold}
begin
  self.Free;
  inherited Destroy;
end; {$endregion}
procedure TFastActorSet.AddActor(x,y:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  Inc        (act_cnt);
  SetLength  (act_arr,
              act_cnt);
  SetLength  (act_pos_arr,
              act_cnt);
  act_arr    [act_cnt-1]  :=TFastActor.Create;
  act_pos_arr[act_cnt-1].x:=x-d_icon.bmp_ftimg_width >>1;
  act_pos_arr[act_cnt-1].y:=y-d_icon.bmp_ftimg_height>>1;

  with d_icon do
   begin
     SetRctPos(x,y);
     SdrProc[3];
   end;

end; {$endregion}



(********************************* Fast Actor *********************************)

constructor TFastActor.Create; {$region -fold}
begin
end; {$endregion}
destructor TFastActor.Destroy; {$region -fold}
begin
  self.Free;
  inherited Destroy;
end; {$endregion}



(***************************** Fast Line Routines *****************************)

{Init. Part--} {$region -fold}
constructor TFastSpLine.Create;                                                                                                                {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  LineSInit;
end; {$endregion}
destructor TFastSpLine.Destroy;                                                                                                                {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  self.Free;
  inherited Destroy;
end; {$endregion}
procedure TFastSpLine.GCCArrInit;                                                                                                      inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  gcd_arr:=Nil;
  SetLength  (gcd_arr,ln_arr_width*ln_arr_height);
  LinePrecalc(        ln_arr_width,ln_arr_height);
end; {$endregion}
procedure TFastSpLine.SplineInit(w,h:integer; ln_arr0_init:boolean; ln_arr1_init:boolean; ln_arr2_init:boolean; aa_buff_init:boolean); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  if ((w<=0) or (h<=0)) then
    Exit;
  ln_arr_width :=w;
  ln_arr_height:=h;
  if ln_arr0_init then
    begin
      SetLength(ln_arr0,w*h);
      ln_arr0_ptr:=Unaligned(@ln_arr0[0]);
    end;
  if ln_arr1_init then
    begin
      SetLength(ln_arr1,w*h);
      ln_arr1_ptr:=Unaligned(@ln_arr1[0]);
    end;
  if ln_arr2_init then
    begin
      SetLength(ln_arr2,w);
      for i:=0 to w-1 do
        SetLength(ln_arr2[i],h);
    end;
  if aa_buff_init then
    begin
      SetLength(aa_arr1,w*h);
      SetLength(aa_arr2,w*h);
    end;
end; {$endregion}
procedure TFastSpLine.SetBckgd(constref bmp_dst_ptr_:PInteger; constref bmp_dst_width_,bmp_dst_height_:integer);                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  bmp_dst_ptr   :=bmp_dst_ptr_;
  bmp_dst_width :=bmp_dst_width_;
  bmp_dst_height:=bmp_dst_height_;
end; {$endregion}
procedure TFastSpLine.MinimizeArrs(aa_buff_clear:boolean);                                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  MinimizeArr(ln_arr0);
  MinimizeArr(ln_arr1);
  MinimizeArr(ln_arr2);
  if (not aa_buff_clear) then
    Exit;
  MinimizeArr(aa_arr1);
  MinimizeArr(aa_arr2);
end; {$endregion} {$endregion}

{Line Drawing} {$region -fold}
// (Fast Line Grid Precalculation) Предпросчет сетки для быстрой линии:
{class} procedure TFastSpline.LinePrecalc(w,h:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  gcd_arr_ptr            :^TFastSpline.TGCDGrid;
  i,j,k,t1,t2,s1,s2,v1,v2: integer;

  {(Binary Stein Algorithm, which finds Greatest Common Divisor of two integer numbers) Бинарный алгоритм Стейна нахождения НСД двух натуральных чисел}
  function SteinGCD(a_,b_:integer): integer; {$region -fold}
  var
    k_: integer;
  begin
    k_:=1;
    while (a_<>0) and (a_<>0) do
      begin
        while (a_ and 1=0) and (b_ and 1=0) do
          begin
            a_:=a_>>1;
            b_:=b_>>1;
            k_:=k_<<1;
          end;
        while (a_ and 1=0) do
          a_:=a_>>1;
        while (b_ and 1=0) do
          b_:=b_>>1;
        if (a_>=b_) then
          a_:=a_-b_
        else
          b_:=b_-a_;
      end;
    Result:=b_*k_;
  end; {$endregion}

begin
  grid_pt_rad:=2;
  k:=2*grid_pt_rad;

  {Loop 1} {$region -fold}
  for j:=0 to h-1 do
    for i:=0 to w-1 do
      if (i>=j) then
        begin
          gcd_arr[i+j*w].a:=SteinGCD(i+1,j+1);
          if (gcd_arr[i+j*w].a<>1) then
            begin

              // Line1 Precalc.:
             {dx+1:=a*c;
              dy+1:=a;}
              if (gcd_arr[i+j*w].a=j+1) then {$region -fold}
                begin
                  gcd_arr[i+j*w].f_ln_kind:=1;
                  gcd_arr[i+j*w].b        :=0;
                  gcd_arr[i+j*w].c        :=Trunc((i+1)/(j+1));
                  Continue;
                end; {$endregion}

              // Line2 Precalc.:
             {dx+1:=c*(dy+1)+a:=a*b*c+a*(c+1):=a((b+1)*c+1);
              dy+1:=a*(b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-1) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) then {$region -fold}
                begin
                  gcd_arr[i+j*w].f_ln_kind:=2;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1));
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-1)/(gcd_arr[i+j*w].b+1));
                  Continue;
                end; {$endregion}

              // Line3 Precalc.:
             {dx+1:=c*(dy+1)+a*b:=a*c+a*b*(c+1):=a((b+1)*c+b);
              dy+1:=a*(b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-((j+1)/gcd_arr[i+j*w].a-1)) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) then {$region -fold}
                begin
                  gcd_arr[i+j*w].f_ln_kind:=3;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1));
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-gcd_arr[i+j*w].b)/(gcd_arr[i+j*w].b+1));
                  Continue;
                end; {$endregion}

              // Line4 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*b*c+a*(b+1)*(c+1):=a((2*b+1)*c+b+1);
              dy+1:=a*(2*b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-(((j+1)/gcd_arr[i+j*w].a-1)/2)-1) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) {$region -fold}
                 and
                 (Trunc((j+1)/gcd_arr[i+j*w].a) mod 2=1) then
                begin
                  gcd_arr[i+j*w].f_ln_kind:=4;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1)/2);
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-gcd_arr[i+j*w].b-1)/((2*gcd_arr[i+j*w].b)+1));
                  Continue;
                end; {$endregion}

              // Line5 Precalc.:
             {dx+1:=c*(dy+1)+a*b:=a*(b+1)*c+a*b*(c+1):=a((2*b+1)*c+b);
              dy+1:=a*(2*b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-(((j+1)/gcd_arr[i+j*w].a-1)/2)) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) {$region -fold}
                 and
                 (Trunc((j+1)/gcd_arr[i+j*w].a) mod 2=1) then
                begin
                  gcd_arr[i+j*w].f_ln_kind:=5;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1)/2);
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-gcd_arr[i+j*w].b)/((2*gcd_arr[i+j*w].b)+1));
                  Continue;
                end; {$endregion}

              // Line6 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*2*b*c+a*(b+1)*(c+1):=a((3*b+1)*c+b+1);
              dy+1:=a*(3*b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-(((j+1)/gcd_arr[i+j*w].a-1)/3)-1) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) {$region -fold}
                 and
                 (Trunc((j+1)/gcd_arr[i+j*w].a) mod 3=1) then
                begin
                  gcd_arr[i+j*w].f_ln_kind:=6;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1)/3);
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-gcd_arr[i+j*w].b-1)/((3*gcd_arr[i+j*w].b)+1));
                  Continue;
                end; {$endregion}

              // Line7 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*(2*b+1)*c+a*b*(c+1):=a((3*b+1)*c+b);
              dy+1:=a*(3*b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-(((j+1)/gcd_arr[i+j*w].a-1)/3)) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) {$region -fold}
                 and
                 (Trunc((j+1)/gcd_arr[i+j*w].a) mod 3=1) then
                begin
                  gcd_arr[i+j*w].f_ln_kind:=7;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1)/3);
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-gcd_arr[i+j*w].b)/((3*gcd_arr[i+j*w].b)+1));
                  Continue;
                end; {$endregion}

              // Line8 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*b*c+a*(2*b+1)*(c+1):=a((3*b+1)*c+2*b+1);
              dy+1:=a*(3*b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-2*(((j+1)/gcd_arr[i+j*w].a-1)/3)-1) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) {$region -fold}
                 and
                 (Trunc((j+1)/gcd_arr[i+j*w].a) mod 3=1) then
                begin
                  gcd_arr[i+j*w].f_ln_kind:=8;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1)/3);
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-2*gcd_arr[i+j*w].b-1)/((3*gcd_arr[i+j*w].b)+1));
                  Continue;
                end; {$endregion}

              // Line9 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*(b+1)*c+a*2*b*(c+1):=a((3*b+1)*c+2*b);
              dy+1:=a*(3*b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-2*(((j+1)/gcd_arr[i+j*w].a-1)/3)) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) {$region -fold}
                 and
                 (Trunc((j+1)/gcd_arr[i+j*w].a) mod 3=1) then
                begin
                  gcd_arr[i+j*w].f_ln_kind:=9;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1)/3);
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-2*gcd_arr[i+j*w].b)/((3*gcd_arr[i+j*w].b)+1));
                  Continue;
                end; {$endregion}

            end;
        end; {$endregion}

  {Loop 2} {$region -fold}
  for j:=0 to h-1 do
    for i:=0 to w-1 do
      if (i>j)                        then
        if (gcd_arr[i+j*w].f_ln_kind=0) then
          begin
            v1:=grid_pt_rad;
            v2:=grid_pt_rad;
            for t1:=0 to k do
              for t2:=0 to k do
                begin
                  s1:=t1-grid_pt_rad;
                  s2:=t2-grid_pt_rad;
                  if (i+s1>=0) and (i+s1<=w-1) and
                     (j+s2>=0) and (j+s2<=h-1) and
                     (gcd_arr[(i+s1)+(j+s2)*w].d<>-1) and
                     (gcd_arr[(i+s1)+(j+s2)*w].f_ln_kind<>0) and
                     (Max(Abs(s1),Abs(s2))<Max(Abs(v1),Abs(v2))) then
                    begin
                      v1:=s1;
                      v2:=s2;
                    end;
                end;
            if (i+v1>=0) and (i+v1<=w-1) and
               (j+v2>=0) and (j+v2<=h-1) then
              begin
                gcd_arr[i+j*w]  :=gcd_arr[(i+v1)+(j+v2)*w];
                gcd_arr[i+j*w].d:=-1;
              end;
          end; {$endregion}

  {Loop 3} {$region -fold}
  {2 alternative records of the same code block}
  {1.} {$region -fold}
  {for j:=0 to h-1 do
    for i:=0 to w-1 do
      if (i<j) then
        begin
          gcd_arr[i+j*w]          :=gcd_arr[j+i*w];
          gcd_arr[i+j*w].f_ln_kind:=gcd_arr[j+i*w].f_ln_kind+10;
        end;} {$endregion}
  {2.} {$region -fold}
  gcd_arr_ptr:=Unaligned(@gcd_arr[0]);
  for j:=0 to h-1 do
    for i:=0 to w-1 do
      begin
        if (i<j) then
          begin
            gcd_arr_ptr^          :=gcd_arr[j+i*w];
            gcd_arr_ptr^.f_ln_kind:=gcd_arr[j+i*w].f_ln_kind+10;
          end;
        Inc(gcd_arr_ptr);
      end; {$endregion} {$endregion}

end; {$endregion}

{Fast Line Solid (Width - 1 pixel)}

// (Solid Line Initialization) Инициализация сплошной линии:
procedure TFastSpline.LineSInit; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  {Right Bottom Corner}
  {0°..-45°}
  LineProc[00]:=@LineS00;
  LineProc[01]:=@LineS01RBC;
  LineProc[02]:=@LineS02RBC;
  LineProc[03]:=@LineS03RBC;
  LineProc[04]:=@LineS04RBC;
  LineProc[05]:=@LineS05RBC;
  LineProc[06]:=@LineS06RBC;
  LineProc[07]:=@LineS07RBC;
  LineProc[08]:=@LineS08RBC;
  LineProc[09]:=@LineS09RBC;
  {-45°..-90°}
  LineProc[10]:=@LineS10;
  LineProc[11]:=@LineS11RBC;
  LineProc[12]:=@LineS12RBC;
  LineProc[13]:=@LineS13RBC;
  LineProc[14]:=@LineS14RBC;
  LineProc[15]:=@LineS15RBC;
  LineProc[16]:=@LineS16RBC;
  LineProc[17]:=@LineS17RBC;
  LineProc[18]:=@LineS18RBC;
  LineProc[19]:=@LineS19RBC;

  {Left Bottom Corner}
  {-135°..-180°}
  LineProc[20]:=@LineS20;
  LineProc[21]:=@LineS21LBC;
  LineProc[22]:=@LineS22LBC;
  LineProc[23]:=@LineS23LBC;
  LineProc[24]:=@LineS24LBC;
  LineProc[25]:=@LineS25LBC;
  LineProc[26]:=@LineS26LBC;
  LineProc[27]:=@LineS27LBC;
  LineProc[28]:=@LineS28LBC;
  LineProc[29]:=@LineS29LBC;
  {-90°..-135°}
  LineProc[30]:=@LineS30;
  LineProc[31]:=@LineS31LBC;
  LineProc[32]:=@LineS32LBC;
  LineProc[33]:=@LineS33LBC;
  LineProc[34]:=@LineS34LBC;
  LineProc[35]:=@LineS35LBC;
  LineProc[36]:=@LineS36LBC;
  LineProc[37]:=@LineS37LBC;
  LineProc[38]:=@LineS38LBC;
  LineProc[39]:=@LineS39LBC;

end; {$endregion}

{THE EXTREMELY FAST LINE ALGORITHM Variation E (Addition Fixed Point PreCalc) by Po-Han Lin on C++} {$region -fold}
(*
void myLine(SURFACE* surface, int x, int y, int x2, int y2) {
  bool yLonger=false;
  int shortLen=y2-y;
  int longLen=x2-x;
  if (abs(shortLen)>abs(longLen)) {
  	int swap=shortLen;
  	shortLen=longLen;
  	longLen=swap;
  	yLonger=true;
  }
  int decInc;
  if (longLen==0) decInc=0;
  else decInc = (shortLen << 16) / longLen;

  if (yLonger) {
  	if (longLen>0) {
  		longLen+=y;
  		for (int j=0x8000+(x<<16);y<=longLen;++y) {
  			myPixel(surface,j >> 16,y);
  			j+=decInc;
  		}
  		return;
  	}
  	longLen+=y;
  	for (int j=0x8000+(x<<16);y>=longLen;--y) {
  		myPixel(surface,j >> 16,y);
  		j-=decInc;
  	}
  	return;
  }

  if (longLen>0) {
	longLen+=x;
	for (int j=0x8000+(y<<16);x<=longLen;++x) {
		myPixel(surface,x,j >> 16);
		j+=decInc;
	}
	return;
  }
  longLen+=x;
  for (int j=0x8000+(y<<16);x>=longLen;--x) {
	myPixel(surface,x,j >> 16);
	j-=decInc;
  }

}
*) {$endregion}

// (Move Points) Перемещение точек:
procedure TFastSpline.LinePHL00; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p0_shift                        : integer;
  i,short_len,long_len,swp,dec_inc: integer;
  yLonger                         : boolean;
begin

  yLonger  :=False;
  short_len:=p1-p0;
  long_len :=r1-r0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
    end;

  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);

  if (yLonger) then
    begin
      if (long_len>0) then
        begin
	  long_len+=p0;
          i:=$8000+(r0<<16);
          p0_shift:=p0*ln_arr_width;
          while (p0<=long_len) do
            begin
              ln_arr0[(i>>16)+p0_shift{p0*ln_arr_width}]:=1;
	      i+=dec_inc;
              Inc(p0);
              Inc(p0_shift,ln_arr_width);
            end;
          Exit;
        end;
      long_len+=p0;
      i:=$8000+(r0<<16);
      p0_shift:=p0*ln_arr_width;
      while (p0>=long_len) do
        begin
          ln_arr0[(i>>16)+p0_shift{p0*ln_arr_width}]:=1;
          i-=dec_inc;
          Dec(p0);
          Dec(p0_shift,ln_arr_width);
        end;
      Exit;
    end;

  if (long_len>0) then
    begin
      long_len+=r0;
      i:=$8000+(p0<<16);
      while (r0<=long_len) do
        begin
          ln_arr0[r0+(i>>16)*ln_arr_width]:=1;
          i+=dec_inc;
          Inc(r0);
        end;
      Exit;
    end;

  long_len+=r0;
  i:=$8000+(p0<<16);
  while (r0>=long_len) do
    begin
      ln_arr0[r0+(i>>16)*ln_arr_width]:=1;
      i-=dec_inc;
      Dec(r0);
    end;

end; {$endregion}
procedure TFastSpline.LinePHL01; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p0_shift                        : integer;
  i,short_len,long_len,swp,dec_inc: integer;
  clip_shift                      : integer=0;
  yLonger                         : boolean;
begin

  yLonger  :=False;
  short_len:=p1-p0;
  long_len :=r1-r0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
      if (pix_cnt>short_len) then
        Exit;
    end
  else
    if (pix_cnt>long_len) then
      Exit;

  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);

  if (yLonger) then
    begin
      if (long_len>0) then
        begin
	  long_len+=p0;
          i:=$8000+(r0<<16);
          p0_shift:=p0*ln_arr_width;
          while (p0<=long_len) or (clip_shift=pix_cnt) do
            begin
              Inc(clip_shift);
              ln_arr0[(i>>16)+p0_shift{p0*ln_arr_width}]:=1;
	      i+=dec_inc;
              Inc(p0);
              Inc(p0_shift,ln_arr_width);
            end;
          Exit;
        end;
      long_len+=p0;
      i:=$8000+(r0<<16);
      p0_shift:=p0*ln_arr_width;
      while (p0>=long_len) or (clip_shift=pix_cnt) do
        begin
          Inc(clip_shift);
          ln_arr0[(i>>16)+p0_shift{p0*ln_arr_width}]:=1;
          i-=dec_inc;
          Dec(p0);
          Dec(p0_shift,ln_arr_width);
        end;
      Exit;
    end;

  if (long_len>0) then
    begin

      long_len+=r0;
      i:=$8000+(p0<<16);
      while (r0<=long_len) or (clip_shift=pix_cnt) do
        begin
          Inc(clip_shift);
          ln_arr0[r0+(i>>16)*ln_arr_width]:=1;
          i+=dec_inc;
          Inc(r0);
        end;
      Exit;
    end;

  long_len+=r0;
  i:=$8000+(p0<<16);
  while (r0>=long_len) or (clip_shift=pix_cnt) do
    begin
      Inc(clip_shift);
      ln_arr0[r0+(i>>16)*ln_arr_width]:=1;
      i-=dec_inc;
      Dec(r0);
    end;

end; {$endregion}
// (Select Points) Выделение точек:
procedure TFastSpline.LinePHL10; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_arr1_ptr2                    : PInteger;
  i,short_len,long_len,swp,dec_inc: integer;
  yLonger                         : boolean;
begin

  yLonger  :=False;
  short_len:=p1-p0;
  long_len :=r1-r0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
    end;

  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);

  if (yLonger) then
    begin
      if (long_len>0) then
        begin
	  long_len+=p0;
          i:=$8000+(r0<<16);
          ln_arr1_ptr2:=ln_arr1_ptr+p0*ln_arr_width;
          Prefetch(ln_arr1_ptr2);
          while (p0<=long_len) do
            begin
              ({ln_arr1_ptr+}(i>>16)+ln_arr1_ptr2{p0*ln_arr_width})^-=1;
	      i+=dec_inc;
              Inc(p0);
              Inc(ln_arr1_ptr2,ln_arr_width);
            end;
          Exit;
        end;
      long_len+=p0;
      i:=$8000+(r0<<16);
      ln_arr1_ptr2:=ln_arr1_ptr+p0*ln_arr_width;
      Prefetch(ln_arr1_ptr2);
      while (p0>=long_len) do
        begin
          ({ln_arr1_ptr+}(i>>16)+ln_arr1_ptr2{p0*ln_arr_width})^-=1;
          i-=dec_inc;
          Dec(p0);
          Dec(ln_arr1_ptr2,ln_arr_width);
        end;
      Exit;
    end;

  if (long_len>0) then
    begin
      long_len+=r0;
      i:=$8000+(p0<<16);
      Prefetch(ln_arr1_ptr);
      while (r0<=long_len) do
        begin
          (ln_arr1_ptr+r0+(i>>16)*ln_arr_width)^-=1;
          i+=dec_inc;
          Inc(r0);
        end;
      Exit;
    end;

  long_len+=r0;
  i:=$8000+(p0<<16);
  Prefetch(ln_arr1_ptr);
  while (r0>=long_len) do
    begin
      (ln_arr1_ptr+r0+(i>>16)*ln_arr_width)^-=1;
      i-=dec_inc;
      Dec(r0);
    end;

end; {$endregion}
procedure TFastSpline.LinePHL11; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_arr1_ptr2                    : PInteger;
  i,short_len,long_len,swp,dec_inc: integer;
  clip_shift                      : integer=0;
  yLonger                         : boolean;
begin

  yLonger  :=False;
  short_len:=p1-p0;
  long_len :=r1-r0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
      if (pix_cnt>short_len) then
        Exit;
    end
  else
    if (pix_cnt>long_len) then
      Exit;

  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);

  if (yLonger) then
    begin
      if (long_len>0) then
        begin
	  long_len+=p0;
          i:=$8000+(r0<<16);
          ln_arr1_ptr2:=ln_arr1_ptr+p0*ln_arr_width;
          Prefetch(ln_arr1_ptr2);
          while (p0<=long_len) or (clip_shift=pix_cnt) do
            begin
              Inc(clip_shift);
              ({ln_arr1_ptr+}(i>>16)+ln_arr1_ptr2{p0*ln_arr_width})^-=1;
	      i+=dec_inc;
              Inc(p0);
              Inc(ln_arr1_ptr2,ln_arr_width);
            end;
          Exit;
        end;
      long_len+=p0;
      i:=$8000+(r0<<16);
      ln_arr1_ptr2:=ln_arr1_ptr+p0*ln_arr_width;
      Prefetch(ln_arr1_ptr2);
      while (p0>=long_len) or (clip_shift=pix_cnt) do
        begin
          Inc(clip_shift);
          ({ln_arr1_ptr+}(i>>16)+ln_arr1_ptr2{p0*ln_arr_width})^-=1;
          i-=dec_inc;
          Dec(p0);
          Dec(ln_arr1_ptr2,ln_arr_width);
        end;
      Exit;
    end;

  if (long_len>0) then
    begin
      long_len+=r0;
      i:=$8000+(p0<<16);
      Prefetch(ln_arr1_ptr);
      while (r0<=long_len) or (clip_shift=pix_cnt) do
        begin
          Inc(clip_shift);
          (ln_arr1_ptr+r0+(i>>16)*ln_arr_width)^-=1;
          i+=dec_inc;
          Inc(r0);
        end;
      Exit;
    end;

  long_len+=r0;
  i:=$8000+(p0<<16);
  Prefetch(ln_arr1_ptr);
  while (r0>=long_len) or (clip_shift=pix_cnt) do
    begin
      Inc(clip_shift);
      (ln_arr1_ptr+r0+(i>>16)*ln_arr_width)^-=1;
      i-=dec_inc;
      Dec(r0);
    end;

end; {$endregion}

// (Unselect Points) Снятие выделения точек:
procedure TFastSpline.LinePHL20; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_arr1_ptr2                    : PInteger;
  i,short_len,long_len,swp,dec_inc: integer;
  yLonger                         : boolean;
begin

  yLonger  :=False;
  short_len:=p1-p0;
  long_len :=r1-r0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
    end;

  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);

  if (yLonger) then
    begin
      if (long_len>0) then
        begin
	  long_len+=p0;
          i:=$8000+(r0<<16);
          ln_arr1_ptr2:=ln_arr1_ptr+p0*ln_arr_width;
          Prefetch(ln_arr1_ptr2);
          while (p0<=long_len) do
            begin
              ({ln_arr1_ptr+}(i>>16)+ln_arr1_ptr2{p0*ln_arr_width})^+=1;
	      i+=dec_inc;
              Inc(p0);
              Inc(ln_arr1_ptr2,ln_arr_width);
            end;
          Exit;
        end;
      long_len+=p0;
      i:=$8000+(r0<<16);
      ln_arr1_ptr2:=ln_arr1_ptr+p0*ln_arr_width;
      Prefetch(ln_arr1_ptr2);
      while (p0>=long_len) do
        begin
          ({ln_arr1_ptr+}(i>>16)+ln_arr1_ptr2{p0*ln_arr_width})^+=1;
          i-=dec_inc;
          Dec(p0);
          Dec(ln_arr1_ptr2,ln_arr_width);
        end;
      Exit;
    end;

  if (long_len>0) then
    begin
      long_len+=r0;
      i:=$8000+(p0<<16);
      Prefetch(ln_arr1_ptr);
      while (r0<=long_len) do
        begin
          (ln_arr1_ptr+r0+(i>>16)*ln_arr_width)^+=1;
          i+=dec_inc;
          Inc(r0);
        end;
      Exit;
    end;

  long_len+=r0;
  i:=$8000+(p0<<16);
  Prefetch(ln_arr1_ptr);
  while (r0>=long_len) do
    begin
      (ln_arr1_ptr+r0+(i>>16)*ln_arr_width)^+=1;
      i-=dec_inc;
      Dec(r0);
    end;

end; {$endregion}
procedure TFastSpline.LinePHL21; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_arr1_ptr2                    : PInteger;
  i,short_len,long_len,swp,dec_inc: integer;
  clip_shift                      : integer=0;
  yLonger                         : boolean;
begin

  yLonger  :=False;
  short_len:=p1-p0;
  long_len :=r1-r0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
      if (pix_cnt>short_len) then
        Exit;
    end
  else
    if (pix_cnt>long_len) then
      Exit;

  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);

  if (yLonger) then
    begin
      if (long_len>0) then
        begin
	  long_len+=p0;
          i:=$8000+(r0<<16);
          ln_arr1_ptr2:=ln_arr1_ptr+p0*ln_arr_width;
          Prefetch(ln_arr1_ptr2);
          while (p0<=long_len) or (clip_shift=pix_cnt) do
            begin
              Inc(clip_shift);
              ({ln_arr1_ptr+}(i>>16)+ln_arr1_ptr2{p0*ln_arr_width})^+=1;
	      i+=dec_inc;
              Inc(p0);
              Inc(ln_arr1_ptr2,ln_arr_width);
            end;
          Exit;
        end;
      long_len+=p0;
      i:=$8000+(r0<<16);
      ln_arr1_ptr2:=ln_arr1_ptr+p0*ln_arr_width;
      Prefetch(ln_arr1_ptr2);
      while (p0>=long_len) or (clip_shift=pix_cnt) do
        begin
          Inc(clip_shift);
          ({ln_arr1_ptr+}(i>>16)+ln_arr1_ptr2{p0*ln_arr_width})^+=1;
          i-=dec_inc;
          Dec(p0);
          Dec(ln_arr1_ptr2,ln_arr_width);
        end;
      Exit;
    end;

  if (long_len>0) then
    begin
      long_len+=r0;
      i:=$8000+(p0<<16);
      Prefetch(ln_arr1_ptr);
      while (r0<=long_len) or (clip_shift=pix_cnt) do
        begin
          Inc(clip_shift);
          (ln_arr1_ptr+r0+(i>>16)*ln_arr_width)^+=1;
          i+=dec_inc;
          Inc(r0);
        end;
      Exit;
    end;

  long_len+=r0;
  i:=$8000+(p0<<16);
  Prefetch(ln_arr1_ptr);
  while (r0>=long_len) or (clip_shift=pix_cnt) do
    begin
      Inc(clip_shift);
      (ln_arr1_ptr+r0+(i>>16)*ln_arr_width)^+=1;
      i-=dec_inc;
      Dec(r0);
    end;

end; {$endregion}

// (Direct Pixel Write) Непосредственная запись в битовую карту:
procedure TFastSpline.LinePHL30; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  bmp_dst_ptr2                    : PInteger;
  i,short_len,long_len,swp,dec_inc: integer;
  yLonger                         : boolean;
begin

  yLonger  :=False;
  short_len:=p1-p0;
  long_len :=r1-r0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
    end;

  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);

  if (yLonger) then
    begin
      if (long_len>0) then
        begin
	  long_len+=p0;
          i:=$8000+(r0<<16);
          bmp_dst_ptr2:=bmp_dst_ptr+p0*bmp_dst_width;
          Prefetch(bmp_dst_ptr2);
          while (p0<=long_len) do
            begin
              ({bmp_dst_ptr+}(i>>16)+bmp_dst_ptr2{p0*bmp_dst_width})^:=local_prop.eds_col_inv;
	      i+=dec_inc;
              Inc(p0);
              Inc(bmp_dst_ptr2,bmp_dst_width);
            end;
          Exit;
        end;
      long_len+=p0;
      i:=$8000+(r0<<16);
      bmp_dst_ptr2:=bmp_dst_ptr+p0*bmp_dst_width;
      Prefetch(bmp_dst_ptr2);
      while (p0>=long_len) do
        begin
          ({bmp_dst_ptr+}(i>>16)+bmp_dst_ptr2{p0*bmp_dst_width})^:=local_prop.eds_col_inv;
          i-=dec_inc;
          Dec(p0);
          Dec(bmp_dst_ptr2,bmp_dst_width);
        end;
      Exit;
    end;

  if (long_len>0) then
    begin
      long_len+=r0;
      i:=$8000+(p0<<16);
      Prefetch(bmp_dst_ptr);
      while (r0<=long_len) do
        begin
          (bmp_dst_ptr+r0+(i>>16)*bmp_dst_width)^:=local_prop.eds_col_inv;
          i+=dec_inc;
          Inc(r0);
        end;
      Exit;
    end;

  long_len+=r0;
  i:=$8000+(p0<<16);
  Prefetch(bmp_dst_ptr);
  while (r0>=long_len) do
    begin
      (bmp_dst_ptr+r0+(i>>16)*bmp_dst_width)^:=local_prop.eds_col_inv;
      i-=dec_inc;
      Dec(r0);
    end;

end; {$endregion}
procedure TFastSpline.LinePHL31; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  bmp_dst_ptr2                    : PInteger;
  i,short_len,long_len,swp,dec_inc: integer;
  clip_shift                      : integer=0;
  yLonger                         : boolean;
begin

  yLonger  :=False;
  short_len:=p1-p0;
  long_len :=r1-r0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
      if (pix_cnt>short_len) then
        Exit;
    end
  else
    if (pix_cnt>long_len) then
      Exit;

  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);

  if (yLonger) then
    begin
      if (long_len>0) then
        begin
	  long_len+=p0;
          i:=$8000+(r0<<16);
          bmp_dst_ptr2:=bmp_dst_ptr+p0*bmp_dst_width;
          Prefetch(bmp_dst_ptr2);
          while (p0<=long_len) or (clip_shift=pix_cnt) do
            begin
              Inc(clip_shift);
              ({bmp_dst_ptr+}(i>>16)+bmp_dst_ptr2{p0*bmp_dst_width})^:=local_prop.eds_col_inv;
	      i+=dec_inc;
              Inc(p0);
              Inc(bmp_dst_ptr2,bmp_dst_width);
            end;
          Exit;
        end;
      long_len+=p0;
      i:=$8000+(r0<<16);
      bmp_dst_ptr2:=bmp_dst_ptr+p0*bmp_dst_width;
      Prefetch(bmp_dst_ptr2);
      while (p0>=long_len) or (clip_shift=pix_cnt) do
        begin
          Inc(clip_shift);
          ({bmp_dst_ptr+}(i>>16)+bmp_dst_ptr2{p0*bmp_dst_width})^:=local_prop.eds_col_inv;
          i-=dec_inc;
          Dec(p0);
          Dec(bmp_dst_ptr2,bmp_dst_width);
        end;
      Exit;
    end;

  if (long_len>0) then
    begin
      long_len+=r0;
      i:=$8000+(p0<<16);
      Prefetch(bmp_dst_ptr);
      while (r0<=long_len) or (clip_shift=pix_cnt) do
        begin
          Inc(clip_shift);
          (bmp_dst_ptr+r0+(i>>16)*bmp_dst_width)^:=local_prop.eds_col_inv;
          i+=dec_inc;
          Inc(r0);
        end;
      Exit;
    end;

  long_len+=r0;
  i:=$8000+(p0<<16);
  Prefetch(bmp_dst_ptr);
  while (r0>=long_len) or (clip_shift=pix_cnt) do
    begin
      Inc(clip_shift);
      (bmp_dst_ptr+r0+(i>>16)*bmp_dst_width)^:=local_prop.eds_col_inv;
      i-=dec_inc;
      Dec(r0);
    end;

end; {$endregion}

{Right Bottom Corner}

{0°..-45°}
// 0: out of grid
procedure TFastSpline.LineS00;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

end; {$endregion}
// 1: (c_n)
procedure TFastSpline.LineS01RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
 {dx+1:=a*c;
  dy+1:=a;}
 {y0-=y1;    // меняем местами координаты по оси y начала и конца линии
  y1+=y0;    // ...
  y0:=y1-y0; // ...
  dy:=-dy;}
  for i:=0 to a-2 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 2: (c_n,c+1)
procedure TFastSpline.LineS02RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a:=a*b*c+a*(c+1):=a((b+1)*c+1);
  dy+1:=a*(b+1);
  Если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1), что легко доказать.
  "Пусть a<>НСД(dx+1,dy+1), тогда dy+1:=a*r*v1, dx+1:=a*r*v2=a*(r*v1*c+1), что невозможно."}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 3: ((c+1)_n,c)
procedure TFastSpline.LineS03RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*b:=a*c+a*b*(c+1):=a((b+1)*c+b);
  dy+1:=a*(b+1);
  Очевидно, что если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1)}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 4: ((c,c+1)_n,c+1)
procedure TFastSpline.LineS04RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*(b+1):=a*b*c+a*(b+1)*(c+1):=a((2*b+1)*c+b+1);
  dy+1:=a*(2*b+1);
  Очевидно, что если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1)}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 5: ((c,c+1)_n,c)
procedure TFastSpline.LineS05RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*b:=a*(b+1)*c+a*b*(c+1):=a((2*b+1)*c+b);
  dy+1:=a*(2*b+1);
  Очевидно, что если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1)}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 6: ((c,c+1,c)_n,c+1)
procedure TFastSpline.LineS06RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*(b+1):=a*2*b*c+a*(b+1)*(c+1):=a((3*b+1)*c+b+1);
  dy+1:=a*(3*b+1);
  Очевидно, что если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1)}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 7: ((c,c+1,c)_n,c)
procedure TFastSpline.LineS07RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*(b+1):=a*(2*b+1)*c+a*b*(c+1):=a((3*b+1)*c+b);
  dy+1:=a*(3*b+1);
  Очевидно, что если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1)}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 8: ((c,c+1,c+1)_n,c+1)
procedure TFastSpline.LineS08RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*(b+1):=a*b*c+a*(2*b+1)*(c+1):=a((3*b+1)*c+2*b+1);
  dy+1:=a*(3*b+1);
  Очевидно, что если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1)}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 9: ((c+1,c,c+1)_n,c)
procedure TFastSpline.LineS09RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*(b+1):=a*(b+1)*c+a*2*b*(c+1):=a((3*b+1)*c+2*b);
  dy+1:=a*(3*b+1);
  Очевидно, что если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1)}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
{-45°..-90°}
// 10: out of grid
procedure TFastSpline.LineS10;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

end; {$endregion}
// 11: (c_n)
procedure TFastSpline.LineS11RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to a-1 do
    FillByte(ln_arr2[p0+i+g,r0+i*c-g],c,1);
end; {$endregion}
// 12: (c_n,c+1)
procedure TFastSpline.LineS12RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        FillByte(ln_arr2[p0+i*(b+1)+j+g,r0+i*((b+1)*c+1)+c*j-g],c,1);
      FillByte(ln_arr2[p0+i*(b+1)+b+g,r0+i*((b+1)*c+1)+c*b-g],c+1,1);
    end;
end; {$endregion}
// 13: ((c+1)_n,c)
procedure TFastSpline.LineS13RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        FillByte(ln_arr2[p0+i*(b+1)+j+g,r0+i*((b+1)*(c+1)-1)+(c+1)*j-g],c+1,1);
      FillByte(ln_arr2[p0+i*(b+1)+b+g,r0+i*((b+1)*(c+1)-1)+(c+1)*b-g],c,1);
    end;
end; {$endregion}
// 14: ((c,c+1)_n,c+1)
procedure TFastSpline.LineS14RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+(2*b+1)*i+2*j  +g,r0+(b*(2*c+1)+c+1)*i+(2*c+1)*j  -g],c,1);
          FillByte(ln_arr2[p0+(2*b+1)*i+2*j+1+g,r0+(b*(2*c+1)+c+1)*i+(2*c+1)*j+c-g],c+1,1);
        end;
      FillByte(ln_arr2[p0+(2*b+1)*i+2*b+g,r0+(b*(2*c+1)+c+1)*i+(2*c+1)*b-g],c+1,1);
    end;
end; {$endregion}
// 15: ((c,c+1)_n,c)
procedure TFastSpline.LineS15RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+(2*b+1)*i+2*j  +g,r0+(b*(2*c+1)+c)*i+(2*c+1)*j  -g],c,1);
          FillByte(ln_arr2[p0+(2*b+1)*i+2*j+1+g,r0+(b*(2*c+1)+c)*i+(2*c+1)*j+c-g],c+1,1);
        end;
      FillByte(ln_arr2[p0+(2*b+1)*i+2*b+g,r0+(b*(2*c+1)+c)*i+(2*c+1)*b-g],c,1);
    end;
end; {$endregion}
// 16: ((c,c+1,c)_n,c+1)
procedure TFastSpline.LineS16RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j  +g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*j      -g],c  ,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+1+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*j+c    -g],c+1,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+2+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*j+2*c+1-g],c  ,1);
        end;
      FillByte(ln_arr2[p0+(3*b+1)*i+3*b+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*b-g],c+1,1);
    end;
end; {$endregion}
// 17: ((c,c+1,c)_n,c)
procedure TFastSpline.LineS17RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j  +g,r0+(b*(3*c+1)+c)*i+(3*c+1)*j      -g],c  ,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+1+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*j+c    -g],c+1,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+2+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*j+2*c+1-g],c  ,1);
        end;
      FillByte(ln_arr2[p0+(3*b+1)*i+3*b+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*b-g],c,1);
    end;
end; {$endregion}
// 18: ((c,c+1,c+1)_n,c+1)
procedure TFastSpline.LineS18RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j  +g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*j      -g],c  ,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+1+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*j+c    -g],c+1,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+2+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*j+2*c+1-g],c+1,1);
        end;
      FillByte(ln_arr2[p0+(3*b+1)*i+3*b+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*b-g],c+1,1);
    end;
end; {$endregion}
// 19: ((c+1,c,c+1)_n,c)
procedure TFastSpline.LineS19RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j  +g,r0+(b*(3*c+2)+c)*i+(3*c+2)*j      -g],c+1,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+1+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*j+c+1  -g],c,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+2+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*j+2*c+1-g],c+1,1);
        end;
      FillByte(ln_arr2[p0+(3*b+1)*i+3*b+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*b-g],c,1);
    end;
end; {$endregion}

{Left Bottom Corner}

{-135°..-180°}
// 20: out of grid
procedure TFastSpline.LineS20;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

end; {$endregion}
// 21: (c_n)
procedure TFastSpline.LineS21LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 22: (c_n,c+1)
procedure TFastSpline.LineS22LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-2 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-2 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 23: ((c+1)_n,c)
procedure TFastSpline.LineS23LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-2 do
        begin
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  for j:=0 to b-2 do
    begin
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m1);
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 24: ((c,c+1)_n,c+1)
procedure TFastSpline.LineS24LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-2 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-2 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 25: ((c,c+1)_n,c)
procedure TFastSpline.LineS25LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 26: ((c,c+1,c)_n,c+1)
procedure TFastSpline.LineS26LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-2 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-2 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m1);
  FillByte(ln_arr0_ptr^,c,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 27: ((c,c+1,c)_n,c)
procedure TFastSpline.LineS27LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 28: ((c,c+1,c+1)_n,c+1)
procedure TFastSpline.LineS28LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-2 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-2 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 29: ((c+1,c,c+1)_n,c)
procedure TFastSpline.LineS29LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-2 do
        begin
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  for j:=0 to b-2 do
    begin
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m1);
  FillByte(ln_arr0_ptr^,c,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m1);
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
{-90°..-135°}
// 30: out of grid
procedure TFastSpline.LineS30;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

end; {$endregion}
// 31: (c_n)
procedure TFastSpline.LineS31LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to a-1 do
    FillByte(ln_arr2[p0-i+g,r0+i*c-g],c,1);
end; {$endregion}
// 32: (c_n,c+1)
procedure TFastSpline.LineS32LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        FillByte(ln_arr2[p0-i*(b+1)-j+g,r0+i*((b+1)*c+1)+c*j-g],c,1);
      FillByte(ln_arr2[p0-i*(b+1)-b+g,r0+i*((b+1)*c+1)+c*b-g],c+1,1);
    end;
end; {$endregion}
// 33: ((c+1)_n,c)
procedure TFastSpline.LineS33LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        FillByte(ln_arr2[p0-i*(b+1)-j+g,r0+i*((b+1)*(c+1)-1)+(c+1)*j-g],c+1,1);
      FillByte(ln_arr2[p0-i*(b+1)-b+g,r0+i*((b+1)*(c+1)-1)+(c+1)*b-g],c,1);
    end;
end; {$endregion}
// 34: ((c,c+1)_n,c+1)
procedure TFastSpline.LineS34LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0-(2*b+1)*i-2*j  +g,r0+(b*(2*c+1)+c+1)*i+(2*c+1)*j  -g],c  ,1);
          FillByte(ln_arr2[p0-(2*b+1)*i-2*j-1+g,r0+(b*(2*c+1)+c+1)*i+(2*c+1)*j+c-g],c+1,1);
        end;
      FillByte(ln_arr2[p0-(2*b+1)*i-2*b+g,r0+(b*(2*c+1)+c+1)*i+(2*c+1)*b-g],c+1,1);
    end;
end; {$endregion}
// 35: ((c,c+1)_n,c)
procedure TFastSpline.LineS35LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0-(2*b+1)*i-2*j  +g,r0+(b*(2*c+1)+c)*i+(2*c+1)*j  -g],c  ,1);
          FillByte(ln_arr2[p0-(2*b+1)*i-2*j-1+g,r0+(b*(2*c+1)+c)*i+(2*c+1)*j+c-g],c+1,1);
        end;
      FillByte(ln_arr2[p0-(2*b+1)*i-2*b+g,r0+(b*(2*c+1)+c)*i+(2*c+1)*b-g],c,1);
    end;
end; {$endregion}
// 36: ((c,c+1,c)_n,c+1)
procedure TFastSpline.LineS36LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j  +g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*j      -g],c  ,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-1+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*j+c    -g],c+1,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-2+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*j+2*c+1-g],c  ,1);
        end;
      FillByte(ln_arr2[p0-(3*b+1)*i-3*b+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*b-g],c+1,1);
    end;
end; {$endregion}
// 37: ((c,c+1,c)_n,c)
procedure TFastSpline.LineS37LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j  +g,r0+(b*(3*c+1)+c)*i+(3*c+1)*j      -g],c  ,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-1+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*j+c    -g],c+1,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-2+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*j+2*c+1-g],c  ,1);
        end;
      FillByte(ln_arr2[p0-(3*b+1)*i-3*b+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*b-g],c,1);
    end;
end; {$endregion}
// 38: ((c,c+1,c+1)_n,c+1)
procedure TFastSpline.LineS38LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j  +g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*j      -g],c  ,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-1+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*j+c    -g],c+1,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-2+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*j+2*c+1-g],c+1,1);
        end;
      FillByte(ln_arr2[p0-(3*b+1)*i-3*b+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*b-g],c+1,1);
    end;
end; {$endregion}
// 39: ((c+1,c,c+1)_n,c)
procedure TFastSpline.LineS39LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j  +g,r0+(b*(3*c+2)+c)*i+(3*c+2)*j      -g],c+1,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-1+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*j+c+1  -g],c  ,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-2+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*j+2*c+1-g],c+1,1);
        end;
      FillByte(ln_arr2[p0-(3*b+1)*i-3*b+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*b-g],c,1);
    end;
end; {$endregion}

// (Solid Line Drawing) Рисование сплошной линии:
procedure TFastSpline.LineSMN(constref x0,y0,x1,y1:integer);                                                         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {адрес n-ого элемента
   статического массива array[min..max] of type
   вычисляется по формуле array_addr+(n-min)*sizeof(type);
   адрес n-ого элемента
   динамического массива array of type
   вычисляется по формуле array_addr+n*sizeof(type);}
  dx:=x1-x0;
  dy:=y1-y0;
  if (Abs(dy)<<9<Abs(dx)*229) then
    begin
      if (dy>0) then {$region -fold}
        begin
          ln_kind_ptr:=Unaligned(@gcd_arr[Abs(dx)+dy*ln_arr_width].f_ln_kind);
          if (ln_kind_ptr^=0) or (ln_kind_ptr^=10) then
            begin
              if (dx<0) then
                begin
                  r0:=x1;
                  p0:=y1;
                  r1:=x0;
                  p1:=y0;
                end
              else
                begin
                  r0:=x0;
                  p0:=y0;
                  r1:=x1;
                  p1:=y1;
                end;
              LinePHL00;
              Exit;
            end
          else
            begin
              ln_arr0_ptr:=Unaligned(@ln_arr0[x0+y0*ln_arr_width]);
              a:=(ln_kind_ptr+1)^;
              b:=(ln_kind_ptr+2)^;
              c:=(ln_kind_ptr+3)^;
              {0°..-45°}
              if (dx>0) then
                begin
                  m1:=ln_arr_width+c+0;
                  m2:=ln_arr_width+c+1;
                  LineProc[ln_kind_ptr^];
                  Exit;
                end;
              {-135°..-180°}
              if (dx<0) then
                begin
                  m1:=ln_arr_width-c-0;
                  m2:=ln_arr_width-c-1;
                  LineProc[ln_kind_ptr^+20];
                  Exit;
                end;
            end;
        end; {$endregion}
      if (dy<0) then {$region -fold}
        begin
          ln_kind_ptr:=Unaligned(@gcd_arr[Abs(dx)-dy*ln_arr_width].f_ln_kind);
          if (ln_kind_ptr^=0) or (ln_kind_ptr^=10) then
            begin
              if (dx<0) then
                begin
                  r0:=x1;
                  p0:=y1;
                  r1:=x0;
                  p1:=y0;
                end
              else
                begin
                  r0:=x0;
                  p0:=y0;
                  r1:=x1;
                  p1:=y1;
                end;
              LinePHL00;
              Exit;
            end
          else
            begin
              ln_arr0_ptr:=Unaligned(@ln_arr0[x1+y1*ln_arr_width]);
              a:=(ln_kind_ptr+1)^;
              b:=(ln_kind_ptr+2)^;
              c:=(ln_kind_ptr+3)^;
              {-180°..-225°}
              if (dx<0) then
                begin
                  m1:=ln_arr_width+c+0;
                  m2:=ln_arr_width+c+1;
                  LineProc[ln_kind_ptr^];
                  Exit;
                end;
              {-315°..-360°}
              if (dx>0) then
                begin
                  m1:=ln_arr_width-c-0;
                  m2:=ln_arr_width-c-1;
                  LineProc[ln_kind_ptr^+20];
                  Exit;
                end;
            end;
        end; {$endregion}
      {Horizontal Line}
      if (dy=0) then {$region -fold}
        begin
          if (dx>0) then
            FillByte(ln_arr0[x0+y0*ln_arr_width],1+dx,1)
          else
            FillByte(ln_arr0[x1+y1*ln_arr_width],1-dx,1);
          Exit;
        end; {$endregion}
    end
  else
  if (Abs(dx)<<9<Abs(dy)*229) then
    begin
      if (dy>0) then {$region -fold}
        begin
          ln_kind_ptr:=Unaligned(@gcd_arr[Abs(dx)+dy*ln_arr_width].f_ln_kind);
          if (ln_kind_ptr^=0) or (ln_kind_ptr^=10) then
            begin
              if (dx<0) then
                begin
                  r0:=x1;
                  p0:=y1;
                  r1:=x0;
                  p1:=y0;
                end
              else
                begin
                  r0:=x0;
                  p0:=y0;
                  r1:=x1;
                  p1:=y1;
                end;
              LinePHL00;
              Exit;
            end
          else
            begin
              a:=(ln_kind_ptr+1)^;
              b:=(ln_kind_ptr+2)^;
              c:=(ln_kind_ptr+3)^;
              {-45°..-90°}
              if (dx>0) then
                begin
                  r0:=x0;
                  p0:=y0;
                  g:=r0-p0;
                  LineProc[ln_kind_ptr^];
                  Exit;
                end;
              {-90°..-135°}
              if (dx<0) then
                begin
                  r0:=x0;
                  p0:=y0;
                  g:=r0-p0;
                  LineProc[ln_kind_ptr^+20];
                  Exit;
                end;
              {Vertical Line Down}
              if (dx=0) then
                begin
                  FillByte(ln_arr2[x0,y0],dy,1);
                  Exit;
                end;
            end;
        end; {$endregion}
      if (dy<0) then {$region -fold}
        begin
          ln_kind_ptr:=Unaligned(@gcd_arr[Abs(dx)-dy*ln_arr_width].f_ln_kind);
          if (ln_kind_ptr^=0) or (ln_kind_ptr^=10) then
            begin
              if (dx<0) then
                begin
                  r0:=x1;
                  p0:=y1;
                  r1:=x0;
                  p1:=y0;
                end
              else
                begin
                  r0:=x0;
                  p0:=y0;
                  r1:=x1;
                  p1:=y1;
                end;
              LinePHL00;
              Exit;
            end
          else
            begin
              a:=(ln_kind_ptr+1)^;
              b:=(ln_kind_ptr+2)^;
              c:=(ln_kind_ptr+3)^;
              {-225°..-270°}
              if (dx<0) then
                begin
                  r0:=y1;
                  p0:=x1;
                  g :=0;
                  LineProc[ln_kind_ptr^];
                  Exit;
                end;
              {-270°..-315°}
              if (dx>0) then
                begin
                  r0:=y1;
                  p0:=x1;
                  g :=0;
                  LineProc[ln_kind_ptr^+20];
                  Exit;
                end;
              {Vertical Line Up}
              if (dx=0) then
                begin
                  FillByte(ln_arr2[x1,y1],-dy,1);
                  Exit;
                end;
            end;
        end; {$endregion}
    end
  else {$region -fold}
    begin
      if (dx<0) then
        begin
          r0:=x1;
          p0:=y1;
          r1:=x0;
          p1:=y0;
        end
      else
        begin
          r0:=x0;
          p0:=y0;
          r1:=x1;
          p1:=y1;
        end;
      LinePHL00;
      Exit;
    end; {$endregion}
end; {$endregion}
procedure TFastSpline.LineSME(constref x0,y0,x1,y1:integer; constref proc_ptr_a:TProc0; constref proc_ptr_b:TProc0); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  LineSMN(x0,y0,x1,y1);
end; {$endregion}
procedure TFastSpline.LinePHL(constref x0,y0,x1,y1:integer; constref proc_ptr_a:TProc0; constref proc_ptr_b:TProc0); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (x1<x0) then
    begin
      r0:=x1;
      p0:=y1;
      r1:=x0;
      p1:=y0;
    end
  else
    begin
      r0:=x0;
      p0:=y0;
      r1:=x1;
      p1:=y1;
    end;
  if (y1<>y0) then
    proc_ptr_a
  else
    proc_ptr_b;
end; {$endregion}

// Fast Line Solid Horizontal(Width - 1 pixel):
procedure TFastSpline.LineSHL00; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (r1>r0) then
    begin
      FillByte(ln_arr0[r0+p0*ln_arr_width],r1-r0+1,1);
      Exit;
    end
  else
    begin
      FillByte(ln_arr0[r1+p0*ln_arr_width],r0-r1+1,1);
      Exit;
    end;
end; {$endregion}
procedure TFastSpline.LineSHL10; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PInteger;
  i       : integer;
begin
  f_ln_ptr:=@ln_arr1_ptr[r0+p0*ln_arr_width];
  for i:=0 to r1-r0 do
    begin
      f_ln_ptr^-=1;
      Inc(f_ln_ptr);
    end;
end; {$endregion}
procedure TFastSpline.LineSHL20; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PInteger;
  i       : integer;
begin
  f_ln_ptr:=@ln_arr1_ptr[r0+p0*ln_arr_width];
  for i:=0 to r1-r0 do
    begin
      f_ln_ptr^+=1;
      Inc(f_ln_ptr);
    end;
end; {$endregion}
procedure TFastSpline.LineSHL30; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FillDWord((bmp_dst_ptr+r0+p0*bmp_dst_width)^,r1-r0+1,local_prop.eds_col_inv);
end; {$endregion}

// Fast Line Solid Vertical(Width - 1 pixel):
procedure TFastSpline.LineSVL00; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (p1>p0) then
    begin
      FillByte(ln_arr2[r0,p0],p1-p0,1);
      Exit;
    end
  else
    begin
      FillByte(ln_arr2[r0,p1],p0-p1,1);
      Exit;
    end;
end; {$endregion}
procedure TFastSpline.LineSVL10; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PInteger;
  i       : integer;
begin
  f_ln_ptr:=@ln_arr1_ptr[r0+p0*ln_arr_width];
  for i:=0 to p1-p0 do
    begin
      f_ln_ptr^-=1;
      Inc(f_ln_ptr,ln_arr_width);
    end;
end; {$endregion}
procedure TFastSpline.LineSVL20; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PInteger;
  i       : integer;
begin
  f_ln_ptr:=@ln_arr1_ptr[r0+p0*ln_arr_width];
  for i:=0 to p1-p0 do
    begin
      f_ln_ptr^+=1;
      Inc(f_ln_ptr,ln_arr_width);
    end;
end; {$endregion}
procedure TFastSpline.LineSVL30; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PInteger;
  i       : integer;
begin
  f_ln_ptr:=bmp_dst_ptr+r0+p0*bmp_dst_width;
  for i:=0 to p1-p0 do
    begin
      f_ln_ptr^:=local_prop.eds_col_inv;
      Inc(f_ln_ptr,bmp_dst_width);
    end;
end; {$endregion}

{Fast Line Clipping}

// Sobkow-Pospisil-Yang Algorithm:
procedure TFastSpline.ClippedLine1(x0,y0,x1,y1:integer; const rct_clp:TPtRect; constref proc1:TProc3; constref proc2:TProc0; constref proc3:TProc0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_code: integer{byte}=0;

  procedure ClipLine    (                            var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    proc1(v0,w0,v1,w1,proc2,proc3);
  end; {$endregion}
  procedure Clip0_Left  (const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    w0+=Trunc(((w1-w0)*(custom_rect2.left-v0))/(v1-v0));
    v0:=custom_rect2.left;
  end; {$endregion}
  procedure Clip0_Top   (const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // inline induces SIGFPE ERROR in outer procedure
  begin
    v0+=Trunc(((v1-v0)*(custom_rect2.bottom-w0))/(w1-w0));
    w0:=custom_rect2.bottom;
  end; {$endregion}
  procedure Clip0_Right (const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    w0+=Trunc(((w1-w0)*(custom_rect2.right-v0))/(v1-v0));
    v0:=custom_rect2.right;
  end; {$endregion}
  procedure Clip0_Bottom(const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    v0+=Trunc(((v1-v0)*(custom_rect2.top-w0))/(w1-w0));
    w0:=custom_rect2.top;
  end; {$endregion}
  procedure Clip1_Left  (const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    w1+=Trunc(((w0-w1)*(custom_rect2.left-v1))/(v0-v1));
    v1:=custom_rect2.left;
  end; {$endregion}
  procedure Clip1_Top   (const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    v1+=Trunc(((v0-v1)*(custom_rect2.bottom-w1))/(w0-w1));
    w1:=custom_rect2.bottom;
  end; {$endregion}
  procedure Clip1_Right (const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    w1+=Trunc(((w0-w1)*(custom_rect2.right-v1))/(v0-v1));
    v1:=custom_rect2.right;
  end; {$endregion}
  procedure Clip1_Bottom(const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    v1+=Trunc(((v0-v1)*(custom_rect2.top-w1))/(w0-w1));
    w1:=custom_rect2.top;
  end; {$endregion}

begin
  {$region -fold}
  {Fast Clipping Algorithm}

   (*
    Алгоритм быстрого отсечения FC(Fast Clipping) Собкова-Поспишила-Янга
  (Sobkow-Pospisil-Yang), с кодированием линий. Отсекает отрезок, заданный
  координатами его точек (x0,y0), (x1,y1), по окну custom_rect.
    * Clip0_A - перемещение начальной точки (x0,y0) в точку пересечения отрезка
  со стороной A;
    * Clip1_A - перемещение конечной точки (x1,y1) в точку пересечения отрезка
  со стороной A;
    Схема кодирования концов отрезков:

                          1001    |  1000   |  1010
                                  |         |
                           0x9    |   0x8   |   0xA
                          _ _ _ _1| _ _ _ _2| _ _ _ _3
                                  |         |
                          0001    |  0000   |  0010
                                  |         |
                           0x1    |   0x0   |   0x2
                          _ _ _ _4| _ _ _ _5| _ _ _ _6
                                  |         |
                          0101    |  0100   |  0110
                                  |         |
                           0x5    |   0x4   |   0x6
                                 7|        8|        9

    Отрезок видим только в области 5, т.е. отрезок, координаты которого
  удовлетворяют условиям:

        Rect.Left < X < Rect.Right    и    Rect.Bottom < Y < Rect.Top,

  но поскольку в Lazarus-е координата Y отсчитывается от верхнего левого
  угла, то последнее неравенство перепишем как

                         Rect.Bottom > Y > Rect.Top,

  (Это обстоятельство также учтено в коде подпрограммы!!!)
    Каждая конечная точка отрезка V0V1 окажется с одной из этих областей.
  Комбинация кодов концов отрезка, называемая кодом линии, используется для
  определения возможных вариантов расположения отрезка и, следовательно,
  отсечения. Код линии формируется из кодов концов отрезка следующим образом:

                 LineCode(V0,V1) = (Code(V0) × 16) + Code(V1),

  здесь Code(V1) обозначает код конечной точки V1, Code(V0) × 16 означает сдвиг
  кода начальной точки V0 влево на 4 разряда.
    Так как каждый код может принимать одно из 9 значений, то всего имеется
  81 возможный вариант расположения отрезка.
   *)

  {Вычисление значения Code - кода отрезка.
  Биты 0-3 - для конечной точки(x1,y1), 4-7 - для начальной точки(x0,y0);}

  if (y1>rct_clp.Bottom) then
    line_code+=8
  else
    if (y1<rct_clp.Top) then
      line_code+=4;

  if (x1>rct_clp.Right) then
    line_code+=2
  else
    if (x1<rct_clp.Left) then
      line_code+=1;

  if (y0>rct_clp.Bottom) then
    line_code+=128
  else
    if (y0<rct_clp.Top) then
      line_code+=64;

  if (x0>rct_clp.Right) then
    line_code+=32
  else
    if (x0<rct_clp.Left) then
      line_code+=16;

  {Отсечение для каждого из 81-го случаев}
  case line_code of

    {Из центра}

    $00:
      begin
        ClipLine(x0,y0,x1,y1);
        Exit;
      end;
    $01:
      begin
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        ClipLine  (        x0,y0,x1,y1);
        Exit;
      end;
    $02:
      begin
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $04:
      begin
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $05:
      begin
        Clip1_Left    (rct_clp,x0,y0,x1,y1);
        if (y1<        rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $06:
      begin
        Clip1_Right   (rct_clp,x0,y0,x1,y1);
        if (y1<        rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $08:
      begin
        Clip1_Top(rct_clp,x0,y0,x1,y1);
        ClipLine (        x0,y0,x1,y1);
        Exit;
      end;
    $09:
      begin
        Clip1_Left (rct_clp,x0,y0,x1,y1);
        if (y1>     rct_clp.Bottom) then
          Clip1_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $0A:
      begin
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        if (y1>     rct_clp.Bottom) then
          Clip1_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;

    {Слева}

    $10:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        ClipLine  (        x0,y0,x1,y1);
        Exit;
      end;
    $11: Exit;                                                 // Отброшен
    $12:
      begin
        Clip0_Left (rct_clp,x0,y0,x1,y1);
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $14:
      begin
        Clip0_Left  (rct_clp,x0,y0,x1,y1);
        if (y0<      rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $15: Exit;                                                 // Отброшен
    $16:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        if (y0<    rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip1_Bottom (rct_clp,x0,y0,x1,y1);
        if (x1>       rct_clp.Right) then
          Clip1_Right(rct_clp,x0,y0,x1,y1);
        ClipLine     (        x0,y0,x1,y1);
        Exit;
      end;
    $18:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        if (y0>    rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip1_Top(rct_clp,x0,y0,x1,y1);
        ClipLine (        x0,y0,x1,y1);
        Exit;
      end;
    $19: Exit;                                                 // Отброшен
    $1A:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        if (y0>    rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip1_Top    (rct_clp,x0,y0,x1,y1);
        if (x1>       rct_clp.Right) then
          Clip1_Right(rct_clp,x0,y0,x1,y1);
        ClipLine     (        x0,y0,x1,y1);
        Exit;
      end;

    {Справа}

    $20:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $21:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        Clip1_Left (rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $22: Exit;                                                 // Отброшен
    $24:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0<     rct_clp.Top) then
          Exit;                                                 // Отброшен
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $25:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0<     rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        if (x1<      rct_clp.Left) then
          Clip1_Left(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $26: Exit;                                                 // Отброшен
    $28:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip1_Top  (rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $29:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip1_Top(rct_clp,x0,y0,x1,y1);
        if (x1<   rct_clp.Left) then
          Clip1_Left(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $2A: Exit;                                                 // Отброшен

    {Снизу}

    $40:
      begin
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $41:
      begin
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (x0<      rct_clp.Left) then
          Exit;                                                // Отброшен
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        if (y1<    rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $42:
      begin
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (x0>      rct_clp.Right) then
          Exit;                                                // Отброшен
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $44: Exit;                                                 // Отброшен
    $45: Exit;                                                 // Отброшен
    $46: Exit;                                                 // Отброшен
    $48:
      begin
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        Clip1_Top   (rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $49:
      begin
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (x0<      rct_clp.Left) then
          Exit;                                                // Отброшен
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        if (y1>    rct_clp.Bottom) then
          Clip1_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $4A:
      begin
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (x0>      rct_clp.Right) then
          Exit;                                                // Отброшен
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        if (y1>     rct_clp.Bottom) then
          Clip1_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;

    {Снизу слева}

    $50:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        if (y0<    rct_clp.Top) then
          Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $51: Exit;                                                 // Отброшен
    $52:
      begin
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        if (y1<     rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (x0<      rct_clp.Left) then
          Clip0_Left(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $54: Exit;                                                 // Отброшен
    $55: Exit;                                                 // Отброшен
    $56: Exit;                                                 // Отброшен
    $58:
      begin
        Clip1_Top(rct_clp,x0,y0,x1,y1);
        if (x1<   rct_clp.Left) then
          Exit;                                                // Отброшен
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (x0<      rct_clp.Left) then
          Clip0_Left(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $59: Exit;                                                 // Отброшен
    $5A:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        if (y0>    rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        if (y1<     rct_clp.Top) then
          Exit;                                                // Отброшен
        if (y0<        rct_clp.Top) then
          Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (y1>        rct_clp.Bottom) then
          Clip1_Top   (rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;

    {Снизу-справа}

    $60:
      begin
        Clip0_Right   (rct_clp,x0,y0,x1,y1);
        if (y0<        rct_clp.Top) then
          Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $61:
      begin
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        if (y1<    rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip0_Bottom (rct_clp,x0,y0,x1,y1);
        if (x0>       rct_clp.Right) then
          Clip0_Right(rct_clp,x0,y0,x1,y1);
        ClipLine     (        x0,y0,x1,y1);
        Exit;
      end;
    $62: Exit;                                                 // Отброшен
    $64: Exit;                                                 // Отброшен
    $65: Exit;                                                 // Отброшен
    $66: Exit;                                                 // Отброшен
    $68:
      begin
        Clip1_Top(rct_clp,x0,y0,x1,y1);
        if (x1>   rct_clp.Right) then
          Exit;                                                // Отброшен
        Clip0_Right   (rct_clp,x0,y0,x1,y1);
        if (y0<        rct_clp.Top) then
          Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $69:
      begin
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        if (y1<    rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Exit;                                                // Отброшен
        if (y1>        rct_clp.Bottom) then
          Clip1_Top   (rct_clp,x0,y0,x1,y1);
        if (y0<        rct_clp.Top) then
          Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $6A: ;                                                     // Отброшен

    {Сверху}

    $80:
      begin
        Clip0_Top(rct_clp,x0,y0,x1,y1);
        ClipLine (        x0,y0,x1,y1);
        Exit;
      end;
    $81:
      begin
        Clip0_Top(rct_clp,x0,y0,x1,y1);
        if (x0<   rct_clp.Left) then
          Exit;                                                // Отброшен
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        ClipLine  (        x0,y0,x1,y1);
        Exit;
      end;
    $82:
      begin
        Clip0_Top(rct_clp,x0,y0,x1,y1);
        if (x0>   rct_clp.Right) then
          Exit;                                                // Отброшен
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $84:
      begin
        Clip0_Top   (rct_clp,x0,y0,x1,y1);
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $85:
      begin
        Clip0_Top(rct_clp,x0,y0,x1,y1);
        if (x0<   rct_clp.Left) then
          Exit;                                                // Отброшен
        Clip1_Left    (rct_clp,x0,y0,x1,y1);
        if (y1<        rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $86:
      begin
        Clip0_Top(rct_clp,x0,y0,x1,y1);
        if (x0>   rct_clp.Right) then
          Exit;                                                // Отброшен
        Clip1_Right   (rct_clp,x0,y0,x1,y1);
        if (y1<        rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $88: Exit;                                                 // Отброшен
    $89: Exit;                                                 // Отброшен
    $8A: Exit;                                                 // Отброшен

    {Сверху-слева}

    $90:
      begin
        Clip0_Left (rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Clip0_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $91: Exit;                                                 // Отброшен
    $92:
      begin
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        if (y1>     rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip0_Top   (rct_clp,x0,y0,x1,y1);
        if (x0<      rct_clp.Left) then
          Clip0_Left(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $94:
      begin
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        if (x1<      rct_clp.Left) then
          Exit;                                                // Отброшен
        Clip0_Left (rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Clip0_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $95: Exit;                                                 // Отброшен
    $96:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        if (y0<    rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        if (y1>     rct_clp.Bottom) then
          Exit;                                                // Отброшен
        if (y0>        rct_clp.Bottom) then
          Clip0_Top   (rct_clp,x0,y0,x1,y1);
        if (y1<        rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $98: Exit;                                                 // Отброшен
    $99: Exit;                                                 // Отброшен
    $9A: Exit;                                                 // Отброшен

    {Сверху-справа}

    $A0:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Clip0_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $A1:
      begin
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        if (y1>    rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip0_Top    (rct_clp,x0,y0,x1,y1);
        if (x0>       rct_clp.Right) then
          Clip0_Right(rct_clp,x0,y0,x1,y1);
        ClipLine     (        x0,y0,x1,y1);
        Exit;
      end;
    $A2: Exit;                                                 // Отброшен
    $A4:
      begin
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        if (x1>      rct_clp.Right) then
          Exit;                                                // Отброшен
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Clip0_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $A5:
      begin
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        if (y1>    rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0<     rct_clp.Top) then
          Exit;                                                // Отброшен
        if (y1<        rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        if (y0>        rct_clp.Bottom) then
          Clip0_Top   (rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $A6: Exit;                                                 // Отброшен
    $A8: Exit;                                                 // Отброшен
    $A9: Exit;                                                 // Отброшен
    $AA: Exit;                                                 // Отброшен

  end;
  {$endregion}
end; {$endregion}

// Matthes-Drakopoulos  Algorithm:
procedure TFastSpline.ClippedLine2(x0,y0,x1,y1:integer; const rct_clp:TPtRect; constref proc1:TProc3; constref proc2:TProc0; constref proc3:TProc0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x: array[0..1] of integer;
  y: array[0..1] of integer;
  i: byte;
begin
  if ((not ((x0<rct_clp.left) and (x1<rct_clp.left))) and (not ((x0>rct_clp.right ) and (x1>rct_clp.right )))) and
     ((not ((y0<rct_clp.top ) and (y1<rct_clp.top ))) and (not ((y0>rct_clp.bottom) and (y1>rct_clp.bottom)))) then
    begin
      x[0]:=x0;
      y[0]:=y0;
      x[1]:=x1;
      y[1]:=y1;
      i   :=0;
      repeat
        begin
          if (x[i]<rct_clp.left) then
            begin
              x[i]:=rct_clp.left;
              y[i]:=Trunc(((y1-y0)*(rct_clp.left  -x0))/(x1-x0)+y0);
            end
          else
          if (x[i]>rct_clp.right) then
            begin
              x[i]:=rct_clp.right;
              y[i]:=Trunc(((y1-y0)*(rct_clp.right -x0))/(x1-x0)+y0);
            end;
          if (y[i]<rct_clp.top) then
            begin
              y[i]:=rct_clp.top;
              x[i]:=Trunc(((x1-x0)*(rct_clp.top   -y0))/(y1-y0)+x0);
            end
          else
          if (y[i]>rct_clp.bottom) then
            begin
              y[i]:=rct_clp.bottom;
              x[i]:=Trunc(((x1-x0)*(rct_clp.bottom-y0))/(y1-y0)+x0);
            end;
          i:=i+1;
        end;
      until (i>1);
      if (not ((x[0]<rct_clp.left ) and (x[1]<rct_clp.left ))) and
         (not ((x[0]>rct_clp.right) and (x[1]>rct_clp.right))) then
        proc1(x[0],y[0],x[1],y[1],proc2,proc3);
    end;
end; {$endregion}
procedure TFastSpline.ClippedLine2(x0,y0,x1,y1:integer; const rct_clp:TPtRect);                                                                      {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x: array[0..1] of integer;
  y: array[0..1] of integer;
  i: byte;
begin
  if ((not ((x0<rct_clp.left) and (x1<rct_clp.left))) and (not ((x0>rct_clp.right ) and (x1>rct_clp.right )))) and
     ((not ((y0<rct_clp.top ) and (y1<rct_clp.top ))) and (not ((y0>rct_clp.bottom) and (y1>rct_clp.bottom)))) then
    begin
      x[0]:=x0;
      y[0]:=y0;
      x[1]:=x1;
      y[1]:=y1;
      i   :=0;
      repeat
        begin
          if (x[i]<rct_clp.left) then
            begin
              x[i]:=rct_clp.left;
              y[i]:=Trunc(((y1-y0)*(rct_clp.left  -x0))/(x1-x0)+y0);
            end
          else
          if (x[i]>rct_clp.right) then
            begin
              x[i]:=rct_clp.right;
              y[i]:=Trunc(((y1-y0)*(rct_clp.right -x0))/(x1-x0)+y0);
            end;
          if (y[i]<rct_clp.top) then
            begin
              y[i]:=rct_clp.top;
              x[i]:=Trunc(((x1-x0)*(rct_clp.top   -y0))/(y1-y0)+x0);
            end
          else
          if (y[i]>rct_clp.bottom) then
            begin
              y[i]:=rct_clp.bottom;
              x[i]:=Trunc(((x1-x0)*(rct_clp.bottom-y0))/(y1-y0)+x0);
            end;
          i:=i+1;
        end;
      until (i>1);
      if (not ((x[0]<rct_clp.left ) and (x[1]<rct_clp.left ))) and
         (not ((x[0]>rct_clp.right) and (x[1]>rct_clp.right))) then
        with ln_pos do
          begin
            x0:=x[0];
            y0:=y[0];
            x1:=x[1];
            y1:=y[1];
          end;
    end;
end; {$endregion} {$endregion}



(****************************** Points Transform ******************************)

// (Align Points to horizontal line, from left to right): Выровнять точки по горизонтали, слева направо:
procedure PtsRawH(var pts:T1PtPosFArr; constref start_ind,end_ind:integer; constref pts_dist:longword);                                                      {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr       : PPtPosF;
  i,pts_dist_acc: integer;
begin
  pts_ptr     :=Unaligned(@pts[start_ind]);
  pts_dist_acc:=Trunc(pts_ptr^.x);
  for i:=0 to end_ind-start_ind-1 do
    begin
      (pts_ptr+i)^.x:=pts_dist_acc;
      Inc(pts_dist_acc,pts_dist);
    end;
end; {$endregion}

// (Align Points to vertical line, from top to bottom): Выровнять точки по вертикали, сверху вниз:
procedure PtsRawV(var pts:T1PtPosFArr; constref start_ind,end_ind:integer; constref pts_dist:longword);                                                      {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr       : PPtPosF;
  i,pts_dist_acc: integer;
begin
  pts_ptr     :=Unaligned(@pts[start_ind]);
  pts_dist_acc:=Trunc(pts_ptr^.y);
  for i:=0 to end_ind-start_ind-1 do
    begin
      (pts_ptr+i)^.y:=pts_dist_acc;
      Inc(pts_dist_acc,pts_dist);
    end;
end; {$endregion}

// (Reset Points Position): Восстановить позицию точек:
procedure PtsRes (constref fst_pt_ptr1,fst_pt_ptr2:PPtPosF;  constref pts_cnt:integer; constref pt_pos_curr,pt_pos_prev:TPtPosF);                            {$ifdef Linux}[local];{$endif} {$region -fold}
var
  fst_pt_ptr3: PPtPosF;
  i,n1,n2    : integer;
  m          : byte;
begin
  n1:=Trunc(pt_pos_curr.x)-Trunc(pt_pos_prev.x);
  n2:=Trunc(pt_pos_curr.y)-Trunc(pt_pos_prev.y);
  for i:=0 to Trunc(pts_cnt/4)-1 do
    begin
       fst_pt_ptr3      :=fst_pt_ptr1+i<<2;
      (fst_pt_ptr3+0)^.x+=n1;
      (fst_pt_ptr3+0)^.y+=n2;
      (fst_pt_ptr3+1)^.x+=n1;
      (fst_pt_ptr3+1)^.y+=n2;
      (fst_pt_ptr3+2)^.x+=n1;
      (fst_pt_ptr3+2)^.y+=n2;
      (fst_pt_ptr3+3)^.x+=n1;
      (fst_pt_ptr3+3)^.y+=n2;
    end;
  m:=pts_cnt mod 4;
  if (m<>0) then
    for i:=0 to m-1 do
      begin
        (fst_pt_ptr2+i)^.x+=n1;
        (fst_pt_ptr2+i)^.y+=n2;
      end;
end; {$endregion}

// (Points Pivot) Ось точек:
procedure PtsPvt (var      pvt:TPtPosF; var pts:T1PtPosFArr; constref pts_cnt:integer);                                                                      {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr: PPtPosF;
  p      : TPtPosF;
  i      : integer;
begin
  if (pts=Nil) then
    Exit;
  p      :=Default(TPtPosF);
  pvt    :=Default(TPtPosF);
  pts_ptr:=Unaligned(@pts[0]);
  for i  :=0 to pts_cnt-1 do
    begin
      p.x+=(pts_ptr+i)^.x;
      p.y+=(pts_ptr+i)^.y;
    end;
  pvt.x  :=p.x/pts_cnt;
  pvt.y  :=p.y/pts_cnt;
end; {$endregion}

// (Points Moving) Перемещение точек:
procedure PtsMov (constref pvt:TPtPos;  var pts:T1PtPosFArr; constref pts_cnt:integer; constref fst_ind:integer              );                              {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr: PPtPosF;
  i      : integer;
begin
  if (pts=Nil) then
    Exit;
  pts_ptr:=Unaligned(@pts[fst_ind]);
  for i:=0 to pts_cnt-1 do
    begin
      pts_ptr^.x-=pvt.x;
      pts_ptr^.y-=pvt.y;
      Inc(pts_ptr);
    end;
end; {$endregion}
procedure PtsMov (constref pvt:TPtPos;  var pts:T1PtPosFArr; constref pts_cnt:integer                                        );                              {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr: PPtPosF;
  i      : integer;
begin
  if (pts=Nil) then
    Exit;
  pts_ptr:=Unaligned(@pts[0]);
  for i:=0 to pts_cnt-1 do
    begin
      pts_ptr^.x-=pvt.x;
      pts_ptr^.y-=pvt.y;
      Inc(pts_ptr);
    end;
end; {$endregion}
procedure PtsMov (constref pvt:TPtPos;  var rct:TPtRect                                                                      );                              {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  rct.left  -=pvt.x;
  rct.top   -=pvt.y;
  rct.right -=pvt.x;
  rct.bottom-=pvt.y;
  rct.width :=rct.right -rct.left;
  rct.height:=rct.bottom-rct.top;
end; {$endregion}
procedure PtsMov (constref pvt:TPtPos;  var rct:TRect                                                                        );                              {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  rct.left  -=pvt.x;
  rct.top   -=pvt.y;
  rct.right -=pvt.x;
  rct.bottom-=pvt.y;
  rct.width :=rct.right -rct.left;
  rct.height:=rct.bottom-rct.top;
end; {$endregion}
procedure WndSht (constref outer_rect:TPtRect; constref inner_rect:T1PtPosFArr; var shift_power:integer; constref mul:integer);                              {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m: integer;
begin
  m:=Max(Trunc(inner_rect[1].x-
               inner_rect[0].x),
         Trunc(inner_rect[1].y-
               inner_rect[0].y));
  if (m>512) then
      shift_power:=Trunc(m/50);
  if (shift_power >Min(outer_rect.width,
                       outer_rect.height)) then
      shift_power:=Min(outer_rect.width,
                       outer_rect.height);
      shift_power*=mul>>4;
end; {$endregion}
procedure MDCalc (var rct:TRect; constref mov_dir:TMovingDirection; constref shift_power:integer                             );                              {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct do
    case mov_dir of
      mdLeft:
        begin
          left +=shift_power;
          right+=shift_power;
          width:=right-left;
        end;
      mdRight:
        begin
          left -=shift_power;
          right-=shift_power;
          width:=right-left;
        end;
      mdUp:
        begin
          top   +=shift_power;
          bottom+=shift_power;
          height:=bottom-top;
        end;
      mdDown:
        begin
          top   -=shift_power;
          bottom-=shift_power;
          height:=bottom-top;
        end;
      mdLeftUp:
        begin
          left  +=shift_power;
          right +=shift_power;
          width :=right-left;
          top   +=shift_power;
          bottom+=shift_power;
          height:=bottom-top;
        end;
      mdRightUp:
        begin
          left  -=shift_power;
          right -=shift_power;
          width :=right-left;
          top   +=shift_power;
          bottom+=shift_power;
          height:=bottom-top;
        end;
      mdLeftDown:
        begin
          left  +=shift_power;
          right +=shift_power;
          width :=right-left;
          top   -=shift_power;
          bottom-=shift_power;
          height:=bottom-top;
        end;
      mdRightDown:
        begin
          left  -=shift_power;
          right -=shift_power;
          width :=right-left;
          top   -=shift_power;
          bottom-=shift_power;
          height:=bottom-top;
        end;
    end;
end; {$endregion}

// (Points Scaling) Масштабирование точек:
procedure PtsScl (constref pvt:TPtPosF; var pts:T1PtPosFArr; constref pts_cnt:integer; scl_mul:TPtPosF; constref scl_dir:TSclDir; constref fst_ind:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr: PPtPosF;
  d1,d2  : double;
  i      : integer;
begin
  if (pts=Nil) then
    Exit;
  if (scl_dir=sdDown) then
    scl_mul:=PtPosF(1/scl_mul.x,
                    1/scl_mul.y);
  d1       :=pvt.x*(1-scl_mul.x);
  d2       :=pvt.y*(1-scl_mul.y);
  pts_ptr  :=Unaligned(@pts[fst_ind]);
  for i:=0 to pts_cnt-1 do
    begin
      //pts_ptr^.x:=scl_mul.x*pts_ptr^.x+d1;
      pts_ptr^.x*=scl_mul.x;
      pts_ptr^.x+=d1;
      //pts_ptr^.y:=scl_mul.y*pts_ptr^.y+d2;
      pts_ptr^.y*=scl_mul.y;
      pts_ptr^.y+=d2;
      Inc(pts_ptr);
    end;
end; {$endregion}
procedure PtsScl (constref pvt:TPtPosF; var pts:T1PtPosFArr; constref pts_cnt:integer; scl_mul:TPtPosF; constref scl_dir:TSclDir                          ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr: PPtPosF;
  d1,d2  : double;
  i      : integer;
begin
  if (pts=Nil) then
    Exit;
  if (scl_dir=sdDown) then
    scl_mul:=PtPosF(1/scl_mul.x,
                    1/scl_mul.y);
  d1       :=pvt.x*(1-scl_mul.x);
  d2       :=pvt.y*(1-scl_mul.y);
  pts_ptr  :=Unaligned(@pts[0]);
  for i:=0 to pts_cnt-1 do
    begin
      //pts_ptr^.x:=scl_mul.x*pts_ptr^.x+d1;
      pts_ptr^.x*=scl_mul.x;
      pts_ptr^.x+=d1;
      //pts_ptr^.y:=scl_mul.y*pts_ptr^.y+d2;
      pts_ptr^.y*=scl_mul.y;
      pts_ptr^.y+=d2;
      Inc(pts_ptr);
    end;
end; {$endregion}
procedure PtsScl (constref pvt:TPtPosF; var rct:TPtRectF   ; constref pts_cnt:integer; scl_mul:TPtPosF; constref scl_dir:TSclDir                          ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  d1,d2: double;
begin
  if (scl_dir=sdDown) then
    scl_mul :=PtPosF(1/scl_mul.x,
                     1/scl_mul.y);
  d1        :=pvt.x*(1-scl_mul.x);
  d2        :=pvt.y*(1-scl_mul.y);
  //rct.left  :=scl_mul.x *rct.left  +d1;
  rct.left  *=scl_mul.x;
  rct.left  +=d1;
  //rct.top   :=scl_mul.y *rct.top   +d2;
  rct.top   *=scl_mul.y;
  rct.top   +=d2;
  //rct.right :=scl_mul.x *rct.right +d1;
  rct.right *=scl_mul.x;
  rct.right +=d1;
  //rct.bottom:=scl_mul.y *rct.bottom+d2;
  rct.bottom*=scl_mul.y;
  rct.bottom+=d2;
  rct.width :=rct.right -rct.left;
  rct.height:=rct.bottom-rct.top;
end; {$endregion}
procedure PtsScl (constref pvt:TPtPosF; var rct:TRect      ; constref pts_cnt:integer; scl_mul:TPtPosF; constref scl_dir:TSclDir                          ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  d1,d2: double;
begin
  if (scl_dir=sdDown) then
    scl_mul :=PtPosF(1/scl_mul.x,
                     1/scl_mul.y);
  d1        :=pvt.x*(1-scl_mul.x);
  d2        :=pvt.y*(1-scl_mul.y);
  rct.left  :=Trunc (  scl_mul.x *rct.left  +d1);
  rct.top   :=Trunc (  scl_mul.y *rct.top   +d2);
  rct.right :=Trunc (  scl_mul.x *rct.right +d1);
  rct.bottom:=Trunc (  scl_mul.y *rct.bottom+d2);
  rct.width :=rct.right -rct.left;
  rct.height:=rct.bottom-rct.top;
end; {$endregion}

// (Points Rotation) Вращение точек:
{TODO}

// (Points Simplification) Точечное упрощение:
{TODO}



(************************** Miscellaneous Primitives **************************)

// Color Info:
procedure SetColorInfo(constref pix_col:integer; var color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  color_info.r:=Red  (pix_col);
  color_info.g:=Green(pix_col);
  color_info.b:=Blue (pix_col);
  with color_info do
    begin
      pix_col :=RGB(b,g,r);
        alpha1:=180;
      d_alpha1:=255-alpha1;
        alpha2:=80;
      d_alpha2:=255-alpha2;
    end;
end; {$endregion}

// Line Segment: Отрезок:
function  LineS   (constref v0,w0,v1,w1,r0,r1:double                               ): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k,d0,d1: double;
begin
  with Result do
    begin
      if (v1=v0) then
        begin
          x0:=v0;
          y0+=r0;
          x1:=v1;
          y1+=r1;
          Exit;
        end;
      if (w1=w0) then
        begin
          x0+=r0;
          y0:=w0;
          x1+=r1;
          y1:=w1;
          Exit;
        end;
      k :=(w1-w0)/(v1-v0);
      d0:=r0*InvSqrt(1+k*k){r0/sqrt(1+k*k)}; // only with garbage init. ON
      x0:=v0+d0;
      y0:=k*d0+w0;
      d1:=r1*InvSqrt(1+k*k){r1/sqrt(1+k*k)}; // only with garbage init. ON
      x1:=v1+d1;
      y1:=k*d1+w1;
    end;
end; {$endregion}
function  LineS   (constref v0,w0,v1,w1,r    :double                               ): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k,d: double;
begin
  with Result do
    begin
      if (v1=v0) then
        begin
          x:=v1;
          y+=r;
          Exit;
        end;
      if (w1=w0) then
        begin
          x+=r;
          y:=w1;
          Exit;
        end;
      k :=(w1-w0)/(v1-v0);
      d :=r*InvSqrt(1+k*k){r/sqrt(1+k*k)}; // only with garbage init. ON
      x :=v1+d;
      y :=k*d+w1;
    end;
end; {$endregion}
function  LineS   (constref v0,w0,v1,w1,r    :double; constref dir_x,dir_y:shortint): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k,dx: double;
begin
  with Result do
    begin
      if (v1=v0) then
        begin
          x:=v1;
          y:=w1+r*dir_y;
          Exit;
        end;
      if (w1=w0) then
        begin
          x:=v1+r*dir_x;
          y:=w1;
          Exit;
        end;
      k :=(w1-w0)/(v1-v0);
      dx:=r*InvSqrt(1+k*k){r/sqrt(1+k*k)}; // only with garbage init. ON
      x :=v1+dir_x*dx;
      y :=w1+dir_y*dx*k;
    end;
end; {$endregion}

// Line Direction: Направление линии:
procedure LineD   (constref v0,w0,v1,w1      :double; var      dir_x,dir_y:shortint);          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (v1>v0) then
    begin
      if (w1=w0) then
        begin
          dir_x:=1;
          dir_y:=0;
          Exit;
        end
      else
        begin
          dir_x:=1;
          dir_y:=1;
          Exit;
        end;
    end
  else
    begin
      if (v1=v0) then
        begin
          if (w1>w0) then
            begin
              dir_x:=0;
              dir_y:=1;
              Exit;
            end
          else
            begin
              dir_x:=0;
              dir_y:=-1;
              Exit;
            end
        end;
      if (w1=w0) then
        begin
          dir_x:=-1;
          dir_y:=0;
          Exit;
        end
      else
        begin
          dir_x:=-1;
          dir_y:=-1;
          Exit;
        end;
    end
end; {$endregion}

// Monochrome Regular Line(Width - 1 pixel):
procedure Line    (x0,y0,x1,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:integer; constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  y0_shift                        : integer;
  i,short_len,long_len,swp,dec_inc: integer;
  yLonger                         : boolean;
begin
  with color_info do
    begin
      yLonger  :=False;
      short_len:=y1-y0;
      long_len :=x1-x0;
      if (Abs(short_len)>Abs(long_len)) then
        begin
          swp      :=short_len;
          short_len:=long_len;
          long_len :=swp;
          yLonger  :=True;
        end;
      if (long_len=0) then
        dec_inc:=0
      else
        dec_inc:=Trunc((short_len<<16)/long_len);
      if (yLonger) then
        begin
          if (long_len>0) then
            begin
    	      long_len+=y0;
              i:=$8000+(x0<<16);
              y0_shift:=y0*bmp_dst_width;
              while (y0<=long_len) do
                begin
                  (bmp_dst_ptr+(i>>16)+y0_shift)^:=pix_col;
    	          i+=dec_inc;
                  Inc(y0);
                  Inc(y0_shift,bmp_dst_width);
                end;
              Exit;
            end;
          long_len+=y0;
          i:=$8000+(x0<<16);
          y0_shift:=y0*bmp_dst_width;
          while (y0>=long_len) do
            begin
              (bmp_dst_ptr+(i>>16)+y0_shift)^:=pix_col;
              i-=dec_inc;
              Dec(y0);
              Dec(y0_shift,bmp_dst_width);
            end;
          Exit;
        end;
      if (long_len>0) then
        begin
          long_len+=x0;
          i:=$8000+(y0<<16);
          while (x0<=long_len) do
            begin
              (bmp_dst_ptr+x0+(i>>16)*bmp_dst_width)^:=pix_col;
              i+=dec_inc;
              Inc(x0);
            end;
          Exit;
        end;
      long_len+=x0;
      i:=$8000+(y0<<16);
      while (x0>=long_len) do
        begin
          (bmp_dst_ptr+x0+(i>>16)*bmp_dst_width)^:=pix_col;
          i-=dec_inc;
          Dec(x0);
        end;
    end;
end; {$endregion}
procedure Line    (x0,y0,x1,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:integer; constref val       :integer   ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  y0_shift                        : integer;
  i,short_len,long_len,swp,dec_inc: integer;
  yLonger                         : boolean;
begin
  yLonger  :=False;
  short_len:=y1-y0;
  long_len :=x1-x0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
    end;
  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);
  if (yLonger) then
    begin
      if (long_len>0) then
        begin
          long_len+=y0;
          i:=$8000+(x0<<16);
          y0_shift:=y0*bmp_dst_width;
          while (y0<=long_len) do
            begin
              (bmp_dst_ptr+(i>>16)+y0_shift)^:=val;
              i+=dec_inc;
              Inc(y0);
              Inc(y0_shift,bmp_dst_width);
            end;
          Exit;
        end;
      long_len+=y0;
      i:=$8000+(x0<<16);
      y0_shift:=y0*bmp_dst_width;
      while (y0>=long_len) do
        begin
          (bmp_dst_ptr+(i>>16)+y0_shift)^:=val;
          i-=dec_inc;
          Dec(y0);
          Dec(y0_shift,bmp_dst_width);
        end;
      Exit;
    end;
  if (long_len>0) then
    begin
      long_len+=x0;
      i:=$8000+(y0<<16);
      while (x0<=long_len) do
        begin
          (bmp_dst_ptr+x0+(i>>16)*bmp_dst_width)^:=val;
          i+=dec_inc;
          Inc(x0);
        end;
      Exit;
    end;
  long_len+=x0;
  i:=$8000+(y0<<16);
  while (x0>=long_len) do
    begin
      (bmp_dst_ptr+x0+(i>>16)*bmp_dst_width)^:=val;
      i-=dec_inc;
      Dec(x0);
    end;
end; {$endregion}
procedure Line    (x0,y0,x1,y1:integer; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width:integer; constref val       :byte      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  y0_shift                        : integer;
  i,short_len,long_len,swp,dec_inc: integer;
  yLonger                         : boolean;
begin
  yLonger  :=False;
  short_len:=y1-y0;
  long_len :=x1-x0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
    end;
  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);
  if (yLonger) then
    begin
      if (long_len>0) then
        begin
          long_len+=y0;
          i:=$8000+(x0<<16);
          y0_shift:=y0*bmp_dst_width;
          while (y0<=long_len) do
            begin
              (bmp_dst_ptr+(i>>16)+y0_shift)^:=val;
              i+=dec_inc;
              Inc(y0);
              Inc(y0_shift,bmp_dst_width);
            end;
          Exit;
        end;
      long_len+=y0;
      i:=$8000+(x0<<16);
      y0_shift:=y0*bmp_dst_width;
      while (y0>=long_len) do
        begin
          (bmp_dst_ptr+(i>>16)+y0_shift)^:=val;
          i-=dec_inc;
          Dec(y0);
          Dec(y0_shift,bmp_dst_width);
        end;
      Exit;
    end;
  if (long_len>0) then
    begin
      long_len+=x0;
      i:=$8000+(y0<<16);
      while (x0<=long_len) do
        begin
          (bmp_dst_ptr+x0+(i>>16)*bmp_dst_width)^:=val;
          i+=dec_inc;
          Inc(x0);
        end;
      Exit;
    end;
  long_len+=x0;
  i:=$8000+(y0<<16);
  while (x0>=long_len) do
    begin
      (bmp_dst_ptr+x0+(i>>16)*bmp_dst_width)^:=val;
      i-=dec_inc;
      Dec(x0);
    end;
end; {$endregion}

// Line Segments Intersection:
function LineSI   (x0,y0,x1,y1,v0,w0,v1,w1:double ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  a0,a1,b0,b1: boolean;
begin
  a0:=((x0-x1)*(w0-y1)<=(y0-y1)*(v0-x1));
  a1:=((x0-x1)*(w1-y1)<=(y0-y1)*(v1-x1));
  b0:=((v1-v0)*(y1-w0)<=(w1-w0)*(x1-v0));
  b1:=((v1-v0)*(y0-w0)<=(w1-w0)*(x0-v0));
  Result:=((a0 and (not a1)) or (a1 and (not a0))) and
          ((b0 and (not b1)) or (b1 and (not b0)));
  {Result:=(((x0-x1)*(w0-y1)-(y0-y1)*(v0-x1))*
           ((x0-x1)*(w1-y1)-(y0-y1)*(v1-x1))<=0) and
          (((v1-v0)*(y1-w0)-(w1-w0)*(x1-v0))*
           ((v1-v0)*(y0-w0)-(w1-w0)*(x0-v0))<=0);}
end; {$endregion}
function LineSI   (x0,y0,x1,y1,v0,w0,v1,w1:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  a0,a1,b0,b1: boolean;
begin
  a0:=((x0-x1)*(w0-y1)<=(y0-y1)*(v0-x1));
  a1:=((x0-x1)*(w1-y1)<=(y0-y1)*(v1-x1));
  b0:=((v1-v0)*(y1-w0)<=(w1-w0)*(x1-v0));
  b1:=((v1-v0)*(y0-w0)<=(w1-w0)*(x0-v0));
  Result:=((a0 and (not a1)) or (a1 and (not a0))) and
          ((b0 and (not b1)) or (b1 and (not b0)));
  {Result:=(((x0-x1)*(w0-y1)-(y0-y1)*(v0-x1))*
           ((x0-x1)*(w1-y1)-(y0-y1)*(v1-x1))<=0) and
          (((v1-v0)*(y1-w0)-(w1-w0)*(x1-v0))*
           ((v1-v0)*(y0-w0)-(w1-w0)*(x0-v0))<=0);}
end; {$endregion}

// Line Clipping:
function LineC    (var x0,y0,x1,y1:integer; constref rct_clp:TPtRect): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x: array[0..1] of integer;
  y: array[0..1] of integer;
  i: byte;
begin
  Result:=False;
  if ((not ((x0<rct_clp.left) and (x1<rct_clp.left))) and (not ((x0>rct_clp.right ) and (x1>rct_clp.right )))) and
     ((not ((y0<rct_clp.top ) and (y1<rct_clp.top ))) and (not ((y0>rct_clp.bottom) and (y1>rct_clp.bottom)))) then
    begin
      x[0]:=x0;
      y[0]:=y0;
      x[1]:=x1;
      y[1]:=y1;
      i   :=0;
      repeat
        begin
          if (x[i]<rct_clp.left) then
            begin
              x[i]:=rct_clp.left;
              y[i]:=Trunc(((y1-y0)*(rct_clp.left  -x0))/(x1-x0)+y0);
            end
          else
          if (x[i]>rct_clp.right) then
            begin
              x[i]:=rct_clp.right;
              y[i]:=Trunc(((y1-y0)*(rct_clp.right -x0))/(x1-x0)+y0);
            end;
          if (y[i]<rct_clp.top) then
            begin
              y[i]:=rct_clp.top;
              x[i]:=Trunc(((x1-x0)*(rct_clp.top   -y0))/(y1-y0)+x0);
            end
          else
          if (y[i]>rct_clp.bottom) then
            begin
              y[i]:=rct_clp.bottom;
              x[i]:=Trunc(((x1-x0)*(rct_clp.bottom-y0))/(y1-y0)+x0);
            end;
          i:=i+1;
        end;
      until (i>1);
      if (not ((x[0]<rct_clp.left ) and (x[1]<rct_clp.left ))) and
         (not ((x[0]>rct_clp.right) and (x[1]>rct_clp.right))) then
        begin
          Result:=True;
          x0    :=x[0];
          y0    :=y[0];
          x1    :=x[1];
          y1    :=y[1];
        end;
    end;
end; {$endregion}

// Monochrome Antialiased Line(Width - 1 pixel):
procedure LineA   (    x0,y0,x1,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:integer; constref color_info:TColorInfo                          ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  bmp_dst_ptr2                      : PInteger;
  dx,dy,dydx                        : double;
  df,deltax,deltay,loop,start,finish: integer;
begin
  with color_info do
    begin
      deltax:=Abs(x1-x0);
      deltay:=Abs(y1-y0);
      {if (deltax=0) or (deltay=0) then
        Exit;}
      if (deltax>deltay) then
        begin
          if (y1>y0) then
            dydx:=-deltay/deltax
          else
            dydx:= deltay/deltax;
          if (x1<x0) then
            begin
              start :=x1;
              finish:=x0;
              dy    :=y1;
            end
          else
            begin
              start :=x0;
              finish:=x1;
              dy    :=y0;
              dydx  :=-dydx;
            end;
          for loop:=start to finish do
            begin
              df          :=Trunc(255*Frac(dy));
              bmp_dst_ptr2:=bmp_dst_ptr +loop+Trunc(dy)*bmp_dst_width;
              AlphaBlend   (bmp_dst_ptr2+0000000000000,r,g,b,    df);
              AlphaBlend   (bmp_dst_ptr2+bmp_dst_width,r,g,b,255-df);
              dy+=dydx;
            end;
        end
      else
        begin
          if (x1>x0) then
            dydx:=-deltax/deltay
          else
            dydx:= deltax/deltay;
          if (y1<y0) then
            begin
              start :=y1;
              finish:=y0;
              dx    :=x1;
            end
          else
            begin
              start :=y0;
              finish:=y1;
              dx    :=x0;
              dydx  :=-dydx;
            end;
          for loop:=start to finish do
            begin
              df          :=Trunc(255*Frac(dx));
              bmp_dst_ptr2:=bmp_dst_ptr +Trunc(dx)+loop*bmp_dst_width;
              AlphaBlend   (bmp_dst_ptr2+0,r,g,b,    df);
              AlphaBlend   (bmp_dst_ptr2+1,r,g,b,255-df);
              dx+=dydx;
            end;
        end;
    end;
end; {$endregion}
procedure LineAC  (var x0,y0,x1,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:integer; constref color_info:TColorInfo; constref rct_clp:TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (y0=y1) then
    begin
      // Line Clipping:
      if LineHC(x0,y0,x1,rct_clp) then
        // Line Drawing:
        LineH(x0,y0,x1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
    end
  else
    begin
      // Line Clipping:
      if LineC(x0,y0,x1,y1,rct_clp) then
        // Line Drawing:
        LineA(x0,y0,x1,y1,bmp_dst_ptr,bmp_dst_width,color_info);
    end;
end; {$endregion}

// Monochrome Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineABC (constref pts:T1PtPosFArr; constref start_ind,end_ind:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:integer; constref color_info:TColorInfo; constref rct_clp:TPtRect; constref shift:TPtPos;                       exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr            : PPtPosF;
  x0,y0,x1,y1,i,d_ind: integer;
begin
  d_ind:=end_ind-start_ind;
  if (d_ind=0) then
    Exit;
  pts_ptr:=Unaligned(@pts[start_ind]);
  for i:=0 to d_ind-1 do
    begin
      x0:=Trunc((pts_ptr+0)^.x)+shift.x;
      y0:=Trunc((pts_ptr+0)^.y)+shift.y;
      x1:=Trunc((pts_ptr+1)^.x)+shift.x;
      y1:=Trunc((pts_ptr+1)^.y)+shift.y;
      if (y0=y1) then
        begin
          // Line Clipping:
          if LineHC(x0,y0,x1,rct_clp) then
            // Line Drawing:
            LineH(x0,y0,x1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        end
      else
        begin
          // Line Clipping:
          if LineC(x0,y0,x1,y1,rct_clp) then
            // Line Drawing:
            LineA(x0,y0,x1,y1,bmp_dst_ptr,bmp_dst_width,color_info);
        end;
      Inc(pts_ptr);
    end;
  if exp_ then
    begin
      pts_ptr:=Unaligned(@pts[start_ind]);
      x0     :=Trunc((pts_ptr+00000)^.x)+shift.x;
      y0     :=Trunc((pts_ptr+00000)^.y)+shift.y;
      x1     :=Trunc((pts_ptr+d_ind)^.x)+shift.x;
      y1     :=Trunc((pts_ptr+d_ind)^.y)+shift.y;
      if (y0=y1) then
        begin
          // Line Clipping:
          if LineHC(x0,y0,x1,rct_clp) then
            // Line Drawing:
            LineH(x0,y0,x1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        end
      else
        begin
          // Line Clipping:
          if LineC(x0,y0,x1,y1,rct_clp) then
            // Line Drawing:
            LineA(x0,y0,x1,y1,bmp_dst_ptr,bmp_dst_width,color_info);
        end;
    end;
end; {$endregion}

// Gradient(Highlight) Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineABCG(constref pts:T1PtPosFArr; constref start_ind,end_ind:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:integer; var      color_info:TColorInfo; constref rct_clp:TPtRect; constref shift:TPtPos;                       exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr                      : PPtPosF;
  x0,y0,x1,y1,i,d_ind,p,pix_col: integer;
begin
  d_ind:=end_ind-start_ind;
  if (d_ind=0) then
    Exit;
  p      :=0;
  pix_col:=color_info.pix_col;
  pts_ptr:=Unaligned(@pts[start_ind]);
  for i:=0 to d_ind-1 do
    begin
      x0:=Trunc((pts_ptr+0)^.x)+shift.x;
      y0:=Trunc((pts_ptr+0)^.y)+shift.y;
      x1:=Trunc((pts_ptr+1)^.x)+shift.x;
      y1:=Trunc((pts_ptr+1)^.y)+shift.y;
      SetColorInfo(Highlight(pix_col,0,0,0,0,0,p),color_info);
      if (y0=y1) then
        begin
          // Line Clipping:
          if LineHC(x0,y0,x1,rct_clp) then
            // Line Drawing:
            LineH(x0,y0,x1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        end
      else
        begin
          // Line Clipping:
          if LineC(x0,y0,x1,y1,rct_clp) then
            // Line Drawing:
            LineA(x0,y0,x1,y1,bmp_dst_ptr,bmp_dst_width,color_info);
        end;
      Inc(p);
      Inc(pts_ptr);
    end;
  if exp_ then
    begin
      pts_ptr:=Unaligned(@pts[start_ind]);
      x0     :=Trunc((pts_ptr+00000)^.x)+shift.x;
      y0     :=Trunc((pts_ptr+00000)^.y)+shift.y;
      x1     :=Trunc((pts_ptr+d_ind)^.x)+shift.x;
      y1     :=Trunc((pts_ptr+d_ind)^.y)+shift.y;
      SetColorInfo(Highlight(pix_col,0,0,0,0,0,p),color_info);
      if (y0=y1) then
        begin
          // Line Clipping:
          if LineHC(x0,y0,x1,rct_clp) then
            // Line Drawing:
            LineH(x0,y0,x1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        end
      else
        begin
          // Line Clipping:
          if LineC(x0,y0,x1,y1,rct_clp) then
            // Line Drawing:
            LineA(x0,y0,x1,y1,bmp_dst_ptr,bmp_dst_width,color_info);
        end;
    end;
end; {$endregion}

// Equidistant Line(Width - 1 pixel):
function  LineE1  (constref v0,w0,v1,w1,rad:double): TLnPosF;                                                                                                                                                                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k,d,l0,l1: double;
begin
  with Result do
    begin
      if (v1=v0) then
        begin
          x0:=v0-rad;
          y0:=w0;
          x1:=x0;
          y1:=w1;
          Exit;
        end
      else
        begin
          if (w1=w0) then
            begin
              x0:=v0;
              y0:=w0-rad;
              x1:=v1;
              y1:=y0;
              Exit;
            end;
          k :=(w1-w0)/(v1-v0);
          d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
          l0:=rad*d*k;
          l1:=rad*d  ;
          x0:=v0-l0;
          y0:=w0+l1;
          x1:=v1-l0;
          y1:=w1+l1;
        end;
    end;
end; {$endregion}
function  LineE2  (constref v0,w0,v1,w1,rad:double): TLnPosF;                                                                                                                                                                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k,d,l0,l1: double;
begin
  with Result do
    begin
      if (v1=v0) then
        begin
          x0:=v0+rad;
          y0:=w0;
          x1:=x0;
          y1:=w1;
          Exit;
        end
      else
        begin
          if (w1=w0) then
            begin
              x0:=v0;
              y0:=w0+rad;
              x1:=v1;
              y1:=y0;
              Exit;
            end;
          k :=(w1-w0)/(v1-v0);
          d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
          l0:=rad*d*k;
          l1:=rad*d  ;
          x0:=v0+l0;
          y0:=w0-l1;
          x1:=v1+l0;
          y1:=w1-l1;
        end;
    end;
end; {$endregion}

// Equidistant Curve for Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineABCE(constref pts:T1PtPosFArr; constref start_ind,end_ind:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:integer; constref color_info:TColorInfo; constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:integer; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    {if (Abs(x1-x0){*(x1-x0)}+Abs(y1-y0){*(y1-y0)}<2) then
      begin
        Inc(pts_ptr);
        Continue;
      end;}
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=x1-rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          LineA(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        v0:=x0+rad;
        w0:=y0;
        v1:=x1+rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          LineA(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          LineA(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          LineA(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            color_info.pix_col);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (end_ind-start_ind>0) then
    CircProc(d_ind);
end; {$endregion}

// Equidistant Curve for Not Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineBCE (constref pts:T1PtPosFArr; constref start_ind,end_ind:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:integer; constref color_info:TColorInfo; constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:integer; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    {if (Abs(x1-x0){*(x1-x0)}+Abs(y1-y0){*(y1-y0)}<2) then
      begin
        Inc(pts_ptr);
        Continue;
      end;}
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=x1-rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        v0:=x0+rad;
        w0:=y0;
        v1:=x1+rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            color_info.pix_col);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (end_ind-start_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE (constref pts:T1PtPosFArr; constref start_ind,end_ind:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:integer; constref val       :integer   ; constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:integer; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=x1-rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        v0:=x0+rad;
        w0:=y0;
        v1:=x1+rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            val);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (end_ind-start_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE (constref pts:T1PtPosFArr; constref start_ind,end_ind:integer; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width:integer; constref val       :byte      ; constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:integer; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=x1-rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        v0:=x0+rad;
        w0:=y0;
        v1:=x1+rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            val);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (end_ind-start_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE (constref pts:T1PtPosFArr; constref start_ind,end_ind:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:integer;                                 constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:integer; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  pt_ind     : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0    :=Trunc((pts_ptr+i)^.x)+shift.x;
    y0    :=Trunc((pts_ptr+i)^.y)+shift.y;
    x1    :=Trunc((pts_ptr+j)^.x)+shift.x;
    y1    :=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=x1-rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0:=x0+rad;
        w0:=y0;
        v1:=x1+rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            pt_ind);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    begin
      pt_ind:=start_ind+i+1;
      LineProc(0,1);
    end;
  pts_ptr :=pts_ptr1;
  if exp_ then
    begin
      pt_ind:=-(start_ind+1);
      LineProc(0,d_ind);
    end;
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    begin
      pt_ind:=start_ind+i+1;
      CircProc(i);
    end;
  pts_ptr :=pts_ptr1;
  if (end_ind-start_ind>0) then
    begin
      pt_ind:=end_ind+1;
      CircProc(d_ind);
    end;
end; {$endregion}

// Equidistant Curve for Not Antialiased Broken Clipped Line(Width - 2 pixel):
procedure LineBCE2(constref pts:T1PtPosFArr; constref start_ind,end_ind:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:integer; constref color_info:TColorInfo; constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:integer; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end;
        v0:=x0+rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end;
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info);
              end;
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info);
              end;
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end;
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end;
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            color_info.pix_col);
    if (rad>1) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-1,
              bmp_dst_ptr,
              rct_clp,
              bmp_dst_width,
              color_info.pix_col);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (d_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE2(constref pts:T1PtPosFArr; constref start_ind,end_ind:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:integer; constref val       :integer   ; constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:integer; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
        v0:=x0+rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end;
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end;
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            val);
    if (rad>1) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-1,
              bmp_dst_ptr,
              rct_clp,
              bmp_dst_width,
              val);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (d_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE2(constref pts:T1PtPosFArr; constref start_ind,end_ind:integer; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width:integer; constref val       :byte      ; constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:integer; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
        v0:=x0+rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end;
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end;
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            val);
    if (rad>1) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-1,
              bmp_dst_ptr,
              rct_clp,
              bmp_dst_width,
              val);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (d_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE2(constref pts:T1PtPosFArr; constref start_ind,end_ind:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:integer;                                 constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:integer; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  pt_ind     : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end;
        v0:=x0+rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end;
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
              end;
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
              end;
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end;
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end;
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            pt_ind);
    if (rad>1) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-1,
              bmp_dst_ptr,
              rct_clp,
              bmp_dst_width,
              pt_ind);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (d_ind>0) then
    CircProc(d_ind);
end; {$endregion}

// Equidistant Curve for Not Antialiased Broken Clipped Line(Width - 3 pixel):
procedure LineBCE3(constref pts:T1PtPosFArr; constref start_ind,end_ind:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:integer; constref color_info:TColorInfo; constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:integer; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0+rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        v0+=1;
        v1+=1;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        v0-=2;
        v1-=2;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        v0:=x0-rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        v0+=1;
        v1+=1;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        v0-=2;
        v1-=2;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            w0+=1;
            w1+=1;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            w0-=2;
            w1-=2;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            w0+=1;
            w1+=1;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            w0-=2;
            w1-=2;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );

        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            w0-=2;
            w1-=2;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
          end;

        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            w0-=2;
            w1-=2;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            v0-=2;
            v1-=2;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
          end;

      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            color_info.pix_col);
    if (rad>1) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-1,
              bmp_dst_ptr,
              rct_clp,
              bmp_dst_width,
              color_info.pix_col);
    if (rad>2) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-2,
              bmp_dst_ptr,
              rct_clp,
              bmp_dst_width,
              color_info.pix_col);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (d_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE3(constref pts:T1PtPosFArr; constref start_ind,end_ind:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:integer;                                 constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:integer; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  pt_ind     : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0+rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0+=1;
        v1+=1;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0-=2;
        v1-=2;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0:=x0-rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0+=1;
        v1+=1;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0-=2;
        v1-=2;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            w0+=1;
            w1+=1;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            w0-=2;
            w1-=2;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            w0+=1;
            w1+=1;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            w0-=2;
            w1-=2;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            w0-=2;
            w1-=2;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end;
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            w0-=2;
            w1-=2;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            v0-=2;
            v1-=2;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end;
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            pt_ind);
    if (rad>1) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-1,
              bmp_dst_ptr,
              rct_clp,
              bmp_dst_width,
              pt_ind);
    if (rad>2) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-2,
              bmp_dst_ptr,
              rct_clp,
              bmp_dst_width,
              pt_ind);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    begin
      pt_ind:=start_ind+i+1;
      LineProc(0,1);
    end;
  pts_ptr :=pts_ptr1;
  if exp_ then
    begin
      pt_ind:=-(start_ind+1);
      LineProc(0,d_ind);
    end;
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    begin
      pt_ind:=start_ind+i+1;
      CircProc(i);
    end;
  pts_ptr :=pts_ptr1;
  if (end_ind-start_ind>0) then
    begin
      pt_ind:=end_ind+1;
      CircProc(d_ind);
    end;
end; {$endregion}

// Monochrome Resilient Line(Width - 1 pixel):
procedure LineR   (constref x0,y0,x1,y1:integer;                                 constref bmp_dst_ptr:PInteger; constref bmp_dst_width:integer; constref color_info:TColorInfo; constref seg_cnt:integer                                                                 ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,dx,dy: double;
  i        : integer;
begin
      x:=x0;
      y:=y0;
  if (x1>x0) then
    begin
      dx:=(x1-x0)/seg_cnt;
      if  (y1>y0) then
        begin
          dy:=(y1-y0)/seg_cnt;
          for i:=0 to seg_cnt-2 do
            begin
              x+=dx;
              y+=dy;
              Point(Trunc(x),
                    Trunc(y),
                    bmp_dst_ptr,
                    bmp_dst_width,
                    color_info);
            end;
        end
      else
        begin
          dy:=(y0-y1)/seg_cnt;
          for i:=0 to seg_cnt-2 do
            begin
              x+=dx;
              y-=dy;
              Point(Trunc(x),
                    Trunc(y),
                    bmp_dst_ptr,
                    bmp_dst_width,
                    color_info);
            end;
        end;
    end
  else
    begin
      dx:=(x0-x1)/seg_cnt;
      if  (y1>y0) then
        begin
          dy:=(y1-y0)/seg_cnt;
          for i:=0 to seg_cnt-2 do
            begin
              x-=dx;
              y+=dy;
              Point(Trunc(x),
                    Trunc(y),
                    bmp_dst_ptr,
                    bmp_dst_width,
                    color_info);
            end;
        end
      else
        begin
          dy:=(y0-y1)/seg_cnt;
          for i:=0 to seg_cnt-2 do
            begin
              x-=dx;
              y-=dy;
              Point(Trunc(x),
                    Trunc(y),
                    bmp_dst_ptr,
                    bmp_dst_width,
                    color_info);
            end;
        end;
    end;
end; {$endregion}

// Monochrome Horizontal Line(Width - 1 pixel):
function  LineHC  (var x0,y0,x1:integer; constref rct_clp:TPtRect): boolean;                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_clp: array[0..7] of boolean;
  clp    : qword absolute arr_clp;
  x2     : integer;
begin
  Result:=True;
  if (y0<rct_clp.top) or (y0>=rct_clp.bottom) then
    begin
      Result:=False;
      Exit;
    end;
  if (x0>x1) then
    begin
      x2:=x1;
      x1:=x0;
      x0:=x2;
    end;
  arr_clp[00]:=(x0< rct_clp.left  );
  arr_clp[01]:=(x0>=rct_clp.left  ) and (x0<rct_clp.right);
  arr_clp[02]:=(x0>=rct_clp.right );
  arr_clp[03]:=(x1< rct_clp.left  );
  arr_clp[04]:=(x1>=rct_clp.left  ) and (x1<rct_clp.right);
  arr_clp[05]:=(x1>=rct_clp.right );
  arr_clp[06]:=False;
  arr_clp[07]:=False;
  case clp of
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000000000000000000001000000000000000000000001:
      begin
        Result:=False;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000000000000100000000000000000000000000000001:
      begin
        x0    :=rct_clp.left;
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000010000000000000000000000000000000000000001:
      begin
        x0    :=rct_clp.left;
        x1    :=rct_clp.right-1;
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000000000000100000000000000000000000100000000:
      begin
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000010000000000000000000000000000000100000000:
      begin
        x1    :=rct_clp.right-1;
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000010000000000000000000000010000000000000000:
      begin
        Result:=False;
        Exit;
      end;
  end;
end; {$endregion}
procedure LineH   (    x0,y0,x1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:integer; constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FillDWord((bmp_dst_ptr+x0+y0*bmp_dst_width)^,x1-x0+1,color_info.pix_col);
end; {$endregion}
procedure LineH   (    x0,y0,x1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:integer; constref val       :integer   ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FillDWord((bmp_dst_ptr+x0+y0*bmp_dst_width)^,x1-x0+1,val);
end; {$endregion}
procedure LineH   (    x0,y0,x1:integer; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width:integer; constref val       :byte      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FillByte((bmp_dst_ptr+x0+y0*bmp_dst_width)^,x1-x0+1,val);
end; {$endregion}

// Monochrome Vertical Line(Width - 1 pixel):
function  LineVC  (var x0,y0,y1:integer; constref rct_clp:TPtRect): boolean;                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_clp: array[0..7] of boolean;
  clp    : qword absolute arr_clp;
  y2     : integer;
begin
  Result:=True;
  if (x0<rct_clp.left) or (x0>=rct_clp.right) then
    begin
      Result:=False;
      Exit;
    end;
  if (y0>y1) then
    begin
      y2:=y1;
      y1:=y0;
      y0:=y2;
    end;
  arr_clp[00]:=(y0< rct_clp.top   );
  arr_clp[01]:=(y0>=rct_clp.top   ) and (y0<rct_clp.bottom);
  arr_clp[02]:=(y0>=rct_clp.bottom);
  arr_clp[03]:=(y1< rct_clp.top   );
  arr_clp[04]:=(y1>=rct_clp.top   ) and (y1<rct_clp.bottom);
  arr_clp[05]:=(y1>=rct_clp.bottom);
  arr_clp[06]:=False;
  arr_clp[07]:=False;
  case clp of
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000000000000000000001000000000000000000000001:
      begin
        Result:=False;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000000000000100000000000000000000000000000001:
      begin
        y0    :=rct_clp.top;
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000010000000000000000000000000000000000000001:
      begin
        y0    :=rct_clp.top;
        y1    :=rct_clp.bottom-1;
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000000000000100000000000000000000000100000000:
      begin
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000010000000000000000000000000000000100000000:
      begin
        y1    :=rct_clp.bottom-1;
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000010000000000000000000000010000000000000000:
      begin
        Result:=False;
        Exit;
      end;
  end;
end; {$endregion}
procedure LineV   (    x0,y0,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:integer; constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_ptr: PInteger;
  i     : integer;
begin
  ln_ptr:=bmp_dst_ptr+x0+y0*bmp_dst_width;
  for i:=0 to y1-y0 do
    begin
      ln_ptr^:=color_info.pix_col;
      Inc(ln_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure LineV   (    x0,y0,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:integer; constref val       :integer   ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_ptr: PInteger;
  i     : integer;
begin
  ln_ptr:=bmp_dst_ptr+x0+y0*bmp_dst_width;
  for i:=0 to y1-y0 do
    begin
      ln_ptr^:=val;
      Inc(ln_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure LineV   (    x0,y0,y1:integer; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width:integer; constref val       :byte      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_ptr: PByte;
  i     : integer;
begin
  ln_ptr:=bmp_dst_ptr+x0+y0*bmp_dst_width;
  for i:=0 to y1-y0 do
    begin
      ln_ptr^:=val;
      Inc(ln_ptr,bmp_dst_width);
    end;
end; {$endregion}

// Point:
procedure Point        (constref x,y:integer; constref bmp_dst_ptr  :PInteger; constref bmp_dst_width:integer;   constref color_info:TColorInfo);                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pixel_ptr: PInteger;
begin
  with color_info do
    begin
      pixel_ptr:=bmp_dst_ptr+(x-1)+bmp_dst_width*(y-1);
      AlphaBlend(pixel_ptr,r,g,b,alpha1);
      Inc(pixel_ptr);
      AlphaBlend(pixel_ptr,r,g,b,alpha2);
      Inc(pixel_ptr);
      AlphaBlend(pixel_ptr,r,g,b,alpha1);
      Inc(pixel_ptr,bmp_dst_width-2);
      AlphaBlend(pixel_ptr,r,g,b,alpha2);
      Inc(pixel_ptr);
      pixel_ptr^:=pix_col;
      Inc(pixel_ptr);
      AlphaBlend(pixel_ptr,r,g,b,alpha2);
      Inc(pixel_ptr,bmp_dst_width-2);
      AlphaBlend(pixel_ptr,r,g,b,alpha1);
      Inc(pixel_ptr);
      AlphaBlend(pixel_ptr,r,g,b,alpha2);
      Inc(pixel_ptr);
      AlphaBlend(pixel_ptr,r,g,b,alpha1);
    end;
end; {$endregion}
procedure Point        (constref x,y:integer; constref bmp_dst_ptr  :PInteger; constref bmp_dst_width:integer;   constref color_info:TColorInfo; constref clip_rect:TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pixel_ptr: PInteger;
begin
  with clip_rect,color_info do
    if (x-1>left  ) and
       (x+1<right ) and
       (y-1>top   ) and
       (y+1<bottom) then
      begin
        pixel_ptr:=bmp_dst_ptr+(x-1)+bmp_dst_width*(y-1);
        AlphaBlend(pixel_ptr,r,g,b,alpha1);
        Inc(pixel_ptr);
        AlphaBlend(pixel_ptr,r,g,b,alpha2);
        Inc(pixel_ptr);
        AlphaBlend(pixel_ptr,r,g,b,alpha1);
        Inc(pixel_ptr,bmp_dst_width-2);
        AlphaBlend(pixel_ptr,r,g,b,alpha2);
        Inc(pixel_ptr);
        pixel_ptr^:=pix_col;
        Inc(pixel_ptr);
        AlphaBlend(pixel_ptr,r,g,b,alpha2);
        Inc(pixel_ptr,bmp_dst_width-2);
        AlphaBlend(pixel_ptr,r,g,b,alpha1);
        Inc(pixel_ptr);
        AlphaBlend(pixel_ptr,r,g,b,alpha2);
        Inc(pixel_ptr);
        AlphaBlend(pixel_ptr,r,g,b,alpha1);
    end;
end; {$endregion}
function  PointCollDraw(constref x,y:integer; constref arr_src_width:integer;  var      arr_src      :T1ByteArr; constref clip_rect :TPtRect): boolean;                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with clip_rect do
    if (x>left  ) and
       (x<right ) and
       (y>top   ) and
       (y<bottom) then
      begin
        if (arr_src[x+arr_src_width*y]=0) then
          begin
            Result:=False;
            arr_src[x+arr_src_width*y]:=1;
          end
        else
          Result:=True;
      end;
end; {$endregion}
function  PointCollDraw(constref x,y:integer; constref arr_src_width:integer;  constref arr_src      :T1ByteArr; constref clip_rect :TPtRect; constref b:byte): boolean;      inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with clip_rect do
    if (x>clip_rect.left  ) and
       (x<clip_rect.right ) and
       (y>clip_rect.top   ) and
       (y<clip_rect.bottom) then
      Result:=(arr_src[x+arr_src_width*y]<>0);
end; {$endregion}

// Rectangle:
procedure SetRctDupId (var sln_prop_var:TCurveProp); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      dup_pts_id.arr[0]:=pts_rct_tns_left  ;
      dup_pts_id.arr[1]:=pts_rct_tns_top   ;
      dup_pts_id.arr[2]:=pts_rct_tns_right ;
      dup_pts_id.arr[3]:=pts_rct_tns_bottom;
      dup_pts_id.arr[4]:=pts_rct_inn_width ;
      dup_pts_id.arr[5]:=pts_rct_inn_height;
    end;
end; {$endregion}
procedure SetEdsWidth (var sln_prop_var:TCurveProp); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      eds_width_half:=Trunc(eds_width/2);
      if Odd(eds_width) then
        eds_width_odd:=0
      else
        eds_width_odd:=1;
    end;
end; {$endregion}
procedure SetRctWidth (var sln_prop_var:TCurveProp); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      pts_rct_width      :=pts_rct_tns_left +
                           pts_rct_tns_right+
                           pts_rct_inn_width;
      pts_rct_width__half:=pts_rct_width>>1;
      if Odd(pts_rct_width) then
        pts_rct_width__odd:=0
      else
        pts_rct_width__odd:=1;
      pts_width:=pts_rct_width;
    end;
end; {$endregion}
procedure SetRctHeight(var sln_prop_var:TCurveProp); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      pts_rct_height     :=pts_rct_tns_top   +
                           pts_rct_tns_bottom+
                           pts_rct_inn_height;
      pts_rct_height_half:=pts_rct_height>>1;
      if Odd(pts_rct_height) then
        pts_rct_height_odd:=0
      else
        pts_rct_height_odd:=1;
      pts_height:=pts_rct_height;
    end;
end; {$endregion}
procedure SetRctValues(var sln_prop_var:TCurveProp); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      rct_val_arr[0]:=-(pts_rct_inn_width >>1)-pts_rct_tns_left+pts_rct_width__odd;
      rct_val_arr[1]:=-(pts_rct_inn_height>>1)-pts_rct_tns_top +pts_rct_height_odd;
      rct_val_arr[2]:=+(pts_rct_inn_height>>1)+1;
      rct_val_arr[3]:=-(pts_rct_inn_height>>1)                 +pts_rct_height_odd;
      rct_val_arr[4]:=+(pts_rct_inn_width >>1)+1;
    end;
end; {$endregion}
procedure Rectangle   (constref x,y:integer; constref arr_dst_ptr:PInteger; constref arr_dst_width,arr_dst_height:integer; constref rct_dst:TPtRect; constref sln_prop_var:TCurveProp; constref PPFloodFillProc:TProc4); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      // rct_top:
      PPFloodFillProc(arr_dst_ptr,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[0],
                                          y+rct_val_arr[1],
                                          pts_rct_width,
                                          pts_rct_tns_top)),
                      arr_dst_width);
      // rct_bottom:
      PPFloodFillProc(arr_dst_ptr,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[0],
                                          y+rct_val_arr[2],
                                          pts_rct_width,
                                          pts_rct_tns_bottom)),
                      arr_dst_width);
      // rct_left:
      PPFloodFillProc(arr_dst_ptr,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[0],
                                          y+rct_val_arr[3],
                                          pts_rct_tns_left,
                                          pts_rct_inn_height)),
                      arr_dst_width);
      // rct_right:
      PPFloodFillProc(arr_dst_ptr,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[4],
                                          y+rct_val_arr[3],
                                          pts_rct_tns_right,
                                          pts_rct_inn_height)),
                      arr_dst_width);
    end;
end; {$endregion}
procedure Rectangle   (constref x,y:integer; constref arr_dst_ptr:PInteger; constref arr_dst_width,arr_dst_height:integer; constref rct_dst:TPtRect; constref sln_prop_var:TCurveProp; constref col:integer);            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      // rct_top:
      PPFloodFill(arr_dst_ptr,
                  ClippedRct(rct_dst,
                             PtBounds(x+rct_val_arr[0],
                                      y+rct_val_arr[1],
                                      pts_rct_width,
                                      pts_rct_tns_top)),
                  arr_dst_width,
                  pts_col_inv);
      // rct_bottom:
      PPFloodFill(arr_dst_ptr,
                  ClippedRct(rct_dst,
                             PtBounds(x+rct_val_arr[0],
                                      y+rct_val_arr[2],
                                      pts_rct_width,
                                      pts_rct_tns_bottom)),
                  arr_dst_width,
                  pts_col_inv);
      // rct_left:
      PPFloodFill(arr_dst_ptr,
                  ClippedRct(rct_dst,
                             PtBounds(x+rct_val_arr[0],
                                      y+rct_val_arr[3],
                                      pts_rct_tns_left,
                                      pts_rct_inn_height)),
                  arr_dst_width,
                  pts_col_inv);
      // rct_right:
      PPFloodFill(arr_dst_ptr,
                  ClippedRct(rct_dst,
                             PtBounds(x+rct_val_arr[4],
                                      y+rct_val_arr[3],
                                      pts_rct_tns_right,
                                      pts_rct_inn_height)),
                  arr_dst_width,
                  pts_col_inv);
    end;
end; {$endregion}

// Rhombus:
{TODO}
procedure Rombus(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:integer; constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pixel_ptr: PInteger;
begin
  with color_info do
    begin

    end;
end; {$endregion}

// Circle Drawing(Midpoint Algorithm):
procedure Circle (constref x0,y0,rad:integer; constref bmp_dst_ptr:PInteger;                           constref bmp_dst_width:integer; constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p   : PInteger;
  x,x1: integer;
  y,y1: integer;
  err : integer;
begin
  p   :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x   :=rad;
  y   :=0;
  err :=0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      (p+y-x1)^:=color_info.pix_col;
      (p+x-y1)^:=color_info.pix_col;
      (p+x+y1)^:=color_info.pix_col;
      (p+y+x1)^:=color_info.pix_col;
      (p-y+x1)^:=color_info.pix_col;
      (p-x+y1)^:=color_info.pix_col;
      (p-x-y1)^:=color_info.pix_col;
      (p-y-x1)^:=color_info.pix_col;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure Circle (constref x0,y0,rad:integer; constref bmp_dst_ptr:PInteger;                           constref bmp_dst_width:integer; constref val       :integer   ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p   : PInteger;
  x,x1: integer;
  y,y1: integer;
  err : integer;
begin
  p   :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x   :=rad;
  y   :=0;
  err :=0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      (p+y-x1)^:=val;
      (p+x-y1)^:=val;
      (p+x+y1)^:=val;
      (p+y+x1)^:=val;
      (p-y+x1)^:=val;
      (p-x+y1)^:=val;
      (p-x-y1)^:=val;
      (p-y-x1)^:=val;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure Circle (constref x0,y0,rad:integer; constref bmp_dst_ptr:PByte   ;                           constref bmp_dst_width:integer; constref val       :byte      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p   : PByte;
  x,x1: integer;
  y,y1: integer;
  err : integer;
begin
  p   :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x   :=rad;
  y   :=0;
  err :=0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      (p+y-x1)^:=val;
      (p+x-y1)^:=val;
      (p+x+y1)^:=val;
      (p+y+x1)^:=val;
      (p-y+x1)^:=val;
      (p-x+y1)^:=val;
      (p-x-y1)^:=val;
      (p-y-x1)^:=val;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure CircleC(constref x0,y0,rad:integer; constref bmp_dst_ptr:PInteger; constref rct_clp:TPtRect; constref bmp_dst_width:integer; constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p   : PInteger;
  x,x1: integer;
  y,y1: integer;
  err : integer;
begin
  p   :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x   :=rad;
  y   :=0;
  err :=0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      if (x0+y>=rct_clp.left) and (x0+y<rct_clp.right ) and
         (y0-x>=rct_clp.top ) and (y0-x<rct_clp.bottom) then
        (p+y-x1)^:=color_info.pix_col; //( x0+y)+(y0-x)*arr_dst_width
      if (x0+x>=rct_clp.left) and (x0+x<rct_clp.right ) and
         (y0-y>=rct_clp.top ) and (y0-y<rct_clp.bottom) then
        (p+x-y1)^:=color_info.pix_col; //( x0+x)+(y0-y)*arr_dst_width
      if (x0+x>=rct_clp.left) and (x0+x<rct_clp.right ) and
         (y0+y>=rct_clp.top ) and (y0+y<rct_clp.bottom) then
        (p+x+y1)^:=color_info.pix_col; //( x0+x)+(y0+y)*arr_dst_width
      if (x0+y>=rct_clp.left) and (x0+y<rct_clp.right ) and
         (y0+x>=rct_clp.top ) and (y0+x<rct_clp.bottom) then
        (p+y+x1)^:=color_info.pix_col; //( x0+y)+(y0+x)*arr_dst_width
      if (x0-y>=rct_clp.left) and (x0-y<rct_clp.right ) and
         (y0+x>=rct_clp.top ) and (y0+x<rct_clp.bottom) then
        (p-y+x1)^:=color_info.pix_col; //( x0-y)+(y0+x)*arr_dst_width
      if (x0-x>=rct_clp.left) and (x0-x<rct_clp.right ) and
         (y0+y>=rct_clp.top ) and (y0+y<rct_clp.bottom) then
        (p-x+y1)^:=color_info.pix_col; //( x0-x)+(y0+y)*arr_dst_width
      if (x0-x>=rct_clp.left) and (x0-x<rct_clp.right ) and
         (y0-y>=rct_clp.top ) and (y0-y<rct_clp.bottom) then
        (p-x-y1)^:=color_info.pix_col; //( x0-x)+(y0-y)*arr_dst_width
      if (x0-y>=rct_clp.left) and (x0-y<rct_clp.right ) and
         (y0-x>=rct_clp.top ) and (y0-x<rct_clp.bottom) then
        (p-y-x1)^:=color_info.pix_col; //( x0-y)+(y0-x)*arr_dst_width
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure CircleC(constref x0,y0,rad:integer; constref bmp_dst_ptr:PInteger; constref rct_clp:TPtRect; constref bmp_dst_width:integer; constref val       :integer   ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p   : PInteger;
  x,x1: integer;
  y,y1: integer;
  err : integer;
begin
  p   :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x   :=rad;
  y   :=0;
  err :=0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      if (x0+y>=rct_clp.left) and (x0+y<rct_clp.right ) and
         (y0-x>=rct_clp.top ) and (y0-x<rct_clp.bottom) then
        (p+y-x1)^:=val; //( x0+y)+(y0-x)*arr_dst_width
      if (x0+x>=rct_clp.left) and (x0+x<rct_clp.right ) and
         (y0-y>=rct_clp.top ) and (y0-y<rct_clp.bottom) then
        (p+x-y1)^:=val; //( x0+x)+(y0-y)*arr_dst_width
      if (x0+x>=rct_clp.left) and (x0+x<rct_clp.right ) and
         (y0+y>=rct_clp.top ) and (y0+y<rct_clp.bottom) then
        (p+x+y1)^:=val; //( x0+x)+(y0+y)*arr_dst_width
      if (x0+y>=rct_clp.left) and (x0+y<rct_clp.right ) and
         (y0+x>=rct_clp.top ) and (y0+x<rct_clp.bottom) then
        (p+y+x1)^:=val; //( x0+y)+(y0+x)*arr_dst_width
      if (x0-y>=rct_clp.left) and (x0-y<rct_clp.right ) and
         (y0+x>=rct_clp.top ) and (y0+x<rct_clp.bottom) then
        (p-y+x1)^:=val; //( x0-y)+(y0+x)*arr_dst_width
      if (x0-x>=rct_clp.left) and (x0-x<rct_clp.right ) and
         (y0+y>=rct_clp.top ) and (y0+y<rct_clp.bottom) then
        (p-x+y1)^:=val; //( x0-x)+(y0+y)*arr_dst_width
      if (x0-x>=rct_clp.left) and (x0-x<rct_clp.right ) and
         (y0-y>=rct_clp.top ) and (y0-y<rct_clp.bottom) then
        (p-x-y1)^:=val; //( x0-x)+(y0-y)*arr_dst_width
      if (x0-y>=rct_clp.left) and (x0-y<rct_clp.right ) and
         (y0-x>=rct_clp.top ) and (y0-x<rct_clp.bottom) then
        (p-y-x1)^:=val; //( x0-y)+(y0-x)*arr_dst_width
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure CircleC(constref x0,y0,rad:integer; constref bmp_dst_ptr:PByte   ; constref rct_clp:TPtRect; constref bmp_dst_width:integer; constref val       :byte      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p   : PByte;
  x,x1: integer;
  y,y1: integer;
  err : integer;
begin
  p   :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x   :=rad;
  y   :=0;
  err :=0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      if (x0+y>=rct_clp.left) and (x0+y<rct_clp.right ) and
         (y0-x>=rct_clp.top ) and (y0-x<rct_clp.bottom) then
        (p+y-x1)^:=val; //( x0+y)+(y0-x)*arr_dst_width
      if (x0+x>=rct_clp.left) and (x0+x<rct_clp.right ) and
         (y0-y>=rct_clp.top ) and (y0-y<rct_clp.bottom) then
        (p+x-y1)^:=val; //( x0+x)+(y0-y)*arr_dst_width
      if (x0+x>=rct_clp.left) and (x0+x<rct_clp.right ) and
         (y0+y>=rct_clp.top ) and (y0+y<rct_clp.bottom) then
        (p+x+y1)^:=val; //( x0+x)+(y0+y)*arr_dst_width
      if (x0+y>=rct_clp.left) and (x0+y<rct_clp.right ) and
         (y0+x>=rct_clp.top ) and (y0+x<rct_clp.bottom) then
        (p+y+x1)^:=val; //( x0+y)+(y0+x)*arr_dst_width
      if (x0-y>=rct_clp.left) and (x0-y<rct_clp.right ) and
         (y0+x>=rct_clp.top ) and (y0+x<rct_clp.bottom) then
        (p-y+x1)^:=val; //( x0-y)+(y0+x)*arr_dst_width
      if (x0-x>=rct_clp.left) and (x0-x<rct_clp.right ) and
         (y0+y>=rct_clp.top ) and (y0+y<rct_clp.bottom) then
        (p-x+y1)^:=val; //( x0-x)+(y0+y)*arr_dst_width
      if (x0-x>=rct_clp.left) and (x0-x<rct_clp.right ) and
         (y0-y>=rct_clp.top ) and (y0-y<rct_clp.bottom) then
        (p-x-y1)^:=val; //( x0-x)+(y0-y)*arr_dst_width
      if (x0-y>=rct_clp.left) and (x0-y<rct_clp.right ) and
         (y0-x>=rct_clp.top ) and (y0-x<rct_clp.bottom) then
        (p-y-x1)^:=val; //( x0-y)+(y0-x)*arr_dst_width
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}

// Wave Search:
function CircleW (constref x0,y0,rad:integer; constref arr_dst:T1PtPos2Arr;                            constref arr_dst_width:integer; var pt:TPtPosF): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p     : PPtPos2;
  x,x1  : integer;
  y,y1  : integer;
  err   : integer;
begin
  Result:=False;
  p     :=@arr_dst[x0+y0*arr_dst_width];
  x     :=rad;
  y     :=0;
  err   :=0;
  while (x>=y) do
    begin
      x1:=x*arr_dst_width;
      y1:=y*arr_dst_width;
      if ((p+y-x1)^.obj_ind<>-1) then //(x0+y)+(y0-x)*arr_dst_width
        begin
          pt    :=PtPosF(x0+y,y0-x);
          Result:=True;
          Exit;
        end;
      if ((p+x-y1)^.obj_ind<>-1) then //(x0+x)+(y0-y)*arr_dst_width
        begin
          pt    :=PtPosF(x0+x,y0-y);
          Result:=True;
          Exit;
        end;
      if ((p+x+y1)^.obj_ind<>-1) then //(x0+x)+(y0+y)*arr_dst_width
        begin
          pt    :=PtPosF(x0+x,y0+y);
          Result:=True;
          Exit;
        end;
      if ((p+y+x1)^.obj_ind<>-1) then //(x0+y)+(y0+x)*arr_dst_width
        begin
          pt    :=PtPosF(x0+y,y0+x);
          Result:=True;
          Exit;
        end;
      if ((p-y+x1)^.obj_ind<>-1) then //(x0-y)+(y0+x)*arr_dst_width
        begin
          pt    :=PtPosF(x0-y,y0+x);
          Result:=True;
          Exit;
        end;
      if ((p-x+y1)^.obj_ind<>-1) then //(x0-x)+(y0+y)*arr_dst_width
        begin
          pt    :=PtPosF(x0-x,y0+y);
          Result:=True;
          Exit;
        end;
      if ((p-x-y1)^.obj_ind<>-1) then //(x0-x)+(y0-y)*arr_dst_width
        begin
          pt    :=PtPosF(x0-x,y0-y);
          Result:=True;
          Exit;
        end;
      if ((p-y-x1)^.obj_ind<>-1) then //(x0-y)+(y0-x)*arr_dst_width
        begin
          pt    :=PtPosF(x0-y,y0-x);
          Result:=True;
          Exit;
        end;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
function CircleWC(constref x0,y0,rad:integer; constref arr_dst:T1PtPos2Arr;  constref rct_clp:TPtRect; constref arr_dst_width:integer; var pt:TPtPosF): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p     : PPtPos2;
  x,x1  : integer;
  y,y1  : integer;
  err   : integer;
begin
  Result:=False;
  p     :=@arr_dst[x0+y0*arr_dst_width];
  x     :=rad;
  y     :=0;
  err   :=0;
  while (x>=y) do
    begin
      x1:=x*arr_dst_width;
      y1:=y*arr_dst_width;
      if (x0+y>=rct_clp.left) and (x0+y<rct_clp.right ) and
         (y0-x>=rct_clp.top ) and (y0-x<rct_clp.bottom) and
         ((p+y-x1)^.obj_ind<>-1) then //(x0+y)+(y0-x)*arr_dst_width
        begin
          pt    :=PtPosF(x0+y,y0-x);
          Result:=True;
          Exit;
        end;
      if (x0+x>=rct_clp.left) and (x0+x<rct_clp.right ) and
         (y0-y>=rct_clp.top ) and (y0-y<rct_clp.bottom) and
         ((p+x-y1)^.obj_ind<>-1) then //(x0+x)+(y0-y)*arr_dst_width
        begin
          pt    :=PtPosF(x0+x,y0-y);
          Result:=True;
          Exit;
        end;
      if (x0+x>=rct_clp.left) and (x0+x<rct_clp.right ) and
         (y0+y>=rct_clp.top ) and (y0+y<rct_clp.bottom) and
         ((p+x+y1)^.obj_ind<>-1) then //(x0+x)+(y0+y)*arr_dst_width
        begin
          pt    :=PtPosF(x0+x,y0+y);
          Result:=True;
          Exit;
        end;
      if (x0+y>=rct_clp.left) and (x0+y<rct_clp.right ) and
         (y0+x>=rct_clp.top ) and (y0+x<rct_clp.bottom) and
         ((p+y+x1)^.obj_ind<>-1) then //(x0+y)+(y0+x)*arr_dst_width
        begin
          pt    :=PtPosF(x0+y,y0+x);
          Result:=True;
          Exit;
        end;
      if (x0-y>=rct_clp.left) and (x0-y<rct_clp.right ) and
         (y0+x>=rct_clp.top ) and (y0+x<rct_clp.bottom) and
         ((p-y+x1)^.obj_ind<>-1) then //(x0-y)+(y0+x)*arr_dst_width
        begin
          pt    :=PtPosF(x0-y,y0+x);
          Result:=True;
          Exit;
        end;
      if (x0-x>=rct_clp.left) and (x0-x<rct_clp.right ) and
         (y0+y>=rct_clp.top ) and (y0+y<rct_clp.bottom) and
         ((p-x+y1)^.obj_ind<>-1) then //(x0-x)+(y0+y)*arr_dst_width
        begin
          pt    :=PtPosF(x0-x,y0+y);
          Result:=True;
          Exit;
        end;
      if (x0-x>=rct_clp.left) and (x0-x<rct_clp.right ) and
         (y0-y>=rct_clp.top ) and (y0-y<rct_clp.bottom) and
         ((p-x-y1)^.obj_ind<>-1) then //(x0-x)+(y0-y)*arr_dst_width
        begin
          pt    :=PtPosF(x0-x,y0-y);
          Result:=True;
          Exit;
        end;
      if (x0-y>=rct_clp.left) and (x0-y<rct_clp.right ) and
         (y0-x>=rct_clp.top ) and (y0-x<rct_clp.bottom) and
         ((p-y-x1)^.obj_ind<>-1) then //(x0-y)+(y0-x)*arr_dst_width
        begin
          pt    :=PtPosF(x0-y,y0-x);
          Result:=True;
          Exit;
        end;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}

// Circle FloodFill:
procedure CircleFloodFill(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref outer_rect:TPtRect; constref bmp_dst_width:integer; constref color_info:TColorInfo; constref diam:longword; constref pow:byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rect_dst : TPtRect;
  pixel_ptr: PInteger;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
  d_alpha  : byte;
  m        : byte;
begin
  if (diam=0) then
    Exit;
  d_alpha  :=255-pow;
  rad1     :=diam>>1;
  rad1_sqr :=rad1*rad1;
  rect_dst :=ClippedRct(outer_rect,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rect_dst.width=0) or (rect_dst.height=0) then
    Exit;
  rad2     :=x-rect_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y-rect_dst.top;
  d_width  :=bmp_dst_width -rect_dst.width;
  pixel_ptr:=bmp_dst_ptr   +rect_dst.left+rect_dst.top*bmp_dst_width;
  for j:=0 to rect_dst.height-1 do
    begin
      d_sqr:=(j-rad3)*(j-rad3)+rad2_sqr;
      for i:=0 to rect_dst.width-1 do
        begin
          dist_sqr:=i*i-rad2*i<<1+d_sqr;
          if (dist_sqr<rad1_sqr) and (pixel_ptr^>>24=0) then
            begin
              //m:=Max(pow-Trunc(255*sqrt(dist_sqr)/rad1),0);
              //if (m<>0) then
                with color_info do
                  pixel_ptr^:=AlphaBlend(pixel_ptr^,r,g,b,0,pow){Highlight(pixel_ptr^,0,0,0,0,0,pow)}{pix_col};
                  pixel_ptr^+=%00000001000000000000000000000000;
            end;
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}

// Spotlight:
procedure CircleHighlight(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref outer_rect:TPtRect; constref bmp_dst_width:integer; constref color_info:TColorInfo; constref diam:longword; constref pow:byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rect_dst : TPtRect;
  pixel_ptr: PInteger;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
  m        : byte;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  rad1_sqr :=rad1*rad1;
  rect_dst :=ClippedRct(outer_rect,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rect_dst.width=0) or (rect_dst.height=0) then
    Exit;
  rad2     :=x-rect_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y-rect_dst.top;
  d_width  :=bmp_dst_width -rect_dst.width;
  pixel_ptr:=bmp_dst_ptr   +rect_dst.left+rect_dst.top*bmp_dst_width;
  for j:=0 to rect_dst.height-1 do
    begin
      d_sqr:=(j-rad3)*(j-rad3)+rad2_sqr;
      for i:=0 to rect_dst.width-1 do
        begin
          dist_sqr:=i*i-rad2*i<<1+d_sqr;
          if (dist_sqr<rad1_sqr) then
            begin
              m:=Max(pow-Trunc(255*sqrt(dist_sqr)/rad1),0); // Abs(pow-Trunc(255*sqrt(dist_sqr)/rad1));
              if (m<>0) then
                with color_info do
                  pixel_ptr^:={ColorizeRMDec(pixel_ptr^,0,m)}{Darken(pixel_ptr^,0,0,0,0,0,m)}Highlight(pixel_ptr^,0,0,0,0,0,m);
            end;
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}

// (Transparent Text) Прозрачный текст:
procedure SetTextInfo(                      constref dst_canvas:TCanvas;                        constref height_:integer=27; constref font_color:TColor=$006C754A; constref font_name:string='AR CENA'; constref font_charset:TFontCharSet=ANSI_CHARSET; constref font_quality:TFontQuality=fqAntialiased; constref pen_mode:TFPPenMode=pmXor; constref brush_style:TFPBrushStyle=bsClear); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with dst_canvas do
    begin
      Font.height :=height_;
    //Font.size   :=height_;
      Font.color  :=font_color;
      Font.charset:=font_charset;
      Font.name   :=font_name;
      Font.quality:=font_quality;
      Pen.mode    :=pen_mode;
      Brush.style :=brush_style;
    end;
end; {$endregion}
procedure Text       (constref x,y:integer; constref dst_canvas:TCanvas; constref text_:string);                                                                                                                                                                                                                                                                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  dst_canvas.TextOut(x,y,text_);
end; {$endregion}



(***************************** Some Basic Routines ****************************)

// (Set Point) Установить точку:
function PtPos (constref pt:TPtPosF         ): TPtPos;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=Trunc(pt.x);
  Result.y:=Trunc(pt.y);
end; {$endregion}
function PtPos (constref pos_x,pos_y:integer): TPtPos;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=pos_x;
  Result.y:=pos_y;
end; {$endregion}
function PtPosF(constref pt:TPtPos          ): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=pt.x;
  Result.y:=pt.y;
end; {$endregion}
function PtPosF(constref pos_x,pos_y:double ): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=pos_x;
  Result.y:=pos_y;
end; {$endregion}
function PtPosF(constref pos_x,pos_y:integer): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=pos_x;
  Result.y:=pos_y;
end; {$endregion}

// (Bounding Rectangle of Points Set) Ограничиваюший прямоугольник множества точек:
function PtsRngRctCalc    (constref pts:T1PtPosFArr; var rct_bnd_ind_arr:TEnum2Arr; constref start_pts_ind:integer=0; constref end_pts_ind:integer=0): TRect; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr                                : PPtPosF;
  min_x,min_y,max_x,max_y                : double;
  ind_min_x,ind_min_y,ind_max_x,ind_max_y: integer;
  i                                      : integer;
begin

  {Misc. Precalc.-----------------} {$region -fold}
  Result:=Default(TRect);

  ind_min_x:=0;
  ind_min_y:=0;
  ind_max_x:=0;
  ind_max_y:=0;

  min_x:=pts[start_pts_ind].x;
  min_y:=pts[start_pts_ind].y;
  max_x:=pts[start_pts_ind].x;
  max_y:=pts[start_pts_ind].y; {$endregion}

  {Calc. of Rectangle-------------} {$region -fold}
  pts_ptr:=Unaligned(@pts[start_pts_ind]);
  for i:=start_pts_ind to end_pts_ind do
    begin
      if ({Trunc(}pts_ptr^.x{)}<=min_x) then
        begin
          min_x    :={Trunc(}pts_ptr^.x{)};
          ind_min_x:=i;
        end;
      if ({Trunc(}pts_ptr^.y{)}<=min_y) then
        begin
          min_y    :={Trunc(}pts_ptr^.y{)};
          ind_min_y:=i;
        end;
      if ({Trunc(}pts_ptr^.x{)}>=max_x) then
        begin
          max_x    :={Trunc(}pts_ptr^.x{)};
          ind_max_x:=i;
        end;
      if ({Trunc(}pts_ptr^.y{)}>=max_y) then
        begin
          max_y    :={Trunc(}pts_ptr^.y{)};
          ind_max_y:=i;
        end;
      Inc(pts_ptr);
    end; {$endregion}

  {Set Rectangle------------------} {$region -fold}
  with Result do
    begin
      left  :=Trunc(pts[ind_min_x].x)+0;
      top   :=Trunc(pts[ind_min_y].y)+0;
      right :=Trunc(pts[ind_max_x].x)+1;
      bottom:=Trunc(pts[ind_max_y].y)+1;
      width :=right-left;
      height:=bottom-top;
    end; {$endregion}

  {Save Indices of Borders(Points)} {$region -fold}
  rct_bnd_ind_arr[0]:=ind_min_x;
  rct_bnd_ind_arr[1]:=ind_min_y;
  rct_bnd_ind_arr[2]:=ind_max_x;
  rct_bnd_ind_arr[3]:=ind_max_y; {$endregion}

end; {$endregion}
function PtsRngIndsRctCalc(constref pts:T1PtPosFArr; constref sel_pts_inds:T1IntrArr; constref pts_cnt:integer                                      ): TRect; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr                                : PPtPosF;
  sel_pts_inds_ptr                       : PInteger;
  min_x,min_y,max_x,max_y                : double;
  ind_min_x,ind_min_y,ind_max_x,ind_max_y: integer;
  i                                      : integer;
begin

  {Misc. Precalc.----} {$region -fold}
  Result:=Default(TRect);

  ind_min_x:=0;
  ind_min_y:=0;
  ind_max_x:=0;
  ind_max_y:=0;

  min_x:=pts[sel_pts_inds[0]].x;
  min_y:=pts[sel_pts_inds[0]].y;
  max_x:=pts[sel_pts_inds[0]].x;
  max_y:=pts[sel_pts_inds[0]].y; {$endregion}

  {Calc. of Rectangle} {$region -fold}
  pts_ptr         :=Unaligned(@pts         [0]);
  sel_pts_inds_ptr:=Unaligned(@sel_pts_inds[0]);
  for i:=0 to pts_cnt-1 do
    begin
      if ((pts_ptr+sel_pts_inds_ptr^)^.x<=min_x) then
        begin
          min_x    :=(pts_ptr+sel_pts_inds_ptr^)^.x;
          ind_min_x:=sel_pts_inds_ptr^;
        end;
      if ((pts_ptr+sel_pts_inds_ptr^)^.y<=min_y) then
        begin
          min_y    :=(pts_ptr+sel_pts_inds_ptr^)^.y;
          ind_min_y:=sel_pts_inds_ptr^;
        end;
      if ((pts_ptr+sel_pts_inds_ptr^)^.x>=max_x) then
        begin
          max_x    :=(pts_ptr+sel_pts_inds_ptr^)^.x;
          ind_max_x:=sel_pts_inds_ptr^;
        end;
      if ((pts_ptr+sel_pts_inds_ptr^)^.y>=max_y) then
        begin
          max_y    :=(pts_ptr+sel_pts_inds_ptr^)^.y;
          ind_max_y:=sel_pts_inds_ptr^;
        end;
      Inc(sel_pts_inds_ptr);
    end; {$endregion}

  {Set Rectangle-----} {$region -fold}
  with Result do
    begin
      left  :=Trunc(pts[ind_min_x].x)+0;
      top   :=Trunc(pts[ind_min_y].y)+0;
      right :=Trunc(pts[ind_max_x].x)+1;
      bottom:=Trunc(pts[ind_max_y].y)+1;
      width :=right-left;
      height:=bottom-top;
    end; {$endregion}

end; {$endregion}

// (Set Rectangle) Установить прямоугольник:
procedure PtRct   (constref pts:T1PtPosFArr; constref rct_bnd_ind_arr:TEnum2Arr; var rct:TRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct do
    begin
      left  :=Trunc(pts[rct_bnd_ind_arr[0]].x)+0;
      top   :=Trunc(pts[rct_bnd_ind_arr[1]].y)+0;
      right :=Trunc(pts[rct_bnd_ind_arr[2]].x)+1;
      bottom:=Trunc(pts[rct_bnd_ind_arr[3]].y)+1;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function PtRctB   (constref rct_left,rct_top,rct_right,rct_bottom:integer): TPtRectB;            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=Default(TPtrectB);
  with Result.pt_rct do
    begin
      left  :=rct_left  ;
      top   :=rct_top   ;
      right :=rct_right ;
      bottom:=rct_bottom;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function PtRct    (constref rct_left,rct_top,rct_right,rct_bottom:integer): TPtRect;             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct_left  ;
      top   :=rct_top   ;
      right :=rct_right ;
      bottom:=rct_bottom;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function PtRct    (constref rct:TRect                                    ): TPtRect;             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct.left  ;
      top   :=rct.top   ;
      right :=rct.right ;
      bottom:=rct.bottom;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function PtRct    (constref rct:TPtRectF                                 ): TPtRect;             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=Trunc(rct.left  );
      top   :=Trunc(rct.top   );
      right :=Trunc(rct.right );
      bottom:=Trunc(rct.bottom);
      width :=right -left;
      height:=bottom-top ;
    end;
end; {$endregion}
function PtRct    (constref rct:T1PtPosFArr                              ): TPtRect;             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=Trunc(rct[0].x);
      top   :=Trunc(rct[0].y);
      right :=Trunc(rct[1].x);
      bottom:=Trunc(rct[1].y);
      width :=right -left;
      height:=bottom-top ;
    end;
end; {$endregion}
function PtBounds (constref rct_left,rct_top,rct_width,rct_height:integer): TPtRect;             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct_left  ;
      top   :=rct_top   ;
      width :=rct_width ;
      height:=rct_height;
      right :=left+width;
      bottom:=top+height;
    end;
end; {$endregion}
function PtBounds (constref rct:TRect                                    ): TPtRect;             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct.left  ;
      top   :=rct.top   ;
      width :=rct.width ;
      height:=rct.height;
      right :=left+width;
      bottom:=top+height;
    end;
end; {$endregion}
function PtBoundsF(constref rct_left,rct_top,rct_width,rct_height:integer): TPtRectF;            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct_left  ;
      top   :=rct_top   ;
      width :=rct_width ;
      height:=rct_height;
      right :=left+width;
      bottom:=top+height;
    end;
end; {$endregion}

// (Inner Clipped Rectangle) Внутренний обрезанный прямоугольник:
function ClippedRctB(constref outer_rect,                  inner_rect:TPtRect; var nt_pix_clp_type,pt_pix_clp_type:byte): TPtRectB; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b_coll_arr: array[0..3] of boolean;
  b_coll    : longword absolute b_coll_arr;
begin
  with Result do
    begin
      b_left  :=(outer_rect.left  >=inner_rect.left  );
      b_top   :=(outer_rect.top   >=inner_rect.top   );
      b_right :=(outer_rect.right <=inner_rect.right );
      b_bottom:=(outer_rect.bottom<=inner_rect.bottom);
      with pt_rct do
        begin
          if b_left then
            left  :=outer_rect.left
          else
            left  :=inner_rect.left;
          if b_top then
            top   :=outer_rect.top
          else
            top   :=inner_rect.top;
          if b_right then
            right :=outer_rect.right
          else
            right :=inner_rect.right;
          if b_bottom then
            bottom:=outer_rect.bottom
          else
            bottom:=inner_rect.bottom;
          {if (outer_rect.left  >=inner_rect.right ) then
            begin
              width:=0;
              Exit;
            end;
          if (outer_rect.right <=inner_rect.left  ) then
            begin
              width:=0;
              Exit;
            end;
          if (outer_rect.top   >=inner_rect.bottom) then
            begin
              height:=0;
              Exit;
            end;
          if (outer_rect.bottom<=inner_rect.top   ) then
            begin
              height:=0;
              Exit;
            end;}
          width   :=right -left;
          height  :=bottom-top;
        end;
      b_coll_arr[0]:=b_left  ;
      b_coll_arr[1]:=b_top   ;
      b_coll_arr[2]:=b_right ;
      b_coll_arr[3]:=b_bottom;
    end;
  case b_coll of
    {No Clip--------------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    0       {%00000000000000000000000000000000}:
      begin
        nt_pix_clp_type:=0;
        pt_pix_clp_type:=0;
      end;
    {Top-Clipped----------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    256     {%00000000000000000000000100000000},
    {Bottom-Clipped-------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16777216{%00000001000000000000000000000000},
    {Top-Bottom-Clipped---------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16777472{%00000001000000000000000100000000}:
      begin
        nt_pix_clp_type:=1;
        pt_pix_clp_type:=1;
      end;
    {Left-Clipped---------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    1       {%00000000000000000000000000000001},
    {Left-Top-Clipped-----------------}
             { |e.b.   |e.b.   |e.b.   |e.b.   }
    257     {%00000000000000000000000100000001},
    {Left-Bottom-Clipped--------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16777217{%00000001000000000000000000000001},
    {Top-Left-Bottom-Clipped----------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16777473{%00000001000000000000000100000001},
    {Right-Clipped--------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    65536   {%00000000000000010000000000000000},
    {Right-Top-Clipped----------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    65792   {%00000000000000010000000100000000},
    {Right-Bottom-Clipped-------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16842752{%00000001000000010000000000000000},
    {Top-Right-Bottom-Clipped---------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16843008{%00000001000000010000000100000000},
    {Left-Top-Right-Clipped-----------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    65793   {%00000000000000010000000100000001},
    {Left-Bottom-Right-Clipped--------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16842753{%00000001000000010000000000000001},
    {Left-Right-Clipped---------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    65537   {%00000000000000010000000000000001},
    {Left-Top-Right-Bottom-Clipped----}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16843009{%00000001000000010000000100000001}:
      begin
        nt_pix_clp_type:=2;
        pt_pix_clp_type:=2;
      end;
  end;
end; {$endregion}
function ClippedRctB(constref outer_rect,                  inner_rect:TPtRect                                          ): TPtRectB; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      b_left  :=(outer_rect.left  >=inner_rect.left  );
      b_top   :=(outer_rect.top   >=inner_rect.top   );
      b_right :=(outer_rect.right <=inner_rect.right );
      b_bottom:=(outer_rect.bottom<=inner_rect.bottom);
      with pt_rct do
        begin
          if b_left then
            left  :=outer_rect.left
          else
            left  :=inner_rect.left;
          if b_top then
            top   :=outer_rect.top
          else
            top   :=inner_rect.top;
          if b_right then
            right :=outer_rect.right
          else
            right :=inner_rect.right;
          if b_bottom then
            bottom:=outer_rect.bottom
          else
            bottom:=inner_rect.bottom;
          {if (outer_rect.left  >=inner_rect.right ) then
            begin
              width:=0;
              Exit;
            end;
          if (outer_rect.right <=inner_rect.left  ) then
            begin
              width:=0;
              Exit;
            end;
          if (outer_rect.top   >=inner_rect.bottom) then
            begin
              height:=0;
              Exit;
            end;
          if (outer_rect.bottom<=inner_rect.top   ) then
            begin
              height:=0;
              Exit;
            end;}
          width :=right -left;
          height:=bottom-top;
        end;
    end;
end; {$endregion}
function ClippedRct (constref outer_rect,                  inner_rect:TPtRect                                          ): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (outer_rect.left  >=inner_rect.left  ) then
        left  :=outer_rect.left
      else
        left  :=inner_rect.left;
      if (outer_rect.top   >=inner_rect.top   ) then
        top   :=outer_rect.top
      else
        top   :=inner_rect.top;
      if (outer_rect.right <=inner_rect.right ) then
        right :=outer_rect.right
      else
        right :=inner_rect.right;
      if (outer_rect.bottom<=inner_rect.bottom) then
        bottom:=outer_rect.bottom
      else
        bottom:=inner_rect.bottom;
      if (outer_rect.left  >=inner_rect.right ) or
         (outer_rect.right <=inner_rect.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (outer_rect.top   >=inner_rect.bottom) or
         (outer_rect.bottom<=inner_rect.top   ) then
        begin
          height:=0;
          Exit;
        end;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedRct (constref outer_rect:TPtRect; constref inner_rect:TPtRectF                                         ): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (outer_rect.left  >=inner_rect.left  ) then
        left  :=Trunc(outer_rect.left)
      else
        left  :=Trunc(inner_rect.left);
      if (outer_rect.top   >=inner_rect.top   ) then
        top   :=Trunc(outer_rect.top)
      else
        top   :=Trunc(inner_rect.top);
      if (outer_rect.right <=inner_rect.right ) then
        right :=Trunc(outer_rect.right)
      else
        right :=Trunc(inner_rect.right);
      if (outer_rect.bottom<=inner_rect.bottom) then
        bottom:=Trunc(outer_rect.bottom)
      else
        bottom:=Trunc(inner_rect.bottom);
      if (outer_rect.left  >=inner_rect.right ) or
         (outer_rect.right <=inner_rect.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (outer_rect.top   >=inner_rect.bottom) or
         (outer_rect.bottom<=inner_rect.top   ) then
        begin
          height:=0;
          Exit;
        end;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedRct (constref outer_rect,                  inner_rect:TRect                                            ): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (outer_rect.left  >=inner_rect.left  ) then
        left  :=outer_rect.left
      else
        left  :=inner_rect.left;
      if (outer_rect.top   >=inner_rect.top   ) then
        top   :=outer_rect.top
      else
        top   :=inner_rect.top;
      if (outer_rect.right <=inner_rect.right ) then
        right :=outer_rect.right
      else
        right :=inner_rect.right;
      if (outer_rect.bottom<=inner_rect.bottom) then
        bottom:=outer_rect.bottom
      else
        bottom:=inner_rect.bottom;
      if (outer_rect.left  >=inner_rect.right ) or
         (outer_rect.right <=inner_rect.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (outer_rect.top   >=inner_rect.bottom) or
         (outer_rect.bottom<=inner_rect.top   ) then
        begin
          height:=0;
          Exit;
        end;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedRct (constref outer_rect:TPtRect; constref inner_rect:TRect                                            ): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (outer_rect.left  >=inner_rect.left  ) then
        left  :=outer_rect.left
      else
        left  :=inner_rect.left;
      if (outer_rect.top   >=inner_rect.top   ) then
        top   :=outer_rect.top
      else
        top   :=inner_rect.top;
      if (outer_rect.right <=inner_rect.right ) then
        right :=outer_rect.right
      else
        right :=inner_rect.right;
      if (outer_rect.bottom<=inner_rect.bottom) then
        bottom:=outer_rect.bottom
      else
        bottom:=inner_rect.bottom;
      if (outer_rect.left  >=inner_rect.right ) or
         (outer_rect.right <=inner_rect.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (outer_rect.top   >=inner_rect.bottom) or
         (outer_rect.bottom<=inner_rect.top   ) then
        begin
          height:=0;
          Exit;
        end;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedRct (constref outer_rect:TPtRect; constref inner_rect:TRect; b:boolean                                 ): TRect;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (outer_rect.left  >=inner_rect.left  ) then
        left  :=outer_rect.left
      else
        left  :=inner_rect.left;
      if (outer_rect.top   >=inner_rect.top   ) then
        top   :=outer_rect.top
      else
        top   :=inner_rect.top;
      if (outer_rect.right <=inner_rect.right ) then
        right :=outer_rect.right
      else
        right :=inner_rect.right;
      if (outer_rect.bottom<=inner_rect.bottom) then
        bottom:=outer_rect.bottom
      else
        bottom:=inner_rect.bottom;
      if (outer_rect.left  >=inner_rect.right ) or
         (outer_rect.right <=inner_rect.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (outer_rect.top   >=inner_rect.bottom) or
         (outer_rect.bottom<=inner_rect.top   ) then
        begin
          height:=0;
          Exit;
        end;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedRct (constref outer_rect,                  inner_rect:TRect; b:boolean                                 ): TRect;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (outer_rect.left  >=inner_rect.left  ) then
        left  :=outer_rect.left
      else
        left  :=inner_rect.left;
      if (outer_rect.top   >=inner_rect.top   ) then
        top   :=outer_rect.top
      else
        top   :=inner_rect.top;
      if (outer_rect.right <=inner_rect.right ) then
        right :=outer_rect.right
      else
        right :=inner_rect.right;
      if (outer_rect.bottom<=inner_rect.bottom) then
        bottom:=outer_rect.bottom
      else
        bottom:=inner_rect.bottom;
      if (outer_rect.left  >=inner_rect.right ) or
         (outer_rect.right <=inner_rect.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (outer_rect.top   >=inner_rect.bottom) or
         (outer_rect.bottom<=inner_rect.top   ) then
        begin
          height:=0;
          Exit;
        end;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedArr (constref rct_src   :TPtRect; constref rct_dst:TPtRectB; constref arr_src_width:longword           ): integer;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b_coll_arr   : array[0..3] of boolean;
  b_coll       : longword absolute b_coll_arr;
begin
  Result:=0;
  b_coll_arr[0]:=rct_dst.b_left  ;
  b_coll_arr[1]:=rct_dst.b_top   ;
  b_coll_arr[2]:=rct_dst.b_right ;
  b_coll_arr[3]:=rct_dst.b_bottom;
  case b_coll of
    {No Clip--------------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    0       {%00000000000000000000000000000000},
    {Left-Clipped---------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    1       {%00000000000000000000000000000001},
    {Top-Clipped----------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    256     {%00000000000000000000000100000000},
    {Bottom-Clipped-------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16777216{%00000001000000000000000000000000},
    {Left-Top-Clipped-----------------}
             { |e.b.   |e.b.   |e.b.   |e.b.   }
    257     {%00000000000000000000000100000001},
    {Left-Bottom-Clipped--------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16777217{%00000001000000000000000000000001},
    {Top-Bottom-Clipped---------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16777472{%00000001000000000000000100000000},
    {Top-Left-Bottom-Clipped----------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16777473{%00000001000000000000000100000001}:
      Result:=rct_src.left;
    {Right-Clipped--------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    65536   {%00000000000000010000000000000000},
    {Right-Top-Clipped----------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    65792   {%00000000000000010000000100000000},
    {Right-Bottom-Clipped-------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16842752{%00000001000000010000000000000000},
    {Top-Right-Bottom-Clipped---------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16843008{%00000001000000010000000100000000},
    {Left-Top-Right-Clipped-----------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    65793   {%00000000000000010000000100000001},
    {Left-Bottom-Right-Clipped--------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16842753{%00000001000000010000000000000001},
    {Left-Right-Clipped---------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    65537   {%00000000000000010000000000000001},
    {Left-Top-Right-Bottom-Clipped----}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16843009{%00000001000000010000000100000001}:
      Result:=arr_src_width-rct_src.width;
  end;
end; {$endregion}

// (Find Rectangle Which Has Not Coprime Width and Height(GCD(src_rect.Width,src_rect.Height)<>1) for source rectangle src_rect) Находит прямоугольник с не взаимно простыми сторонами(GCD(src_rect.Width,src_rect.Height)<>1) для исходного прямоугольника src_rect:
function NCSRectCalc(constref rct_src:TRect; constref bucket_width,bucket_heigth:integer): TRect; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct_src.left;
      top   :=rct_src.top ;
      width :=(Trunc(rct_src.width /bucket_width )+1)*bucket_width ;
      height:=(Trunc(rct_src.height/bucket_heigth)+1)*bucket_heigth;
      right :=left+width;
      bottom:=top+height;
    end;
end; {$endregion}

// (Two Rectangles Bounding Rectangle 1) Ограничивающий прямоугольник для двух заданных прямоугольников:
function TwoRctsBoundingRct(constref rct1,rct2:TRect  ): TRect;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=Min(rct1.left  ,rct2.left  );
      top   :=Min(rct1.top   ,rct2.top   );
      right :=Max(rct1.right ,rct2.right );
      bottom:=Max(rct1.bottom,rct2.bottom);
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function TwoRctsBoundingRct(constref rct1,rct2:TPtRect): TPtRect; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=Min(rct1.left  ,rct2.left  );
      top   :=Min(rct1.top   ,rct2.top   );
      right :=Max(rct1.right ,rct2.right );
      bottom:=Max(rct1.bottom,rct2.bottom);
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}

// (Rectangle in Rectangle) Прямоугольник в прямоугольнике:
function IsRct1InRct2(constref rct1,                rct2:TRect  ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.left  >=rct2.left  ) and
          (rct1.top   >=rct2.top   ) and
          (rct1.right <=rct2.right ) and
          (rct1.bottom<=rct2.bottom);
end; {$endregion}
function IsRct1InRct2(constref rct1,                rct2:TPtRect): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.left  >=rct2.left  ) and
          (rct1.top   >=rct2.top   ) and
          (rct1.right <=rct2.right ) and
          (rct1.bottom<=rct2.bottom);
end; {$endregion}
function IsRct1InRct2(constref rct1:TRect; constref rct2:TPtRect): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.left  >=rct2.left  ) and
          (rct1.top   >=rct2.top   ) and
          (rct1.right <=rct2.right ) and
          (rct1.bottom<=rct2.bottom);
end; {$endregion}

// (Rectangle out of Rectangle) Прямоугольник вне прямоугольника:
function IsRct1OutOfRct2(constref rct1,                rct2:TRect  ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.right <=rct2.left  ) or
          (rct1.bottom<=rct2.top   ) or
          (rct1.left  >=rct2.right ) or
          (rct1.top   >=rct2.bottom);
end; {$endregion}
function IsRct1OutOfRct2(constref rct1,                rct2:TPtRect): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.right <=rct2.left  ) or
          (rct1.bottom<=rct2.top   ) or
          (rct1.left  >=rct2.right ) or
          (rct1.top   >=rct2.bottom);
end; {$endregion}
function IsRct1OutOfRct2(constref rct1:TRect; constref rct2:TPtRect): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.right <=rct2.left  ) or
          (rct1.bottom<=rct2.top   ) or
          (rct1.left  >=rct2.right ) or
          (rct1.top   >=rct2.bottom);
end; {$endregion}

// (Point in Rectangle) Точка в прямоугольнике:
function IsPtInRct(constref x,y:integer; constref rct_dst:TRect                        ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct_dst.left  <x) and
          (rct_dst.top   <y) and
          (rct_dst.right >x) and
          (rct_dst.bottom>y);
end; {$endregion}
function IsPtInRct(constref x,y:integer; constref rct_dst:TPtRect                      ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct_dst.left  <x) and
          (rct_dst.top   <y) and
          (rct_dst.right >x) and
          (rct_dst.bottom>y);
end; {$endregion}
function IsPtInRct(constref pt:TPtPos  ; constref rct_dst:TRect                        ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct_dst.left  <pt.x) and
          (rct_dst.top   <pt.y) and
          (rct_dst.right >pt.x) and
          (rct_dst.bottom>pt.y);
end; {$endregion}
function IsPtInRct(constref pt:TPtPos  ; constref rct_dst:TPtRect                      ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct_dst.left  <pt.x) and
          (rct_dst.top   <pt.y) and
          (rct_dst.right >pt.x) and
          (rct_dst.bottom>pt.y);
end; {$endregion}
function IsPtInRct(constref pt:TPtPosF ; constref rct_dst:TRect                        ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct_dst.left  <pt.x) and
          (rct_dst.top   <pt.y) and
          (rct_dst.right >pt.x) and
          (rct_dst.bottom>pt.y);
end; {$endregion}
function IsPtInRct(constref pt:TPtPosF ; constref rct_dst:TPtRect                      ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct_dst.left  <pt.x) and
          (rct_dst.top   <pt.y) and
          (rct_dst.right >pt.x) and
          (rct_dst.bottom>pt.y);
end; {$endregion}
function IsPtInRct(constref pt:TPtPosF ; constref rct_dst:TPtRect; constref rad:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct_dst.left  <pt.x-rad) and
          (rct_dst.top   <pt.y-rad) and
          (rct_dst.right >pt.x+rad) and
          (rct_dst.bottom>pt.y+rad);
end; {$endregion}

// (Point in Circle) Точка в окружности:
function IsPtInCrc(constref x,y,                 prec:integer; constref crc_dst:TCrPos ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x-crc_dst.x)*(x-crc_dst.x)+(y-crc_dst.x)*(y-crc_dst.x)<=(crc_dst.r+prec)*(crc_dst.r+prec);
end; {$endregion}
function IsPtInCrc(constref x,y,                 prec:integer; constref crc_dst:TCrPosF): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x-crc_dst.x)*(x-crc_dst.x)+(y-crc_dst.x)*(y-crc_dst.x)<=(crc_dst.r+prec)*(crc_dst.r+prec);
end; {$endregion}
function IsPtInCrc(constref x,y:double; constref prec:integer; constref crc_dst:TCrPosF): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x-crc_dst.x)*(x-crc_dst.x)+(y-crc_dst.x)*(y-crc_dst.x)<=(crc_dst.r+prec)*(crc_dst.r+prec);
end; {$endregion}

// (Distance Between Two Points) Расстояние между двумя точками:
function PtDist   (constref x0,y0,x1,y1:integer): double ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=sqrt((x1-x0)*(x1-x0)+(y1-y0)*(y1-y0));
end; {$endregion}
function PtDist   (constref x0,y0,x1,y1:double ): double ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=sqrt((x1-x0)*(x1-x0)+(y1-y0)*(y1-y0));
end; {$endregion}
function PtDistSqr(constref x0,y0,x1,y1:integer): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x1-x0)*(x1-x0)+(y1-y0)*(y1-y0);
end; {$endregion}
function PtDistSqr(constref x0,y0,x1,y1:integer): double ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x1-x0)*(x1-x0)+(y1-y0)*(y1-y0);
end; {$endregion}
function PtDistSqr(constref x0,y0,x1,y1:double ): double ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x1-x0)*(x1-x0)+(y1-y0)*(y1-y0);
end; {$endregion}

// (Line-Line Intersection Point) Точка пересечение двух линий:
function LineLineIntPt(constref x0,y0,x1,y1,v0,w0,v1,w1:double):TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      x:=-((x1-x0)*(v1*w0-v0*w1)-(v1-v0)*(x1*y0-x0*y1))/((x1-x0)*(w1-w0)-(v1-v0)*(y1-y0));
      y:= ((y1-y0)*x            +        (x1*y0-x0*y1))/ (x1-x0);
    end;
end; {$endregion}

// (Line-Circle Intersection Point) Точка пересечение линии и окружности:
function LineCircIntPt(constref x0,y0,x1,y1:double; constref crc_dst:TCrPosF): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k,b,g,s,h: double;
begin
  k:=(   y1-   y0)/(x1-x0);
  b:=(x1*y0-x0*y1)/(x1-x0);
  with Result do
    begin
      g :=b-crc_dst.y;
      h :=1+k*k;
      s :=sqrt((g*k-crc_dst.x)*(g*k-crc_dst.x)-h*(g*g+crc_dst.x*crc_dst.x-crc_dst.r*crc_dst.r));
      x0:=(crc_dst.x-g*k-s)/h;
      x1:=(crc_dst.x-g*k+s)/h;
      y0:=k*x0+b;
      y1:=k*x1+b;
    end;
end; {$endregion}
function LineCircIntPt(constref x0,y0,x1,y1:double; constref x,y,r  :double ): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k,b,g,s,h: double;
begin
  k:=(   y1-   y0)/(x1-x0);
  b:=(x1*y0-x0*y1)/(x1-x0);
  with Result do
    begin
      g :=b-y;
      h :=1+k*k;
      s :=sqrt((g*k-x)*(g*k-x)-h*(g*g+x*x-r*r));
      x0:=(x-g*k-s)/h;
      x1:=(x-g*k+s)/h;
      y0:=k*x0+b;
      y1:=k*x1+b;
    end;
end; {$endregion}
function CrPosF       (                             constref x,y,r  :double ): TCrPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=x;
  Result.y:=y;
  Result.r:=r;
end; {$endregion}



(********************************** Blitters **********************************)

// Get Bitmap Handle:
function  GetBmpHandle  (bmp:Graphics.TBitmap): pointer; inline; {$region -fold}
var
  bmp_info: TBitmapInfo;
begin
  bmp_info.bmiHeader.biSize       :=sizeof(BitmapInfo.bmiHeader);
  bmp_info.bmiHeader.biWidth      :=bmp.Width;
  bmp_info.bmiHeader.biHeight     :=-bmp.Height; // BitMap.Height will invert image on axis X
  bmp_info.bmiHeader.biPlanes     :=1;
  bmp_info.bmiHeader.biBitCount   :=32;
  bmp_info.bmiHeader.biCompression:=BI_RGB;
  bmp.Handle:=CreateDIBSection(bmp.Canvas.Handle,bmp_info,DIB_RGB_COLORS,GetBmpHandle,0,0);
end; {$endregion}
procedure GLBitmapToRect(texture_id:longint; bmp:Graphics.TBitmap; b:boolean); inline; {$region -fold}
begin
  if (not b) then
    glDisable(GL_TEXTURE_2D)
  else
    begin
      glEnable     (GL_TEXTURE_2D);
      glGenTextures(1,@texture_id);
      glBindTexture(GL_TEXTURE_2D,texture_id);
    end;
end; {$endregion}

// Copy One Canvas To Another:
procedure CnvToCnv(rct_dst:TPtRect; cnv_dst,cnv_src:TCanvas; copy_mode:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {$ifdef Windows}
  BitBlt(cnv_dst.Handle,
         rct_dst.left,
         rct_dst.top,
         rct_dst.width,
         rct_dst.height,
         cnv_src.Handle,
         0,
         0,
         copy_mode);
  {$else}
  with cnv_dst do
    begin
      CopyMode:=copy_mode;
      CopyRect(rct_dst,cnv_src,Rect(0,0,rct_dst.width,rct_dst.height));
    end;
  {$endif}
end; {$endregion}

// Blitter1:
procedure BitBlt1(constref bmp_src_ptr,bmp_dst_ptr:PInteger ; constref rct_src:TPtRect;                             constref rct_dst_left,rct_dst_top,bmp_src_width,bmp_dst_width:integer);                                {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  bits_per_line: integer;
  y            : integer;
begin
  bits_per_line:=rct_src.width<<2;
  src_pixel_ptr:=Unaligned(@bmp_src_ptr[rct_src.left+rct_src.top*bmp_src_width]);
  dst_pixel_ptr:=Unaligned(@bmp_dst_ptr[rct_dst_left+rct_dst_top*bmp_dst_width]);
  for y:=0 to rct_src.height-1 do
    begin
      Move(src_pixel_ptr^,dst_pixel_ptr^,bits_per_line);
      Inc (src_pixel_ptr,bmp_src_width);
      Inc (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure BitBlt1(constref bmp_src_ptr,bmp_dst_ptr:PInteger ; constref rct_src_left,rct_src_top,rct_src_width,rct_src_height,rct_dst_left,rct_dst_top,bmp_src_width,bmp_dst_width:integer);                                {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  bits_per_line: integer;
  y            : integer;
begin
  bits_per_line:=rct_src_width<<2;
  src_pixel_ptr:=Unaligned(@bmp_src_ptr[rct_src_left+rct_src_top*bmp_src_width]);
  dst_pixel_ptr:=Unaligned(@bmp_dst_ptr[rct_dst_left+rct_dst_top*bmp_dst_width]);
  for y:=0 to rct_src_height-1 do
    begin
      Move(src_pixel_ptr^,dst_pixel_ptr^,bits_per_line);
      Inc (src_pixel_ptr,bmp_src_width);
      Inc (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure BitBlt1(var      arr_src                :T1IntrArr; constref                          rct_src_width,rct_src_height,rct_dst_left,rct_dst_top                            :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_med       : T1IntrArr;
  arr_med_ptr   : PInteger;
  arr_src_ptr   : PInteger;
  bits_per_line : integer;
  y             : integer;
  arr_src_width : integer;
  arr_src_height: integer;
begin
  arr_src_width := rct_dst_left+rct_src_width;
  arr_src_height:= rct_dst_top +rct_src_height;
  SetLength     (  arr_med,    (rct_src_width*rct_src_height));
  arr_med       := arr_src;
  SetLength     (  arr_src     ,arr_src_width*arr_src_height);
  FillDWord     ((@arr_src[0])^,arr_src_width*arr_src_height,0);
  arr_med_ptr   :=@arr_med[00000000000000000000000000000000000000];
  arr_src_ptr   :=@arr_src[rct_dst_left+rct_dst_top*arr_src_width];
  bits_per_line := rct_src_width<<2;
  for y:=0 to rct_src_height-1 do
    begin
      Move(arr_med_ptr^,arr_src_ptr^,bits_per_line);
      Inc (arr_med_ptr,rct_src_width);
      Inc (arr_src_ptr,arr_src_width);
    end;
  SetLength(arr_med,0);
end; {$endregion}

// Blitter2:
procedure BitBlt2(constref bmp_src_ptr,bmp_dst_ptr:PInteger ; constref rct_src:TPtRect;                             constref rct_dst_left,rct_dst_top,bmp_src_width,bmp_dst_width:integer); {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(@bmp_src_ptr[rct_src.left+rct_src.width-1+(rct_src.top+rct_src.height-1)*bmp_src_width]);
  dst_pixel_ptr:=Unaligned(@bmp_dst_ptr[rct_dst_left+rct_src.width-1+(rct_dst_top+rct_src.height-1)*bmp_dst_width]);
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
              dst_pixel_ptr^:=
              src_pixel_ptr^;
          Dec(src_pixel_ptr);
          Dec(dst_pixel_ptr);
        end;
      Dec    (src_pixel_ptr,d_width1);
      Dec    (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
procedure BitBlt2(constref bmp_src_ptr,bmp_dst_ptr:PInteger ; constref rct_src_left,rct_src_top,rct_src_width,rct_src_height,rct_dst_left,rct_dst_top,bmp_src_width,bmp_dst_width:integer); {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  d_width1         :=bmp_src_width-rct_src_width;
  d_width2         :=bmp_dst_width-rct_src_width;
  src_pixel_ptr    :=Unaligned(@bmp_src_ptr[rct_src_left+rct_src_width-1+(rct_src_top+rct_src_height-1)*bmp_src_width]);
  dst_pixel_ptr    :=Unaligned(@bmp_dst_ptr[rct_dst_left+rct_src_width-1+(rct_dst_top+rct_src_height-1)*bmp_dst_width]);
  for y:=0 to rct_src_height-1 do
    begin
      for x:=0 to rct_src_width-1 do
        begin
              dst_pixel_ptr^:=
              src_pixel_ptr^;
          Dec(src_pixel_ptr);
          Dec(dst_pixel_ptr);
        end;
      Dec    (src_pixel_ptr,d_width1);
      Dec    (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}

// Blitter3:
procedure BitBlt3(constref bmp_src_ptr,bmp_dst_ptr:PInteger ; constref rct_src:TPtRect;                             constref rct_dst_left,rct_dst_top,bmp_src_width,bmp_dst_width:integer; transparent_color:integer); {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(@bmp_src_ptr[rct_src.left+rct_src.width-1+(rct_src.top+rct_src.height-1)*bmp_src_width]);
  dst_pixel_ptr:=Unaligned(@bmp_dst_ptr[rct_dst_left+rct_src.width-1+(rct_dst_top+rct_src.height-1)*bmp_dst_width]);
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
          if (src_pixel_ptr^<>transparent_color) then
              dst_pixel_ptr^:=src_pixel_ptr^;
          Dec(src_pixel_ptr);
          Dec(dst_pixel_ptr);
        end;
      Dec    (src_pixel_ptr,d_width1);
      Dec    (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
procedure BitBlt3(constref bmp_src_ptr,bmp_dst_ptr:PInteger ; constref rct_src_left,rct_src_top,rct_src_width,rct_src_height,rct_dst_left,rct_dst_top,bmp_src_width,bmp_dst_width:integer; transparent_color:integer); {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  d_width1         :=bmp_src_width-rct_src_width;
  d_width2         :=bmp_dst_width-rct_src_width;
  src_pixel_ptr    :=Unaligned(@bmp_src_ptr[rct_src_left+rct_src_width-1+(rct_src_top+rct_src_height-1)*bmp_src_width]);
  dst_pixel_ptr    :=Unaligned(@bmp_dst_ptr[rct_dst_left+rct_src_width-1+(rct_dst_top+rct_src_height-1)*bmp_dst_width]);
  for y:=0 to rct_src_height-1 do
    begin
      for x:=0 to rct_src_width-1 do
        begin
          if (src_pixel_ptr^<>transparent_color) then
              dst_pixel_ptr^:=
              src_pixel_ptr^;
          Dec(src_pixel_ptr);
          Dec(dst_pixel_ptr);
        end;
      Dec    (src_pixel_ptr,d_width1);
      Dec    (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}



(******************************* Image Transform ******************************)

// Scale:
procedure ITScaleDown(constref bmp_src_ptr:PInteger; constref bmp_dst_ptr:PInteger; constref bmp_dst_width,bmp_dst_height:integer; constref ker_w,ker_h: integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  bmp_src_ptr2: PInteger;
  bmp_src_ptr3: PInteger;
  bmp_dst_ptr2: PInteger;
  ker_prod_inv: double;
  ker_prod    : integer;
  ker_h_prod  : integer;
  ker_w_int   : integer;
  ker_h_int   : integer;
  d_width_ker : integer;
  width_j_prod: integer;
  w,h         : integer;
  x,y         : integer;
  i,j         : integer;
  r,g,b       : integer;
begin
  ker_w_int   :=ker_w-1;
  ker_h_int   :=ker_h-1;
  ker_prod    :=ker_w*ker_h;
  ker_prod_inv:=1/ker_prod;
  ker_h_prod  :=ker_h*bmp_dst_width;
  w           :=Trunc(bmp_dst_width /ker_w)-1;
  h           :=Trunc(bmp_dst_height/ker_h)-1;
  d_width_ker :=bmp_dst_width-w-1;
  bmp_src_ptr2:=bmp_src_ptr;
  bmp_dst_ptr2:=bmp_dst_ptr;
  for y:=0 to h do
    begin
      for x:=0 to w do
        begin
          bmp_src_ptr3:=Unaligned(bmp_src_ptr2+x*ker_w+y*ker_h_prod);
          width_j_prod:=0;
          r           :=0;
          for j:=0 to ker_h_int do
            begin
              for i:=0 to ker_w_int do
                r+=Red((bmp_src_ptr3+i+width_j_prod)^);
              Inc(width_j_prod,bmp_dst_width);
            end;
          width_j_prod:=0;
          g           :=0;
          for j:=0 to ker_h_int do
            begin
              for i:=0 to ker_w_int do
                g+=Green((bmp_src_ptr3+i+width_j_prod)^);
              Inc(width_j_prod,bmp_dst_width);
            end;
          width_j_prod:=0;
          b           :=0;
          for j:=0 to ker_h_int do
            begin
              for i:=0 to ker_w_int do
                b+=Blue((bmp_src_ptr3+i+width_j_prod)^);
              Inc(width_j_prod,bmp_dst_width);
            end;
          bmp_dst_ptr2^:=RGB(Trunc(r*ker_prod_inv),
                             Trunc(g*ker_prod_inv),
                             Trunc(b*ker_prod_inv));
          Inc(bmp_dst_ptr2);
        end;
      Inc(bmp_dst_ptr2,d_width_ker);
      //Application.ProcessMessages;
    end;
end; {$endregion}



(******************************* Post-Processing ******************************)

procedure PPDec2ProcInit;  {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPDec2Proc[000]:=Unaligned(@AlphablendDec2);
  PPDec2Proc[001]:=Unaligned(@AdditiveDec2  );
  PPDec2Proc[002]:=Unaligned(@AlphablendDec2);
  PPDec2Proc[003]:=Unaligned(@InverseDec2   );
  PPDec2Proc[004]:=Unaligned(@HighlightDec2 );
  PPDec2Proc[005]:=Unaligned(@DarkenDec2    );
  PPDec2Proc[006]:=Unaligned(@GrayscaleRDec2);
  PPDec2Proc[007]:=Unaligned(@GrayscaleGDec2);
  PPDec2Proc[008]:=Unaligned(@GrayscaleBDec2);
  PPDec2Proc[009]:=Unaligned(@AlphablendDec2);
end; {$endregion}
procedure ArrFillProcInit; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  ArrFillProc[000]:=Unaligned(@ArrFillProc0);
  ArrFillProc[001]:=Unaligned(@ArrFillProc1);
  ArrFillProc[002]:=Unaligned(@ArrFillProc2);
  ArrFillProc[003]:=Unaligned(@ArrFillProc3);
  ArrFillProc[004]:=Unaligned(@ArrFillProc4);
  ArrFillProc[005]:=Unaligned(@ArrFillProc5);
  ArrFillProc[006]:=Unaligned(@ArrFillProc6);
  ArrFillProc[007]:=Unaligned(@ArrFillProc7);
  ArrFillProc[008]:=Unaligned(@ArrFillProc8);
  ArrFillProc[009]:=Unaligned(@ArrFillProc9);
end; {$endregion}
procedure PPBlurProcInit;  {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPBlurProc[00]:=Unaligned(@PPBlurProc00);
  PPBlurProc[01]:=Unaligned(@PPBlurProc01);
  PPBlurProc[02]:=Unaligned(@PPBlurProc02);
  PPBlurProc[03]:=Unaligned(@PPBlurProc03);
  PPBlurProc[04]:=Unaligned(@PPBlurProc04);
  PPBlurProc[05]:=Unaligned(@PPBlurProc05);
  PPBlurProc[06]:=Unaligned(@PPBlurProc06);
  PPBlurProc[07]:=Unaligned(@PPBlurProc07);
  PPBlurProc[08]:=Unaligned(@PPBlurProc08);
  PPBlurProc[09]:=Unaligned(@PPBlurProc09);
  PPBlurProc[10]:=Unaligned(@PPBlurProc10);
  PPBlurProc[11]:=Unaligned(@PPBlurProc11);
end; {$endregion}

// (Flood Fill) Заливка:
procedure PPFloodFillAdd     (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer);                       {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
             (dst_pixel_ptr)^-=-1;
          Inc(dst_pixel_ptr);
        end;
      Inc    (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPFloodFillSub     (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer);                       {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
             (dst_pixel_ptr)^-=1;
          Inc(dst_pixel_ptr);
        end;
      Inc    (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPFloodFill        (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer; constref col:integer); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  y            : integer;
begin
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      FillDWord(dst_pixel_ptr^,rct_dst.width,col);
      Inc      (dst_pixel_ptr ,bmp_dst_width    );
    end;
end; {$endregion}
procedure PPFloodFill        (                  constref             bmp_dst_ptr:PInteger; constref bmp_dst_width:integer; constref rct_dst_width,rct_dst_height,first_pix_pos:integer;       constref col:TColor ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  pix          : integer;
  x,y          : integer;
begin
  if (rct_dst_width=0) or (rct_dst_height=0) then
    Exit;
  pix          :=RGB(Blue(col),Green(col),Red(col));
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+first_pix_pos);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst_height-1 do
    begin
      FillDWord(dst_pixel_ptr^,rct_dst_width,pix);
      Inc      (dst_pixel_ptr ,bmp_dst_width    );
    end;
end; {$endregion}
procedure PPFloodFill        (                  constref             bmp_dst:Graphics.TBitmap;                                                                                                constref col:TColor ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  raw_image     : TRawImage;
  pixel_ptr     : PInteger;
  pixel_row_ptr : PInteger;
  byte_per_pixel: integer;
  x,y           : integer;
begin
  bmp_dst.BeginUpdate(False);
  bmp_dst.PixelFormat:=pf32bit;
  raw_image      :=bmp_dst.RawImage;
  pixel_row_ptr  :=PInteger(raw_image.Data);
  byte_per_pixel :=Trunc(raw_image.Description.BitsPerPixel>>3);
  for y:=0 to bmp_dst.height-1 do
    begin
      pixel_ptr:=pixel_row_ptr;
      for x:=0 to bmp_dst.width-1 do
        begin
                    pixel_ptr^:=col;
          Inc(PByte(pixel_ptr),byte_per_pixel);
        end;
      Inc(PByte(pixel_row_ptr),raw_image.Description.BytesPerLine);
    end;
  bmp_dst.EndUpdate(False);
end; {$endregion}

// (Additive) Аддитивное смешивание:
procedure PPAdditive         (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect ; constref               bmp_dst_width:integer; constref col:TColor                      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  r,g,b        : byte;
begin
  r            :=Red  (col);
  g            :=Green(col);
  b            :=Blue (col);
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(@bmp_dst_ptr[rct_dst.left+rct_dst.top*bmp_dst_width]);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                   dst_pixel_ptr^:=
          Additive(dst_pixel_ptr^,b,g,r);
          Inc     (dst_pixel_ptr);
        end;
      Inc         (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPAdditive         (                  constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref rct_src:TPtRect; constref rct_dst:TPtRectB; constref bmp_src_width,bmp_dst_width:integer                                           ); {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(bmp_src_ptr+rct_src.       left+rct_src.       top*bmp_src_width);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.pt_rct.left+rct_dst.pt_rct.top*bmp_dst_width);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
                   dst_pixel_ptr^  :=
          Additive(dst_pixel_ptr^  ,
             Blue (src_pixel_ptr^) ,
             Green(src_pixel_ptr^) ,
             Red  (src_pixel_ptr^));
          Inc     (src_pixel_ptr ) ;
          Inc     (dst_pixel_ptr ) ;
        end;
      Inc         (src_pixel_ptr,d_width1);
      Inc         (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
procedure PPAdditiveDec      (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect ; constref               bmp_dst_width:integer; constref col:TColor; constref pow:byte=64); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  r,g,b        : byte;
begin
  r            :=Red  (col);
  g            :=Green(col);
  b            :=Blue (col);
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                      dst_pixel_ptr^:=
          AdditiveDec(dst_pixel_ptr^,b,g,r,pow);
          Inc        (dst_pixel_ptr);
        end;
      Inc            (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPAdditiveDec      (                  constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref rct_src:TPtRect; constref rct_dst:TPtRectB; constref bmp_src_width,bmp_dst_width:integer;                      constref pow:byte=64); {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(bmp_src_ptr+rct_src.       left+rct_src.       top*bmp_src_width);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.pt_rct.left+rct_dst.pt_rct.top*bmp_dst_width);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
                      dst_pixel_ptr^ :=
          AdditiveDec(dst_pixel_ptr^ ,
                Blue (src_pixel_ptr^),
                Green(src_pixel_ptr^),
                Red  (src_pixel_ptr^),
                pow);
          Inc        (src_pixel_ptr );
          Inc        (dst_pixel_ptr );
        end;
      Inc            (src_pixel_ptr,d_width1);
      Inc            (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}

// (AlphaBlend) Полупрозрачность:
procedure PPAlphaBlend       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect ; constref               bmp_dst_width:integer; constref col:TColor; constref pow:byte=64); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  r,g,b        : byte;
  alpha,d_alpha: byte;
begin
  r            :=Red  (col);
  g            :=Green(col);
  b            :=Blue (col);
  alpha        :=pow;
  d_alpha      :=255-alpha;
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                     dst_pixel_ptr^:=
          AlphaBlend(dst_pixel_ptr^,b,g,r,alpha,d_alpha);
          Inc       (dst_pixel_ptr);
        end;
      Inc           (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPAlphaBlend       (                  constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref rct_src:TPtRect; constref rct_dst:TPtRectB; constref bmp_src_width,bmp_dst_width:integer;                      constref pow:byte=64); {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(bmp_src_ptr+rct_src.       left+rct_src.       top*bmp_src_width);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.pt_rct.left+rct_dst.pt_rct.top*bmp_dst_width);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
                     dst_pixel_ptr^ :=
          AlphaBlend(dst_pixel_ptr^ ,
               Blue (src_pixel_ptr^),
               Green(src_pixel_ptr^),
               Red  (src_pixel_ptr^),
                   pow,
               255-pow);
          Inc       (src_pixel_ptr );
          Inc       (dst_pixel_ptr );
        end;
      Inc           (src_pixel_ptr,d_width1);
      Inc           (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}

// (Inverse) Инверсия:
procedure PPInverse          (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer                      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                   dst_pixel_ptr^ :=
          Inverse (dst_pixel_ptr^);
          Inc     (dst_pixel_ptr );
        end;
      Inc         (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPInverseDec       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer; constref pow:byte=64); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                     dst_pixel_ptr^:=
          InverseDec(dst_pixel_ptr^,pow);
          Inc       (dst_pixel_ptr);
        end;
      Inc           (dst_pixel_ptr,d_width);
    end;
end; {$endregion}

// (HighLight) Подсветка:
procedure PPHighlight        (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer; constref pow:byte=64); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                    dst_pixel_ptr^:=
          Highlight(dst_pixel_ptr^,0,0,0,0,0,pow);
          Inc      (dst_pixel_ptr);
        end;
      Inc          (dst_pixel_ptr,d_width);
    end;
end; {$endregion}

// (Darken) Затемнение:
procedure PPDarken           (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer; constref pow:byte=64); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                 dst_pixel_ptr^:=
          Darken(dst_pixel_ptr^,0,0,0,0,0,pow);
          Inc   (dst_pixel_ptr);
        end;
      Inc       (dst_pixel_ptr,d_width);
    end;
end; {$endregion}

// (GrayscaleR) Серый оттенок: красный канал:
procedure PPGrayscaleR       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer                      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                     dst_pixel_ptr^ :=
          GrayscaleR(dst_pixel_ptr^);
          Inc       (dst_pixel_ptr );
        end;
      Inc           (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPGrayscaleRDec    (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer; constref pow:byte=64); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                        dst_pixel_ptr^:=
          GrayscaleRDec(dst_pixel_ptr^,pow);
          Inc          (dst_pixel_ptr);
        end;
      Inc              (dst_pixel_ptr,d_width);
    end;
end; {$endregion}

// (GrayscaleG) Серый оттенок: зеленый канал:
procedure PPGrayscaleG       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer                      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                     dst_pixel_ptr^ :=
          GrayscaleG(dst_pixel_ptr^);
          Inc       (dst_pixel_ptr );
        end;
      Inc           (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPGrayscaleGDec    (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer; constref pow:byte=64); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                        dst_pixel_ptr^:=
          GrayscaleGDec(dst_pixel_ptr^,pow);
          Inc          (dst_pixel_ptr);
        end;
      Inc              (dst_pixel_ptr,d_width);
    end;
end; {$endregion}

// (GrayscaleB) Серый оттенок: синий   канал:
procedure PPGrayscaleB       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer                      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                     dst_pixel_ptr^ :=
          GrayscaleB(dst_pixel_ptr^);
          Inc       (dst_pixel_ptr );
        end;
      Inc           (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPGrayscaleBDec    (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer; constref pow:byte=64); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                        dst_pixel_ptr^:=
          GrayscaleBDec(dst_pixel_ptr^,pow);
          Inc          (dst_pixel_ptr);
        end;
      Inc              (dst_pixel_ptr,d_width);
    end;
end; {$endregion}

// (Monochrome Noise) Монохромный шум:
procedure PPMonoNoise        (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer; constref col:TColor                      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if Odd(dst_pixel_ptr^) then
                 dst_pixel_ptr^:=col;
          Inc   (dst_pixel_ptr);
        end;
      Inc       (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPMonoNoiseDec     (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer; constref col:TColor; constref pow:byte=64); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  r,g,b        : byte;
  alpha,d_alpha: byte;
begin
  r            :=Red  (col);
  g            :=Green(col);
  b            :=Blue (col);
  alpha        :=pow;
  d_alpha      :=255-pow;
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if Odd    (dst_pixel_ptr^) then
                     dst_pixel_ptr^:=
          AlphaBlend(dst_pixel_ptr^,b,g,r,alpha,d_alpha);
          Inc       (dst_pixel_ptr);
        end;
      Inc           (dst_pixel_ptr,d_width);
    end;
end; {$endregion}

// (Blur) Размытие:
procedure PPBlurProc00       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          (pixel_ptr4+bmp_dst_width+1)^:=RGB((Byte(    ((pixel_ptr4+0)^)>>00)+Byte(    ((pixel_ptr4+2)^)>>00)+Byte(    ((pixel_ptr4+bmp_dst_width<<1)^)>>00)+Byte(    ((pixel_ptr4+bmp_dst_width<<1+2)^)>>00))>>2,
                                             (Byte(Word((pixel_ptr4+0)^)>>08)+Byte(Word((pixel_ptr4+2)^)>>08)+Byte(Word((pixel_ptr4+bmp_dst_width<<1)^)>>08)+Byte(Word((pixel_ptr4+bmp_dst_width<<1+2)^)>>08))>>2,
                                             (Byte(    ((pixel_ptr4+0)^)>>16)+Byte(    ((pixel_ptr4+2)^)>>16)+Byte(    ((pixel_ptr4+bmp_dst_width<<1)^)>>16)+Byte(    ((pixel_ptr4+bmp_dst_width<<1+2)^)>>16))>>2);
          Inc(pixel_ptr4);
        end;
      Inc(pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc01       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
  r          : byte;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          r                            :=        (Byte(((pixel_ptr4)^)>>00)+Byte(((pixel_ptr4+2)^)>>00)+Byte(((pixel_ptr4+bmp_dst_width<<1)^)>>00)+Byte(((pixel_ptr4+bmp_dst_width<<1+2)^)>>00))>>2;
          (pixel_ptr4+bmp_dst_width+1)^:=RGB(r,r,(Byte(((pixel_ptr4)^)>>16)+Byte(((pixel_ptr4+2)^)>>16)+Byte(((pixel_ptr4+bmp_dst_width<<1)^)>>16)+Byte(((pixel_ptr4+bmp_dst_width<<1+2)^)>>16))>>2);
          Inc(pixel_ptr4);
        end;
      Inc(pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc02       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
  r          : byte;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          r                            :=      (Byte(    ((pixel_ptr4)^)>>00)+Byte(    ((pixel_ptr4+2)^)>>00)+Byte(    ((pixel_ptr4+bmp_dst_width<<1)^)>>00)+Byte(    ((pixel_ptr4+bmp_dst_width<<1+2)^)>>00))>>2;
          (pixel_ptr4+bmp_dst_width+1)^:=RGB(r,(Byte(Word((pixel_ptr4)^)>>08)+Byte(Word((pixel_ptr4+2)^)>>08)+Byte(Word((pixel_ptr4+bmp_dst_width<<1)^)>>08)+Byte(Word((pixel_ptr4+bmp_dst_width<<1+2)^)>>08))>>2,r);
          Inc(pixel_ptr4);
        end;
      Inc(pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc03       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
  g          : byte;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          g                            :=        (Byte(Word((pixel_ptr4)^)>>08)+Byte(Word((pixel_ptr4+2)^)>>08)+Byte(Word((pixel_ptr4+bmp_dst_width<<1)^)>>08)+Byte(Word((pixel_ptr4+bmp_dst_width<<1+2)^)>>08))>>2;
          (pixel_ptr4+bmp_dst_width+1)^:=RGB(g,g,(Byte(    ((pixel_ptr4)^)>>16)+Byte(    ((pixel_ptr4+2)^)>>16)+Byte(    ((pixel_ptr4+bmp_dst_width<<1)^)>>16)+Byte(    ((pixel_ptr4+bmp_dst_width<<1+2)^)>>16))>>2);
          Inc(pixel_ptr4);
        end;
      Inc(pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc04       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
  g          : byte;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          g                            :=    (Byte(Word((pixel_ptr4)^)>>08)+Byte(Word((pixel_ptr4+2)^)>>08)+Byte(Word((pixel_ptr4+bmp_dst_width<<1)^)>>08)+Byte(Word((pixel_ptr4+bmp_dst_width<<1+2)^)>>08))>>2;
          (pixel_ptr4+bmp_dst_width+1)^:=RGB((Byte(    ((pixel_ptr4)^)>>00)+Byte(    ((pixel_ptr4+2)^)>>00)+Byte(    ((pixel_ptr4+bmp_dst_width<<1)^)>>00)+Byte(    ((pixel_ptr4+bmp_dst_width<<1+2)^)>>00))>>2,g,g);
          Inc(pixel_ptr4);
        end;
      Inc(pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc05       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
  b          : byte;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          b                            :=      (Byte(    ((pixel_ptr4)^)>>16)+Byte(    ((pixel_ptr4+2)^)>>16)+Byte(    ((pixel_ptr4+bmp_dst_width<<1)^)>>16)+Byte(    ((pixel_ptr4+bmp_dst_width<<1+2)^)>>16))>>2;
          (pixel_ptr4+bmp_dst_width+1)^:=RGB(b,(Byte(Word((pixel_ptr4)^)>>08)+Byte(Word((pixel_ptr4+2)^)>>08)+Byte(Word((pixel_ptr4+bmp_dst_width<<1)^)>>08)+Byte(Word((pixel_ptr4+bmp_dst_width<<1+2)^)>>08))>>2,b);
          Inc(pixel_ptr4);
        end;
      Inc(pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc06       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
  b          : byte;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          b                            :=    (Byte(((pixel_ptr4)^)>>16)+Byte(((pixel_ptr4+2)^)>>16)+Byte(((pixel_ptr4+bmp_dst_width<<1)^)>>16)+Byte(((pixel_ptr4+bmp_dst_width<<1+2)^)>>16))>>2;
          (pixel_ptr4+bmp_dst_width+1)^:=RGB((Byte(((pixel_ptr4)^)>>00)+Byte(((pixel_ptr4+2)^)>>00)+Byte(((pixel_ptr4+bmp_dst_width<<1)^)>>00)+Byte(((pixel_ptr4+bmp_dst_width<<1+2)^)>>00))>>2,b,b);
          Inc(pixel_ptr4);
        end;
      Inc(pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc07       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
  r          : byte;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          r:=(Red((pixel_ptr4+0                 )^)+
              Red((pixel_ptr4+2                 )^)+
              Red((pixel_ptr4+0+bmp_dst_width<<1)^)+
              Red((pixel_ptr4+2+bmp_dst_width<<1)^))>>2;
          (pixel_ptr4+bmp_dst_width+1)^:=RGB(r,r,r);
          Inc(pixel_ptr4);
        end;
      Inc(pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc08       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
  g          : byte;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          g:=(Green((pixel_ptr4+0                 )^)+
              Green((pixel_ptr4+2                 )^)+
              Green((pixel_ptr4+0+bmp_dst_width<<1)^)+
              Green((pixel_ptr4+2+bmp_dst_width<<1)^))>>2;
          (pixel_ptr4+bmp_dst_width+1)^:=RGB(g,g,g);
          Inc(pixel_ptr4);
        end;
      Inc(pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc09       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
  b          : byte;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          b:=(Blue((pixel_ptr4+0                 )^)+
              Blue((pixel_ptr4+2                 )^)+
              Blue((pixel_ptr4+0+bmp_dst_width<<1)^)+
              Blue((pixel_ptr4+2+bmp_dst_width<<1)^))>>2;
          (pixel_ptr4+bmp_dst_width+1)^:=RGB(b,b,b);
          Inc(pixel_ptr4);
        end;
      Inc(pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc10       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          (pixel_ptr4+bmp_dst_width+1)^:=RGB((Byte(    ((pixel_ptr4)^)>>00)+Byte(    ((pixel_ptr4+1)^)>>00)+Byte(    ((pixel_ptr4+2)^)>>00)+Byte(    ((pixel_ptr4+bmp_dst_width)^)>>00)+Byte(    ((pixel_ptr4+bmp_dst_width+2)^)>>00)+Byte(    ((pixel_ptr4+bmp_dst_width<<1)^)>>00)+Byte(    ((pixel_ptr4+bmp_dst_width<<1+1)^)>>00)+Byte(    ((pixel_ptr4+bmp_dst_width<<1+2)^)>>00))>>3,
                                             (Byte(Word((pixel_ptr4)^)>>08)+Byte(Word((pixel_ptr4+1)^)>>08)+Byte(Word((pixel_ptr4+2)^)>>08)+Byte(Word((pixel_ptr4+bmp_dst_width)^)>>08)+Byte(Word((pixel_ptr4+bmp_dst_width+2)^)>>08)+Byte(Word((pixel_ptr4+bmp_dst_width<<1)^)>>08)+Byte(Word((pixel_ptr4+bmp_dst_width<<1+1)^)>>08)+Byte(Word((pixel_ptr4+bmp_dst_width<<1+2)^)>>08))>>3,
                                             (Byte(    ((pixel_ptr4)^)>>16)+Byte(    ((pixel_ptr4+1)^)>>16)+Byte(    ((pixel_ptr4+2)^)>>16)+Byte(    ((pixel_ptr4+bmp_dst_width)^)>>16)+Byte(    ((pixel_ptr4+bmp_dst_width+2)^)>>16)+Byte(    ((pixel_ptr4+bmp_dst_width<<1)^)>>16)+Byte(    ((pixel_ptr4+bmp_dst_width<<1+1)^)>>16)+Byte(    ((pixel_ptr4+bmp_dst_width<<1+2)^)>>16))>>3);
          Inc(pixel_ptr4);
        end;
      Inc(pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc11       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          if (Byte(    ((pixel_ptr4+bmp_dst_width+1)^)>>00)>200) and
             (Byte(Word((pixel_ptr4+bmp_dst_width+1)^)>>08)>200) and
             (Byte(    ((pixel_ptr4+bmp_dst_width+1)^)>>16)>200) then
          (pixel_ptr4+bmp_dst_width+1)^:=RGB((Byte(    ((pixel_ptr4+0)^)>>00)+Byte(    ((pixel_ptr4+2)^)>>00)+Byte(    ((pixel_ptr4+bmp_dst_width<<1)^)>>00)+Byte(    ((pixel_ptr4+bmp_dst_width<<1+2)^)>>00))>>2,
                                             (Byte(Word((pixel_ptr4+0)^)>>08)+Byte(Word((pixel_ptr4+2)^)>>08)+Byte(Word((pixel_ptr4+bmp_dst_width<<1)^)>>08)+Byte(Word((pixel_ptr4+bmp_dst_width<<1+2)^)>>08))>>2,
                                             (Byte(    ((pixel_ptr4+0)^)>>16)+Byte(    ((pixel_ptr4+2)^)>>16)+Byte(    ((pixel_ptr4+bmp_dst_width<<1)^)>>16)+Byte(    ((pixel_ptr4+bmp_dst_width<<1+2)^)>>16))>>2);
          Inc(pixel_ptr4);
        end;
      Inc(pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlur             (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer; constref blur_type:byte=0; constref border_filter:TBorderFilter=efNotTiled); {$region -fold}
var
  pixel_ptr0,pixel_ptr1,pixel_ptr2,pixel_ptr3,pixel_ptr4: PInteger;
  i,j,d_width                                           : integer;
  r0,r1,r2,r3,r4,r5,r6,r7,r8                            : byte;
  g0,g1,g2,g3,g4,g5,g6,g7,g8                            : byte;
  b0,b1,b2,b3,b4,b5,b6,b7,b8                            : byte;
  r,g,b                                                 : byte;
begin

  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;

  d_width:=bmp_dst_width-rct_dst.width;

  // left -top    pixel
  pixel_ptr0:=Unaligned(bmp_dst_ptr+rct_dst.left+                bmp_dst_width* rct_dst.top                  );
  // right-top    pixel
  pixel_ptr1:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.width-1+bmp_dst_width* rct_dst.top                  );
  // left -bottom pixel
  pixel_ptr2:=Unaligned(bmp_dst_ptr+rct_dst.left+                bmp_dst_width*(rct_dst.top+rct_dst.height-1));
  // right-bottom pixel
  pixel_ptr3:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.width-1+bmp_dst_width*(rct_dst.top+rct_dst.height-1));

  pixel_ptr4:=pixel_ptr0;

  {Borders-------------} {$region -fold}

  case border_filter of

    efNotTiled:
      begin

        {Left-Top Pixel----} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
        pixel_ptr4^:=RGB((Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+1)^)+Red  ((pixel_ptr4+bmp_dst_width+0)^)+Red  ((pixel_ptr4+bmp_dst_width+1)^))>>2,
                         (Green((pixel_ptr4+0)^)+Green((pixel_ptr4+1)^)+Green((pixel_ptr4+bmp_dst_width+0)^)+Green((pixel_ptr4+bmp_dst_width+1)^))>>2,
                         (Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+1)^)+Blue ((pixel_ptr4+bmp_dst_width+0)^)+Blue ((pixel_ptr4+bmp_dst_width+1)^))>>2); {$endregion}

        {Right-Top Pixel---} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.width-1+bmp_dst_width*rct_dst.top);
        pixel_ptr4^:=RGB((Red  ((pixel_ptr4-1)^)+Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+bmp_dst_width-1)^)+Red  ((pixel_ptr4+bmp_dst_width+0)^))>>2,
                         (Green((pixel_ptr4-1)^)+Green((pixel_ptr4+0)^)+Green((pixel_ptr4+bmp_dst_width-1)^)+Green((pixel_ptr4+bmp_dst_width+0)^))>>2,
                         (Blue ((pixel_ptr4-1)^)+Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+bmp_dst_width-1)^)+Blue ((pixel_ptr4+bmp_dst_width+0)^))>>2); {$endregion}

        {Left-Bottom Pixel-} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*(rct_dst.top+rct_dst.height-1));
        pixel_ptr4^:=RGB((Red  ((pixel_ptr4-bmp_dst_width+0)^)+Red  ((pixel_ptr4-bmp_dst_width+1)^)+Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+1)^))>>2,
                         (Green((pixel_ptr4-bmp_dst_width+0)^)+Green((pixel_ptr4-bmp_dst_width+1)^)+Green((pixel_ptr4+0)^)+Green((pixel_ptr4+1)^))>>2,
                         (Blue ((pixel_ptr4-bmp_dst_width+0)^)+Blue ((pixel_ptr4-bmp_dst_width+1)^)+Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+1)^))>>2); {$endregion}

        {Right-Bottom Pixel} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.width-1+bmp_dst_width*(rct_dst.top+rct_dst.height-1));
        pixel_ptr4^:=RGB((Red  ((pixel_ptr4-bmp_dst_width-1)^)+Red  ((pixel_ptr4-bmp_dst_width+0)^)+Red  ((pixel_ptr4-1)^)+Red  ((pixel_ptr4+0)^))>>2,
                         (Green((pixel_ptr4-bmp_dst_width-1)^)+Green((pixel_ptr4-bmp_dst_width+0)^)+Green((pixel_ptr4-1)^)+Green((pixel_ptr4+0)^))>>2,
                         (Blue ((pixel_ptr4-bmp_dst_width-1)^)+Blue ((pixel_ptr4-bmp_dst_width+0)^)+Blue ((pixel_ptr4-1)^)+Blue ((pixel_ptr4+0)^))>>2); {$endregion}

        {Top Line----------} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+1+bmp_dst_width*rct_dst.top);
        for i:=0 to rct_dst.width-3 do
          begin
            pixel_ptr4^:=RGB(Trunc((Red  ((pixel_ptr4-1)^)+Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+1)^)+Red  ((pixel_ptr4+bmp_dst_width-1)^)+Red  ((pixel_ptr4+bmp_dst_width+0)^)+Red  ((pixel_ptr4+bmp_dst_width+1)^))/6),
                             Trunc((Green((pixel_ptr4-1)^)+Green((pixel_ptr4+0)^)+Green((pixel_ptr4+1)^)+Green((pixel_ptr4+bmp_dst_width-1)^)+Green((pixel_ptr4+bmp_dst_width+0)^)+Green((pixel_ptr4+bmp_dst_width+1)^))/6),
                             Trunc((Blue ((pixel_ptr4-1)^)+Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+1)^)+Blue ((pixel_ptr4+bmp_dst_width-1)^)+Blue ((pixel_ptr4+bmp_dst_width+0)^)+Blue ((pixel_ptr4+bmp_dst_width+1)^))/6));
            Inc(pixel_ptr4);
          end; {$endregion}

        {Left Line---------} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*(rct_dst.top+1));
        for j:=0 to rct_dst.height-3 do
          begin
            pixel_ptr4^:=RGB(Trunc((Red  ((pixel_ptr4-bmp_dst_width)^)+Red  ((pixel_ptr4-bmp_dst_width+1)^)+Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+1)^)+Red  ((pixel_ptr4+bmp_dst_width+0)^)+Red  ((pixel_ptr4+bmp_dst_width+1)^))/6),
                             Trunc((Green((pixel_ptr4-bmp_dst_width)^)+Green((pixel_ptr4-bmp_dst_width+1)^)+Green((pixel_ptr4+0)^)+Green((pixel_ptr4+1)^)+Green((pixel_ptr4+bmp_dst_width+0)^)+Green((pixel_ptr4+bmp_dst_width+1)^))/6),
                             Trunc((Blue ((pixel_ptr4-bmp_dst_width)^)+Blue ((pixel_ptr4-bmp_dst_width+1)^)+Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+1)^)+Blue ((pixel_ptr4+bmp_dst_width+0)^)+Blue ((pixel_ptr4+bmp_dst_width+1)^))/6));
            Inc(pixel_ptr4,bmp_dst_width);
          end; {$endregion}

        {Right Line--------} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.width-1+bmp_dst_width*(rct_dst.top+1));
        for j:=0 to rct_dst.height-3 do
          begin
            pixel_ptr4^:=RGB(Trunc((Red  ((pixel_ptr4-bmp_dst_width-1)^)+Red  ((pixel_ptr4-bmp_dst_width+0)^)+Red  ((pixel_ptr4-1)^)+Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+bmp_dst_width-1)^)+Red  ((pixel_ptr4+bmp_dst_width+0)^))/6),
                             Trunc((Green((pixel_ptr4-bmp_dst_width-1)^)+Green((pixel_ptr4-bmp_dst_width+0)^)+Green((pixel_ptr4-1)^)+Green((pixel_ptr4+0)^)+Green((pixel_ptr4+bmp_dst_width-1)^)+Green((pixel_ptr4+bmp_dst_width+0)^))/6),
                             Trunc((Blue ((pixel_ptr4-bmp_dst_width-1)^)+Blue ((pixel_ptr4-bmp_dst_width+0)^)+Blue ((pixel_ptr4-1)^)+Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+bmp_dst_width-1)^)+Blue ((pixel_ptr4+bmp_dst_width+0)^))/6));
            Inc(pixel_ptr4,bmp_dst_width);
          end; {$endregion}

        {Bottom Line-------} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+1+bmp_dst_width*(rct_dst.top+rct_dst.height-1));
        for i:=0 to rct_dst.width-3 do
          begin
            pixel_ptr4^:=RGB(Trunc((Red  ((pixel_ptr4-bmp_dst_width-1)^)+Red  ((pixel_ptr4-bmp_dst_width+0)^)+Red  ((pixel_ptr4-bmp_dst_width+1)^)+Red  ((pixel_ptr4-1)^)+Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+1)^))/6),
                             Trunc((Green((pixel_ptr4-bmp_dst_width-1)^)+Green((pixel_ptr4-bmp_dst_width+0)^)+Green((pixel_ptr4-bmp_dst_width+1)^)+Green((pixel_ptr4-1)^)+Green((pixel_ptr4+0)^)+Green((pixel_ptr4+1)^))/6),
                             Trunc((Blue ((pixel_ptr4-bmp_dst_width-1)^)+Blue ((pixel_ptr4-bmp_dst_width+0)^)+Blue ((pixel_ptr4-bmp_dst_width+1)^)+Blue ((pixel_ptr4-1)^)+Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+1)^))/6));
            Inc(pixel_ptr4);
          end; {$endregion}

      end;

    efTiled:  {TODO}
      begin

        {Left-Top Pixel----} {$region -fold}
        pixel_ptr4 :=Unaligned(@bmp_dst_ptr[rct_dst.left+bmp_dst_width*rct_dst.top]);
        pixel_ptr4^:=RGB((Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+1)^)+Red  ((pixel_ptr4+bmp_dst_width+0)^)+Red  ((pixel_ptr4+bmp_dst_width+1)^))>>2,
                         (Green((pixel_ptr4+0)^)+Green((pixel_ptr4+1)^)+Green((pixel_ptr4+bmp_dst_width+0)^)+Green((pixel_ptr4+bmp_dst_width+1)^))>>2,
                         (Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+1)^)+Blue ((pixel_ptr4+bmp_dst_width+0)^)+Blue ((pixel_ptr4+bmp_dst_width+1)^))>>2); {$endregion}
        {r0:=pixel_ptr3^{shr 0};
        g0:=pixel_ptr3^ shr 8 ;
        b0:=pixel_ptr3^ shr 16;
        r1:=pixel_ptr2^{shr 0};
        g1:=pixel_ptr2^ shr 8 ;
        b1:=pixel_ptr2^ shr 16;
        Inc(pixel_ptr2);
        r2:=pixel_ptr2^{shr 0};
        g2:=pixel_ptr2^ shr 8 ;
        b2:=pixel_ptr2^ shr 16;
        r3:=pixel_ptr1^{shr 0};
        g3:=pixel_ptr1^ shr 8 ;
        b3:=pixel_ptr1^ shr 16;
        r4:=pixel_ptr0^{shr 0};
        g4:=pixel_ptr0^ shr 8 ;
        b4:=pixel_ptr0^ shr 16;
        Inc(pixel_ptr0);
        r5:=pixel_ptr0^{shr 0};
        g5:=pixel_ptr0^ shr 8 ;
        b5:=pixel_ptr0^ shr 16;
        Inc(pixel_ptr1,bmp_dst_width);
        r6:=pixel_ptr1^{shr 0};
        g6:=pixel_ptr1^ shr 8 ;
        b6:=pixel_ptr1^ shr 16;
        Inc(pixel_ptr0,bmp_dst_width-1);
        r7:=pixel_ptr0^{shr 0};
        g7:=pixel_ptr0^ shr 8 ;
        b7:=pixel_ptr0^ shr 16;
        Inc(pixel_ptr0);
        r8:=pixel_ptr0^{shr 0};
        g8:=pixel_ptr0^ shr 8 ;
        b8:=pixel_ptr0^ shr 16;
        Dec(pixel_ptr0,bmp_dst_width+1); // Reset left -top    pixel pointer
        Dec(pixel_ptr1,bmp_dst_width);   // Reset right-top    pixel pointer
        Dec(pixel_ptr2);                 // Reset left -bottom pixel pointer
        r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
        g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
        b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
        pixel_ptr0^:=RGB(r,g,b); {$endregion}}

        {Right-Top Pixel---} {$region -fold}
        Dec(pixel_ptr3);
        r0:=pixel_ptr3^>>00;
        g0:=pixel_ptr3^>>08;
        b0:=pixel_ptr3^>>16;
        Inc(pixel_ptr3);
        r1:=pixel_ptr3^>>00;
        g1:=pixel_ptr3^>>08;
        b1:=pixel_ptr3^>>16;
        r2:=pixel_ptr2^>>00;
        g2:=pixel_ptr2^>>08;
        b2:=pixel_ptr2^>>16;
        Dec(pixel_ptr1);
        r3:=pixel_ptr1^>>00;
        g3:=pixel_ptr1^>>08;
        b3:=pixel_ptr1^>>16;
        Inc(pixel_ptr1);
        r4:=pixel_ptr1^>>00;
        g4:=pixel_ptr1^>>08;
        b4:=pixel_ptr1^>>16;
        r5:=pixel_ptr0^>>00;
        g5:=pixel_ptr0^>>08;
        b5:=pixel_ptr0^>>16;
        Inc(pixel_ptr1,bmp_dst_width-1);
        r6:=pixel_ptr1^>>00;
        g6:=pixel_ptr1^>>08;
        b6:=pixel_ptr1^>>16;
        Inc(pixel_ptr1);
        r7:=pixel_ptr1^>>00;
        g7:=pixel_ptr1^>>08;
        b7:=pixel_ptr1^>>16;
        Inc(pixel_ptr0,bmp_dst_width);
        r8:=pixel_ptr0^>>00;
        g8:=pixel_ptr0^>>08;
        b8:=pixel_ptr0^>>16;
        Dec(pixel_ptr0,bmp_dst_width); // Reset left -top pixel pointer
        Dec(pixel_ptr1,bmp_dst_width); // Reset right-top pixel pointer
        r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
        g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
        b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
        pixel_ptr1^:=RGB(r,g,b); {$endregion}

        {Left-Bottom Pixel-} {$region -fold}
        Dec(pixel_ptr3,bmp_dst_width);
        r0:=pixel_ptr3^>>00;
        g0:=pixel_ptr3^>>08;
        b0:=pixel_ptr3^>>16;
        Dec(pixel_ptr2,bmp_dst_width);
        r1:=pixel_ptr2^>>00;
        g1:=pixel_ptr2^>>08;
        b1:=pixel_ptr2^>>16;
        Inc(pixel_ptr2);
        r2:=pixel_ptr2^>>00;
        g2:=pixel_ptr2^>>08;
        b2:=pixel_ptr2^>>16;
        Inc(pixel_ptr3,bmp_dst_width);
        r3:=pixel_ptr3^>>00;
        g3:=pixel_ptr3^>>08;
        b3:=pixel_ptr3^>>16;
        Inc(pixel_ptr2,bmp_dst_width-1);
        r4:=pixel_ptr2^>>00;
        g4:=pixel_ptr2^>>08;
        b4:=pixel_ptr2^>>16;
        Inc(pixel_ptr2);
        r5:=pixel_ptr2^>>00;
        g5:=pixel_ptr2^>>08;
        b5:=pixel_ptr2^>>16;
        r6:=pixel_ptr1^>>00;
        g6:=pixel_ptr1^>>08;
        b6:=pixel_ptr1^>>16;
        r7:=pixel_ptr0^>>00;
        g7:=pixel_ptr0^>>08;
        b7:=pixel_ptr0^>>16;
        Inc(pixel_ptr0);
        r8:=pixel_ptr0^>>00;
        g8:=pixel_ptr0^>>08;
        b8:=pixel_ptr0^>>16;
        Dec(pixel_ptr0); // Reset left-top    pixel pointer
        Dec(pixel_ptr2); // Reset left-bottom pixel pointer
        r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
        g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
        b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
        pixel_ptr2^:=RGB(r,g,b); {$endregion}

        {Right-Bottom Pixel} {$region -fold}
        Dec(pixel_ptr3,bmp_dst_width+1);
        r0:=pixel_ptr3^>>00;
        g0:=pixel_ptr3^>>08;
        b0:=pixel_ptr3^>>16;
        Inc(pixel_ptr3);
        r1:=pixel_ptr3^>>00;
        g1:=pixel_ptr3^>>08;
        b1:=pixel_ptr3^>>16;
        Dec(pixel_ptr2,bmp_dst_width);
        r2:=pixel_ptr2^>>00;
        g2:=pixel_ptr2^>>08;
        b2:=pixel_ptr2^>>16;
        Inc(pixel_ptr3,bmp_dst_width-1);
        r3:=pixel_ptr3^>>00;
        g3:=pixel_ptr3^>>08;
        b3:=pixel_ptr3^>>16;
        Inc(pixel_ptr3);
        r4:=pixel_ptr3^>>00;
        g4:=pixel_ptr3^>>08;
        b4:=pixel_ptr3^>>16;
        Inc(pixel_ptr2,bmp_dst_width);
        r5:=pixel_ptr2^>>00;
        g5:=pixel_ptr2^>>08;
        b5:=pixel_ptr2^>>16;
        Dec(pixel_ptr1);
        r6:=pixel_ptr1^>>00;
        g6:=pixel_ptr1^>>08;
        b6:=pixel_ptr1^>>16;
        Inc(pixel_ptr1);
        r7:=pixel_ptr1^>>00;
        g7:=pixel_ptr1^>>08;
        b7:=pixel_ptr1^>>16;
        r8:=pixel_ptr0^>>00;
        g8:=pixel_ptr0^>>08;
        b8:=pixel_ptr0^>>16;
        r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
        g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
        b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
        pixel_ptr3^:=RGB(r,g,b); {$endregion}

        {Top Line----------} {$region -fold}
        for i:=1 to rct_dst.width-2 do
          begin
            r0:=pixel_ptr2^>>00;
            g0:=pixel_ptr2^>>08;
            b0:=pixel_ptr2^>>16;
            Inc(pixel_ptr2);
            r1:=pixel_ptr2^>>00;
            g1:=pixel_ptr2^>>08;
            b1:=pixel_ptr2^>>16;
            Inc(pixel_ptr2);
            r2:=pixel_ptr2^>>00;
            g2:=pixel_ptr2^>>08;
            b2:=pixel_ptr2^>>16;
            r3:=pixel_ptr0^>>00;
            g3:=pixel_ptr0^>>08;
            b3:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r4:=pixel_ptr0^>>00;
            g4:=pixel_ptr0^>>08;
            b4:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r5:=pixel_ptr0^>>00;
            g5:=pixel_ptr0^>>08;
            b5:=pixel_ptr0^>>16;
            Inc(pixel_ptr0,bmp_dst_width-2);
            r6:=pixel_ptr0^>>00;
            g6:=pixel_ptr0^>>08;
            b6:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r7:=pixel_ptr0^>>00;
            g7:=pixel_ptr0^>>08;
            b7:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r8:=pixel_ptr0^>>00;
            g8:=pixel_ptr0^>>08;
            b8:=pixel_ptr0^>>16;
            Dec(pixel_ptr0,bmp_dst_width+1);
            Dec(pixel_ptr2);
            r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
            g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
            b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
            pixel_ptr0^:=RGB(r,g,b);
          end;
        Dec(pixel_ptr0,rct_dst.width-2); // Reset left-top    pixel pointer
        Dec(pixel_ptr2,rct_dst.width-2); // Reset left-bottom pixel pointer
        {$endregion}

        {Left Line---------} {$region -fold}
        for j:=1 to rct_dst.height-2 do
          begin
            r0:=pixel_ptr1^>>00;
            g0:=pixel_ptr1^>>08;
            b0:=pixel_ptr1^>>16;
            r1:=pixel_ptr0^>>00;
            g1:=pixel_ptr0^>>08;
            b1:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r2:=pixel_ptr0^>>00;
            g2:=pixel_ptr0^>>08;
            b2:=pixel_ptr0^>>16;
            Inc(pixel_ptr1,bmp_dst_width);
            r3:=pixel_ptr1^>>00;
            g3:=pixel_ptr1^>>08;
            b3:=pixel_ptr1^>>16;
            Inc(pixel_ptr0,bmp_dst_width-1);
            r4:=pixel_ptr0^>>00;
            g4:=pixel_ptr0^>>08;
            b4:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r5:=pixel_ptr0^>>00;
            g5:=pixel_ptr0^>>08;
            b5:=pixel_ptr0^>>16;
            Inc(pixel_ptr1,bmp_dst_width);
            r6:=pixel_ptr1^>>00;
            g6:=pixel_ptr1^>>08;
            b6:=pixel_ptr1^>>16;
            Inc(pixel_ptr0,bmp_dst_width-1);
            r7:=pixel_ptr0^>>00;
            g7:=pixel_ptr0^>>08;
            b7:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r8:=pixel_ptr0^>>00;
            g8:=pixel_ptr0^>>08;
            b8:=pixel_ptr0^>>16;
            Dec(pixel_ptr0,bmp_dst_width+1);
            Dec(pixel_ptr1,bmp_dst_width);
            r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
            g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
            b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
            pixel_ptr0^:=RGB(r,g,b);
          end;
        Dec(pixel_ptr0,bmp_dst_width*(rct_dst.height-2)); // Reset left -top pixel pointer
        Dec(pixel_ptr1,bmp_dst_width*(rct_dst.height-2)); // Reset right-top pixel pointer
        {$endregion}

        {Right Line--------} {$region -fold}
        Dec(pixel_ptr1);
        for j:=1 to rct_dst.height-2 do
          begin
            r0:=pixel_ptr1^>>00;
            g0:=pixel_ptr1^>>08;
            b0:=pixel_ptr1^>>16;
            Inc(pixel_ptr1);
            r1:=pixel_ptr1^>>00;
            g1:=pixel_ptr1^>>08;
            b1:=pixel_ptr1^>>16;
            r2:=pixel_ptr0^>>00;
            g2:=pixel_ptr0^>>08;
            b2:=pixel_ptr0^>>16;
            Inc(pixel_ptr1,bmp_dst_width-1);
            r3:=pixel_ptr1^>>00;
            g3:=pixel_ptr1^>>08;
            b3:=pixel_ptr1^>>16;
            Inc(pixel_ptr1);
            r4:=pixel_ptr1^>>00;
            g4:=pixel_ptr1^>>08;
            b4:=pixel_ptr1^>>16;
            Inc(pixel_ptr0,bmp_dst_width);
            r5:=pixel_ptr0^>>00;
            g5:=pixel_ptr0^>>08;
            b5:=pixel_ptr0^>>16;
            Inc(pixel_ptr1,bmp_dst_width-1);
            r6:=pixel_ptr1^>>00;
            g6:=pixel_ptr1^>>08;
            b6:=pixel_ptr1^>>16;
            Inc(pixel_ptr1);
            r7:=pixel_ptr1^>>00;
            g7:=pixel_ptr1^>>08;
            b7:=pixel_ptr1^>>16;
            Inc(pixel_ptr0,bmp_dst_width);
            r8:=pixel_ptr0^>>00;
            g8:=pixel_ptr0^>>08;
            b8:=pixel_ptr0^>>16;
            Dec(pixel_ptr0,bmp_dst_width);
            Dec(pixel_ptr1,bmp_dst_width);
            r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
            g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
            b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
            pixel_ptr1^:=RGB(r,g,b);
            Dec(pixel_ptr1);
          end;
        Dec(pixel_ptr0,bmp_dst_width*(rct_dst.height-2));   // Reset left -top pixel pointer
        Dec(pixel_ptr1,bmp_dst_width*(rct_dst.height-2)-1); // Reset right-top pixel pointer
        {$endregion}

        {Bottom Line-------} {$region -fold}
        Dec(pixel_ptr2,bmp_dst_width);
        for i:=1 to rct_dst.width-2 do
          begin
            r0:=pixel_ptr2^>>00;
            g0:=pixel_ptr2^>>08;
            b0:=pixel_ptr2^>>16;
            Inc(pixel_ptr2);
            r1:=pixel_ptr2^>>00;
            g1:=pixel_ptr2^>>08;
            b1:=pixel_ptr2^>>16;
            Inc(pixel_ptr2);
            r2:=pixel_ptr2^>>00;
            g2:=pixel_ptr2^>>08;
            b2:=pixel_ptr2^>>16;
            Inc(pixel_ptr2,bmp_dst_width-2);
            r3:=pixel_ptr2^>>00;
            g3:=pixel_ptr2^>>08;
            b3:=pixel_ptr2^>>16;
            Inc(pixel_ptr2);
            r4:=pixel_ptr2^>>00;
            g4:=pixel_ptr2^>>08;
            b4:=pixel_ptr2^>>16;
            Inc(pixel_ptr2);
            r5:=pixel_ptr2^>>00;
            g5:=pixel_ptr2^>>08;
            b5:=pixel_ptr2^>>16;
            r6:=pixel_ptr0^>>00;
            g6:=pixel_ptr0^>>08;
            b6:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r7:=pixel_ptr0^>>00;
            g7:=pixel_ptr0^>>08;
            b7:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r8:=pixel_ptr0^>>00;
            g8:=pixel_ptr0^>>08;
            b8:=pixel_ptr0^>>16;
            Dec(pixel_ptr2);
            r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
            g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
            b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
            pixel_ptr2^:=RGB(r,g,b);
            Dec(pixel_ptr0);               // Reset left-top    pixel pointer
            Dec(pixel_ptr2,bmp_dst_width); // Reset left-bottom pixel pointer
          end;
        Dec(pixel_ptr0,rct_dst.width-2); // Reset left-top    pixel pointer
        Inc(pixel_ptr2,d_width+2);       // Reset left-bottom pixel pointer
        {$endregion}

      end;

  end; {$endregion}

  {Inner Rectangle Area} {$region -fold}
  {
  blur_type:
    00: {Fast----}
    01: {g to r--}
    02: {b to r--}
    03: {r to g--}
    04: {b to g--}
    05: {r to b--}
    06: {g to b--}
    07: {b,g to r}
    08: {r,b to g}
    09: {r,g to b}
    10: {Slow----}
  }
  PPBlurProc[blur_type](bmp_dst_ptr,rct_dst,bmp_dst_width); {$endregion}

end; {$endregion}
procedure PPBlur             (                  constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref rct_src:TPtRect; constref rct_dst:TPtRectB; constref bmp_src_width,bmp_dst_width:integer; constref blur_type:byte=0                                                 ); {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  if (rct_src.width<=0) or (rct_src.height<=0) then
    Exit;
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(bmp_src_ptr+rct_src.       left+rct_src.       top*bmp_src_width);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.pt_rct.left+rct_dst.pt_rct.top*bmp_dst_width);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
          if (src_pixel_ptr^>>24<>0) then
            dst_pixel_ptr^:=RGB((Byte(    ((dst_pixel_ptr-bmp_dst_width-1)^)>>00)+Byte(    ((dst_pixel_ptr-bmp_dst_width+1)^)>>00)+Byte(    ((dst_pixel_ptr+bmp_dst_width-1)^)>>00)+Byte(    ((dst_pixel_ptr+bmp_dst_width+1)^)>>00))>>2,
                                (Byte(Word((dst_pixel_ptr-bmp_dst_width-1)^)>>08)+Byte(Word((dst_pixel_ptr-bmp_dst_width+1)^)>>08)+Byte(Word((dst_pixel_ptr+bmp_dst_width-1)^)>>08)+Byte(Word((dst_pixel_ptr+bmp_dst_width+1)^)>>08))>>2,
                                (Byte(    ((dst_pixel_ptr-bmp_dst_width-1)^)>>16)+Byte(    ((dst_pixel_ptr-bmp_dst_width+1)^)>>16)+Byte(    ((dst_pixel_ptr+bmp_dst_width-1)^)>>16)+Byte(    ((dst_pixel_ptr+bmp_dst_width+1)^)>>16))>>2);
          Inc(src_pixel_ptr);
          Inc(dst_pixel_ptr);
        end;
      Inc(src_pixel_ptr,d_width1);
      Inc(dst_pixel_ptr,d_width2);
    end;
end; {$endregion}

// (Color Correction) Цветокоррекция:
procedure PPColorCorrectionM0(ColorizeM:TFunc0; constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer; constref pow:byte=32); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  d            : smallint;
begin
  if (pow>=128) then
    Exit;
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  d            :=(pow-128)<<1;
  d_width      := bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
              dst_pixel_ptr^:=ColorizeM(dst_pixel_ptr^,0,0,0,0,0,0,d);
          Inc(dst_pixel_ptr);
        end;
      Inc(dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPColorCorrectionP0(ColorizeP:TFunc0; constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:integer; constref pow:byte=32); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  d            : smallint;
begin
  if (pow<128) then
    Exit;
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  d            :=(pow-128)<<1;
  d_width      := bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
              dst_pixel_ptr^:=ColorizeP(dst_pixel_ptr^,0,0,0,0,0,0,d);
          Inc(dst_pixel_ptr);
        end;
      Inc(dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPColorCorrectionM0(ColorizeM:TFunc0; constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref rct_src:TPtRect; constref rct_dst:TPtRectB; constref bmp_src_width,bmp_dst_width:integer; constref pow:byte=32); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  d_width1     : integer;
  d_width2     : integer;
  x,y          : integer;
  d            : smallint;
begin
  if (pow>=128) then
    Exit;
  if (rct_src.width<=0) or (rct_src.height<=0) then
    Exit;
  d            :=(pow-128)<<1;
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(bmp_src_ptr+rct_src.       left+rct_src.       top*bmp_src_width);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.pt_rct.left+rct_dst.pt_rct.top*bmp_dst_width);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
          if (src_pixel_ptr^>>24<>0) then
            dst_pixel_ptr^:=ColorizeM(dst_pixel_ptr^,0,0,0,0,0,0,d);
          Inc(src_pixel_ptr);
          Inc(dst_pixel_ptr);
        end;
      Inc(src_pixel_ptr,d_width1);
      Inc(dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
procedure PPColorCorrectionP0(ColorizeP:TFunc0; constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref rct_src:TPtRect; constref rct_dst:TPtRectB; constref bmp_src_width,bmp_dst_width:integer; constref pow:byte=32); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  d_width1     : integer;
  d_width2     : integer;
  x,y          : integer;
  d            : smallint;
begin
  if (pow<128) then
    Exit;
  if (rct_src.width<=0) or (rct_src.height<=0) then
    Exit;
  d            :=(pow-128)<<1;
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(bmp_src_ptr+rct_src.       left+rct_src.       top*bmp_src_width);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.pt_rct.left+rct_dst.pt_rct.top*bmp_dst_width);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
          if (src_pixel_ptr^>>24<>0) then
            dst_pixel_ptr^:=ColorizeP(dst_pixel_ptr^,0,0,0,0,0,0,d);
          Inc(src_pixel_ptr);
          Inc(dst_pixel_ptr);
        end;
      Inc(src_pixel_ptr,d_width1);
      Inc(dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
procedure PPColorCorrectionM1(ColorizeM:TFunc1; constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref rct_src:TPtRect; constref rct_dst:TPtRectB; constref bmp_src_width,bmp_dst_width:integer; constref pow:byte=32); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  d_width1     : integer;
  d_width2     : integer;
  x,y          : integer;
  d            : smallint;
begin
  if (pow>=128) then
    Exit;
  if (rct_src.width<=0) or (rct_src.height<=0) then
    Exit;
  d            :=(pow-128)<<1;
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(bmp_src_ptr+rct_src.       left+rct_src.       top*bmp_src_width);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.pt_rct.left+rct_dst.pt_rct.top*bmp_dst_width);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
          if (src_pixel_ptr^>>24=255) then
            dst_pixel_ptr^:=ColorizeM(dst_pixel_ptr^,0,d)
          else
          if (src_pixel_ptr^>>24<255) and (src_pixel_ptr^>>24>0) then
            dst_pixel_ptr^:=ColorizeM(dst_pixel_ptr^,255-src_pixel_ptr^>>24,d);
          Inc(src_pixel_ptr);
          Inc(dst_pixel_ptr);
        end;
      Inc(src_pixel_ptr,d_width1);
      Inc(dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
procedure PPColorCorrectionP1(ColorizeP:TFunc1; constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref rct_src:TPtRect; constref rct_dst:TPtRectB; constref bmp_src_width,bmp_dst_width:integer; constref pow:byte=32); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  d_width1     : integer;
  d_width2     : integer;
  x,y          : integer;
  d            : smallint;
begin
  if (pow<128) then
    Exit;
  if (rct_src.width<=0) or (rct_src.height<=0) then
    Exit;
  d            :=(pow-128)<<1;
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(bmp_src_ptr+rct_src.       left+rct_src.       top*bmp_src_width);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.pt_rct.left+rct_dst.pt_rct.top*bmp_dst_width);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
          if (src_pixel_ptr^>>24=255) then
            dst_pixel_ptr^:=ColorizeP(dst_pixel_ptr^,0,d)
          else
          if (src_pixel_ptr^>>24<255) and (src_pixel_ptr^>>24>0) then
            dst_pixel_ptr^:=ColorizeP(dst_pixel_ptr^,255-src_pixel_ptr^>>24,d);
          Inc(src_pixel_ptr);
          Inc(dst_pixel_ptr);
        end;
      Inc(src_pixel_ptr,d_width1);
      Inc(dst_pixel_ptr,d_width2);
    end;
end; {$endregion}

end.

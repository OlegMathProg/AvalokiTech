unit Fast_Primitives;

{This file contains some routines for fast drawing of primitives like a line,
rectangle,circle,rhombus and their miscellaneous variations, filters, blitters,
sprites processing etc.}

{$mode objfpc}{$H+,R-,Q-}{$modeswitch advancedrecords}

interface

uses

  {$ifdef Windows}Windows,{$endif}Graphics, Classes, FPCanvas, GraphType, Math, Types, TypInfo, SysUtils, GL;

const

  ONE_DIV_BY_SQRT_TWO=1/sqrt(2);
  ONE_MUL_1024       =1<<10;
  DEFAULT_SCL_MUL    =6/5;
  DEFAULT_SCL_MUL_INV=5/6;
  FULL_ROT           =pi/180;
  ONE_DIV_BY_FULL_ROT=1/FULL_ROT;
  MAX_SPRITE_WIDTH   =4096;
  MAX_SPRITE_HEIGHT  =4096;
  NT_BIT_MASK_ALPHA  =$FF000000;
  NZ_ITEM_COEFF10    =1+Trunc(ln(Double(MAXBYTE ))/ln(2));
  NZ_ITEM_COEFF20    =1<<NZ_ITEM_COEFF10-1;
  NZ_ITEM_COEFF11    =1+Trunc(ln(Double(MAXWORD ))/ln(2));
  NZ_ITEM_COEFF21    =1<<NZ_ITEM_COEFF11-1;
  NZ_ITEM_COEFF12    =1+Trunc(ln(Double(MAXDWORD))/ln(2));
  NZ_ITEM_COEFF22    =1<<NZ_ITEM_COEFF12-1;

type

  // Exdended to Be Able to Have ABGR Color Format: !!!!!!!!!!!!!!!!!!!!!!!!!!!!
  PInteger          =PLongWord;
  TColor            =LongWord{-$7FFFFFFF-1..$7FFFFFFF};
  PColor            =^TColor;
  TColorArr         =array of TColor;
  PColorArr         =^TColorArr;
  TColor2Arr        =array of array of TColor;
  PColor2Arr        =^TColor2Arr;



  {Forward Declarations********************************************************}
  TFastActorSet     =class;
  TFastActor        =class;
  TFastImage        =class;
  TFastLine         =class;
  TFastText         =class;
  {****************************************************************************}



  {Miscellaneous Types ********************************************************}
  {Direction Type}
  TMovingDirection  =(mdLeft,mdRight,mdUp,mdDown,mdLeftUp,mdRightUp,mdLeftDown,mdRightDown,mdNone);
  PMovingDirection  =^TMovingDirection;

  {Drawing Style}
  TDrawingStyle     =(dsMonochrome ,
                      dsAdditive   ,
                      dsAlphablend ,
                      dsInverse    ,
                      dsHighlight  ,
                      dsDarken     ,
                      dsGrayscaleR ,
                      dsGrayscaleG ,
                      dsGrayscaleB ,
                      dsMononoise  ,
                      dsColorizeRM ,
                      dsColorizeRP ,
                      dsColorizeGM ,
                      dsColorizeGP ,
                      dsColorizeBM ,
                      dsColorizeBP ,
                      dsBlurRGB    ,
                      dsBlurRRB    ,
                      dsBlurRGR    ,
                      dsBlurGGB    ,
                      dsBlurRGG    ,
                      dsBlurBGB    ,
                      dsBlurRBB    ,
                      dsBlurRRR    ,
                      dsBlurGGG    ,
                      dsBlurBBB    ,
                      dsGradientTBH,
                      dsGradientBTH,
                      dsGradientTBD,
                      dsGradientBTD);
  PDrawingStyle     =^TDrawingStyle;

  TDynamicsStyle    =(dsNone,dsSoft,dsSpring,dsRigid);
  PDynamicsStyle    =^TDynamicsStyle;

  {Spline Type}
  TSplineType       =(stFreeHand,stFormula,stRandom,stLoad);
  PSplineType       =^TSplineType;

  {Spline Mode}
  TSplineMode       =(smContinuous,smDiscrete,smSpray);
  PSplineMode       =^TSplineMode;

  {Selection}
  TSubgraphOp       =(soSub,soAdd);
  PSubgraphOp       =^TSubgraphOp;

  {Selection Mode}
  TSelectionMode     =(smCircle,smBrush,smRectangle,smRegion,smSelectAll);
  PSelectionMode     =^TSelectionMode;

  {Background Post-Processing}
  TBackgroundStyle   =(bsGrayscale,bsBlur,bsBoth,bsNone);
  PBackgroundStyle   =^TBackgroundStyle;

  {Clipping}
  TClipStyle        =(csClippedEdges1,csClippedEdges2,csRemoveEdges,csResilientEdges,csAdvancedClip);
  PClipStyle        =^TClipStyle;

  {Blur}
  TBorderFilter     =(efNotTiled,efTiled);
  PBorderFilter     =^TBorderFilter;

  {SplineFormula}
  TSplineFormula    =(sfCycloid,sfEpicycloid,sfHypocycloid,sfRose,sfSpiral,sfSuperellipse);
  PSplineFormula    =^TSplineFormula;

  PByteBool         =^boolean;

  TParamType        =(ptLeft,ptTop);
  PParamType        =^TParamType;

  TSclDir           =(sdUp,sdDown,sdNone);
  PSclDir           =^TSclDir;

  TEnum0            =0..3;
  PEnum0            =^TEnum0;

  TEnum1            =0..4;
  PEnum1            =^TEnum1;

  TEnum0Arr         =packed array of TEnum0;
  PEnum0Arr         =^TEnum0Arr;

  TEnum1Arr         =packed array of TEnum1;
  PEnum1Arr         =^TEnum1Arr;

  TEnum2Arr         =array[0..3] of integer;
  PEnum2Arr         =^TEnum2Arr;

  TFunc0Args        =packed record {$region -fold}
    r      :byte;
    g      :byte;
    b      :byte;
    alpha  :byte;
    d_alpha:byte;
    pow    :byte;
    d      :smallint;
  end; {$endregion}
  PFunc0Args        =^TFunc0Args;

  TObjSel           =packed record {$region -fold}
    // kind   of selected object(spline, sprite, etc.,...)
    obj_kind:integer;
    // number of selected object inside array of this kind
    obj_id  :integer;
  end; {$endregion}
  PObjSel           =^TObjSel;

  TPtRect           =packed record {$region -fold}
    left  : integer;
    top   : integer;
    width : integer;
    height: integer;
    right : integer;
    bottom: integer;
  end; {$endregion}
  PPtRect           =^TPtRect;

  TPtRectF          =packed record {$region -fold}
    left  : double;
    top   : double;
    width : double;
    height: double;
    right : double;
    bottom: double;
  end; {$endregion}
  PPtRectF          =^TPtRectF;

  TPtRectB          =packed record {$region -fold}
    pt_rct  : TPtRect;
    b_left  : boolean;
    b_top   : boolean;
    b_right : boolean;
    b_bottom: boolean;
  end; {$endregion}
  PPtRectB          =^TPtRectB;

  TPtPos            =packed record {$region -fold}
    x,y: integer;
    class operator =(r1,r2:TPtPos): boolean; inline; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PPtPos            =^TPtPos;

  TPtPos2           =record {$region -fold}
    arr        : array[0..5] of word;
    obj_ind    : integer;
    pts_ind    : integer;
    dup_pts_cnt: integer;
    weight     : integer;
    class operator    =(r1,r2      :TPtPos2): boolean; inline; {$ifdef Linux}[local];{$endif}
    class operator    *(r1,r2      :TPtPos2): boolean; inline; {$ifdef Linux}[local];{$endif}
    procedure SetEqual0(var      r1:TPtPos2;
                        constref r2:TPtPos2);          inline; {$ifdef Linux}[local];{$endif}
    procedure SetEqual1(var      r1:TPtPos2;
                        constref r2:TPtPos2);          inline; {$ifdef Linux}[local];{$endif}
    procedure SetEqual2(var      r1:TPtPos2;
                        constref r2:TPtPos2);          inline; {$ifdef Linux}[local];{$endif}
    function  IsEqual  (         r1,
                                 r2:TPtPos2): boolean; inline; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PPtPos2           =^TPtPos2;

  TPtPosF           =packed record {$region -fold}
    x,y: double{single};
    class operator =(r1,r2:TPtPosF): boolean; inline; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PPtPosF           =^TPtPosF;

  TCrPos            =packed record {$region -fold}
    x,y,r: integer;
  end; {$endregion}
  PCrPos            =^TCrPos;

  TCrPosF           =packed record {$region -fold}
    x,y,r: double;
  end; {$endregion}
  PCrPosF           =^TCrPosF;

  TLnPos            =packed record {$region -fold}
    x0,y0,x1,y1: integer;
  end; {$endregion}
  PLnPos            =^TLnPos;

  TLnPosF           =packed record {$region -fold}
    x0,y0,x1,y1: double;
  end; {$endregion}
  PLnPosF           =^TLnPosF;

  TEdge             =packed record {$region -fold}
    first_point: TColor;
    last_point : TColor;
    obj_ind    : TColor;
  end; {$endregion}
  PEdge             =^TEdge;

  TSlPt             =packed record {$region -fold}
    point  : TColor;
    obj_ind: TColor;
  end; {$endregion}
  PSlPt             =^TSlPt;

  TFX               =packed record {$region -fold}
    nt_value_proc_ind: byte;
    pt_value_proc_ind: byte;
    rep_cnt          : byte;
    {Type of Surface-------} {$region -fold}
    // [0..001]
    // 0 - nothing;
    // 1 - src. image;
    nt_pix_srf_type: byte;
    pt_pix_srf_type: byte; {$endregion}
    {Type of Color Effect--} {$region -fold}
    // [0..255]
    // 00 - monochrome       ;
    // 01 - additive         ;
    // 02 - alphablend       ;
    // 03 - inverse          ;
    // 04 - highlight        ;
    // 05 - darken           ;
    // 06 - grayscale r      ;
    // 07 - grayscale g      ;
    // 08 - grayscale b      ;
    // 09 - monochrome noise ;
    // 10 - colorize r(minus);
    // 11 - colorize r(plus) ;
    // 12 - colorize g(minus);
    // 13 - colorize g(plus) ;
    // 14 - colorize b(minus);
    // 15 - colorize b(plus) ;
    // 16 - blurRGB          ;
    // 17 - blurRRB          ;
    // 18 - blurRGR          ;
    // 19 - blurGGB          ;
    // 20 - blurRGG          ;
    // 21 - blurBGB          ;
    // 22 - blurRBB          ;
    // 23 - blurRRR          ;
    // 24 - blurGGG          ;
    // 25 - blurBBB          ;
    // 26 - gradientTBH      ;
    // 27 - gradientBTH      ;
    // 28 - gradientTBD      ;
    // 29 - gradientBTD      ;
    nt_pix_cfx_type: byte;
    pt_pix_cfx_type: byte; {$endregion}
    {Type of Image Changing} {$region -fold}
    // [0..001]
    // 0 - constant;
    // 1 - fading;
    nt_pix_cng_type: byte;
    pt_pix_cng_type: byte; {$endregion}
  end; {$endregion}
  PFX               =^TFX;

  TByteDstFld       =packed record {$region -fold}
    v0,v1: byte
  end; {$endregion}
  PByteDstFld       =^TByteDstFld;

  TBckgdStngs       =packed record {$region -fold}
    // outer(clipping) rectangle:
    rct_clp       :TPtRect;
    // handle of drawing destination surface(background):
    bmp_dst_ptr   :PInteger;
    // width of drawing destination surface(background):
    bmp_dst_width :TColor;
    // height of drawing destination surface(background):
    bmp_dst_height:TColor;
  end; {$endregion}
  PBckgdStngs       =^TBckgdStngs;

  PIList            =^TIList;
  TIList            =packed record {$region -fold}
    next_item: PIList;
    x_ptr    : ^integer;
  end; {$endregion}

  PFList            =^TFList;
  TFList            =packed record {$region -fold}
    next_item: PFList;
    x,y      : double;
  end; {$endregion}

  TGCDGrid          =packed record {$region -fold}
    f_ln_kind,a,b,c,d: integer;
  end; {$endregion}
  PGCDGrid          =^TGCDGrid;
  {****************************************************************************}



  {Anti-Aliasing **************************************************************}
  TFastAALine       =packed record {$region -fold}
    first_pt_x: integer;
    first_pt_y: integer;
    line_shift: integer;
    line_kind : byte;
    // 00 - horizontal line: 2 points from left to right;
    // 01 - horizontal line: 2 points from right to left;
    // 02 - horizontal line: outer line from ends to middle;
    // 03 - horizontal line: inner line from middle to ends;
    // 04 - horizontal line: const fill;

    // 05 - vertical   line: 2 points from top to bottom;
    // 06 - vertical   line: 2 points from bottom to top;
    // 07 - vertical   line: inner line from ends to middle;
    // 08 - vertical   line: outer line from middle to ends;
    // 09 - vertical   line: const fill;

    // 10 - 1 point;
    // 11 - circle;
  end; {$endregion}
  PFastAALine       =^TFastAALine;
  {****************************************************************************}



  {Miscellaneous Array Types **************************************************}
  TFastImageArr     =array of TFastImage;
  PFastImageArr     =^TFastImageArr;

  TPictArr          =array of TPicture;
  PPictArr          =^TPictArr;

  TFLnArr           =array of TFastLine;
  PFLnArr           =^TFLnArr;

  TFTxArr           =array of TFastText;
  PFTxArr           =^TFTxArr;

  TAALnArr          =array of TFastAALine;
  PAALnArr          =^TAALnArr;

  TObjSelArr        =array of TObjSel;
  PObjSelArr        =^TObjSelArr;

  TRectArr          =array of TRect;
  PRectArr          =^TRectArr;

  T2PtPosFArr        =array of array of TPtPosF;
  P2PtPosFArr        =^T2PtPosFArr;

  TPtPosFArr        =array of TPtPosF;
  PPtPosFArr        =^TPtPosFArr;

  TPtPosArr         =array of TPtPos;
  PPtPosArr         =^TPtPosArr;

  TPtPos2Arr        =array of TPtPos2;
  PPtPos2Arr        =^TPtPos2Arr;

  TEdgeArr          =array of TEdge;
  PEdgeArr          =^TEdgeArr;

  TSlPtArr          =array of TSlPt;
  PSlPtArr          =^TSlPtArr;

  TRctValArr        =array[0..4] of integer;
  PRctValArr        =^TRctValArr;

  TFXArr            =array[byte] of TFX;
  PFXArr            =^TFXArr;

  TDublArr          =array of double;
  PDublArr          =^TDublArr;

  TIntrArr          =array of integer;
  PIntrArr          =^TIntrArr;

  TSmIntArr         =array of smallint;
  PSmIntArr         =^TSmIntArr;

  TShIntArr         =array of shortint;
  PShIntArr         =^TShIntArr;

  TLWordArr         =array of longword;
  PLWordArr         =^TLWordArr;

  TWordArr          =array of word;
  PWordArr          =^TWordArr;

  T1Byte1Arr        =array of byte;
  P1Byte1Arr        =^T1Byte1Arr;

  T1Byte2Arr        =array[byte] of byte;
  P1Byte2Arr        =^T1Byte2Arr;

  T2ByteArr         =array of array of byte;
  P2ByteArr         =^T2ByteArr;

  TByteDstFldArr    =array of TByteDstFld;
  PByteDstFldArr    =^TByteDstFldArr;

  TBool1Arr         =array of boolean;
  PBool1Arr         =^TBool1Arr;

  TBool2Arr         =array[0..100] of boolean;
  PBool2Arr         =^TBool2Arr;

  TGCDArr           =array of TGCDGrid;
  PGCDArr           =TGCDArr;

  TStringArr        =array of string;
  PStringArr        =^TStringArr;

  TFontArr          =array of TFont;
  PFontArr          =^TFontArr;
  {****************************************************************************}



  {Procedure Types ************************************************************}
  TProc0            =procedure of object;
  PProc0            =^TProc0;

  TProc1            =procedure(         index        :integer;
                                        image        :TCustomBitmap) of object;
  PProc1            =^TProc1;

  TProc2            =procedure(var      arr_dst      :TColorArr;
                               constref arr_dst_width:TColor;
                               constref val          :TColor)        of object;
  PProc2            =^TProc2;

  TProc3            =procedure(constref x0,y0,x1,y1  :integer;
                               constref proc_ptr_a   :TProc0;
                               constref proc_ptr_b   :TProc0)        of object;
  PProc3            =^TProc3;

  TProc4            =procedure(constref bmp_dst_ptr  :PInteger;
                               constref rct_dst      :TPtRect;
                               constref bmp_dst_width:TColor);
  PProc4            =^TProc4;

  TProc4_1          =procedure(constref bmp_dst_ptr  :PByte;
                               constref rct_dst      :TPtRect;
                               constref bmp_dst_width:TColor);
  PProc4_1          =^TProc4_1;

  TProc5            =procedure(constref arr0         :T1Byte1Arr;
                               constref bmp_ptr      :PInteger;
                               constref bmp_width,
                                        bmp_height   :TColor;
                               constref rct_dst      :TPtRect;
                               constref col          :TColor;
                               constref alpha        :byte=120);
  PProc5            =^TProc5;

  TProc6            =procedure(constref bmp_dst_ptr  :PInteger;
                               constref rct_dst      :TPtRect;
                               constref bmp_dst_width:TColor);
  PProc6            =^TProc6;

  TProc7            =procedure(constref x,y          :integer)       of object;
  PProc7            =^TProc7;

  TProc8            =procedure(         pixel_ptr    :PInteger;
                                        bmp_dst_width:TColor);
  PProc8            =^TProc8;

  TProc9            =procedure(         bmp_src_ptr,
                                        bmp_dst_ptr  :PInteger;
                               constref bmp_dst_width:TColor;
                               constref rct_src      :TPtRect;
                               constref d_width,
                                        c,s,v,w,
                                        lt,tp,rt,bt  :integer);
  PProc9            =^TProc9;

  TProc10           =procedure(         x,y          :integer;
                               constref pvt          :TPtPosF;
                               var      pts          :TPtPosFArr;
                               constref bmp_dst_ptr  :PInteger;
                               constref rct_clp      :TPtRect)       of object;
  PProc10           =^TProc10;

  TProc11           =procedure(         x,y          :integer;
                               constref pvt          :TPtPosF;
                               var      pts          :TPtPosFArr;
                               constref bmp_dst_ptr  :PInteger;
                               constref rct1,rct2    :TPtRect)       of object;
  PProc11           =^TProc11;

  TProc12           =procedure(         x,y          :integer;
                               var      sel_pts_rect :TPtRectF)      of object;
  PProc12           =^TProc12;

  TProc13           =procedure(         x,y          :integer)       of object;
  PProc13           =^TProc13;

  TFunc0            =function (         pixel        :TColor;
                               constref r            :byte    =000;
                               constref g            :byte    =000;
                               constref b            :byte    =000;
                               constref alpha        :byte    =000;
                               constref d_alpha      :byte    =255;
                               constref pow          :byte    =064;
                               constref d            :smallint=000): TColor;
  PFunc0            =^TFunc0;

  TFunc1            =function (         pixel        :TColor;
                               constref alpha_fade   :byte;
                               constref d            :smallint): TColor;
  PFunc1            =^TFunc1;

  TFunc2            =function (         pixel        :TColor;
                               constref r,g,b        :byte;
                                        alpha,d_alpha:byte;
                               constref alpha_fade   :byte;
                               constref pow          :byte;
                               constref d            :smallint): TColor;
  PFunc2            =^TFunc2;
  {****************************************************************************}



  {Text Properties(Attributes) ************************************************}
  TFTextProp        =packed record {$region -fold}
    // background color:
    bkgnd_col    : TColor;
    // background drawing:
    bkgnd_draw   : boolean;
    // background random color:
    bkgnd_rnd_col: boolean;
  end; {$endregion}
  PFTextProp        =^TFTextProp;
  {****************************************************************************}



  {Spline Properties(Attributes) **********************************************}
  TCurveProp        =packed record {$region -fold}
    // duplicated points id:
    dup_pts_id               : TPtPos2;
    // global spline object index:
    curve_obj_ind            : TColor;
    // spline points count:
    pts_cnt                  : TColor;
    //
    pts_cnt_val              : TColor;
    // edges simplification angle:
    eds_smpl_angle           : single;
    //
    eds_col_ptr              : PColor;
    // edges  color:
    eds_col                  : TColor;
    // edges  color(inverted):
    eds_col_inv              : TColor;
    // edges  color(random):
    eds_col_rnd              : boolean;
    // edges color(fall-off):
    eds_col_fall_off         : boolean;
    eds_col_fall_off_inc     : byte;
    // edges width:
    eds_width                : TColor;
    // edges width half:
    eds_width_half           : TColor;
    // edges width parity:
    eds_width_odd            : TColor;
    // edges anti-aliasing:
    eds_aa                   : boolean;
    // points color pointer:

    pts_col_ptr              : PInteger;
    // points color:
    pts_col                  : TColor;
    // points color(inverted):
    pts_col_inv              : TColor;
    // points color(random):
    pts_col_rnd              : boolean;
    // points color(fall-off):
    pts_col_fall_off         : boolean;
    pts_col_fall_off_inc     : byte;

    // point width:
    pts_width                : TColor;
    // point width  half:
    pts_width__half          : TColor;
    // point width parity:
    pts_width__odd           : TColor;
    // point height:
    pts_height               : TColor;
    // point height half:
    pts_height_half          : TColor;
    // point height parity:
    pts_height_odd           : TColor;

    {Custom Point-Rectangle}
    rct_val_arr              : TRctValArr;
    // point rectangle width:
    pts_rct_width            : TColor;
    // point rectangle width half:
    pts_rct_width__half      : TColor;
    // point rectangle width parity:
    pts_rct_width__odd       : TColor;
    // point rectangle height:
    pts_rct_height           : TColor;
    // point rectangle height half:
    pts_rct_height_half      : TColor;
    // point rectangle height parity:
    pts_rct_height_odd       : TColor;
    // point rectangle thickness left:
    pts_rct_tns_left         : TColor;
    // point rectangle thickness top:
    pts_rct_tns_top          : TColor;
    // point rectangle thickness right:
    pts_rct_tns_right        : TColor;
    // point rectangle thickness bottom:
    pts_rct_tns_bottom       : TColor;
    // point rectangle inner width:
    pts_rct_inn_width        : TColor;
    // point rectangle inner width parity:
    pts_rct_inn_width__odd   : TColor;
    // point rectangle inner height:
    pts_rct_inn_height       : TColor;
    // point rectangle inner height parity:
    pts_rct_inn_height_odd   : TColor;

    {Custom Point-Circle}
    // point inner radius:
    pts_crc_diam_inn         : TColor;
    // point inner radius half:
    pts_crc_diam_inn_half    : TColor;
    // point outer radius:
    pts_crc_diam_out         : TColor;
    // point outer radius half:
    pts_crc_diam_out_half    : TColor;

    {Custom Point-Polygon}
    // point polygon width:
    pts_plg_diam             : TColor;
    // point polygon width half:
    pts_plg_diam_half        : TColor;
    // point polygon angles count:
    pts_plg_ang_cnt          : TColor;

    {Custom Point-Sprite}
    // point sprite width:
    pts_srt_width            : TColor;
    // point sprite height:
    pts_srt_height           : TColor;

    // points drawing frequance:
    sln_pts_frq              : word;
    // spline type:
    sln_type                 : TSplineType;
    // spline mode:
    sln_mode                 : TSplineMode;
    // spray radius:
    spray_rad                : TColor;
    // edges  blending:
    eds_bld_stl              : TDrawingStyle;
    // points blending:
    pts_bld_stl              : TDrawingStyle;
    // edges clipping:
    clp_stl                  : TClipStyle;
    // edges level of details:
    eds_lod                  : boolean;
    // simplification angle
    eds_simpl_angle          : double;
    // hidden-line elimination:
    hid_ln_elim              : boolean;
    // best precision for hidden-line elimination:
    best_precision           : boolean;
    // lazy_repaint:
    lazy_repaint             : boolean;
    lazy_repaint_prev        : boolean;
    // byte mode:
    byte_mode                : boolean;
    byte_mode_prev           : boolean;
    // free memory on out of window:
    free_mem_on_out_of_wnd   : boolean;
    // free memory on scale down:
    free_mem_on_scale_down   : boolean;
    // remove brunching:
    remove_brunching_adaptive: boolean;
    remove_brunching_constant: boolean;
    remove_brunching_none    : boolean;
    // edges bounding rectangle:
    rct_eds_show             : boolean;
    // points bounding rectangle:
    rct_pts_show             : boolean;
    // edges  visibility:
    eds_show                 : boolean;
    // points visibility:
    pts_show                 : boolean;
    // connect ends:
    cnc_ends                 : boolean;
    // invert points indices order:
    pts_ord_inv              : boolean;
    // is object out of window:
    is_out_of_wnd            : boolean;
    // dynamics style:
    dyn_stl                  : TDynamicsStyle;

    // formula type:
    fml_type                 : TSplineFormula;

    {Cycloid}
    // points count:
    cycloid_pts_cnt          : TColor;
    // loops count:
    cycloid_loop_cnt         : TColor;
    // loop radius:
    cycloid_loop_rad         : double;
    // curvature:
    cycloid_curvature        : double;
    // curve direction on axis x:
    cycloid_dir_x            : TMovingDirection;
    // curve direction on axis y:
    cycloid_dir_y            : TMovingDirection;

    {Epicycloid}
    // points count:
    epicycloid_pts_cnt       : TColor;
    // petals count:
    epicycloid_petals_cnt    : double;
    // curve radius:
    epicycloid_rad           : double;
    // rotation angle:
    epicycloid_rot           : double;
    // cut on angle:
    epicycloid_angle         : double;

    {Rose}
    // points count:
    rose_pts_cnt             : TColor;
    // petals count:
    rose_petals_cnt          : double;
    // curve radius:
    rose_rad                 : double;
    // rotation angle:
    rose_rot                 : double;
    // cut on angle:
    rose_angle               : double;

    {Spiral}
    // points count:
    spiral_pts_cnt           : TColor;
    // spiral coil step:
    spiral_coil_step         : double;
    // curve radius:
    spiral_rad               : double;
    // rotation angle:
    spiral_rot               : double;
    // cut on angle:
    spiral_angle             : double;

    {Superellipse}
    {TODO}

  end; {$endregion}
  PCurveProp        =^TCurveProp;
  {****************************************************************************}



  {Select Items Properties(Attributes) ****************************************}
  TSelItProp        =packed record {$region -fold}
    bkgnd_style   : TBackgroundStyle;
    selection_mode: TSelectionMode;
  end; {$endregion}
  PSelItProp        =^TSelItProp;
  {****************************************************************************}



  {Color Information **********************************************************}
  TEquidistantCurve =packed record {$region -fold}
    pts     : TColorArr;

    //...
  end; {$endregion}
  PEquidistantCurve =^TEquidistantCurve;
  {****************************************************************************}



  {Color Information **********************************************************}
  TColorInfo        =packed record {$region -fold}
    pix_col : TColor;
    r,g,b   : byte;
      alpha1: byte;
    d_alpha1: byte;
      alpha2: byte;
    d_alpha2: byte;
  end; {$endregion}
  PColorInfo        =^TColorInfo;
  {****************************************************************************}



  {Color Transform Information ************************************************}
  TColTransInfo     =packed record {$region -fold}
    // monochrome        value:
    monochrome_val       : TColor;
    // red channel       value:
    r_val                : byte;
    // green channel     value:
    g_val                : byte;
    // blue channel      value:
    b_val                : byte;
    {// additive          value:
    additive_val         : byte;
    // alphablend        value:
    alpha_val,d_alpha_val: byte;
    // inverse           value:
    inverse_val          : byte;
    // highlight         value:
    highlight_val        : byte;
    // darken            value:
    darken_val           : byte;
    // grayscale r       value:
    grayscale_r_val      : byte;
    // grayscale g       value:
    grayscale_g_val      : byte;
    // grayscale b       value:
    grayscale_b_val      : byte;
    // noise             value:
    mononoise_val        : byte;
    // colorize r(minus) value:
    colorize_r_m_val     : byte;
    // colorize r(plus)  value:
    colorize_r_p_val     : byte;
    // colorize g(minus) value:
    colorize_g_m_val     : byte;
    // colorize g(plus)  value:
    colorize_g_p_val     : byte;
    // colorize b(minus) value:
    colorize_b_m_val     : byte;
    // colorize b(plus)  value:
    colorize_b_p_val     : byte;}
  end; {$endregion}
  PColTransInfo     =^TColTransInfo;

  TColTransInfo2    =packed record {$region -fold}
    // monochrome        value:
    monochrome_val       : TColor;
    // red channel       value:
    r_val                : TColor;
    // green channel     value:
    g_val                : TColor;
    // blue channel      value:
    b_val                : TColor;
    {// additive          value:
    additive_val         : TColor;
    // alphablend        value:
    alpha_val,d_alpha_val: TColor;
    // inverse           value:
    inverse_val          : TColor;
    // highlight         value:
    highlight_val        : TColor;
    // darken            value:
    darken_val           : TColor;
    // grayscale r       value:
    grayscale_r_val      : TColor;
    // grayscale g       value:
    grayscale_g_val      : TColor;
    // grayscale b       value:
    grayscale_b_val      : TColor;
    // noise             value:
    mononoise_val        : TColor;
    // colorize r(minus) value:
    colorize_r_m_val     : TColor;
    // colorize r(plus)  value:
    colorize_r_p_val     : TColor;
    // colorize g(minus) value:
    colorize_g_m_val     : TColor;
    // colorize g(plus)  value:
    colorize_g_p_val     : TColor;
    // colorize b(minus) value:
    colorize_b_m_val     : TColor;
    // colorize b(plus)  value:
    colorize_b_p_val     : TColor;}
  end; {$endregion}
  PColTransInfo2    =^TColTransInfo2;
  {****************************************************************************}



  {Fast Actors Container ******************************************************}
  TFastActorSet     =class {$region -fold}
    // list of actors:
    act_arr       : array of TFastActor;
    // dummy icon:
    d_icon        : TFastImage;
    // array of actors positions:
    act_pos_arr   : TPtPosFArr;
    // selection field:
    sel_fld       : TColorArr;
    sel_fld_ptr   : PInteger;
    // actors count:
    act_cnt       : TColor;
    // first frame rect:
    first_frm_rect: TPtRect;
    // init. part:
    constructor Create(constref bkgnd_ptr         :PInteger;
                       constref bkgnd_width,
                                bkgnd_height      :TColor;
                       var      rct_clp           :TPtRect;
                       constref bmp_src_rct       :TPtRect;
                       constref location          :string='';
                       constref ImgLstGetBmp      :TProc1=Nil;
                       constref d_icon_img_lst_ind:TColor=0);  {$ifdef Linux}[local];{$endif}
    destructor  Destroy;                             override; {$ifdef Linux}[local];{$endif}
    // add actor;
    procedure AddActor(x,y                        :integer);   {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PFastActorSet     =^TFastActorSet;
  {****************************************************************************}



  {Fast Image Container *******************************************************}
  TFastActorInstInfo=packed record {$region -fold}
    frm_ind         : integer;
    bmp_ftimg_left  : integer;
    bmp_ftimg_top   : integer;
    bmp_ftimg_right : integer;
    bmp_ftimg_bottom: integer;
    col_trans_var   : TColTransInfo;
    fx_arr          : TFXArr;
    fx_cnt          : byte;
    {Type of Image Drawing-------} {$region -fold}
    // 0 - color;
    // 1 - value;
    // 2 - color
    // and value;
    pix_drw_type    : byte; {$endregion}
    {Type of Surface-------------} {$region -fold}
    // 0 - nothing;
    // 1 - src. image;
    // 2 - dst. background;
    nt_pix_srf_type : byte;
    pt_pix_srf_type : byte; {$endregion}
    {Type of Color Effect--------} {$region -fold}
    // 0 - monochrome;
    // 1 - additive;
    // 2 - alphablend;
    nt_pix_cfx_type : byte;
    pt_pix_cfx_type : byte; {$endregion}
    {Type of Image Clipping------} {$region -fold}
    // 0 - not clippped;
    // 1 - top-bottom clippped;
    // 2 - left-right-top-bottom clippped;
    nt_pix_clp_type : byte;
    pt_pix_clp_type : byte; {$endregion}
    {Type of Image Changing------} {$region -fold}
    // 0 - constant;
    // 1 - fading;
    nt_pix_cng_type : byte;
    pt_pix_cng_type : byte; {$endregion}
  end; {$endregion}
  PFastActorInstInfo=^TFastActorInstInfo;

  TFastActor        =class {$region -fold}
    // list of frames
    frm_arr      : array of TFastImage;
    // list of instances:
    act_inst_arr : array of array of TFastActorInstInfo;
    // list of paths for actor:
    path_ind_arr : TColorArr;
    //
    src_img_color: TBitmap;
    // frames count;
    frm_cnt      : TColor;
    constructor Create;                                      {$ifdef Linux}[local];{$endif}
    destructor  Destroy;                           override; {$ifdef Linux}[local];{$endif}
    {procedure   BakeRot(var      rot_img_:TFastImage;
                        constref angle_  :double); inline;   {$ifdef Linux}[local];{$endif}}
    {Turn One Image          Into Frames}
    //procedure ImgToFrames;           {$ifdef Linux}[local];{$endif}
    {Turn     Image Sequance Into Frames}
    //procedure SqcToFrames;           {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PFastActor        =^TFastActor;
  {****************************************************************************}



  {Fast Image *****************************************************************}
  PFastImage        =^TFastImage;
  TFastImage        =class {$region -fold}

    type
      TRenderType=(rtDynamic,rtStatic);

    {Proc. Table-----------------} {$region -fold}
    public
      var
        // Image Compression:
        CmpProc               : array[0..012] of TProc0;

        // Image Drawing:
        // NT - not transparent pixels:
        NTValueProc           : array[0..300] of TProc0;
        NTColorProc           : array[0..029] of TProc0;
        NTBeginProc           : array[0..002] of TProc0;
        nt_pix_intr_arr_ptr   : PInteger;
        // PT - partly transparent pixels:
        PTValueProc           : array[0..300] of TProc0;
        PTColorProc           : array[0..029] of TProc0;
        PTBeginProc           : array[0..002] of TProc0;
        pt_pix_intr_arr_ptr   : PInteger;

        // Proc.Indices:
        // NT - not transparent pixels:
        nt_begin_proc_ind     : byte;
        nt_color_proc_ind     : byte;
        nt_value_proc_ind     : byte;
        // PT - partly transparent pixels:
        pt_begin_proc_ind     : byte;
        pt_color_proc_ind     : byte;
        pt_value_proc_ind     : byte;

        // Shader Type Proc. Table:
        SdrType               : array[0..038] of TProc0;
        sdr_type_ind          : byte;

        // Shader Uber Proc. Table:
        SdrProc               : array[0..003] of TProc0;
        sdr_proc_ind          : byte; {$endregion}

    {Gradient Vector-------------} {$region -fold}
    grad_vec                  : TLnPos; {$endregion}

    {Color Info------------------} {$region -fold}
    public
      var
        col_trans_var         : TColTransInfo;
        col_trans_arr         : T1Byte2Arr; {$endregion}

    {Color/Alpha of Current Layer} {$region -fold}
    {protected} public
      var
        // NT - not transparent pixels:
        nt_pix_intr_ccl_arr   : TColorArr;

        // PT - partly transparent pixels:
        // color channel:
        pt_pix_intr_ccl_arr   : TColorArr;
        // alpha channel:
        pt_pix_byte_acl_arr   : T1Byte1Arr; {$endregion}

    {Color       of Lower   Layer} {$region -fold}
    {protected} public
      var
        // NT - not transparent pixels:
        nt_pix_intr_cll_arr   : TColorArr;

        // PT - partly transparent pixels:
        pt_pix_intr_cll_arr   : TColorArr; {$endregion}

    {Value       of Current Layer} {$region -fold}
    {protected} public
      var
        // NT - not transparent pixels:
        nt_pix_intr_val_arr   : TColorArr;

        // PT - partly transparent pixels; reserved:
        pt_pix_intr_val_arr   : TColorArr; {$endregion}

    {Items Counts in Rows--------} {$region -fold}
    {protected} public
      var
        // NT - not transparent pixels:
        nt_pix_intr_cnt_arr   : TColorArr;

        // PT - partly transparent pixels:
        pt_pix_intr_cnt_arr   : TColorArr; {$endregion}

    {Items Shifts----------------} {$region -fold}
    {protected} public
      var
        // NT - not transparent pixels:
        nt_pix_intr_sht_arr   : TColorArr;

        // PT - partly transparent pixels:
        pt_pix_intr_sht_arr   : TColorArr; {$endregion}

    {Image Kind------------------} {$region -fold}
    public
      var
        img_kind              : byte;
        {
        ----------------Image Has Alpha Channel And Color Channel---------------
        0:
        image has:  not monochrome alpha channel,
                    not monochrome color channel,
        count of    not transparent pixels>0;
        count of partly transparent pixels>0;

        1:
        image has:  not monochrome alpha channel,
                    not monochrome color channel,
        count of    not transparent pixels>0;
        count of partly transparent pixels=0;

        2:
        image has:  not monochrome alpha channel,
                    not monochrome color channel,
        count of    not transparent pixels=0;
        count of partly transparent pixels>0;

        3:
        image has:      monochrome alpha channel(white, not transparent),
                    not monochrome color channel,
        count of    not transparent pixels>0;
        count of partly transparent pixels=0;

        4:
        image has:      monochrome alpha channel(transparent),
                    not monochrome color channel,
        count of    not transparent pixels=0;
        count of partly transparent pixels>0;


        ----------------------Image Has Only Alpha Channel----------------------
        5:
        image has:  not monochrome alpha channel,
                                no color channel,
        count of    not transparent pixels>0;
        count of partly transparent pixels>0;

        6:
        image has:  not monochrome alpha channel,
                                no color channel,
        count of    not transparent pixels>0;
        count of partly transparent pixels=0;

        7:
        image has:  not monochrome alpha channel,
                                no color channel,
        count of    not transparent pixels=0;
        count of partly transparent pixels>0;

        8:
        image has:      monochrome alpha channel(white, not transparent),
                                no color channel,
        count of    not transparent pixels>0;
        count of partly transparent pixels=0;

        9:
        image has:      monochrome alpha channel(transparent),
                                no color channel,
        count of    not transparent pixels=0;
        count of partly transparent pixels>0;


        --------------Image Has No Alpha Channel And Color Channel--------------
        10:
        image has:      no alpha channel(black, invisible),
                        no color channel,
        count of    not transparent pixels=0;
        count of partly transparent pixels=0;

        --------------------------Image is Value Array--------------------------
        11:
        count of    not transparent pixels>0;
        count of partly transparent pixels>0;

        ------------------------------Image is Mask-----------------------------
        12:
        count of    not transparent pixels>0;
        count of partly transparent pixels=0;
        } {$endregion}

    {Image Metrics---------------} {$region -fold}
    public
      var
        //
        bmp_src_rct_clp        : TPtRect;
        // pointer to background image(where all sprites are drawn):
        bmp_bkgnd_ptr          : PInteger;
        // background image width:
        bmp_bkgnd_width        : TColor;
        // background image height:
        bmp_bkgnd_height       : TColor;
        //
        bmp_color_ptr          : PInteger;
        //
        bmp_alpha_ptr          : PInteger;
        bmp_alpha_ptr2         : PByte;
        //
        bmp_value_ptr          : PInteger;
        //
        bmp_ftimg_width_origin : TColor;
        bmp_ftimg_width        : TColor;
        //
        bmp_ftimg_height_origin: TColor;
        bmp_ftimg_height       : TColor;
        //
        bmp_ftimg_left         : integer;
        //
        bmp_ftimg_top          : integer;
        //
        bmp_ftimg_right        : integer;
        //
        bmp_ftimg_bottom       : integer;
        //
        nt_pix_arr_row_mrg_top : TColor;
        //
        nt_pix_arr_row_mrg_btm : TColor;
        //
        pt_pix_arr_row_mrg_top : TColor;
        //
        pt_pix_arr_row_mrg_btm : TColor;
        //
        width_parity           : boolean;
        //
        height_parity          : boolean;
        //
        tile_map_calc          : boolean;
        //
        render_type            : TRenderType;
        //
        alpha_max              : byte;
        //
        remove_brunching_none  : boolean; {$endregion}

    {Image Clipping--------------} {$region -fold}
    public
      var
        {Precalculated Table of Counts Vertically(Image Clipping)}
        // NT - not transparent pixels:
        nt_cnt_ind_arr        : TColorArr;
        // PT - partly transparent pixels:  array
        pt_cnt_ind_arr        : TColorArr;
        //
        rct_clp_ptr           : PPtRect;
        //
        rct_src               : TPtRect;
        //
        rct_dst               : TPtRectB;
        //
        arr_src_sht           : integer;
        //
        rct_clp_mrg           : TColor; {$endregion}

    {Post-Processing-------------} {$region -fold}
    public
      var
        // effects param.s array:
        fx_arr                : TFXArr;
        // count of effects:
        fx_cnt                : byte; {$endregion}

    {Tiles Copying---------------} {$region -fold}
    public
      var
        // array of tiles bounding rectangles inside one bitmap:
        rect_src_arr          : array of TPtRect;
        // tiles count:
        tiles_cnt             : TColor; {$endregion}

    {Total Count of Pixels-------} {$region -fold}
    public{protected}
      var
        // all pixels:
        al_pix_cnt            : TColor;
        // not    transparent pixels count:
        nt_pix_cnt            : TColor;
        // partly transparent pixels count:
        pt_pix_cnt            : TColor;
        // count of zero(black) color pixels:
        zr_pix_cnt            : TColor;
        // count of pixels which are equal to first pixel:
        pt_pix_cng_cnt        : TColor; {$endregion}

    {Type of Image Drawing-------} {$region -fold}
    public
      var
        // 0 - color:
        // 1 - value:
        // 2 - color
        // and value:
        pix_drw_type          : byte; {$endregion}

    {Type of Surface-------------} {$region -fold}
    public
      var
        // 0 - nothing;
        // 1 - src. image;
        // 2 - dst. background;
        nt_pix_srf_type       : byte;
        pt_pix_srf_type       : byte; {$endregion}

    {Type of Color Effect--------} {$region -fold}
    public
      var
        // 0 - Monochrome;
        // 1 - Additive;
        // 2 - Alphablend;
        // 3 - Inverse;
        // 4 - Highlight;
        // 5 - Darken;
        // 6 - GrayscaleR;
        // 7 - GrayscaleG;
        // 8 - GrayscaleB;
        // 9 - Monochrome Noise;
        nt_pix_cfx_type       : byte;
        pt_pix_cfx_type       : byte; {$endregion}

    {Type of Image Clipping------} {$region -fold}
    public
      var

        // Clipping Proc. Table:
        NTUselessProc         : array[0..002] of TProc2;
        PTUselessProc         : array[0..002] of TProc2;

        // 0 - not clippped;
        // 1 - top-bottom clippped;
        // 2 - left-right-top-bottom clippped;
        nt_pix_clp_type       : byte;
        pt_pix_clp_type       : byte; {$endregion}

    {Type of Image Changing------} {$region -fold}
    public
      var
        // 0 - constant;
        // 1 - fading;
        nt_pix_cng_type       : byte;
        pt_pix_cng_type       : byte; {$endregion}

    {Type of Image Processing----} {$region -fold}
    public
      var
        // 0 - not to draw image(exclude shader);
        // 1 -        draw image(include shader);
        nt_useless            : byte;
        pt_useless            : byte; {$endregion}

    {Tile Map--------------------} {$region -fold}
    public
      var
        //map spline properties:
        sln_prop_var          : TCurveProp;
        //tile map handle:
        tilemap_sprite_ptr    : PFastImage;
        //width and height of sprite at mask:
        tilemap_sprite_w_h    : TPtPos; {$endregion}

    {Image Processing------------} {$region -fold}

    {Clear Arrays-----------------------------------------} {$region -fold}
    procedure ClrArr(arr_clear_val:word); inline; {$ifdef Linux}[local];{$endif}
    procedure ClrArr;                     inline; {$ifdef Linux}[local];{$endif} {$endregion}

    {Define Image Kind------------------------------------} {$region -fold}
    procedure DetImageKind; {$ifdef Linux}[local];{$endif} {$endregion}

    {Create Array    of Items Counts  in Rows from Bitmap-} {$region -fold}
    //** color and alpha are in separate bitmaps
    // NT - not transparent pixels:
    procedure CrtNTCountBmpS; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure CrtPTCountBmpS; {$ifdef Linux}[local];{$endif}
    //** color and alpha are in one bitmap
    // NT - not transparent pixels:
    procedure CrtNTCountBmpO; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure CrtPTCountBmpO; {$ifdef Linux}[local];{$endif} {$endregion}

    {Create Array    of Items Counts  in Rows from Array--} {$region -fold}
    // NT - not transparent pixels:
    procedure CrtNTCountArrA; {$ifdef Linux}[local];{$endif}
    procedure CrtNTCountArrB; {$ifdef Linux}[local];{$endif}
    procedure CrtNTCountArrC; {$ifdef Linux}[local];{$endif}
    procedure CrtNTCountArrD; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure CrtPTCountArrA; {$ifdef Linux}[local];{$endif}
    procedure CrtPTCountArrB; {$ifdef Linux}[local];{$endif}
    procedure CrtPTCountArrC; {$ifdef Linux}[local];{$endif}
    procedure CrtPTCountArrD; {$ifdef Linux}[local];{$endif} {$endregion}

    {Create Array    of Items Shifts  in Rows from Bitmap-} {$region -fold}
    //** color and alpha are in separate bitmaps
    // NT - not transparent pixels:
    procedure CrtNTShiftBmpS; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure CrtPTShiftBmpS; {$ifdef Linux}[local];{$endif}
    //** color and alpha are in one bitmap
    // NT - not transparent pixels:
    procedure CrtNTShiftBmpO; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure CrtPTShiftBmpO; {$ifdef Linux}[local];{$endif} {$endregion}

    {Create Array    of Items Shifts  in Rows from Array--} {$region -fold}
    // NT - not transparent pixels:
    procedure CrtNTShiftArrA; {$ifdef Linux}[local];{$endif}
    procedure CrtNTShiftArrB; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure CrtPTShiftArrA; {$ifdef Linux}[local];{$endif}
    procedure CrtPTShiftArrB; {$ifdef Linux}[local];{$endif} {$endregion}

    {Store Color     of Current Layer         from Bmp/Arr} {$region -fold}
    // NT - not transparent pixels:
    {store color channel}
    procedure StrNTColorBmpA; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    {store color channel}
    procedure StrPTColorBmpA; {$ifdef Linux}[local];{$endif}
    //** color and alpha are in separate bitmaps
    {store alpha channel into byte array---}
    procedure StrPTAlphaArrS; {$ifdef Linux}[local];{$endif}
    {store alpha channel into color channel}
    procedure StrPTAlphaBmpS; {$ifdef Linux}[local];{$endif}
    //** color and alpha are in one bitmap
    {store alpha channel into byte array---}
    procedure StrPTAlphaArrO; {$ifdef Linux}[local];{$endif}
    {store alpha channel into color channel}
    procedure StrPTAlphaBmpO; {$ifdef Linux}[local];{$endif} {$endregion}

    {Store Color     of Lower   Layer         from Bitmap-} {$region -fold}
    // NT - not transparent pixels:
    procedure StrNTLowerBmpA; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure StrPTLowerBmpA; {$ifdef Linux}[local];{$endif}
    // store alpha from byte array:
    procedure StrPTLowerArrA; {$ifdef Linux}[local];{$endif} {$endregion}

    {Store Value     of Current Layer         from Array--} {$region -fold}
    procedure StrNTValueArrA; {$ifdef Linux}[local];{$endif} {$endregion}

    {Set Chess Order of Alpha Channel in Rows from Bitmap-} {$region -fold}
    // calculation of image sides parity
    procedure CalcSidesParity; {$ifdef Linux}[local];{$endif}
    // color and alpha are in separate bitmaps
    // NT - not transparent pixels:
    procedure SetNTChessBmpS0; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure SetPTChessBmpS0; {$ifdef Linux}[local];{$endif}
    // color and alpha are in one bitmap
    // NT - not transparent pixels:
    procedure SetNTChessBmpO0; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure SetPTChessBmpO0; {$ifdef Linux}[local];{$endif} {$endregion}

    {Create Array of Tiles Bounding Rectangles------------} {$region -fold}
    procedure CrtRectArr; inline; {$ifdef Linux}[local];{$endif} {$endregion}

    {Full Image Compression-------------------------------} {$region -fold}
    // img. kind: 000:
    procedure CmpProc000;  inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 001:
    procedure CmpProc001;  inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 002:
    procedure CmpProc002;  inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 003:
    procedure CmpProc003;  inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 004:
    procedure CmpProc004;  inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 005:
    procedure CmpProc005;  inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 006:
    procedure CmpProc006;  inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 007:
    procedure CmpProc007;  inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 008:
    procedure CmpProc008;  inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 009:
    procedure CmpProc009;  inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 010:
    procedure CmpProc010;  inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 011:
    procedure CmpProc011;  inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 012:
    procedure CmpProc012;  inline; {$ifdef Linux}[local];{$endif}

    procedure CmpProcInit; inline; {$ifdef Linux}[local];{$endif}
    procedure ImgToCImg;   inline; {$ifdef Linux}[local];{$endif} {$endregion}

    {Fill Transparent Image on Background-----------------} {$region -fold}

    // NT - not transparent pixels:

    // not clippped:
    procedure FilNTProc0_0(constref args:TFunc0Args; Func0:TFunc0); {$ifdef Linux}[local];{$endif}
    // top-bottom clippped:
    procedure FilNTProc0_2(constref args:TFunc0Args; Func0:TFunc0); {$ifdef Linux}[local];{$endif}
    // left-right-top-bottom clippped:
    procedure FilNTProc0_4(constref args:TFunc0Args; Func0:TFunc0); {$ifdef Linux}[local];{$endif}

    // not clippped:
    procedure FilNTProc1_0(                          Proc8:TProc8); {$ifdef Linux}[local];{$endif}
    // top-bottom clippped:
    procedure FilNTProc1_2(                          Proc8:TProc8); {$ifdef Linux}[local];{$endif}
    // left-right-top-bottom clippped:
    procedure FilNTProc1_4(                          Proc8:TProc8); {$ifdef Linux}[local];{$endif}

    {Empty}
    procedure FilNTValue009; {$ifdef Linux}[local];{$endif}
    {Empty}
    procedure FilNTColor009; {$ifdef Linux}[local];{$endif}

    {Monochrome}
    // (constant) not clipped:
    procedure FilNTValue000; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue002; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue004; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue006; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Additive}
    // (constant) not clipped:
    procedure FilNTValue010; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue012; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue014; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue016; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilNTValue011; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilNTValue013; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilNTValue015; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure FilNTValue017; {$ifdef Linux}[local];{$endif}

    {Alphablend}
    // (constant) not clipped:
    procedure FilNTValue020; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue022; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue024; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue026; {$ifdef Linux}[local];{$endif}
    // (fading)
    //same;

    {Inverse}
    // (constant) not clipped:
    procedure FilNTValue030; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue032; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue034; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue036; {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure FilNTValue031; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilNTValue033; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilNTValue035; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure FilNTValue037; {$ifdef Linux}[local];{$endif}

    {Highlight}
    // (constant) not clipped:
    procedure FilNTValue040; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue042; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue044; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue046; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Darken}
    // (constant) not clipped:
    procedure FilNTValue050; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue052; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue054; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue056; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleR}
    // (constant) not clipped:
    procedure FilNTValue060; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue062; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue064; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue066; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilNTValue061; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilNTValue063; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilNTValue065; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure FilNTValue067; {$ifdef Linux}[local];{$endif}

    {GrayscaleG}
    // (constant) not clipped:
    procedure FilNTValue070; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue072; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue074; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue076; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilNTValue071; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilNTValue073; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilNTValue075; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure FilNTValue077; {$ifdef Linux}[local];{$endif}

    {GrayscaleB}
    // (constant) not clipped:
    procedure FilNTValue080; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue082; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue084; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue086; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilNTValue081; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilNTValue083; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilNTValue085; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure FilNTValue087; {$ifdef Linux}[local];{$endif}

    {Monochrome Noise}
    // (constant) not clipped:
    procedure FilNTValue090; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue092; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue094; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue096; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilNTValue091; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilNTValue093; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilNTValue095; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure FilNTValue097; {$ifdef Linux}[local];{$endif}

    {ColorizeRM}
    // (constant) not clipped:
    procedure FilNTValue100; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue102; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue104; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue106; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeRP}
    // (constant) not clipped:
    procedure FilNTValue110; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue112; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue114; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue116; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeGM}
    // (constant) not clipped:
    procedure FilNTValue120; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue122; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue124; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue126; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeGP}
    // (constant) not clipped:
    procedure FilNTValue130; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue132; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue134; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue136; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeBM}
    // (constant) not clipped:
    procedure FilNTValue140; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue142; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue144; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue146; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeBP}
    // (constant) not clipped:
    procedure FilNTValue150; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue152; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue154; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue156; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGB}
    // (constant) not clipped:
    procedure FilNTValue160; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue162; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue164; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue166; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRRB}
    // (constant) not clipped:
    procedure FilNTValue170; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue172; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue174; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue176; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGR}
    // (constant) not clipped:
    procedure FilNTValue180; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue182; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue184; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue186; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurGGB}
    // (constant) not clipped:
    procedure FilNTValue190; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue192; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue194; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue196; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGG}
    // (constant) not clipped:
    procedure FilNTValue200; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue202; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue204; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue206; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurBGB}
    // (constant) not clipped:
    procedure FilNTValue210; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue212; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue214; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue216; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRBB}
    // (constant) not clipped:
    procedure FilNTValue220; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue222; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue224; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue226; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRRR}
    // (constant) not clipped:
    procedure FilNTValue230; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue232; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue234; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue236; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurGGG}
    // (constant) not clipped:
    procedure FilNTValue240; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue242; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue244; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue246; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurBBB}
    // (constant) not clipped:
    procedure FilNTValue250; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTValue252; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTValue254; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTValue256; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Color of Curent Layer}
    // (constant) not clipped:
    procedure FilNTColor000; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTColor002; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTColor004; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTColor006; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Color of Curent Layer(Additive)}
    // (constant) not clipped:
    procedure FilNTColor010; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTColor012; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTColor014; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTColor016; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilNTColor011; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilNTColor013; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilNTColor015; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure FilNTColor017; {$ifdef Linux}[local];{$endif}

    {Color of Curent Layer(AlphaBlend)}
    // (constant) not clipped:
    procedure FilNTColor020; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilNTColor022; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilNTColor024; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilNTColor026; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;



    // PT - partly transparent pixels;

    // not clippped:
    procedure FilPTProc1_0(Proc8:TProc8); {$ifdef Linux}[local];{$endif}
    // top-bottom clippped:
    procedure FilPTProc1_2(Proc8:TProc8); {$ifdef Linux}[local];{$endif}
    // left-right-top-bottom clippped:
    procedure FilPTProc1_4(Proc8:TProc8); {$ifdef Linux}[local];{$endif}

    {Empty}
    procedure FilPTValue009; {$ifdef Linux}[local];{$endif}
    {Empty}
    procedure FilPTColor009; {$ifdef Linux}[local];{$endif}

    {Monochrome}
    // (constant) not clipped:
    procedure FilPTValue000; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue002; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped :
    procedure FilPTValue004; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Additive}
    // (constant) not clipped:
    procedure FilPTValue010; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue012; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue014; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilPTValue011; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilPTValue013; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilPTValue015; {$ifdef Linux}[local];{$endif}

    {Alphablend}
    // (constant) not clipped:
    procedure FilPTValue020; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue022; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue024; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Inverse}
    // (constant) not clipped:
    procedure FilPTValue030; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue032; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue034; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilPTValue031; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilPTValue033; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilPTValue035; {$ifdef Linux}[local];{$endif}

    {Highlight}
    // (constant) not clipped:
    procedure FilPTValue040; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue042; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue044; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Darken}
    // (constant) not clipped:
    procedure FilPTValue050; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue052; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue054; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleR}
    // (constant) not clipped:
    procedure FilPTValue060; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue062; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue064; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilPTValue061; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilPTValue063; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilPTValue065; {$ifdef Linux}[local];{$endif}

    {GrayscaleG}
    // (constant) not clipped:
    procedure FilPTValue070; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue072; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue074; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilPTValue071; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilPTValue073; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilPTValue075; {$ifdef Linux}[local];{$endif}

    {GrayscaleB}
    // (constant) not clipped:
    procedure FilPTValue080; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue082; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue084; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilPTValue081; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilPTValue083; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilPTValue085; {$ifdef Linux}[local];{$endif}

    {Monochrome Noise}
    // (constant) not clipped:
    procedure FilPTValue090; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue092; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue094; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilPTValue091; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilPTValue093; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilPTValue095; {$ifdef Linux}[local];{$endif}

    {ColorizeRM}
    // (constant) not clipped:
    procedure FilPTValue100; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue102; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue104; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeRP}
    // (constant) not clipped:
    procedure FilPTValue110; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue112; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue114; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeGM}
    // (constant) not clipped:
    procedure FilPTValue120; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue122; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue124; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeGP}
    // (constant) not clipped:
    procedure FilPTValue130; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue132; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue134; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeBM}
    // (constant) not clipped:
    procedure FilPTValue140; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue142; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue144; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeBP}
    // (constant) not clipped:
    procedure FilPTValue150; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue152; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue154; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGB}
    // (constant) not clipped:
    procedure FilPTValue160; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue162; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue164; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRRB}
    // (constant) not clipped:
    procedure FilPTValue170; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue172; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue174; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGR}
    // (constant) not clipped:
    procedure FilPTValue180; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue182; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue184; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurGGB}
    // (constant) not clipped:
    procedure FilPTValue190; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue192; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue194; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGG}
    // (constant) not clipped:
    procedure FilPTValue200; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue202; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue204; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurBGB}
    // (constant) not clipped:
    procedure FilPTValue210; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue212; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue214; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRBB}
    // (constant) not clipped:
    procedure FilPTValue220; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue222; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue224; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRRR}
    // (constant) not clipped:
    procedure FilPTValue230; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue232; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue234; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurGGG}
    // (constant) not clipped:
    procedure FilPTValue240; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue242; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue244; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurBBB}
    // (constant) not clipped:
    procedure FilPTValue250; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTValue252; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTValue254; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Color of Curent Layer}
    // (constant) not clipped:
    procedure FilPTColor000; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTColor002; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTColor004; {$ifdef Linux}[local];{$endif}
    // (constant) image has transparent alpha channel:
    procedure FilPTColor006; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Color of Curent Layer(Additive)}
    // (constant) not clipped:
    procedure FilPTColor010; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTColor012; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTColor014; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure FilPTColor016; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure FilPTColor011; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure FilPTColor013; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure FilPTColor015; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    // same as (constant);

    {Color of Curent Layer(AlphaBlend)}
    // (constant) not clipped:
    procedure FilPTColor020; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure FilPTColor022; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure FilPTColor024; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Fill Array at Specified Rectangle with Specified Value}
    procedure FilNTValueArrA(var      arr_src         :TColorArr;
                             constref bmp_ftimg_width_:TColor;
                             constref val             :TColor=0); {$ifdef Linux}[local];{$endif}
    procedure FilNTValueArrB(var      arr_src         :T1Byte1Arr;
                             constref bmp_ftimg_width_:TColor;
                             constref val             :byte=0);   {$ifdef Linux}[local];{$endif}
    procedure FilPTValueArrA(var      arr_src         :TColorArr;
                             constref bmp_ftimg_width_:TColor;
                             constref val             :TColor=0); {$ifdef Linux}[local];{$endif}
    procedure FilPTValueArrB(var      arr_src         :T1Byte1Arr;
                             constref bmp_ftimg_width_:TColor;
                             constref val             :byte=0);   {$ifdef Linux}[local];{$endif}

    {Restore Source Image from Compressed Image}
    procedure ResNTValueArr(var      arr_src         :TColorArr;
                            constref bmp_ftimg_width_:TColor);    {$ifdef Linux}[local];{$endif}

    // Check NTValueArr:
    function  ChkNTValueArr: boolean;                     inline; {$ifdef Linux}[local];{$endif}

    // NT - not transparent pixels:
    procedure SetNTNilToPtr; {$ifdef Linux}[local];{$endif}
    procedure SetNTCCLToPtr; {$ifdef Linux}[local];{$endif}
    procedure SetNTCLLToPtr; {$ifdef Linux}[local];{$endif}

    // PT - partly transparent pixels:
    procedure SetPTNilToPtr; {$ifdef Linux}[local];{$endif}
    procedure SetPTCCLToPtr; {$ifdef Linux}[local];{$endif}
    procedure SetPTCLLToPtr; {$ifdef Linux}[local];{$endif}

    // Procedures Table Init.:
    procedure FilProcInit; {$ifdef Linux}[local];{$endif}

    // Table of Counts Vertically Init.(Image Clipping):
    procedure CrtNTCntIndArr; {$ifdef Linux}[local];{$endif}
    procedure CrtPTCntIndArr; {$ifdef Linux}[local];{$endif}

    // Tile Map Drawing:
    // Fill Tile Map With Random Color:
    procedure FilTileMap0; {$ifdef Linux}[local];{$endif}
    // Fill Tile Map With Specified Sprite:
    procedure FilTileMap1; {$ifdef Linux}[local];{$endif}
    // Fill Tile Map With Rectangles:
    procedure FilTileMap2; {$ifdef Linux}[local];{$endif}

    // Full Image Drawing:
    procedure ShaderInfo;  inline; {$ifdef Linux}[local];{$endif}
    procedure SetSdrType;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrTypeInit; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType000;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType001;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType002;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType003;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType004;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType005;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType006;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType007;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType008;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType009;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType010;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType011;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType012;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType013;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType014;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType015;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType016;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType017;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType018;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType019;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType020;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType021;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType022;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType023;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType024;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType025;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType026;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType027;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType028;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType029;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType030;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType031;  inline; {$ifdef Linux}[local];{$endif}
    procedure ShaderType;  inline; {$ifdef Linux}[local];{$endif}
    procedure SdrProcInit; inline; {$ifdef Linux}[local];{$endif}
    procedure UberShader0; inline; {$ifdef Linux}[local];{$endif}
    procedure UberShader1; inline; {$ifdef Linux}[local];{$endif}
    procedure UberShader2; inline; {$ifdef Linux}[local];{$endif}
    procedure UberShader3; inline; {$ifdef Linux}[local];{$endif}

    // Clear Background from Image:
    procedure ClrBkgnd; inline; {$ifdef Linux}[local];{$endif} {$endregion}

    {Create Border Around the Image-----------------------} {$region -fold}
    procedure CrtBorderBmp   (constref arr_src      :TColorArr;
                              var arr_dst           :TObjSelArr;
                              constref arr_src_width,
                                       arr_dst_width:TColor;
                              constref rect_left,
                                       rect_top,
                                       rect_width,
                                       rect_height  :TColor;
                              var brdr_pix_cnt      :TColor;
                              constref obj_kind,
                                       obj_id       :TColor);  {$ifdef Linux}[local];{$endif}
    procedure BorderCalc1    (constref arr_src      :TColorArr;
                              var      arr_dst      :T1Byte1Arr;
                              constref arr_src_width,
                                       arr_dst_width:TColor;
                              constref rct_dst_     :TPtRect); {$ifdef Linux}[local];{$endif}
    procedure BorderCalc2    (constref arr_src      :TColorArr;
                              var      arr_dst      :T1Byte1Arr;
                              var      arr_alpha    :TAALnArr;
                              constref arr_src_width,
                                       arr_dst_width:TColor;
                              constref rct_dst_     :TPtRect;
                              out      line_cnt     :TColor);  {$ifdef Linux}[local];{$endif} {$endregion} {$endregion}

    {Image Clipping--------------} {$region -fold}
    procedure UlsProcInit;                                        {$ifdef Linux}[local];{$endif}
    procedure NTUseless0(var      arr_dst      :TColorArr;
                         constref arr_dst_width:TColor;
                         constref val          :TColor);          {$ifdef Linux}[local];{$endif}
    procedure NTUseless1(var      arr_dst      :TColorArr;
                         constref arr_dst_width:TColor;
                         constref val          :TColor);          {$ifdef Linux}[local];{$endif}
    procedure NTUseless2(var      arr_dst      :TColorArr;
                         constref arr_dst_width:TColor;
                         constref val          :TColor);          {$ifdef Linux}[local];{$endif}
    procedure PTUseless0(var      arr_dst      :TColorArr;
                         constref arr_dst_width:TColor;
                         constref val          :TColor);          {$ifdef Linux}[local];{$endif}
    procedure PTUseless1(var      arr_dst      :TColorArr;
                         constref arr_dst_width:TColor;
                         constref val          :TColor);          {$ifdef Linux}[local];{$endif}
    procedure PTUseless2(var      arr_dst      :TColorArr;
                         constref arr_dst_width:TColor;
                         constref val          :TColor);          {$ifdef Linux}[local];{$endif}
    function  Useless: byte;                              inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctPos (         rct          :TPtRect); inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctPos (         x,y,w,h      :integer); inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctPos (         x,y          :integer); inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctPos (         pvt          :TPtPosF); inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctDst;                                  inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctSrc;                                  inline; {$ifdef Linux}[local];{$endif} {$endregion}

    {Init. Part------------------} {$region -fold}
    constructor Create  (constref bkgnd_ptr     :PInteger;
                         constref bkgnd_width,
                                  bkgnd_height  :TColor;
                         var      rct_clp       :TPtRect;
                         constref bmp_src_rct   :TPtRect;
                         constref empty         :TColor=0);                 {$ifdef Linux}[local];{$endif}
    constructor Create  (constref bkgnd_ptr     :PInteger;
                         constref bkgnd_width,
                                  bkgnd_height  :TColor;
                         var      rct_clp       :TPtRect;
                         constref bmp_src_rct   :TPtRect;
                         constref location      :string  ='';
                         constref ImgLstGetBmp  :TProc1  =Nil;
                         constref img_ind       :TColor  =0;
                         constref mask_tpl_calc :boolean =False;
                         constref pic_src       :TPicture=Nil);             {$ifdef Linux}[local];{$endif}
    destructor  Destroy; override;                                          {$ifdef Linux}[local];{$endif}
    procedure SetBkgnd  (constref bkgnd_ptr     :PInteger;
                         constref bkgnd_width,
                                  bkgnd_height  :TColor;
                         constref rct_clp       :TPtRect);          inline; {$ifdef Linux}[local];{$endif}
    procedure SetClpRct (constref rct_clp       :TPtRect);          inline; {$ifdef Linux}[local];{$endif}
    procedure SetValInfo(constref bmp_color_ptr_,
                                  bmp_alpha_ptr_,
                                  bmp_value_ptr_:PInteger;
                         constref ftimg_width,
                                  ftimg_height  :TColor);           inline; {$ifdef Linux}[local];{$endif}
    procedure SetPPInfo (         val           :TColor=$00434D3E); inline; {$ifdef Linux}[local];{$endif}
    procedure SetGradVec(constref vec           :TLnPos          ); inline; {$ifdef Linux}[local];{$endif}
    procedure SetGradVec(         x0,y0,x1,y1   :integer         ); inline; {$ifdef Linux}[local];{$endif}
    procedure SrcDestroy(         bmp_src       :TPicture        ); inline; {$ifdef Linux}[local];{$endif}
    procedure SrcDestroy(         bmp_src       :TBitmap         ); inline; {$ifdef Linux}[local];{$endif}
    procedure SrcDestroy(         arr_src       :TColorArr       ); inline; {$ifdef Linux}[local];{$endif}
    procedure SrcDestroy(         arr_src       :TWordArr        ); inline; {$ifdef Linux}[local];{$endif}
    procedure SrcDestroy(         arr_src       :T1Byte1Arr      ); inline; {$ifdef Linux}[local];{$endif} {$endregion}

  end; {$endregion}
  {****************************************************************************}



  {Fast Line ******************************************************************}
  TFastLine         =class {$region -fold}

    {Misc. Types------------------------------------} {$region -fold}
    {type
      TGCDGrid={type} packed record
        f_ln_kind,a,b,c,d: integer;
      end;
      TGCDArr =array of TGCDGrid;} {$endregion}

    {State Machine for Line Drawing Routines--------} {$region -fold}
    protected
      var
        LineProc: array[0..39] of TProc0; {$endregion}

    {Edges and Points Pixels Buffers----------------} {$region -fold}
    public
      var
        {spline sprite}
        fst_img              : TFastImage;

        {static edges buffer : for "vertical"   lines}
        ln_arr2              : T2ByteArr;

        {static edges buffer : for "regular"    lines}
        ln_arr1              : TColorArr;

        {static edges buffer : for "horizontal" lines}
        ln_arr0              : T1Byte1Arr;

        {destination bitmap(background)}
        bmp_dst_ptr          : PInteger;
        bmp_dst_width        : TColor;
        bmp_dst_height       : TColor;

        {source array}
        ln_arr1_ptr          : PInteger;
        ln_arr0_ptr          : PByte;
        ln_arr_width         : TColor;
        ln_arr_height        : TColor;

        {line kind pointer}
        ln_kind_ptr          : PInteger; {$endregion}

    {Misc. Variables: Line Drawing------------------} {$region -fold}
    protected
      var
        dx,dy,a,b,c,m1,m2: integer;
        r0,p0,r1,p1,g    : integer; {$endregion}

    {Hidden-Line Elimination------------------------} {$region -fold}
    public
     {is line visible array:
      0 - line is invisible;
      1 - line is   visible}
      useless_arr: T1Byte1Arr;
     {hidden  lines count}
      hid_ln_cnt : TColor;
     {visible lines count}
      vis_ln_cnt : TColor;
     {existing lines count}
      has_ln_cnt : TColor; {$endregion}

    {Misc. Variables: Clipping----------------------} {$region -fold}
    public
      {drawing window rectangle pointer}
      rct_clp_ptr: PPtRect;
      ln_pos     : TLnPos;
      color_info : TColorInfo;
      pix_cnt    : TColor; {$endregion}

    {Resilient Line---------------------------------} {$region -fold}
    res_ln_pts_cnt: TColorArr; {$endregion}

    {Precalculated Table of Greatest Common Divisors} {$region -fold}
    {public
      {class} var
        {array of greatest common divisors}
        gcd_arr    : TGCDArr;
        {precision of calculation}
        grid_pt_rad: TColor;} {$endregion}

    {Spline Local Properties------------------------} {$region -fold}
    public
      var
        local_prop: TCurveProp; {$endregion}

    {Bounding Rectangles of Spline Object-----------} {$region -fold}
    public
      var
        {spline entire rectangle}
        rct_ent: TRect;
        {spline visible(clipped by inner window) rectangle}
        rct_vis: TRect;
        {spline window(inner window) rectangle}
        rct_wnd: TRect; {$endregion}

    {Post-Processing--------------------------------} {$region -fold}
    args             : TFunc0Args;
    pp_dec_2_proc_ind: byte; {$endregion}

    {Edge Anti-Aliasing-----------------------------} {$region -fold}
    public
      var
        {alpha border of anti-aliased spline}
        aa_arr2            : TAALnArr;
        {alpha border of anti-aliased spline}
        aa_arr1            : T1Byte1Arr;
        {antialiased lines count}
        aa_line_cnt        : TColor;
        aa_nz_arr_items_cnt: TColor; {$endregion}

    {Misc. Routines---------------------------------} {$region -fold}
    public
      constructor Create;                                                           {$ifdef Linux}[local];{$endif}
      destructor  Destroy; override;                                                {$ifdef Linux}[local];{$endif}
      procedure GCCArrInit;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure GCCArrRepl        (         dst_fl_var     :TFastLine);     inline; {$ifdef Linux}[local];{$endif}
      procedure BuffersInit       (         w,h            :TColor;
                                            ln_arr0_init   :boolean;
                                            ln_arr1_init   :boolean;
                                            ln_arr2_init   :boolean;
                                            aa_buff_init   :boolean);       inline; {$ifdef Linux}[local];{$endif}
      procedure SetBkgnd          (constref bmp_dst_ptr_   :PInteger;
                                   constref bmp_dst_width_,
                                            bmp_dst_height_:TColor;
                                   constref rct_clp_ptr_   :PPtRect);       inline; {$ifdef Linux}[local];{$endif}
      procedure MinimizeArrs      (         aa_buff_clear  :boolean);       inline; {$ifdef Linux}[local];{$endif}
      {Fast Line Grid Precalculation}
    {class} procedure LinePrecalc (         w,h            :TColor);                {$ifdef Linux}[local];{$endif}
      {Solid Line Initialization}
      procedure LineSInit;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL00;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL01;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL02;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL10;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL11;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL20;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL21;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL30;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL31;                                                  inline; {$ifdef Linux}[local];{$endif}

    protected
      {Right Bottom Corner}
      {0°..-45°}
      procedure LineS00;                                                    inline; {$ifdef Linux}[local];{$endif}
      procedure LineS01RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS02RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS03RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS04RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS05RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS06RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS07RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS08RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS09RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      {-45°..-90°}
      procedure LineS10;                                                    inline; {$ifdef Linux}[local];{$endif}
      procedure LineS11RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS12RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS13RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS14RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS15RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS16RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS17RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS18RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS19RBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      {Left Bottom Corner}
      {-135°..-180°}
      procedure LineS20;                                                    inline; {$ifdef Linux}[local];{$endif}
      procedure LineS21LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS22LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS23LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS24LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS25LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS26LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS27LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS28LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS29LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      {-90°..-135°}
      procedure LineS30;                                                    inline; {$ifdef Linux}[local];{$endif}
      procedure LineS31LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS32LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS33LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS34LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS35LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS36LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS37LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS38LBC;                                                 inline; {$ifdef Linux}[local];{$endif}
      procedure LineS39LBC;                                                 inline; {$ifdef Linux}[local];{$endif}

    public
      {Solid Line Drawing}
      {Fast Line Solid Mode Normal}
      procedure LineSMN           (constref x0,y0,x1,y1    :integer);       inline; {$ifdef Linux}[local];{$endif}
      {Fast Line Solid Mode Extended}
      procedure LineSME           (constref x0,y0,x1,y1    :integer;
                                   constref proc_ptr_a     :TProc0;
                                   constref proc_ptr_b     :TProc0);        inline; {$ifdef Linux}[local];{$endif}
      {Fast Line Po-Han Lin}
      procedure LinePHL           (constref x0,y0,x1,y1    :integer;
                                   constref proc_ptr_a     :TProc0;
                                   constref proc_ptr_b     :TProc0);        inline; {$ifdef Linux}[local];{$endif}
      {Solid Horizontal Line Drawing}
      procedure LineSHL00;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LineSHL10;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LineSHL20;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LineSHL30;                                                  inline; {$ifdef Linux}[local];{$endif}
      {Solid Vertical Line Drawing}
      procedure LineSVL00;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LineSVL10;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LineSVL20;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure LineSVL30;                                                  inline; {$ifdef Linux}[local];{$endif}
      {Fast Line Clipping}
      procedure ClippedLine1      (         x0,y0,x1,y1    :integer;
                                   const    rct_clp        :TPtRect;
                                   constref proc1          :TProc3;
                                   constref proc2          :TProc0;
                                   constref proc3          :TProc0);                {$ifdef Linux}[local];{$endif}
      procedure ClippedLine2      (         x0,y0,x1,y1    :integer;
                                   const    rct_clp        :TPtRect;
                                   constref proc1          :TProc3;
                                   constref proc2          :TProc0;
                                   constref proc3          :TProc0);                {$ifdef Linux}[local];{$endif}
      procedure ClippedLine2      (         x0,y0,x1,y1    :integer;
                                   const    rct_clp        :TPtRect);               {$ifdef Linux}[local];{$endif}
      procedure FillBuffer        (constref rct_clp        :TPtRect);               {$ifdef Linux}[local];{$endif} {$endregion}

  end; {$endregion}
  PFastLine         =^TFastLine;
  {****************************************************************************}



  {Fast Text ******************************************************************}
  TFastText         =class {$region -fold}
    public
      var
        {text sprite}
        fst_img   : TFastImage;
        {Text Local Properties}
        local_prop: TFTextProp;
      constructor Create;            {$ifdef Linux}[local];{$endif}
      destructor  Destroy; override; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PFastText         =^TFastText;
  {****************************************************************************}



{Color Transform}
function Red                    (         pixel              :TColor): byte;           inline; {$ifdef Linux}[local];{$endif}
function Green                  (         pixel              :TColor): byte;           inline; {$ifdef Linux}[local];{$endif}
function Blue                   (         pixel              :TColor): byte;           inline; {$ifdef Linux}[local];{$endif}
function RGB                    (         r,g,b              :byte): TColor;           inline; {$ifdef Linux}[local];{$endif}
function SetColorInv            (         pixel              :TColor;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): TColor;     inline; {$ifdef Linux}[local];{$endif}
function Additive               (         pixel              :TColor;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): TColor;     inline; {$ifdef Linux}[local];{$endif}
procedure AlphaBlend            (         pixel_ptr          :PInteger;
                                 constref r,g,b              :byte;
                                 constref d_alpha            :byte);                   inline; {$ifdef Linux}[local];{$endif}
function AlphaBlend             (         pixel              :TColor;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): TColor;     inline; {$ifdef Linux}[local];{$endif}
function Inverse                (         pixel              :TColor): TColor;         inline; {$ifdef Linux}[local];{$endif}
function Highlight              (         pixel              :TColor;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): TColor;     inline; {$ifdef Linux}[local];{$endif}
function Darken                 (         pixel              :TColor;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): TColor;     inline; {$ifdef Linux}[local];{$endif}
function GrayscaleR             (         pixel              :TColor;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): TColor;     inline; {$ifdef Linux}[local];{$endif}
function GrayscaleG             (         pixel              :TColor;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): TColor;     inline; {$ifdef Linux}[local];{$endif}
function GrayscaleB             (         pixel              :TColor;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): TColor;     inline; {$ifdef Linux}[local];{$endif}
function ColorizeRM             (         pixel              :TColor;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): TColor;     inline; {$ifdef Linux}[local];{$endif}
function ColorizeRP             (         pixel              :TColor;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): TColor;     inline; {$ifdef Linux}[local];{$endif}
function ColorizeGM             (         pixel              :TColor;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): TColor;     inline; {$ifdef Linux}[local];{$endif}
function ColorizeGP             (         pixel              :TColor;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): TColor;     inline; {$ifdef Linux}[local];{$endif}
function ColorizeBM             (         pixel              :TColor;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): TColor;     inline; {$ifdef Linux}[local];{$endif}
function ColorizeBP             (         pixel              :TColor;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=255;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): TColor;     inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGB               (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRB               (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGR               (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGB               (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGG               (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure BlurBGB               (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure BlurRBB               (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRR               (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGG               (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure BlurBBB               (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure Contrast              (         pixel_ptr          :PInteger;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref contrast_pow2      :double=0.0);             inline; {$ifdef Linux}[local];{$endif}
function AdditiveDec            (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                 constref alpha_fade         :byte): TColor;           inline; {$ifdef Linux}[local];{$endif}
function AdditiveDec2           (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
procedure AlphaBlendDec         (         pixel_ptr          :PInteger;
                                 constref r,g,b              :byte;
                                          alpha              :byte;
                                 constref alpha_fade         :byte);                   inline; {$ifdef Linux}[local];{$endif}
function AlphaBlendDec          (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte): TColor;           inline; {$ifdef Linux}[local];{$endif}
function AlphaBlendDec2         (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
function InverseDec             (         pixel              :TColor;
                                 constref alpha_fade         :byte): TColor;           inline; {$ifdef Linux}[local];{$endif}
function InverseDec2            (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
function HighlightDec           (         pixel              :TColor;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte=64): TColor;        inline; {$ifdef Linux}[local];{$endif}
function HighlightDec2          (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
function DarkenDec              (         pixel              :TColor;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte=64): TColor;        inline; {$ifdef Linux}[local];{$endif}
function DarkenDec2             (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
function GrayscaleRDec          (         pixel              :TColor;
                                 constref alpha_fade         :byte): TColor;           inline; {$ifdef Linux}[local];{$endif}
function GrayscaleRDec2         (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
function GrayscaleGDec          (         pixel              :TColor;
                                 constref alpha_fade         :byte): TColor;           inline; {$ifdef Linux}[local];{$endif}
function GrayscaleGDec2         (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
function GrayscaleBDec          (         pixel              :TColor;
                                 constref alpha_fade         :byte): TColor;           inline; {$ifdef Linux}[local];{$endif}
function GrayscaleBDec2         (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
function ColorizeRMDec          (         pixel              :TColor;
                                 constref alpha_fade         :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
function ColorizeRMDec2         (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
function ColorizeRPDec          (         pixel              :TColor;
                                 constref alpha_fade         :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
function ColorizeRPDec2         (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
function ColorizeGMDec          (         pixel              :TColor;
                                 constref alpha_fade         :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
function ColorizeGMDec2         (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
function ColorizeGPDec          (         pixel              :TColor;
                                 constref alpha_fade         :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
function ColorizeGPDec2         (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
function ColorizeBMDec          (         pixel              :TColor;
                                 constref alpha_fade         :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
function ColorizeBMDec2         (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
function ColorizeBPDec          (         pixel              :TColor;
                                 constref alpha_fade         :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
function ColorizeBPDec2         (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}

{Misc. Routines}
function GetEnumVal             (         enum               :TDrawingStyle): TColor;  inline; {$ifdef Linux}[local];{$endif}
function GetEnumVal             (         enum               :TDrawingStyle): integer; inline; {$ifdef Linux}[local];{$endif}
//
function Min1                   (constref a1,a2              :double ): double ;       inline; {$ifdef Linux}[local];{$endif}
function Min2                   (constref a1,a2              :integer): integer;       inline; {$ifdef Linux}[local];{$endif}
function Min3                   (constref a1,a2              :TColor ): TColor;        inline; {$ifdef Linux}[local];{$endif}
//
function Min4                   (constref arr                :TIntrArr;
                                 constref max_item_val       :integer;
                                 constref item_cnt           :integer): integer;       inline; {$ifdef Linux}[local];{$endif}
function Min5                   (constref arr                :TColorArr;
                                 constref max_item_val       :TColor;
                                 constref item_cnt           :TColor): TColor;         inline; {$ifdef Linux}[local];{$endif}
//
function Min6                   (constref arr                :TIntrArr;
                                 constref max_item_val       :integer;
                                 constref item_cnt           :integer;
                                 constref b                  :boolean): integer;       inline; {$ifdef Linux}[local];{$endif}
function Min7                   (constref arr                :TColorArr;
                                 constref max_item_val       :TColor;
                                 constref item_cnt           :TColor;
                                 constref b                  :boolean): TColor;        inline; {$ifdef Linux}[local];{$endif}
//
function Min8                   (constref arr                :TEdgeArr;
                                 constref max_item_val       :integer;
                                 constref item_cnt           :integer): integer;       inline; {$ifdef Linux}[local];{$endif}
function Min9                   (constref arr                :TEdgeArr;
                                 constref max_item_val       :TColor;
                                 constref item_cnt           :TColor): TColor;         inline; {$ifdef Linux}[local];{$endif}
//
function Max1                   (constref a1,a2              :double ): double ;       inline; {$ifdef Linux}[local];{$endif}
function Max2                   (constref a1,a2              :integer): integer;       inline; {$ifdef Linux}[local];{$endif}
function Max3                   (constref a1,a2              :TColor ): TColor;        inline; {$ifdef Linux}[local];{$endif}
function Max4                   (constref arr                :TIntrArr;
                                 constref min_item_val       :integer;
                                 constref item_cnt           :integer): integer;       inline; {$ifdef Linux}[local];{$endif}
function Max5                   (constref arr                :TColorArr;
                                 constref min_item_val       :TColor;
                                 constref item_cnt           :TColor): TColor;         inline; {$ifdef Linux}[local];{$endif}
function Max6                   (constref arr                :TIntrArr;
                                 constref min_item_val       :integer;
                                 constref item_cnt           :integer;
                                 constref b                  :boolean): integer;       inline; {$ifdef Linux}[local];{$endif}
function Max7                   (constref arr                :TColorArr;
                                 constref min_item_val       :TColor;
                                 constref item_cnt           :TColor;
                                 constref b                  :boolean): TColor;        inline; {$ifdef Linux}[local];{$endif}
function Max8                   (constref arr                :TEdgeArr;
                                 constref min_item_val       :integer;
                                 constref item_cnt           :integer): integer;       inline; {$ifdef Linux}[local];{$endif}
function Max9                   (constref arr                :TEdgeArr;
                                 constref min_item_val       :TColor;
                                 constref item_cnt           :TColor): TColor;         inline; {$ifdef Linux}[local];{$endif}
function InvSqrt                (constref x                  :single): single;         inline; {$ifdef Linux}[local];{$endif}
function Limit                  (         x                  :integer): byte;          inline; {$ifdef Linux}[local];{$endif}
procedure PtrInit               (var      ptr                :PInteger;
                                 constref arr                :TIntrArr);               inline; {$ifdef Linux}[local];{$endif}
procedure PtrInit               (var      ptr                :PInteger;
                                 constref arr                :TColorArr);              inline; {$ifdef Linux}[local];{$endif}
procedure MaxSpriteWHRctInit    (var      rct                :TPtRect);                inline; {$ifdef Linux}[local];{$endif}
function ArcTan4                (constref x0,y0,x1,y1        :double): double;         inline; {$ifdef Linux}[local];{$endif}

function IndexOfSubStr          (const    list               :TStrings;
                                 var      sub_string         :string): integer;        inline; {$ifdef Linux}[local];{$endif}

// (Binary Search) Бинарный поиск:
function BinarySearch           (constref n                  :TColor;
                                 constref arr_item_ptr       :PInteger;
                                 constref right_border       :integer): integer;       inline; {$ifdef Linux}[local];{$endif}

{Store Color Channel into Integer Array}
procedure BmpToArr              (constref bmp_src_ptr        :PInteger;
                                 var      bmp_dst_ptr        :PInteger;
                                 var      arr_dst            :TColorArr;
                                 constref bmp_src_rct        :TPtRect;
                                 constref bmp_src_width,
                                          bmp_src_height     :TColor;
                                 var      bmp_dst_width,
                                          bmp_dst_height     :TColor);                 inline; {$ifdef Linux}[local];{$endif}

{Store Alpha Channel into Byte Array}
//...

(******************************* Bitmap Loading *******************************)

function CrtTPicInstFromHDDSrc  (constref location           :string): TPicture;       inline; {$ifdef Linux}[local];{$endif}
function CrtTBmpInstFromImgLst  (constref ImgLstGetBmp       :TProc1;
                                 constref img_ind            :TColor=0): TBitmap;      inline; {$ifdef Linux}[local];{$endif}
function CrtTBmpInst            (constref bmp_src            :TBitmap;
                                 var      bmp_dst_ptr        :PInteger): TBitmap;      inline; {$ifdef Linux}[local];{$endif}
function CrtTBmpInst            (constref bmp_dst_width,
                                          bmp_dst_height     :TColor;
                                 var      bmp_src_ptr        :PInteger): TBitmap;      inline; {$ifdef Linux}[local];{$endif}

{Arrays Addition}
procedure ArrAdd                (constref arr_src1,
                                          arr_src2           :T1Byte1Arr;
                                 var      arr_dst            :TColorArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (constref arr_src1,
                                          arr_src2           :TDublArr;
                                 var      arr_dst            :TDublArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (constref arr_src1,
                                          arr_src2           :TColorArr;
                                 var      arr_dst            :TColorArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (constref arr_src1,
                                          arr_src2           :TWordArr;
                                 var      arr_dst            :TWordArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (constref arr_src1,
                                          arr_src2           :T1Byte1Arr;
                                 var      arr_dst            :T1Byte1Arr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (constref arr_src1           :TColorArr;
                                 constref arr_src2           :T1Byte1Arr;
                                 constref width,
                                          height             :TColor;
                                 constref val                :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (constref arr_src1           :T1Byte1Arr;
                                 constref arr_src2           :T2ByteArr;
                                 constref arr_dst            :TColorArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (constref arr_src1           :T1Byte1Arr;
                                 constref arr_src2           :T2ByteArr;
                                 constref arr_dst            :T1Byte1Arr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (var      arr_src1           :T1Byte1Arr;
                                 constref arr_src2           :T2ByteArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (var      arr_src1           :T1Byte1Arr;
                                 constref arr_src2           :T2ByteArr;
                                 constref rct_dst            :TPtrect;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}

{Arrays Subtraction}
procedure ArrSub                (constref arr_src1,
                                          arr_src2           :TDublArr;
                                 var      arr_dst            :TDublArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrSub                (constref arr_src1,
                                          arr_src2           :TIntrArr;
                                 var      arr_dst            :TIntrArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrSub                (constref arr_src1,
                                          arr_src2           :TColorArr;
                                 var      arr_dst            :TColorArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrSub                (constref arr_src1,
                                          arr_src2           :TWordArr;
                                 var      arr_dst            :TWordArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrSub                (constref arr_src1,
                                          arr_src2           :T1Byte1Arr;
                                 var      arr_dst            :T1Byte1Arr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrSub                (constref arr_src            :T1Byte1Arr;
                                 constref arr_dst            :TIntrArr;
                                 constref width,height       :TColor;
                                 constref val                :TColor);                         {$ifdef Linux}[local];{$endif}

{2D Array to 1D Array}
procedure Arr2DTo1D             (constref arr_src            :T2ByteArr;
                                 var      arr_dst            :T1Byte1Arr;
                                 constref arr_src_width,
                                          arr_src_height     :TColor);                         {$ifdef Linux}[local];{$endif}

{Clear Arrays}
procedure BmpClear              (         bmp                :Graphics.TBitmap);       inline; {$ifdef Linux}[local];{$endif}
procedure ArrClear              (         arr1_ptr           :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref arr_width          :TColor;
                                 constref val                :TColor=0);               inline; {$ifdef Linux}[local];{$endif}
procedure ArrClear              (var      arr0               :T1Byte1Arr;
                                 constref rct_dst            :TPtRect;
                                 constref arr_width          :TColor;
                                 constref val                :byte=0);                 inline; {$ifdef Linux}[local];{$endif}
procedure ArrClear              (var      arr1               :TColorArr;
                                 constref rct_dst            :TPtRect;
                                 constref arr_width          :TColor;
                                 constref val                :TColor=0);               inline; {$ifdef Linux}[local];{$endif}
procedure ArrClear              (var      arr1_ptr           :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref arr_width          :TColor;
                                          f1,f2,f3,f4        :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure ArrClear              (var      arr2               :T2ByteArr;
                                 constref rct_dst            :TPtRect;
                                 constref val                :byte=0);                 inline; {$ifdef Linux}[local];{$endif}
procedure ArrClear              (var      arr3               :TPtPos2Arr;
                                 constref rct_dst            :TPtRect;
                                 constref arr_width          :TColor);                 inline; {$ifdef Linux}[local];{$endif}

// Clear Alpha Channel:
function ArrClear               (         arr1_ptr           :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref arr_width          :TColor;
                                 constref val                :TColor=0;
                                          b                  :boolean=False):byte;     inline; {$ifdef Linux}[local];{$endif}

{Fill Arrays On Bitmap}
procedure ArrFillProc00         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc01         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc02         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc03         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc04         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc05         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc06         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc07         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc08         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc09         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc10         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc11         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc12         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc13         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc14         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc15         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc16         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc17         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc18         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc19         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc20         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc21         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc22         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc23         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc24         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFillProc25         (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
//
procedure ArrFill               (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtrect;
                                          b                  : boolean);

procedure ArrFill               (constref arr0               :TColorArr ;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtrect;
                                 constref col                :TColor);
procedure ArrFill               (constref arr0               :TPtPos2Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtrect;
                                 constref col                :TColor);
procedure ArrFill               (constref arr0               :TPtPos2Arr;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtrect);
procedure ArrFill               (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtrect);
//
procedure ArrFillTest           (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtrect;
                                 constref col                :TColor);
procedure ArrFillTest           (constref arr0               :TIntrArr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                 bmp_height                  :TColor;
                                 constref rct_dst            :TPtrect;
                                 constref col                :TColor);

// Non-Zero Items Count:
function ArrNzItCnt             (constref arr                :T1Byte1Arr): TColor;             {$ifdef Linux}[local];{$endif}
function ArrNzItCnt             (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref col                :TColor): TColor;                 {$ifdef Linux}[local];{$endif}
function ArrNzItCnt             (constref arr1_ptr           :PShortInt;
                                 constref arr2_ptr           :PByte;
                                 constref length             :integer): TColor;                {$ifdef Linux}[local];{$endif}
function ArrNzItCnt             (constref arr1_ptr           :PShortInt;
                                 constref length             :integer;
                                          b                  :boolean): TColor;                {$ifdef Linux}[local];{$endif}
function ArrNzItCnt             (constref arr                :T1Byte1Arr;
                                 constref max_arr_it_val     :TColor=MAXBYTE ): TColor;        {$ifdef Linux}[local];{$endif}
function ArrNzItCnt             (constref arr                :TWordArr;
                                 constref max_arr_it_val     :TColor=MAXWORD ): TColor;        {$ifdef Linux}[local];{$endif}
function ArrNzItCnt             (constref arr                :TColorArr;
                                 constref max_arr_it_val     :TColor=MAXDWORD): TColor;        {$ifdef Linux}[local];{$endif}

// Create Array With "Visible" Items:
procedure ArrNzItCrt            (constref arr1_src_ptr       :PShortInt;
                                 constref arr2_src_ptr       :PByte;
                                          arr_dst_ptr        :PColor;
                                 constref length1,
                                          length2            :integer);                        {$ifdef Linux}[local];{$endif}
procedure ArrNzItCrt            (constref arr1_src_ptr       :PShortInt;
                                          arr_dst_ptr        :PColor;
                                 constref length1,
                                          length2            :integer);                        {$ifdef Linux}[local];{$endif}

// Copy One Array To Another:
procedure ArrToArr1             (         arr_src_ptr        :PPtPosF;
                                          arr_dst_ptr        :PPtPosF;
                                          pts_cnt            :integer);                        {$ifdef Linux}[local];{$endif}
procedure ArrToArr2             (         arr_src_ptr        :PPtPosF;
                                          arr_dst_ptr        :PPtPosF;
                                          pts_cnt            :integer);                        {$ifdef Linux}[local];{$endif}

{Linked Lists}
procedure AddListItem           (constref pt_x               :integer;
                                 var      first_item,p1,p2   :PIList);
procedure AddListItem           (constref pt                 :TPtPosF;
                                 var      first_item,p1,p2   :PFList);
procedure ArrToList1            (constref arr_src            :TIntrArr;
                                 var      first_item,p1,p2   :PIList);
procedure ArrToList2            (constref arr_src            :TIntrArr;
                                 var      first_item,p1,p2   :PIList);
procedure ListToArr             (var      arr_dst            :TIntrArr;
                                 var      first_item,p1,p2   :PIList);
procedure ListToArr             (var      arr_dst            :TPtPosFArr;
                                 var      first_item,p1,p2   :PFList);
procedure FreeList1             (var      first_item,p1,p2   :PIList);
procedure FreeList2             (var      first_item,p1,p2   :PFList);


{Edge Antialiasing}
procedure BorderCalc000         (constref arr_src            :T1Byte1Arr;
                                 var      arr_dst            :T1Byte1Arr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 var      aa_nz_arr_it_cnt   :TColor);                         {$ifdef Linux}[local];{$endif}
procedure BorderCalc0           (constref arr_src_ptr        :PInteger;
                                 var      arr_dst            :T1Byte1Arr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 var      aa_nz_arr_it_cnt   :TColor;
                                 constref background_color   :TColor);                         {$ifdef Linux}[local];{$endif}
procedure BorderCalc1           (constref arr_src_ptr        :PInteger;
                                 var      arr_dst            :T1Byte1Arr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 var      aa_nz_arr_it_cnt   :TColor);                         {$ifdef Linux}[local];{$endif}
procedure BorderCalc1           (constref arr_src            :TColorArr;
                                 var      arr_dst            :T1Byte1Arr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 var      aa_nz_arr_it_cnt   :TColor);                         {$ifdef Linux}[local];{$endif}
procedure BorderCalc1           (constref arr_src            :T1Byte1Arr;
                                 var      arr_dst            :T1Byte1Arr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 var      aa_nz_arr_it_cnt   :TColor);                         {$ifdef Linux}[local];{$endif}

// Mixed: Image Has Circle And Other Contours:
procedure BorderCalc20          (constref arr_src_ptr        :PInteger;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                         {$ifdef Linux}[local];{$endif}
procedure BorderCalc20          (constref arr_src            :TColorArr;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                         {$ifdef Linux}[local];{$endif}
procedure BorderCalc20          (constref arr_src            :T1Byte1Arr;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                         {$ifdef Linux}[local];{$endif}

// Image Has Only Circle Contours:
procedure BorderCalc21          (constref arr_src_ptr        :PInteger;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                         {$ifdef Linux}[local];{$endif}
procedure BorderCalc21          (constref arr_src            :TColorArr;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                         {$ifdef Linux}[local];{$endif}
procedure BorderCalc21          (constref arr_src            :T1Byte1Arr;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                         {$ifdef Linux}[local];{$endif}

// Image Has No Circle Contours:
procedure BorderCalc22          (constref arr_src_ptr        :PInteger;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                         {$ifdef Linux}[local];{$endif}
procedure BorderCalc22          (constref arr_src            :TColorArr;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                         {$ifdef Linux}[local];{$endif}
procedure BorderCalc22          (constref arr_src            :T1Byte1Arr;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                         {$ifdef Linux}[local];{$endif}

procedure BorderFill            (constref arr_src            :TAALnArr;
                                 constref rct_dst_left,
                                          rct_dst_top        :integer;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width          :TColor;
                                 constref line_cnt           :TColor;
                                 constref col                :TColor;
                                          args               :TFunc0Args;
                                          Func2              :TFunc2);
procedure BorderFill            (constref arr_src            :TAALnArr;
                                 constref rct_dst_left,
                                          rct_dst_top        :integer;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width          :TColor;
                                 constref line_cnt           :TColor;
                                 constref col                :TColor;
                                          args               :TFunc0Args);
procedure BorderFill            (constref arr_src            :TAALnArr;
                                 constref rct_dst_left,
                                          rct_dst_top        :integer;
                                 constref bmp_ptr            :PByte;
                                 constref bmp_width          :TColor;
                                 constref line_cnt           :TColor;
                                 constref col                :TColor;
                                          args               :TFunc0Args);

// One-Pixel Border-Blur Calculation:
procedure BorderPixCh           (         arr_src_ptr        :PInteger;
                                 constref arr_src_width      :TColor;
                                 constref background_color   :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure BorderPixCh           (         arr_src_ptr        :PInteger;
                                 constref arr_src_width      :TColor;
                                 constref alpha_color        :byte);                   inline; {$ifdef Linux}[local];{$endif}
procedure BorderPixCh           (         arr_src_ptr        :PInteger;
                                 constref arr_src_width      :TColor;
                                 constref alpha_color        :byte;
                                 constref alpha_mask         :TColor);                 inline; {$ifdef Linux}[local];{$endif}

// Border Blur:
procedure BorderBlur            (constref arr_src_ptr        :PInteger;
                                 var      arr_dst            :T1Byte1Arr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref background_color   :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure BorderBlur            (constref arr_src_ptr        :PInteger;
                                 constref arr_src_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref alpha_color        :byte);                   inline; {$ifdef Linux}[local];{$endif}
procedure BorderBlur            (constref arr_src_ptr        :PInteger;
                                 constref arr_src_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref alpha_color        :byte;
                                 constref mask               :TColor);                 inline; {$ifdef Linux}[local];{$endif}

procedure EdgeAATest            (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref val1,val2          :byte);                   inline; {$ifdef Linux}[local];{$endif}

(****************************** Points Transform ******************************)

// (Align Points to horizontal line, from left to right): Выровнять точки по горизонтали, слева направо:
procedure PtsRawH               (var      pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref pts_dist           :TColor);                 inline; {$ifdef Linux}[local];{$endif}

// (Align Points to vertical line, from top to bottom): Выровнять точки по вертикали, сверху вниз:
procedure PtsRawV               (var      pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref pts_dist           :TColor);                 inline; {$ifdef Linux}[local];{$endif}

// (Reset Points Position): Восстановить позицию точек:
procedure PtsRes                (constref fst_pt_ptr1,
                                          fst_pt_ptr2        :PPtPosF;
                                 constref pts_cnt            :TColor;
                                 constref pt_pos_curr,
                                          pt_pos_prev        :TPtPosF);                inline; {$ifdef Linux}[local];{$endif}

// (Points Pivot) Ось точек:
procedure PtsPvt                (var      pvt                :TPtPosF;
                                 var      pts                :TPtPosFArr;
                                 constref pts_cnt            :TColor);                 inline; {$ifdef Linux}[local];{$endif}

// (Points Moving) Перемещение точек:
procedure PtsMov                (constref pvt                :TPtPos;
                                 var      pts                :TPtPosFArr;
                                 constref fst_ind,
                                          lst_ind            :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure PtsMov                (constref pvt                :TPtPos;
                                 var      rct                :TPtRect);                inline; {$ifdef Linux}[local];{$endif}
procedure PtsMov                (constref pvt                :TPtPos;
                                 var      rct                :TRect);                  inline; {$ifdef Linux}[local];{$endif}

procedure WndSht                (constref outer_rect         :TPtRect;
                                 constref inner_rect         :TPtPosFArr;
                                 var      shift_power        :integer;
                                 constref mul                :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure MDCalc                (var      rct                :TRect;
                                 constref mov_dir            :TMovingDirection;
                                 constref parallax_shift     :TPtPos);                 inline; {$ifdef Linux}[local];{$endif}

// (Points Scaling) Масштабирование точек:
procedure PtsScl                (constref pvt                :TPtPosF;
                                 var      pts                :TPtPosFArr;
                                          scl_mul            :TPtPosF;
                                 constref scl_dir            :TSclDir;
                                          fst_ind            :TColor=0;
                                          lst_ind            :TColor=0);               inline; {$ifdef Linux}[local];{$endif}
procedure PtsScl                (constref pvt                :TPtPosF;
                                 var      rct                :TPtRectF;
                                          scl_mul            :TPtPosF;
                                 constref scl_dir            :TSclDir);                inline; {$ifdef Linux}[local];{$endif}
procedure PtsScl                (constref pvt                :TPtPosF;
                                 var      rct                :TRect;
                                          scl_mul            :TPtPosF;
                                 constref scl_dir            :TSclDir);                inline; {$ifdef Linux}[local];{$endif}
function  GetDir1               (         prev_pos,
                                          curr_pos,
                                          pvt                :TPtPosF): TSclDir;       inline; {$ifdef Linux}[local];{$endif}
function  GetDir2               (         prev_pos,
                                          curr_pos,
                                          pvt                :TPtPosF): TSclDir;       inline; {$ifdef Linux}[local];{$endif}
procedure SetMul                (         prev_pos,
                                          curr_pos,
                                          pvt                :TPtPosF;
                                 var      scl_mul            :TPtPosF;
                                 constref scl_dir            :TSclDir);                inline; {$ifdef Linux}[local];{$endif}

// (Points Rotation) Вращение точек:
procedure GetRot                (constref pvt                :TPtPos;
                                 constref angle              :double;
                                 var      c,s,v,w            :double);                 inline; {$ifdef Linux}[local];{$endif}
procedure GetRot                (constref pvt                :TPtPos;
                                 constref angle              :double;
                                 var      c,s,v,w            :integer;
                                 constref x,y                :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure GetRot                (constref pvt                :TPtPosF;
                                 constref angle              :double;
                                 var      c,s,v,w            :double);                 inline; {$ifdef Linux}[local];{$endif}
procedure GetRotRound           (constref pvt                :TPtPos;
                                 constref angle              :double;
                                 var      c,s,v,w            :double;
                                 constref x,y                :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure GetRotNotRound        (constref pvt                :TPtPos;
                                 constref angle              :double;
                                 var      c,s,v,w            :double;
                                 constref x,y                :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure GetRotNotRound2       (constref pvt                :TPtPos;
                                 constref angle              :double;
                                 var      c,s,v,w            :integer;
                                 constref x,y                :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure PtsRot                (var      pts                :TPtPosFArr;
                                 constref pts_cnt            :TColor;
                                 constref angle              :double;
                                 var      c,s,v,w            :double;
                                 constref fst_ind            :TColor=0);               inline; {$ifdef Linux}[local];{$endif}
function  PtsRot                (         rct                :TPtRectF;
                                 constref angle              :double;
                                 var      c,s,v,w            :double;
                                 constref margin             :TColor=1): TPtRectF;     inline; {$ifdef Linux}[local];{$endif}
function  PtsRot                (         rct                :TRect;
                                 constref angle              :double;
                                 var      c,s,v,w            :double;
                                 constref margin             :TColor=1): TRect;        inline; {$ifdef Linux}[local];{$endif}
function  PtsRot                (         rct                :TPtRect;
                                 constref angle              :double;
                                 var      c,s,v,w            :double;
                                 constref margin             :TColor=1): TPtRect;      inline; {$ifdef Linux}[local];{$endif}

(************************** Miscellaneous Primitives **************************)

// Color Info:
procedure SetColorInfo          (constref pix_col_           :TColor;
                                 var      color_info         :TColorInfo;
                                          alpha_max          :byte=255);               inline; {$ifdef Linux}[local];{$endif}
procedure SetColorInfo          (constref pix_col_           :TColor;
                                 var      color_info         :TColorInfo;
                                          b_                 :boolean);                inline; {$ifdef Linux}[local];{$endif}

// Line Segment: Отрезок:
function  LineS                 (constref v0,w0,v1,w1,r0,r1  :double): TLnPosF;        inline; {$ifdef Linux}[local];{$endif}
function  LineS                 (constref v0,w0,v1,w1,r      :double): TPtPosF;        inline; {$ifdef Linux}[local];{$endif}
function  LineS                 (constref v0,w0,v1,w1,r      :double;
                                 constref dir_x,dir_y        :shortint): TPtPosF;      inline; {$ifdef Linux}[local];{$endif}

// Line Direction: Направление линии:
procedure LineD                 (constref v0,w0,v1,w1        :double;
                                 var      dir_x,dir_y        :shortint);               inline; {$ifdef Linux}[local];{$endif}

// Monochrome Line:
procedure Line                  (         x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo);             inline; {$ifdef Linux}[local];{$endif}
procedure Line                  (         x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure Line                  (         x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :byte);                   inline; {$ifdef Linux}[local];{$endif}
// Line Segments Intersection:
function  LineSI                (         x0,y0,x1,y1,
                                          v0,w0,v1,w1        :double ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  LineSI                (         x0,y0,x1,y1,
                                          v0,w0,v1,w1        :integer): boolean;       inline; {$ifdef Linux}[local];{$endif}

// Line Clipping:
function  LineC                 (var      x0,y0,x1,y1        :integer;
                                 constref rct_clp            :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}

// Monochrome Antialiased Line(Width - 1 pixel):
procedure LineA                 (         x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo;
                                          alpha_max          :byte=255);               inline; {$ifdef Linux}[local];{$endif}
procedure LineAC                (var      x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo;
                                 constref rct_clp            :TPtRect);                inline; {$ifdef Linux}[local];{$endif}

// Monochrome Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineABC               (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}

// Gradient(Highlight) Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineABCG              (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 var      color_info         :TColorInfo;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}

// Equidistant Line(Width - 1 pixel):
function  LineE1                (constref v0,w0,v1,w1,rad    :double): TLnPosF;        inline; {$ifdef Linux}[local];{$endif}
function  LineE2                (constref v0,w0,v1,w1,rad    :double): TLnPosF;        inline; {$ifdef Linux}[local];{$endif}

// Equidistant Curve for Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineABCE              (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}

// Equidistant Curve for Not Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineBCE               (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE               (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE               (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :byte;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE               (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}

// Equidistant Curve for Not Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineBCE2              (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE2              (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE2              (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :byte;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE2              (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}

// Equidistant Curve for Not Antialiased Broken Clipped Line(Width - 3 pixel):
procedure LineBCE3              (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE3              (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}

// Resilient Line(Width - 1 pixel):
procedure LineR                 (constref x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo;
                                 constref seg_cnt            :TColor);                 inline; {$ifdef Linux}[local];{$endif}

// Monochrome Horizontal Line(Width - 1 pixel):
function  LineHC                (var      x0,y0,x1           :integer;
                                 constref rct_clp            :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
procedure LineH                 (         x0,y0,x1           :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo);             inline; {$ifdef Linux}[local];{$endif}
procedure LineH                 (         x0,y0,x1           :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure LineH                 (         x0,y0,x1           :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :byte);                   inline; {$ifdef Linux}[local];{$endif}

// Monochrome Vertical Line(Width - 1 pixel):
function  LineVC                (var      x0,y0,y1           :integer;
                                 constref rct_clp            :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
procedure LineV                 (         x0,y0,y1           :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo);             inline; {$ifdef Linux}[local];{$endif}
procedure LineV                 (         x0,y0,y1           :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure LineV                 (         x0,y0,y1           :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :byte);                   inline; {$ifdef Linux}[local];{$endif}

// Point
procedure Point                 (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo);             inline; {$ifdef Linux}[local];{$endif}
procedure Point                 (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo;
                                 constref clip_rect          :TPtRect);                inline; {$ifdef Linux}[local];{$endif}
procedure Point                 (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo;
                                 constref clip_rect          :TPtRect;
                                 constref alpha_fade         :byte);                   inline; {$ifdef Linux}[local];{$endif}

// Point Collisin Drawing on Array
function PointCollDraw          (constref x,y                :integer;
                                 constref arr_src_width      :TColor;
                                 var      arr_src            :T1Byte1Arr;
                                 constref clip_rect          :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
function PointCollDraw          (constref x,y                :integer;
                                 constref arr_src_width      :TColor;
                                 constref arr_src            :T1Byte1Arr;
                                 constref clip_rect          :TPtRect;
                                 constref b                  :byte   ): boolean;       inline; {$ifdef Linux}[local];{$endif}

// Rectangle
procedure SetRctDupId           (var      sln_prop_var       :TCurveProp);             inline; {$ifdef Linux}[local];{$endif}
procedure SetEdsWidth           (var      sln_prop_var       :TCurveProp);             inline; {$ifdef Linux}[local];{$endif}
procedure SetRctWidth           (var      sln_prop_var       :TCurveProp);             inline; {$ifdef Linux}[local];{$endif}
procedure SetRctHeight          (var      sln_prop_var       :TCurveProp);             inline; {$ifdef Linux}[local];{$endif}
procedure SetRctValues          (var      sln_prop_var       :TCurveProp);             inline; {$ifdef Linux}[local];{$endif}
procedure Rectangle             (constref x,y                :integer;
                                 constref arr_dst_ptr        :PInteger;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref sln_prop_var       :TCurveProp);             inline; {$ifdef Linux}[local];{$endif}
procedure Rectangle             (constref x,y                :integer;
                                 constref arr_dst_ptr        :PInteger;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref sln_prop_var       :TCurveProp;
                                 constref PPFloodFillProc    :TProc4);                 inline; {$ifdef Linux}[local];{$endif}
procedure Rectangle             (constref x,y                :integer;
                                 constref arr_dst_ptr        :PByte;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref sln_prop_var       :TCurveProp;
                                 constref PPFloodFillProc    :TProc4_1);               inline; {$ifdef Linux}[local];{$endif}

// Rhombus:
procedure Rombus                (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo);             inline; {$ifdef Linux}[local];{$endif}

// Circle Drawing(Midpoint Algorithm):
procedure Circle                (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo);             inline; {$ifdef Linux}[local];{$endif}
procedure Circle                (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure Circle                (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure Circle                (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :byte);                   inline; {$ifdef Linux}[local];{$endif}
procedure Circle                (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure CircleC               (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref rct_clp            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo);             inline; {$ifdef Linux}[local];{$endif}
procedure CircleC               (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref rct_clp            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure CircleC               (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref rct_clp            :TPtRect;
                                 constref bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure CircleC               (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref rct_clp            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :byte);                   inline; {$ifdef Linux}[local];{$endif}
procedure CircleC               (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref rct_clp            :TPtRect;
                                 constref bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}

// Wave Search:
function CircleW                (constref x0,y0,rad          :integer;
                                 constref arr_dst            :TPtPos2Arr;
                                 constref arr_dst_width      :TColor;
                                 var      pt                 :TPtPosF): boolean;       inline; {$ifdef Linux}[local];{$endif}
function CircleWC               (constref x0,y0,rad          :integer;
                                 constref arr_dst            :TPtPos2Arr;
                                 constref rct_clp            :TPtRect;
                                 constref arr_dst_width      :TColor;
                                 var      pt                 :TPtPosF): boolean;       inline; {$ifdef Linux}[local];{$endif}

// Circle FloodFill:
procedure CircleFloodFill       (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref outer_rect         :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo;
                                 constref diam               :TColor;
                                 constref pow                :byte);                   inline; {$ifdef Linux}[local];{$endif}

// SpotLight
procedure CircleHighlight       (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref outer_rect         :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo;
                                 constref diam               :TColor;
                                 constref pow                :byte;
                                          alpha_max          :byte=255);               inline; {$ifdef Linux}[local];{$endif}

// Text
procedure SetTextInfo           (constref dst_canvas         :TCanvas;
                                 constref height_            :integer      =27;
                                 constref font_color         :TColor       =$006C754A;
                                 constref font_name          :string       ='AR CENA';
                                 constref font_charset       :TFontCharSet =ANSI_CHARSET;
                                 constref font_quality       :TFontQuality =fqAntialiased;
                                 constref pen_mode           :TFPPenMode   =pmXor;
                                 constref brush_style        :TFPBrushStyle=bsClear);  inline; {$ifdef Linux}[local];{$endif}
procedure Text                  (constref x,y                :integer;
                                 constref dst_canvas         :TCanvas;
                                 constref text_              :string);                 inline; {$ifdef Linux}[local];{$endif}

(***************************** Some Basic Routines ****************************)

// (Set Point) Установить точку:
function PtPos                  (constref pt                 :TPtPosF): TPtPos;        inline; {$ifdef Linux}[local];{$endif}
function PtPos                  (constref pos_x,pos_y        :integer): TPtPos;        inline; {$ifdef Linux}[local];{$endif}
function PtPos                  (constref pos_x,pos_y        :double ): TPtPos;        inline; {$ifdef Linux}[local];{$endif}
function PtPosF                 (constref pt                 :TPtPos ): TPtPosF;       inline; {$ifdef Linux}[local];{$endif}
function PtPosF                 (constref pos_x,pos_y        :double ): TPtPosF;       inline; {$ifdef Linux}[local];{$endif}
function PtPosF                 (constref pos_x,pos_y        :integer): TPtPosF;       inline; {$ifdef Linux}[local];{$endif}

// (Set Line) Установить линию:
function LnPos                  (constref vec                :TLnPosF): TLnPos;        inline; {$ifdef Linux}[local];{$endif}
function LnPos                  (constref x0,y0,x1,y1        :integer): TLnPos;        inline; {$ifdef Linux}[local];{$endif}
function LnPosF                 (constref vec                :TLnPos ): TLnPosF;       inline; {$ifdef Linux}[local];{$endif}
function LnPosF                 (constref x0,y0,x1,y1        :double ): TLnPosF;       inline; {$ifdef Linux}[local];{$endif}
function LnPosF                 (constref x0,y0,x1,y1        :integer): TLnPosF;       inline; {$ifdef Linux}[local];{$endif}

// (Bounding Rectangle of Points Set) Ограничиваюший прямоугольник множества точек:
function PtsRngRctCalc          (constref pts                :TPtPosFArr;
                                 var      rct_bnd_ind_arr    :TEnum2Arr;
                                 constref start_pts_ind      :TColor=0;
                                 constref end_pts_ind        :TColor=0): TRect;                {$ifdef Linux}[local];{$endif}
function PtsRngIndsRctCalc      (constref pts                :TPtPosFArr;
                                 constref sel_pts_inds       :TColorArr;
                                 constref pts_cnt            :TColor  ): TRect;                {$ifdef Linux}[local];{$endif}

// (Set Rectangle) Установить прямоугольник:
procedure PtRct                 (constref pts                :TPtPosFArr;
                                 constref rct_bnd_ind_arr    :TEnum2Arr;
                                 var      rct                :TRect);                  inline; {$ifdef Linux}[local];{$endif}
function PtRctB                 (constref rct_left,
                                          rct_top,
                                          rct_right,
                                          rct_bottom         :integer   ): TPtRectB;   inline; {$ifdef Linux}[local];{$endif}
function PtRct                  (constref rct_left,
                                          rct_top,
                                          rct_right,
                                          rct_bottom         :integer   ): TPtRect;    inline; {$ifdef Linux}[local];{$endif}
function PtRct                  (constref rct                :TRect     ): TPtRect;    inline; {$ifdef Linux}[local];{$endif}
function PtRct                  (constref rct                :TPtRectF  ): TPtRect;    inline; {$ifdef Linux}[local];{$endif}
function PtRct                  (constref rct                :TPtPosFArr): TPtRect;    inline; {$ifdef Linux}[local];{$endif}
function PtBounds               (constref rct_left,
                                          rct_top,
                                          rct_width,
                                          rct_height         :integer   ): TPtRect;    inline; {$ifdef Linux}[local];{$endif}
function PtBounds               (constref rct                :TRect     ): TPtRect;    inline; {$ifdef Linux}[local];{$endif}
function PtBoundsF              (constref rct_left,
                                          rct_top,
                                          rct_width,
                                          rct_height         :integer   ): TPtRectF;   inline; {$ifdef Linux}[local];{$endif}

// (Inner Clipped Rectangle) Внутренний обрезанный прямоугольник:
function ClippedRctB            (constref out_rct,
                                          inn_rct            :TPtRect;
                                 var      b                  :byte)    : TPtRect;      inline; {$ifdef Linux}[local];{$endif}
function ClippedRctB            (constref out_rct,
                                          inn_rct            :TPtRect;
                                 var      nt_pix_clp_type,
                                          pt_pix_clp_type    :byte)    : TPtRectB;     inline; {$ifdef Linux}[local];{$endif}
function ClippedRctB            (constref out_rct,
                                          inn_rct            :TPtRect) : TPtRectB;     inline; {$ifdef Linux}[local];{$endif}
function ClippedRct             (constref out_rct,
                                          inn_rct            :TPtRect) : TPtRect;      inline; {$ifdef Linux}[local];{$endif}
function ClippedRct             (constref out_rct            :TPtRect;
                                 constref inn_rct            :TPtRectF): TPtRect;      inline; {$ifdef Linux}[local];{$endif}
function ClippedRct             (constref out_rct,
                                          inn_rct            :TRect)   : TPtRect;      inline; {$ifdef Linux}[local];{$endif}
function ClippedRct             (constref out_rct            :TPtRect;
                                 constref inn_rct            :TRect)   : TPtRect;      inline; {$ifdef Linux}[local];{$endif}
function ClippedRct             (constref out_rct            :TPtRect;
                                 constref inn_rct            :TRect;
                                          b                  :boolean) : TRect;        inline; {$ifdef Linux}[local];{$endif}
function ClippedRct             (constref out_rct,
                                          inn_rct            :TRect;
                                          b                  :boolean) : TRect;        inline; {$ifdef Linux}[local];{$endif}
function ClippedArr             (constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRectB;
                                 constref arr_src_width      :longword): integer;      inline; {$ifdef Linux}[local];{$endif}

// (Find Rectangle Which Has Not Coprime Width and Height(GCD(src_rect.Width,src_rect.Height)<>1) for source rectangle src_rect) Находит прямоугольник с не взаимно простыми сторонами(GCD(src_rect.Width,src_rect.Height)<>1) для исходного прямоугольника src_rect:
function NCSRectCalc            (constref rct_src            :TRect;
                                 constref bucket_width,
                                          bucket_heigth      :integer): TRect;         inline; {$ifdef Linux}[local];{$endif}
function NCSRectCalc            (constref rct_src            :TPtRectF;
                                 constref bucket_width,
                                          bucket_heigth      :integer): TPtRectF;      inline; {$ifdef Linux}[local];{$endif}

// (Two Rectangles Bounding Rectangle 1) Ограничивающий прямоугольник для двух заданных прямоугольников:
function TwoRctsBoundingRct     (constref rct1,
                                          rct2               :TRect)  : TRect;         inline; {$ifdef Linux}[local];{$endif}
function TwoRctsBoundingRct     (constref rct1,
                                          rct2               :TPtRect): TPtRect;       inline; {$ifdef Linux}[local];{$endif}

// (Rectangle in Rectangle) Прямоугольник в прямоугольнике:
function IsRct1InRct2           (constref rct1,
                                          rct2               :TRect)  : boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsRct1InRct2           (constref rct1,
                                          rct2               :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsRct1InRct2           (constref rct1               :TRect;
                                 constref rct2               :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}

// (Rectangle out of Rectangle) Прямоугольник вне прямоугольника:
function IsRct1OutOfRct2        (constref rct1,
                                          rct2               :TRect)  : boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsRct1OutOfRct2        (constref rct1,
                                          rct2               :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsRct1OutOfRct2        (constref rct1               :TRect;
                                 constref rct2               :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsRct1OutOfRct2        (constref rct1               :TPtRectF;
                                 constref rct2               :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}

// (Point in Rectangle) Точка в прямоугольнике:
function IsPtInRct              (constref x,y,
                                          rct_dst_left,
                                          rct_dst_top,
                                          rct_dst_right,
                                          rct_dst_bottom     :integer): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInRct              (constref x,y                :integer;
                                 constref rct_dst            :TRect)  : boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInRct              (constref x,y                :integer;
                                 constref rct_dst            :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInRct              (constref pt                 :TPtPos;
                                 constref rct_dst            :TRect)  : boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInRct              (constref pt                 :TPtPos;
                                 constref rct_dst            :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInRct              (constref pt                 :TPtPosF;
                                 constref rct_dst            :TRect)  : boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInRct              (constref pt                 :TPtPosF;
                                 constref rct_dst            :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInRct              (constref pt                 :TPtPosF;
                                 constref rct_dst            :TPtRect;
                                 constref rad                :integer): boolean;       inline; {$ifdef Linux}[local];{$endif}

// (Point in Circle) Точка в окружности:
function IsPtInCrc              (constref x,y                :integer;
                                 constref crc_dst            :TCrPos;
                                 constref prec               :integer): boolean;        inline; {$ifdef Linux}[local];{$endif}
function IsPtInCrc              (constref x,y                :integer;
                                 constref crc_dst            :TCrPosF;
                                 constref prec               :integer): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInCrc              (constref x,y                :double;
                                 constref crc_dst            :TCrPosF;
                                 constref prec               :integer): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInCrc              (constref x,y                :double;
                                 constref crc_x,
                                          crc_y,
                                          crc_r              :integer;
                                 constref prec               :integer): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInCrc              (constref x,y                :integer;
                                 constref crc_x,
                                          crc_y,
                                          crc_r              :integer;
                                 constref prec               :integer): boolean;       inline; {$ifdef Linux}[local];{$endif}

// (Distance Between Two Points) Расстояние между двумя точками:
function PtDist                 (constref x0,y0,x1,y1        :integer): double ;       inline; {$ifdef Linux}[local];{$endif}
function PtDist                 (constref x0,y0,x1,y1        :double ): double ;       inline; {$ifdef Linux}[local];{$endif}
function PtDistSqr              (constref x0,y0,x1,y1        :integer): integer;       inline; {$ifdef Linux}[local];{$endif}
function PtDistSqr              (constref x0,y0,x1,y1        :integer): double ;       inline; {$ifdef Linux}[local];{$endif}
function PtDistSqr              (constref x0,y0,x1,y1        :double ): double ;       inline; {$ifdef Linux}[local];{$endif}

// (Line-Line Intersection Point) Точка пересечение двух линий:
function LineLineIntPt          (constref x0,y0,x1,y1,
                                          v0,w0,v1,w1        :double):TPtPosF;         inline; {$ifdef Linux}[local];{$endif}

// (Line-Circle Intersection Point) Точка пересечение линии и окружности:
function LineCrcIntPt           (constref x0,y0,x1,y1        :double;
                                 constref crc_dst            :TCrPosF): TLnPosF;       inline; {$ifdef Linux}[local];{$endif}
function LineCrcIntPt           (constref x0,y0,x1,y1        :double;
                                 constref x,y,r              :double ): TLnPosF;       inline; {$ifdef Linux}[local];{$endif}
function CrcPosF                (constref x,y,r              :double ): TCrPosF;       inline; {$ifdef Linux}[local];{$endif}

// (Rectangle-Circle Intersection) Пересечение прямоугольника и окружности:
function RctCrcInt              (constref rct                :TRect;
                                 constref x,y,r              :integer): boolean;       inline; {$ifdef Linux}[local];{$endif}
function RctCrcInt              (constref rct                :TPtRect;
                                 constref x,y,r              :integer): boolean;       inline; {$ifdef Linux}[local];{$endif}

// (Angle Between Two Connected Segments,(x1,y1) - Connection Point) Угол между двумя соединенными сегментами,(x1,y1) - точка соединения:
function Angle1                 (constref x0,y0,x1,y1,x2,y2  :double): double;         inline; {$ifdef Linux}[local];{$endif}
function Angle2                 (constref x0,y0,x1,y1,x2,y2  :double): double;         inline; {$ifdef Linux}[local];{$endif}

(********************************** Blitters **********************************)

function  GetBmpHandle          (         bmp                :TBitmap): PInteger{pointer}; inline;
procedure GLBitmapInit          (         tex_id             :TColor;
                                          bmp                :Graphics.TBitmap;
                                          b                  :boolean);                inline;
procedure CnvToCnv              (         rct_dst            :TPtRect;
                                          cnv_dst,
                                          cnv_src            :TCanvas;
                                          copy_mode          :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure BitBlt1               (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst_left,
                                          rct_dst_top,
                                          bmp_src_width,
                                          bmp_dst_width      :integer);                inline;
procedure BitBlt1               (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src_left,
                                          rct_src_top,
                                          rct_src_width,
                                          rct_src_height,
                                          rct_dst_left,
                                          rct_dst_top,
                                          bmp_src_width,
                                          bmp_dst_width      :integer);                inline;
procedure BitBlt1               (var      arr_src            :TColorArr;
                                 constref rct_src_width,
                                          rct_src_height,
                                          rct_dst_left,
                                          rct_dst_top        :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure BitBlt2               (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst_left,
                                          rct_dst_top,
                                          bmp_src_width,
                                          bmp_dst_width      :integer);                inline;
procedure BitBlt2               (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src_left,
                                          rct_src_top,
                                          rct_src_width,
                                          rct_src_height,
                                          rct_dst_left,
                                          rct_dst_top,
                                          bmp_src_width,
                                          bmp_dst_width      :integer);                inline;
procedure BmpToBmp2             (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref bmp_src_width,
                                          bmp_dst_width      :integer;
                                 constref clp_rct            :TPtRect;
                                 constref inn_wnd_mrg_       :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure BitBlt3               (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst_left,
                                          rct_dst_top,
                                          bmp_src_width,
                                          bmp_dst_width      :integer;
                                          transparent_color  :TColor);                 inline;
procedure BitBlt3               (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src_left,
                                          rct_src_top,
                                          rct_src_width,
                                          rct_src_height,
                                          rct_dst_left,
                                          rct_dst_top,
                                          bmp_src_width,
                                          bmp_dst_width      :integer;
                                          transparent_color  :TColor);                 inline; {$ifdef Linux}[local];{$endif}

(******************************* Image Transform ******************************)

// Scale:
procedure ImgScl                (constref bmp_src_ptr        :PInteger;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width,
                                          bmp_dst_height     :TColor;
                                 constref ker_w,
                                          ker_h              :integer);                inline; {$ifdef Linux}[local];{$endif}

// Rotate:
procedure ImgRotLoop0           (constref rct_src            :TPtRect;
                                          bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width,
                                          d_width,
                                          c,s,v,w,
                                          lt,tp,rt,bt        :integer;
                                 constref mask_alpha         :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure ImgRotLoop1           (constref rct_src            :TPtRect;
                                          bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width,
                                          d_width,
                                          c,s,v,w,
                                          lt,tp,rt,bt        :integer;
                                 constref mask_alpha         :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure ImgRotLoop2           (constref rct_src            :TPtRect;
                                          bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width,
                                          d_width,
                                          c,s,v,w,
                                          lt,tp,rt,bt        :integer;
                                 constref mask_alpha         :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure ImgRotLoop3           (constref rct_src            :TPtRect;
                                          bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width,
                                          d_width,
                                          c,s,v,w,
                                          lt,tp,rt,bt        :integer;
                                 constref mask_alpha         :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure ImgRotLoop4           (constref rct_src            :TPtRect;
                                          bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width,
                                          d_width,
                                          c,s,v,w,
                                          lt,tp,rt,bt        :integer;
                                 constref mask_alpha         :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure ImgRotLoop5           (constref rct_src            :TPtRect;
                                          bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width,
                                          d_width,
                                          c,s,v,w,
                                          lt,tp,rt,bt        :integer;
                                 constref mask_alpha         :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure ImgRot1               (constref pvt                :TPtPos;
                                 constref rct_src,
                                          rct_clp            :TPtRect;
                                 constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 constref angle              :double;
                                 constref x,
                                          y                  :integer;
                                 constref add_alpha_mask     :byte;
                                 var      bounding_rct       :TPtRect;
                                 constref mask_alpha         :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure ImgRot2               (constref pvt                :TPtPos;
                                 constref rct_src,
                                          rct_clp            :TPtRect;
                                 constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 constref angle              :double;
                                 constref x,
                                          y,
                                          inn_wnd_mrg,
                                          bmp_src_height     :integer);                inline; {$ifdef Linux}[local];{$endif}

(******************************* Post-Processing ******************************)

procedure PPDec2ProcInit;                                                                      {$ifdef Linux}[local];{$endif}
procedure ArrFillProcInit;                                                                     {$ifdef Linux}[local];{$endif}
procedure PPBlurProcInit;                                                                      {$ifdef Linux}[local];{$endif}

// (Flood Fill) Заливка:
procedure PPFloodFillAdd        (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPFloodFillSub        (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPFloodFill           (constref bmp_dst_ptr        :PByte;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPFloodFill           (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref col                :TColor);
procedure PPFloodFill           (constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_dst_width,
                                          rct_dst_height,
                                          first_pix_pos      :integer;
                                 constref col                :TColor);
procedure PPFloodFill           (constref bmp_dst            :Graphics.TBitmap;
                                 constref col                :TColor);                         {$ifdef Linux}[local];{$endif}
procedure PPFloodFill           (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref col                :TColor;
                                          flood_fill_inc     :boolean);

// (Additive) Аддитивное смешивание:
procedure PPAdditive            (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref col                :TColor);
procedure PPAdditive            (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRectB;
                                 constref bmp_src_width,
                                          bmp_dst_width      :TColor);
procedure PPAdditiveDec         (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref col                :TColor;
                                 constref pow                :byte=64);
procedure PPAdditiveDec         (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRectB;
                                 constref bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 constref pow                :byte=64);

// (AlphaBlend) Полупрозрачность:
procedure PPAlphaBlend          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref col                :TColor;
                                 constref pow                :byte=64;
                                          alpha_max          :byte=255);
procedure PPAlphaBlend          (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRectB;
                                 constref bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 constref pow                :byte=64;
                                          alpha_max          :byte=255);

// (Inverse) Инверсия:
procedure PPInverse             (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPInverseDec          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref pow                :byte=64);

// (HighLight) Подсветка:
procedure PPHighlight           (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref pow                :byte=64);

// (Darken) Затемнение:
procedure PPDarken              (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref pow                :byte=64);

// (GrayscaleR) Оттенок серого: красный канал:
procedure PPGrayscaleR          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPGrayscaleRDec       (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref pow                :byte=64);

// (GrayscaleG) Оттенок серого: красный канал:
procedure PPGrayscaleG          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPGrayscaleGDec       (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref pow                :byte=64);

// (GrayscaleB) Оттенок серого: красный канал:
procedure PPGrayscaleB          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPGrayscaleBDec       (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref pow                :byte=64);

// (Monochrome Noise) Монохромный шум:
procedure PPMonoNoise           (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref col                :TColor);
procedure PPMonoNoiseDec        (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref col                :TColor;
                                 constref pow                :byte=64;
                                          alpha_max          :byte=255);

// (Colorize) Окраска:
procedure PPColorCorrectionM0   (         ColorizeM          :TFunc0;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref pow                :byte=32;
                                          alpha_max          :byte=255);
procedure PPColorCorrectionP0   (         ColorizeP          :TFunc0;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref pow                :byte=32;
                                          alpha_max          :byte=255);
procedure PPColorCorrectionM0   (         ColorizeM          :TFunc0;
                                 constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRectB;
                                 constref bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 constref pow                :byte=32;
                                          alpha_max          :byte=255);
procedure PPColorCorrectionP0   (         ColorizeP          :TFunc0;
                                 constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRectB;
                                 constref bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 constref pow                :byte=32;
                                          alpha_max          :byte=255);
procedure PPColorCorrectionM1   (         ColorizeM          :TFunc1;
                                 constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRectB;
                                 constref bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 constref pow                :byte=32;
                                          alpha_max          :byte=255);
procedure PPColorCorrectionP1   (         ColorizeP          :TFunc1;
                                 constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRectB;
                                 constref bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 constref pow                :byte=32;
                                          alpha_max          :byte=255);

// (Contrast) Контрастность:
procedure PPContrast1           (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref pow                :byte=64);
procedure PPContrast2           (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref pow                :byte=64);

// (Blur) Размытие:
procedure PPBlurProc00          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPBlurProc01          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPBlurProc02          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPBlurProc03          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPBlurProc04          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPBlurProc05          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPBlurProc06          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPBlurProc07          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPBlurProc08          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPBlurProc09          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPBlurProc10          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPBlurProc11          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPBlur                (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref blur_type          :byte=0;
                                 constref border_filter      :TBorderFilter=efNotTiled);
procedure PPBlur                (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRectB;
                                 constref bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 constref blur_type          :byte=0);

var

  {Precalculated Table of Greatest Common Divisors}
  {array of greatest common divisors}
  gcd_arr             : TGCDArr;
  {precision of calculation}
  grid_pt_rad         : TColor;

  DefaultParallaxShift: TPtPos=(x:16; y:16);
  PPDec2Proc          : array[0..29] of TFunc2;
  ArrFillProc         : array[0..29] of TProc5;
  PPBlurProc          : array[0..11] of TProc6;
  curve_default_prop  : TCurveProp={$region -fold}
  (
    dup_pts_id               : (arr:(0,0,0,0,0,0); obj_ind:-1; pts_ind:-1; dup_pts_cnt:0; weight:0);
    curve_obj_ind            : 0;
    pts_cnt                  : 0;
    pts_cnt_val              : 1;
    eds_smpl_angle           : 2.0;

    eds_col_ptr              : Nil;
    eds_col                  : $00BF923E;
    eds_col_inv              : $00998F77{SetColorInv(eds_col)};
    eds_col_rnd              : False;
    eds_col_fall_off         : False;
    eds_col_fall_off_inc     : 1;
    eds_width                : 1;
    eds_width_half           : 0;
    eds_width_odd            : 0;
    eds_aa                   : True;

    pts_col_ptr              : Nil;
    pts_col                  : $004B3918;
    pts_col_inv              : $00998F77{SetColorInv(pts_col)};
    pts_col_rnd              : False;
    pts_col_fall_off         : False;
    pts_col_fall_off_inc     : 1;

    pts_width                : 5;
    pts_width__half          : 2;
    pts_width__odd           : 0;
    pts_height               : 5;
    pts_height_half          : 2;
    pts_height_odd           : 0;

    {rectangle}
    rct_val_arr              : (-2,-2,2,-1,2);
    pts_rct_width            : 5;
    pts_rct_width__half      : 2;
    pts_rct_width__odd       : 0;
    pts_rct_height           : 5;
    pts_rct_height_half      : 2;
    pts_rct_height_odd       : 0;
    pts_rct_tns_left         : 1;
    pts_rct_tns_top          : 1;
    pts_rct_tns_right        : 1;
    pts_rct_tns_bottom       : 1;
    pts_rct_inn_width        : 3;
    pts_rct_inn_width__odd   : 1;
    pts_rct_inn_height       : 3;
    pts_rct_inn_height_odd   : 1;

    {circle}
    pts_crc_diam_inn         : 5;
    pts_crc_diam_inn_half    : 2;
    pts_crc_diam_out         : 5;
    pts_crc_diam_out_half    : 2;

    {polygon}
    pts_plg_diam             : 5;
    pts_plg_diam_half        : 2;
    pts_plg_ang_cnt          : 3;

    {sprite}
    pts_srt_width            : 5;
    pts_srt_height           : 5;

    sln_pts_frq              : 16;
    sln_type                 : stFreeHand;
    sln_mode                 : smContinuous;
    spray_rad                : 32;
    eds_bld_stl              : dsMonochrome;
    pts_bld_stl              : dsAlphaBlend;
    clp_stl                  : csClippedEdges1;
    eds_lod                  : False;
    eds_simpl_angle          : 20.0;
    hid_ln_elim              : True;
    best_precision           : False;
    lazy_repaint             : True;
    lazy_repaint_prev        : False;
    byte_mode                : True;
    byte_mode_prev           : True;
    free_mem_on_out_of_wnd   : True;
    free_mem_on_scale_down   : False;
    remove_brunching_adaptive: False;
    remove_brunching_constant: False;
    remove_brunching_none    : True;
    rct_eds_show             : False;
    rct_pts_show             : False;
    eds_show                 : False;
    pts_show                 : False;
    cnc_ends                 : False;
    pts_ord_inv              : False;
    is_out_of_wnd            : False;
    dyn_stl                  : dsNone;

    fml_type                 : sfCycloid;

    {Cycloid}
    cycloid_pts_cnt          : 256;
    cycloid_loop_cnt         : 003;
    cycloid_loop_rad         : 064.0;
    cycloid_curvature        : 001.0;
    cycloid_dir_x            : mdRight;
    cycloid_dir_y            : mdUp;

    {Epicycloid}
    epicycloid_pts_cnt       : 256;
    epicycloid_petals_cnt    : 008.0;
    epicycloid_rad           : 256.0;
    epicycloid_rot           : 000.0;
    epicycloid_angle         : 360.0;

    {Rose}
    rose_pts_cnt             : 256;
    rose_petals_cnt          : 007.0;
    rose_rad                 : 256.0;
    rose_rot                 : 000.0;
    rose_angle               : 180.0;

    {Spiral}
    spiral_pts_cnt           : 256;
    spiral_coil_step         : 001.0;
    spiral_rad               : 256.0;
    spiral_rot               : 000.0;
    spiral_angle             : 720.0;

    {Superellipse}

  ); {$endregion}
  ftext_default_prop  : TFTextProp={$region -fold}
  (
    bkgnd_col    : clWhite;
    bkgnd_draw   : False;
    bkgnd_rnd_col: false;
  ); {$endregion}
  selit_default_prop  : TSelItProp={$region -fold}
  (
    bkgnd_style   : bsBoth;
    selection_mode: smCircle;
  ); {$endregion}

implementation

(******************************** Misc. Routines ******************************) {$region -fold}

//
class operator TPtPos. =(r1,r2:TPtPos ): boolean;                                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(r1.x=r2.x) and (r1.y=r2.y);
end;  {$endregion}
//
class operator TPtPosF.=(r1,r2:TPtPosF): boolean;                                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(r1.x=r2.x) and (r1.y=r2.y);
end;  {$endregion}
class operator TPtPos2.=(r1,r2:TPtPos2): boolean;                                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(r1*r2) and (r1.obj_ind=r2.obj_ind) and (r1.dup_pts_cnt=r2.dup_pts_cnt);
end;  {$endregion}
class operator TPtPos2.*(r1,r2:TPtPos2): boolean;                                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(r1.arr[0]=r2.arr[0]) and
          (r1.arr[1]=r2.arr[1]) and
          (r1.arr[2]=r2.arr[2]) and
          (r1.arr[3]=r2.arr[3]) and
          (r1.arr[4]=r2.arr[4]) and
          (r1.arr[5]=r2.arr[5]);
end;  {$endregion}
//
procedure      TPtPos2.SetEqual0(var r1:TPtPos2; constref r2:TPtPos2);                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  r1.dup_pts_cnt:=r2.dup_pts_cnt;
  r1.arr[0]     :=r2.arr[0];
  r1.arr[1]     :=r2.arr[1];
  r1.arr[2]     :=r2.arr[2];
  r1.arr[3]     :=r2.arr[3];
  r1.arr[4]     :=r2.arr[4];
  r1.arr[5]     :=r2.arr[5];
  //SetEqual2(r1,r2);
end; {$endregion}
procedure      TPtPos2.SetEqual1(var r1:TPtPos2; constref r2:TPtPos2);                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  r1.obj_ind    :=-1{r2.obj_ind};
  r1.pts_ind    :=-1{r2.pts_ind};
  r1.dup_pts_cnt:=r2.dup_pts_cnt;
  r1.arr[0]     :=r2.arr[0];
  r1.arr[1]     :=r2.arr[1];
  r1.arr[2]     :=r2.arr[2];
  r1.arr[3]     :=r2.arr[3];
  r1.arr[4]     :=r2.arr[4];
  r1.arr[5]     :=r2.arr[5];
  //SetEqual2(r1,r2);
end; {$endregion}
procedure      TPtPos2.SetEqual2(var r1:TPtPos2; constref r2:TPtPos2);                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  r1.arr[0]:=r2.arr[0];
  r1.arr[1]:=r2.arr[1];
  r1.arr[2]:=r2.arr[2];
  r1.arr[3]:=r2.arr[3];
  r1.arr[4]:=r2.arr[4];
  r1.arr[5]:=r2.arr[5];
end; {$endregion}
//
function       TPtPos2.IsEqual  (r1,r2 :TPtPos2): boolean;                                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=
  (r1.arr[0]=r2.arr[0]) and
  (r1.arr[1]=r2.arr[1]) and
  (r1.arr[2]=r2.arr[2]) and
  (r1.arr[3]=r2.arr[3]) and
  (r1.arr[4]=r2.arr[4]) and
  (r1.arr[5]=r2.arr[5]);
end; {$endregion}
//
function GetEnumVal(enum:TDrawingStyle): integer;                                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=GetEnumValue(TypeInfo(enum),GetEnumName(TypeInfo(enum),Ord(enum)));
end; {$endregion}
function GetEnumVal(enum:TDrawingStyle): TColor;                                                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=GetEnumValue(TypeInfo(enum),GetEnumName(TypeInfo(enum),Ord(enum)));
end; {$endregion}
//
function Min1(constref a1,a2:double                                                                               ): double;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (a1<a2) then
    Result:=a1
  else
    Result:=a2;
end; {$endregion}
function Min2(constref a1,a2:integer                                                                              ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (a1<a2) then
    Result:=a1
  else
    Result:=a2;
end; {$endregion}
function Min3(constref a1,a2:TColor                                                                               ): TColor;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (a1<a2) then
    Result:=a1
  else
    Result:=a2;
end; {$endregion}
//
function Min4(constref arr:TIntrArr;  constref max_item_val:integer; constref item_cnt:integer                    ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=max_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]<=Result) then
      Result:=arr[i];
end; {$endregion}
function Min5(constref arr:TColorArr; constref max_item_val:TColor;  constref item_cnt:TColor                     ): TColor;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=max_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]<=Result) then
      Result:=arr[i];
end; {$endregion}
//
function Min6(constref arr:TIntrArr;  constref max_item_val:integer; constref item_cnt:integer; constref b:boolean): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,a: integer;
begin
  Result:=0;
  a  :=max_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]<=a) then
      begin
        a  :=arr[i];
        Result:=i;
      end;
end; {$endregion}
function Min7(constref arr:TColorArr; constref max_item_val:TColor;  constref item_cnt:TColor;  constref b:boolean): TColor;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
  a: TColor;
begin
  Result:=0;
  a     :=max_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]<=a) then
      begin
        a     :=arr[i];
        Result:=i;
      end;
end; {$endregion}
//
function Min8(constref arr:TEdgeArr;  constref max_item_val:integer; constref item_cnt:integer                    ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=max_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i].obj_ind<=Result) then
      Result:=arr[i].obj_ind;
end; {$endregion}
function Min9(constref arr:TEdgeArr;  constref max_item_val:TColor;  constref item_cnt:TColor                     ): TColor;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=max_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i].obj_ind<=Result) then
      Result:=arr[i].obj_ind;
end; {$endregion}
//
function Max1(constref a1,a2:double                                                                               ): double;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (a1>a2) then
    Result:=a1
  else
    Result:=a2;
end; {$endregion}
function Max2(constref a1,a2:integer                                                                              ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (a1>a2) then
    Result:=a1
  else
    Result:=a2;
end; {$endregion}
function Max3(constref a1,a2:TColor                                                                               ): TColor;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (a1>a2) then
    Result:=a1
  else
    Result:=a2;
end; {$endregion}
//
function Max4(constref arr:TIntrArr;  constref min_item_val:integer; constref item_cnt:integer                    ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=min_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]>=Result) then
      Result:=arr[i];
end; {$endregion}
function Max5(constref arr:TColorArr; constref min_item_val:TColor;  constref item_cnt:TColor                     ): TColor;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=min_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]>=Result) then
      Result:=arr[i];
end; {$endregion}
//
function Max6(constref arr:TIntrArr;  constref min_item_val:integer; constref item_cnt:integer; constref b:boolean): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,a: integer;
begin
  Result:=0;
  a     :=min_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]>=a) then
      begin
        a     :=arr[i];
        Result:=i;
      end;
end; {$endregion}
function Max7(constref arr:TColorArr; constref min_item_val:TColor;  constref item_cnt:TColor;  constref b:boolean): TColor;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
  a: TColor;
begin
  Result:=0;
  a     :=min_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]>=a) then
      begin
        a     :=arr[i];
        Result:=i;
      end;
end; {$endregion}
//
function Max8(constref arr:TEdgeArr;  constref min_item_val:integer; constref item_cnt:integer                    ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=min_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i].obj_ind>=Result) then
      Result:=arr[i].obj_ind;
end; {$endregion}
function Max9(constref arr:TEdgeArr;  constref min_item_val:TColor;  constref item_cnt:TColor                     ): TColor;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=min_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i].obj_ind>=Result) then
      Result:=arr[i].obj_ind;
end; {$endregion}
//
function InvSqrt(constref x:single): single;                                                                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  result_as_int: UInt32 absolute Result;
begin
  Result       :=x;
  result_as_int:=$5F3759DF-(result_as_int>>1);
  Result       *=(1.5-(x*0.5*Result*Result));
end; {$endregion}
//
function Limit(x:integer): byte;                                                                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (x<0) then
    Result:=0
  else
  if (x>255) then
    Result:=255
  else
    Result:=x;
end; {$endregion}
//
procedure PtrInit(var ptr:PInteger; constref arr:TIntrArr );                                                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (Length(arr)<>0) then
    ptr:=@arr[0];
end; {$endregion}
procedure PtrInit(var ptr:PInteger; constref arr:TColorArr);                                                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (Length(arr)<>0) then
    ptr:=@arr[0];
end; {$endregion}
//
procedure MaxSpriteWHRctInit(var rct:TPtRect);                                                                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  rct:=PtBounds
  (
    0,
    0,
    MAX_SPRITE_WIDTH,
    MAX_SPRITE_HEIGHT
  )
end; {$endregion}
function ArcTan4(constref x0,y0,x1,y1:double): double;                                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v1,w1,k,b,dx: double;
  angle       : double;
begin
  if (x1=x0) then
    begin
      Result:=pi/2;
      Exit;
    end;
  if (y1=y0) then
    begin
      Result:=0;
      Exit;
    end;
  angle:=Abs(ArcTan((y1-y0)/(x1-x0)));
  if ((y1>y0) and (x1>x0)) or
     ((y1<y0) and (x1<x0)) then
    Result:=angle
  else
  if ((y1>y0) and (x1<x0)) or
     ((y1<y0) and (x1>x0)) then
    Result:=pi-angle;
end; {$endregion}

// (Finding a Substring in a TStrings) Поиск подстроки в строке:
function IndexOfSubStr(const list:TStrings; var sub_string:string): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  index: integer;
begin
  Result:=-1;
  if List.Count=0 then
    Exit;
  sub_string:=UpperCase(sub_string);
  for index:=0 to List.Count-1 do
    if (Pos(sub_string,UpperCase(list[index]))>0) then
      begin
        Result:=index;
        Break;
      end;
end; {$endregion}

// (Binary Search) Бинарный поиск:
function BinarySearch(constref n:TColor; constref arr_item_ptr:PInteger; constref right_border:integer): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  a,b: integer;
begin
  a:=0;
  b:=n-1;
  Result:=(a+b)>>1;
  while ((b-a)>1) do
    begin
      if ((arr_item_ptr+Result)^<right_border) then
        a:=Result
      else
        b:=Result;
      Result:=(a+b)>>1;
    end;
end; {$endregion}

// (Interpolation search) Интерполирующий поиск:
{TODO}

// Store Color Channel into Integer Array:
procedure BmpToArr(constref bmp_src_ptr:PInteger; var bmp_dst_ptr:PInteger; var arr_dst:TColorArr; constref bmp_src_rct:TPtRect; constref bmp_src_width,bmp_src_height:TColor; var bmp_dst_width,bmp_dst_height:TColor); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  bmp_src_rct_clp: TPtRect;
begin
  with bmp_src_rct_clp do
    begin
      bmp_src_rct_clp:=ClippedRct(PtBounds(0,0,bmp_src_width,bmp_src_height),bmp_src_rct);
      SetLength(arr_dst,width*height);
      bmp_dst_ptr:=Unaligned(@arr_dst[0]);
      if (width=bmp_src_width) and (height=bmp_src_height) then
        Move(bmp_src_ptr^,(@arr_dst[0])^,(width*height)<<2)
      else
        BitBlt2(bmp_src_ptr,bmp_dst_ptr,bmp_src_rct_clp,0,0,bmp_src_width,width);
      bmp_dst_width :=width;
      bmp_dst_height:=height;
    end;
end; {$endregion}

// Store Alpha Channel into Byte Array:
{TODO}
{$endregion}



(******************************* Color Transform ******************************) {$region -fold}

function Red           (pixel:TColor): byte;   inline; {$ifdef Linux}[local]; {$endif} {$region -fold}
begin
  Result:=(pixel>>00) and $000000ff;
end; {$endregion}
function Green         (pixel:TColor): byte;   inline; {$ifdef Linux}[local]; {$endif} {$region -fold}
begin
  Result:=(pixel>>08) and $000000ff;
end; {$endregion}
function Blue          (pixel:TColor): byte;   inline; {$ifdef Linux}[local]; {$endif} {$region -fold}
begin
  Result:=(pixel>>16) and $000000ff;
end; {$endregion}
function RGB           (r,g,b:byte  ): TColor; inline; {$ifdef Linux}[local]; {$endif} {$region -fold}
begin
  Result:=(b<<16) or (g<<08) or r;
end; {$endregion}

// Regular Effect:
function SetColorInv   (pixel:TColor; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Blue (pixel),
              Green(pixel),
              Red  (pixel));
end; {$endregion}
function Additive      (pixel:TColor; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Min(Red  (pixel)+b,255),
              Min(Green(pixel)+g,255),
              Min(Blue (pixel)+r,255));
end; {$endregion}
procedure AlphaBlend   (pixel_ptr:PInteger; constref r,g,b:byte;                                                      constref d_alpha:byte                                                 );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=(((Blue (pixel_ptr^)-r)*d_alpha)>>8+r)<<16+
              (((Green(pixel_ptr^)-g)*d_alpha)>>8+g)<<08+
              (((Red  (pixel_ptr^)-b)*d_alpha)>>8+b)<<00;
end; {$endregion}
function AlphaBlend    (pixel:TColor; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=   (((Blue (pixel)-r)*d_alpha)>>8+r)<<16+
             (((Green(pixel)-g)*d_alpha)>>8+g)<<08+
             (((Red  (pixel)-b)*d_alpha)>>8+b)<<00;
         {RGB(((Red  (pixel)-b)*d_alpha+b<<8-b)>>8,
              ((Green(pixel)-g)*d_alpha+g<<8-g)>>8,
              ((Blue (pixel)-r)*d_alpha+r<<8-r)>>8);}
         {RGB(((Red  (pixel)-b)*d_alpha)>>8+b,
              ((Green(pixel)-g)*d_alpha)>>8+g,
              ((Blue (pixel)-r)*d_alpha)>>8+r);}
         {RGB((Red  (pixel)*d_alpha+b*alpha)>>8,
              (Green(pixel)*d_alpha+g*alpha)>>8,
              (Blue (pixel)*d_alpha+r*alpha)>>8);}
end; {$endregion}
function Inverse       (pixel:TColor                                                                                                                                                        ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=Integer($ffffffff-pixel);
end; {$endregion}
function Highlight     (pixel:TColor; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Min3(Red  (pixel)+pow,255),
              Min3(Green(pixel)+pow,255),
              Min3(Blue (pixel)+pow,255));
end; {$endregion}
function Darken        (pixel:TColor; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Max2(Red  (pixel)-pow,0),
              Max2(Green(pixel)-pow,0),
              Max2(Blue (pixel)-pow,0));
end; {$endregion}
function GrayscaleR    (pixel:TColor; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Red(pixel),
              Red(pixel),
              Red(pixel));
end; {$endregion}
function GrayscaleG    (pixel:TColor; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Green(pixel),
              Green(pixel),
              Green(pixel));
end; {$endregion}
function GrayscaleB    (pixel:TColor; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Blue(pixel),
              Blue(pixel),
              Blue(pixel));
end; {$endregion}
function ColorizeRM    (pixel:TColor; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: TColor;
begin
  v:=Red(pixel)+d;
  if (v<000) then
    Result:=pixel-Blue(pixel)<<16
  else
    Result:=pixel-Blue(pixel)<<16+Byte(v)<<16;
end; {$endregion}
function ColorizeRP    (pixel:TColor; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: TColor;
begin
  v:=Red(pixel)+d;
  if (v>255) then
    Result:=pixel-Blue(pixel)<<16+255<<16
  else
    Result:=pixel-Blue(pixel)<<16+Byte(v)<<16;
end; {$endregion}
function ColorizeGM    (pixel:TColor; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: TColor;
begin
  v:=Green(pixel)+d;
  if (v<000) then
    Result:=pixel-Green(pixel)<<08
  else
    Result:=pixel-Green(pixel)<<08+Byte(v)<<08;
end; {$endregion}
function ColorizeGP    (pixel:TColor; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: TColor;
begin
  v:=Green(pixel)+d;;
  if (v>255) then
    Result:=pixel-Green(pixel)<<08+255<<08
  else
    Result:=pixel-Green(pixel)<<08+Byte(v)<<08;
end; {$endregion}
function ColorizeBM    (pixel:TColor; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: TColor;
begin
  v:=Blue(pixel)+d;
  if (v<000) then
    Result:=pixel-Red(pixel)<<00
  else
    Result:=pixel-Red(pixel)<<00+Byte(v)<<00;
end; {$endregion}
function ColorizeBP    (pixel:TColor; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=255; constref pow:byte=64; constref d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: TColor;
begin
  v:=Blue(pixel)+d;
  if (v>255) then
    Result:=pixel-Red(pixel)<<00+255<<00
  else
    Result:=pixel-Red(pixel)<<00+Byte(v)<<00;
end; {$endregion}
procedure BlurRGB      (pixel_ptr:PInteger; bmp_dst_width:TColor                                                                                                                            );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v0,v1,v2,v3: TColor;
begin
  v0                          :=(pixel_ptr+0                 )^;
  v1                          :=(pixel_ptr+2                 )^;
  v2                          :=(pixel_ptr+bmp_dst_width<<1  )^;
  v3                          :=(pixel_ptr+bmp_dst_width<<1+2)^;
  (pixel_ptr+bmp_dst_width+1)^:=RGB((Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00)+Byte(    (v3)>>00))>>2,
                                    (Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08))>>2,
                                    (Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16)+Byte(    (v3)>>16))>>2);
end; {$endregion}
procedure BlurRRB      (pixel_ptr:PInteger; bmp_dst_width:TColor                                                                                                                            );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v0,v1,v2,v3: TColor;
  r          : byte;
begin
  v0                          :=(pixel_ptr+0                 )^;
  v1                          :=(pixel_ptr+2                 )^;
  v2                          :=(pixel_ptr+bmp_dst_width<<1  )^;
  v3                          :=(pixel_ptr+bmp_dst_width<<1+2)^;
  r                           :=        (Byte((v0)>>00)+Byte((v1)>>00)+Byte((v2)>>00)+Byte((v3)>>00))>>2;
  (pixel_ptr+bmp_dst_width+1)^:=RGB(r,r,(Byte((v0)>>16)+Byte((v1)>>16)+Byte((v2)>>16)+Byte((v3)>>16))>>2);
end; {$endregion}
procedure BlurRGR      (pixel_ptr:PInteger; bmp_dst_width:TColor                                                                                                                            );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v0,v1,v2,v3: TColor;
  r          : byte;
begin
  v0                          :=(pixel_ptr+0                 )^;
  v1                          :=(pixel_ptr+2                 )^;
  v2                          :=(pixel_ptr+bmp_dst_width<<1  )^;
  v3                          :=(pixel_ptr+bmp_dst_width<<1+2)^;
  r                           :=      (Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00)+Byte(    (v3)>>00))>>2;
  (pixel_ptr+bmp_dst_width+1)^:=RGB(r,(Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08))>>2,r);
end; {$endregion}
procedure BlurGGB      (pixel_ptr:PInteger; bmp_dst_width:TColor                                                                                                                            );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v0,v1,v2,v3: TColor;
  g          : byte;
begin
  v0                          :=(pixel_ptr+0                 )^;
  v1                          :=(pixel_ptr+2                 )^;
  v2                          :=(pixel_ptr+bmp_dst_width<<1  )^;
  v3                          :=(pixel_ptr+bmp_dst_width<<1+2)^;
  g                           :=        (Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08))>>2;
  (pixel_ptr+bmp_dst_width+1)^:=RGB(g,g,(Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16)+Byte(    (v3)>>16))>>2);
end; {$endregion}
procedure BlurRGG      (pixel_ptr:PInteger; bmp_dst_width:TColor                                                                                                                            );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v0,v1,v2,v3: TColor;
  g          : byte;
begin
  v0                          :=(pixel_ptr+0                 )^;
  v1                          :=(pixel_ptr+2                 )^;
  v2                          :=(pixel_ptr+bmp_dst_width<<1  )^;
  v3                          :=(pixel_ptr+bmp_dst_width<<1+2)^;
  g                           :=    (Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08))>>2;
  (pixel_ptr+bmp_dst_width+1)^:=RGB((Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00)+Byte(    (v3)>>00))>>2,g,g);
end; {$endregion}
procedure BlurBGB      (pixel_ptr:PInteger; bmp_dst_width:TColor                                                                                                                            );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v0,v1,v2,v3: TColor;
  b          : byte;
begin
  v0                          :=(pixel_ptr+0                 )^;
  v1                          :=(pixel_ptr+2                 )^;
  v2                          :=(pixel_ptr+bmp_dst_width<<1  )^;
  v3                          :=(pixel_ptr+bmp_dst_width<<1+2)^;
  b                           :=      (Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16)+Byte(    (v3)>>16))>>2;
  (pixel_ptr+bmp_dst_width+1)^:=RGB(b,(Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08))>>2,b);
end; {$endregion}
procedure BlurRBB      (pixel_ptr:PInteger; bmp_dst_width:TColor                                                                                                                            );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v0,v1,v2,v3: TColor;
  b          : byte;
begin
  v0                          :=(pixel_ptr+0                 )^;
  v1                          :=(pixel_ptr+2                 )^;
  v2                          :=(pixel_ptr+bmp_dst_width<<1  )^;
  v3                          :=(pixel_ptr+bmp_dst_width<<1+2)^;
  b                           :=    (Byte((v0)>>16)+Byte((v1)>>16)+Byte((v2)>>16)+Byte((v3)>>16))>>2;
  (pixel_ptr+bmp_dst_width+1)^:=RGB((Byte((v0)>>00)+Byte((v1)>>00)+Byte((v2)>>00)+Byte((v3)>>00))>>2,b,b);
end; {$endregion}
procedure BlurRRR      (pixel_ptr:PInteger; bmp_dst_width:TColor                                                                                                                            );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r:=(Red((pixel_ptr+0                 )^)+
      Red((pixel_ptr+2                 )^)+
      Red((pixel_ptr+0+bmp_dst_width<<1)^)+
      Red((pixel_ptr+2+bmp_dst_width<<1)^))>>2;
          (pixel_ptr+bmp_dst_width+1)^:=RGB(r,r,r);
end; {$endregion}
procedure BlurGGG      (pixel_ptr:PInteger; bmp_dst_width:TColor                                                                                                                            );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g:=(Green((pixel_ptr+0                 )^)+
      Green((pixel_ptr+2                 )^)+
      Green((pixel_ptr+0+bmp_dst_width<<1)^)+
      Green((pixel_ptr+2+bmp_dst_width<<1)^))>>2;
            (pixel_ptr+bmp_dst_width+1)^:=RGB(g,g,g);
end; {$endregion}
procedure BlurBBB      (pixel_ptr:PInteger; bmp_dst_width:TColor                                                                                                                            );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b:=(Blue((pixel_ptr+0                 )^)+
      Blue((pixel_ptr+2                 )^)+
      Blue((pixel_ptr+0+bmp_dst_width<<1)^)+
      Blue((pixel_ptr+2+bmp_dst_width<<1)^))>>2;
           (pixel_ptr+bmp_dst_width+1)^:=RGB(b,b,b);
end; {$endregion}
procedure Contrast     (pixel_ptr:PInteger; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref contrast_pow2:double=0.0                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(Limit(r+Trunc((Red  (pixel_ptr^)-r)*contrast_pow2)),
                  Limit(g+Trunc((Green(pixel_ptr^)-g)*contrast_pow2)),
                  Limit(b+Trunc((Blue (pixel_ptr^)-b)*contrast_pow2)));
end; {$endregion}
// Decrease Effect:
function AdditiveDec   (pixel    :TColor;   constref r,g,b:byte;                     constref alpha_fade:byte                                        ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin

  if   (Min3(Red  (pixel)+b,255)>Red(pixel)) then
    r_:=Min3(Red  (pixel)+b,255)-((alpha_fade*(Abs(Min3(Red  (pixel)+b,255)-Red  (pixel))))>>8)
  else
    r_:=Min3(Red  (pixel)+b,255)+((alpha_fade*(Abs(Min3(Red  (pixel)+b,255)-Red  (pixel))))>>8);

  if   (Min3(Green(pixel)+g,255)>Green(pixel)) then
    g_:=Min3(Green(pixel)+g,255)-((alpha_fade*(Abs(Min3(Green(pixel)+g,255)-Green(pixel))))>>8)
  else
    g_:=Min3(Green(pixel)+g,255)+((alpha_fade*(Abs(Min3(Green(pixel)+g,255)-Green(pixel))))>>8);

  if   (Min3(Blue (pixel)+r,255)>Blue (pixel)) then
    b_:=Min3(Blue (pixel)+r,255)-((alpha_fade*(Abs(Min3(Blue (pixel)+r,255)-Blue (pixel))))>>8)
  else
    b_:=Min3(Blue (pixel)+r,255)+((alpha_fade*(Abs(Min3(Blue (pixel)+r,255)-Blue (pixel))))>>8);

  Result:=RGB{ToColor}(r_,g_,b_);

end; {$endregion}
function AdditiveDec2  (pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin

  if   (Min3(Red  (pixel)+b,255)>Red(pixel)) then
    r_:=Min3(Red  (pixel)+b,255)-((alpha_fade*(Abs(Min3(Red  (pixel)+b,255)-Red  (pixel))))>>8)
  else
    r_:=Min3(Red  (pixel)+b,255)+((alpha_fade*(Abs(Min3(Red  (pixel)+b,255)-Red  (pixel))))>>8);

  if   (Min3(Green(pixel)+g,255)>Green(pixel)) then
    g_:=Min3(Green(pixel)+g,255)-((alpha_fade*(Abs(Min3(Green(pixel)+g,255)-Green(pixel))))>>8)
  else
    g_:=Min3(Green(pixel)+g,255)+((alpha_fade*(Abs(Min3(Green(pixel)+g,255)-Green(pixel))))>>8);

  if   (Min3(Blue (pixel)+r,255)>Blue (pixel)) then
    b_:=Min3(Blue (pixel)+r,255)-((alpha_fade*(Abs(Min3(Blue (pixel)+r,255)-Blue (pixel))))>>8)
  else
    b_:=Min3(Blue (pixel)+r,255)+((alpha_fade*(Abs(Min3(Blue (pixel)+r,255)-Blue (pixel))))>>8);

  Result:=RGB{ToColor}(r_,g_,b_);

end; {$endregion}
procedure AlphaBlendDec(pixel_ptr:PInteger; constref r,g,b:byte; alpha        :byte; constref alpha_fade:byte                                        );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  d_alpha:byte;
begin
  d_alpha:=255-Max2(alpha-alpha_fade,0);
  pixel_ptr^:=(((Blue (pixel_ptr^)-r)*d_alpha)>>8+r)<<16+
              (((Green(pixel_ptr^)-g)*d_alpha)>>8+g)<<08+
              (((Red  (pixel_ptr^)-b)*d_alpha)>>8+b)<<00;
end; {$endregion}
function AlphaBlendDec (pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte                                        ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  alpha  :=Max2(alpha-alpha_fade,0);
  d_alpha:=255-alpha;
  Result:=(((Blue (pixel)-r)*d_alpha)>>8+r)<<16+
          (((Green(pixel)-g)*d_alpha)>>8+g)<<08+
          (((Red  (pixel)-b)*d_alpha)>>8+b)<<00;
       {RGB((b*alpha+d_alpha*Red  (pixel))>>8,
            (g*alpha+d_alpha*Green(pixel))>>8,
            (r*alpha+d_alpha*Blue (pixel))>>8);}
end; {$endregion}
function AlphaBlendDec2(pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  alpha  :=Max2(alpha-Byte(d){alpha_fade},0);
  d_alpha:=255-alpha;
  Result:=(((Blue (pixel)-r)*d_alpha)>>8+r)<<16+
          (((Green(pixel)-g)*d_alpha)>>8+g)<<08+
          (((Red  (pixel)-b)*d_alpha)>>8+b)<<00;
       {RGB((b*alpha+d_alpha*Red  (pixel))>>8,
            (g*alpha+d_alpha*Green(pixel))>>8,
            (r*alpha+d_alpha*Blue (pixel))>>8);}
end; {$endregion}
function InverseDec    (pixel    :TColor;                                            constref alpha_fade:byte                                        ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r,g,b: byte;
begin

  if  (255>Red  (pixel)<<1) then
    r:=255-Red  (pixel)-((alpha_fade*(Abs(255-Red  (pixel)<<1)))>>8)
  else
    r:=255-Red  (pixel)+((alpha_fade*(Abs(255-Red  (pixel)<<1)))>>8);

  if  (255>Green(pixel)<<1) then
    g:=255-Green(pixel)-((alpha_fade*(Abs(255-Green(pixel)<<1)))>>8)
  else
    g:=255-Green(pixel)+((alpha_fade*(Abs(255-Green(pixel)<<1)))>>8);

  if  (255>Blue (pixel)<<1) then
    b:=255-Blue (pixel)-((alpha_fade*(Abs(255-Blue (pixel)<<1)))>>8)
  else
    b:=255-Blue (pixel)+((alpha_fade*(Abs(255-Blue (pixel)<<1)))>>8);

  Result:=RGB(r,g,b);

end; {$endregion}
function InverseDec2   (pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin

  if   (255>Red  (pixel)<<1) then
    r_:=255-Red  (pixel)-((alpha_fade*(Abs(255-Red  (pixel)<<1)))>>8)
  else
    r_:=255-Red  (pixel)+((alpha_fade*(Abs(255-Red  (pixel)<<1)))>>8);

  if   (255>Green(pixel)<<1) then
    g_:=255-Green(pixel)-((alpha_fade*(Abs(255-Green(pixel)<<1)))>>8)
  else
    g_:=255-Green(pixel)+((alpha_fade*(Abs(255-Green(pixel)<<1)))>>8);

  if   (255>Blue (pixel)<<1) then
    b_:=255-Blue (pixel)-((alpha_fade*(Abs(255-Blue (pixel)<<1)))>>8)
  else
    b_:=255-Blue (pixel)+((alpha_fade*(Abs(255-Blue (pixel)<<1)))>>8);

  Result:=RGB(r_,g_,b_);

end; {$endregion}
function HighlightDec  (pixel    :TColor;                                            constref alpha_fade:byte; constref pow:byte=64                  ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r,g,b: byte;
begin

  if  (Min3(Red  (pixel)+pow,255)>Red(pixel)) then
    r:=Min3(Red  (pixel)+pow,255)-((alpha_fade*(Abs(Min3(Red  (pixel)+pow,255)-Red  (pixel))))>>8)
  else
    r:=Min3(Red  (pixel)+pow,255)+((alpha_fade*(Abs(Min3(Red  (pixel)+pow,255)-Red  (pixel))))>>8);

  if  (Min3(Green(pixel)+pow,255)>Green(pixel)) then
    g:=Min3(Green(pixel)+pow,255)-((alpha_fade*(Abs(Min3(Green(pixel)+pow,255)-Green(pixel))))>>8)
  else
    g:=Min3(Green(pixel)+pow,255)+((alpha_fade*(Abs(Min3(Green(pixel)+pow,255)-Green(pixel))))>>8);

  if  (Min3(Blue (pixel)+pow,255)>Blue (pixel)) then
    b:=Min3(Blue (pixel)+pow,255)-((alpha_fade*(Abs(Min3(Blue (pixel)+pow,255)-Blue (pixel))))>>8)
  else
    b:=Min3(Blue (pixel)+pow,255)+((alpha_fade*(Abs(Min3(Blue (pixel)+pow,255)-Blue (pixel))))>>8);

  Result:=RGB(r,g,b);

end; {$endregion}
function HighlightDec2 (pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin

  if   (Min3(Red  (pixel)+pow,255)>Red(pixel)) then
    r_:=Min3(Red  (pixel)+pow,255)-((alpha_fade*(Abs(Min3(Red  (pixel)+pow,255)-Red  (pixel))))>>8)
  else
    r_:=Min3(Red  (pixel)+pow,255)+((alpha_fade*(Abs(Min3(Red  (pixel)+pow,255)-Red  (pixel))))>>8);

  if   (Min3(Green(pixel)+pow,255)>Green(pixel)) then
    g_:=Min3(Green(pixel)+pow,255)-((alpha_fade*(Abs(Min3(Green(pixel)+pow,255)-Green(pixel))))>>8)
  else
    g_:=Min3(Green(pixel)+pow,255)+((alpha_fade*(Abs(Min3(Green(pixel)+pow,255)-Green(pixel))))>>8);

  if   (Min3(Blue (pixel)+pow,255)>Blue (pixel)) then
    b_:=Min3(Blue (pixel)+pow,255)-((alpha_fade*(Abs(Min3(Blue (pixel)+pow,255)-Blue (pixel))))>>8)
  else
    b_:=Min3(Blue (pixel)+pow,255)+((alpha_fade*(Abs(Min3(Blue (pixel)+pow,255)-Blue (pixel))))>>8);

  Result:=RGB(r_,g_,b_);

end; {$endregion}
function DarkenDec     (pixel    :TColor;                                            constref alpha_fade:byte; constref pow:byte=64                  ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r,g,b: byte;
begin

  if  (Max2(Red  (pixel)-pow,0)>Red(pixel)) then
    r:=Max2(Red  (pixel)-pow,0)-((alpha_fade*(Abs(Max2(Red  (pixel)-pow,0)-Red  (pixel))))>>8)
  else
    r:=Max2(Red  (pixel)-pow,0)+((alpha_fade*(Abs(Max2(Red  (pixel)-pow,0)-Red  (pixel))))>>8);

  if  (Max2(Green(pixel)-pow,0)>Green(pixel)) then
    g:=Max2(Green(pixel)-pow,0)-((alpha_fade*(Abs(Max2(Green(pixel)-pow,0)-Green(pixel))))>>8)
  else
    g:=Max2(Green(pixel)-pow,0)+((alpha_fade*(Abs(Max2(Green(pixel)-pow,0)-Green(pixel))))>>8);

  if  (Max2(Blue (pixel)-pow,0)>Blue (pixel)) then
    b:=Max2(Blue (pixel)-pow,0)-((alpha_fade*(Abs(Max2(Blue (pixel)-pow,0)-Blue (pixel))))>>8)
  else
    b:=Max2(Blue (pixel)-pow,0)+((alpha_fade*(Abs(Max2(Blue (pixel)-pow,0)-Blue (pixel))))>>8);

  Result:=RGB(r,g,b);

end; {$endregion}
function DarkenDec2    (pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin

  if   (Max2(Red  (pixel)-pow,0)>Red(pixel)) then
    r_:=Max2(Red  (pixel)-pow,0)-((alpha_fade*(Abs(Max2(Red  (pixel)-pow,0)-Red  (pixel))))>>8)
  else
    r_:=Max2(Red  (pixel)-pow,0)+((alpha_fade*(Abs(Max2(Red  (pixel)-pow,0)-Red  (pixel))))>>8);

  if   (Max2(Green(pixel)-pow,0)>Green(pixel)) then
    g_:=Max2(Green(pixel)-pow,0)-((alpha_fade*(Abs(Max2(Green(pixel)-pow,0)-Green(pixel))))>>8)
  else
    g_:=Max2(Green(pixel)-pow,0)+((alpha_fade*(Abs(Max2(Green(pixel)-pow,0)-Green(pixel))))>>8);

  if   (Max2(Blue (pixel)-pow,0)>Blue (pixel)) then
    b_:=Max2(Blue (pixel)-pow,0)-((alpha_fade*(Abs(Max2(Blue (pixel)-pow,0)-Blue (pixel))))>>8)
  else
    b_:=Max2(Blue (pixel)-pow,0)+((alpha_fade*(Abs(Max2(Blue (pixel)-pow,0)-Blue (pixel))))>>8);

  Result:=RGB(r_,g_,b_);

end; {$endregion}
function GrayscaleRDec (pixel    :TColor;                                            constref alpha_fade:byte                                        ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r,g,b: byte;
begin

    r:=Red  (pixel);

  if  (Green(pixel)>Red(pixel)) then
    g:=Green(pixel)-((alpha_fade*(Abs(Green(pixel)-Red(pixel))))>>8)
  else
    g:=Green(pixel)+((alpha_fade*(Abs(Green(pixel)-Red(pixel))))>>8);

  if  (Blue (pixel)>Red(pixel)) then
    b:=Blue (pixel)-((alpha_fade*(Abs(Blue (pixel)-Red(pixel))))>>8)
  else
    b:=Blue (pixel)+((alpha_fade*(Abs(Blue (pixel)-Red(pixel))))>>8);

  Result:=RGB(r,g,b);

end; {$endregion}
function GrayscaleRDec2(pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin

    r_:=Red  (pixel);

  if   (Green(pixel)>Red(pixel)) then
    g_:=Green(pixel)-((d*(Abs(Green(pixel)-Red(pixel))))>>8)
  else
    g_:=Green(pixel)+((d*(Abs(Green(pixel)-Red(pixel))))>>8);

  if   (Blue (pixel)>Red(pixel)) then
    b_:=Blue (pixel)-((d*(Abs(Blue (pixel)-Red(pixel))))>>8)
  else
    b_:=Blue (pixel)+((d*(Abs(Blue (pixel)-Red(pixel))))>>8);

  Result:=RGB(r_,g_,b_);

end; {$endregion}
function GrayscaleGDec (pixel    :TColor;                                            constref alpha_fade:byte                                        ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r,g,b: byte;
begin

  if  (Red  (pixel)>Green(pixel)) then
    r:=Red  (pixel)-((alpha_fade*(Abs(Red  (pixel)-Green(pixel))))>>8)
  else
    r:=Red  (pixel)+((alpha_fade*(Abs(Red  (pixel)-Green(pixel))))>>8);

    g:=Green(pixel);

  if  (Blue (pixel)>Green(pixel)) then
    b:=Blue (pixel)-((alpha_fade*(Abs(Blue (pixel)-Green(pixel))))>>8)
  else
    b:=Blue (pixel)+((alpha_fade*(Abs(Blue (pixel)-Green(pixel))))>>8);

  Result:=RGB(r,g,b);

end; {$endregion}
function GrayscaleGDec2(pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin

  if   (Red  (pixel)>Green(pixel)) then
    r_:=Red  (pixel)-((alpha_fade*(Abs(Red  (pixel)-Green(pixel))))>>8)
  else
    r_:=Red  (pixel)+((alpha_fade*(Abs(Red  (pixel)-Green(pixel))))>>8);

    g_:=Green(pixel);

  if   (Blue (pixel)>Green(pixel)) then
    b_:=Blue (pixel)-((alpha_fade*(Abs(Blue (pixel)-Green(pixel))))>>8)
  else
    b_:=Blue (pixel)+((alpha_fade*(Abs(Blue (pixel)-Green(pixel))))>>8);

  Result:=RGB(r_,g_,b_);

end; {$endregion}
function GrayscaleBDec (pixel    :TColor;                                            constref alpha_fade:byte                                        ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r,g,b: byte;
begin

  if  (Red  (pixel)>Blue(pixel)) then
    r:=Red  (pixel)-((alpha_fade*(Abs(Red  (pixel)-Blue(pixel))))>>8)
  else
    r:=Red  (pixel)+((alpha_fade*(Abs(Red  (pixel)-Blue(pixel))))>>8);

  if  (Green(pixel)>Blue(pixel)) then
    g:=Green(pixel)-((alpha_fade*(Abs(Green(pixel)-Blue(pixel))))>>8)
  else
    g:=Green(pixel)+((alpha_fade*(Abs(Green(pixel)-Blue(pixel))))>>8);

    b:=Blue (pixel);

  Result:=RGB(r,g,b);

end; {$endregion}
function GrayscaleBDec2(pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin

  if   (Red  (pixel)>Blue(pixel)) then
    r_:=Red  (pixel)-((alpha_fade*(Abs(Red  (pixel)-Blue(pixel))))>>8)
  else
    r_:=Red  (pixel)+((alpha_fade*(Abs(Red  (pixel)-Blue(pixel))))>>8);

  if   (Green(pixel)>Blue(pixel)) then
    g_:=Green(pixel)-((alpha_fade*(Abs(Green(pixel)-Blue(pixel))))>>8)
  else
    g_:=Green(pixel)+((alpha_fade*(Abs(Green(pixel)-Blue(pixel))))>>8);

    b_:=Blue (pixel);

  Result:=RGB(r_,g_,b_);

end; {$endregion}
function ColorizeRMDec (pixel    :TColor;                                            constref alpha_fade:byte;                    constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
  b: byte;
begin
  v:=Red(pixel)+d;
  if (v<000) then
    b:=(alpha_fade*Blue(pixel))>>8
  else
    begin
      if  (Byte(v)>Blue(pixel)) then
        b:=Byte(v)-(alpha_fade*(Abs(Byte(v)-Blue(pixel))))>>8
      else
        b:=Byte(v)+(alpha_fade*(Abs(Byte(v)-Blue(pixel))))>>8;
    end;
  Result:=pixel-Blue(pixel)<<16+b<<16;
end; {$endregion}
function ColorizeRMDec2(pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
  b_: byte;
begin
  v:=Red(pixel)+d;
  if (v<000) then
    b_:=(alpha_fade*Blue(pixel))>>8
  else
    begin
      if  (Byte(v)>Blue(pixel)) then
        b_:=Byte(v)-(alpha_fade*(Abs(Byte(v)-Blue(pixel))))>>8
      else
        b_:=Byte(v)+(alpha_fade*(Abs(Byte(v)-Blue(pixel))))>>8;
    end;
  Result:=pixel-Blue(pixel)<<16+b_<<16;
end; {$endregion}
function ColorizeRPDec (pixel    :TColor;                                            constref alpha_fade:byte;                    constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
  b: byte;
begin
  v:=Red(pixel)+d;
  if (v>255) then
    begin
      if  (255>Blue(pixel)) then
        b:=255-(alpha_fade*(Abs(255-Blue(pixel))))>>8
      else
        b:=255+(alpha_fade*(Abs(255-Blue(pixel))))>>8
    end
  else
    begin
      if  (Byte(v)>Blue(pixel)) then
        b:=Byte(v)-(alpha_fade*(Abs(Byte(v)-Blue(pixel))))>>8
      else
        b:=Byte(v)+(alpha_fade*(Abs(Byte(v)-Blue(pixel))))>>8;
    end;
  Result:=pixel-Blue(pixel)<<16+b<<16;
end; {$endregion}
function ColorizeRPDec2(pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
  b_: byte;
begin
  v:=Red(pixel)+d;
  if (v>255) then
    begin
      if  (255>Blue(pixel)) then
        b_:=255-(alpha_fade*(Abs(255-Blue(pixel))))>>8
      else
        b_:=255+(alpha_fade*(Abs(255-Blue(pixel))))>>8
    end
  else
    begin
      if  (Byte(v)>Blue(pixel)) then
        b_:=Byte(v)-(alpha_fade*(Abs(Byte(v)-Blue(pixel))))>>8
      else
        b_:=Byte(v)+(alpha_fade*(Abs(Byte(v)-Blue(pixel))))>>8;
    end;
  Result:=pixel-Blue(pixel)<<16+b_<<16;
end; {$endregion}
function ColorizeGMDec (pixel    :TColor;                                            constref alpha_fade:byte;                    constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
  g: byte;
begin
  v:=Green(pixel)+d;
  if (v<000) then
    g:=(alpha_fade*Green(pixel))>>8
  else
    begin
      if  (Byte(v)>Green(pixel)) then
        g:=Byte(v)-(alpha_fade*(Abs(Byte(v)-Green(pixel))))>>8
      else
        g:=Byte(v)+(alpha_fade*(Abs(Byte(v)-Green(pixel))))>>8;
    end;
  Result:=pixel-Green(pixel)<<08+g<<08;
end; {$endregion}
function ColorizeGMDec2(pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
  g_: byte;
begin
  v:=Green(pixel)+d;
  if (v<000) then
    g_:=(alpha_fade*Green(pixel))>>8
  else
    begin
      if  (Byte(v)>Green(pixel)) then
        g_:=Byte(v)-(alpha_fade*(Abs(Byte(v)-Green(pixel))))>>8
      else
        g_:=Byte(v)+(alpha_fade*(Abs(Byte(v)-Green(pixel))))>>8;
    end;
  Result:=pixel-Green(pixel)<<08+g_<<08;
end; {$endregion}
function ColorizeGPDec (pixel    :TColor;                                            constref alpha_fade:byte;                    constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
  g: byte;
begin
  v:=Green(pixel)+d;
  if (v>255) then
    begin
      if  (255>Green(pixel)) then
        g:=255-(alpha_fade*(Abs(255-Green(pixel))))>>8
      else
        g:=255+(alpha_fade*(Abs(255-Green(pixel))))>>8;
    end
  else
    begin
      if  (Byte(v)>Green(pixel)) then
        g:=Byte(v)-(alpha_fade*(Abs(Byte(v)-Green(pixel))))>>8
      else
        g:=Byte(v)+(alpha_fade*(Abs(Byte(v)-Green(pixel))))>>8;
    end;
  Result:=pixel-Green(pixel)<<08+g<<08;
end; {$endregion}
function ColorizeGPDec2(pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
  g_: byte;
begin
  v:=Green(pixel)+d;
  if (v>255) then
    begin
      if  (255>Green(pixel)) then
        g_:=255-(alpha_fade*(Abs(255-Green(pixel))))>>8
      else
        g_:=255+(alpha_fade*(Abs(255-Green(pixel))))>>8;
    end
  else
    begin
      if  (Byte(v)>Green(pixel)) then
        g_:=Byte(v)-(alpha_fade*(Abs(Byte(v)-Green(pixel))))>>8
      else
        g_:=Byte(v)+(alpha_fade*(Abs(Byte(v)-Green(pixel))))>>8;
    end;
  Result:=pixel-Green(pixel)<<08+g_<<08;
end; {$endregion}
function ColorizeBMDec (pixel    :TColor;                                            constref alpha_fade:byte;                    constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
  r: byte;
begin
  v:=Blue(pixel)+d;
  if (v<000) then
    r:=(alpha_fade*Red(pixel))>>8
  else
    begin
      if  (Byte(v)>Red(pixel)) then
        r:=Byte(v)-(alpha_fade*(Abs(Byte(v)-Red(pixel))))>>8
      else
        r:=Byte(v)+(alpha_fade*(Abs(Byte(v)-Red(pixel))))>>8;
    end;
  Result:=pixel-Red(pixel)<<00+r<<00;
end; {$endregion}
function ColorizeBMDec2(pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
  r_: byte;
begin
  v:=Blue(pixel)+d;
  if (v<000) then
    r_:=(alpha_fade*Red(pixel))>>8
  else
    begin
      if  (Byte(v)>Red(pixel)) then
        r_:=Byte(v)-(alpha_fade*(Abs(Byte(v)-Red(pixel))))>>8
      else
        r_:=Byte(v)+(alpha_fade*(Abs(Byte(v)-Red(pixel))))>>8;
    end;
  Result:=pixel-Red(pixel)<<00+r_<<00;
end; {$endregion}
function ColorizeBPDec (pixel    :TColor;                                            constref alpha_fade:byte;                    constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
  r: byte;
begin
  v:=Blue(pixel)+d;
  if (v>255) then
    begin
      if  (255>Red(pixel)) then
        r:=255-(alpha_fade*(Abs(255-Red(pixel))))>>8
      else
        r:=255+(alpha_fade*(Abs(255-Red(pixel))))>>8
    end
  else
    begin
      if  (Byte(v)>Red(pixel)) then
        r:=Byte(v)-(alpha_fade*(Abs(Byte(v)-Red(pixel))))>>8
      else
        r:=Byte(v)+(alpha_fade*(Abs(Byte(v)-Red(pixel))))>>8;
    end;
  Result:=pixel-Red(pixel)<<00+r<<00;
end; {$endregion}
function ColorizeBPDec2(pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v: integer;
  r_: byte;
begin
  v:=Blue(pixel)+d;
  if (v>255) then
    begin
      if  (255>Red(pixel)) then
        r_:=255-(alpha_fade*(Abs(255-Red(pixel))))>>8
      else
        r_:=255+(alpha_fade*(Abs(255-Red(pixel))))>>8
    end
  else
    begin
      if  (Byte(v)>Red(pixel)) then
        r_:=Byte(v)-(alpha_fade*(Abs(Byte(v)-Red(pixel))))>>8
      else
        r_:=Byte(v)+(alpha_fade*(Abs(Byte(v)-Red(pixel))))>>8;
    end;
  Result:=pixel-Red(pixel)<<00+r_<<00;
end; {$endregion}
{$endregion}



(***************************** Some Basic Routines ****************************) {$region -fold}

// (Set Point) Установить точку:
function PtPos (constref pt:TPtPosF         ): TPtPos;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=Trunc(pt.x);
  Result.y:=Trunc(pt.y);
end; {$endregion}
function PtPos (constref pos_x,pos_y:integer): TPtPos;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=pos_x;
  Result.y:=pos_y;
end; {$endregion}
function PtPos (constref pos_x,pos_y:double ): TPtPos;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=Trunc(pos_x);
  Result.y:=Trunc(pos_y);
end; {$endregion}
function PtPosF(constref pt:TPtPos          ): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=pt.x;
  Result.y:=pt.y;
end; {$endregion}
function PtPosF(constref pos_x,pos_y:double ): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=pos_x;
  Result.y:=pos_y;
end; {$endregion}
function PtPosF(constref pos_x,pos_y:integer): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=pos_x;
  Result.y:=pos_y;
end; {$endregion}

// (Set Point) Установить точку:
function LnPos (constref vec:TLnPosF        ): TLnPos;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      x0:=Trunc(vec.x0);
      y0:=Trunc(vec.y0);
      x1:=Trunc(vec.x1);
      y1:=Trunc(vec.y1);
    end;
end; {$endregion}
function LnPos (constref x0,y0,x1,y1:integer): TLnPos;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x0:=x0;
  Result.y0:=y0;
  Result.x1:=x1;
  Result.y1:=y1;
end; {$endregion}
function LnPosF(constref vec:TLnPos         ): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      x0:=vec.x0;
      y0:=vec.y0;
      x1:=vec.x1;
      y1:=vec.y1;
    end;
end; {$endregion}
function LnPosF(constref x0,y0,x1,y1:double ): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x0:=x0;
  Result.y0:=y0;
  Result.x1:=x1;
  Result.y1:=y1;
end; {$endregion}
function LnPosF(constref x0,y0,x1,y1:integer): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x0:=x0;
  Result.y0:=y0;
  Result.x1:=x1;
  Result.y1:=y1;
end; {$endregion}

// (Bounding Rectangle of Points Set) Ограничиваюший прямоугольник множества точек:
function PtsRngRctCalc    (constref pts:TPtPosFArr; var rct_bnd_ind_arr  :TEnum2Arr; constref start_pts_ind:TColor=0; constref end_pts_ind:TColor=0): TRect; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr                                : PPtPosF;
  min_x,min_y,max_x,max_y                : double;
  ind_min_x,ind_min_y,ind_max_x,ind_max_y: integer;
  i                                      : integer;
begin

  {Misc. Precalc.-----------------} {$region -fold}
  Result:=Default(TRect);

  ind_min_x:=0;
  ind_min_y:=0;
  ind_max_x:=0;
  ind_max_y:=0;

  with pts[start_pts_ind] do
    begin
      min_x:=x;
      min_y:=y;
      max_x:=x;
      max_y:=y;
    end; {$endregion}

  {Calc. of Rectangle-------------} {$region -fold}
  pts_ptr:=Unaligned(@pts[start_pts_ind]);
  for i:=start_pts_ind to end_pts_ind do
    begin
      if ({Trunc(}pts_ptr^.x{)}<=min_x) then
        begin
          min_x    :={Trunc(}pts_ptr^.x{)};
          ind_min_x:=i;
        end;
      if ({Trunc(}pts_ptr^.y{)}<=min_y) then
        begin
          min_y    :={Trunc(}pts_ptr^.y{)};
          ind_min_y:=i;
        end;
      if ({Trunc(}pts_ptr^.x{)}>=max_x) then
        begin
          max_x    :={Trunc(}pts_ptr^.x{)};
          ind_max_x:=i;
        end;
      if ({Trunc(}pts_ptr^.y{)}>=max_y) then
        begin
          max_y    :={Trunc(}pts_ptr^.y{)};
          ind_max_y:=i;
        end;
      Inc(pts_ptr);
    end; {$endregion}

  {Set Rectangle------------------} {$region -fold}
  with Result do
    begin
      left  :=Trunc(pts[ind_min_x].x)+0;
      top   :=Trunc(pts[ind_min_y].y)+0;
      right :=Trunc(pts[ind_max_x].x)+1;
      bottom:=Trunc(pts[ind_max_y].y)+1;
      width :=right-left;
      height:=bottom-top;
    end; {$endregion}

  {Save Indices of Borders(Points)} {$region -fold}
  rct_bnd_ind_arr[0]:=ind_min_x;
  rct_bnd_ind_arr[1]:=ind_min_y;
  rct_bnd_ind_arr[2]:=ind_max_x;
  rct_bnd_ind_arr[3]:=ind_max_y; {$endregion}

end; {$endregion}
function PtsRngIndsRctCalc(constref pts:TPtPosFArr; constref sel_pts_inds:TColorArr; constref pts_cnt:TColor                                       ): TRect; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr                                : PPtPosF;
  sel_pts_inds_ptr                       : PInteger;
  min_x,min_y,max_x,max_y                : double;
  ind_min_x,ind_min_y,ind_max_x,ind_max_y: integer;
  i                                      : integer;
begin

  {Misc. Precalc.----} {$region -fold}
  Result:=Default(TRect);

  ind_min_x:=0;
  ind_min_y:=0;
  ind_max_x:=0;
  ind_max_y:=0;

  with pts[sel_pts_inds[0]] do
    begin
      min_x:=x;
      min_y:=y;
      max_x:=x;
      max_y:=y;
    end; {$endregion}

  {Calc. of Rectangle} {$region -fold}
  pts_ptr         :=Unaligned(@pts         [0]);
  sel_pts_inds_ptr:=Unaligned(@sel_pts_inds[0]);
  for i:=0 to pts_cnt-1 do
    begin
      if ((pts_ptr+sel_pts_inds_ptr^)^.x<=min_x) then
        begin
          min_x    :=(pts_ptr+sel_pts_inds_ptr^)^.x;
          ind_min_x:=sel_pts_inds_ptr^;
        end;
      if ((pts_ptr+sel_pts_inds_ptr^)^.y<=min_y) then
        begin
          min_y    :=(pts_ptr+sel_pts_inds_ptr^)^.y;
          ind_min_y:=sel_pts_inds_ptr^;
        end;
      if ((pts_ptr+sel_pts_inds_ptr^)^.x>=max_x) then
        begin
          max_x    :=(pts_ptr+sel_pts_inds_ptr^)^.x;
          ind_max_x:=sel_pts_inds_ptr^;
        end;
      if ((pts_ptr+sel_pts_inds_ptr^)^.y>=max_y) then
        begin
          max_y    :=(pts_ptr+sel_pts_inds_ptr^)^.y;
          ind_max_y:=sel_pts_inds_ptr^;
        end;
      Inc(sel_pts_inds_ptr);
    end; {$endregion}

  {Set Rectangle-----} {$region -fold}
  with Result do
    begin
      left  :=Trunc(pts[ind_min_x].x)+0;
      top   :=Trunc(pts[ind_min_y].y)+0;
      right :=Trunc(pts[ind_max_x].x)+1;
      bottom:=Trunc(pts[ind_max_y].y)+1;
      width :=right-left;
      height:=bottom-top;
    end; {$endregion}

end; {$endregion}

// (Set Rectangle) Установить прямоугольник:
procedure PtRct   (constref pts:TPtPosFArr; constref rct_bnd_ind_arr:TEnum2Arr; var rct:TRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct do
    begin
      left  :=Trunc(pts[rct_bnd_ind_arr[0]].x)+0;
      top   :=Trunc(pts[rct_bnd_ind_arr[1]].y)+0;
      right :=Trunc(pts[rct_bnd_ind_arr[2]].x)+1;
      bottom:=Trunc(pts[rct_bnd_ind_arr[3]].y)+1;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function PtRctB   (constref rct_left,rct_top,rct_right,rct_bottom:integer): TPtRectB;           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=Default(TPtrectB);
  with Result.pt_rct do
    begin
      left  :=rct_left  ;
      top   :=rct_top   ;
      right :=rct_right ;
      bottom:=rct_bottom;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function PtRct    (constref rct_left,rct_top,rct_right,rct_bottom:integer): TPtRect;            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct_left  ;
      top   :=rct_top   ;
      right :=rct_right ;
      bottom:=rct_bottom;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function PtRct    (constref rct:TRect                                    ): TPtRect;            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct.left  ;
      top   :=rct.top   ;
      right :=rct.right ;
      bottom:=rct.bottom;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function PtRct    (constref rct:TPtRectF                                 ): TPtRect;            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=Trunc(rct.left  );
      top   :=Trunc(rct.top   );
      right :=Trunc(rct.right );
      bottom:=Trunc(rct.bottom);
      width :=right -left;
      height:=bottom-top ;
    end;
end; {$endregion}
function PtRct    (constref rct:TPtPosFArr                               ): TPtRect;            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=Trunc(rct[0].x);
      top   :=Trunc(rct[0].y);
      right :=Trunc(rct[1].x);
      bottom:=Trunc(rct[1].y);
      width :=right -left;
      height:=bottom-top ;
    end;
end; {$endregion}
function PtBounds (constref rct_left,rct_top,rct_width,rct_height:integer): TPtRect;            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct_left  ;
      top   :=rct_top   ;
      width :=rct_width ;
      height:=rct_height;
      right :=left+width;
      bottom:=top+height;
    end;
end; {$endregion}
function PtBounds (constref rct:TRect                                    ): TPtRect;            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct.left  ;
      top   :=rct.top   ;
      width :=rct.width ;
      height:=rct.height;
      right :=left+width;
      bottom:=top+height;
    end;
end; {$endregion}
function PtBoundsF(constref rct_left,rct_top,rct_width,rct_height:integer): TPtRectF;           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct_left  ;
      top   :=rct_top   ;
      width :=rct_width ;
      height:=rct_height;
      right :=left+width;
      bottom:=top+height;
    end;
end; {$endregion}

// (Inner Clipped Rectangle) Внутренний обрезанный прямоугольник:
function ClippedRctB(constref out_rct,                  inn_rct:TPtRect; var b                              :byte): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b0,b1,b2,b3: boolean;
begin
  b0:=(out_rct.left  <=inn_rct.left  );
  b1:=(out_rct.top   <=inn_rct.top   );
  b2:=(out_rct.right >=inn_rct.right );
  b3:=(out_rct.bottom>=inn_rct.bottom);
  {Inner Rectangle Is In Outer Rectangle}
  if (b0 and b1 and b2 and b3) then
    begin
      Result:=inn_rct;
      b     :=0;
      Exit;
    end
  else
  {Inner Rectangle Is Out Of Outer Rectangle}
  if (out_rct.left  >=inn_rct.right ) or
     (out_rct.top   >=inn_rct.bottom) or
     (out_rct.right <=inn_rct.left  ) or
     (out_rct.bottom<=inn_rct.top   ) then
    begin
      Result:=Default(TPtRect);
      b     :=2;
      Exit;
    end
  else
  {Inner Rectangle Is Clipped By Outer Rectangle}
  with Result do
    begin
      b:=1;
      if b0 then
        left  :=inn_rct.left
      else
        left  :=out_rct.left;
      if b1 then
        top   :=inn_rct.top
      else
        top   :=out_rct.top;
      if b2 then
        right :=inn_rct.right
      else
        right :=out_rct.right;
      if b3 then
        bottom:=inn_rct.bottom
      else
        bottom:=out_rct.bottom;
      width   :=right -left;
      height  :=bottom-top;
    end;
end; {$endregion}
function ClippedRctB(constref out_rct,                  inn_rct:TPtRect; var nt_pix_clp_type,pt_pix_clp_type:byte): TPtRectB; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b_coll_arr: array[0..3] of boolean;
  b_coll    : longword absolute b_coll_arr;
begin
  with Result do
    begin
      b_left  :=(out_rct.left  >=inn_rct.left  );
      b_top   :=(out_rct.top   >=inn_rct.top   );
      b_right :=(out_rct.right <=inn_rct.right );
      b_bottom:=(out_rct.bottom<=inn_rct.bottom);
      with pt_rct do
        begin
          if b_left then
            left  :=out_rct.left
          else
            left  :=inn_rct.left;
          if b_top then
            top   :=out_rct.top
          else
            top   :=inn_rct.top;
          if b_right then
            right :=out_rct.right
          else
            right :=inn_rct.right;
          if b_bottom then
            bottom:=out_rct.bottom
          else
            bottom:=inn_rct.bottom;
          width   :=right -left;
          height  :=bottom-top;
        end;
      b_coll_arr[0]:=b_left  ;
      b_coll_arr[1]:=b_top   ;
      b_coll_arr[2]:=b_right ;
      b_coll_arr[3]:=b_bottom;
    end;
  case b_coll of
    {No Clip--------------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    0       {%00000000000000000000000000000000}:
      begin
        nt_pix_clp_type:=0;
        pt_pix_clp_type:=0;
      end;
    {Top-Clipped----------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    256     {%00000000000000000000000100000000},
    {Bottom-Clipped-------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16777216{%00000001000000000000000000000000},
    {Top-Bottom-Clipped---------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16777472{%00000001000000000000000100000000}:
      begin
        nt_pix_clp_type:=1;
        pt_pix_clp_type:=1;
      end;
    {Left-Clipped---------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    1       {%00000000000000000000000000000001},
    {Left-Top-Clipped-----------------}
             { |e.b.   |e.b.   |e.b.   |e.b.   }
    257     {%00000000000000000000000100000001},
    {Left-Bottom-Clipped--------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16777217{%00000001000000000000000000000001},
    {Top-Left-Bottom-Clipped----------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16777473{%00000001000000000000000100000001},
    {Right-Clipped--------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    65536   {%00000000000000010000000000000000},
    {Right-Top-Clipped----------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    65792   {%00000000000000010000000100000000},
    {Right-Bottom-Clipped-------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16842752{%00000001000000010000000000000000},
    {Top-Right-Bottom-Clipped---------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16843008{%00000001000000010000000100000000},
    {Left-Top-Right-Clipped-----------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    65793   {%00000000000000010000000100000001},
    {Left-Bottom-Right-Clipped--------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16842753{%00000001000000010000000000000001},
    {Left-Right-Clipped---------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    65537   {%00000000000000010000000000000001},
    {Left-Top-Right-Bottom-Clipped----}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16843009{%00000001000000010000000100000001}:
      begin
        nt_pix_clp_type:=2;
        pt_pix_clp_type:=2;
      end;
  end;
end; {$endregion}
function ClippedRctB(constref out_rct,                  inn_rct:TPtRect                                          ): TPtRectB; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      b_left  :=(out_rct.left  >=inn_rct.left  );
      b_top   :=(out_rct.top   >=inn_rct.top   );
      b_right :=(out_rct.right <=inn_rct.right );
      b_bottom:=(out_rct.bottom<=inn_rct.bottom);
      with pt_rct do
        begin
          if b_left then
            left  :=out_rct.left
          else
            left  :=inn_rct.left;
          if b_top then
            top   :=out_rct.top
          else
            top   :=inn_rct.top;
          if b_right then
            right :=out_rct.right
          else
            right :=inn_rct.right;
          if b_bottom then
            bottom:=out_rct.bottom
          else
            bottom:=inn_rct.bottom;
          width :=right -left;
          height:=bottom-top;
        end;
    end;
end; {$endregion}
function ClippedRct (constref out_rct,                  inn_rct:TPtRect                                          ): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (out_rct.left  >=inn_rct.left  ) then
        left  :=out_rct.left
      else
        left  :=inn_rct.left;
      if (out_rct.top   >=inn_rct.top   ) then
        top   :=out_rct.top
      else
        top   :=inn_rct.top;
      if (out_rct.right <=inn_rct.right ) then
        right :=out_rct.right
      else
        right :=inn_rct.right;
      if (out_rct.bottom<=inn_rct.bottom) then
        bottom:=out_rct.bottom
      else
        bottom:=inn_rct.bottom;
      if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedRct (constref out_rct:TPtRect; constref inn_rct:TPtRectF                                         ): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (out_rct.left  >=inn_rct.left  ) then
        left  :=Trunc(out_rct.left)
      else
        left  :=Trunc(inn_rct.left);
      if (out_rct.top   >=inn_rct.top   ) then
        top   :=Trunc(out_rct.top)
      else
        top   :=Trunc(inn_rct.top);
      if (out_rct.right <=inn_rct.right ) then
        right :=Trunc(out_rct.right)
      else
        right :=Trunc(inn_rct.right);
      if (out_rct.bottom<=inn_rct.bottom) then
        bottom:=Trunc(out_rct.bottom)
      else
        bottom:=Trunc(inn_rct.bottom);
      if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedRct (constref out_rct,                  inn_rct:TRect                                            ): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (out_rct.left  >=inn_rct.left  ) then
        left  :=out_rct.left
      else
        left  :=inn_rct.left;
      if (out_rct.top   >=inn_rct.top   ) then
        top   :=out_rct.top
      else
        top   :=inn_rct.top;
      if (out_rct.right <=inn_rct.right ) then
        right :=out_rct.right
      else
        right :=inn_rct.right;
      if (out_rct.bottom<=inn_rct.bottom) then
        bottom:=out_rct.bottom
      else
        bottom:=inn_rct.bottom;
      if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedRct (constref out_rct:TPtRect; constref inn_rct:TRect                                            ): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (out_rct.left  >=inn_rct.left  ) then
        left  :=out_rct.left
      else
        left  :=inn_rct.left;
      if (out_rct.top   >=inn_rct.top   ) then
        top   :=out_rct.top
      else
        top   :=inn_rct.top;
      if (out_rct.right <=inn_rct.right ) then
        right :=out_rct.right
      else
        right :=inn_rct.right;
      if (out_rct.bottom<=inn_rct.bottom) then
        bottom:=out_rct.bottom
      else
        bottom:=inn_rct.bottom;
      if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedRct (constref out_rct:TPtRect; constref inn_rct:TRect; b:boolean                                 ): TRect;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (out_rct.left  >=inn_rct.left  ) then
        left  :=out_rct.left
      else
        left  :=inn_rct.left;
      if (out_rct.top   >=inn_rct.top   ) then
        top   :=out_rct.top
      else
        top   :=inn_rct.top;
      if (out_rct.right <=inn_rct.right ) then
        right :=out_rct.right
      else
        right :=inn_rct.right;
      if (out_rct.bottom<=inn_rct.bottom) then
        bottom:=out_rct.bottom
      else
        bottom:=inn_rct.bottom;
      if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedRct (constref out_rct,                  inn_rct:TRect; b:boolean                                 ): TRect;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (out_rct.left  >=inn_rct.left  ) then
        left  :=out_rct.left
      else
        left  :=inn_rct.left;
      if (out_rct.top   >=inn_rct.top   ) then
        top   :=out_rct.top
      else
        top   :=inn_rct.top;
      if (out_rct.right <=inn_rct.right ) then
        right :=out_rct.right
      else
        right :=inn_rct.right;
      if (out_rct.bottom<=inn_rct.bottom) then
        bottom:=out_rct.bottom
      else
        bottom:=inn_rct.bottom;
      if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedArr (constref rct_src:TPtRect; constref rct_dst:TPtRectB; constref arr_src_width:longword        ): integer;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b_coll_arr   : array[0..3] of boolean;
  b_coll       : longword absolute b_coll_arr;
begin
  Result:=0;
  b_coll_arr[0]:=rct_dst.b_left  ;
  b_coll_arr[1]:=rct_dst.b_top   ;
  b_coll_arr[2]:=rct_dst.b_right ;
  b_coll_arr[3]:=rct_dst.b_bottom;
  case b_coll of
    {No Clip--------------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    0       {%00000000000000000000000000000000},
    {Left-Clipped---------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    1       {%00000000000000000000000000000001},
    {Top-Clipped----------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    256     {%00000000000000000000000100000000},
    {Bottom-Clipped-------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16777216{%00000001000000000000000000000000},
    {Left-Top-Clipped-----------------}
             { |e.b.   |e.b.   |e.b.   |e.b.   }
    257     {%00000000000000000000000100000001},
    {Left-Bottom-Clipped--------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16777217{%00000001000000000000000000000001},
    {Top-Bottom-Clipped---------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16777472{%00000001000000000000000100000000},
    {Top-Left-Bottom-Clipped----------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16777473{%00000001000000000000000100000001}:
      Result:=rct_src.left;
    {Right-Clipped--------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    65536   {%00000000000000010000000000000000},
    {Right-Top-Clipped----------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    65792   {%00000000000000010000000100000000},
    {Right-Bottom-Clipped-------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16842752{%00000001000000010000000000000000},
    {Top-Right-Bottom-Clipped---------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16843008{%00000001000000010000000100000000},
    {Left-Top-Right-Clipped-----------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    65793   {%00000000000000010000000100000001},
    {Left-Bottom-Right-Clipped--------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16842753{%00000001000000010000000000000001},
    {Left-Right-Clipped---------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    65537   {%00000000000000010000000000000001},
    {Left-Top-Right-Bottom-Clipped----}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16843009{%00000001000000010000000100000001}:
      Result:=arr_src_width-rct_src.width;
  end;
end; {$endregion}

// (Find Rectangle Which Has Not Coprime Width and Height(GCD(src_rect.Width,src_rect.Height)<>1) for source rectangle src_rect) Находит прямоугольник с не взаимно простыми сторонами(GCD(src_rect.Width,src_rect.Height)<>1) для исходного прямоугольника src_rect:
function NCSRectCalc(constref rct_src:TRect   ; constref bucket_width,bucket_heigth:integer): TRect   ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct_src.left;
      top   :=rct_src.top ;
      width :=(Trunc(rct_src.width /bucket_width )+1)*bucket_width ;
      height:=(Trunc(rct_src.height/bucket_heigth)+1)*bucket_heigth;
      right :=left+width;
      bottom:=top+height;
    end;
end; {$endregion}
function NCSRectCalc(constref rct_src:TPtRectF; constref bucket_width,bucket_heigth:integer): TPtRectF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct_src.left;
      top   :=rct_src.top ;
      width :=(Trunc(rct_src.width /bucket_width )+1)*bucket_width ;
      height:=(Trunc(rct_src.height/bucket_heigth)+1)*bucket_heigth;
      right :=left+width;
      bottom:=top+height;
    end;
end; {$endregion}

// (Two Rectangles Bounding Rectangle 1) Ограничивающий прямоугольник для двух заданных прямоугольников:
function TwoRctsBoundingRct(constref rct1,rct2:TRect  ): TRect;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=Min2(rct1.left  ,rct2.left  );
      top   :=Min2(rct1.top   ,rct2.top   );
      right :=Max2(rct1.right ,rct2.right );
      bottom:=Max2(rct1.bottom,rct2.bottom);
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function TwoRctsBoundingRct(constref rct1,rct2:TPtRect): TPtRect; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=Min2(rct1.left  ,rct2.left  );
      top   :=Min2(rct1.top   ,rct2.top   );
      right :=Max2(rct1.right ,rct2.right );
      bottom:=Max2(rct1.bottom,rct2.bottom);
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}

// (Rectangle in Rectangle) Прямоугольник в прямоугольнике:
function IsRct1InRct2(constref rct1,                rct2:TRect  ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.left  >=rct2.left  ) and
          (rct1.top   >=rct2.top   ) and
          (rct1.right <=rct2.right ) and
          (rct1.bottom<=rct2.bottom);
end; {$endregion}
function IsRct1InRct2(constref rct1,                rct2:TPtRect): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.left  >=rct2.left  ) and
          (rct1.top   >=rct2.top   ) and
          (rct1.right <=rct2.right ) and
          (rct1.bottom<=rct2.bottom);
end; {$endregion}
function IsRct1InRct2(constref rct1:TRect; constref rct2:TPtRect): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.left  >=rct2.left  ) and
          (rct1.top   >=rct2.top   ) and
          (rct1.right <=rct2.right ) and
          (rct1.bottom<=rct2.bottom);
end; {$endregion}

// (Rectangle out of Rectangle) Прямоугольник вне прямоугольника:
function IsRct1OutOfRct2(constref rct1,                   rct2:TRect  ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.right <=rct2.left  ) or
          (rct1.bottom<=rct2.top   ) or
          (rct1.left  >=rct2.right ) or
          (rct1.top   >=rct2.bottom);
end; {$endregion}
function IsRct1OutOfRct2(constref rct1,                   rct2:TPtRect): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.right <=rct2.left  ) or
          (rct1.bottom<=rct2.top   ) or
          (rct1.left  >=rct2.right ) or
          (rct1.top   >=rct2.bottom);
end; {$endregion}
function IsRct1OutOfRct2(constref rct1:TRect   ; constref rct2:TPtRect): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.right <=rct2.left  ) or
          (rct1.bottom<=rct2.top   ) or
          (rct1.left  >=rct2.right ) or
          (rct1.top   >=rct2.bottom);
end; {$endregion}
function IsRct1OutOfRct2(constref rct1:TPtRectF; constref rct2:TPtRect): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.right <=rct2.left  ) or
          (rct1.bottom<=rct2.top   ) or
          (rct1.left  >=rct2.right ) or
          (rct1.top   >=rct2.bottom);
end; {$endregion}

// (Point in Rectangle) Точка в прямоугольнике:
function IsPtInRct(constref x,y,rct_dst_left,rct_dst_top,rct_dst_right,rct_dst_bottom:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct_dst_left  <x) and
          (rct_dst_top   <y) and
          (rct_dst_right >x) and
          (rct_dst_bottom>y);
end; {$endregion}
function IsPtInRct(constref x,y:integer; constref rct_dst:TRect                              ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct_dst.left  <x) and
          (rct_dst.top   <y) and
          (rct_dst.right >x) and
          (rct_dst.bottom>y);
end; {$endregion}
function IsPtInRct(constref x,y:integer; constref rct_dst:TPtRect                            ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct_dst.left  <x) and
          (rct_dst.top   <y) and
          (rct_dst.right >x) and
          (rct_dst.bottom>y);
end; {$endregion}
function IsPtInRct(constref pt:TPtPos  ; constref rct_dst:TRect                              ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct_dst.left  <pt.x) and
          (rct_dst.top   <pt.y) and
          (rct_dst.right >pt.x) and
          (rct_dst.bottom>pt.y);
end; {$endregion}
function IsPtInRct(constref pt:TPtPos  ; constref rct_dst:TPtRect                            ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct_dst.left  <pt.x) and
          (rct_dst.top   <pt.y) and
          (rct_dst.right >pt.x) and
          (rct_dst.bottom>pt.y);
end; {$endregion}
function IsPtInRct(constref pt:TPtPosF ; constref rct_dst:TRect                              ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct_dst.left  <pt.x) and
          (rct_dst.top   <pt.y) and
          (rct_dst.right >pt.x) and
          (rct_dst.bottom>pt.y);
end; {$endregion}
function IsPtInRct(constref pt:TPtPosF ; constref rct_dst:TPtRect                            ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct_dst.left  <pt.x) and
          (rct_dst.top   <pt.y) and
          (rct_dst.right >pt.x) and
          (rct_dst.bottom>pt.y);
end; {$endregion}
function IsPtInRct(constref pt:TPtPosF ; constref rct_dst:TPtRect; constref rad:integer      ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct_dst.left  <pt.x-rad) and
          (rct_dst.top   <pt.y-rad) and
          (rct_dst.right >pt.x+rad) and
          (rct_dst.bottom>pt.y+rad);
end; {$endregion}

// (Point in Circle) Точка в окружности:
function IsPtInCrc(constref x,y:integer; constref crc_dst:TCrPos           ; constref prec:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x-crc_dst.x)*(x-crc_dst.x)+(y-crc_dst.y)*(y-crc_dst.y)<=(crc_dst.r+prec)*(crc_dst.r+prec);
end; {$endregion}
function IsPtInCrc(constref x,y:integer; constref crc_dst:TCrPosF          ; constref prec:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x-crc_dst.x)*(x-crc_dst.x)+(y-crc_dst.y)*(y-crc_dst.y)<=(crc_dst.r+prec)*(crc_dst.r+prec);
end; {$endregion}
function IsPtInCrc(constref x,y:double ; constref crc_dst:TCrPosF          ; constref prec:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x-crc_dst.x)*(x-crc_dst.x)+(y-crc_dst.y)*(y-crc_dst.y)<=(crc_dst.r+prec)*(crc_dst.r+prec);
end; {$endregion}
function IsPtInCrc(constref x,y:double ; constref crc_x,crc_y,crc_r:integer; constref prec:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x-crc_x)*(x-crc_x)+(y-crc_y)*(y-crc_y)<=(crc_r+prec)*(crc_r+prec);
end; {$endregion}
function IsPtInCrc(constref x,y:integer; constref crc_x,crc_y,crc_r:integer; constref prec:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x-crc_x)*(x-crc_x)+(y-crc_y)*(y-crc_y)<=(crc_r+prec)*(crc_r+prec);
end; {$endregion}

// (Distance Between Two Points) Расстояние между двумя точками:
function PtDist   (constref x0,y0,x1,y1:integer): double ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=sqrt((x1-x0)*(x1-x0)+(y1-y0)*(y1-y0));
end; {$endregion}
function PtDist   (constref x0,y0,x1,y1:double ): double ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=sqrt((x1-x0)*(x1-x0)+(y1-y0)*(y1-y0));
end; {$endregion}
function PtDistSqr(constref x0,y0,x1,y1:integer): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x1-x0)*(x1-x0)+(y1-y0)*(y1-y0);
end; {$endregion}
function PtDistSqr(constref x0,y0,x1,y1:integer): double ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x1-x0)*(x1-x0)+(y1-y0)*(y1-y0);
end; {$endregion}
function PtDistSqr(constref x0,y0,x1,y1:double ): double ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x1-x0)*(x1-x0)+(y1-y0)*(y1-y0);
end; {$endregion}

// (Line-Line Intersection Point) Точка пересечение двух линий:
function LineLineIntPt(constref x0,y0,x1,y1,v0,w0,v1,w1:double):TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=-((x1-x0)*(v1*w0-v0*w1)-(v1-v0)*(x1*y0-x0*y1))/((x1-x0)*(w1-w0)-(v1-v0)*(y1-y0));
  Result.y:= ((y1-y0)*Result.x     +        (x1*y0-x0*y1))/ (x1-x0);
end; {$endregion}

// (Line-Circle Intersection Point) Точка пересечение линии и окружности:
function LineCrcIntPt(constref x0,y0,x1,y1:double; constref crc_dst:TCrPosF): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k,b,g,s,h: double;
begin
  k:=(   y1-   y0)/(x1-x0);
  b:=(x1*y0-x0*y1)/(x1-x0);
  g:=b-crc_dst.y;
  h:=1+k*k;
  s:=sqrt((g*k-crc_dst.x)*(g*k-crc_dst.x)-h*(g*g+crc_dst.x*crc_dst.x-crc_dst.r*crc_dst.r));
  with Result do
    begin
      x0:=(crc_dst.x-g*k-s)/h;
      x1:=(crc_dst.x-g*k+s)/h;
      y0:=k*x0+b;
      y1:=k*x1+b;
    end;
end; {$endregion}
function LineCrcIntPt(constref x0,y0,x1,y1:double; constref x,y,r  :double ): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k,b,g,s,h: double;
begin
  k:=(   y1-   y0)/(x1-x0);
  b:=(x1*y0-x0*y1)/(x1-x0);
  g:=b-y;
  h:=1+k*k;
  s:=sqrt((g*k-x)*(g*k-x)-h*(g*g+x*x-r*r));
  with Result do
    begin
      x0:=(x-g*k-s)/h;
      x1:=(x-g*k+s)/h;
      y0:=k*x0+b;
      y1:=k*x1+b;
    end;
end; {$endregion}
function CrcPosF     (                             constref x,y,r  :double ): TCrPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=x;
  Result.y:=y;
  Result.r:=r;
end; {$endregion}

// (Rectangle-Circle Intersection) Пересечение прямоугольника и окружности:
function RctCrcInt(constref rct:TRect  ; constref x,y,r:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=False;
  if (rct.width =0) then
    Exit;
  if (rct.height=0) then
    Exit;
  with rct do
    Result:=IsPtInRct(x,y,left-r,top   ,right+r,bottom  ) or
            IsPtInRct(x,y,left  ,top-r ,right  ,bottom+r) or
            IsPtInCrc(x,y,left  ,top   ,r,0) or
            IsPtInCrc(x,y,left  ,bottom,r,0) or
            IsPtInCrc(x,y,right ,top   ,r,0) or
            IsPtInCrc(x,y,right ,bottom,r,0);
end; {$endregion}
function RctCrcInt(constref rct:TPtRect; constref x,y,r:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=False;
  if (rct.width =0) then
    Exit;
  if (rct.height=0) then
    Exit;
  with rct do
    Result:=IsPtInRct(x,y,left-r,top   ,right+r,bottom  ) or
            IsPtInRct(x,y,left  ,top-r ,right  ,bottom+r) or
            IsPtInCrc(x,y,left  ,top   ,r,0) or
            IsPtInCrc(x,y,left  ,bottom,r,0) or
            IsPtInCrc(x,y,right ,top   ,r,0) or
            IsPtInCrc(x,y,right ,bottom,r,0);
end; {$endregion}

// (Angle Between Two Connected Segments,(x1,y1) - Connection Point) Угол между двумя соединенными сегментами,(x1,y1) - точка соединения:
function Angle1(constref x0,y0,x1,y1,x2,y2:double): double ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=     ONE_DIV_BY_FULL_ROT*ArcCos(((x0-x1)*(x2-x1)+(y0-y1)*(y2-y1))/Sqrt((Sqr(x0-x1)+Sqr(y0-y1))*(Sqr(x2-x1)+Sqr(y2-y1))));
end; {$endregion}
function Angle2(constref x0,y0,x1,y1,x2,y2:double): double ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=180-(ONE_DIV_BY_FULL_ROT*ArcCos(((x0-x1)*(x2-x1)+(y0-y1)*(y2-y1))/Sqrt((Sqr(x0-x1)+Sqr(y0-y1))*(Sqr(x2-x1)+Sqr(y2-y1)))));
end; {$endregion}

// (Parallax) Параллакс:
function DistToObj(constref parallax_shift:TColor): double; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
{$endregion}



(******************************* Array Operation ******************************) {$region -fold}

// Arrays Addition:
procedure ArrAdd(constref arr_src1,arr_src2:T1Byte1Arr;                              var      arr_dst:TColorArr ; constref arr_dst_width,arr_dst_height:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PByte;
  arr_src2_ptr: PByte;
  arr_dst_ptr : PInteger;
  i,w_h_mul   : integer;
begin
  w_h_mul     :=arr_dst_width*arr_dst_height;
  SetLength(arr_dst,w_h_mul);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to w_h_mul-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^+arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrAdd(constref arr_src1,arr_src2:TDublArr  ;                              var      arr_dst:TDublArr  ; constref arr_dst_width,arr_dst_height:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PDouble;
  arr_src2_ptr: PDouble;
  arr_dst_ptr : PDouble;
  i,w_h_mul   : integer;
begin
  w_h_mul     :=arr_dst_width*arr_dst_height;
  SetLength(arr_dst,w_h_mul);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to w_h_mul-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^+arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrAdd(constref arr_src1,arr_src2:TColorArr ;                              var      arr_dst:TColorArr ; constref arr_dst_width,arr_dst_height:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PInteger;
  arr_src2_ptr: PInteger;
  arr_dst_ptr : PInteger;
  i,w_h_mul   : integer;
begin
  w_h_mul     :=arr_dst_width*arr_dst_height;
  SetLength(arr_dst,w_h_mul);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to w_h_mul-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^+arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrAdd(constref arr_src1,arr_src2:TWordArr  ;                              var      arr_dst:TWordArr  ; constref arr_dst_width,arr_dst_height:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PWord;
  arr_src2_ptr: PWord;
  arr_dst_ptr : PWord;
  i,w_h_mul   : integer;
begin
  w_h_mul     :=arr_dst_width*arr_dst_height;
  SetLength(arr_dst,w_h_mul);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to w_h_mul-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^+arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrAdd(constref arr_src1,arr_src2:T1Byte1Arr;                              var      arr_dst:T1Byte1Arr; constref arr_dst_width,arr_dst_height:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PByte;
  arr_src2_ptr: PByte;
  arr_dst_ptr : PByte;
  i,w_h_mul   : integer;
begin
  w_h_mul     :=arr_dst_width*arr_dst_height;
  SetLength(arr_dst,w_h_mul);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to w_h_mul-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^+arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrAdd(constref arr_src1         :TColorArr ; constref arr_src2:T1Byte1Arr;                             constref         width,        height:TColor; constref val:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PInteger;
  arr_src2_ptr: PByte;
  i           : integer;
begin
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  for i:=0 to width*height-1 do
    begin
      if (arr_src2_ptr^<>0) then
        arr_src1_ptr^+=val;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
    end;
end; {$endregion}
procedure ArrAdd(constref arr_src1         :T1Byte1Arr; constref arr_src2:T2ByteArr; constref arr_dst:TColorArr ; constref arr_dst_width,arr_dst_height:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
 {arr_dst_ptr : PInteger;
  arr_src1_ptr: PByte;
  arr_src2_ptr: PByte;}
 {ptr10,ptr11 : PInteger;
  ptr20,ptr21 : PByte;}
  x,y,v       : integer;
begin
  v:=0;
  for y:=0 to arr_dst_height-1 do
    begin
      for x:=0 to arr_dst_width-1 do
        arr_dst[x+v]:=arr_src1[x+v]+arr_src2[x,y];
      Inc(v,arr_dst_width);
    end;
 {for x:=0 to arr_dst_width-1 do
    begin
      arr_dst_ptr :=@arr_dst [x];
      arr_src1_ptr:=@arr_src1[x];
      arr_src2_ptr:=@arr_src2[x,0];
      for y:=0 to arr_dst_height-1 do
        begin
          arr_dst_ptr^:=arr_src1_ptr^+arr_src2_ptr^;
          Inc(arr_dst_ptr ,arr_dst_width);
          Inc(arr_src1_ptr,arr_dst_width);
          Inc(arr_src2_ptr);
        end;
    end;}
 {ptr11:=@arr_dst [0];
  ptr21:=@arr_src1[0];
  for x:=0 to arr_dst_width-1 do
    begin
      ptr10:=ptr11;
      ptr20:=ptr21;
      arr_src2_ptr:=@arr_src2[x,0];
      for y:=0 to arr_dst_height-1 do
        begin
          ptr10^:=ptr20^+arr_src2_ptr^;
          Inc(ptr10,arr_dst_width);
          Inc(ptr20,arr_dst_width);
          Inc(arr_src2_ptr);
        end;
      Inc(ptr11);
      Inc(ptr21);
    end;}
end; {$endregion}
procedure ArrAdd(constref arr_src1         :T1Byte1Arr; constref arr_src2:T2ByteArr; constref arr_dst:T1Byte1Arr; constref arr_dst_width,arr_dst_height:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,v: integer;
begin
  v:=0;
  Prefetch(arr_dst );
  Prefetch(arr_src1);
  Prefetch(arr_src2);
  for y:=0 to arr_dst_height-1 do
    begin
      for x:=0 to arr_dst_width-1 do
        arr_dst[x+v]:=arr_src1[x+v]+arr_src2[x,y];
      Inc(v,arr_dst_width);
    end;
end; {$endregion}
procedure ArrAdd(var      arr_src1         :T1Byte1Arr; constref arr_src2:T2ByteArr;                              constref arr_dst_width,arr_dst_height:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,v: integer;
begin
  v:=0;
  Prefetch(arr_src1);
  Prefetch(arr_src2);
  for y:=0 to arr_dst_height-1 do
    begin
      for x:=0 to arr_dst_width-1 do
        arr_src1[x+v]+=arr_src2[x,y];
      Inc(v,arr_dst_width);
    end;
end; {$endregion}
procedure ArrAdd(var      arr_src1         :T1Byte1Arr; constref arr_src2:T2ByteArr; constref rct_dst:TPtrect   ; constref arr_dst_width,arr_dst_height:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,v: integer;
begin
  v :=arr_dst_width*rct_dst.top;
  Prefetch(arr_src1);
  Prefetch(arr_src2);
  for y:=rct_dst.top to rct_dst.bottom-1 do
    begin
      for x:=rct_dst.left to rct_dst.right-1 do
        arr_src1[x+v]+=arr_src2[x,y];
      Inc(v,arr_dst_width);
    end;
end; {$endregion}

// Arrays Subtraction:
procedure ArrSub(constref arr_src1,arr_src2:TDublArr  ; var      arr_dst:TDublArr  ; constref arr_dst_width,arr_dst_height:TColor);      {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PDouble;
  arr_src2_ptr: PDouble;
  arr_dst_ptr : PDouble;
  i           : integer;
begin
  SetLength(arr_dst,arr_dst_width*arr_dst_height);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to arr_dst_width*arr_dst_height-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^-arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrSub(constref arr_src1,arr_src2:TIntrArr  ; var      arr_dst:TIntrArr  ; constref arr_dst_width,arr_dst_height:TColor);      {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PInteger;
  arr_src2_ptr: PInteger;
  arr_dst_ptr : PInteger;
  i           : integer;
begin
  SetLength(arr_dst,arr_dst_width*arr_dst_height);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to arr_dst_width*arr_dst_height-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^-arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrSub(constref arr_src1,arr_src2:TColorArr ; var      arr_dst:TColorArr ; constref arr_dst_width,arr_dst_height:TColor);      {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PLongWord;
  arr_src2_ptr: PLongWord;
  arr_dst_ptr : PLongWord;
  i           : integer;
begin
  SetLength(arr_dst,arr_dst_width*arr_dst_height);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to arr_dst_width*arr_dst_height-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^-arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrSub(constref arr_src1,arr_src2:TWordArr  ; var      arr_dst:TWordArr  ; constref arr_dst_width,arr_dst_height:TColor);      {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PWord;
  arr_src2_ptr: PWord;
  arr_dst_ptr : PWord;
  i           : integer;
begin
  SetLength(arr_dst,arr_dst_width*arr_dst_height);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to arr_dst_width*arr_dst_height-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^-arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrSub(constref arr_src1,arr_src2:T1Byte1Arr; var      arr_dst:T1Byte1Arr; constref arr_dst_width,arr_dst_height:TColor);      {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PByte;
  arr_src2_ptr: PByte;
  arr_dst_ptr : PByte;
  i           : integer;
begin
  SetLength(arr_dst,arr_dst_width*arr_dst_height);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to arr_dst_width*arr_dst_height-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^-arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrSub(constref arr_src          :T1Byte1Arr; constref arr_dst:TIntrArr  ; constref width,height:TColor; constref val:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_dst_ptr: PInteger;
  arr_src_ptr: PByte;
  i           : integer;
begin
  arr_dst_ptr:=Unaligned(@arr_dst[0]);
  arr_src_ptr:=Unaligned(@arr_src[0]);
  for i:=0 to width*height-1 do
    begin
      if (arr_src_ptr^<>0) then
        arr_dst_ptr^-=val;
      Inc(arr_dst_ptr);
      Inc(arr_src_ptr);
    end;
end; {$endregion}

// 2D Array to 1D Array:
procedure Arr2DTo1D(constref arr_src:T2ByteArr; var arr_dst:T1Byte1Arr; constref arr_src_width,arr_src_height:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr: PByte;
  arr_dst_ptr: PByte;
  x,y        : integer;
begin
  SetLength(arr_dst,arr_src_width*arr_src_height);
  for x:=0 to arr_src_width-1 do
    begin
      arr_src_ptr:=Unaligned(@arr_src[x,0]);
      arr_dst_ptr:=Unaligned(@arr_dst[x  ]);
      for y:=0 to arr_src_height-1 do
        begin
          arr_dst_ptr^:=arr_src_ptr^;
          Inc(arr_dst_ptr,arr_src_width);
          Inc(arr_src_ptr);
        end;
    end;
end; {$endregion}

// Clear Arrays:
procedure BmpClear(bmp:Graphics.TBitmap);                                                                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  //PatBlt(bmp.Canvas.Handle,0,0,bmp.width,bmp.height,WHITENESS);
  bmp.Canvas.Clear;
end; {$endregion}
procedure ArrClear(    arr1_ptr:PInteger;   constref rct_dst:TPtRect; constref arr_width:TColor; constref val:TColor=0); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to rct_dst.height-1 do
    begin
      FillByte(arr1_ptr^,rct_dst.width,val);
      Inc(arr1_ptr,arr_width);
    end;
end; {$endregion}
procedure ArrClear(var arr0    :T1Byte1Arr; constref rct_dst:TPtRect; constref arr_width:TColor; constref val:byte  =0); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p: PByte;
  i: integer;
begin
  p:=Unaligned(@arr0[rct_dst.left+arr_width*rct_dst.top]);
  for i:=0 to rct_dst.height-1 do
    begin
      FillByte(p^,rct_dst.width,val);
      Inc(p,arr_width);
    end;
end; {$endregion}
procedure ArrClear(var arr1    :TColorArr;  constref rct_dst:TPtRect; constref arr_width:TColor; constref val:TColor=0); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p: PInteger;
  i: integer;
begin
  p:=Unaligned(@arr1[rct_dst.left+arr_width*rct_dst.top]);
  for i:=0 to rct_dst.height-1 do
    begin
      FillDWord(p^,rct_dst.width,val);
      Inc(p,arr_width);
    end;
end; {$endregion}
procedure ArrClear(var arr1_ptr:PInteger;   constref rct_dst:TPtRect; constref arr_width:TColor; f1,f2,f3,f4:integer  ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p: PInteger;
  i: integer;
begin
  p:=Unaligned(@arr1_ptr[0{rct_dst.left+arr_width*rct_dst.top}]);
  for i:=0 to rct_dst.height-1 do
    begin
      FillDWord(p^,arr_width,0);
      Inc(p,arr_width);
    end;
end; {$endregion}
procedure ArrClear(var arr2    :T2ByteArr;  constref rct_dst:TPtRect;                            constref val:byte  =0); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to rct_dst.width-1 do
    FillByte(arr2[rct_dst.left+i,rct_dst.top],rct_dst.height,val);
end; {$endregion}
procedure ArrClear(var arr3    :TPtPos2Arr; constref rct_dst:TPtRect; constref arr_width:TColor                       ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p      : PPtPos2;
  i,j    : integer;
  d_width: integer;
begin
  d_width:=arr_width-rct_dst.width;
  p      :=Unaligned(@arr3[rct_dst.left+arr_width*rct_dst.top]);
  for j:=0 to rct_dst.height-1 do
    begin
      for i:=0 to rct_dst.width-1 do
        begin
          if (p^.obj_ind<>-1) then
            p^.SetEqual1(p^,Default(TPtPos2));
          Inc(p);
        end;
      Inc(p,d_width);
    end;
end; {$endregion}

// Clear Alpha Channel:
function  ArrClear(    arr1_ptr:PInteger;   constref rct_dst:TPtRect; constref arr_width:TColor; constref val:TColor=0; b:boolean=False):byte; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p  : PInteger;
  x,y: integer;
label
  emd;
begin
  Result:=00000000000000000000000000000000000000000000000000000000;
  p     :=Unaligned(@arr1_ptr[rct_dst.left+arr_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          (p+x)^:=(p+x)^<<8>>8;
          {if (((p+x)^>>24)<>0) then
            begin
              Result:=1;
              goto emd;
            end;}
        end;
      Inc(p,arr_width);
    end;
  emd:
end; {$endregion}

// Fill Arrays On Bitmap:
procedure ArrFillProc00(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
//pixel_ptr0 : PInteger;
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(Blue(col),Green(col),Red(col));
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
//pixel_ptr0 :=pixel_ptr;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
  {chess order}
  {for y:=0 to Trunc(rct_dst.height/2)-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
          if Odd(PInteger(pixel_ptr+x+1)-PInteger(pixel_ptr0)) then
            (pixel_ptr+x)^:=pix_color;
      Inc(pixel_ptr  ,bmp_width);
      Inc(f_arr_0_ptr,bmp_width);
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
          if Odd(PInteger(pixel_ptr+x)-PInteger(pixel_ptr0)) then
            (pixel_ptr+x)^:=pix_color;
      Inc(pixel_ptr  ,bmp_width);
      Inc(f_arr_0_ptr,bmp_width);
    end;}
end; {$endregion}
procedure ArrFillProc01(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
  r,g,b      : byte;
begin
  r          :=Red  (col);
  g          :=Green(col);
  b          :=Blue (col);
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:={Additive(pixel_ptr^,r,g,b);} RGB(Min(Red  (pixel_ptr^)+b,255),
                                                          Min(Green(pixel_ptr^)+g,255),
                                                          Min(Blue (pixel_ptr^)+r,255));
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFillProc02(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
  r,g,b      : byte;
    alpha1   : byte;
  d_alpha1   : byte;
begin
  r          :=Red  (col);
  g          :=Green(col);
  b          :=Blue (col);
  alpha1     :=alpha;
  d_alpha1   :=255-alpha1;
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:=AlphaBlend(pixel_ptr^,r,g,b,d_alpha1,alpha1);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFillProc03(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:=Inverse(pixel_ptr^);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFillProc04(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:=Highlight(pixel_ptr^);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFillProc05(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:=Darken(pixel_ptr^);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFillProc06(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:=GrayscaleR(pixel_ptr^);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFillProc07(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:=GrayscaleG(pixel_ptr^);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFillProc08(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:=GrayscaleB(pixel_ptr^);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFillProc09(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(Blue(col),Green(col),Red(col));
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) and Odd(pixel_ptr^) then
            pixel_ptr^:=pix_color;
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFillProc10(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(Blue(col),Green(col),Red(col));
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFillProc11(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(Blue(col),Green(col),Red(col));
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFillProc12(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(Blue(col),Green(col),Red(col));
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFillProc13(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(Blue(col),Green(col),Red(col));
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFillProc14(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(Blue(col),Green(col),Red(col));
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFillProc15(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(Blue(col),Green(col),Red(col));
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFillProc16(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(Blue(col),Green(col),Red(col));
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFillProc17(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(Blue(col),Green(col),Red(col));
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFillProc18(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(Blue(col),Green(col),Red(col));
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFillProc19(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(Blue(col),Green(col),Red(col));
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFillProc20(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(Blue(col),Green(col),Red(col));
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFillProc21(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(Blue(col),Green(col),Red(col));
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFillProc22(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(Blue(col),Green(col),Red(col));
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFillProc23(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(Blue(col),Green(col),Red(col));
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFillProc24(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(Blue(col),Green(col),Red(col));
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFillProc25(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(Blue(col),Green(col),Red(col));
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}

//
procedure ArrFill     (constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; b:boolean); {$region -fold}
var
  pixel_ptr: PInteger;
  arr0_ptr : PByte;
  x,y      : integer;
begin
  pixel_ptr:=Unaligned(@bmp_ptr[0]);
  arr0_ptr :=Unaligned(@arr0   [0]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if ((arr0_ptr +x)^=1{<>0}) then
              (pixel_ptr+x+10+bmp_width*10)^:=clGreen
          else
          if ((arr0_ptr +x)^=2{<>0}) then
            (pixel_ptr+x+10+bmp_width*10)^:=clBlue
          else
          if ((arr0_ptr +x)^>2{<>0}) then
            (pixel_ptr+x+10+bmp_width*10)^:=clRed
        end;
      Inc(arr0_ptr ,bmp_width);
      Inc(pixel_ptr,bmp_width);
    end;
end; {$endregion}

procedure ArrFill     (constref arr0:TColorArr ; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor); {$region -fold}
var
  pixel_ptr: PInteger;
  arr0_ptr : PInteger;
  x,y      : integer;
  pix_color: TColor;
begin
  pix_color:=RGB(Blue(col),Green(col),Red(col));
  pixel_ptr:=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  arr0_ptr :=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((arr0_ptr +x)^ <>0) then
            (pixel_ptr+x)^:=pix_color;
      Inc(arr0_ptr ,bmp_width);
      Inc(pixel_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFill     (constref arr0:TPtPos2Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PPtPos2;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^.obj_ind<>-1) then
            pixel_ptr^:=col;
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFill     (constref arr0:TPtPos2Arr;                            constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect);                      {$region -fold}
var
  f_arr_0_ptr: PPtPos2;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  f_arr_0_ptr:=Unaligned(@arr0[rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          f_arr_0_ptr^.obj_ind:=-1;
          Inc(f_arr_0_ptr);
        end;
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFill     (constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect);                      {$region -fold}
var
  pixel_ptr: PInteger;
  d_width  : integer;
  x,y      : integer;
begin
  d_width  :=bmp_width-rct_dst.width;
  pixel_ptr:=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (pixel_ptr^<>0) then
            arr0[pixel_ptr^-1]:=1;
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFillTest (constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
begin
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^=1) then
          (pixel_ptr+x)^:=col;
      Inc (pixel_ptr  ,bmp_width);
      Inc (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFillTest (constref arr0:TIntrArr;   constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PInteger;
  x,y        : integer;
begin
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^=1) then
          (pixel_ptr+x)^:=col;
      Inc (pixel_ptr  ,bmp_width);
      Inc (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}

// Non-Zero Items Count:
function ArrNzItCnt(constref arr:T1Byte1Arr                                                                                    ): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_ptr: PByte;
  i      : integer;
begin
  Result :=0;
  arr_ptr:=Unaligned(@arr[0]);
  for i:=0 to Length(arr)-1 do
    if ((arr_ptr+i)^=1) then
      Inc(Result);
end; {$endregion}
function ArrNzItCnt(constref bmp_dst_ptr:PInteger; constref rct_dst:TPtRect; constref bmp_dst_width:TColor; constref col:TColor): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  Result       :=0;
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((dst_pixel_ptr+x)^=col) then
          Inc(Result);
      Inc (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
function ArrNzItCnt(constref arr1_ptr:PShortInt;   constref arr2_ptr:PByte;  constref length:integer                           ): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=0;
  for i:=0 to length-1 do
    if ((arr1_ptr+i)^=0) and
       ((arr2_ptr+i)^=1) then
      Inc(Result);
end; {$endregion}
function ArrNzItCnt(constref arr1_ptr:PShortInt;                             constref length:integer; b:boolean                ): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=0;
  for i:=0 to length-1 do
    if ((arr1_ptr+i)^=0) then
      Inc(Result);
end; {$endregion}
function ArrNzItCnt(constref arr:T1Byte1Arr;       constref max_arr_it_val:TColor=MAXBYTE                                      ): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  n,m: TColor;
  i  : integer;
begin
  Result:=0;
  {n     :=1+Trunc(ln(Double(max_arr_it_val-1))/ln(2)); // instead of max_arr_it_val, you can substitute any other number in the interval [2**Trunc(ln(Double(max_arr_it_val))/ln(2))+1;+inf)
  m     :=1<<n-1;}
  for i:=0 to Length(arr)-1 do
    Inc(Result,(arr[i]+NZ_ITEM_COEFF20{m})>>NZ_ITEM_COEFF10{n}); // Inc(Result,Ord(arr[i]<>0));// the less array is sparse the faster it is
                                                                                               // as compared with:
                                                                                               // "if arr[i]<>0 then
                                                                                               //    Inc(Result);"
end; {$endregion}
function ArrNzItCnt(constref arr:TWordArr;         constref max_arr_it_val:TColor=MAXWORD                                      ): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  n,m: TColor;
  i  : integer;
begin
  Result:=0;
  {n     :=1+Trunc(ln(Double(max_arr_it_val-1))/ln(2)); // instead of max_arr_it_val, you can substitute any other number in the interval [2**Trunc(ln(Double(max_arr_it_val))/ln(2))+1;+inf)
  m     :=1<<n-1;}
  for i:=0 to Length(arr)-1 do
    Inc(Result,(arr[i]+NZ_ITEM_COEFF21{m})>>NZ_ITEM_COEFF11{n}); // Inc(Result,Ord(arr[i]<>0));// the less array is sparse the faster it is
                                                                                               // as compared with:
                                                                                               // "if arr[i]<>0 then
                                                                                               //    Inc(Result);"
end; {$endregion}
function ArrNzItCnt(constref arr:TColorArr;        constref max_arr_it_val:TColor=MAXDWORD                                     ): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  n,m: TColor;
  i  : integer;
begin
  Result:=0;
  {n     :=1+Trunc(ln(Double(max_arr_it_val-1))/ln(2)); // instead of max_arr_it_val, you can substitute any other number in the interval [2**Trunc(ln(Double(max_arr_it_val))/ln(2))+1;+inf)
  m     :=1<<n-1;}
  for i:=0 to Length(arr)-1 do
    Inc(Result,(arr[i]+NZ_ITEM_COEFF22{m})>>NZ_ITEM_COEFF12{n}); // Inc(Result,Ord(arr[i]<>0));// the less array is sparse the faster it is
                                                                                               // as compared with:
                                                                                               // "if arr[i]<>0 then
                                                                                               //    Inc(Result);"
end; {$endregion}

// Create Array With "Visible" Items:
procedure ArrNzItCrt(constref arr1_src_ptr:PShortInt; constref arr2_src_ptr:PByte; arr_dst_ptr:PColor; constref length1,length2:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_dst_ptr0: PColor;
  i           : integer;
begin
  arr_dst_ptr0:=arr_dst_ptr;
  for i:=0 to length1-1 do
    if ((arr1_src_ptr+i)^=0) and
       ((arr2_src_ptr+i)^=1) then
      begin
        arr_dst_ptr^:=i;
        Inc(arr_dst_ptr);
        if (arr_dst_ptr-arr_dst_ptr0=length2) then
          Break;
      end;
end; {$endregion}
procedure ArrNzItCrt(constref arr1_src_ptr:PShortInt;                              arr_dst_ptr:PColor; constref length1,length2:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_dst_ptr0: PColor;
  i           : integer;
begin
  arr_dst_ptr0:=arr_dst_ptr;
  for i:=0 to length1-1 do
    if ((arr1_src_ptr+i)^=0) then
      begin
        arr_dst_ptr^:=i;
        Inc(arr_dst_ptr);
        if (arr_dst_ptr-arr_dst_ptr0=length2) then
          Break;
      end;
end; {$endregion}

// Copy One Array To Another:
procedure ArrToArr1(arr_src_ptr:PPtPosF; arr_dst_ptr:PPtPosF; pts_cnt:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to pts_cnt-1 do
    (arr_dst_ptr+i)^:=(arr_src_ptr+i)^;
end; {$endregion}
procedure ArrToArr2(arr_src_ptr:PPtPosF; arr_dst_ptr:PPtPosF; pts_cnt:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to pts_cnt-1 do
    (arr_src_ptr+i)^:=(arr_dst_ptr+i)^;
end; {$endregion}
{$endregion}



(******************************** Linked Lists ********************************) {$region -fold}

procedure AddListItem(constref pt_x   :integer;    var first_item,p1,p2:PIList); {$region -fold}
begin
  New(p1);
  New(p1^.x_ptr);
  p1^.x_ptr^:=pt_x;
  if (first_item=Nil) then
    first_item:=p1
  else
    p2^.next_item:=p1;
  p2:=p1;
end; {$endregion}
procedure AddListItem(constref pt     :TPtPosF;    var first_item,p1,p2:PFList); {$region -fold}
begin
  New(p1);
  p1^.x:=pt.x;
  p1^.y:=pt.y;
  if (first_item=Nil) then
    first_item:=p1
  else
    p2^.next_item:=p1;
  p2:=p1;
end; {$endregion}
procedure ArrToList1 (constref arr_src:TIntrArr;   var first_item,p1,p2:PIList); {$region -fold}
var
  arr_src_ptr:^integer;
  i          : integer;
begin
  arr_src_ptr:=@arr_src[0];
  first_item :=Nil;
  for i:=0 to Length(arr_src)-1 do
    begin
      New(p1);
      p1^.x_ptr:=arr_src_ptr;
      if (first_item=Nil) then
        first_item:=p1
      else
        p2^.next_item:=p1;
      p2:=p1;
      Inc(arr_src_ptr);
    end;
  p2^.next_item:=Nil;
end; {$endregion}
procedure ArrToList2 (constref arr_src:TIntrArr;   var first_item,p1,p2:PIList); {$region -fold}
var
  arr_src_ptr:^integer;
  i          : integer;
begin
  arr_src_ptr:=@arr_src[0];
  first_item :=Nil;
  for i:=0 to Length(arr_src)-1 do
    begin
      New(p1);
      New(p1^.x_ptr);
      p1^.x_ptr^:=arr_src_ptr^;
      if (first_item=Nil) then
        first_item:=p1
      else
        p2^.next_item:=p1;
      p2:=p1;
      Inc(arr_src_ptr);
    end;
  p2^.next_item:=Nil;
end; {$endregion}
procedure ListToArr  (var      arr_dst:TIntrArr;   var first_item,p1,p2:PIList); {$region -fold}
var
  arr_dst_ptr:^integer;
  i          : integer;
begin
  arr_dst_ptr:=@arr_dst[0];
  p1         :=first_item;
  for i:=0 to Length(arr_dst)-1 do
    begin
      arr_dst_ptr^:=p1^.x_ptr^;
      p1          :=p1^.next_item;
      Inc(arr_dst_ptr);
    end;
  p2^.next_item:=Nil;
end; {$endregion}
procedure ListToArr  (var      arr_dst:TPtPosFArr; var first_item,p1,p2:PFList); {$region -fold}
var
  arr_dst_ptr: PPtPosF;
  i          : integer;
begin
  arr_dst_ptr:=@arr_dst[0];
  p1         :=first_item;
  for i:=0 to Length(arr_dst)-1 do
    begin
      arr_dst_ptr^.x:=p1^.x;
      arr_dst_ptr^.y:=p1^.y;
      p1            :=p1^.next_item;
      Inc(arr_dst_ptr);
    end;
  p2^.next_item:=Nil;
end; {$endregion}
procedure FreeList1 (                              var first_item,p1,p2:PIList); {$region -fold}
var
  t:PIList;
begin
  p1:=first_item;
  while (p1<>Nil) do
    begin
      t :=p1;
      p1:=p1^.next_item;
      Dispose(t);
    end;
  first_item:=Nil;
  p1        :=Nil;
  p2        :=Nil;
end; {$endregion}
procedure FreeList2 (                              var first_item,p1,p2:PFList); {$region -fold}
var
  t:PFList;
begin
  p1:=first_item;
  while (p1<>Nil) do
    begin
      t :=p1;
      p1:=p1^.next_item;
      Dispose(t);
    end;
  first_item:=Nil;
  p1        :=Nil;
  p2        :=Nil;
end; {$endregion}
{
type

  T1IntrArr=array of integer;

  PCnvlList=^TCnvlList;
  TCnvlList=packed record
    next_item: PCnvlList;
    arr_item : PInteger;
  end;

var
  first_item,p1,p2: PCnvlList;
  arr,arr2        : array of integer;


procedure CreateArray(var arr_src1,arr_src2:T1IntrArr); {$region -fold}
begin

  SetLength(arr_src1,8);
  arr_src1[0]:=0;
  arr_src1[1]:=3;
  arr_src1[2]:=0;
  arr_src1[3]:=1;
  arr_src1[4]:=3;
  arr_src1[5]:=2;
  arr_src1[6]:=1;
  arr_src1[7]:=1;

  SetLength(arr_src2,8);
  arr_src2[0]:=2;
  arr_src2[1]:=5;
  arr_src2[2]:=1;
  arr_src2[3]:=0;
  arr_src2[4]:=7;
  arr_src2[5]:=3;
  arr_src2[6]:=1;
  arr_src2[7]:=5;

end; {$endregion}

procedure ShowArr(constref arr_src1,arr_src2:T1IntrArr; constref arr_src_length:integer); {$region -fold}
var
  i: integer;
begin
  Writeln;
  for i:=0 to arr_src_length-1 do
    Write(arr_src1[i],' ');
  Writeln('Done');
  for i:=0 to arr_src_length-1 do
    Write(arr_src2[i],' ');
  Writeln('Done');
end; {$endregion}

procedure ArrToList1(constref arr_src:T1IntrArr; constref arr_src_length:integer); {$region -fold}
var
  arr_src_ptr:^integer;
  i          : integer;
begin
  arr_src_ptr:=@arr_src[0];
  first_item :=Nil;
  for i:=0 to arr_src_length-1 do
    begin
      New(p1);
      p1^.arr_item:=arr_src_ptr;
      if (first_item=Nil) then
        first_item:=p1
      else
        p2^.next_item:=p1;
      p2:=p1;
      Inc(arr_src_ptr);
    end;
  p2^.next_item:=Nil;
end; {$endregion}
procedure ArrToList2(constref arr_src:T1IntrArr; constref arr_src_length:integer); {$region -fold}
var
  arr_src_ptr:^integer;
  i          : integer;
begin
  arr_src_ptr:=@arr_src[0];
  first_item :=Nil;
  for i:=0 to arr_src_length-1 do
    begin
      New(p1);
      New(p1^.arr_item);
      p1^.arr_item^:=arr_src_ptr^;
      if (first_item=Nil) then
        first_item:=p1
      else
        p2^.next_item:=p1;
      p2:=p1;
      Inc(arr_src_ptr);
    end;
  p2^.next_item:=Nil;
end; {$endregion}

procedure ListToArr(var arr_src:T1IntrArr; constref arr_src_length:integer); {$region -fold}
var
  arr_src_ptr:^integer;
  i          : integer;
begin
  arr_src_ptr:=@arr_src[0];
  p1:=first_item;
  for i:=0 to arr_src_length-1 do
    begin
      arr_src_ptr^:=p1^.arr_item^;
      p1:=p1^.next_item;
      Inc(arr_src_ptr);
    end;
end; {$endregion}

procedure ShowList; {$region -fold}
var
  v_ptr:^integer;
  i    : integer;
begin
  Writeln;
  p1:=first_item;
  {v_ptr:=p1^.arr_item;
  for i:=0 to 7{Length(arr)-1} do
    Write((v_ptr+i)^,' ');}
  while (p1<>Nil) do
    begin
      Write({Integer(@p1^.arr_item)}p1^.arr_item^,' ');
      p1:=p1^.next_item;
    end;
end; {$endregion}

begin
  CreateArray(arr,arr2);
  ShowArr    (arr,arr2,8);
  ArrToList2 (arr,8);
  {arr :=Nil;
  arr2:=Nil;}
  ShowList;
  ListToArr (arr,8);
  ShowArr   (arr,arr2,8);
  //AddListAndArr(arr2,10);
  //ShowArr(arr,arr2,8,8);
  Readln;
end.
}
{$endregion}



(****************************** Edge Antialiasing *****************************) {$region -fold}

{$region -fold}
{procedure BorderCalc0(constref arr_src    :T1IntrArr; var arr_dst:T1ByteArr;                          constref arr_src_width,arr_dst_width:integer; constref rct_dst:TPtRect; var aa_nz_arr_it_cnt:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr          : PInteger;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
  pix_cnt_btw_pts      : integer;
begin
  pix_cnt_btw_pts      :=0;
  aa_nz_arr_it_cnt     :=0;
  d_width1             :=                                arr_src_width- rct_dst.width;
  d_width2             :=                                arr_dst_width- rct_dst.width;
  arr_src_ptr          :=Unaligned(@arr_src[rct_dst.left+arr_src_width*(rct_dst.top+1)]);
  arr_dst_ptr          :=Unaligned(@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr^<>0) then
            begin
              arr_dst_ptr^:=3;
              Inc(pix_cnt_btw_pts);
              while (arr_dst_ptr^<>3) do
                begin
                  if ((arr_src_ptr+arr_src_width-1)^<>0) then
                    begin
                      arr_src_ptr +=arr_src_width-1;
                      arr_dst_ptr +=arr_dst_width-1;
                      arr_dst_ptr^:=1;
                      Inc(pix_cnt_btw_pts);
                    end
                  else
                  if ((arr_src_ptr+arr_src_width)^<>0) then
                    begin
                      arr_src_ptr +=arr_src_width;
                      arr_dst_ptr +=arr_dst_width;
                      arr_dst_ptr^:=1;
                      Inc(pix_cnt_btw_pts);
                    end
                  else
                  if ((arr_src_ptr+arr_src_width+1)^<>0) then
                    begin
                      arr_src_ptr +=arr_src_width+1;
                      arr_dst_ptr +=arr_dst_width+1;
                      arr_dst_ptr^:=1;
                      Inc(pix_cnt_btw_pts);
                    end
                  else
                  if ((arr_src_ptr+1)^<>0) then
                    begin
                      arr_src_ptr +=1;
                      arr_dst_ptr +=1;
                      arr_dst_ptr^:=1;
                      Inc(pix_cnt_btw_pts);
                    end
                  else
                  if ((arr_src_ptr-arr_src_width+1)^<>0) then
                    begin
                      arr_src_ptr -=arr_src_width+1;
                      arr_dst_ptr -=arr_dst_width+1;
                      arr_dst_ptr^:=1;
                      Inc(pix_cnt_btw_pts);
                    end
                  else
                  if ((arr_src_ptr+arr_src_width)^<>0) then
                    begin
                      arr_src_ptr -=arr_src_width;
                      arr_dst_ptr -=arr_dst_width;
                      arr_dst_ptr^:=1;
                      Inc(pix_cnt_btw_pts);
                    end
                  else
                  if ((arr_src_ptr-arr_src_width-1)^<>0) then
                    begin
                      arr_src_ptr -=arr_src_width-1;
                      arr_dst_ptr -=arr_dst_width-1;
                      arr_dst_ptr^:=1;
                      Inc(pix_cnt_btw_pts);
                    end
                  else
                  if ((arr_src_ptr-1)^<>0) then
                    begin
                      arr_src_ptr -=1;
                      arr_dst_ptr -=1;
                      arr_dst_ptr^:=1;
                      Inc(pix_cnt_btw_pts);
                    end;
                end;
            end;
          Inc(arr_src_ptr);
          Inc(arr_dst_ptr);
        end;
      Inc(arr_src_ptr,d_width1);
      Inc(arr_dst_ptr,d_width2);
    end;
end; {$endregion}}
{$endregion}

procedure BorderCalc000(constref arr_src   :T1Byte1Arr; var arr_dst:T1Byte1Arr;                         constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; var aa_nz_arr_it_cnt:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr          : PByte;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
  pix_cnt_btw_pts      : integer;
  p                    : byte=0;
label
  l1;
begin
  pix_cnt_btw_pts      :=0;
  aa_nz_arr_it_cnt     :=0;
  d_width1             :=                                arr_src_width- rct_dst.width;
  d_width2             :=                                arr_dst_width- rct_dst.width;
  arr_src_ptr          :=Unaligned(@arr_src[rct_dst.left+arr_src_width*(rct_dst.top+1)]);
  arr_dst_ptr          :=Unaligned(@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr^<>0) then
            goto l1;
          Inc(arr_src_ptr);
          Inc(arr_dst_ptr);
        end;
      Inc(arr_src_ptr,d_width1);
      Inc(arr_dst_ptr,d_width2);
    end;
  l1:
  arr_dst_ptr^:=3;

  //Inc(pix_cnt_btw_pts);
  while (arr_dst_ptr^<>3) and (p=1) do//repeat
    begin
      {0 0 0
       1 0 0
       0 0 0}
      if ((arr_src_ptr-1)^<>0) and ((arr_dst_ptr-1)^=0) then
        begin
          arr_src_ptr +=arr_src_width-1;
          arr_dst_ptr +=arr_dst_width-1;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {0 0 0
       0 0 0
       1 0 0}
      if ((arr_src_ptr+arr_src_width-1)^<>0) and ((arr_dst_ptr+arr_src_width-1)^=0) then
        begin
          arr_src_ptr +=arr_src_width-1;
          arr_dst_ptr +=arr_dst_width-1;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {0 0 0
       0 0 0
       0 1 0}
      if ((arr_src_ptr+arr_src_width)^<>0) and ((arr_dst_ptr+arr_src_width)^=0) then
        begin
          arr_src_ptr +=arr_src_width;
          arr_dst_ptr +=arr_dst_width;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {0 0 0
       0 0 0
       0 0 1}
      if ((arr_src_ptr+arr_src_width+1)^<>0) and ((arr_dst_ptr+arr_src_width+1)^=0) then
        begin
          arr_src_ptr +=arr_src_width+1;
          arr_dst_ptr +=arr_dst_width+1;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {0 0 0
       0 0 1
       0 0 0}
      if ((arr_src_ptr+1)^<>0) and ((arr_dst_ptr+1)^=0) then
        begin
          arr_src_ptr +=1;
          arr_dst_ptr +=1;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {0 0 1
       0 0 0
       0 0 0}
      if ((arr_src_ptr-arr_src_width+1)^<>0) and ((arr_dst_ptr-arr_src_width+1)^=0) then
        begin
          arr_src_ptr -=arr_src_width+1;
          arr_dst_ptr -=arr_dst_width+1;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {0 1 0
       0 0 0
       0 0 0}
      if ((arr_src_ptr-arr_src_width)^<>0) and ((arr_dst_ptr-arr_src_width)^=0) then
        begin
          arr_src_ptr -=arr_src_width;
          arr_dst_ptr -=arr_dst_width;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {1 0 0
       0 0 0
       0 0 0}
      if ((arr_src_ptr-arr_src_width-1)^<>0) and ((arr_dst_ptr-arr_src_width-1)^=0) then
        begin
          arr_src_ptr -=arr_src_width-1;
          arr_dst_ptr -=arr_dst_width-1;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end;
    end;
    //until (arr_dst_ptr^<>3);
end; {$endregion}

procedure BorderCalc0 (constref arr_src_ptr:PInteger  ; var arr_dst:T1Byte1Arr;                         constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; var      aa_nz_arr_it_cnt:TColor; constref background_color:TColor                  ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2         : PInteger;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
begin
  aa_nz_arr_it_cnt:=0;
  d_width1        :=                                    arr_src_width- rct_dst.width   ;
  d_width2        :=                                    arr_dst_width- rct_dst.width   ;
  arr_src_ptr2    :=Unaligned( arr_src_ptr+rct_dst.left+arr_src_width*(rct_dst.top+1) );
  arr_dst_ptr     :=Unaligned(@arr_dst    [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  Prefetch(arr_src_ptr2);
  Prefetch(arr_dst_ptr );
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr2^<>background_color) then
            begin
              if ((arr_src_ptr2-arr_src_width)^=background_color) then
                begin
                  (arr_dst_ptr-arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr2+arr_src_width)^=background_color) then
                begin
                  (arr_dst_ptr+arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr2-1)^=background_color) then
                begin
                  (arr_dst_ptr-1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr2+1)^=background_color) then
                begin
                  (arr_dst_ptr+1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
            end;
          Inc(arr_src_ptr2);
          Inc(arr_dst_ptr );
        end;
      Inc(arr_src_ptr2,d_width1);
      Inc(arr_dst_ptr ,d_width2);
    end;
end; {$endregion}
procedure BorderCalc1 (constref arr_src_ptr:PInteger  ; var arr_dst:T1Byte1Arr;                         constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; var      aa_nz_arr_it_cnt:TColor                                                    ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2         : PInteger;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
begin
  aa_nz_arr_it_cnt     :=0;
  d_width1             :=                                    arr_src_width- rct_dst.width   ;
  d_width2             :=                                    arr_dst_width- rct_dst.width   ;
  arr_src_ptr2         :=Unaligned( arr_src_ptr+rct_dst.left+arr_src_width*(rct_dst.top+1) );
  arr_dst_ptr          :=Unaligned(@arr_dst    [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  Prefetch(arr_src_ptr2);
  Prefetch(arr_dst_ptr );
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr2^<>0) then
            begin
              if ((arr_src_ptr2-arr_src_width)^=0) then
                begin
                  (arr_dst_ptr-arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr2+arr_src_width)^=0) then
                begin
                  (arr_dst_ptr+arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr2-1)^=0) then
                begin
                  (arr_dst_ptr-1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr2+1)^=0) then
                begin
                  (arr_dst_ptr+1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
            end;
          Inc(arr_src_ptr2);
          Inc(arr_dst_ptr );
        end;
      Inc(arr_src_ptr2,d_width1);
      Inc(arr_dst_ptr ,d_width2);
    end;
end; {$endregion}
procedure BorderCalc1 (constref arr_src    :TColorArr ; var arr_dst:T1Byte1Arr;                         constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; var      aa_nz_arr_it_cnt:TColor                                                    ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr          : PInteger;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
begin
  aa_nz_arr_it_cnt     :=0;
  d_width1             :=                                arr_src_width- rct_dst.width;
  d_width2             :=                                arr_dst_width- rct_dst.width;
  arr_src_ptr          :=Unaligned(@arr_src[rct_dst.left+arr_src_width*(rct_dst.top+1)]);
  arr_dst_ptr          :=Unaligned(@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr^<>0) then
            begin
              if ((arr_src_ptr-arr_src_width)^=0) then
                begin
                  (arr_dst_ptr-arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr+arr_src_width)^=0) then
                begin
                  (arr_dst_ptr+arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr-1)^=0) then
                begin
                  (arr_dst_ptr-1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr+1)^=0) then
                begin
                  (arr_dst_ptr+1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
            end;
          Inc(arr_src_ptr);
          Inc(arr_dst_ptr);
        end;
      Inc(arr_src_ptr,d_width1);
      Inc(arr_dst_ptr,d_width2);
    end;
end; {$endregion}
procedure BorderCalc1 (constref arr_src    :T1Byte1Arr; var arr_dst:T1Byte1Arr;                         constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; var      aa_nz_arr_it_cnt:TColor                                                    ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr          : PByte;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
begin
  aa_nz_arr_it_cnt     :=0;
  d_width1             :=                                arr_src_width- rct_dst.width;
  d_width2             :=                                arr_dst_width- rct_dst.width;
  arr_src_ptr          :=Unaligned(@arr_src[rct_dst.left+arr_src_width*(rct_dst.top+1)]);
  arr_dst_ptr          :=Unaligned(@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr^<>0) then
            begin
              if ((arr_src_ptr-arr_src_width)^=0) then
                begin
                  (arr_dst_ptr-arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr+arr_src_width)^=0) then
                begin
                  (arr_dst_ptr+arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr-1)^=0) then
                begin
                  (arr_dst_ptr-1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr+1)^=0) then
                begin
                  (arr_dst_ptr+1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
            end;
          Inc(arr_src_ptr);
          Inc(arr_dst_ptr);
        end;
      Inc(arr_src_ptr,d_width1);
      Inc(arr_dst_ptr,d_width2);
    end;
end; {$endregion}

// Mixed: Image Has Circle And Other Contours:
procedure BorderCalc20(constref arr_src_ptr:PInteger  ; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; out      line_cnt        :TColor                                                    ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Circle----------} {$region -fold}
              if //((arr_dst_ptr                 -1)^=0) and ((arr_dst_ptr                 +1)^=0) and
                 ((arr_dst_ptr+arr_dst_width   -1)^=1) and ((arr_dst_ptr+arr_dst_width   +1)^=1) and
                 //((arr_dst_ptr+arr_dst_width<<1-1)^=0) and ((arr_dst_ptr+arr_dst_width<<1+1)^=0) and
                 ((arr_dst_ptr+arr_dst_width<<1  )^=1) then
                begin
                   arr_dst_ptr^                  :=2;
                  (arr_dst_ptr+arr_dst_width -1)^:=2;
                  (arr_dst_ptr+arr_dst_width +1)^:=2;
                  (arr_dst_ptr+arr_dst_width<<1)^:=2;
                  arr_alpha_ptr^.line_kind       :=11;
                  arr_alpha_ptr^.first_pt_x      :=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y      :=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end {$endregion}
              {Fill Horizontal Line-} {$region -fold}
              else
              if ((arr_dst_ptr+1)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr);
                    end;
                  arr_alpha_ptr^.line_shift:=arr_dst_ptr-line_first_pt_ptr;
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=arr_dst_ptr      -arr_dst_left_ptr+d0;
                  line_kind_arr[3]         :=((arr_src_ptr+d1-1)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2  )^<>0);
                  {line_kind=2----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=2;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=0,1,3} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1  -arr_src_width)^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2  -arr_src_width)^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1+arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1  +arr_src_width)^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2  +arr_src_width)^<>0);
                      case line_kind of
                        {line_kind=0} {$region -fold}
                        {can be rolled to line_kind=1}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001,
                        {00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000,
                        {00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000,
                        {00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001,
                        {00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000,
                        {00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001,
                        {01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000,
                        {01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001,
                        {01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001,
                        {01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000,
                        {01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000,
                        {01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001,
                        {01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000,
                        {01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001,
                        {01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000,
                        {11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000,
                        {10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000,
                        {11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000,
                        {10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001:
                          begin
                            arr_alpha_ptr^.line_kind :=0;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=1} {$region -fold}
                        {can be rolled to line_kind=0}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000,
                        {01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000,
                        {01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000,
                        {11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000,
                        {01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000,
                        {11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000,
                        {01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000,
                        {11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000,
                        {10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000,
                        {00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000,
                        {00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000,
                        {10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000,
                        {00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000,
                        {10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000,
                        {01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000,
                        {00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001,
                        {01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001,
                        {00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001,
                        {11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001:
                          begin
                            arr_alpha_ptr^.line_kind :=1;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=3} {$region -fold}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000:
                        if ((arr_src_ptr+d2-arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000:
                        if ((arr_src_ptr+d2+arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill Vertical Line---} {$region -fold}
              else
              if ((arr_dst_ptr+arr_dst_width)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr,arr_dst_width);
                    end;
                  arr_alpha_ptr^.line_shift:=Trunc((arr_dst_ptr-line_first_pt_ptr)/arr_dst_width);
                  Dec(arr_dst_ptr,arr_dst_ptr-line_first_pt_ptr);
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=d1+arr_src_width*arr_alpha_ptr^.line_shift;
                  line_kind_arr[3]         :=((arr_src_ptr+d1 -arr_src_width)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2               )^<>0);
                  {line_kind=7----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=7;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=5,6,8} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1+1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1+1              )^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2+1              )^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1-1              )^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2-1              )^<>0);
                      case line_kind of
                        {line_kind=5} {$region -fold}
                        {can be rolled to line_kind=6}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001,
                        {00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000,
                        {00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000,
                        {00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001,
                        {00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000,
                        {00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001,
                        {01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000,
                        {01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001,
                        {01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001,
                        {01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000,
                        {01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000,
                        {01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001,
                        {01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000,
                        {01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001,
                        {01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000,
                        {11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000,
                        {10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000,
                        {11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000,
                        {10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001:
                          begin
                            arr_alpha_ptr^.line_kind :=5;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=6} {$region -fold}
                        {can be rolled to line_kind=5}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000,
                        {01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000,
                        {01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000,
                        {11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000,
                        {01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000,
                        {11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000,
                        {01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000,
                        {11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000,
                        {10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000,
                        {00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000,
                        {00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000,
                        {10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000,
                        {00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000,
                        {10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000,
                        {01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000,
                        {00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001,
                        {01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001,
                        {00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001,
                        {11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001:
                          begin
                            arr_alpha_ptr^.line_kind :=6;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=8} {$region -fold}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000:
                        if ((arr_src_ptr+d2+1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000:
                        if ((arr_src_ptr+d2-1-arr_src_width)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill One Pixel-------} {$region -fold}
              else
              if (((arr_dst_ptr-arr_dst_width)^<>1) and ((arr_dst_ptr-1)^<>1)) or
                 (((arr_dst_ptr+arr_dst_width)^<>1) and ((arr_dst_ptr+1)^<>1)) then
                begin
                  arr_dst_ptr^             :=2;
                  arr_alpha_ptr^.line_kind :=10;
                  arr_alpha_ptr^.first_pt_x:=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end; {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
procedure BorderCalc20(constref arr_src    :TColorArr ; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; out      line_cnt        :TColor                                                    ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_src_ptr           : PInteger;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_src_ptr     :=Unaligned(@arr_src  [000000000000000000000000000000000000000000]);
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Circle----------} {$region -fold}
              if //((arr_dst_ptr                 -1)^=0) and ((arr_dst_ptr                 +1)^=0) and
                 ((arr_dst_ptr+arr_dst_width   -1)^=1) and ((arr_dst_ptr+arr_dst_width   +1)^=1) and
                 //((arr_dst_ptr+arr_dst_width<<1-1)^=0) and ((arr_dst_ptr+arr_dst_width<<1+1)^=0) and
                 ((arr_dst_ptr+arr_dst_width<<1  )^=1) then
                begin
                   arr_dst_ptr^                  :=2;
                  (arr_dst_ptr+arr_dst_width -1)^:=2;
                  (arr_dst_ptr+arr_dst_width +1)^:=2;
                  (arr_dst_ptr+arr_dst_width<<1)^:=2;
                  arr_alpha_ptr^.line_kind       :=11;
                  arr_alpha_ptr^.first_pt_x      :=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y      :=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end {$endregion}
              {Fill Horizontal Line-} {$region -fold}
              else
              if ((arr_dst_ptr+1)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr);
                    end;
                  arr_alpha_ptr^.line_shift:=arr_dst_ptr-line_first_pt_ptr;
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=arr_dst_ptr      -arr_dst_left_ptr+d0;
                  line_kind_arr[3]         :=((arr_src_ptr+d1-1)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2  )^<>0);
                  {line_kind=2----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=2;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=0,1,3} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1  -arr_src_width)^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2  -arr_src_width)^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1+arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1  +arr_src_width)^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2  +arr_src_width)^<>0);
                      case line_kind of
                        {line_kind=0} {$region -fold}
                        {can be rolled to line_kind=1}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001,
                        {00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000,
                        {00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000,
                        {00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001,
                        {00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000,
                        {00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001,
                        {01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000,
                        {01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001,
                        {01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001,
                        {01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000,
                        {01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000,
                        {01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001,
                        {01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000,
                        {01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001,
                        {01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000,
                        {11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000,
                        {10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000,
                        {11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000,
                        {10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001:
                          begin
                            arr_alpha_ptr^.line_kind :=0;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=1} {$region -fold}
                        {can be rolled to line_kind=0}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000,
                        {01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000,
                        {01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000,
                        {11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000,
                        {01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000,
                        {11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000,
                        {01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000,
                        {11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000,
                        {10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000,
                        {00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000,
                        {00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000,
                        {10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000,
                        {00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000,
                        {10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000,
                        {01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000,
                        {00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001,
                        {01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001,
                        {00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001,
                        {11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001:
                          begin
                            arr_alpha_ptr^.line_kind :=1;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=3} {$region -fold}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000:
                        if ((arr_src_ptr+d2-arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000:
                        if ((arr_src_ptr+d2+arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill Vertical Line---} {$region -fold}
              else
              if ((arr_dst_ptr+arr_dst_width)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr,arr_dst_width);
                    end;
                  arr_alpha_ptr^.line_shift:=Trunc((arr_dst_ptr-line_first_pt_ptr)/arr_dst_width);
                  Dec(arr_dst_ptr,arr_dst_ptr-line_first_pt_ptr);
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=d1+arr_src_width*arr_alpha_ptr^.line_shift;
                  line_kind_arr[3]         :=((arr_src_ptr+d1 -arr_src_width)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2               )^<>0);
                  {line_kind=7----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=7;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=5,6,8} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1+1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1+1              )^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2+1              )^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1-1              )^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2-1              )^<>0);
                      case line_kind of
                        {line_kind=5} {$region -fold}
                        {can be rolled to line_kind=6}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001,
                        {00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000,
                        {00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000,
                        {00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001,
                        {00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000,
                        {00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001,
                        {01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000,
                        {01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001,
                        {01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001,
                        {01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000,
                        {01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000,
                        {01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001,
                        {01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000,
                        {01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001,
                        {01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000,
                        {11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000,
                        {10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000,
                        {11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000,
                        {10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001:
                          begin
                            arr_alpha_ptr^.line_kind :=5;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=6} {$region -fold}
                        {can be rolled to line_kind=5}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000,
                        {01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000,
                        {01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000,
                        {11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000,
                        {01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000,
                        {11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000,
                        {01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000,
                        {11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000,
                        {10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000,
                        {00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000,
                        {00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000,
                        {10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000,
                        {00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000,
                        {10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000,
                        {01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000,
                        {00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001,
                        {01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001,
                        {00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001,
                        {11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001:
                          begin
                            arr_alpha_ptr^.line_kind :=6;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=8} {$region -fold}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000:
                        if ((arr_src_ptr+d2+1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000:
                        if ((arr_src_ptr+d2-1-arr_src_width)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill One Pixel-------} {$region -fold}
              else
              if (((arr_dst_ptr-arr_dst_width)^<>1) and ((arr_dst_ptr-1)^<>1)) or
                 (((arr_dst_ptr+arr_dst_width)^<>1) and ((arr_dst_ptr+1)^<>1)) then
                begin
                  arr_dst_ptr^             :=2;
                  arr_alpha_ptr^.line_kind :=10;
                  arr_alpha_ptr^.first_pt_x:=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end; {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
procedure BorderCalc20(constref arr_src    :T1Byte1Arr; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; out      line_cnt        :TColor                                                    ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_src_ptr           : PByte;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_src_ptr     :=Unaligned(@arr_src  [000000000000000000000000000000000000000000]);
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Circle----------} {$region -fold}
              if //((arr_dst_ptr                 -1)^=0) and ((arr_dst_ptr                 +1)^=0) and
                 ((arr_dst_ptr+arr_dst_width   -1)^=1) and ((arr_dst_ptr+arr_dst_width   +1)^=1) and
                 //((arr_dst_ptr+arr_dst_width<<1-1)^=0) and ((arr_dst_ptr+arr_dst_width<<1+1)^=0) and
                 ((arr_dst_ptr+arr_dst_width<<1  )^=1) then
                begin
                   arr_dst_ptr^                  :=2;
                  (arr_dst_ptr+arr_dst_width -1)^:=2;
                  (arr_dst_ptr+arr_dst_width +1)^:=2;
                  (arr_dst_ptr+arr_dst_width<<1)^:=2;
                  arr_alpha_ptr^.line_kind       :=11;
                  arr_alpha_ptr^.first_pt_x      :=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y      :=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end {$endregion}
              {Fill Horizontal Line-} {$region -fold}
              else
              if ((arr_dst_ptr+1)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr);
                    end;
                  arr_alpha_ptr^.line_shift:=arr_dst_ptr-line_first_pt_ptr;
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=arr_dst_ptr      -arr_dst_left_ptr+d0;
                  line_kind_arr[3]         :=((arr_src_ptr+d1-1)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2  )^<>0);
                  {line_kind=2----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=2;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=0,1,3} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1  -arr_src_width)^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2  -arr_src_width)^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1+arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1  +arr_src_width)^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2  +arr_src_width)^<>0);
                      case line_kind of
                        {line_kind=0} {$region -fold}
                        {can be rolled to line_kind=1}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001,
                        {00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000,
                        {00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000,
                        {00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001,
                        {00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000,
                        {00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001,
                        {01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000,
                        {01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001,
                        {01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001,
                        {01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000,
                        {01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000,
                        {01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001,
                        {01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000,
                        {01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001,
                        {01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000,
                        {11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000,
                        {10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000,
                        {11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000,
                        {10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001:
                          begin
                            arr_alpha_ptr^.line_kind :=0;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=1} {$region -fold}
                        {can be rolled to line_kind=0}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000,
                        {01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000,
                        {01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000,
                        {11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000,
                        {01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000,
                        {11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000,
                        {01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000,
                        {11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000,
                        {10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000,
                        {00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000,
                        {00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000,
                        {10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000,
                        {00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000,
                        {10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000,
                        {01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000,
                        {00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001,
                        {01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001,
                        {00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001,
                        {11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001:
                          begin
                            arr_alpha_ptr^.line_kind :=1;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=3} {$region -fold}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000:
                        if ((arr_src_ptr+d2-arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000:
                        if ((arr_src_ptr+d2+arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill Vertical Line---} {$region -fold}
              else
              if ((arr_dst_ptr+arr_dst_width)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr,arr_dst_width);
                    end;
                  arr_alpha_ptr^.line_shift:=Trunc((arr_dst_ptr-line_first_pt_ptr)/arr_dst_width);
                  Dec(arr_dst_ptr,arr_dst_ptr-line_first_pt_ptr);
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=d1+arr_src_width*arr_alpha_ptr^.line_shift;
                  line_kind_arr[3]         :=((arr_src_ptr+d1 -arr_src_width)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2               )^<>0);
                  {line_kind=7----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=7;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=5,6,8} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1+1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1+1              )^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2+1              )^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1-1              )^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2-1              )^<>0);
                      case line_kind of
                        {line_kind=5} {$region -fold}
                        {can be rolled to line_kind=6}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001,
                        {00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000,
                        {00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000,
                        {00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001,
                        {00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000,
                        {00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001,
                        {01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000,
                        {01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001,
                        {01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001,
                        {01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000,
                        {01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000,
                        {01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001,
                        {01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000,
                        {01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001,
                        {01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000,
                        {11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000,
                        {10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000,
                        {11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000,
                        {10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001:
                          begin
                            arr_alpha_ptr^.line_kind :=5;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=6} {$region -fold}
                        {can be rolled to line_kind=5}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000,
                        {01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000,
                        {01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000,
                        {11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000,
                        {01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000,
                        {11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000,
                        {01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000,
                        {11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000,
                        {10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000,
                        {00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000,
                        {00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000,
                        {10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000,
                        {00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000,
                        {10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000,
                        {01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000,
                        {00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001,
                        {01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001,
                        {00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001,
                        {11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001:
                          begin
                            arr_alpha_ptr^.line_kind :=6;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=8} {$region -fold}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000:
                        if ((arr_src_ptr+d2+1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000:
                        if ((arr_src_ptr+d2-1-arr_src_width)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill One Pixel-------} {$region -fold}
              else
              if (((arr_dst_ptr-arr_dst_width)^<>1) and ((arr_dst_ptr-1)^<>1)) or
                 (((arr_dst_ptr+arr_dst_width)^<>1) and ((arr_dst_ptr+1)^<>1)) then
                begin
                  arr_dst_ptr^             :=2;
                  arr_alpha_ptr^.line_kind :=10;
                  arr_alpha_ptr^.first_pt_x:=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end; {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}

// Image Has Only Circle Contours:
procedure BorderCalc21(constref arr_src_ptr:PInteger  ; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; out      line_cnt        :TColor                                                    ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Circle----------} {$region -fold}
              if //((arr_dst_ptr                 -1)^=0) and ((arr_dst_ptr                 +1)^=0) and
                 ((arr_dst_ptr+arr_dst_width   -1)^=1) and ((arr_dst_ptr+arr_dst_width   +1)^=1) and
                 //((arr_dst_ptr+arr_dst_width<<1-1)^=0) and ((arr_dst_ptr+arr_dst_width<<1+1)^=0) and
                 ((arr_dst_ptr+arr_dst_width<<1  )^=1) then
                begin
                   arr_dst_ptr^                  :=2;
                  (arr_dst_ptr+arr_dst_width -1)^:=2;
                  (arr_dst_ptr+arr_dst_width +1)^:=2;
                  (arr_dst_ptr+arr_dst_width<<1)^:=2;
                  arr_alpha_ptr^.line_kind       :=11;
                  arr_alpha_ptr^.first_pt_x      :=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y      :=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end; {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
procedure BorderCalc21(constref arr_src    :TColorArr ; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; out      line_cnt        :TColor                                                    ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_src_ptr           : PInteger;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_src_ptr     :=Unaligned(@arr_src  [000000000000000000000000000000000000000000]);
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Circle----------} {$region -fold}
              if //((arr_dst_ptr                 -1)^=0) and ((arr_dst_ptr                 +1)^=0) and
                 ((arr_dst_ptr+arr_dst_width   -1)^=1) and ((arr_dst_ptr+arr_dst_width   +1)^=1) and
                 //((arr_dst_ptr+arr_dst_width<<1-1)^=0) and ((arr_dst_ptr+arr_dst_width<<1+1)^=0) and
                 ((arr_dst_ptr+arr_dst_width<<1  )^=1) then
                begin
                   arr_dst_ptr^                  :=2;
                  (arr_dst_ptr+arr_dst_width -1)^:=2;
                  (arr_dst_ptr+arr_dst_width +1)^:=2;
                  (arr_dst_ptr+arr_dst_width<<1)^:=2;
                  arr_alpha_ptr^.line_kind       :=11;
                  arr_alpha_ptr^.first_pt_x      :=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y      :=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
procedure BorderCalc21(constref arr_src    :T1Byte1Arr; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; out      line_cnt        :TColor                                                    ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_src_ptr           : PByte;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_src_ptr     :=Unaligned(@arr_src  [000000000000000000000000000000000000000000]);
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Circle----------} {$region -fold}
              if //((arr_dst_ptr                 -1)^=0) and ((arr_dst_ptr                 +1)^=0) and
                 ((arr_dst_ptr+arr_dst_width   -1)^=1) and ((arr_dst_ptr+arr_dst_width   +1)^=1) and
                 //((arr_dst_ptr+arr_dst_width<<1-1)^=0) and ((arr_dst_ptr+arr_dst_width<<1+1)^=0) and
                 ((arr_dst_ptr+arr_dst_width<<1  )^=1) then
                begin
                   arr_dst_ptr^                  :=2;
                  (arr_dst_ptr+arr_dst_width -1)^:=2;
                  (arr_dst_ptr+arr_dst_width +1)^:=2;
                  (arr_dst_ptr+arr_dst_width<<1)^:=2;
                  arr_alpha_ptr^.line_kind       :=11;
                  arr_alpha_ptr^.first_pt_x      :=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y      :=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}

// Image Has No Circle Contours:
procedure BorderCalc22(constref arr_src_ptr:PInteger  ; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; out      line_cnt        :TColor                                                    ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Horizontal Line-} {$region -fold}
              if ((arr_dst_ptr+1)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr);
                    end;
                  arr_alpha_ptr^.line_shift:=arr_dst_ptr-line_first_pt_ptr;
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=arr_dst_ptr      -arr_dst_left_ptr+d0;
                  line_kind_arr[3]         :=((arr_src_ptr+d1-1)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2  )^<>0);
                  {line_kind=2----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=2;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=0,1,3} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1  -arr_src_width)^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2  -arr_src_width)^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1+arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1  +arr_src_width)^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2  +arr_src_width)^<>0);
                      case line_kind of
                        {line_kind=0} {$region -fold}
                        {can be rolled to line_kind=1}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001,
                        {00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000,
                        {00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000,
                        {00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001,
                        {00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000,
                        {00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001,
                        {01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000,
                        {01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001,
                        {01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001,
                        {01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000,
                        {01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000,
                        {01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001,
                        {01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000,
                        {01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001,
                        {01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000,
                        {11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000,
                        {10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000,
                        {11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000,
                        {10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001:
                          begin
                            arr_alpha_ptr^.line_kind :=0;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=1} {$region -fold}
                        {can be rolled to line_kind=0}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000,
                        {01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000,
                        {01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000,
                        {11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000,
                        {01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000,
                        {11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000,
                        {01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000,
                        {11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000,
                        {10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000,
                        {00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000,
                        {00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000,
                        {10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000,
                        {00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000,
                        {10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000,
                        {01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000,
                        {00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001,
                        {01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001,
                        {00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001,
                        {11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001:
                          begin
                            arr_alpha_ptr^.line_kind :=1;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=3} {$region -fold}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000:
                        if ((arr_src_ptr+d2-arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000:
                        if ((arr_src_ptr+d2+arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill Vertical Line---} {$region -fold}
              else
              if ((arr_dst_ptr+arr_dst_width)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr,arr_dst_width);
                    end;
                  arr_alpha_ptr^.line_shift:=Trunc((arr_dst_ptr-line_first_pt_ptr)/arr_dst_width);
                  Dec(arr_dst_ptr,arr_dst_ptr-line_first_pt_ptr);
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=d1+arr_src_width*arr_alpha_ptr^.line_shift;
                  line_kind_arr[3]         :=((arr_src_ptr+d1 -arr_src_width)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2               )^<>0);
                  {line_kind=7----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=7;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=5,6,8} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1+1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1+1              )^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2+1              )^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1-1              )^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2-1              )^<>0);
                      case line_kind of
                        {line_kind=5} {$region -fold}
                        {can be rolled to line_kind=6}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001,
                        {00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000,
                        {00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000,
                        {00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001,
                        {00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000,
                        {00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001,
                        {01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000,
                        {01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001,
                        {01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001,
                        {01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000,
                        {01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000,
                        {01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001,
                        {01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000,
                        {01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001,
                        {01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000,
                        {11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000,
                        {10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000,
                        {11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000,
                        {10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001:
                          begin
                            arr_alpha_ptr^.line_kind :=5;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=6} {$region -fold}
                        {can be rolled to line_kind=5}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000,
                        {01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000,
                        {01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000,
                        {11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000,
                        {01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000,
                        {11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000,
                        {01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000,
                        {11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000,
                        {10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000,
                        {00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000,
                        {00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000,
                        {10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000,
                        {00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000,
                        {10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000,
                        {01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000,
                        {00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001,
                        {01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001,
                        {00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001,
                        {11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001:
                          begin
                            arr_alpha_ptr^.line_kind :=6;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=8} {$region -fold}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000:
                        if ((arr_src_ptr+d2+1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000:
                        if ((arr_src_ptr+d2-1-arr_src_width)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill One Pixel-------} {$region -fold}
              else
              if (((arr_dst_ptr-arr_dst_width)^<>1) and ((arr_dst_ptr-1)^<>1)) or
                 (((arr_dst_ptr+arr_dst_width)^<>1) and ((arr_dst_ptr+1)^<>1)) then
                begin
                  arr_dst_ptr^             :=2;
                  arr_alpha_ptr^.line_kind :=10;
                  arr_alpha_ptr^.first_pt_x:=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end; {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
procedure BorderCalc22(constref arr_src    :TColorArr ; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; out      line_cnt        :TColor                                                    ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_src_ptr           : PInteger;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_src_ptr     :=Unaligned(@arr_src  [000000000000000000000000000000000000000000]);
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Horizontal Line-} {$region -fold}
              if ((arr_dst_ptr+1)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr);
                    end;
                  arr_alpha_ptr^.line_shift:=arr_dst_ptr-line_first_pt_ptr;
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=arr_dst_ptr      -arr_dst_left_ptr+d0;
                  line_kind_arr[3]         :=((arr_src_ptr+d1-1)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2  )^<>0);
                  {line_kind=2----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=2;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=0,1,3} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1  -arr_src_width)^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2  -arr_src_width)^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1+arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1  +arr_src_width)^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2  +arr_src_width)^<>0);
                      case line_kind of
                        {line_kind=0} {$region -fold}
                        {can be rolled to line_kind=1}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001,
                        {00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000,
                        {00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000,
                        {00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001,
                        {00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000,
                        {00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001,
                        {01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000,
                        {01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001,
                        {01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001,
                        {01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000,
                        {01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000,
                        {01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001,
                        {01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000,
                        {01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001,
                        {01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000,
                        {11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000,
                        {10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000,
                        {11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000,
                        {10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001:
                          begin
                            arr_alpha_ptr^.line_kind :=0;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=1} {$region -fold}
                        {can be rolled to line_kind=0}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000,
                        {01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000,
                        {01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000,
                        {11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000,
                        {01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000,
                        {11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000,
                        {01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000,
                        {11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000,
                        {10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000,
                        {00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000,
                        {00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000,
                        {10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000,
                        {00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000,
                        {10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000,
                        {01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000,
                        {00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001,
                        {01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001,
                        {00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001,
                        {11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001:
                          begin
                            arr_alpha_ptr^.line_kind :=1;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=3} {$region -fold}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000:
                        if ((arr_src_ptr+d2-arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000:
                        if ((arr_src_ptr+d2+arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill Vertical Line---} {$region -fold}
              else
              if ((arr_dst_ptr+arr_dst_width)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr,arr_dst_width);
                    end;
                  arr_alpha_ptr^.line_shift:=Trunc((arr_dst_ptr-line_first_pt_ptr)/arr_dst_width);
                  Dec(arr_dst_ptr,arr_dst_ptr-line_first_pt_ptr);
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=d1+arr_src_width*arr_alpha_ptr^.line_shift;
                  line_kind_arr[3]         :=((arr_src_ptr+d1 -arr_src_width)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2               )^<>0);
                  {line_kind=7----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=7;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=5,6,8} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1+1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1+1              )^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2+1              )^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1-1              )^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2-1              )^<>0);
                      case line_kind of
                        {line_kind=5} {$region -fold}
                        {can be rolled to line_kind=6}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001,
                        {00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000,
                        {00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000,
                        {00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001,
                        {00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000,
                        {00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001,
                        {01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000,
                        {01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001,
                        {01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001,
                        {01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000,
                        {01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000,
                        {01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001,
                        {01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000,
                        {01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001,
                        {01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000,
                        {11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000,
                        {10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000,
                        {11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000,
                        {10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001:
                          begin
                            arr_alpha_ptr^.line_kind :=5;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=6} {$region -fold}
                        {can be rolled to line_kind=5}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000,
                        {01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000,
                        {01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000,
                        {11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000,
                        {01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000,
                        {11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000,
                        {01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000,
                        {11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000,
                        {10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000,
                        {00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000,
                        {00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000,
                        {10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000,
                        {00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000,
                        {10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000,
                        {01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000,
                        {00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001,
                        {01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001,
                        {00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001,
                        {11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001:
                          begin
                            arr_alpha_ptr^.line_kind :=6;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=8} {$region -fold}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000:
                        if ((arr_src_ptr+d2+1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000:
                        if ((arr_src_ptr+d2-1-arr_src_width)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill One Pixel-------} {$region -fold}
              else
              if (((arr_dst_ptr-arr_dst_width)^<>1) and ((arr_dst_ptr-1)^<>1)) or
                 (((arr_dst_ptr+arr_dst_width)^<>1) and ((arr_dst_ptr+1)^<>1)) then
                begin
                  arr_dst_ptr^             :=2;
                  arr_alpha_ptr^.line_kind :=10;
                  arr_alpha_ptr^.first_pt_x:=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end; {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
procedure BorderCalc22(constref arr_src    :T1Byte1Arr; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; out      line_cnt        :TColor                                                    ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_src_ptr           : PByte;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_src_ptr     :=Unaligned(@arr_src  [000000000000000000000000000000000000000000]);
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Horizontal Line-} {$region -fold}
              if ((arr_dst_ptr+1)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr);
                    end;
                  arr_alpha_ptr^.line_shift:=arr_dst_ptr-line_first_pt_ptr;
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=arr_dst_ptr      -arr_dst_left_ptr+d0;
                  line_kind_arr[3]         :=((arr_src_ptr+d1-1)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2  )^<>0);
                  {line_kind=2----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=2;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=0,1,3} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1  -arr_src_width)^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2  -arr_src_width)^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1+arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1  +arr_src_width)^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2  +arr_src_width)^<>0);
                      case line_kind of
                        {line_kind=0} {$region -fold}
                        {can be rolled to line_kind=1}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001,
                        {00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000,
                        {00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000,
                        {00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001,
                        {00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000,
                        {00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001,
                        {01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000,
                        {01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001,
                        {01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001,
                        {01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000,
                        {01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000,
                        {01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001,
                        {01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000,
                        {01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001,
                        {01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000,
                        {11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000,
                        {10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000,
                        {11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000,
                        {10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001:
                          begin
                            arr_alpha_ptr^.line_kind :=0;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=1} {$region -fold}
                        {can be rolled to line_kind=0}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000,
                        {01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000,
                        {01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000,
                        {11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000,
                        {01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000,
                        {11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000,
                        {01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000,
                        {11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000,
                        {10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000,
                        {00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000,
                        {00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000,
                        {10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000,
                        {00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000,
                        {10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000,
                        {01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000,
                        {00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001,
                        {01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001,
                        {00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001,
                        {11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001:
                          begin
                            arr_alpha_ptr^.line_kind :=1;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=3} {$region -fold}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000:
                        if ((arr_src_ptr+d2-arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000:
                        if ((arr_src_ptr+d2+arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill Vertical Line---} {$region -fold}
              else
              if ((arr_dst_ptr+arr_dst_width)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr,arr_dst_width);
                    end;
                  arr_alpha_ptr^.line_shift:=Trunc((arr_dst_ptr-line_first_pt_ptr)/arr_dst_width);
                  Dec(arr_dst_ptr,arr_dst_ptr-line_first_pt_ptr);
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=d1+arr_src_width*arr_alpha_ptr^.line_shift;
                  line_kind_arr[3]         :=((arr_src_ptr+d1 -arr_src_width)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2               )^<>0);
                  {line_kind=7----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=7;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=5,6,8} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1+1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1+1              )^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2+1              )^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1-1              )^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2-1              )^<>0);
                      case line_kind of
                        {line_kind=5} {$region -fold}
                        {can be rolled to line_kind=6}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001,
                        {00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000,
                        {00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000,
                        {00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001,
                        {00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000,
                        {00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001,
                        {01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000,
                        {01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001,
                        {01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001,
                        {01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000,
                        {01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000,
                        {01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001,
                        {01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000,
                        {01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001,
                        {01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000,
                        {11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000,
                        {10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000,
                        {11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000,
                        {10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001:
                          begin
                            arr_alpha_ptr^.line_kind :=5;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=6} {$region -fold}
                        {can be rolled to line_kind=5}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000,
                        {01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000,
                        {01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000,
                        {11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000,
                        {01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000,
                        {11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000,
                        {01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000,
                        {11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000,
                        {10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000,
                        {00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000,
                        {00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000,
                        {10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000,
                        {00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000,
                        {10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000,
                        {01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000,
                        {00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001,
                        {01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001,
                        {00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001,
                        {11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001:
                          begin
                            arr_alpha_ptr^.line_kind :=6;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=8} {$region -fold}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000:
                        if ((arr_src_ptr+d2+1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000:
                        if ((arr_src_ptr+d2-1-arr_src_width)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill One Pixel-------} {$region -fold}
              else
              if (((arr_dst_ptr-arr_dst_width)^<>1) and ((arr_dst_ptr-1)^<>1)) or
                 (((arr_dst_ptr+arr_dst_width)^<>1) and ((arr_dst_ptr+1)^<>1)) then
                begin
                  arr_dst_ptr^             :=2;
                  arr_alpha_ptr^.line_kind :=10;
                  arr_alpha_ptr^.first_pt_x:=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end; {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}

procedure BorderFill  (constref arr_src    :TAALnArr;   constref rct_dst_left,rct_dst_top:integer; constref bmp_ptr:PInteger; constref bmp_width:TColor;                       constref line_cnt        :TColor; constref col:TColor; args:TFunc0Args; Func2:TFunc2); {$region -fold}
var
  arr_src_ptr : PFastAALine;
  pixel_ptr   : Pinteger;
  i,j         : integer;
  alpha_shift3: integer;
  alpha_shift2: integer;
  alpha_shift1: byte;
    alpha1    : byte;
  d_alpha1    : byte;
    alpha2    : byte;
  d_alpha2    : byte;
begin
  if (line_cnt=0) then
    Exit;
  with args do
    begin
      r           :=Red  (col);
      g           :=Green(col);
      b           :=Blue (col);
      alpha1      :=alpha;
      d_alpha1    :=255-alpha1;
      alpha_shift1:=255-alpha;
      arr_src_ptr :=Unaligned(@arr_src[0]);
      for i:=0 to line_cnt-1 do
        begin
          pixel_ptr:=Unaligned(bmp_ptr+arr_src_ptr^.first_pt_x+rct_dst_left+bmp_width*(arr_src_ptr^.first_pt_y+rct_dst_top));
          case arr_src_ptr^.line_kind of
            00{00 - horizontal line: 2 points from left to right---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=alpha1+j*alpha_shift3;
                    d_alpha2  :=255-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clFuchsia);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                    Inc  (alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            01{01 - horizontal line: 2 points from right to left---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=255-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=255-alpha_shift3-j*alpha_shift3;
                    d_alpha2  :=255-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clBlue);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                    Dec  (alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            02{02 - horizontal line: outer line from ends to middle}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=alpha1+j*alpha_shift3;
                    d_alpha2  :=255-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                    Inc  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                    alpha2    :=255-alpha_shift3;
                    d_alpha2  :=    alpha_shift3;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                  end;
                alpha2:=255-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=255-j*alpha_shift3;
                    d_alpha2  :=255-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                    Dec  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=
                  //SetColorInv({clGreen}clPurple);
                  Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
              end; {$endregion}
            03{03 - horizontal line: inner line from middle to ends}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=255-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=255-j*alpha_shift3;
                    d_alpha2  :=255-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clWhite);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                    Dec  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                    alpha2    :=255+alpha_shift3;
                    d_alpha2  :=   -alpha_shift3;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                  end;
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=alpha1+j*alpha_shift3;
                    d_alpha2  :=255-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clWhite);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                    Inc  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=
                  //SetColorInv({clGreen}clWhite);
                  Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
              end; {$endregion}
            04{04 - horizontal line: const fill--------------------}: {$region -fold}
              begin

              end; {$endregion}
            05{05 - vertical   line: 2 points from top to bottom---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=alpha1+j*alpha_shift3;
                    d_alpha2  :=255-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clFuchsia);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                    Inc  (alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            06{06 - vertical   line: 2 points from bottom to top---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=255-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=255-alpha_shift3-j*alpha_shift3;
                    d_alpha2  :=255-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clBlue);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                    Dec  (alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            07{07 - vertical   line: inner line from ends to middle}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                    //alpha2    :=alpha1+j*alpha_shift3;
                    d_alpha2  :=255-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                    Inc  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                    alpha2    :=255-alpha_shift3;
                    d_alpha2  :=    alpha_shift3;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                  end;
                alpha2:=255-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                    //alpha2    :=255-j*alpha_shift3;
                    d_alpha2  :=255-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                    Dec  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=
                  //SetColorInv({clGreen}clPurple);
                  Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
              end; {$endregion}
            08{08 - vertical   line: outer line from middle to ends}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=255-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                    //alpha2    :=255-j*alpha_shift3;
                    d_alpha2  :=255-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clWhite);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                    Dec  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                    alpha2    :=255+alpha_shift3;
                    d_alpha2  :=   -alpha_shift3;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                  end;
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                    //alpha2    :=alpha1+j*alpha_shift3;
                    d_alpha2  :=255-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clWhite);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                    Inc  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=
                  //SetColorInv({clGreen}clWhite);
                  Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
              end; {$endregion}
            09{09 - vertical   line: const fill--------------------}: {$region -fold}
              begin

              end; {$endregion}
            10{10 - 1 point----------------------------------------}: {$region -fold}
              begin
                pixel_ptr^:=
                //SetColorInv(clRed);
                Func2(pixel_ptr^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
              end; {$endregion}
            11{11 - circle-----------------------------------------}: {$region -fold}
              begin
                (pixel_ptr               )^:=Func2((pixel_ptr               )^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
                (pixel_ptr+bmp_width   -1)^:=Func2((pixel_ptr+bmp_width   -1)^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
                (pixel_ptr+bmp_width   +1)^:=Func2((pixel_ptr+bmp_width   +1)^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
                (pixel_ptr+bmp_width<<1+0)^:=Func2((pixel_ptr+bmp_width<<1+0)^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
                (pixel_ptr             -1)^:=Func2((pixel_ptr             -1)^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
                (pixel_ptr             +1)^:=Func2((pixel_ptr             +1)^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
                (pixel_ptr+bmp_width<<1-1)^:=Func2((pixel_ptr+bmp_width<<1-1)^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
                (pixel_ptr+bmp_width<<1+1)^:=Func2((pixel_ptr+bmp_width<<1+1)^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
              end; {$endregion}
          end;
          Inc(arr_src_ptr);
        end;
    end;
end; {$endregion}
procedure BorderFill  (constref arr_src    :TAALnArr;   constref rct_dst_left,rct_dst_top:integer; constref bmp_ptr:PInteger; constref bmp_width:TColor;                       constref line_cnt        :TColor; constref col:TColor; args:TFunc0Args              ); {$region -fold}
var
  arr_src_ptr : PFastAALine;
  pixel_ptr   : Pinteger;
  i,j         : integer;
  alpha_shift3: integer;
  alpha_shift2: integer;
  alpha_shift1: byte;
    alpha1    : byte;
  d_alpha1    : byte;
    alpha2    : byte;
  d_alpha3    : TColor;
  d_alpha4    : TColor;
begin
  if (line_cnt=0) then
    Exit;
  with args do
    begin
      alpha1      :=000+alpha;
      d_alpha1    :=255-alpha;
      d_alpha3    :=d_alpha1<<24;
      d_alpha4    :=Max2(d_alpha1-150,0)<<24;
      alpha_shift1:=d_alpha1;
      arr_src_ptr :=Unaligned(@arr_src[0]);
      for i:=0 to line_cnt-1 do
        begin
          pixel_ptr:=Unaligned(bmp_ptr+arr_src_ptr^.first_pt_x+rct_dst_left+bmp_width*(arr_src_ptr^.first_pt_y+rct_dst_top));
          case arr_src_ptr^.line_kind of
            00{00 - horizontal line: 2 points from left to right---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(255-alpha2)<<24;
                    Inc(pixel_ptr);
                    Inc(alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            01{01 - horizontal line: 2 points from right to left---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=255-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(255-alpha2)<<24;
                    Inc(pixel_ptr);
                    Dec(alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            02{02 - horizontal line: outer line from ends to middle}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(255-alpha2)<<24;
                    Inc(pixel_ptr);
                    Inc(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                        pixel_ptr^:=alpha_shift3<<24;
                    Inc(pixel_ptr);
                  end;
                alpha2:=255-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                    pixel_ptr^:=(255-alpha2)<<24;
                    Inc  (pixel_ptr);
                    Dec  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=alpha_shift3<<24;
              end; {$endregion}
            03{03 - horizontal line: inner line from middle to ends}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=255-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(255-alpha2)<<24;
                    Inc(pixel_ptr);
                    Dec(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                        pixel_ptr^:=(-alpha_shift3)<<24;
                    Inc(pixel_ptr);
                  end;
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(255-alpha2)<<24;
                    Inc(pixel_ptr);
                    Inc(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=(255-alpha2)<<24;
              end; {$endregion}
            04{04 - horizontal line: const fill--------------------}: {$region -fold}
              begin

              end; {$endregion}
            05{05 - vertical   line: 2 points from top to bottom---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(255-alpha2)<<24;
                    Inc(pixel_ptr,bmp_width);
                    Inc(alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            06{06 - vertical   line: 2 points from bottom to top---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=255-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(255-alpha2)<<24;
                    Inc(pixel_ptr,bmp_width);
                    Dec(alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            07{07 - vertical   line: inner line from ends to middle}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(255-alpha2)<<24;
                    Inc(pixel_ptr,bmp_width);
                    Inc(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                    pixel_ptr^:=alpha_shift3<<24;
                    Inc(pixel_ptr,bmp_width);
                  end;
                alpha2:=255-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(255-alpha2)<<24;
                    Inc(pixel_ptr,bmp_width);
                    Dec(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=(255-alpha2)<<24;
              end; {$endregion}
            08{08 - vertical   line: outer line from middle to ends}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=255-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(255-alpha2)<<24;
                    Inc(pixel_ptr,bmp_width);
                    Dec(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                        pixel_ptr^:=(-alpha_shift3)<<24;
                    Inc(pixel_ptr,bmp_width);
                  end;
                alpha2:=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(255-alpha2)<<24;
                    Inc(pixel_ptr,bmp_width);
                    Inc(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=(255-alpha2)<<24;
              end; {$endregion}
            09{09 - vertical   line: const fill--------------------}: {$region -fold}
              begin

              end; {$endregion}
            10{10 - 1 point----------------------------------------}: {$region -fold}
              pixel_ptr^:=d_alpha1<<24; {$endregion}
            11{11 - circle-----------------------------------------}: {$region -fold}
              begin
                (pixel_ptr               )^:=d_alpha3;
                (pixel_ptr+bmp_width   -1)^:=d_alpha3;
                (pixel_ptr+bmp_width   +1)^:=d_alpha3;
                (pixel_ptr+bmp_width<<1+0)^:=d_alpha3;
                (pixel_ptr             -1)^:=d_alpha4;
                (pixel_ptr             +1)^:=d_alpha4;
                (pixel_ptr+bmp_width<<1-1)^:=d_alpha4;
                (pixel_ptr+bmp_width<<1+1)^:=d_alpha4;
              end; {$endregion}
          end;
          Inc(arr_src_ptr);
        end;
    end;
end; {$endregion}
procedure BorderFill  (constref arr_src    :TAALnArr;   constref rct_dst_left,rct_dst_top:integer; constref bmp_ptr:PByte   ; constref bmp_width:TColor;                       constref line_cnt        :TColor; constref col:TColor; args:TFunc0Args              ); {$region -fold}
var
  arr_src_ptr : PFastAALine;
  pixel_ptr   : PByte;
  i,j         : integer;
  alpha_shift3: integer;
  alpha_shift2: integer;
  alpha_shift1: byte;
    alpha1    : byte;
  d_alpha1    : byte;
    alpha2    : byte;
//d_alpha3    : byte;
  d_alpha4    : byte;
begin
  if (line_cnt=0) then
    Exit;
  with args do
    begin
      alpha1      :=000+alpha;
      d_alpha1    :=255-alpha;
      d_alpha4    :=Max2(d_alpha1-150,0);
      alpha_shift1:=d_alpha1;
      arr_src_ptr :=Unaligned(@arr_src[0]);
      for i:=0 to line_cnt-1 do
        begin
          pixel_ptr:=Unaligned(bmp_ptr+arr_src_ptr^.first_pt_x+rct_dst_left+bmp_width*(arr_src_ptr^.first_pt_y+rct_dst_top));
          case arr_src_ptr^.line_kind of
            00{00 - horizontal line: 2 points from left to right---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=255-alpha2;
                    Inc(pixel_ptr);
                    Inc(alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            01{01 - horizontal line: 2 points from right to left---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=255-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=255-alpha2;
                    Inc(pixel_ptr);
                    Dec(alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            02{02 - horizontal line: outer line from ends to middle}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=255-alpha2;
                    Inc(pixel_ptr);
                    Inc(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                        pixel_ptr^:=alpha_shift3;
                    Inc(pixel_ptr);
                  end;
                alpha2:=255-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                    pixel_ptr^:=255-alpha2;
                    Inc  (pixel_ptr);
                    Dec  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=alpha_shift3;
              end; {$endregion}
            03{03 - horizontal line: inner line from middle to ends}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=255-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=255-alpha2;
                    Inc(pixel_ptr);
                    Dec(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                        pixel_ptr^:=-alpha_shift3;
                    Inc(pixel_ptr);
                  end;
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=255-alpha2;
                    Inc(pixel_ptr);
                    Inc(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=255-alpha2;
              end; {$endregion}
            04{04 - horizontal line: const fill--------------------}: {$region -fold}
              begin

              end; {$endregion}
            05{05 - vertical   line: 2 points from top to bottom---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=255-alpha2;
                    Inc(pixel_ptr,bmp_width);
                    Inc(alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            06{06 - vertical   line: 2 points from bottom to top---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=255-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=255-alpha2;
                    Inc(pixel_ptr,bmp_width);
                    Dec(alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            07{07 - vertical   line: inner line from ends to middle}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=255-alpha2;
                    Inc(pixel_ptr,bmp_width);
                    Inc(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                    pixel_ptr^:=alpha_shift3;
                    Inc(pixel_ptr,bmp_width);
                  end;
                alpha2:=255-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=255-alpha2;
                    Inc(pixel_ptr,bmp_width);
                    Dec(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=255-alpha2;
              end; {$endregion}
            08{08 - vertical   line: outer line from middle to ends}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=255-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=255-alpha2;
                    Inc(pixel_ptr,bmp_width);
                    Dec(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                        pixel_ptr^:=-alpha_shift3;
                    Inc(pixel_ptr,bmp_width);
                  end;
                alpha2:=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=255-alpha2;
                    Inc(pixel_ptr,bmp_width);
                    Inc(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=255-alpha2;
              end; {$endregion}
            09{09 - vertical   line: const fill--------------------}: {$region -fold}
              begin

              end; {$endregion}
            10{10 - 1 point----------------------------------------}: {$region -fold}
              pixel_ptr^:=d_alpha1; {$endregion}
            11{11 - circle-----------------------------------------}: {$region -fold}
              begin
                (pixel_ptr               )^:=d_alpha1;
                (pixel_ptr+bmp_width   -1)^:=d_alpha1;
                (pixel_ptr+bmp_width   +1)^:=d_alpha1;
                (pixel_ptr+bmp_width<<1+0)^:=d_alpha1;
                (pixel_ptr             -1)^:=d_alpha4;
                (pixel_ptr             +1)^:=d_alpha4;
                (pixel_ptr+bmp_width<<1-1)^:=d_alpha4;
                (pixel_ptr+bmp_width<<1+1)^:=d_alpha4;
              end; {$endregion}
          end;
          Inc(arr_src_ptr);
        end;
    end;
end; {$endregion}

// One-Pixel Border-Blur Calculation:
procedure BorderPixCh (arr_src_ptr:PInteger; constref arr_src_width:TColor; constref background_color:TColor                          ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2              : PInteger;
  non_zero_pix_cnt          : byte=0;
  r0,r1,r2,r3,r4,r5,r6,r7,r8: byte;
  g0,g1,g2,g3,g4,g5,g6,g7,g8: byte;
  b0,b1,b2,b3,b4,b5,b6,b7,b8: byte;
begin
  // pixel-border scheme:
  // 012
  // 345
  // 678
  // 4 - arr_src_ptr;
  // 0,1,2,3,5,6,7,8 - pixel-border;
  arr_src_ptr2:=arr_src_ptr-arr_src_width-1;
  if (arr_src_ptr2^<>background_color) then
    begin
      r0:=arr_src_ptr2^{shr 00};
      g0:=arr_src_ptr2^ shr 08 ;
      b0:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r0:=0;
      g0:=0;
      b0:=0;
    end;
  arr_src_ptr2:=arr_src_ptr-arr_src_width;
  if (arr_src_ptr2^<>background_color) then
    begin
      r1:=arr_src_ptr2^{shr 00};
      g1:=arr_src_ptr2^ shr 08 ;
      b1:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r1:=0;
      g1:=0;
      b1:=0;
    end;
  arr_src_ptr2:=arr_src_ptr-arr_src_width+1;
  if (arr_src_ptr2^<>background_color) then
    begin
      r2:=arr_src_ptr2^{shr 00};
      g2:=arr_src_ptr2^ shr 08 ;
      b2:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r2:=0;
      g2:=0;
      b2:=0;
    end;
  arr_src_ptr2:=arr_src_ptr-1;
  if (arr_src_ptr2^<>background_color) then
    begin
      r3:=arr_src_ptr2^{shr 00};
      g3:=arr_src_ptr2^ shr 08 ;
      b3:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r3:=0;
      g3:=0;
      b3:=0;
    end;
  if (arr_src_ptr^<>background_color) then
    begin
      r4:=arr_src_ptr^{shr 00};
      g4:=arr_src_ptr^ shr 08 ;
      b4:=arr_src_ptr^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r4:=0;
      g4:=0;
      b4:=0;
    end;
  arr_src_ptr2:=arr_src_ptr+1;
  if (arr_src_ptr2^<>background_color) then
    begin
      r5:=arr_src_ptr2^{shr 00};
      g5:=arr_src_ptr2^ shr 08 ;
      b5:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r5:=0;
      g5:=0;
      b5:=0;
    end;
  arr_src_ptr2:=arr_src_ptr+arr_src_width-1;
  if (arr_src_ptr2^<>background_color) then
    begin
      r6:=arr_src_ptr2^{shr 00};
      g6:=arr_src_ptr2^ shr 08 ;
      b6:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r6:=0;
      g6:=0;
      b6:=0;
    end;
  arr_src_ptr2:=arr_src_ptr+arr_src_width;
  if (arr_src_ptr2^<>background_color) then
    begin
      r7:=arr_src_ptr2^{shr 00};
      g7:=arr_src_ptr2^ shr 08 ;
      b7:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r7:=0;
      g7:=0;
      b7:=0;
    end;
  arr_src_ptr2:=arr_src_ptr+arr_src_width+1;
  if (arr_src_ptr2^<>background_color) then
    begin
      r8:=arr_src_ptr2^{shr 00};
      g8:=arr_src_ptr2^ shr 08 ;
      b8:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r8:=0;
      g8:=0;
      b8:=0;
    end;
  arr_src_ptr^:={clRed}RGB(Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/non_zero_pix_cnt),
                           Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/non_zero_pix_cnt),
                           Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/non_zero_pix_cnt));
end; {$endregion}
procedure BorderPixCh (arr_src_ptr:PInteger; constref arr_src_width:TColor; constref alpha_color     :byte                            ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2              : PInteger;
  non_zero_pix_cnt          : byte=0;
  r0,r1,r2,r3,r4,r5,r6,r7,r8: byte;
  g0,g1,g2,g3,g4,g5,g6,g7,g8: byte;
  b0,b1,b2,b3,b4,b5,b6,b7,b8: byte;
begin
  // pixel-border scheme:
  // 012
  // 345
  // 678
  // 4 - arr_src_ptr;
  // 0,1,2,3,5,6,7,8 - pixel-border;
  arr_src_ptr2:=arr_src_ptr-arr_src_width-1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r0:=arr_src_ptr2^{shr 00};
      g0:=arr_src_ptr2^ shr 08 ;
      b0:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r0:=0;
      g0:=0;
      b0:=0;
    end;
  arr_src_ptr2:=arr_src_ptr-arr_src_width;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r1:=arr_src_ptr2^{shr 00};
      g1:=arr_src_ptr2^ shr 08 ;
      b1:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r1:=0;
      g1:=0;
      b1:=0;
    end;
  arr_src_ptr2:=arr_src_ptr-arr_src_width+1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r2:=arr_src_ptr2^{shr 00};
      g2:=arr_src_ptr2^ shr 08 ;
      b2:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r2:=0;
      g2:=0;
      b2:=0;
    end;
  arr_src_ptr2:=arr_src_ptr-1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r3:=arr_src_ptr2^{shr 00};
      g3:=arr_src_ptr2^ shr 08 ;
      b3:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r3:=0;
      g3:=0;
      b3:=0;
    end;
  {if (arr_src_ptr^>>24<>alpha_color) then
    begin
      r4:=arr_src_ptr^{shr 00};
      g4:=arr_src_ptr^ shr 08 ;
      b4:=arr_src_ptr^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r4:=0;
      g4:=0;
      b4:=0;
    end;}
  arr_src_ptr2:=arr_src_ptr+1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r5:=arr_src_ptr2^{shr 00};
      g5:=arr_src_ptr2^ shr 08 ;
      b5:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r5:=0;
      g5:=0;
      b5:=0;
    end;
  arr_src_ptr2:=arr_src_ptr+arr_src_width-1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r6:=arr_src_ptr2^{shr 00};
      g6:=arr_src_ptr2^ shr 08 ;
      b6:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r6:=0;
      g6:=0;
      b6:=0;
    end;
  arr_src_ptr2:=arr_src_ptr+arr_src_width;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r7:=arr_src_ptr2^{shr 00};
      g7:=arr_src_ptr2^ shr 08 ;
      b7:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r7:=0;
      g7:=0;
      b7:=0;
    end;
  arr_src_ptr2:=arr_src_ptr+arr_src_width+1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r8:=arr_src_ptr2^{shr 00};
      g8:=arr_src_ptr2^ shr 08 ;
      b8:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r8:=0;
      g8:=0;
      b8:=0;
    end;
  if (non_zero_pix_cnt in [0..4]) then
    Exit;
  arr_src_ptr^:={clRed}RGB(Trunc((r0+r1+r2+r3{+r4}+r5+r6+r7+r8)/non_zero_pix_cnt),
                           Trunc((g0+g1+g2+g3{+g4}+g5+g6+g7+g8)/non_zero_pix_cnt),
                           Trunc((b0+b1+b2+b3{+b4}+b5+b6+b7+b8)/non_zero_pix_cnt));
end; {$endregion}
procedure BorderPixCh (arr_src_ptr:PInteger; constref arr_src_width:TColor; constref alpha_color     :byte; constref alpha_mask:TColor); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2              : PInteger;
  non_zero_pix_cnt          : byte=0;
  r0,r1,r2,r3,r4,r5,r6,r7,r8: byte;
  g0,g1,g2,g3,g4,g5,g6,g7,g8: byte;
  b0,b1,b2,b3,b4,b5,b6,b7,b8: byte;
begin
  // pixel-border scheme:
  // 012
  // 345
  // 678
  // 4 - arr_src_ptr;
  // 0,1,2,3,5,6,7,8 - pixel-border;
  arr_src_ptr2:=arr_src_ptr-arr_src_width-1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r0:=arr_src_ptr2^{shr 00};
      g0:=arr_src_ptr2^ shr 08 ;
      b0:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r0:=0;
      g0:=0;
      b0:=0;
    end;
  arr_src_ptr2:=arr_src_ptr-arr_src_width;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r1:=arr_src_ptr2^{shr 00};
      g1:=arr_src_ptr2^ shr 08 ;
      b1:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r1:=0;
      g1:=0;
      b1:=0;
    end;
  arr_src_ptr2:=arr_src_ptr-arr_src_width+1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r2:=arr_src_ptr2^{shr 00};
      g2:=arr_src_ptr2^ shr 08 ;
      b2:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r2:=0;
      g2:=0;
      b2:=0;
    end;
  arr_src_ptr2:=arr_src_ptr-1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r3:=arr_src_ptr2^{shr 00};
      g3:=arr_src_ptr2^ shr 08 ;
      b3:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r3:=0;
      g3:=0;
      b3:=0;
    end;
  {if (arr_src_ptr^>>24<>alpha_color) then
    begin
      r4:=arr_src_ptr^{shr 00};
      g4:=arr_src_ptr^ shr 08 ;
      b4:=arr_src_ptr^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r4:=0;
      g4:=0;
      b4:=0;
    end;}
  arr_src_ptr2:=arr_src_ptr+1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r5:=arr_src_ptr2^{shr 00};
      g5:=arr_src_ptr2^ shr 08 ;
      b5:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r5:=0;
      g5:=0;
      b5:=0;
    end;
  arr_src_ptr2:=arr_src_ptr+arr_src_width-1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r6:=arr_src_ptr2^{shr 00};
      g6:=arr_src_ptr2^ shr 08 ;
      b6:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r6:=0;
      g6:=0;
      b6:=0;
    end;
  arr_src_ptr2:=arr_src_ptr+arr_src_width;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r7:=arr_src_ptr2^{shr 00};
      g7:=arr_src_ptr2^ shr 08 ;
      b7:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r7:=0;
      g7:=0;
      b7:=0;
    end;
  arr_src_ptr2:=arr_src_ptr+arr_src_width+1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r8:=arr_src_ptr2^{shr 00};
      g8:=arr_src_ptr2^ shr 08 ;
      b8:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r8:=0;
      g8:=0;
      b8:=0;
    end;
  if (non_zero_pix_cnt in [0..4{6}]) then
    Exit;
  arr_src_ptr^:={clRed}RGB(Trunc((r0+r1+r2+r3{+r4}+r5+r6+r7+r8)/non_zero_pix_cnt),
                           Trunc((g0+g1+g2+g3{+g4}+g5+g6+g7+g8)/non_zero_pix_cnt),
                           Trunc((b0+b1+b2+b3{+b4}+b5+b6+b7+b8)/non_zero_pix_cnt))<<8>>8+alpha_mask;
end; {$endregion}

// Border Blur:
procedure BorderBlur  (constref arr_src_ptr:PInteger ; var arr_dst:T1Byte1Arr; constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; constref background_color:TColor                    ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2         : PInteger;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
begin

  d_width1        :=                                    arr_src_width- rct_dst.width   ;
  d_width2        :=                                    arr_dst_width- rct_dst.width   ;
  arr_src_ptr2    :=Unaligned( arr_src_ptr+rct_dst.left+arr_src_width*(rct_dst.top+1) );
  arr_dst_ptr     :=Unaligned(@arr_dst    [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  Prefetch(arr_src_ptr2);
  Prefetch(arr_dst_ptr );
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_dst_ptr^=1) then
            BorderPixCh(arr_src_ptr2,arr_src_width,background_color);
          Inc(arr_src_ptr2);
          Inc(arr_dst_ptr );
        end;
      Inc(arr_src_ptr2,d_width1);
      Inc(arr_dst_ptr ,d_width2);
    end;
end; {$endregion}
procedure BorderBlur  (constref arr_src_ptr:PInteger ;                         constref arr_src_width              :TColor; constref rct_dst:TPtRect; constref alpha_color     :byte                      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2: PInteger;
  d_width,x,y : integer;
begin

  d_width     :=0000000000000000000000000000000000+arr_src_width- rct_dst.width  ;
  arr_src_ptr2:=Unaligned(arr_src_ptr+rct_dst.left+arr_src_width*(rct_dst.top+1));
  Prefetch(arr_src_ptr2);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr2^>>24=alpha_color) then
            {arr_src_ptr2^:=clRed;}BorderPixCh(arr_src_ptr2,arr_src_width,alpha_color);
          Inc(arr_src_ptr2);
        end;
      Inc(arr_src_ptr2,d_width);
    end;
end; {$endregion}
procedure BorderBlur  (constref arr_src_ptr:PInteger ;                         constref arr_src_width              :TColor; constref rct_dst:TPtRect; constref alpha_color     :byte; constref mask:TColor); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2: PInteger;
  d_width,x,y : integer;
begin
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  d_width     :=0000000000000000000000000000000000+arr_src_width- rct_dst.width  ;
  arr_src_ptr2:=Unaligned(arr_src_ptr+rct_dst.left+arr_src_width*(rct_dst.top+1));
  Prefetch(arr_src_ptr2);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr2^>>24=alpha_color) then
            {arr_src_ptr2^:=clRed;}BorderPixCh(arr_src_ptr2,arr_src_width,alpha_color,mask);
          Inc(arr_src_ptr2);
        end;
      Inc(arr_src_ptr2,d_width);
    end;
end; {$endregion}

procedure EdgeAATest  (constref bmp_dst_ptr:PInteger; constref rct_dst:TPtRect; constref bmp_dst_width:TColor; constref val1,val2:byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  dst_pixel_ptr             : PInteger;
  d_width                   : integer;
  x,y                       : integer;
  r0,r1,r2,r3,r4,r5,r6,r7,r8: boolean;
  v1,v2,v3                  : boolean;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(@bmp_dst_ptr[rct_dst.left+rct_dst.top*bmp_dst_width]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          r0:=Abs((dst_pixel_ptr^>>00)-((dst_pixel_ptr+              1)^>>00))>=val1;
          r1:=Abs((dst_pixel_ptr^>>08)-((dst_pixel_ptr+              1)^>>08))>=val1;
          r2:=Abs((dst_pixel_ptr^>>16)-((dst_pixel_ptr+              1)^>>16))>=val1;
          v1:=r0 and r1 and r2;
          r3:=Abs((dst_pixel_ptr^>>00)-((dst_pixel_ptr+bmp_dst_width+1)^>>00))>=val1;
          r4:=Abs((dst_pixel_ptr^>>08)-((dst_pixel_ptr+bmp_dst_width+1)^>>08))>=val1;
          r5:=Abs((dst_pixel_ptr^>>16)-((dst_pixel_ptr+bmp_dst_width+1)^>>16))>=val1;
          v2:=r3 and r4 and r5;
          r6:=Abs((dst_pixel_ptr^>>00)-((dst_pixel_ptr+bmp_dst_width  )^>>00))>=val1;
          r7:=Abs((dst_pixel_ptr^>>08)-((dst_pixel_ptr+bmp_dst_width  )^>>08))>=val1;
          r8:=Abs((dst_pixel_ptr^>>16)-((dst_pixel_ptr+bmp_dst_width  )^>>16))>=val1;
          v3:=r6 and r7 and r8;
          if v1 and v2 and (not v3) then
            BlurRGB(dst_pixel_ptr-1,bmp_dst_width) //(dst_pixel_ptr+bmp_dst_width)^:={clRed};
          else
          if v1 and (not v2) and v3 then
            BlurRGB(dst_pixel_ptr,bmp_dst_width) //(dst_pixel_ptr+bmp_dst_width)^:={clRed};
          else
          if (not v1) and v2 and v3 then
            BlurRGB(dst_pixel_ptr-bmp_dst_width-1,bmp_dst_width); //(dst_pixel_ptr+bmp_dst_width)^:={clRed};
          Inc     (dst_pixel_ptr);
        end;
      Inc         (dst_pixel_ptr,d_width);
    end;

end; {$endregion}
{$endregion}



(******************************* Bitmap Loading *******************************) {$region -fold}

function CrtTPicInstFromHDDSrc(constref location:string): TPicture;                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=TPicture.Create;
  Result.LoadFromFile(location);
end; {$endregion}
function CrtTBmpInstFromImgLst(constref ImgLstGetBmp:TProc1; constref img_ind:TColor=0): TBitmap;                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=TBitmap.Create;
  ImgLstGetBmp(img_ind,Result);
end; {$endregion}
function CrtTBmpInst          (constref bmp_src:TBitmap; var bmp_dst_ptr:PInteger): TBitmap;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      Result     :=TBitmap.Create;
      Width      :=bmp_src.width;
      Height     :=bmp_src.height;
      bmp_dst_ptr:=GetBmpHandle(Result);
      Canvas.Draw(0,0,bmp_src);
    end;
end; {$endregion}
function CrtTBmpInst          (constref bmp_dst_width,bmp_dst_height:TColor; var bmp_src_ptr:PInteger): TBitmap; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      Result     :=TBitmap.Create;
      PixelFormat:=pf32bit;
      Width      :=bmp_dst_width;
      Height     :=bmp_dst_height;
      bmp_src_ptr:=GetBmpHandle(Result);
    end;
end; {$endregion}
{$endregion}



(************************* Transparent Image Routines *************************) {$region -fold}

{Clear All Specified Buffers--------------------------} {$region -fold}
procedure TFastImage.ClrArr(arr_clear_val:word); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  {Color/Alpha of Current Layer} {$region -fold}

  // NT - not transparent pixels;
  if Odd(arr_clear_val>>10) then
    begin
      nt_pix_intr_ccl_arr:=Nil;
      {SetLength(nt_pix_intr_ccl_arr,1);
      nt_pix_intr_ccl_arr[0]:=0;}
    end;

  // PT - partly transparent pixels;
  // color channel;
  if Odd(arr_clear_val>>09) then
    begin
      pt_pix_intr_ccl_arr:=Nil;
      {SetLength(pt_pix_intr_ccl_arr,1);
      pt_pix_intr_ccl_arr[0]:=0;}
    end;
  // alpha channel
  if Odd(arr_clear_val>>08) then
    begin
      pt_pix_byte_acl_arr:=Nil;
      {SetLength(pt_pix_byte_acl_arr,1);
      pt_pix_byte_acl_arr[0]:=0;}
    end; {$endregion}

  {Color       of Lower   Layer} {$region -fold}

  // NT - not transparent pixels;
  if Odd(arr_clear_val>>07) then
    begin
      //nt_pix_intr_cll_arr:=Nil;
      {SetLength(nt_pix_intr_cll_arr,1);
      nt_pix_intr_cll_arr[0]:=0;}
    end;

  // PT - partly transparent pixels;
  if Odd(arr_clear_val>>06) then
    begin
      //pt_pix_intr_cll_arr:=Nil;
      {SetLength(pt_pix_intr_cll_arr,1);
      pt_pix_intr_cll_arr[0]:=0;}
    end; {$endregion}

  {Value       of Current Layer} {$region -fold}

  // NT - not transparent pixels;
  if Odd(arr_clear_val>>05) then
    begin
      //nt_pix_intr_val_arr:=Nil;
      {SetLength(nt_pix_intr_val_arr,1);
      nt_pix_intr_val_arr[0]:=0;}
    end;

  // PT - partly transparent pixels; reserved;
  if Odd(arr_clear_val>>04) then
    begin
      //pt_pix_intr_val_arr:=Nil;
      {SetLength(pt_pix_intr_val_arr,1);
      pt_pix_intr_val_arr[0]:=0;}
    end; {$endregion}

  {Counts of Items in Rows-----} {$region -fold}

  // NT - not transparent pixels;
  if Odd(arr_clear_val>>03) then
    begin
      nt_pix_intr_cnt_arr:=Nil;
      {SetLength(nt_pix_intr_cnt_arr,1);
      nt_pix_intr_cnt_arr[0]:=0;}
    end;

  // PT - partly transparent pixels;
  if Odd(arr_clear_val>>02) then
    begin
      pt_pix_intr_cnt_arr:=Nil;
      {SetLength(pt_pix_intr_cnt_arr,1);
      pt_pix_intr_cnt_arr[0]:=0;}
    end; {$endregion}

  {Items Shifts----------------} {$region -fold}

  // NT - not transparent pixels;
  if Odd(arr_clear_val>>01) then
    begin
      //nt_pix_intr_sht_arr:=Nil;
      {SetLength(nt_pix_intr_sht_arr,1);
      nt_pix_intr_sht_arr[0]:=0;}
    end;

  // PT - partly transparent pixels;
  if Odd(arr_clear_val>>00) then
    begin
      //pt_pix_intr_sht_arr:=Nil;
      {SetLength(pt_pix_intr_sht_arr,1);
      pt_pix_intr_sht_arr[0]:=0;}
    end; {$endregion}

end; {$endregion}
procedure TFastImage.ClrArr;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  {Color       of Lower   Layer} {$region -fold}
  // NT - not transparent pixels;
  nt_pix_intr_cll_arr:=Nil;
  // PT - partly transparent pixels;
  pt_pix_intr_cll_arr:=Nil; {$endregion}

  {Value       of Current Layer} {$region -fold}
  // NT - not transparent pixels;
  nt_pix_intr_val_arr:=Nil;
  // PT - partly transparent pixels; reserved;
  pt_pix_intr_val_arr:=Nil; {$endregion}

  {Items Shifts----------------} {$region -fold}
  // NT - not transparent pixels;
  nt_pix_intr_sht_arr:=Nil;
  // PT - partly transparent pixels;
  pt_pix_intr_sht_arr:=Nil; {$endregion}

end; {$endregion} {$endregion}

{Define Image Kind------------------------------------} {$region -fold}
procedure TFastImage.DetImageKind; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr  : PInteger;
  first_pix_alpha: integer;
  x,y            : integer;
  d_width        : integer;
begin

  if (bmp_ftimg_width =0) or (bmp_src_rct_clp.width =0) or
     (bmp_ftimg_height=0) or (bmp_src_rct_clp.height=0) then
    begin
      nt_pix_cnt:=0;
      pt_pix_cnt:=0;
      img_kind  :=10;
      Exit;
    end;

  if (img_kind=11) then
    begin
      nt_pix_cnt:=0;
      pt_pix_cnt:=0;
      Exit;
    end;

  if tile_map_calc then
    begin
      nt_pix_cnt:=0;
      pt_pix_cnt:=0;
      img_kind  :=12;
      Exit;
    end;

  d_width        := bmp_ftimg_width-bmp_src_rct_clp.width;
  pix_color_ptr  :=@bmp_color_ptr  [bmp_src_rct_clp.left+
                    bmp_ftimg_width*bmp_src_rct_clp.top];
  first_pix_alpha:=pix_color_ptr^>>24;
  zr_pix_cnt     :=0;
  pt_pix_cng_cnt :=0;
  nt_pix_cnt     :=0;
  pt_pix_cnt     :=0;
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_color_ptr^<<08=000) then
            Inc(zr_pix_cnt);
          if (pix_color_ptr^>>24=alpha_max) then
            Inc(nt_pix_cnt);
          if (pix_color_ptr^>>24>000) and (pix_color_ptr^>>24<alpha_max) then
            begin
              if (pix_color_ptr^>>24=first_pix_alpha) then
                Inc(pt_pix_cng_cnt);
              Inc(pt_pix_cnt);
            end;
          Inc(pix_color_ptr);
        end;
      Inc(pix_color_ptr,d_width)
    end;

  if (pt_pix_cng_cnt<>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (zr_pix_cnt    <>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (nt_pix_cnt     >0)                                            and
     (pt_pix_cnt     >0)                                            then
    img_kind:=0;

  if (pt_pix_cng_cnt<>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (zr_pix_cnt    <>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (nt_pix_cnt     >0)                                            and
     (pt_pix_cnt     =0)                                            then
    img_kind:=1;

  if (pt_pix_cng_cnt<>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (zr_pix_cnt    <>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (nt_pix_cnt     =0)                                            and
     (pt_pix_cnt     >0)                                            then
    img_kind:=2;

  if (pt_pix_cng_cnt<>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (zr_pix_cnt    <>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
    ((nt_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) or
     (nt_pix_cnt     =0))                                           and
     (pt_pix_cnt     =0)                                            then
    img_kind:=3;

  if (pt_pix_cng_cnt =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (zr_pix_cnt    <>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (nt_pix_cnt     =0)                                            and
     (pt_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) then
    begin
      col_trans_arr[2]:=first_pix_alpha;
      img_kind:=4;
    end;

  if (pt_pix_cng_cnt<>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (zr_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (nt_pix_cnt     >0)                                            and
     (pt_pix_cnt     >0)                                            then
    img_kind:=5;

  if (pt_pix_cng_cnt<>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (zr_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (nt_pix_cnt     >0)                                            and
     (pt_pix_cnt     =0)                                            then
    img_kind:=6;

  if (pt_pix_cng_cnt<>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (zr_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (nt_pix_cnt     =0)                                            and
     (pt_pix_cnt     >0)                                            then
    img_kind:=7;

  if (pt_pix_cng_cnt =0)                                            and
     (zr_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (nt_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (pt_pix_cnt     =0)                                            then
    img_kind:=8;

  if (pt_pix_cng_cnt =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (zr_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (nt_pix_cnt     =0)                                            and
     (pt_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) then
    img_kind:=9;

  if (pt_pix_cng_cnt =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (zr_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
     (nt_pix_cnt     =0)                                            and
     (pt_pix_cnt     =0)                                            then
    img_kind:=10;

  nt_pix_cnt:=0;
  pt_pix_cnt:=0;

end; {$endregion} {$endregion}

{Create Array    of Items Counts  in Rows from Bitmap-} {$region -fold}
// color and alpha are in separate bitmaps
// NT - not transparent pixels;
procedure TFastImage.CrtNTCountBmpS; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr             : PInteger;
  nt_pix_cnt_arr_ptr        : PInteger;
  nt_pix_arr_row_mrg_btm_ptr: PInteger;
  nt_pix_cnt_row            : integer=0;
  x,y,i                     : integer;
  d_width                   : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    Exit;
  SetLength(nt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
  d_width           :=bmp_ftimg_width-bmp_src_rct_clp.width;
  nt_pix_cnt        :=0;
  nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000]);
  pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_alpha_ptr^=$FFFFFF) then
            Inc(nt_pix_cnt_row);
          Inc(pix_alpha_ptr);
        end;
      if (nt_pix_cnt_row<>0) then
        begin
          nt_pix_cnt_arr_ptr^:=nt_pix_cnt_row;
          nt_pix_cnt         +=nt_pix_cnt_row;
          nt_pix_cnt_row     :=0;
        end;
      Inc(nt_pix_cnt_arr_ptr);
      Inc(pix_alpha_ptr,d_width);
    end;
  if (nt_pix_cnt=0) then
    Exit;

  {Find Top Margin Value}
  nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[0]);
  for i:=0 to bmp_src_rct_clp.height-1 do
    begin
      if (nt_pix_cnt_arr_ptr^<>0) then
        Break;
      Inc(nt_pix_cnt_arr_ptr);
    end;
  nt_pix_arr_row_mrg_top:=PInteger(nt_pix_cnt_arr_ptr)-PInteger(@nt_pix_intr_cnt_arr[0]);

  {Find Bottom Margin Value}
  if (nt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
    begin
      nt_pix_arr_row_mrg_btm_ptr:=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
      nt_pix_cnt_arr_ptr        :=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
      for i:=0 to Abs(bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-2) do
        begin
          if (nt_pix_cnt_arr_ptr^<>0) then
            nt_pix_arr_row_mrg_btm_ptr:=nt_pix_cnt_arr_ptr;
          Inc(nt_pix_cnt_arr_ptr);
        end;
      if (nt_pix_cnt_arr_ptr^<>0) then
        nt_pix_arr_row_mrg_btm_ptr:=nt_pix_cnt_arr_ptr;
      nt_pix_arr_row_mrg_btm:=PInteger(@nt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-PInteger(nt_pix_arr_row_mrg_btm_ptr);
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImage.CrtPTCountBmpS; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr             : PInteger;
  pt_pix_cnt_arr_ptr        : PInteger;
  pt_pix_arr_row_mrg_btm_ptr: PInteger;
  pt_pix_cnt_row            : integer=0;
  x,y,i                     : integer;
  d_width                   : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    Exit;
  SetLength(pt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
  d_width           :=bmp_ftimg_width-bmp_src_rct_clp.width;
  pt_pix_cnt        :=0;
  pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000]);
  pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<alpha_max) then
            Inc(pt_pix_cnt_row);
          Inc(pix_alpha_ptr,4);
        end;
      if (pt_pix_cnt_row<>0) then
        begin
          pt_pix_cnt_arr_ptr^:=pt_pix_cnt_row;
          pt_pix_cnt         +=pt_pix_cnt_row;
          pt_pix_cnt_row     :=0;
        end;
      Inc(pt_pix_cnt_arr_ptr);
      Inc(pix_alpha_ptr,d_width<<2);
    end;
  if (pt_pix_cnt=0) then
    Exit;

  {Find Top Margin Value}
  pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[0]);
  for i:=0 to bmp_src_rct_clp.height-1 do
    begin
      if (pt_pix_cnt_arr_ptr^<>0) then
        Break;
      Inc(pt_pix_cnt_arr_ptr);
    end;
  pt_pix_arr_row_mrg_top:=PInteger(pt_pix_cnt_arr_ptr)-PInteger(@pt_pix_intr_cnt_arr[0]);

  {Find Bottom Margin Value}
  if (pt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
    begin
      pt_pix_arr_row_mrg_btm_ptr:=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
      pt_pix_cnt_arr_ptr        :=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
      for i:=0 to Abs(bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-2) do
        begin
          if (pt_pix_cnt_arr_ptr^<>0) then
            pt_pix_arr_row_mrg_btm_ptr:=pt_pix_cnt_arr_ptr;
          Inc(pt_pix_cnt_arr_ptr);
        end;
      if (pt_pix_cnt_arr_ptr^<>0) then
        pt_pix_arr_row_mrg_btm_ptr:=pt_pix_cnt_arr_ptr;
      pt_pix_arr_row_mrg_btm:=PInteger(@pt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-PInteger(pt_pix_arr_row_mrg_btm_ptr);
    end;
end; {$endregion}
// color and alpha are in one bitmap
// NT - not transparent pixels;
procedure TFastImage.CrtNTCountBmpO; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr             : PInteger;
  nt_pix_cnt_arr_ptr        : PInteger;
  nt_pix_arr_row_mrg_btm_ptr: PInteger;
  nt_pix_cnt_row            : integer=0;
  x,y,i                     : integer;
  d_width                   : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    Exit;
  SetLength(nt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
  d_width           :=bmp_ftimg_width-bmp_src_rct_clp.width;
  nt_pix_cnt        :=0;
  nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000]);
  pix_color_ptr     :=Unaligned(@bmp_color_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_color_ptr^>>24=alpha_max) then
            Inc(nt_pix_cnt_row);
          Inc(pix_color_ptr);
        end;
      if (nt_pix_cnt_row<>0) then
        begin
          nt_pix_cnt_arr_ptr^:=nt_pix_cnt_row;
          nt_pix_cnt         +=nt_pix_cnt_row;
          nt_pix_cnt_row     :=0;
        end;
      Inc(nt_pix_cnt_arr_ptr);
      Inc(pix_color_ptr,d_width);
    end;
  if (nt_pix_cnt=0) then
    Exit;

  {Find Top Margin Value}
  nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[0]);
  for i:=0 to bmp_src_rct_clp.height-1 do
    begin
      if (nt_pix_cnt_arr_ptr^<>0) then
        Break;
      Inc(nt_pix_cnt_arr_ptr);
    end;
  nt_pix_arr_row_mrg_top:=PInteger(nt_pix_cnt_arr_ptr)-PInteger(@nt_pix_intr_cnt_arr[0]);

  {Find Bottom Margin Value}
  if (nt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
    begin
      nt_pix_arr_row_mrg_btm_ptr:=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
      nt_pix_cnt_arr_ptr        :=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
      for i:=0 to Abs(bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-2) do
        begin
          if (nt_pix_cnt_arr_ptr^<>0) then
            nt_pix_arr_row_mrg_btm_ptr:=nt_pix_cnt_arr_ptr;
          Inc(nt_pix_cnt_arr_ptr);
        end;
      if (nt_pix_cnt_arr_ptr^<>0) then
        nt_pix_arr_row_mrg_btm_ptr:=nt_pix_cnt_arr_ptr;
      nt_pix_arr_row_mrg_btm:=PInteger(@nt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-PInteger(nt_pix_arr_row_mrg_btm_ptr);
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImage.CrtPTCountBmpO; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr             : PInteger;
  pt_pix_cnt_arr_ptr        : PInteger;
  pt_pix_arr_row_mrg_btm_ptr: PInteger;
  pt_pix_cnt_row            : integer=0;
  x,y,i                     : integer;
  d_width                   : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    Exit;
  SetLength(pt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
  d_width           :=bmp_ftimg_width-bmp_src_rct_clp.width;
  pt_pix_cnt        :=0;
  pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000]);
  pix_color_ptr     :=Unaligned(@bmp_color_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_color_ptr^>>24>0) and (pix_color_ptr^>>24<alpha_max) then
            Inc(pt_pix_cnt_row);
          Inc(pix_color_ptr);
        end;
      if (pt_pix_cnt_row<>0) then
        begin
          pt_pix_cnt_arr_ptr^:=pt_pix_cnt_row;
          pt_pix_cnt         +=pt_pix_cnt_row;
          pt_pix_cnt_row     :=0;
        end;
      Inc(pt_pix_cnt_arr_ptr);
      Inc(pix_color_ptr,d_width);
    end;
  if (pt_pix_cnt=0) then
    Exit;

  {Find Top Margin Value}
  pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[0]);
  for i:=0 to bmp_src_rct_clp.height-1 do
    begin
      if (pt_pix_cnt_arr_ptr^<>0) then
        Break;
      Inc(pt_pix_cnt_arr_ptr);
    end;
  pt_pix_arr_row_mrg_top:=PInteger(pt_pix_cnt_arr_ptr)-PInteger(@pt_pix_intr_cnt_arr[0]);

  {Find Bottom Margin Value}
  if (pt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
    begin
      pt_pix_arr_row_mrg_btm_ptr:=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
      pt_pix_cnt_arr_ptr        :=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
      for i:=0 to Abs(bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-2) do
        begin
          if (pt_pix_cnt_arr_ptr^<>0) then
            pt_pix_arr_row_mrg_btm_ptr:=pt_pix_cnt_arr_ptr;
          Inc(pt_pix_cnt_arr_ptr);
        end;
      if (pt_pix_cnt_arr_ptr^<>0) then
        pt_pix_arr_row_mrg_btm_ptr:=pt_pix_cnt_arr_ptr;
      pt_pix_arr_row_mrg_btm:=PInteger(@pt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-PInteger(pt_pix_arr_row_mrg_btm_ptr);
    end;
end; {$endregion} {$endregion}

{Create Array    of Items Counts  in Rows from Array--} {$region -fold}
// NT - not transparent pixels;
procedure TFastImage.CrtNTCountArrA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr             : PInteger;
  nt_pix_cnt_arr_ptr        : PInteger;
  nt_pix_arr_row_mrg_btm_ptr: PInteger;
  nt_pix_cnt_row            : integer=0;
  x,y,i,n                   : integer;
  d_width                   : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    begin
      nt_pix_cnt:=0;
      Exit;
    end;
  //SetLength(nt_pix_intr_cnt_arr,0);
  SetLength(nt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
  d_width           :=bmp_ftimg_width-bmp_src_rct_clp.width;
  nt_pix_cnt        :=0;
  nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000]);
  pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_alpha_ptr^{>}<>0) then
            Inc(nt_pix_cnt_row);
          Inc(pix_alpha_ptr);
        end;
      if (nt_pix_cnt_row<>0) then
        begin
          nt_pix_cnt_arr_ptr^:=nt_pix_cnt_row;
          nt_pix_cnt         +=nt_pix_cnt_row;
          nt_pix_cnt_row     :=0;
        end;
      Inc(nt_pix_cnt_arr_ptr);
      Inc(pix_alpha_ptr,d_width);
    end;
  if (nt_pix_cnt=0) then
    Exit;

  {Find Top Margin Value}
  nt_pix_arr_row_mrg_top:=0;
  nt_pix_cnt_arr_ptr    :=Unaligned(@nt_pix_intr_cnt_arr[0]);
  for i:=0 to bmp_src_rct_clp.height-1 do
    begin
      if (nt_pix_cnt_arr_ptr^<>0) then
        Break;
      Inc(nt_pix_cnt_arr_ptr);
    end;
  nt_pix_arr_row_mrg_top:=PInteger(nt_pix_cnt_arr_ptr)-PInteger(@nt_pix_intr_cnt_arr[0]);

  {Find Bottom Margin Value}
  if (nt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
    begin
      nt_pix_arr_row_mrg_btm    :=0;
      nt_pix_arr_row_mrg_btm_ptr:=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
      nt_pix_cnt_arr_ptr        :=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
      for i:=0 to Abs(bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-2) do
        begin
          if (nt_pix_cnt_arr_ptr^<>0) then
            nt_pix_arr_row_mrg_btm_ptr:=nt_pix_cnt_arr_ptr;
          Inc(nt_pix_cnt_arr_ptr);
        end;
      if (nt_pix_cnt_arr_ptr^<>0) then
        nt_pix_arr_row_mrg_btm_ptr:=nt_pix_cnt_arr_ptr;
      n:=PInteger(@nt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-PInteger(nt_pix_arr_row_mrg_btm_ptr);
      if (n>0) then
        nt_pix_arr_row_mrg_btm:=n;
    end;
end; {$endregion}
procedure TFastImage.CrtNTCountArrB; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr             : PByte;
  nt_pix_cnt_arr_ptr        : PInteger;
  nt_pix_arr_row_mrg_btm_ptr: PInteger;
  nt_pix_cnt_row            : integer=0;
  x,y,i,n                   : integer;
  d_width                   : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    begin
      nt_pix_cnt:=0;
      Exit;
    end;
  //SetLength(nt_pix_intr_cnt_arr,0);
  SetLength(nt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
  d_width           :=bmp_ftimg_width-bmp_src_rct_clp.width;
  nt_pix_cnt        :=0;
  nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000]);
  pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr2     [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_alpha_ptr^{>}<>0) then
            Inc(nt_pix_cnt_row);
          Inc(pix_alpha_ptr);
        end;
      if (nt_pix_cnt_row<>0) then
        begin
          nt_pix_cnt_arr_ptr^:=nt_pix_cnt_row;
          nt_pix_cnt         +=nt_pix_cnt_row;
          nt_pix_cnt_row     :=0;
        end;
      Inc(nt_pix_cnt_arr_ptr);
      Inc(pix_alpha_ptr,d_width);
    end;
  if (nt_pix_cnt=0) then
    Exit;

  {Find Top Margin Value}
  nt_pix_arr_row_mrg_top:=0;
  nt_pix_cnt_arr_ptr    :=Unaligned(@nt_pix_intr_cnt_arr[0]);
  for i:=0 to bmp_src_rct_clp.height-1 do
    begin
      if (nt_pix_cnt_arr_ptr^<>0) then
        Break;
      Inc(nt_pix_cnt_arr_ptr);
    end;
  nt_pix_arr_row_mrg_top:=PInteger(nt_pix_cnt_arr_ptr)-PInteger(@nt_pix_intr_cnt_arr[0]);

  {Find Bottom Margin Value}
  if (nt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
    begin
      nt_pix_arr_row_mrg_btm    :=0;
      nt_pix_arr_row_mrg_btm_ptr:=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
      nt_pix_cnt_arr_ptr        :=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
      for i:=0 to Abs(bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-2) do
        begin
          if (nt_pix_cnt_arr_ptr^<>0) then
            nt_pix_arr_row_mrg_btm_ptr:=nt_pix_cnt_arr_ptr;
          Inc(nt_pix_cnt_arr_ptr);
        end;
      if (nt_pix_cnt_arr_ptr^<>0) then
        nt_pix_arr_row_mrg_btm_ptr:=nt_pix_cnt_arr_ptr;
      n:=PInteger(@nt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-PInteger(nt_pix_arr_row_mrg_btm_ptr);
      if (n>0) then
        nt_pix_arr_row_mrg_btm:=n;
    end;
end; {$endregion}
procedure TFastImage.CrtNTCountArrC; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr             : PInteger;
  nt_pix_cnt_arr_ptr        : PInteger;
  nt_pix_arr_row_mrg_btm_ptr: PInteger;
  nt_pix_cnt_row            : integer=0;
  x,y,i,n                   : integer;
  d_width                   : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    begin
      nt_pix_cnt:=0;
      Exit;
    end;
  //SetLength(nt_pix_intr_cnt_arr,0);
  SetLength(nt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
  d_width           :=bmp_ftimg_width-bmp_src_rct_clp.width;
  nt_pix_cnt        :=0;
  nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000]);
  pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          Inc(nt_pix_cnt_row,(pix_alpha_ptr^+NZ_ITEM_COEFF22)>>NZ_ITEM_COEFF12);
          Inc(pix_alpha_ptr);
        end;
      if (nt_pix_cnt_row<>0) then
        begin
          nt_pix_cnt_arr_ptr^:=nt_pix_cnt_row;
          nt_pix_cnt         +=nt_pix_cnt_row;
          nt_pix_cnt_row     :=0;
        end;
      Inc(nt_pix_cnt_arr_ptr);
      Inc(pix_alpha_ptr,d_width);
    end;
  if (nt_pix_cnt=0) then
    Exit;

  {Find Top Margin Value}
  nt_pix_arr_row_mrg_top:=0;
  nt_pix_cnt_arr_ptr    :=Unaligned(@nt_pix_intr_cnt_arr[0]);
  for i:=0 to bmp_src_rct_clp.height-1 do
    begin
      if (nt_pix_cnt_arr_ptr^<>0) then
        Break;
      Inc(nt_pix_cnt_arr_ptr);
    end;
  nt_pix_arr_row_mrg_top:=PInteger(nt_pix_cnt_arr_ptr)-PInteger(@nt_pix_intr_cnt_arr[0]);

  {Find Bottom Margin Value}
  if (nt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
    begin
      nt_pix_arr_row_mrg_btm    :=0;
      nt_pix_arr_row_mrg_btm_ptr:=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
      nt_pix_cnt_arr_ptr        :=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
      for i:=0 to Abs(bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-2) do
        begin
          if (nt_pix_cnt_arr_ptr^<>0) then
            nt_pix_arr_row_mrg_btm_ptr:=nt_pix_cnt_arr_ptr;
          Inc(nt_pix_cnt_arr_ptr);
        end;
      if (nt_pix_cnt_arr_ptr^<>0) then
        nt_pix_arr_row_mrg_btm_ptr:=nt_pix_cnt_arr_ptr;
      n:=PInteger(@nt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-PInteger(nt_pix_arr_row_mrg_btm_ptr);
      if (n>0) then
        nt_pix_arr_row_mrg_btm:=n;
    end;
end; {$endregion}
procedure TFastImage.CrtNTCountArrD; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr             : PByte;
  nt_pix_cnt_arr_ptr        : PInteger;
  nt_pix_arr_row_mrg_btm_ptr: PInteger;
  nt_pix_cnt_row            : integer=0;
  x,y,i,n                   : integer;
  d_width                   : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    begin
      nt_pix_cnt:=0;
      Exit;
    end;
  //SetLength(nt_pix_intr_cnt_arr,0);
  SetLength(nt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
  d_width           :=bmp_ftimg_width-bmp_src_rct_clp.width;
  nt_pix_cnt        :=0;
  nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000]);
  pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr2     [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          Inc(nt_pix_cnt_row,(pix_alpha_ptr^+NZ_ITEM_COEFF20)>>NZ_ITEM_COEFF10);
          Inc(pix_alpha_ptr);
        end;
      if (nt_pix_cnt_row<>0) then
        begin
          nt_pix_cnt_arr_ptr^:=nt_pix_cnt_row;
          nt_pix_cnt         +=nt_pix_cnt_row;
          nt_pix_cnt_row     :=0;
        end;
      Inc(nt_pix_cnt_arr_ptr);
      Inc(pix_alpha_ptr,d_width);
    end;
  if (nt_pix_cnt=0) then
    Exit;

  {Find Top Margin Value}
  nt_pix_arr_row_mrg_top:=0;
  nt_pix_cnt_arr_ptr    :=Unaligned(@nt_pix_intr_cnt_arr[0]);
  for i:=0 to bmp_src_rct_clp.height-1 do
    begin
      if (nt_pix_cnt_arr_ptr^<>0) then
        Break;
      Inc(nt_pix_cnt_arr_ptr);
    end;
  nt_pix_arr_row_mrg_top:=PInteger(nt_pix_cnt_arr_ptr)-PInteger(@nt_pix_intr_cnt_arr[0]);

  {Find Bottom Margin Value}
  if (nt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
    begin
      nt_pix_arr_row_mrg_btm    :=0;
      nt_pix_arr_row_mrg_btm_ptr:=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
      nt_pix_cnt_arr_ptr        :=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
      for i:=0 to Abs(bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-2) do
        begin
          if (nt_pix_cnt_arr_ptr^<>0) then
            nt_pix_arr_row_mrg_btm_ptr:=nt_pix_cnt_arr_ptr;
          Inc(nt_pix_cnt_arr_ptr);
        end;
      if (nt_pix_cnt_arr_ptr^<>0) then
        nt_pix_arr_row_mrg_btm_ptr:=nt_pix_cnt_arr_ptr;
      n:=PInteger(@nt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-PInteger(nt_pix_arr_row_mrg_btm_ptr);
      if (n>0) then
        nt_pix_arr_row_mrg_btm:=n;
    end;
end; {$endregion}

// PT - partly transparent pixels;
procedure TFastImage.CrtPTCountArrA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr             : PInteger;
  pt_pix_cnt_arr_ptr        : PInteger;
  pt_pix_arr_row_mrg_btm_ptr: PInteger;
  pt_pix_cnt_row            : integer=0;
  x,y,i,p                   : integer;
  d_width                   : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    begin
      pt_pix_cnt:=0;
      Exit;
    end;
  //SetLength(pt_pix_intr_cnt_arr,0);
  SetLength(pt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
  d_width           :=bmp_ftimg_width-bmp_src_rct_clp.width;
  pt_pix_cnt        :=0;
  pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000]);
  pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_alpha_ptr^{>}<>0) then
            Inc(pt_pix_cnt_row);
          Inc(pix_alpha_ptr);
        end;
      if (pt_pix_cnt_row<>0) then
        begin
          pt_pix_cnt_arr_ptr^:=pt_pix_cnt_row;
          pt_pix_cnt         +=pt_pix_cnt_row;
          pt_pix_cnt_row     :=0;
        end;
      Inc(pt_pix_cnt_arr_ptr);
      Inc(pix_alpha_ptr,d_width);
    end;
  if (pt_pix_cnt=0) then
    Exit;

  {Find Top Margin Value}
  pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[0]);
  for i:=0 to bmp_src_rct_clp.height-1 do
    begin
      if (pt_pix_cnt_arr_ptr^<>0) then
        Break;
      Inc(pt_pix_cnt_arr_ptr);
    end;
  pt_pix_arr_row_mrg_top:=PInteger(pt_pix_cnt_arr_ptr)-PInteger(@pt_pix_intr_cnt_arr[0]);

  {Find Bottom Margin Value}
  if (pt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
    begin
      pt_pix_arr_row_mrg_btm_ptr:=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
      pt_pix_cnt_arr_ptr        :=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
      for i:=0 to Abs(bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-2) do
        begin
          if (pt_pix_cnt_arr_ptr^<>0) then
            pt_pix_arr_row_mrg_btm_ptr:=pt_pix_cnt_arr_ptr;
          Inc(pt_pix_cnt_arr_ptr);
        end;
      if (pt_pix_cnt_arr_ptr^<>0) then
        pt_pix_arr_row_mrg_btm_ptr:=pt_pix_cnt_arr_ptr;
      p:=PInteger(@pt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-PInteger(pt_pix_arr_row_mrg_btm_ptr);
      if (p>0) then
        pt_pix_arr_row_mrg_btm:=p;
    end;
end; {$endregion}
procedure TFastImage.CrtPTCountArrB; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr             : PByte;
  pt_pix_cnt_arr_ptr        : PInteger;
  pt_pix_arr_row_mrg_btm_ptr: PInteger;
  pt_pix_cnt_row            : integer=0;
  x,y,i,p                   : integer;
  d_width                   : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    begin
      pt_pix_cnt:=0;
      Exit;
    end;
  //SetLength(pt_pix_intr_cnt_arr,0);
  SetLength(pt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
  d_width           :=bmp_ftimg_width-bmp_src_rct_clp.width;
  pt_pix_cnt        :=0;
  pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000]);
  pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr2      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_alpha_ptr^{>}<>0) then
            Inc(pt_pix_cnt_row);
          Inc(pix_alpha_ptr);
        end;
      if (pt_pix_cnt_row<>0) then
        begin
          pt_pix_cnt_arr_ptr^:=pt_pix_cnt_row;
          pt_pix_cnt         +=pt_pix_cnt_row;
          pt_pix_cnt_row     :=0;
        end;
      Inc(pt_pix_cnt_arr_ptr);
      Inc(pix_alpha_ptr,d_width);
    end;
  if (pt_pix_cnt=0) then
    Exit;

  {Find Top Margin Value}
  pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[0]);
  for i:=0 to bmp_src_rct_clp.height-1 do
    begin
      if (pt_pix_cnt_arr_ptr^<>0) then
        Break;
      Inc(pt_pix_cnt_arr_ptr);
    end;
  pt_pix_arr_row_mrg_top:=PInteger(pt_pix_cnt_arr_ptr)-PInteger(@pt_pix_intr_cnt_arr[0]);

  {Find Bottom Margin Value}
  if (pt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
    begin
      pt_pix_arr_row_mrg_btm_ptr:=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
      pt_pix_cnt_arr_ptr        :=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
      for i:=0 to Abs(bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-2) do
        begin
          if (pt_pix_cnt_arr_ptr^<>0) then
            pt_pix_arr_row_mrg_btm_ptr:=pt_pix_cnt_arr_ptr;
          Inc(pt_pix_cnt_arr_ptr);
        end;
      if (pt_pix_cnt_arr_ptr^<>0) then
        pt_pix_arr_row_mrg_btm_ptr:=pt_pix_cnt_arr_ptr;
      p:=PInteger(@pt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-PInteger(pt_pix_arr_row_mrg_btm_ptr);
      if (p>0) then
        pt_pix_arr_row_mrg_btm:=p;
    end;
end; {$endregion}
procedure TFastImage.CrtPTCountArrC; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr             : PInteger;
  pt_pix_cnt_arr_ptr        : PInteger;
  pt_pix_arr_row_mrg_btm_ptr: PInteger;
  pt_pix_cnt_row            : integer=0;
  x,y,i,p                   : integer;
  d_width                   : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    begin
      pt_pix_cnt:=0;
      Exit;
    end;
  //SetLength(pt_pix_intr_cnt_arr,0);
  SetLength(pt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
  d_width           :=bmp_ftimg_width-bmp_src_rct_clp.width;
  pt_pix_cnt        :=0;
  pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000]);
  pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          Inc(pt_pix_cnt_row,(pix_alpha_ptr^+NZ_ITEM_COEFF22)>>NZ_ITEM_COEFF12);
          Inc(pix_alpha_ptr);
        end;
      if (pt_pix_cnt_row<>0) then
        begin
          pt_pix_cnt_arr_ptr^:=pt_pix_cnt_row;
          pt_pix_cnt         +=pt_pix_cnt_row;
          pt_pix_cnt_row     :=0;
        end;
      Inc(pt_pix_cnt_arr_ptr);
      Inc(pix_alpha_ptr,d_width);
    end;
  if (pt_pix_cnt=0) then
    Exit;

  {Find Top Margin Value}
  pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[0]);
  for i:=0 to bmp_src_rct_clp.height-1 do
    begin
      if (pt_pix_cnt_arr_ptr^<>0) then
        Break;
      Inc(pt_pix_cnt_arr_ptr);
    end;
  pt_pix_arr_row_mrg_top:=PInteger(pt_pix_cnt_arr_ptr)-PInteger(@pt_pix_intr_cnt_arr[0]);

  {Find Bottom Margin Value}
  if (pt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
    begin
      pt_pix_arr_row_mrg_btm_ptr:=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
      pt_pix_cnt_arr_ptr        :=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
      for i:=0 to Abs(bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-2) do
        begin
          if (pt_pix_cnt_arr_ptr^<>0) then
            pt_pix_arr_row_mrg_btm_ptr:=pt_pix_cnt_arr_ptr;
          Inc(pt_pix_cnt_arr_ptr);
        end;
      if (pt_pix_cnt_arr_ptr^<>0) then
        pt_pix_arr_row_mrg_btm_ptr:=pt_pix_cnt_arr_ptr;
      p:=PInteger(@pt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-PInteger(pt_pix_arr_row_mrg_btm_ptr);
      if (p>0) then
        pt_pix_arr_row_mrg_btm:=p;
    end;
end; {$endregion}
procedure TFastImage.CrtPTCountArrD; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr             : PByte;
  pt_pix_cnt_arr_ptr        : PInteger;
  pt_pix_arr_row_mrg_btm_ptr: PInteger;
  pt_pix_cnt_row            : integer=0;
  x,y,i,p                   : integer;
  d_width                   : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    begin
      pt_pix_cnt:=0;
      Exit;
    end;
  //SetLength(pt_pix_intr_cnt_arr,0);
  SetLength(pt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
  d_width           :=bmp_ftimg_width-bmp_src_rct_clp.width;
  pt_pix_cnt        :=0;
  pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000]);
  pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr2      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          Inc(pt_pix_cnt_row,(pix_alpha_ptr^+NZ_ITEM_COEFF20)>>NZ_ITEM_COEFF10);
          Inc(pix_alpha_ptr);
        end;
      if (pt_pix_cnt_row<>0) then
        begin
          pt_pix_cnt_arr_ptr^:=pt_pix_cnt_row;
          pt_pix_cnt         +=pt_pix_cnt_row;
          pt_pix_cnt_row     :=0;
        end;
      Inc(pt_pix_cnt_arr_ptr);
      Inc(pix_alpha_ptr,d_width);
    end;
  if (pt_pix_cnt=0) then
    Exit;

  {Find Top Margin Value}
  pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[0]);
  for i:=0 to bmp_src_rct_clp.height-1 do
    begin
      if (pt_pix_cnt_arr_ptr^<>0) then
        Break;
      Inc(pt_pix_cnt_arr_ptr);
    end;
  pt_pix_arr_row_mrg_top:=PInteger(pt_pix_cnt_arr_ptr)-PInteger(@pt_pix_intr_cnt_arr[0]);

  {Find Bottom Margin Value}
  if (pt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
    begin
      pt_pix_arr_row_mrg_btm_ptr:=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
      pt_pix_cnt_arr_ptr        :=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
      for i:=0 to Abs(bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-2) do
        begin
          if (pt_pix_cnt_arr_ptr^<>0) then
            pt_pix_arr_row_mrg_btm_ptr:=pt_pix_cnt_arr_ptr;
          Inc(pt_pix_cnt_arr_ptr);
        end;
      if (pt_pix_cnt_arr_ptr^<>0) then
        pt_pix_arr_row_mrg_btm_ptr:=pt_pix_cnt_arr_ptr;
      p:=PInteger(@pt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-PInteger(pt_pix_arr_row_mrg_btm_ptr);
      if (p>0) then
        pt_pix_arr_row_mrg_btm:=p;
    end;
end; {$endregion} {$endregion}

{Create Array    of Items Shifts  in Rows from Bitmap-} {$region -fold}
// color and alpha are in separate bitmaps
// NT - not transparent pixels;
procedure TFastImage.CrtNTShiftBmpS; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_sht_arr_ptr: PInteger;
  pix_alpha_ptr          : PInteger;
  x,y                    : integer;
  d_width                : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    Exit;
  if (nt_pix_cnt=0) then
    Exit;
  SetLength(nt_pix_intr_sht_arr,nt_pix_cnt);
  d_width                :=bmp_ftimg_width-bmp_src_rct_clp.width;
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000]);
  pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_alpha_ptr^=$FFFFFF) then
            begin
                  nt_pix_intr_sht_arr_ptr^:=x;
              Inc(nt_pix_intr_sht_arr_ptr);
            end;
          Inc(pix_alpha_ptr);
        end;
      Inc(pix_alpha_ptr,d_width);
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImage.CrtPTShiftBmpS; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_intr_sht_arr_ptr: PInteger;
  pix_alpha_ptr          : PByte;
  x,y                    : integer;
  d_width                : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    Exit;
  if (pt_pix_cnt=0) then
    Exit;
  SetLength(pt_pix_intr_sht_arr,pt_pix_cnt);
  d_width                :=bmp_ftimg_width-bmp_src_rct_clp.width;
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000]);
  pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<alpha_max) then
            begin
                  pt_pix_intr_sht_arr_ptr^:=x;
              Inc(pt_pix_intr_sht_arr_ptr);
            end;
          Inc(pix_alpha_ptr,4);
        end;
      Inc(pix_alpha_ptr,d_width<<2);
    end;
end; {$endregion}
// color and alpha are in one bitmap
// NT - not transparent pixels;
procedure TFastImage.CrtNTShiftBmpO; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_sht_arr_ptr: PInteger;
  pix_color_ptr          : PInteger;
  x,y                    : integer;
  d_width                : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    Exit;
  if (nt_pix_cnt=0) then
    Exit;
  SetLength(nt_pix_intr_sht_arr,nt_pix_cnt);
  d_width                :=bmp_ftimg_width-bmp_src_rct_clp.width;
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000]);
  pix_color_ptr          :=Unaligned(@bmp_color_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_color_ptr^>>24=alpha_max) then
            begin
                  nt_pix_intr_sht_arr_ptr^:=x{+bmp_src_rct_clp.left};
              Inc(nt_pix_intr_sht_arr_ptr);
            end;
          Inc(pix_color_ptr);
        end;
      Inc(pix_color_ptr,d_width);
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImage.CrtPTShiftBmpO; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_intr_sht_arr_ptr: PInteger;
  pix_color_ptr          : PInteger;
  x,y                    : integer;
  d_width                : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    Exit;
  if (pt_pix_cnt=0) then
    Exit;
  SetLength(pt_pix_intr_sht_arr,pt_pix_cnt);
  d_width                :=bmp_ftimg_width-bmp_src_rct_clp.width;
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000]);
  pix_color_ptr          :=Unaligned(@bmp_color_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_color_ptr^>>24>0) and (pix_color_ptr^>>24<alpha_max) then
            begin
                  pt_pix_intr_sht_arr_ptr^:=x{+bmp_src_rct_clp.left};
              Inc(pt_pix_intr_sht_arr_ptr);
            end;
          Inc(pix_color_ptr);
        end;
      Inc(pix_color_ptr,d_width);
    end;
end; {$endregion} {$endregion}

{Create Array    of Items Shifts  in Rows from Array--} {$region -fold}
// NT - not transparent pixels;
procedure TFastImage.CrtNTShiftArrA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_sht_arr_ptr: PInteger;
  pix_alpha_ptr          : PInteger;
  x,y                    : integer;
  d_width                : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (nt_pix_cnt=0) then
    begin
      //nt_pix_intr_sht_arr:=Nil;
      Exit;
    end;
  //SetLength(nt_pix_intr_sht_arr,0);
  if (nt_pix_cnt>Length(nt_pix_intr_sht_arr)) or (nt_pix_intr_sht_arr=Nil) then
    SetLength(nt_pix_intr_sht_arr,nt_pix_cnt);
  d_width                :=bmp_ftimg_width-bmp_src_rct_clp.width;
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000]);
  pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_alpha_ptr^{>}<>0) then
            begin
                  nt_pix_intr_sht_arr_ptr^:=x;
              Inc(nt_pix_intr_sht_arr_ptr);
            end;
          Inc(pix_alpha_ptr);
        end;
      Inc(pix_alpha_ptr,d_width);
    end;
end; {$endregion}
procedure TFastImage.CrtNTShiftArrB; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_sht_arr_ptr: PInteger;
  pix_alpha_ptr          : PByte;
  x,y                    : integer;
  d_width                : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (nt_pix_cnt=0) then
    begin
      //nt_pix_intr_sht_arr:=Nil;
      Exit;
    end;
  //SetLength(nt_pix_intr_sht_arr,0);
  if (nt_pix_cnt>Length(nt_pix_intr_sht_arr)) or (nt_pix_intr_sht_arr=Nil) then
    SetLength(nt_pix_intr_sht_arr,nt_pix_cnt);
  d_width                :=bmp_ftimg_width-bmp_src_rct_clp.width;
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000]);
  pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr2     [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_alpha_ptr^{>}<>0) then
            begin
                  nt_pix_intr_sht_arr_ptr^:=x;
              Inc(nt_pix_intr_sht_arr_ptr);
            end;
          Inc(pix_alpha_ptr);
        end;
      Inc(pix_alpha_ptr,d_width);
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImage.CrtPTShiftArrA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_intr_sht_arr_ptr: PInteger;
  pix_alpha_ptr          : PInteger;
  x,y                    : integer;
  d_width                : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (pt_pix_cnt=0) then
    begin
      //pt_pix_intr_sht_arr:=Nil;
      Exit;
    end;
  //SetLength(pt_pix_intr_sht_arr,0);
  if (pt_pix_cnt>Length(pt_pix_intr_sht_arr)) or (pt_pix_intr_sht_arr=Nil) then
    SetLength(pt_pix_intr_sht_arr,pt_pix_cnt);
  d_width                :=bmp_ftimg_width-bmp_src_rct_clp.width;
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000]);
  pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_alpha_ptr^{>}<>0) then
            begin
                  pt_pix_intr_sht_arr_ptr^:=x;
              Inc(pt_pix_intr_sht_arr_ptr);
            end;
          Inc(pix_alpha_ptr);
        end;
      Inc(pix_alpha_ptr,d_width);
    end;
end; {$endregion}
procedure TFastImage.CrtPTShiftArrB; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_intr_sht_arr_ptr: PInteger;
  pix_alpha_ptr          : PByte;
  x,y                    : integer;
  d_width                : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (pt_pix_cnt=0) then
    begin
      //pt_pix_intr_sht_arr:=Nil;
      Exit;
    end;
  //SetLength(pt_pix_intr_sht_arr,0);
  if (pt_pix_cnt>Length(pt_pix_intr_sht_arr)) or (pt_pix_intr_sht_arr=Nil) then
    SetLength(pt_pix_intr_sht_arr,pt_pix_cnt);
  d_width                :=bmp_ftimg_width-bmp_src_rct_clp.width;
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000]);
  pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr2     [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
  for y:=0 to bmp_src_rct_clp.height-1 do
    begin
      for x:=0 to bmp_src_rct_clp.width-1 do
        begin
          if (pix_alpha_ptr^{>}<>0) then
            begin
                  pt_pix_intr_sht_arr_ptr^:=x;
              Inc(pt_pix_intr_sht_arr_ptr);
            end;
          Inc(pix_alpha_ptr);
        end;
      Inc(pix_alpha_ptr,d_width);
    end;
end; {$endregion} {$endregion}

{Create Array    of Items Indices in Rows from Array--} {$region -fold}
procedure TFastimage.CrtNTCntIndArr; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_cnt_ind_arr_ptr     : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  i                      : integer;
  s                      : longword;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    Exit;
  if (nt_pix_cnt=0) then
    Exit;
  SetLength(nt_cnt_ind_arr,0);
  SetLength(nt_cnt_ind_arr,bmp_src_rct_clp.height);
  nt_cnt_ind_arr_ptr     :=Unaligned(@nt_cnt_ind_arr     [0]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[0]);
  s:=0;
  for i:=0 to bmp_src_rct_clp.height-1 do
    begin
          nt_cnt_ind_arr_ptr^:=s;
      Inc(nt_cnt_ind_arr_ptr);
      s+= nt_pix_intr_cnt_arr_ptr^;
      Inc(nt_pix_intr_cnt_arr_ptr);
    end;
end; {$endregion}
procedure TFastimage.CrtPTCntIndArr; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_cnt_ind_arr_ptr     : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  i                      : integer;
  s                      : longword;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
    Exit;
  if (pt_pix_cnt=0) then
    Exit;
  SetLength(pt_cnt_ind_arr,0);
  SetLength(pt_cnt_ind_arr,bmp_src_rct_clp.height);
  pt_cnt_ind_arr_ptr     :=Unaligned(@pt_cnt_ind_arr     [0]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[0]);
  s:=0;
  for i:=0 to bmp_src_rct_clp.height-1 do
    begin
          pt_cnt_ind_arr_ptr^:=s;
      Inc(pt_cnt_ind_arr_ptr);
      s+= pt_pix_intr_cnt_arr_ptr^;
      Inc(pt_pix_intr_cnt_arr_ptr);
    end;
end; {$endregion} {$endregion}

{Store Color     of Current Layer         from Bmp/Arr} {$region -fold}
// NT - not transparent pixels;
{store color channel}
procedure TFastImage.StrNTColorBmpA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (nt_pix_cnt=0) then
    Exit;
  SetLength(nt_pix_intr_ccl_arr,nt_pix_cnt);
  first_row_pix_ptr      :=Unaligned(@bmp_color_ptr      [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  nt_pix_intr_ccl_arr_ptr:=Unaligned(@nt_pix_intr_ccl_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
              nt_pix_intr_ccl_arr_ptr^:=(pix_color_ptr+nt_pix_intr_sht_arr_ptr^)^;
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_ccl_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_ftimg_width);
    end;
end; {$endregion}
// PT - partly transparent pixels;
{store color channel}
procedure TFastImage.StrPTColorBmpA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (pt_pix_cnt=0) then
    Exit;
  SetLength(pt_pix_intr_ccl_arr,pt_pix_cnt);
  first_row_pix_ptr      :=Unaligned(@bmp_color_ptr      [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_intr_ccl_arr_ptr:=Unaligned(@pt_pix_intr_ccl_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
              pt_pix_intr_ccl_arr_ptr^:=(pix_color_ptr+pt_pix_intr_sht_arr_ptr^)^;
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_ccl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_ftimg_width);
    end;
end; {$endregion}
//** color and alpha are in separate bitmaps
{store alpha channel into byte array---}
procedure TFastImage.StrPTAlphaArrS; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr          : PByte;
  first_row_pix_ptr      : PByte;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (pt_pix_cnt=0) then
    Exit;
  SetLength(pt_pix_byte_acl_arr,pt_pix_cnt);
  first_row_pix_ptr      :=Unaligned(@bmp_alpha_ptr      [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_alpha_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
              pt_pix_byte_acl_arr_ptr^:=(pix_alpha_ptr+pt_pix_intr_sht_arr_ptr^<<2)^;
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_ftimg_width<<2);
    end;
end; {$endregion}
{store alpha channel into color channel}
procedure TFastImage.StrPTAlphaBmpS; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr          : PByte;
  first_row_pix_ptr      : PByte;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (pt_pix_cnt=0) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_alpha_ptr      [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_intr_ccl_arr_ptr:=Unaligned(@pt_pix_intr_ccl_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_alpha_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
              pt_pix_intr_ccl_arr_ptr^+=(pix_alpha_ptr+pt_pix_intr_sht_arr_ptr^<<2)^<<24;
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_ccl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_ftimg_width<<2);
    end;
end; {$endregion}
//** color and alpha are in one bitmap
{store alpha channel into byte array---}
procedure TFastImage.StrPTAlphaArrO; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (pt_pix_cnt=0) then
    Exit;
  SetLength(pt_pix_byte_acl_arr,pt_pix_cnt);
  first_row_pix_ptr      :=Unaligned(@bmp_color_ptr      [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
              pt_pix_byte_acl_arr_ptr^:=(pix_color_ptr+pt_pix_intr_sht_arr_ptr^)^>>24;
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_ftimg_width);
    end;
end; {$endregion}
{store alpha channel into color channel}
procedure TFastImage.StrPTAlphaBmpO; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (pt_pix_cnt=0) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_color_ptr      [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_intr_ccl_arr_ptr:=Unaligned(@pt_pix_intr_ccl_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
              pt_pix_intr_ccl_arr_ptr^:=(pix_color_ptr+pt_pix_intr_sht_arr_ptr^)^;
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_ccl_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_ftimg_width);
    end;
end; {$endregion} {$endregion}

{Store Color     of Lower   Layer         from Bitmap-} {$region -fold}
// NT - not transparent pixels;
procedure TFastImage.StrNTLowerBmpA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_cll_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (nt_pix_cnt=0) then
    begin
      //nt_pix_intr_cll_arr:=Nil;
      Exit;
    end;
  //SetLength(nt_pix_intr_cll_arr,0);
  if (nt_pix_cnt>Length(nt_pix_intr_cll_arr)) or (nt_pix_intr_cll_arr=Nil) then
    SetLength(nt_pix_intr_cll_arr,nt_pix_cnt);
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top+{bmp_src_rct_clp.top}bmp_ftimg_top)*bmp_bkgnd_width+{bmp_src_rct_clp.left}bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  nt_pix_intr_cll_arr_ptr:=Unaligned(@nt_pix_intr_cll_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
              nt_pix_intr_cll_arr_ptr^:=(pix_color_ptr+nt_pix_intr_sht_arr_ptr^)^;
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_cll_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImage.StrPTLowerBmpA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_cll_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (pt_pix_cnt=0) then
    begin
      //pt_pix_intr_cll_arr:=Nil;
      Exit;
    end;
  //SetLength(nt_pix_intr_cll_arr,0);
  if (pt_pix_cnt>Length(pt_pix_intr_cll_arr)) or (pt_pix_intr_cll_arr=Nil) then
    SetLength(pt_pix_intr_cll_arr,pt_pix_cnt);
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_intr_cll_arr_ptr:=Unaligned(@pt_pix_intr_cll_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
              pt_pix_intr_cll_arr_ptr^:=(pix_color_ptr+pt_pix_intr_sht_arr_ptr^)^;
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_cll_arr_ptr);
        end;
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// store alpha from byte array;
procedure TFastImage.StrPTLowerArrA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_intr_cll_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  i                      : integer;
begin
  pt_pix_intr_cll_arr_ptr:=Unaligned(@pt_pix_intr_cll_arr[0]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[0]);
  for i:=0 to pt_pix_cnt-1 do
    begin
          pt_pix_intr_cll_arr_ptr^+=pt_pix_byte_acl_arr_ptr^<<24;
      Inc(pt_pix_intr_cll_arr_ptr);
      Inc(pt_pix_byte_acl_arr_ptr);
    end;
end; {$endregion} {$endregion}

{Store Value     of Current Layer         from Array--} {$region -fold}
procedure TFastImage.StrNTValueArrA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_value_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_val_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (nt_pix_cnt=0) then
    begin
      //nt_pix_intr_val_arr:=Nil;
      Exit;
    end;
  //SetLength(nt_pix_intr_val_arr,0);
  if (nt_pix_cnt>Length(nt_pix_intr_val_arr)) or (nt_pix_intr_val_arr=Nil) then
    SetLength(nt_pix_intr_val_arr,nt_pix_cnt);
  first_row_pix_ptr      :=Unaligned(@bmp_value_ptr      [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  nt_pix_intr_val_arr_ptr:=Unaligned(@nt_pix_intr_val_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_value_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
              nt_pix_intr_val_arr_ptr^:=(pix_value_ptr+nt_pix_intr_sht_arr_ptr^)^;
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_val_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_ftimg_width);
    end;
end; {$endregion} {$endregion}

{Set Chess Order of Alpha Channel in Rows from Bitmap-} {$region -fold}
// calculation of image sides Parity}
procedure TFastImage.CalcSidesParity; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  if Odd(bmp_src_rct_clp.width) then
    width_parity:=False
  else
    width_parity:=True;

  if Odd(bmp_src_rct_clp.height) then
    height_parity:=False
  else
    height_parity:=True;

end; {$endregion}
// color and alpha are in separate bitmaps
// NT - not transparent pixels;
procedure TFastImage.SetNTChessBmpS0; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr: PInteger;
  x,y,w,h      : integer;
  d_width      : integer;
begin

  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (bmp_src_rct_clp.width*bmp_src_rct_clp.height<6) then
    Exit;

  w            :=Trunc(bmp_src_rct_clp.width /2)-1;
  h            :=Trunc(bmp_src_rct_clp.height/2)-1;
  d_width      :=bmp_ftimg_width-bmp_src_rct_clp.width;
  pix_alpha_ptr:=Unaligned(@bmp_alpha_ptr[bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);

  if width_parity then
    begin
      if height_parity then
        for y:=0 to h do
          begin
            for x:=0 to w do
              begin
                if (pix_alpha_ptr^=$FFFFFF) then
                  pix_alpha_ptr^:=$000000;
                Inc(pix_alpha_ptr,2);
              end;
            Inc(pix_alpha_ptr,d_width);
            Dec(pix_alpha_ptr);
            for x:=0 to w do
              begin
                if (pix_alpha_ptr^=$FFFFFF) then
                  pix_alpha_ptr^:=$000000;
                Inc(pix_alpha_ptr,2);
              end;
            Inc(pix_alpha_ptr,d_width);
            Inc(pix_alpha_ptr);
          end
      else
        begin
          for x:=0 to w do
            begin
              if (pix_alpha_ptr^=$FFFFFF) then
                pix_alpha_ptr^:=$000000;
              Inc(pix_alpha_ptr,2);
            end;
          Inc(pix_alpha_ptr,d_width);
        end;
    end
  else
    for y:=0 to bmp_src_rct_clp.height-1 do
      begin
        for x:=0 to w do
          begin
            if (pix_alpha_ptr^=$FFFFFF) then
              pix_alpha_ptr^:=$000000;
            Inc(pix_alpha_ptr,2);
          end;
        Inc(pix_alpha_ptr,d_width);
      end;

end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImage.SetPTChessBmpS0; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr: PByte;
  x,y,w,h      : integer;
  d_width      : integer;
begin

  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (bmp_src_rct_clp.width*bmp_src_rct_clp.height<6) then
    Exit;

  w            :=Trunc(bmp_src_rct_clp.width /2)-1;
  h            :=Trunc(bmp_src_rct_clp.height/2)-1;
  d_width      :=bmp_ftimg_width-bmp_src_rct_clp.width;
  pix_alpha_ptr:=Unaligned(@bmp_alpha_ptr[bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);

  if width_parity then
    begin
      if height_parity then
        for y:=0 to h do
          begin
            for x:=0 to w do
              begin
                if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<alpha_max) then
                  pix_alpha_ptr^:=$000000;
                Inc(pix_alpha_ptr,8);
              end;
            Inc(pix_alpha_ptr,d_width<<2);
            Dec(pix_alpha_ptr,4);
            for x:=0 to w do
              begin
                if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<alpha_max) then
                  pix_alpha_ptr^:=$000000;
                Inc(pix_alpha_ptr,8);
              end;
            Inc(pix_alpha_ptr,d_width<<2);
            Inc(pix_alpha_ptr,4);
          end
      else
        begin
          for x:=0 to w do
            begin
              if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<alpha_max) then
                pix_alpha_ptr^:=$000000;
              Inc(pix_alpha_ptr,8);
            end;
          Inc(pix_alpha_ptr,d_width<<2);
        end;
    end
  else
    for y:=0 to bmp_src_rct_clp.height-1 do
      begin
        for x:=0 to w do
          begin
            if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<alpha_max) then
              pix_alpha_ptr^:=$000000;
            Inc(pix_alpha_ptr,8);
          end;
        Inc(pix_alpha_ptr,d_width<<2);
      end;

end; {$endregion}
// color and alpha are in one bitmap
// NT - not transparent pixels;
procedure TFastImage.SetNTChessBmpO0; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr: PInteger;
  x,y,w,h      : integer;
  d_width      : integer;
begin

  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (bmp_src_rct_clp.width*bmp_src_rct_clp.height<6) then
    Exit;

  w            :=Trunc(bmp_src_rct_clp.width /2)-1;
  h            :=Trunc(bmp_src_rct_clp.height/2)-1;
  d_width      :=bmp_ftimg_width-bmp_src_rct_clp.width;
  pix_alpha_ptr:=Unaligned(@bmp_color_ptr[bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);

  if width_parity then
    begin
      if height_parity then
        for y:=0 to h do
          begin
            for x:=0 to w do
              begin
                if (pix_alpha_ptr^>>24=alpha_max) then
                  pix_alpha_ptr^:=0;
                Inc(pix_alpha_ptr,2);
              end;
            Inc(pix_alpha_ptr,d_width);
            Dec(pix_alpha_ptr);
            for x:=0 to w do
              begin
                if (pix_alpha_ptr^>>24=alpha_max) then
                  pix_alpha_ptr^:=0;
                Inc(pix_alpha_ptr,2);
              end;
            Inc(pix_alpha_ptr,d_width);
            Inc(pix_alpha_ptr);
          end
      else
        begin
          for x:=0 to w do
            begin
              if (pix_alpha_ptr^>>24=alpha_max) then
                pix_alpha_ptr^:=0;
              Inc(pix_alpha_ptr,2);
            end;
          Inc(pix_alpha_ptr,d_width);
        end;
    end
  else
    for y:=0 to bmp_src_rct_clp.height-1 do
      begin
        for x:=0 to w do
          begin
            if (pix_alpha_ptr^>>24=alpha_max) then
              pix_alpha_ptr^:=0;
            Inc(pix_alpha_ptr,2);
          end;
        Inc(pix_alpha_ptr,d_width);
      end;

end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImage.SetPTChessBmpO0; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr: PInteger;
  x,y,w,h      : integer;
  d_width      : integer;
begin

  if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (bmp_src_rct_clp.width*bmp_src_rct_clp.height<6) then
    Exit;

  w            :=Trunc(bmp_src_rct_clp.width /2)-1;
  h            :=Trunc(bmp_src_rct_clp.height/2)-1;
  d_width      :=bmp_ftimg_width-bmp_src_rct_clp.width;
  pix_alpha_ptr:=Unaligned(@bmp_color_ptr[bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);

  if width_parity then
    begin
      if height_parity then
        for y:=0 to h do
          begin
            for x:=0 to w do
              begin
                if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<alpha_max) then
                  pix_alpha_ptr^:=0;
                Inc(pix_alpha_ptr,2);
              end;
            Inc(pix_alpha_ptr,d_width);
            Dec(pix_alpha_ptr);
            for x:=0 to w do
              begin
                if (pix_alpha_ptr^>>24>0) and (pix_alpha_ptr^>>24<alpha_max) then
                  pix_alpha_ptr^:=0;
                Inc(pix_alpha_ptr,2);
              end;
            Inc(pix_alpha_ptr,d_width);
            Inc(pix_alpha_ptr);
          end
      else
        begin
          for x:=0 to w do
            begin
              if (pix_alpha_ptr^>>24>0) and (pix_alpha_ptr^>>24<alpha_max) then
                pix_alpha_ptr^:=0;
              Inc(pix_alpha_ptr,2);
            end;
          Inc(pix_alpha_ptr,d_width);
        end;
    end
  else
    for y:=0 to bmp_src_rct_clp.height-1 do
      begin
        for x:=0 to w do
          begin
            if (pix_alpha_ptr^>>24>0) and (pix_alpha_ptr^>>24<alpha_max) then
              pix_alpha_ptr^:=0;
            Inc(pix_alpha_ptr,2);
          end;
        Inc(pix_alpha_ptr,d_width);
      end;

end; {$endregion} {$endregion}

{Create Array of Tiles Bounding Rectangles------------} {$region -fold}
procedure TFastImage.CrtRectArr; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(rect_src_arr,tiles_cnt);
end; {$endregion} {$endregion}

{Full Image Compression-------------------------------} {$region -fold}
// img. kind: 000:
procedure TFastImage.CmpProc000;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // NT - not transparent pixels;
  CrtNTCountBmpO;
  CrtNTShiftBmpO;
  CrtNTCntIndArr;
  StrNTColorBmpA;
  // PT - partly transparent pixels;
  CrtPTCountBmpO;
  CrtPTShiftBmpO;
  CrtPTCntIndArr;
  StrPTColorBmpA;
  // store alpha channel;
  StrPTAlphaArrO;
end; {$endregion}
// img. kind: 001:
procedure TFastImage.CmpProc001;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // NT - not transparent pixels;
  CrtNTCountBmpO;
  CrtNTShiftBmpO;
  CrtNTCntIndArr;
  StrNTColorBmpA;
end; {$endregion}
// img. kind: 002:
procedure TFastImage.CmpProc002;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // PT - partly transparent pixels;
  CrtPTCountBmpO;
  CrtPTCntIndArr;
  CrtPTShiftBmpO;
  StrPTColorBmpA;
  // store alpha channel;
  StrPTAlphaArrO;
end; {$endregion}
// img. kind: 003: empty:
procedure TFastImage.CmpProc003;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {do nothing}
end; {$endregion}
// img. kind: 004: empty:
procedure TFastImage.CmpProc004;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {do nothing}
end; {$endregion}
// img. kind: 005:
procedure TFastImage.CmpProc005;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // NT - not transparent pixels;
  CrtNTCountBmpO;
  CrtNTCntIndArr;
  CrtNTShiftBmpO;
  // PT - partly transparent pixels;
  CrtPTCountBmpO;
  CrtPTCntIndArr;
  CrtPTShiftBmpO;
  // store alpha channel;
  StrPTAlphaArrO;
end; {$endregion}
// img. kind: 006:
procedure TFastImage.CmpProc006;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // NT - not transparent pixels;
  CrtNTCountBmpO;
  CrtNTCntIndArr;
  CrtNTShiftBmpO;
end; {$endregion}
// img. kind: 007:
procedure TFastImage.CmpProc007;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // PT - partly transparent pixels;
  CrtPTCountBmpO;
  CrtPTCntIndArr;
  CrtPTShiftBmpO;
  // store alpha channel;
  StrPTAlphaArrO;
end; {$endregion}
// img. kind: 008: empty:
procedure TFastImage.CmpProc008;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {do nothing}
end; {$endregion}
// img. kind: 009:
procedure TFastImage.CmpProc009;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {do nothing}
end; {$endregion}
// img. kind: 010:
procedure TFastImage.CmpProc010;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {do nothing}
end; {$endregion}
// img. kind: 011:
procedure TFastImage.CmpProc011;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // NT - not transparent pixels;
  if (bmp_alpha_ptr2=Nil) then // byte mode - on:
    begin
      if remove_brunching_none then
        CrtNTCountArrA
      else
        CrtNTCountArrC;
      CrtNTShiftArrA;
      CrtNTCntIndArr;
      StrNTValueArrA;
      //StrNTLowerBmpA;
    end
  else // byte mode - off:
    begin
      if remove_brunching_none then
        CrtNTCountArrB
      else
        CrtNTCountArrD;
      CrtNTShiftArrB;
      CrtNTCntIndArr;
      //StrNTLowerBmpA;
    end;
  {// PT - partly transparent pixels;
  CrtPTCountArrA;
  CrtPTCntIndArr;
  CrtPTShiftArrA;
  // store alpha channel;
  StrPTAlphaArrO;}
end; {$endregion}
// img. kind: 012:
procedure TFastImage.CmpProc012;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // NT - not transparent(not black!) pixels;
  CrtNTCountArrA;
  CrtNTCntIndArr;
  CrtNTShiftArrA;
end; {$endregion}
// Procedures Table Init.:
procedure TFastImage.CmpProcInit; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  {Image Description} {$region -fold}
  {
    ----------------Image Has Alpha Channel And Color Channel---------------
    0:
    image has:  not monochrome alpha channel,
                not monochrome color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels>0;

    1:
    image has:  not monochrome alpha channel,
                not monochrome color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;

    2:
    image has:  not monochrome alpha channel,
                not monochrome color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels>0;

    3:
    image has:      monochrome alpha channel(white, not transparent),
                not monochrome color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;

    4:
    image has:      monochrome alpha channel(transparent),
                not monochrome color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels>0;


    ----------------------Image Has Only Alpha Channel----------------------
    5:
    image has:  not monochrome alpha channel,
                            no color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels>0;

    6:
    image has:  not monochrome alpha channel,
                            no color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;

    7:
    image has:  not monochrome alpha channel,
                            no color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels>0;

    8:
    image has:      monochrome alpha channel(white, not transparent),
                            no color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;

    9:
    image has:      monochrome alpha channel(transparent),
                            no color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels>0;


    --------------Image Has No Alpha Channel And Color Channel--------------
    10:
    image has:      no alpha channel(black, invisible),
                    no color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels=0;


    --------------------------Image is Value Array--------------------------
    11:
    count of    not transparent pixels>0;
    count of partly transparent pixels>0;

    --------------------------Image is Mask--------------------------
    12:
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;
  } {$endregion}

  // img. kind: 000:
  CmpProc[000]:=@CmpProc000;
  // img. kind: 001:
  CmpProc[001]:=@CmpProc001;
  // img. kind: 002:
  CmpProc[002]:=@CmpProc002;
  // img. kind: 003:
  CmpProc[003]:=@CmpProc003;
  // img. kind: 004:
  CmpProc[004]:=@CmpProc004;
  // img. kind: 005:
  CmpProc[005]:=@CmpProc005;
  // img. kind: 006:
  CmpProc[006]:=@CmpProc006;
  // img. kind: 007:
  CmpProc[007]:=@CmpProc007;
  // img. kind: 008:
  CmpProc[008]:=@CmpProc008;
  // img. kind: 009:
  CmpProc[009]:=@CmpProc009;
  // img. kind: 010:
  CmpProc[010]:=@CmpProc010;
  // img. kind: 011:
  CmpProc[011]:=@CmpProc011;
  // img. kind: 012:
  CmpProc[012]:=@CmpProc012;

end; {$endregion}

// Final image Compression:
procedure TFastImage.ImgToCImg;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  DetImageKind;
  CmpProc[img_kind];
  SetSdrType;
end; {$endregion} {$endregion}

{Drawing of Compressed Image on Background------------} {$region -fold}

// NT - not transparent pixels:

// not clippped:
procedure TFastImage.FilNTProc0_0(constref args:TFunc0Args; Func0:TFunc0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with args do
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=Func0(
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,r,g,b,alpha,d_alpha,pow,d);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc    (nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// top-bottom clippped:
procedure TFastImage.FilNTProc0_2(constref args:TFunc0Args; Func0:TFunc0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with args do
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=Func0(
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,r,g,b,alpha,d_alpha,pow,d);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc    (nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// left-right-top-bottom clippped:
procedure TFastImage.FilNTProc0_4(constref args:TFunc0Args; Func0:TFunc0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                  with args do
                     (nt_pix_intr_sht_arr_ptr^+v)^:=Func0(
                     (nt_pix_intr_sht_arr_ptr^+v)^,r,g,b,alpha,d_alpha,pow,d);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                  with args do
                     (nt_pix_intr_sht_arr_ptr^+v)^:=Func0(
                     (nt_pix_intr_sht_arr_ptr^+v)^,r,g,b,alpha,d_alpha,pow,d);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                  with args do
                     (nt_pix_intr_sht_arr_ptr^+v)^:=Func0(
                     (nt_pix_intr_sht_arr_ptr^+v)^,r,g,b,alpha,d_alpha,pow,d);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  with args do
                     (nt_pix_intr_sht_arr_ptr^+v)^:=Func0(
                     (nt_pix_intr_sht_arr_ptr^+v)^,r,g,b,alpha,d_alpha,pow,d);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}

// not clippped:
procedure TFastImage.FilNTProc1_0(                          Proc8:TProc8); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
        Proc8(nt_pix_intr_sht_arr_ptr^+pix_color_ptr,bmp_bkgnd_width);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc    (nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// top-bottom clippped:
procedure TFastImage.FilNTProc1_2(                          Proc8:TProc8); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
        Proc8(nt_pix_intr_sht_arr_ptr^+pix_color_ptr,bmp_bkgnd_width);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc    (nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// left-right-top-bottom clippped:
procedure TFastImage.FilNTProc1_4(                          Proc8:TProc8); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                Proc8(nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                Proc8(nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                Proc8(nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                Proc8(nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}

{Empty}
procedure TFastImage.FilNTValue009; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

end; {$endregion}
{Empty}
procedure TFastImage.FilNTColor009; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

end; {$endregion}

{Monochrome}
// (constant) not clippped:
procedure TFastImage.FilNTValue000; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=col_trans_var.monochrome_val;
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue002; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=col_trans_var.monochrome_val;
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue004; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=col_trans_var.monochrome_val;
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=col_trans_var.monochrome_val;
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=col_trans_var.monochrome_val;
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=col_trans_var.monochrome_val;
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue006; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPFloodFill(bmp_bkgnd_ptr,
              rct_dst.pt_rct,
              bmp_bkgnd_width,
              col_trans_var.monochrome_val);
end; {$endregion}
// (fading):
// same;

{Additive}
// (constant) not clippped:
procedure TFastImage.FilNTValue010; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.r:=col_trans_var.r_val;
  args.g:=col_trans_var.g_val;
  args.b:=col_trans_var.b_val;
  FilNTProc0_0(args,@Additive);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue012; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.r:=col_trans_var.r_val;
  args.g:=col_trans_var.g_val;
  args.b:=col_trans_var.b_val;
  FilNTProc0_2(args,@Additive);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue014; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.r:=col_trans_var.r_val;
  args.g:=col_trans_var.g_val;
  args.b:=col_trans_var.b_val;
  FilNTProc0_4(args,@Additive);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue016; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPAdditive(bmp_bkgnd_ptr,
             rct_dst.pt_rct,
             bmp_bkgnd_width,
             col_trans_var.monochrome_val);
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilNTValue011; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDec(
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,r_val,g_val,b_val,col_trans_arr[1]);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilNTValue013; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDec(
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,r_val,g_val,b_val,col_trans_arr[1]);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue015; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                  with col_trans_var do
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(
                     (nt_pix_intr_sht_arr_ptr^+v)^,
                                                   r_val,
                                                   g_val,
                                                   b_val,
                                                   col_trans_arr[1]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                  with col_trans_var do
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(
                     (nt_pix_intr_sht_arr_ptr^+v)^,
                                                   r_val,
                                                   g_val,
                                                   b_val,
                                                   col_trans_arr[1]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                  with col_trans_var do
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(
                     (nt_pix_intr_sht_arr_ptr^+v)^,
                                                   r_val,
                                                   g_val,
                                                   b_val,
                                                   col_trans_arr[1]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  with col_trans_var do
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(
                     (nt_pix_intr_sht_arr_ptr^+v)^,
                                                   r_val,
                                                   g_val,
                                                   b_val,
                                                   col_trans_arr[1]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImage.FilNTValue017; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPAdditiveDec(bmp_bkgnd_ptr,
                rct_dst.pt_rct,
                bmp_bkgnd_width,
                col_trans_var.monochrome_val,
                col_trans_arr[1]);
end; {$endregion}

{Alphablend}
// (constant) not clippped:
procedure TFastImage.FilNTValue020; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  d_alpha                : byte;
begin
  d_alpha                :=alpha_max-col_trans_arr[2];
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlend(
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,r_val,g_val,b_val,d_alpha,col_trans_arr[2]);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue022; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  d_alpha                : byte;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  d_alpha                :=alpha_max-col_trans_arr[2];
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlend(
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,r_val,g_val,b_val,d_alpha,col_trans_arr[2]);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue024; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  d_alpha                : byte;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  d_alpha                :=alpha_max-col_trans_arr[2];
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                  with col_trans_var do
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(
                     (nt_pix_intr_sht_arr_ptr^+v)^,
                                                   r_val,
                                                   g_val,
                                                   b_val,
                                                   d_alpha,
                                                   col_trans_arr[2]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                  with col_trans_var do
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(
                     (nt_pix_intr_sht_arr_ptr^+v)^,
                                                   r_val,
                                                   g_val,
                                                   b_val,
                                                   d_alpha,
                                                   col_trans_arr[2]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                  with col_trans_var do
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(
                     (nt_pix_intr_sht_arr_ptr^+v)^,
                                                   r_val,
                                                   g_val,
                                                   b_val,
                                                   d_alpha,
                                                   col_trans_arr[2]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  with col_trans_var do
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(
                     (nt_pix_intr_sht_arr_ptr^+v)^,
                                                   r_val,
                                                   g_val,
                                                   b_val,
                                                   d_alpha,
                                                   col_trans_arr[2]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue026; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPAlphaBlend(bmp_bkgnd_ptr,
               rct_dst.pt_rct,
               bmp_bkgnd_width,
               col_trans_var.monochrome_val,
               col_trans_arr[2]);
end; {$endregion}
// (fading):
// same;

{Inverse}
// (constant) not clippped:
procedure TFastImage.FilNTValue030; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=Inverse(
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue032; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=Inverse(
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue034; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=Inverse(
                     (nt_pix_intr_sht_arr_ptr^+v)^);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=Inverse(
                     (nt_pix_intr_sht_arr_ptr^+v)^);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=Inverse(
                     (nt_pix_intr_sht_arr_ptr^+v)^);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=Inverse(
                     (nt_pix_intr_sht_arr_ptr^+v)^);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue036; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPInverse(bmp_bkgnd_ptr,
            rct_dst.pt_rct,
            bmp_bkgnd_width);
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilNTValue031; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=InverseDec(
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,col_trans_arr[3]);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc    (nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilNTValue033; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=InverseDec(
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,col_trans_arr[3]);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc    (nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue035; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=InverseDec(
                     (nt_pix_intr_sht_arr_ptr^+v)^,col_trans_arr[3]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=InverseDec(
                     (nt_pix_intr_sht_arr_ptr^+v)^,col_trans_arr[3]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=InverseDec(
                     (nt_pix_intr_sht_arr_ptr^+v)^,col_trans_arr[3]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=InverseDec(
                     (nt_pix_intr_sht_arr_ptr^+v)^,col_trans_arr[3]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImage.FilNTValue037; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPInverseDec(bmp_bkgnd_ptr,
               rct_dst.pt_rct,
               bmp_bkgnd_width,
               col_trans_arr[3]);
end; {$endregion}

{Highlight}
// (constant) not clippped:
procedure TFastImage.FilNTValue040; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.pow:=col_trans_arr[4];
  FilNTProc0_0(args,@Highlight);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue042; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.pow:=col_trans_arr[4];
  FilNTProc0_2(args,@Highlight);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue044; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.pow:=col_trans_arr[4];
  FilNTProc0_4(args,@Highlight);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue046; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPHighlight(bmp_bkgnd_ptr,
              rct_dst.pt_rct,
              bmp_bkgnd_width,
              col_trans_arr[4]);
end; {$endregion}
// (fading):
// same;

{Darken}
// (constant) not clippped:
procedure TFastImage.FilNTValue050; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.pow:=col_trans_arr[5];
  FilNTProc0_0(args,@Darken);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue052; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.pow:=col_trans_arr[5];
  FilNTProc0_2(args,@Darken);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue054; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.pow:=col_trans_arr[5];
  FilNTProc0_4(args,@Darken);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue056; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPDarken(bmp_bkgnd_ptr,
           rct_dst.pt_rct,
           bmp_bkgnd_width,
           col_trans_arr[5]);
end; {$endregion}
// (fading):
// same;

{GrayscaleR}
// (constant) not clippped:
procedure TFastImage.FilNTValue060; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc0_0(Default(TFunc0Args),@GrayscaleR);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue062; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc0_2(Default(TFunc0Args),@GrayscaleR);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue064; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc0_4(Default(TFunc0Args),@GrayscaleR);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue066; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPGrayscaleR(bmp_bkgnd_ptr,
               rct_dst.pt_rct,
               bmp_bkgnd_width);
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilNTValue061; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  d_grayscale_r          : byte;
begin
  d_grayscale_r          :=alpha_max-col_trans_arr[6];
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleRDec(
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,d_grayscale_r);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc    (nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilNTValue063; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  d_grayscale_r          : byte;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  d_grayscale_r          :=alpha_max-col_trans_arr[6];
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleRDec(
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,d_grayscale_r);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc    (nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue065; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  d_grayscale_r          : byte;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  d_grayscale_r          :=alpha_max-col_trans_arr[6];
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleRDec(
                     (nt_pix_intr_sht_arr_ptr^+v)^,d_grayscale_r);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleRDec(
                     (nt_pix_intr_sht_arr_ptr^+v)^,d_grayscale_r);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleRDec(
                     (nt_pix_intr_sht_arr_ptr^+v)^,d_grayscale_r);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleRDec(
                     (nt_pix_intr_sht_arr_ptr^+v)^,d_grayscale_r);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImage.FilNTValue067; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPGrayscaleRDec(bmp_bkgnd_ptr,
                  rct_dst.pt_rct,
                  bmp_bkgnd_width,
                  col_trans_arr[6]);
end; {$endregion}

{GrayscaleG}
// (constant) not clippped:
procedure TFastImage.FilNTValue070; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc0_0(Default(TFunc0Args),@GrayscaleG);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue072; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc0_2(Default(TFunc0Args),@GrayscaleG);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue074; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc0_4(Default(TFunc0Args),@GrayscaleG);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue076; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPGrayscaleG(bmp_bkgnd_ptr,
               rct_dst.pt_rct,
               bmp_bkgnd_width);
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilNTValue071; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  d_grayscale_g          : byte;
begin
  d_grayscale_g          :=alpha_max-col_trans_arr[7];
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleGDec(
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,d_grayscale_g);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc    (nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilNTValue073; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  d_grayscale_g          : byte;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  d_grayscale_g          :=alpha_max-col_trans_arr[7];
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleGDec(
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,d_grayscale_g);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc    (nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue075; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  d_grayscale_g          : byte;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  d_grayscale_g          :=alpha_max-col_trans_arr[7];
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleGDec(
                     (nt_pix_intr_sht_arr_ptr^+v)^,d_grayscale_g);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleGDec(
                     (nt_pix_intr_sht_arr_ptr^+v)^,d_grayscale_g);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleGDec(
                     (nt_pix_intr_sht_arr_ptr^+v)^,d_grayscale_g);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleGDec(
                     (nt_pix_intr_sht_arr_ptr^+v)^,d_grayscale_g);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImage.FilNTValue077; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPGrayscaleGDec(bmp_bkgnd_ptr,
                  rct_dst.pt_rct,
                  bmp_bkgnd_width,
                  col_trans_arr[7]);
end; {$endregion}

{GrayscaleB}
// (constant) not clippped:
procedure TFastImage.FilNTValue080; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc0_0(Default(TFunc0Args),@GrayscaleB);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue082; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc0_2(Default(TFunc0Args),@GrayscaleB);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue084; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc0_4(Default(TFunc0Args),@GrayscaleB);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue086; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPGrayscaleB(bmp_bkgnd_ptr,
               rct_dst.pt_rct,
               bmp_bkgnd_width);
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilNTValue081; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  d_grayscale_b          : byte;
begin
  d_grayscale_b          :=alpha_max-col_trans_arr[8];
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleBDec(
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,d_grayscale_b);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc    (nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilNTValue083; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  d_grayscale_b          : byte;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  d_grayscale_b          :=alpha_max-col_trans_arr[8];
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleBDec(
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,d_grayscale_b);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc    (nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue085; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  d_grayscale_b          : byte;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  d_grayscale_b          :=alpha_max-col_trans_arr[8];
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleBDec(
                     (nt_pix_intr_sht_arr_ptr^+v)^,d_grayscale_b);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleBDec(
                     (nt_pix_intr_sht_arr_ptr^+v)^,d_grayscale_b);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleBDec(
                     (nt_pix_intr_sht_arr_ptr^+v)^,d_grayscale_b);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleBDec(
                     (nt_pix_intr_sht_arr_ptr^+v)^,d_grayscale_b);
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImage.FilNTValue087; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPGrayscaleBDec(bmp_bkgnd_ptr,
                  rct_dst.pt_rct,
                  bmp_bkgnd_width,
                  col_trans_arr[8]);
end; {$endregion}

{Monochrome Noise}
// (constant) not clippped:
procedure TFastImage.FilNTValue090; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
          if Odd((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=col_trans_var.monochrome_val;
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue092; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
          if Odd((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=col_trans_var.monochrome_val;
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue094; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                  if Odd((nt_pix_intr_sht_arr_ptr^+v)^) then
                         (nt_pix_intr_sht_arr_ptr^+v)^:=col_trans_var.monochrome_val;
                  Inc    (nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                  if Odd((nt_pix_intr_sht_arr_ptr^+v)^) then
                         (nt_pix_intr_sht_arr_ptr^+v)^:=col_trans_var.monochrome_val;
                  Inc    (nt_pix_intr_sht_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                  if Odd((nt_pix_intr_sht_arr_ptr^+v)^) then
                         (nt_pix_intr_sht_arr_ptr^+v)^:=col_trans_var.monochrome_val;
                  Inc    (nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  if Odd((nt_pix_intr_sht_arr_ptr^+v)^) then
                         (nt_pix_intr_sht_arr_ptr^+v)^:=col_trans_var.monochrome_val;
                  Inc    (nt_pix_intr_sht_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue096; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPMonoNoise(bmp_bkgnd_ptr,
              rct_dst.pt_rct,
              bmp_bkgnd_width,
              col_trans_var.monochrome_val);
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilNTValue091; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  d_mononoise            : byte;
begin
  d_mononoise            :=alpha_max-col_trans_arr[9];
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
          if Odd((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
            with col_trans_var do
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlend((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,r_val,g_val,b_val,d_mononoise,col_trans_arr[9]);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilNTValue093; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  d_mononoise            : byte;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  d_mononoise            :=alpha_max-col_trans_arr[9];
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
          if Odd((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
            with col_trans_var do
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlend((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,r_val,g_val,b_val,d_mononoise,col_trans_arr[9]);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue095; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  d_mononoise            : byte;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  d_mononoise            :=alpha_max-col_trans_arr[9];
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                  with col_trans_var do
                    if Odd((nt_pix_intr_sht_arr_ptr^+v)^) then
                           (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend((nt_pix_intr_sht_arr_ptr^+v)^,
                                                                     r_val,
                                                                     g_val,
                                                                     b_val,
                                                                     d_mononoise,
                                                                     col_trans_arr[9]);
                  Inc      (nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                  with col_trans_var do
                    if Odd((nt_pix_intr_sht_arr_ptr^+v)^) then
                           (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend((nt_pix_intr_sht_arr_ptr^+v)^,
                                                                     r_val,
                                                                     g_val,
                                                                     b_val,
                                                                     d_mononoise,
                                                                     col_trans_arr[9]);
                  Inc      (nt_pix_intr_sht_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                  with col_trans_var do
                    if Odd((nt_pix_intr_sht_arr_ptr^+v)^) then
                           (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend((nt_pix_intr_sht_arr_ptr^+v)^,
                                                                     r_val,
                                                                     g_val,
                                                                     b_val,
                                                                     d_mononoise,
                                                                     col_trans_arr[9]);
                  Inc      (nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  with col_trans_var do
                    if Odd((nt_pix_intr_sht_arr_ptr^+v)^) then
                           (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend((nt_pix_intr_sht_arr_ptr^+v)^,
                                                                     r_val,
                                                                     g_val,
                                                                     b_val,
                                                                     d_mononoise,
                                                                     col_trans_arr[9]);
                  Inc      (nt_pix_intr_sht_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImage.FilNTValue097; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPMonoNoiseDec(bmp_bkgnd_ptr,
                 rct_dst.pt_rct,
                 bmp_bkgnd_width,
                 col_trans_var.monochrome_val,
                 col_trans_arr[9]);
end; {$endregion}

{ColorizeRM}
// (constant) not clippped:
procedure TFastImage.FilNTValue100; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.d:=(col_trans_arr[10]-128)<<1;
  FilNTProc0_0(args,@ColorizeRM);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue102; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.d:=(col_trans_arr[10]-128)<<1;
  FilNTProc0_2(args,@ColorizeRM);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue104; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.d:=(col_trans_arr[10]-128)<<1;
  FilNTProc0_4(args,@ColorizeRM);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue106; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPColorCorrectionM0(@ColorizeRM,
                      bmp_bkgnd_ptr,
                      rct_dst.pt_rct,
                      bmp_bkgnd_width,
                      col_trans_arr[10]);
end; {$endregion}
// (fading):
// same;

{ColorizeRP}
// (constant) not clippped:
procedure TFastImage.FilNTValue110; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.d:=(col_trans_arr[11]-128)<<1;
  FilNTProc0_0(args,@ColorizeRP);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue112; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.d:=(col_trans_arr[11]-128)<<1;
  FilNTProc0_2(args,@ColorizeRP);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue114; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.d:=(col_trans_arr[11]-128)<<1;
  FilNTProc0_4(args,@ColorizeRP);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue116; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPColorCorrectionP0(@ColorizeRP,
                      bmp_bkgnd_ptr,
                      rct_dst.pt_rct,
                      bmp_bkgnd_width,
                      col_trans_arr[11]);
end; {$endregion}
// (fading):
// same;

{ColorizeGM}
// (constant) not clippped:
procedure TFastImage.FilNTValue120; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.d:=(col_trans_arr[12]-128)<<1;
  FilNTProc0_0(args,@ColorizeGM);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue122; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.d:=(col_trans_arr[12]-128)<<1;
  FilNTProc0_2(args,@ColorizeGM);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue124; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.d:=(col_trans_arr[12]-128)<<1;
  FilNTProc0_4(args,@ColorizeGM);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue126; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPColorCorrectionM0(@ColorizeGM,
                      bmp_bkgnd_ptr,
                      rct_dst.pt_rct,
                      bmp_bkgnd_width,
                      col_trans_arr[12]);
end; {$endregion}
// (fading):
// same;

{ColorizeGP}
// (constant) not clippped:
procedure TFastImage.FilNTValue130; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.d:=(col_trans_arr[13]-128)<<1;
  FilNTProc0_0(args,@ColorizeGP);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue132; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.d:=(col_trans_arr[13]-128)<<1;
  FilNTProc0_2(args,@ColorizeGP);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue134; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.d:=(col_trans_arr[13]-128)<<1;
  FilNTProc0_4(args,@ColorizeGP);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue136; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPColorCorrectionP0(@ColorizeGP,
                      bmp_bkgnd_ptr,
                      rct_dst.pt_rct,
                      bmp_bkgnd_width,
                      col_trans_arr[13]);
end; {$endregion}
// (fading):
// same;

{ColorizeBM}
// (constant) not clippped:
procedure TFastImage.FilNTValue140; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.d:=(col_trans_arr[14]-128)<<1;
  FilNTProc0_0(args,@ColorizeBM);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue142; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.d:=(col_trans_arr[14]-128)<<1;
  FilNTProc0_2(args,@ColorizeBM);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue144; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.d:=(col_trans_arr[14]-128)<<1;
  FilNTProc0_4(args,@ColorizeBM);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue146; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPColorCorrectionM0(@ColorizeBM,
                      bmp_bkgnd_ptr,
                      rct_dst.pt_rct,
                      bmp_bkgnd_width,
                      col_trans_arr[14]);
end; {$endregion}
// (fading):
// same;

{ColorizeBP}
// (constant) not clippped:
procedure TFastImage.FilNTValue150; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.d:=(col_trans_arr[15]-128)<<1;
  FilNTProc0_0(args,@ColorizeBP);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue152; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.d:=(col_trans_arr[15]-128)<<1;
  FilNTProc0_2(args,@ColorizeBP);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue154; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  args.d:=(col_trans_arr[15]-128)<<1;
  FilNTProc0_4(args,@ColorizeBP);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue156; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPColorCorrectionP0(@ColorizeBP,
                      bmp_bkgnd_ptr,
                      rct_dst.pt_rct,
                      bmp_bkgnd_width,
                      col_trans_arr[15]);
end; {$endregion}
// (fading):
// same;

{BlurRGB}
// (constant) not clippped:
procedure TFastImage.FilNTValue160; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_0(@BlurRGB);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue162; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_2(@BlurRGB);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue164; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_4(@BlurRGB);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue166; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPBlur(bmp_bkgnd_ptr,
         rct_dst.pt_rct,
         bmp_bkgnd_width,
         0);
end; {$endregion}
// (fading):
// same;

{BlurRRB}
// (constant) not clippped:
procedure TFastImage.FilNTValue170; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_0(@BlurRRB);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue172; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_2(@BlurRRB);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue174; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_4(@BlurRRB);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue176; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPBlur(bmp_bkgnd_ptr,
         rct_dst.pt_rct,
         bmp_bkgnd_width,
         1);
end; {$endregion}
// (fading):
// same;

{BlurRGR}
// (constant) not clippped:
procedure TFastImage.FilNTValue180; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_0(@BlurRGR);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue182; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_2(@BlurRGR);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue184; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_4(@BlurRGR);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue186; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPBlur(bmp_bkgnd_ptr,
         rct_dst.pt_rct,
         bmp_bkgnd_width,
         2);
end; {$endregion}
// (fading):
// same;

{BlurGGB}
// (constant) not clippped:
procedure TFastImage.FilNTValue190; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_0(@BlurGGB);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue192; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_2(@BlurGGB);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue194; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_4(@BlurGGB);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue196; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPBlur(bmp_bkgnd_ptr,
         rct_dst.pt_rct,
         bmp_bkgnd_width,
         3);
end; {$endregion}
// (fading):
// same;

{BlurRGG}
// (constant) not clippped:
procedure TFastImage.FilNTValue200; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_0(@BlurRGG);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue202; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_2(@BlurRGG);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue204; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_4(@BlurRGG);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue206; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPBlur(bmp_bkgnd_ptr,
         rct_dst.pt_rct,
         bmp_bkgnd_width,
         4);
end; {$endregion}
// (fading):
// same;

{BlurBGB}
// (constant) not clippped:
procedure TFastImage.FilNTValue210; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_0(@BlurBGB);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue212; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_2(@BlurBGB);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue214; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_4(@BlurBGB);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue216; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPBlur(bmp_bkgnd_ptr,
         rct_dst.pt_rct,
         bmp_bkgnd_width,
         5);
end; {$endregion}
// (fading):
// same;

{BlurRBB}
// (constant) not clippped:
procedure TFastImage.FilNTValue220; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_0(@BlurRBB);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue222; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_2(@BlurRBB);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue224; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_4(@BlurRBB);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue226; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPBlur(bmp_bkgnd_ptr,
         rct_dst.pt_rct,
         bmp_bkgnd_width,
         6);
end; {$endregion}
// (fading):
// same;

{BlurRRR}
// (constant) not clippped:
procedure TFastImage.FilNTValue230; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_0(@BlurRRR);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue232; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_2(@BlurRRR);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue234; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_4(@BlurRRR);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue236; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPBlur(bmp_bkgnd_ptr,
         rct_dst.pt_rct,
         bmp_bkgnd_width,
         7);
end; {$endregion}
// (fading):
// same;

{BlurGGG}
// (constant) not clippped:
procedure TFastImage.FilNTValue240; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_0(@BlurGGG);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue242; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_2(@BlurGGG);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue244; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_4(@BlurGGG);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue246; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPBlur(bmp_bkgnd_ptr,
         rct_dst.pt_rct,
         bmp_bkgnd_width,
         8);
end; {$endregion}
// (fading):
// same;

{BlurBBB}
// (constant) not clippped:
procedure TFastImage.FilNTValue250; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_0(@BlurBBB);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTValue252; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_2(@BlurBBB);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTValue254; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilNTProc1_4(@BlurBBB);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTValue256; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPBlur(bmp_bkgnd_ptr,
         rct_dst.pt_rct,
         bmp_bkgnd_width,
         9);
end; {$endregion}
// (fading):
// same;

{Color of Curent Layer}
// (constant) not clippped:
procedure TFastImage.FilNTColor000; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  nt_pix_intr_ccl_arr_ptr:=Unaligned( nt_pix_intr_arr_ptr);
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=
              nt_pix_intr_ccl_arr_ptr^;
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_ccl_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTColor002; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  nt_pix_intr_ccl_arr_ptr:=Unaligned(@nt_pix_intr_arr_ptr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=
              nt_pix_intr_ccl_arr_ptr^;
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_ccl_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTColor004; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  nt_pix_intr_ccl_arr_ptr:=Unaligned(@nt_pix_intr_arr_ptr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              Inc(nt_pix_intr_ccl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=
                      nt_pix_intr_ccl_arr_ptr^;
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (nt_pix_intr_ccl_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              Inc(nt_pix_intr_ccl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=
                      nt_pix_intr_ccl_arr_ptr^;
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=
                      nt_pix_intr_ccl_arr_ptr^;
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (nt_pix_intr_ccl_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=
                      nt_pix_intr_ccl_arr_ptr^;
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTColor006; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  BitBlt1(bmp_color_ptr,
          bmp_bkgnd_ptr,
          rct_src,
          rct_dst.pt_rct.left,
          rct_dst.pt_rct.top,
          bmp_ftimg_width_origin{bmp_ftimg_width},
          bmp_bkgnd_width);
end; {$endregion}
// (fading):
// same;

{Color of Curent Layer(Additive)}
// (constant) not clippped:
procedure TFastImage.FilNTColor010; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  nt_pix_intr_ccl_arr_ptr:=Unaligned( nt_pix_intr_arr_ptr);
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=Additive(
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
        Blue (nt_pix_intr_ccl_arr_ptr^),
        Green(nt_pix_intr_ccl_arr_ptr^),
        Red  (nt_pix_intr_ccl_arr_ptr^));
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_ccl_arr_ptr);
        end;
      Inc    (nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTColor012; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  nt_pix_intr_ccl_arr_ptr:=Unaligned(@nt_pix_intr_arr_ptr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=Additive(
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
        Blue (nt_pix_intr_ccl_arr_ptr^),
        Green(nt_pix_intr_ccl_arr_ptr^),
        Red  (nt_pix_intr_ccl_arr_ptr^));
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_ccl_arr_ptr);
        end;
      Inc    (nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTColor014; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  nt_pix_intr_ccl_arr_ptr:=Unaligned(@nt_pix_intr_arr_ptr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              Inc(nt_pix_intr_ccl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=Additive(
                     (nt_pix_intr_sht_arr_ptr^+v)^,
                Blue (nt_pix_intr_ccl_arr_ptr^),
                Green(nt_pix_intr_ccl_arr_ptr^),
                Red  (nt_pix_intr_ccl_arr_ptr^));
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (nt_pix_intr_ccl_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              Inc(nt_pix_intr_ccl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=Additive(
                     (nt_pix_intr_sht_arr_ptr^+v)^,
                Blue (nt_pix_intr_ccl_arr_ptr^),
                Green(nt_pix_intr_ccl_arr_ptr^),
                Red  (nt_pix_intr_ccl_arr_ptr^));
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=Additive(
                     (nt_pix_intr_sht_arr_ptr^+v)^,
                Blue (nt_pix_intr_ccl_arr_ptr^),
                Green(nt_pix_intr_ccl_arr_ptr^),
                Red  (nt_pix_intr_ccl_arr_ptr^));
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (nt_pix_intr_ccl_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=Additive(
                     (nt_pix_intr_sht_arr_ptr^+v)^,
                Blue (nt_pix_intr_ccl_arr_ptr^),
                Green(nt_pix_intr_ccl_arr_ptr^),
                Red  (nt_pix_intr_ccl_arr_ptr^));
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTColor016; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPAdditive(bmp_color_ptr,
             bmp_bkgnd_ptr,
             rct_src,
             rct_dst,
             bmp_ftimg_width_origin{bmp_ftimg_width},
             bmp_bkgnd_width);
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilNTColor011; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  nt_pix_intr_ccl_arr_ptr:=Unaligned( nt_pix_intr_arr_ptr);
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDec(
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
        Blue (nt_pix_intr_ccl_arr_ptr^),
        Green(nt_pix_intr_ccl_arr_ptr^),
        Red  (nt_pix_intr_ccl_arr_ptr^),col_trans_arr[1]);
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_ccl_arr_ptr);
        end;
      Inc    (nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilNTColor013; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  nt_pix_intr_ccl_arr_ptr:=Unaligned(@nt_pix_intr_arr_ptr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDec(
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
        Blue (nt_pix_intr_ccl_arr_ptr^),
        Green(nt_pix_intr_ccl_arr_ptr^),
        Red  (nt_pix_intr_ccl_arr_ptr^),col_trans_arr[1]);
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_ccl_arr_ptr);
        end;
      Inc    (nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilNTColor015; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  nt_pix_intr_ccl_arr_ptr:=Unaligned(@nt_pix_intr_arr_ptr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              Inc(nt_pix_intr_ccl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(
                     (nt_pix_intr_sht_arr_ptr^+v)^,
                Blue (nt_pix_intr_ccl_arr_ptr^),
                Green(nt_pix_intr_ccl_arr_ptr^),
                Red  (nt_pix_intr_ccl_arr_ptr^),col_trans_arr[1]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (nt_pix_intr_ccl_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              Inc(nt_pix_intr_ccl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(
                     (nt_pix_intr_sht_arr_ptr^+v)^,
                Blue (nt_pix_intr_ccl_arr_ptr^),
                Green(nt_pix_intr_ccl_arr_ptr^),
                Red  (nt_pix_intr_ccl_arr_ptr^),col_trans_arr[1]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(
                     (nt_pix_intr_sht_arr_ptr^+v)^,
                Blue (nt_pix_intr_ccl_arr_ptr^),
                Green(nt_pix_intr_ccl_arr_ptr^),
                Red  (nt_pix_intr_ccl_arr_ptr^),col_trans_arr[1]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (nt_pix_intr_ccl_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(
                     (nt_pix_intr_sht_arr_ptr^+v)^,
                Blue (nt_pix_intr_ccl_arr_ptr^),
                Green(nt_pix_intr_ccl_arr_ptr^),
                Red  (nt_pix_intr_ccl_arr_ptr^),col_trans_arr[1]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImage.FilNTColor017; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPAdditiveDec(bmp_color_ptr,
                bmp_bkgnd_ptr,
                rct_src,
                rct_dst,
                bmp_ftimg_width_origin{bmp_ftimg_width},
                bmp_bkgnd_width,
                col_trans_arr[1]);
end; {$endregion}

{Color of Curent Layer(Alphablend)}
// (constant) not clippped:
procedure TFastImage.FilNTColor020; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
  d_alpha                : byte;
begin
  d_alpha                :=alpha_max-col_trans_arr[2];
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  nt_pix_intr_ccl_arr_ptr:=Unaligned( nt_pix_intr_arr_ptr);
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlend(
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
        Blue (nt_pix_intr_ccl_arr_ptr^),
        Green(nt_pix_intr_ccl_arr_ptr^),
        Red  (nt_pix_intr_ccl_arr_ptr^),d_alpha,col_trans_arr[2]);
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_ccl_arr_ptr);
        end;
      Inc    (nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilNTColor022; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
  d_alpha                : byte;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  d_alpha                :=alpha_max-col_trans_arr[2];
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  nt_pix_intr_ccl_arr_ptr:=Unaligned(@nt_pix_intr_arr_ptr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlend(
             (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
        Blue (nt_pix_intr_ccl_arr_ptr^),
        Green(nt_pix_intr_ccl_arr_ptr^),
        Red  (nt_pix_intr_ccl_arr_ptr^),d_alpha,col_trans_arr[2]);
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_ccl_arr_ptr);
        end;
      Inc    (nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilNTColor024; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  d_alpha                : byte;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    Exit;
  d_alpha                :=alpha_max-col_trans_arr[2];
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  nt_pix_intr_ccl_arr_ptr:=Unaligned(@nt_pix_intr_arr_ptr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (nt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(nt_pix_intr_sht_arr_ptr,c1+1);
              Inc(nt_pix_intr_ccl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(
                     (nt_pix_intr_sht_arr_ptr^+v)^,
                Blue (nt_pix_intr_ccl_arr_ptr^),
                Green(nt_pix_intr_ccl_arr_ptr^),
                Red  (nt_pix_intr_ccl_arr_ptr^),d_alpha,col_trans_arr[2]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (nt_pix_intr_ccl_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(nt_pix_intr_sht_arr_ptr,c+1);
              Inc(nt_pix_intr_ccl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(
                     (nt_pix_intr_sht_arr_ptr^+v)^,
                Blue (nt_pix_intr_ccl_arr_ptr^),
                Green(nt_pix_intr_ccl_arr_ptr^),
                Red  (nt_pix_intr_ccl_arr_ptr^),d_alpha,col_trans_arr[2]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(
                     (nt_pix_intr_sht_arr_ptr^+v)^,
                Blue (nt_pix_intr_ccl_arr_ptr^),
                Green(nt_pix_intr_ccl_arr_ptr^),
                Red  (nt_pix_intr_ccl_arr_ptr^),d_alpha,col_trans_arr[2]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
              Inc    (nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (nt_pix_intr_ccl_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(
                     (nt_pix_intr_sht_arr_ptr^+v)^,
                Blue (nt_pix_intr_ccl_arr_ptr^),
                Green(nt_pix_intr_ccl_arr_ptr^),
                Red  (nt_pix_intr_ccl_arr_ptr^),d_alpha,col_trans_arr[2]);
                  Inc(nt_pix_intr_sht_arr_ptr);
                  Inc(nt_pix_intr_ccl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilNTColor026; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPAlphaBlend(bmp_color_ptr,
               bmp_bkgnd_ptr,
               rct_src,
               rct_dst,
               bmp_ftimg_width_origin{bmp_ftimg_width},
               bmp_bkgnd_width,
               col_trans_arr[2]);
end; {$endregion}
// (fading):
// same;



// PT - partly transparent pixels:

// not clippped:
procedure TFastImage.FilPTProc1_0(                          Proc8:TProc8); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
        Proc8(pt_pix_intr_sht_arr_ptr^+pix_color_ptr,bmp_bkgnd_width);
          Inc(pt_pix_intr_sht_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// top-bottom clippped:
procedure TFastImage.FilPTProc1_2(                          Proc8:TProc8); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
        Proc8(pt_pix_intr_sht_arr_ptr^+pix_color_ptr,bmp_bkgnd_width);
          Inc(pt_pix_intr_sht_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// left-right-top-bottom clippped:
procedure TFastImage.FilPTProc1_4(                          Proc8:TProc8); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                Proc8(pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width);
                  Inc(pt_pix_intr_sht_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                Proc8(pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width);
                  Inc(pt_pix_intr_sht_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                Proc8(pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width);
                  Inc(pt_pix_intr_sht_arr_ptr);
                end;
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                Proc8(pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width);
                  Inc(pt_pix_intr_sht_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}

{Empty}
procedure TFastImage.FilPTValue009; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
{Empty}
procedure TFastImage.FilPTColor009; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Monochrome}
// (constant) not clippped:
procedure TFastImage.FilPTValue000; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlend(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                       r_val,
                                                       g_val,
                                                       b_val,
              pt_pix_byte_acl_arr_ptr^,
    alpha_max-pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue002; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlend(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                       r_val,
                                                       g_val,
                                                       b_val,
              pt_pix_byte_acl_arr_ptr^,
    alpha_max-pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue004; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                   r_val,
                                                   g_val,
                                                   b_val,
                      pt_pix_byte_acl_arr_ptr^,
            alpha_max-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                   r_val,
                                                   g_val,
                                                   b_val,
                      pt_pix_byte_acl_arr_ptr^,
            alpha_max-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                   r_val,
                                                   g_val,
                                                   b_val,
                      pt_pix_byte_acl_arr_ptr^,
            alpha_max-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                   r_val,
                                                   g_val,
                                                   b_val,
                      pt_pix_byte_acl_arr_ptr^,
            alpha_max-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading):
// same;

{Additive}
// (constant) not clippped:
procedure TFastImage.FilPTValue010; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                       r_val,
                                                       g_val,
                                                       b_val,
    alpha_max-pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue012; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                       r_val,
                                                       g_val,
                                                       b_val,
    alpha_max-pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue014; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                   r_val,
                                                   g_val,
                                                   b_val,
            alpha_max-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                   r_val,
                                                   g_val,
                                                   b_val,
            alpha_max-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                   r_val,
                                                   g_val,
                                                   b_val,
            alpha_max-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                   r_val,
                                                   g_val,
                                                   b_val,
            alpha_max-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilPTValue011; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                       r_val,
                                                       g_val,
                                                       b_val,
alpha_max-Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[1],0));
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilPTValue013; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                       r_val,
                                                       g_val,
                                                       b_val,
alpha_max-Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[1],0));
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue015; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                   r_val,
                                                   g_val,
                                                   b_val,
        alpha_max-Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[1],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                   r_val,
                                                   g_val,
                                                   b_val,
        alpha_max-Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[1],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                   r_val,
                                                   g_val,
                                                   b_val,
        alpha_max-Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[1],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                   r_val,
                                                   g_val,
                                                   b_val,
        alpha_max-Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[1],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}

{Alphablend}
// (constant) not clippped:
procedure TFastImage.FilPTValue020; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                       r_val,
                                                       g_val,
                                                       b_val,
              pt_pix_byte_acl_arr_ptr^,
    alpha_max-pt_pix_byte_acl_arr_ptr^,col_trans_arr[2]);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue022; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                       r_val,
                                                       g_val,
                                                       b_val,
              pt_pix_byte_acl_arr_ptr^,
    alpha_max-pt_pix_byte_acl_arr_ptr^,col_trans_arr[2]);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue024; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                   r_val,
                                                   g_val,
                                                   b_val,
                      pt_pix_byte_acl_arr_ptr^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,col_trans_arr[2]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                   r_val,
                                                   g_val,
                                                   b_val,
                      pt_pix_byte_acl_arr_ptr^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,col_trans_arr[2]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                   r_val,
                                                   g_val,
                                                   b_val,
                      pt_pix_byte_acl_arr_ptr^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,col_trans_arr[2]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                                                   r_val,
                                                   g_val,
                                                   b_val,
                      pt_pix_byte_acl_arr_ptr^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,col_trans_arr[2]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading):
// same;

{Inverse}
// (constant) not clippped:
procedure TFastImage.FilPTValue030; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=InverseDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
    alpha_max-pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue032; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=InverseDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
    alpha_max-pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue034; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=InverseDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=InverseDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=InverseDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  with col_trans_var do
                     (pt_pix_intr_sht_arr_ptr^+v)^:=InverseDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilPTValue031; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=InverseDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
alpha_max-Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[3],0));
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilPTValue033; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=InverseDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
alpha_max-Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[3],0));
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue035; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=InverseDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
        alpha_max-Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[3],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=InverseDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
        alpha_max-Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[3],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=InverseDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
        alpha_max-Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[3],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=InverseDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
        alpha_max-Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[3],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}

{Highlight}
// (constant) not clippped:
procedure TFastImage.FilPTValue040; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=HighlightDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
    alpha_max-pt_pix_byte_acl_arr_ptr^,col_trans_arr[4]);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue042; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=HighlightDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
    alpha_max-pt_pix_byte_acl_arr_ptr^,col_trans_arr[4]);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue044; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=HighlightDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,col_trans_arr[4]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=HighlightDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,col_trans_arr[4]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=HighlightDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,col_trans_arr[4]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=HighlightDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,col_trans_arr[4]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading):
// same;

{Darken}
// (constant) not clippped:
procedure TFastImage.FilPTValue050; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=DarkenDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
    alpha_max-pt_pix_byte_acl_arr_ptr^,col_trans_arr[5]);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue052; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=DarkenDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
    alpha_max-pt_pix_byte_acl_arr_ptr^,col_trans_arr[5]);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue054; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=DarkenDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,col_trans_arr[5]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=DarkenDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,col_trans_arr[5]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=DarkenDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,col_trans_arr[5]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=DarkenDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,col_trans_arr[5]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading):
// same;

{GrayscaleR}
// (constant) not clippped:
procedure TFastImage.FilPTValue060; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleRDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
              pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue062; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleRDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
              pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue064; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleRDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                      pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleRDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                      pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleRDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                      pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleRDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                      pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilPTValue061; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleRDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
          Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[6],0));
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilPTValue063; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleRDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
          Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[6],0));
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue065; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleRDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                  Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[6],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleRDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                  Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[6],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleRDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                  Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[6],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleRDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                  Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[6],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}

{GrayscaleG}
// (constant) not clippped:
procedure TFastImage.FilPTValue070; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleGDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
              pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue072; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleGDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
              pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue074; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleGDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                      pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleGDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                      pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleGDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                      pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleGDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                      pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilPTValue071; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleGDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
          Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[7],0));
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilPTValue073; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleGDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
          Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[7],0));
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue075; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleGDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                  Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[7],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleGDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                  Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[7],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleGDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                  Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[7],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleGDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                  Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[7],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}

{GrayscaleB}
// (constant) not clippped:
procedure TFastImage.FilPTValue080; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleBDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
              pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue082; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleBDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
              pt_pix_byte_acl_arr_ptr^);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue084; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleBDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                      pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleBDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                      pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleBDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                      pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleBDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                      pt_pix_byte_acl_arr_ptr^);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilPTValue081; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleBDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
          Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[8],0));
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilPTValue083; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleBDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
          Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[8],0));
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue085; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleBDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                  Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[8],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleBDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                  Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[8],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleBDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                  Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[8],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleBDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                  Max(pt_pix_byte_acl_arr_ptr^-col_trans_arr[8],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}

{Monochrome Noise}
// (constant) not clippped:
procedure TFastImage.FilPTValue090; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
            if Odd((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
                   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlend(
                   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                             r_val,
                                                             g_val,
                                                             b_val,
                    pt_pix_byte_acl_arr_ptr^,
          alpha_max-pt_pix_byte_acl_arr_ptr^);
          Inc      (pt_pix_intr_sht_arr_ptr);
          Inc      (pt_pix_byte_acl_arr_ptr);
        end;
      Inc          (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue092; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
            if Odd((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
                   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlend(
                   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                             r_val,
                                                             g_val,
                                                             b_val,
                    pt_pix_byte_acl_arr_ptr^,
          alpha_max-pt_pix_byte_acl_arr_ptr^);
          Inc      (pt_pix_intr_sht_arr_ptr);
          Inc      (pt_pix_byte_acl_arr_ptr);
        end;
      Inc          (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue094; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                  with col_trans_var do
                    if Odd((pt_pix_intr_sht_arr_ptr^+v)^) then
                           (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(
                           (pt_pix_intr_sht_arr_ptr^+v)^,
                                                         r_val,
                                                         g_val,
                                                         b_val,
                            pt_pix_byte_acl_arr_ptr^,
                  alpha_max-pt_pix_byte_acl_arr_ptr^);
                  Inc      (pt_pix_intr_sht_arr_ptr);
                  Inc      (pt_pix_byte_acl_arr_ptr);
                end;
              Inc          (pt_pix_intr_sht_arr_ptr,
                            pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc          (pt_pix_byte_acl_arr_ptr,
                            pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                  with col_trans_var do
                    if Odd((pt_pix_intr_sht_arr_ptr^+v)^) then
                           (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(
                           (pt_pix_intr_sht_arr_ptr^+v)^,
                                                         r_val,
                                                         g_val,
                                                         b_val,
                            pt_pix_byte_acl_arr_ptr^,
                  alpha_max-pt_pix_byte_acl_arr_ptr^);
                  Inc      (pt_pix_intr_sht_arr_ptr);
                  Inc      (pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                  with col_trans_var do
                    if Odd((pt_pix_intr_sht_arr_ptr^+v)^) then
                           (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(
                           (pt_pix_intr_sht_arr_ptr^+v)^,
                                                         r_val,
                                                         g_val,
                                                         b_val,
                            pt_pix_byte_acl_arr_ptr^,
                  alpha_max-pt_pix_byte_acl_arr_ptr^);
                  Inc      (pt_pix_intr_sht_arr_ptr);
                  Inc      (pt_pix_byte_acl_arr_ptr);
                end;
              Inc          (pt_pix_intr_sht_arr_ptr,
                            pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc          (pt_pix_byte_acl_arr_ptr,
                            pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  with col_trans_var do
                    if Odd((pt_pix_intr_sht_arr_ptr^+v)^) then
                           (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(
                           (pt_pix_intr_sht_arr_ptr^+v)^,
                                                         r_val,
                                                         g_val,
                                                         b_val,
                            pt_pix_byte_acl_arr_ptr^,
                  alpha_max-pt_pix_byte_acl_arr_ptr^);
                  Inc      (pt_pix_intr_sht_arr_ptr);
                  Inc      (pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilPTValue091; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
            if Odd((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
                   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendDec(
                   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                             r_val,
                                                             g_val,
                                                             b_val,
                    pt_pix_byte_acl_arr_ptr^,
          alpha_max-pt_pix_byte_acl_arr_ptr^,col_trans_arr[9]);
          Inc      (pt_pix_intr_sht_arr_ptr);
          Inc      (pt_pix_byte_acl_arr_ptr);
        end;
      Inc          (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilPTValue093; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          with col_trans_var do
            if Odd((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
                   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendDec(
                   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                                                             r_val,
                                                             g_val,
                                                             b_val,
                    pt_pix_byte_acl_arr_ptr^,
          alpha_max-pt_pix_byte_acl_arr_ptr^,col_trans_arr[9]);
          Inc      (pt_pix_intr_sht_arr_ptr);
          Inc      (pt_pix_byte_acl_arr_ptr);
        end;
      Inc          (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue095; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                  with col_trans_var do
                    if Odd((pt_pix_intr_sht_arr_ptr^+v)^) then
                           (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDec(
                           (pt_pix_intr_sht_arr_ptr^+v)^,
                                                         r_val,
                                                         g_val,
                                                         b_val,
                            pt_pix_byte_acl_arr_ptr^,
                  alpha_max-pt_pix_byte_acl_arr_ptr^,col_trans_arr[9]);
                  Inc      (pt_pix_intr_sht_arr_ptr);
                  Inc      (pt_pix_byte_acl_arr_ptr);
                end;
              Inc          (pt_pix_intr_sht_arr_ptr,
                            pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc          (pt_pix_byte_acl_arr_ptr,
                            pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                  with col_trans_var do
                    if Odd((pt_pix_intr_sht_arr_ptr^+v)^) then
                           (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDec(
                           (pt_pix_intr_sht_arr_ptr^+v)^,
                                                         r_val,
                                                         g_val,
                                                         b_val,
                            pt_pix_byte_acl_arr_ptr^,
                  alpha_max-pt_pix_byte_acl_arr_ptr^,col_trans_arr[9]);
                  Inc      (pt_pix_intr_sht_arr_ptr);
                  Inc      (pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                  with col_trans_var do
                    if Odd((pt_pix_intr_sht_arr_ptr^+v)^) then
                           (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDec(
                           (pt_pix_intr_sht_arr_ptr^+v)^,
                                                         r_val,
                                                         g_val,
                                                         b_val,
                            pt_pix_byte_acl_arr_ptr^,
                  alpha_max-pt_pix_byte_acl_arr_ptr^,col_trans_arr[9]);
                  Inc      (pt_pix_intr_sht_arr_ptr);
                  Inc      (pt_pix_byte_acl_arr_ptr);
                end;
              Inc          (pt_pix_intr_sht_arr_ptr,
                            pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc          (pt_pix_byte_acl_arr_ptr,
                            pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  with col_trans_var do
                    if Odd((pt_pix_intr_sht_arr_ptr^+v)^) then
                           (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDec(
                           (pt_pix_intr_sht_arr_ptr^+v)^,
                                                         r_val,
                                                         g_val,
                                                         b_val,
                            pt_pix_byte_acl_arr_ptr^,
                  alpha_max-pt_pix_byte_acl_arr_ptr^,col_trans_arr[9]);
                  Inc      (pt_pix_intr_sht_arr_ptr);
                  Inc      (pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}

{ColorizeRM}
// (constant) not clippped:
procedure TFastImage.FilPTValue100; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  d                      : smallint;
begin
  d                      :=(col_trans_arr[10]-128)<<1;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=ColorizeRMDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
    alpha_max-pt_pix_byte_acl_arr_ptr^,d);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue102; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  d                      : smallint;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  d                      :=(col_trans_arr[10]-128)<<1;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=ColorizeRMDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
    alpha_max-pt_pix_byte_acl_arr_ptr^,d);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue104; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  d                      : smallint;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  d                      :=(col_trans_arr[10]-128)<<1;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeRMDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,d);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeRMDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,d);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeRMDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,d);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeRMDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,d);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading):
// same;

{ColorizeRP}
// (constant) not clippped:
procedure TFastImage.FilPTValue110; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  d                      : smallint;
begin
  d                      :=(col_trans_arr[11]-128)<<1;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=ColorizeRPDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
    alpha_max-pt_pix_byte_acl_arr_ptr^,d);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue112; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  d                      : smallint;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  d                      :=(col_trans_arr[11]-128)<<1;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=ColorizeRPDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
    alpha_max-pt_pix_byte_acl_arr_ptr^,d);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue114; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  d                      : smallint;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  d                      :=(col_trans_arr[11]-128)<<1;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeRPDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,d);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeRPDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,d);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeRPDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,d);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeRPDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,d);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading):
// same;

{ColorizeGM}
// (constant) not clippped:
procedure TFastImage.FilPTValue120; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  d                      : smallint;
begin
  d                      :=(col_trans_arr[12]-128)<<1;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=ColorizeGMDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
    alpha_max-pt_pix_byte_acl_arr_ptr^,d);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue122; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  d                      : smallint;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  d                      :=(col_trans_arr[12]-128)<<1;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=ColorizeGMDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
    alpha_max-pt_pix_byte_acl_arr_ptr^,d);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue124; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  d                      : smallint;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  d                      :=(col_trans_arr[12]-128)<<1;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeGMDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,d);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeGMDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,d);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeGMDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,d);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeGMDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,d);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading):
// same;

{ColorizeGP}
// (constant) not clippped:
procedure TFastImage.FilPTValue130; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  d                      : smallint;
begin
  d                      :=(col_trans_arr[13]-128)<<1;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=ColorizeGPDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
    alpha_max-pt_pix_byte_acl_arr_ptr^,d);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue132; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  d                      : smallint;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  d                      :=(col_trans_arr[13]-128)<<1;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=ColorizeGPDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
    alpha_max-pt_pix_byte_acl_arr_ptr^,d);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue134; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  d                      : smallint;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  d                      :=(col_trans_arr[13]-128)<<1;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeGPDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,d);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeGPDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,d);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeGPDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,d);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeGPDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,d);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading):
// same;

{ColorizeBM}
// (constant) not clippped:
procedure TFastImage.FilPTValue140; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  d                      : smallint;
begin
  d                      :=(col_trans_arr[14]-128)<<1;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=ColorizeBMDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
    alpha_max-pt_pix_byte_acl_arr_ptr^,d);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue142; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  d                      : smallint;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  d                      :=(col_trans_arr[14]-128)<<1;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=ColorizeBMDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
    alpha_max-pt_pix_byte_acl_arr_ptr^,d);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue144; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  d                      : smallint;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  d                      :=(col_trans_arr[14]-128)<<1;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeBMDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,d);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeBMDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,d);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeBMDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,d);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeBMDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,d);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading):
// same;

{ColorizeBP}
// (constant) not clippped:
procedure TFastImage.FilPTValue150; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  d                      : smallint;
begin
  d                      :=(col_trans_arr[15]-128)<<1;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=ColorizeBPDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
    alpha_max-pt_pix_byte_acl_arr_ptr^,d);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue152; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  d                      : smallint;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  d                      :=(col_trans_arr[15]-128)<<1;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=ColorizeBPDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
    alpha_max-pt_pix_byte_acl_arr_ptr^,d);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue154; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  d                      : smallint;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  d                      :=(col_trans_arr[15]-128)<<1;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_byte_acl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeBPDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,d);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_byte_acl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeBPDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,d);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_byte_acl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeBPDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,d);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (pt_pix_byte_acl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeBPDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
            alpha_max-pt_pix_byte_acl_arr_ptr^,d);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_byte_acl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRGB}
// (constant) not clippped:
procedure TFastImage.FilPTValue160; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_0(@BlurRGB);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue162; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_2(@BlurRGB);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue164; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_4(@BlurRGB);
end; {$endregion}
// (fading):
// same;

{BlurRRB}
// (constant) not clippped:
procedure TFastImage.FilPTValue170; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_0(@BlurRRB);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue172; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_2(@BlurRRB);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue174; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_4(@BlurRRB);
end; {$endregion}
// (fading):
// same;

{BlurRGR}
// (constant) not clippped:
procedure TFastImage.FilPTValue180; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_0(@BlurRGR);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue182; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_2(@BlurRGR);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue184; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_4(@BlurRGR);
end; {$endregion}
// (fading):
// same;

{BlurGGB}
// (constant) not clippped:
procedure TFastImage.FilPTValue190; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_0(@BlurGGB);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue192; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_2(@BlurGGB);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue194; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_4(@BlurGGB);
end; {$endregion}
// (fading):
// same;

{BlurRGG}
// (constant) not clippped:
procedure TFastImage.FilPTValue200; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_0(@BlurRGG);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue202; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_2(@BlurRGG);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue204; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_4(@BlurRGG);
end; {$endregion}
// (fading):
// same;

{BlurBGB}
// (constant) not clippped:
procedure TFastImage.FilPTValue210; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_0(@BlurBGB);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue212; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_2(@BlurBGB);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue214; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_4(@BlurBGB);
end; {$endregion}
// (fading):
// same;

{BlurRBB}
// (constant) not clippped:
procedure TFastImage.FilPTValue220; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_0(@BlurRBB);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue222; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_2(@BlurRBB);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue224; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_4(@BlurRBB);
end; {$endregion}
// (fading):
// same;

{BlurRRR}
// (constant) not clippped:
procedure TFastImage.FilPTValue230; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_0(@BlurRRR);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue232; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_2(@BlurRRR);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue234; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_4(@BlurRRR);
end; {$endregion}
// (fading):
// same;

{BlurGGG}
// (constant) not clippped:
procedure TFastImage.FilPTValue240; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_0(@BlurGGG);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue242; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_2(@BlurGGG);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue244; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_4(@BlurGGG);
end; {$endregion}
// (fading):
// same;

{BlurBBB}
// (constant) not clippped:
procedure TFastImage.FilPTValue250; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_0(@BlurBBB);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTValue252; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_2(@BlurBBB);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTValue254; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FilPTProc1_4(@BlurBBB);
end; {$endregion}
// (fading):
// same;

{Color of Curent Layer}
// (constant) not clippped:
procedure TFastImage.FilPTColor000; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_intr_ccl_arr_ptr:=Unaligned( pt_pix_intr_arr_ptr);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlend(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
        Blue (pt_pix_intr_ccl_arr_ptr^),
        Green(pt_pix_intr_ccl_arr_ptr^),
        Red  (pt_pix_intr_ccl_arr_ptr^),
              pt_pix_intr_ccl_arr_ptr^>>24,
    alpha_max-pt_pix_intr_ccl_arr_ptr^>>24);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_ccl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTColor002; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_intr_ccl_arr_ptr:=Unaligned(@pt_pix_intr_arr_ptr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlend(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
        Blue (pt_pix_intr_ccl_arr_ptr^),
        Green(pt_pix_intr_ccl_arr_ptr^),
        Red  (pt_pix_intr_ccl_arr_ptr^),
              pt_pix_intr_ccl_arr_ptr^>>24,
    alpha_max-pt_pix_intr_ccl_arr_ptr^>>24);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_ccl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTColor004; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.left>bmp_ftimg_width -1) then
    Exit;
  if (rct_src.top >bmp_ftimg_height-1) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_intr_ccl_arr_ptr:=Unaligned(@pt_pix_intr_arr_ptr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_intr_ccl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                Blue (pt_pix_intr_ccl_arr_ptr^   ),
                Green(pt_pix_intr_ccl_arr_ptr^   ),
                Red  (pt_pix_intr_ccl_arr_ptr^   ),
                      pt_pix_intr_ccl_arr_ptr^>>24,
            alpha_max-pt_pix_intr_ccl_arr_ptr^>>24);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (pt_pix_intr_ccl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_intr_ccl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_intr_ccl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                Blue (pt_pix_intr_ccl_arr_ptr^),
                Green(pt_pix_intr_ccl_arr_ptr^),
                Red  (pt_pix_intr_ccl_arr_ptr^),
                      pt_pix_intr_ccl_arr_ptr^>>24,
            alpha_max-pt_pix_intr_ccl_arr_ptr^>>24);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_intr_ccl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                Blue (pt_pix_intr_ccl_arr_ptr^),
                Green(pt_pix_intr_ccl_arr_ptr^),
                Red  (pt_pix_intr_ccl_arr_ptr^),
                      pt_pix_intr_ccl_arr_ptr^>>24,
            alpha_max-pt_pix_intr_ccl_arr_ptr^>>24);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (pt_pix_intr_ccl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlend(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                Blue (pt_pix_intr_ccl_arr_ptr^),
                Green(pt_pix_intr_ccl_arr_ptr^),
                Red  (pt_pix_intr_ccl_arr_ptr^),
                      pt_pix_intr_ccl_arr_ptr^>>24,
            alpha_max-pt_pix_intr_ccl_arr_ptr^>>24);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) image has transparent alpha channel:
procedure TFastImage.FilPTColor006; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPAlphaBlend(bmp_color_ptr,
               bmp_bkgnd_ptr,
               rct_src,
               rct_dst,
               bmp_ftimg_width_origin{bmp_ftimg_width},
               bmp_bkgnd_width,
               col_trans_arr[2]);
end; {$endregion}
// (fading):
// same;

{Color of Curent Layer(Additive)}
// (constant) not clippped:
procedure TFastImage.FilPTColor010; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_intr_ccl_arr_ptr:=Unaligned( pt_pix_intr_arr_ptr);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
        Blue (pt_pix_intr_ccl_arr_ptr^),
        Green(pt_pix_intr_ccl_arr_ptr^),
        Red  (pt_pix_intr_ccl_arr_ptr^),
    alpha_max-pt_pix_intr_ccl_arr_ptr^>>24);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_ccl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTColor012; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_intr_ccl_arr_ptr:=Unaligned(@pt_pix_intr_arr_ptr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
        Blue (pt_pix_intr_ccl_arr_ptr^),
        Green(pt_pix_intr_ccl_arr_ptr^),
        Red  (pt_pix_intr_ccl_arr_ptr^),
    alpha_max-pt_pix_intr_ccl_arr_ptr^>>24);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_ccl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTColor014; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_intr_ccl_arr_ptr:=Unaligned(@pt_pix_intr_arr_ptr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_intr_ccl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                Blue (pt_pix_intr_ccl_arr_ptr^),
                Green(pt_pix_intr_ccl_arr_ptr^),
                Red  (pt_pix_intr_ccl_arr_ptr^),
            alpha_max-pt_pix_intr_ccl_arr_ptr^>>24);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (pt_pix_intr_ccl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_intr_ccl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_intr_ccl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                Blue (pt_pix_intr_ccl_arr_ptr^),
                Green(pt_pix_intr_ccl_arr_ptr^),
                Red  (pt_pix_intr_ccl_arr_ptr^),
            alpha_max-pt_pix_intr_ccl_arr_ptr^>>24);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_intr_ccl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                Blue (pt_pix_intr_ccl_arr_ptr^),
                Green(pt_pix_intr_ccl_arr_ptr^),
                Red  (pt_pix_intr_ccl_arr_ptr^),
            alpha_max-pt_pix_intr_ccl_arr_ptr^>>24);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (pt_pix_intr_ccl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                Blue (pt_pix_intr_ccl_arr_ptr^),
                Green(pt_pix_intr_ccl_arr_ptr^),
                Red  (pt_pix_intr_ccl_arr_ptr^),
            alpha_max-pt_pix_intr_ccl_arr_ptr^>>24);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImage.FilPTColor016; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPAdditiveDec(bmp_color_ptr,
                bmp_bkgnd_ptr,
                rct_src,
                rct_dst,
                bmp_ftimg_width_origin{bmp_ftimg_width},
                bmp_bkgnd_width,
                col_trans_arr[1]);
end; {$endregion}
// (fading) not clippped:
procedure TFastImage.FilPTColor011; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_intr_ccl_arr_ptr:=Unaligned( pt_pix_intr_arr_ptr);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
      Blue   (pt_pix_intr_ccl_arr_ptr^),
      Green  (pt_pix_intr_ccl_arr_ptr^),
      Red    (pt_pix_intr_ccl_arr_ptr^),
alpha_max-Max(pt_pix_intr_ccl_arr_ptr^>>024-col_trans_arr[1],0));
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_ccl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImage.FilPTColor013; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_intr_ccl_arr_ptr:=Unaligned(@pt_pix_intr_arr_ptr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
      Blue   (pt_pix_intr_ccl_arr_ptr^),
      Green  (pt_pix_intr_ccl_arr_ptr^),
      Red    (pt_pix_intr_ccl_arr_ptr^),
alpha_max-Max(pt_pix_intr_ccl_arr_ptr^>>024-col_trans_arr[1],0));
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_ccl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImage.FilPTColor015; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_intr_ccl_arr_ptr:=Unaligned(@pt_pix_intr_arr_ptr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_intr_ccl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
              Blue   (pt_pix_intr_ccl_arr_ptr^),
              Green  (pt_pix_intr_ccl_arr_ptr^),
              Red    (pt_pix_intr_ccl_arr_ptr^),
        alpha_max-Max(pt_pix_intr_ccl_arr_ptr^>>024-col_trans_arr[1],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (pt_pix_intr_ccl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_intr_ccl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_intr_ccl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
              Blue   (pt_pix_intr_ccl_arr_ptr^),
              Green  (pt_pix_intr_ccl_arr_ptr^),
              Red    (pt_pix_intr_ccl_arr_ptr^),
        alpha_max-Max(pt_pix_intr_ccl_arr_ptr^>>024-col_trans_arr[1],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_intr_ccl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
              Blue   (pt_pix_intr_ccl_arr_ptr^),
              Green  (pt_pix_intr_ccl_arr_ptr^),
              Red    (pt_pix_intr_ccl_arr_ptr^),
        alpha_max-Max(pt_pix_intr_ccl_arr_ptr^>>024-col_trans_arr[1],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (pt_pix_intr_ccl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
              Blue   (pt_pix_intr_ccl_arr_ptr^),
              Green  (pt_pix_intr_ccl_arr_ptr^),
              Red    (pt_pix_intr_ccl_arr_ptr^),
        alpha_max-Max(pt_pix_intr_ccl_arr_ptr^>>024-col_trans_arr[1],0));
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) image has monochrome color channel
// same as (constant)

{Color of Curent Layer(Alphablend)}
// (constant) not clippped:
procedure TFastImage.FilPTColor020; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
  pt_pix_intr_ccl_arr_ptr:=Unaligned( pt_pix_intr_arr_ptr);
  for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
        Blue (pt_pix_intr_ccl_arr_ptr^),
        Green(pt_pix_intr_ccl_arr_ptr^),
        Red  (pt_pix_intr_ccl_arr_ptr^),
              pt_pix_intr_ccl_arr_ptr^>>24,
    alpha_max-pt_pix_intr_ccl_arr_ptr^>>24,col_trans_arr[2]);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_ccl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImage.FilPTColor022; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(rct_src.top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  pt_pix_intr_ccl_arr_ptr:=Unaligned(@pt_pix_intr_arr_ptr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendDec(
             (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
        Blue (pt_pix_intr_ccl_arr_ptr^),
        Green(pt_pix_intr_ccl_arr_ptr^),
        Red  (pt_pix_intr_ccl_arr_ptr^),
              pt_pix_intr_ccl_arr_ptr^>>24,
    alpha_max-pt_pix_intr_ccl_arr_ptr^>>24,col_trans_arr[2]);
          Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_ccl_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImage.FilPTColor024; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  first_sht_pix_ptr      : PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.pt_rct.top*bmp_bkgnd_width+rct_dst.pt_rct.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  pt_pix_intr_ccl_arr_ptr:=Unaligned(@pt_pix_intr_arr_ptr[pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
  for y:=0 to rct_src.height-1 do
    begin
      if (pt_pix_intr_cnt_arr_ptr^<>0) then
        begin
          pix_color_ptr    :=first_row_pix_ptr;
          first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

          {left-right-clipped} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              Inc(pt_pix_intr_sht_arr_ptr,c1+1);
              Inc(pt_pix_intr_ccl_arr_ptr,c1+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                Blue (pt_pix_intr_ccl_arr_ptr^),
                Green(pt_pix_intr_ccl_arr_ptr^),
                Red  (pt_pix_intr_ccl_arr_ptr^),
                      pt_pix_intr_ccl_arr_ptr^>>24,
            alpha_max-pt_pix_intr_ccl_arr_ptr^>>24,col_trans_arr[2]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              Inc    (pt_pix_intr_ccl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c2+1));
              goto label1;
            end; {$endregion}

          {left-clipped------} {$region -fold}
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_intr_ccl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if (first_sht_pix_ptr^<rct_src.left) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
              Inc(pt_pix_intr_sht_arr_ptr,c+1);
              Inc(pt_pix_intr_ccl_arr_ptr,c+1);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                Blue (pt_pix_intr_ccl_arr_ptr^),
                Green(pt_pix_intr_ccl_arr_ptr^),
                Red  (pt_pix_intr_ccl_arr_ptr^),
                      pt_pix_intr_ccl_arr_ptr^>>24,
            alpha_max-pt_pix_intr_ccl_arr_ptr^>>24,col_trans_arr[2]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
              goto label1;
            end; {$endregion}

          {right-clipped-----} {$region -fold}
          if (first_sht_pix_ptr^>=rct_src.right) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              Inc(pt_pix_intr_ccl_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
              goto label1;
            end
          else
          if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
            begin
              c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to c do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                Blue (pt_pix_intr_ccl_arr_ptr^),
                Green(pt_pix_intr_ccl_arr_ptr^),
                Red  (pt_pix_intr_ccl_arr_ptr^),
                      pt_pix_intr_ccl_arr_ptr^>>24,
            alpha_max-pt_pix_intr_ccl_arr_ptr^>>24,col_trans_arr[2]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
              Inc    (pt_pix_intr_sht_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              Inc    (pt_pix_intr_ccl_arr_ptr,
                      pt_pix_intr_cnt_arr_ptr^-(c+1));
              goto label1;
            end; {$endregion}

          {not clipped-------} {$region -fold}
          if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
             ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
            begin
              v:=pix_color_ptr-rct_src.left;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                     (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDec(
                     (pt_pix_intr_sht_arr_ptr^+v)^,
                Blue (pt_pix_intr_ccl_arr_ptr^),
                Green(pt_pix_intr_ccl_arr_ptr^),
                Red  (pt_pix_intr_ccl_arr_ptr^),
                      pt_pix_intr_ccl_arr_ptr^>>24,
            alpha_max-pt_pix_intr_ccl_arr_ptr^>>24,col_trans_arr[2]);
                  Inc(pt_pix_intr_sht_arr_ptr);
                  Inc(pt_pix_intr_ccl_arr_ptr);
                end;
            end; {$endregion}

        end;
      label1:
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading):
// same;

{Fill Array at Specified Rectangle with Specified Value}
// NT - not transparent pixels:
procedure TFastImage.FilNTValueArrA(var arr_src:TColorArr ; constref bmp_ftimg_width_:TColor; constref val:TColor=0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_value_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
//nt_pix_intr_val_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (nt_pix_cnt=0) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@arr_src            [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width_+bmp_src_rct_clp.left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
//nt_pix_intr_val_arr_ptr:=Unaligned(@nt_pix_intr_val_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_value_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_value_ptr)^:=val;
          Inc(nt_pix_intr_sht_arr_ptr);
        //Inc(nt_pix_intr_val_arr_ptr);
        end;
      Inc    (nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_ftimg_width_);
    end;
end; {$endregion}
procedure TFastImage.FilNTValueArrB(var arr_src:T1Byte1Arr; constref bmp_ftimg_width_:TColor; constref val:byte  =0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_value_ptr          : PByte;
  first_row_pix_ptr      : PByte;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
//nt_pix_intr_val_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (nt_pix_cnt=0) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@arr_src            [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width_+bmp_src_rct_clp.left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
//nt_pix_intr_val_arr_ptr:=Unaligned(@nt_pix_intr_val_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_value_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_value_ptr)^:=val;
          Inc(nt_pix_intr_sht_arr_ptr);
        //Inc(nt_pix_intr_val_arr_ptr);
        end;
      Inc    (nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_ftimg_width_);
    end;
end; {$endregion}
// PT - partly transparent pixels:
procedure TFastImage.FilPTValueArrA(var arr_src:TColorArr ; constref bmp_ftimg_width_:TColor; constref val:TColor=0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_value_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
//pt_pix_intr_val_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (pt_pix_cnt=0) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@arr_src            [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width_+bmp_src_rct_clp.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
//pt_pix_intr_val_arr_ptr:=Unaligned(@pt_pix_intr_val_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_value_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_value_ptr)^:=val;
          Inc(pt_pix_intr_sht_arr_ptr);
        //Inc(pt_pix_intr_val_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_ftimg_width_);
    end;
end; {$endregion}
procedure TFastImage.FilPTValueArrB(var arr_src:T1Byte1Arr; constref bmp_ftimg_width_:TColor; constref val:byte  =0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_value_ptr          : PByte;
  first_row_pix_ptr      : PByte;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
//pt_pix_intr_val_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (pt_pix_cnt=0) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@arr_src            [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width_+bmp_src_rct_clp.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
//pt_pix_intr_val_arr_ptr:=Unaligned(@pt_pix_intr_val_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
    begin
      pix_value_ptr:=first_row_pix_ptr;
      for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (pt_pix_intr_sht_arr_ptr^+pix_value_ptr)^:=val;
          Inc(pt_pix_intr_sht_arr_ptr);
        //Inc(pt_pix_intr_val_arr_ptr);
        end;
      Inc    (pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_ftimg_width_);
    end;
end; {$endregion}

{Restore Source Image from Compressed Image}
procedure TFastImage.ResNTValueArr(var arr_src:TColorArr; constref bmp_ftimg_width_:TColor);                          {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_value_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_val_arr_ptr: PInteger;
  x,y                    : integer;
begin
  if (nt_pix_cnt=0) then
    Exit;
  first_row_pix_ptr      :=Unaligned(@arr_src            [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width_+bmp_src_rct_clp.left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  nt_pix_intr_val_arr_ptr:=Unaligned(@nt_pix_intr_val_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_value_ptr:=first_row_pix_ptr;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
             (nt_pix_intr_sht_arr_ptr^+pix_value_ptr)^:=nt_pix_intr_val_arr_ptr^;
          Inc(nt_pix_intr_sht_arr_ptr);
          Inc(nt_pix_intr_val_arr_ptr);
        end;
      Inc    (nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_ftimg_width_);
    end;
end; {$endregion}

// Check NTValueArr:
function  TFastImage.ChkNTValueArr: boolean;                                                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=({@}nt_pix_intr_val_arr{[0]}=Nil);
end; {$endregion}

// NT - not transparent pixels:
procedure TFastImage.SetNTNilToPtr; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TFastImage.SetNTCCLToPtr; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  nt_pix_intr_arr_ptr:=Unaligned(@nt_pix_intr_ccl_arr[0]);
end; {$endregion}
procedure TFastImage.SetNTCLLToPtr; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  nt_pix_intr_arr_ptr:=Unaligned(@nt_pix_intr_cll_arr[0]);
end; {$endregion}

// PT - partly transparent pixels:
procedure TFastImage.SetPTNilToPtr; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TFastImage.SetPTCCLToPtr; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pt_pix_intr_arr_ptr:=Unaligned(@pt_pix_intr_ccl_arr[0]);
end; {$endregion}
procedure TFastImage.SetPTCLLToPtr; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pt_pix_intr_arr_ptr:=Unaligned(@pt_pix_intr_cll_arr[0]);
end; {$endregion}

// Procedures Table Init.:
procedure TFastimage.FilProcInit; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  // NT - not transparent pixels;
  NTBeginProc[000]:=Unaligned(@SetNTNilToPtr);
  NTBeginProc[001]:=Unaligned(@SetNTCCLToPtr);
  NTBeginProc[002]:=Unaligned(@SetNTCLLToPtr);

  // PT - partly transparent pixels;
  PTBeginProc[000]:=Unaligned(@SetPTNilToPtr);
  PTBeginProc[001]:=Unaligned(@SetPTCCLToPtr);
  PTBeginProc[002]:=Unaligned(@SetPTCLLToPtr);



  // NT - not transparent pixels;

  {Empty}
  NTValueProc[009]:=Unaligned(@FilNTValue009);
  {Empty}
  NTColorProc[009]:=Unaligned(@FilNTColor009);

  {Monochrome}
  // (constant) not clippped
  NTValueProc[000]:=Unaligned(@FilNTValue000);
  // (constant) top-bottom clippped
  NTValueProc[002]:=Unaligned(@FilNTValue002);
  // (constant) left-right-top-bottom clippped
  NTValueProc[004]:=Unaligned(@FilNTValue004);
  // (constant) image has monochrome color channel
  NTValueProc[006]:=Unaligned(@FilNTValue006);
  // (fading) not clippped
  NTValueProc[001]:=Unaligned(@FilNTValue000);
  // (fading) top-bottom clippped
  NTValueProc[003]:=Unaligned(@FilNTValue002);
  // (fading) left-right-top-bottom clippped
  NTValueProc[005]:=Unaligned(@FilNTValue004);
  // (fading) image has monochrome color channel
  NTValueProc[007]:=Unaligned(@FilNTValue006);

  {Additive}
  // (constant) not clippped
  NTValueProc[010]:=Unaligned(@FilNTValue010);
  // (constant) top-bottom clippped
  NTValueProc[012]:=Unaligned(@FilNTValue012);
  // (constant) left-right-top-bottom clippped
  NTValueProc[014]:=Unaligned(@FilNTValue014);
  // (constant) image has monochrome color channel
  NTValueProc[016]:=Unaligned(@FilNTValue016);
  // (fading) not clippped
  NTValueProc[011]:=Unaligned(@FilNTValue011);
  // (fading) top-bottom clippped
  NTValueProc[013]:=Unaligned(@FilNTValue013);
  // (fading) left-right-top-bottom clippped
  NTValueProc[015]:=Unaligned(@FilNTValue015);
  // (fading) image has monochrome color channel
  NTValueProc[017]:=Unaligned(@FilNTValue017);

  {Alphablend}
  // (constant) not clippped
  NTValueProc[020]:=Unaligned(@FilNTValue020);
  // (constant) top-bottom clippped
  NTValueProc[022]:=Unaligned(@FilNTValue022);
  // (constant) left-right-top-bottom clippped
  NTValueProc[024]:=Unaligned(@FilNTValue024);
  // (constant) image has monochrome color channel
  NTValueProc[026]:=Unaligned(@FilNTValue026);
  // (fading) not clippped
  NTValueProc[021]:=Unaligned(@FilNTValue020);
  // (fading) top-bottom clippped
  NTValueProc[023]:=Unaligned(@FilNTValue022);
  // (fading) left-right-top-bottom clippped
  NTValueProc[025]:=Unaligned(@FilNTValue024);
  // (fading) image has monochrome color channel
  NTValueProc[027]:=Unaligned(@FilNTValue026);

  {Inverse}
  // (constant) not clippped
  NTValueProc[030]:=Unaligned(@FilNTValue030);
  // (constant) top-bottom clippped
  NTValueProc[032]:=Unaligned(@FilNTValue032);
  // (constant) left-right-top-bottom clippped
  NTValueProc[034]:=Unaligned(@FilNTValue034);
  // (constant) image has monochrome color channel
  NTValueProc[036]:=Unaligned(@FilNTValue036);
  // (fading) not clippped
  NTValueProc[031]:=Unaligned(@FilNTValue031);
  // (fading) top-bottom clippped
  NTValueProc[033]:=Unaligned(@FilNTValue033);
  // (fading) left-right-top-bottom clippped
  NTValueProc[035]:=Unaligned(@FilNTValue035);
  // (fading) image has monochrome color channel
  NTValueProc[037]:=Unaligned(@FilNTValue037);

  {Highlight}
  // (constant) not clippped
  NTValueProc[040]:=Unaligned(@FilNTValue040);
  // (constant) top-bottom clippped
  NTValueProc[042]:=Unaligned(@FilNTValue042);
  // (constant) left-right-top-bottom clippped
  NTValueProc[044]:=Unaligned(@FilNTValue044);
  // (constant) image has monochrome color channel
  NTValueProc[046]:=Unaligned(@FilNTValue046);
  // (fading) not clippped
  NTValueProc[041]:=Unaligned(@FilNTValue040);
  // (fading) top-bottom clippped
  NTValueProc[043]:=Unaligned(@FilNTValue042);
  // (fading) left-right-top-bottom clippped
  NTValueProc[045]:=Unaligned(@FilNTValue044);
  // (fading) image has monochrome color channel
  NTValueProc[047]:=Unaligned(@FilNTValue046);

  {Darken}
  // (constant) not clippped
  NTValueProc[050]:=Unaligned(@FilNTValue050);
  // (constant) top-bottom clippped
  NTValueProc[052]:=Unaligned(@FilNTValue052);
  // (constant) left-right-top-bottom clippped
  NTValueProc[054]:=Unaligned(@FilNTValue054);
  // (constant) image has monochrome color channel
  NTValueProc[056]:=Unaligned(@FilNTValue056);
  // (fading) not clippped
  NTValueProc[051]:=Unaligned(@FilNTValue050);
  // (fading) top-bottom clippped
  NTValueProc[053]:=Unaligned(@FilNTValue052);
  // (fading) left-right-top-bottom clippped
  NTValueProc[055]:=Unaligned(@FilNTValue054);
  // (fading) image has monochrome color channel
  NTValueProc[057]:=Unaligned(@FilNTValue056);

  {GrayscaleR}
  // (constant) not clippped
  NTValueProc[060]:=Unaligned(@FilNTValue060);
  // (constant) top-bottom clippped
  NTValueProc[062]:=Unaligned(@FilNTValue062);
  // (constant) left-right-top-bottom clippped
  NTValueProc[064]:=Unaligned(@FilNTValue064);
  // (constant) image has monochrome color channel
  NTValueProc[066]:=Unaligned(@FilNTValue066);
  // (fading) not clippped
  NTValueProc[061]:=Unaligned(@FilNTValue061);
  // (fading) top-bottom clippped
  NTValueProc[063]:=Unaligned(@FilNTValue063);
  // (fading) left-right-top-bottom clippped
  NTValueProc[065]:=Unaligned(@FilNTValue065);
  // (fading) image has monochrome color channel
  NTValueProc[067]:=Unaligned(@FilNTValue067);

  {GrayscaleG}
  // (constant) not clippped
  NTValueProc[070]:=Unaligned(@FilNTValue070);
  // (constant) top-bottom clippped
  NTValueProc[072]:=Unaligned(@FilNTValue072);
  // (constant) left-right-top-bottom clippped
  NTValueProc[074]:=Unaligned(@FilNTValue074);
  // (constant) image has monochrome color channel
  NTValueProc[076]:=Unaligned(@FilNTValue076);
  // (fading) not clippped
  NTValueProc[071]:=Unaligned(@FilNTValue071);
  // (fading) top-bottom clippped
  NTValueProc[073]:=Unaligned(@FilNTValue073);
  // (fading) left-right-top-bottom clippped
  NTValueProc[075]:=Unaligned(@FilNTValue075);
  // (fading) image has monochrome color channel
  NTValueProc[077]:=Unaligned(@FilNTValue077);

  {GrayscaleB}
  // (constant) not clippped
  NTValueProc[080]:=Unaligned(@FilNTValue080);
  // (constant) top-bottom clippped
  NTValueProc[082]:=Unaligned(@FilNTValue082);
  // (constant) left-right-top-bottom clippped
  NTValueProc[084]:=Unaligned(@FilNTValue084);
  // (constant) image has monochrome color channel
  NTValueProc[086]:=Unaligned(@FilNTValue086);
  // (fading) not clippped
  NTValueProc[081]:=Unaligned(@FilNTValue081);
  // (fading) top-bottom clippped
  NTValueProc[083]:=Unaligned(@FilNTValue083);
  // (fading) left-right-top-bottom clippped
  NTValueProc[085]:=Unaligned(@FilNTValue085);
  // (fading) image has monochrome color channel
  NTValueProc[087]:=Unaligned(@FilNTValue087);

  {Monochrome Noise}
  // (constant) not clippped
  NTValueProc[090]:=Unaligned(@FilNTValue090);
  // (constant) top-bottom clippped
  NTValueProc[092]:=Unaligned(@FilNTValue092);
  // (constant) left-right-top-bottom clippped
  NTValueProc[094]:=Unaligned(@FilNTValue094);
  // (constant) image has monochrome color channel
  NTValueProc[096]:=Unaligned(@FilNTValue096);
  // (fading) not clippped
  NTValueProc[091]:=Unaligned(@FilNTValue091);
  // (fading) top-bottom clippped
  NTValueProc[093]:=Unaligned(@FilNTValue093);
  // (fading) left-right-top-bottom clippped
  NTValueProc[095]:=Unaligned(@FilNTValue095);
  // (fading) image has monochrome color channel
  NTValueProc[097]:=Unaligned(@FilNTValue097);

  {ColorizeRM}
  // (constant) not clippped
  NTValueProc[100]:=Unaligned(@FilNTValue100);
  // (constant) top-bottom clippped
  NTValueProc[102]:=Unaligned(@FilNTValue102);
  // (constant) left-right-top-bottom clippped
  NTValueProc[104]:=Unaligned(@FilNTValue104);
  // (constant) image has monochrome color channel
  NTValueProc[106]:=Unaligned(@FilNTValue106);
  // (fading) not clippped
  NTValueProc[101]:=Unaligned(@FilNTValue100);
  // (fading) top-bottom clippped
  NTValueProc[103]:=Unaligned(@FilNTValue102);
  // (fading) left-right-top-bottom clippped
  NTValueProc[105]:=Unaligned(@FilNTValue104);
  // (fading) image has monochrome color channel
  NTValueProc[107]:=Unaligned(@FilNTValue106);

  {ColorizeRP}
  // (constant) not clippped
  NTValueProc[110]:=Unaligned(@FilNTValue110);
  // (constant) top-bottom clippped
  NTValueProc[112]:=Unaligned(@FilNTValue112);
  // (constant) left-right-top-bottom clippped
  NTValueProc[114]:=Unaligned(@FilNTValue114);
  // (constant) image has monochrome color channel
  NTValueProc[116]:=Unaligned(@FilNTValue116);
  // (fading) not clippped
  NTValueProc[111]:=Unaligned(@FilNTValue110);
  // (fading) top-bottom clippped
  NTValueProc[113]:=Unaligned(@FilNTValue112);
  // (fading) left-right-top-bottom clippped
  NTValueProc[115]:=Unaligned(@FilNTValue114);
  // (fading) image has monochrome color channel
  NTValueProc[117]:=Unaligned(@FilNTValue116);

  {ColorizeGM}
  // (constant) not clippped
  NTValueProc[120]:=Unaligned(@FilNTValue120);
  // (constant) top-bottom clippped
  NTValueProc[122]:=Unaligned(@FilNTValue122);
  // (constant) left-right-top-bottom clippped
  NTValueProc[124]:=Unaligned(@FilNTValue124);
  // (constant) image has monochrome color channel
  NTValueProc[126]:=Unaligned(@FilNTValue126);
  // (fading) not clippped
  NTValueProc[121]:=Unaligned(@FilNTValue120);
  // (fading) top-bottom clippped
  NTValueProc[123]:=Unaligned(@FilNTValue122);
  // (fading) left-right-top-bottom clippped
  NTValueProc[125]:=Unaligned(@FilNTValue124);
  // (fading) image has monochrome color channel
  NTValueProc[127]:=Unaligned(@FilNTValue126);

  {ColorizeGP}
  // (constant) not clippped
  NTValueProc[130]:=Unaligned(@FilNTValue130);
  // (constant) top-bottom clippped
  NTValueProc[132]:=Unaligned(@FilNTValue132);
  // (constant) left-right-top-bottom clippped
  NTValueProc[134]:=Unaligned(@FilNTValue134);
  // (constant) image has monochrome color channel
  NTValueProc[136]:=Unaligned(@FilNTValue136);
  // (fading) not clippped
  NTValueProc[131]:=Unaligned(@FilNTValue130);
  // (fading) top-bottom clippped
  NTValueProc[133]:=Unaligned(@FilNTValue132);
  // (fading) left-right-top-bottom clippped
  NTValueProc[135]:=Unaligned(@FilNTValue134);
  // (fading) image has monochrome color channel
  NTValueProc[137]:=Unaligned(@FilNTValue136);

  {ColorizeBM}
  // (constant) not clippped
  NTValueProc[140]:=Unaligned(@FilNTValue140);
  // (constant) top-bottom clippped
  NTValueProc[142]:=Unaligned(@FilNTValue142);
  // (constant) left-right-top-bottom clippped
  NTValueProc[144]:=Unaligned(@FilNTValue144);
  // (constant) image has monochrome color channel
  NTValueProc[146]:=Unaligned(@FilNTValue146);
  // (fading) not clippped
  NTValueProc[141]:=Unaligned(@FilNTValue140);
  // (fading) top-bottom clippped
  NTValueProc[143]:=Unaligned(@FilNTValue142);
  // (fading) left-right-top-bottom clippped
  NTValueProc[145]:=Unaligned(@FilNTValue144);
  // (fading) image has monochrome color channel
  NTValueProc[147]:=Unaligned(@FilNTValue146);

  {ColorizeBP}
  // (constant) not clippped
  NTValueProc[150]:=Unaligned(@FilNTValue150);
  // (constant) top-bottom clippped
  NTValueProc[152]:=Unaligned(@FilNTValue152);
  // (constant) left-right-top-bottom clippped
  NTValueProc[154]:=Unaligned(@FilNTValue154);
  // (constant) image has monochrome color channel
  NTValueProc[156]:=Unaligned(@FilNTValue156);
  // (fading) not clippped
  NTValueProc[151]:=Unaligned(@FilNTValue150);
  // (fading) top-bottom clippped
  NTValueProc[153]:=Unaligned(@FilNTValue152);
  // (fading) left-right-top-bottom clippped
  NTValueProc[155]:=Unaligned(@FilNTValue154);
  // (fading) image has monochrome color channel
  NTValueProc[157]:=Unaligned(@FilNTValue156);

  {BlurRGB}
  // (constant) not clippped
  NTValueProc[160]:=Unaligned(@FilNTValue160);
  // (constant) top-bottom clippped
  NTValueProc[162]:=Unaligned(@FilNTValue162);
  // (constant) left-right-top-bottom clippped
  NTValueProc[164]:=Unaligned(@FilNTValue164);
  // (constant) image has monochrome color channel
  NTValueProc[166]:=Unaligned(@FilNTValue166);
  // (fading) not clippped
  NTValueProc[161]:=Unaligned(@FilNTValue160);
  // (fading) top-bottom clippped
  NTValueProc[163]:=Unaligned(@FilNTValue162);
  // (fading) left-right-top-bottom clippped
  NTValueProc[165]:=Unaligned(@FilNTValue164);
  // (fading) image has monochrome color channel
  NTValueProc[167]:=Unaligned(@FilNTValue166);

  {BlurRRB}
  // (constant) not clippped
  NTValueProc[170]:=Unaligned(@FilNTValue170);
  // (constant) top-bottom clippped
  NTValueProc[172]:=Unaligned(@FilNTValue172);
  // (constant) left-right-top-bottom clippped
  NTValueProc[174]:=Unaligned(@FilNTValue174);
  // (constant) image has monochrome color channel
  NTValueProc[176]:=Unaligned(@FilNTValue176);
  // (fading) not clippped
  NTValueProc[171]:=Unaligned(@FilNTValue170);
  // (fading) top-bottom clippped
  NTValueProc[173]:=Unaligned(@FilNTValue172);
  // (fading) left-right-top-bottom clippped
  NTValueProc[175]:=Unaligned(@FilNTValue174);
  // (fading) image has monochrome color channel
  NTValueProc[177]:=Unaligned(@FilNTValue176);

  {BlurRGR}
  // (constant) not clippped
  NTValueProc[180]:=Unaligned(@FilNTValue180);
  // (constant) top-bottom clippped
  NTValueProc[182]:=Unaligned(@FilNTValue182);
  // (constant) left-right-top-bottom clippped
  NTValueProc[184]:=Unaligned(@FilNTValue184);
  // (constant) image has monochrome color channel
  NTValueProc[186]:=Unaligned(@FilNTValue186);
  // (fading) not clippped
  NTValueProc[181]:=Unaligned(@FilNTValue180);
  // (fading) top-bottom clippped
  NTValueProc[183]:=Unaligned(@FilNTValue182);
  // (fading) left-right-top-bottom clippped
  NTValueProc[185]:=Unaligned(@FilNTValue184);
  // (fading) image has monochrome color channel
  NTValueProc[187]:=Unaligned(@FilNTValue186);

  {BlurGGB}
  // (constant) not clippped
  NTValueProc[190]:=Unaligned(@FilNTValue190);
  // (constant) top-bottom clippped
  NTValueProc[192]:=Unaligned(@FilNTValue192);
  // (constant) left-right-top-bottom clippped
  NTValueProc[194]:=Unaligned(@FilNTValue194);
  // (constant) image has monochrome color channel
  NTValueProc[196]:=Unaligned(@FilNTValue196);
  // (fading) not clippped
  NTValueProc[191]:=Unaligned(@FilNTValue190);
  // (fading) top-bottom clippped
  NTValueProc[193]:=Unaligned(@FilNTValue192);
  // (fading) left-right-top-bottom clippped
  NTValueProc[195]:=Unaligned(@FilNTValue194);
  // (fading) image has monochrome color channel
  NTValueProc[197]:=Unaligned(@FilNTValue196);

  {BlurRGG}
  // (constant) not clippped
  NTValueProc[200]:=Unaligned(@FilNTValue200);
  // (constant) top-bottom clippped
  NTValueProc[202]:=Unaligned(@FilNTValue202);
  // (constant) left-right-top-bottom clippped
  NTValueProc[204]:=Unaligned(@FilNTValue204);
  // (constant) image has monochrome color channel
  NTValueProc[206]:=Unaligned(@FilNTValue206);
  // (fading) not clippped
  NTValueProc[201]:=Unaligned(@FilNTValue200);
  // (fading) top-bottom clippped
  NTValueProc[203]:=Unaligned(@FilNTValue202);
  // (fading) left-right-top-bottom clippped
  NTValueProc[205]:=Unaligned(@FilNTValue204);
  // (fading) image has monochrome color channel
  NTValueProc[207]:=Unaligned(@FilNTValue206);

  {BlurBGB}
  // (constant) not clippped
  NTValueProc[210]:=Unaligned(@FilNTValue210);
  // (constant) top-bottom clippped
  NTValueProc[212]:=Unaligned(@FilNTValue212);
  // (constant) left-right-top-bottom clippped
  NTValueProc[214]:=Unaligned(@FilNTValue214);
  // (constant) image has monochrome color channel
  NTValueProc[216]:=Unaligned(@FilNTValue216);
  // (fading) not clippped
  NTValueProc[211]:=Unaligned(@FilNTValue210);
  // (fading) top-bottom clippped
  NTValueProc[213]:=Unaligned(@FilNTValue212);
  // (fading) left-right-top-bottom clippped
  NTValueProc[215]:=Unaligned(@FilNTValue214);
  // (fading) image has monochrome color channel
  NTValueProc[217]:=Unaligned(@FilNTValue216);

  {BlurRBB}
  // (constant) not clippped
  NTValueProc[220]:=Unaligned(@FilNTValue220);
  // (constant) top-bottom clippped
  NTValueProc[222]:=Unaligned(@FilNTValue222);
  // (constant) left-right-top-bottom clippped
  NTValueProc[224]:=Unaligned(@FilNTValue224);
  // (constant) image has monochrome color channel
  NTValueProc[226]:=Unaligned(@FilNTValue226);
  // (fading) not clippped
  NTValueProc[221]:=Unaligned(@FilNTValue220);
  // (fading) top-bottom clippped
  NTValueProc[223]:=Unaligned(@FilNTValue222);
  // (fading) left-right-top-bottom clippped
  NTValueProc[225]:=Unaligned(@FilNTValue224);
  // (fading) image has monochrome color channel
  NTValueProc[227]:=Unaligned(@FilNTValue226);

  {BlurRRR}
  // (constant) not clippped
  NTValueProc[230]:=Unaligned(@FilNTValue230);
  // (constant) top-bottom clippped
  NTValueProc[232]:=Unaligned(@FilNTValue232);
  // (constant) left-right-top-bottom clippped
  NTValueProc[234]:=Unaligned(@FilNTValue234);
  // (constant) image has monochrome color channel
  NTValueProc[236]:=Unaligned(@FilNTValue236);
  // (fading) not clippped
  NTValueProc[231]:=Unaligned(@FilNTValue230);
  // (fading) top-bottom clippped
  NTValueProc[233]:=Unaligned(@FilNTValue232);
  // (fading) left-right-top-bottom clippped
  NTValueProc[235]:=Unaligned(@FilNTValue234);
  // (fading) image has monochrome color channel
  NTValueProc[237]:=Unaligned(@FilNTValue236);

  {BlurGGG}
  // (constant) not clippped
  NTValueProc[240]:=Unaligned(@FilNTValue240);
  // (constant) top-bottom clippped
  NTValueProc[242]:=Unaligned(@FilNTValue242);
  // (constant) left-right-top-bottom clippped
  NTValueProc[244]:=Unaligned(@FilNTValue244);
  // (constant) image has monochrome color channel
  NTValueProc[246]:=Unaligned(@FilNTValue246);
  // (fading) not clippped
  NTValueProc[241]:=Unaligned(@FilNTValue240);
  // (fading) top-bottom clippped
  NTValueProc[243]:=Unaligned(@FilNTValue242);
  // (fading) left-right-top-bottom clippped
  NTValueProc[245]:=Unaligned(@FilNTValue244);
  // (fading) image has monochrome color channel
  NTValueProc[247]:=Unaligned(@FilNTValue246);

  {BlurBBB}
  // (constant) not clippped
  NTValueProc[250]:=Unaligned(@FilNTValue250);
  // (constant) top-bottom clippped
  NTValueProc[252]:=Unaligned(@FilNTValue252);
  // (constant) left-right-top-bottom clippped
  NTValueProc[254]:=Unaligned(@FilNTValue254);
  // (constant) image has monochrome color channel
  NTValueProc[256]:=Unaligned(@FilNTValue256);
  // (fading) not clippped
  NTValueProc[251]:=Unaligned(@FilNTValue250);
  // (fading) top-bottom clippped
  NTValueProc[253]:=Unaligned(@FilNTValue252);
  // (fading) left-right-top-bottom clippped
  NTValueProc[255]:=Unaligned(@FilNTValue254);
  // (fading) image has monochrome color channel
  NTValueProc[257]:=Unaligned(@FilNTValue256);

  {Color of Curent Layer}
  // (constant) not clippped
  NTColorProc[000]:=Unaligned(@FilNTColor000);
  // (constant) top-bottom clippped
  NTColorProc[002]:=Unaligned(@FilNTColor002);
  // (constant) left-right-top-bottom clippped
  NTColorProc[004]:=Unaligned(@FilNTColor004);
  // (constant) image has monochrome color channel
  NTColorProc[006]:=Unaligned(@FilNTColor006);
  // (fading) not clippped
  NTColorProc[001]:=Unaligned(@FilNTColor000);
  // (fading) top-bottom clippped
  NTColorProc[003]:=Unaligned(@FilNTColor002);
  // (fading) left-right-top-bottom clippped
  NTColorProc[005]:=Unaligned(@FilNTColor004);
  // (fading) image has monochrome color channel
  NTColorProc[007]:=Unaligned(@FilNTColor006);

  {Color of Curent Layer(Additive)}
  // (constant) not clippped
  NTColorProc[010]:=Unaligned(@FilNTColor010);
  // (constant) top-bottom clippped
  NTColorProc[012]:=Unaligned(@FilNTColor012);
  // (constant) left-right-top-bottom clippped
  NTColorProc[014]:=Unaligned(@FilNTColor014);
  // (constant) image has monochrome color channel
  NTColorProc[016]:=Unaligned(@FilNTColor016);
  // (fading) not clippped
  NTColorProc[011]:=Unaligned(@FilNTColor011);
  // (fading) top-bottom clippped
  NTColorProc[013]:=Unaligned(@FilNTColor013);
  // (fading) left-right-top-bottom clippped
  NTColorProc[015]:=Unaligned(@FilNTColor015);
  // (fading) image has monochrome color channel
  NTColorProc[017]:=Unaligned(@FilNTColor017);

  {Color of Curent Layer(Alphablend)}
  // (constant) not clippped
  NTColorProc[020]:=Unaligned(@FilNTColor020);
  // (constant) top-bottom clippped
  NTColorProc[022]:=Unaligned(@FilNTColor022);
  // (constant) left-right-top-bottom clippped
  NTColorProc[024]:=Unaligned(@FilNTColor024);
  // (constant) image has monochrome color channel
  NTColorProc[026]:=Unaligned(@FilNTColor026);
  // (fading) not clippped
  NTColorProc[021]:=Unaligned(@FilNTColor020);
  // (fading) top-bottom clippped
  NTColorProc[023]:=Unaligned(@FilNTColor022);
  // (fading) left-right-top-bottom clippped
  NTColorProc[025]:=Unaligned(@FilNTColor024);
  // (fading) image has monochrome color channel
  NTColorProc[027]:=Unaligned(@FilNTColor026);



  // PT - partly transparent pixels;

  {Empty}
  PTValueProc[009]:=Unaligned(@FilPTValue009);
  {Empty}
  PTColorProc[009]:=Unaligned(@FilPTColor009);

  {Monochrome}
  // (constant) not clippped
  PTValueProc[000]:=Unaligned(@FilPTValue000);
  // (constant) top-bottom clippped
  PTValueProc[002]:=Unaligned(@FilPTValue002);
  // (constant) left-right-top-bottom clippped
  PTValueProc[004]:=Unaligned(@FilPTValue004);
  // (fading) not clippped
  PTValueProc[001]:=Unaligned(@FilPTValue000);
  // (fading) top-bottom clippped
  PTValueProc[003]:=Unaligned(@FilPTValue002);
  // (fading) left-right-top-bottom clippped
  PTValueProc[005]:=Unaligned(@FilPTValue004);

  {Additive}
  // (constant) not clippped
  PTValueProc[010]:=Unaligned(@FilPTValue010);
  // (constant) top-bottom clippped
  PTValueProc[012]:=Unaligned(@FilPTValue012);
  // (constant) left-right-top-bottom clippped
  PTValueProc[014]:=Unaligned(@FilPTValue014);
  // (fading) not clippped
  PTValueProc[011]:=Unaligned(@FilPTValue011);
  // (fading) top-bottom clippped
  PTValueProc[013]:=Unaligned(@FilPTValue013);
  // (fading) left-right-top-bottom clippped
  PTValueProc[015]:=Unaligned(@FilPTValue015);

  {Alphablend}
  // (constant) not clippped
  PTValueProc[020]:=Unaligned(@FilPTValue020);
  // (constant) top-bottom clippped
  PTValueProc[022]:=Unaligned(@FilPTValue022);
  // (constant) left-right-top-bottom clippped
  PTValueProc[024]:=Unaligned(@FilPTValue024);
  // (fading) not clippped
  PTValueProc[021]:=Unaligned(@FilPTValue020);
  // (fading) top-bottom clippped
  PTValueProc[023]:=Unaligned(@FilPTValue022);
  // (fading) left-right-top-bottom clippped
  PTValueProc[025]:=Unaligned(@FilPTValue024);

  {Inverse}
  // (constant) not clippped
  PTValueProc[030]:=Unaligned(@FilPTValue030);
  // (constant) top-bottom clippped
  PTValueProc[032]:=Unaligned(@FilPTValue032);
  // (constant) left-right-top-bottom clippped
  PTValueProc[034]:=Unaligned(@FilPTValue034);
  // (fading) not clippped
  PTValueProc[031]:=Unaligned(@FilPTValue031);
  // (fading) top-bottom clippped
  PTValueProc[033]:=Unaligned(@FilPTValue033);
  // (fading) left-right-top-bottom clippped
  PTValueProc[035]:=Unaligned(@FilPTValue035);

  {Highlighted}
  // (constant) not clippped
  PTValueProc[040]:=Unaligned(@FilPTValue040);
  // (constant) top-bottom clippped
  PTValueProc[042]:=Unaligned(@FilPTValue042);
  // (constant) left-right-top-bottom clippped
  PTValueProc[044]:=Unaligned(@FilPTValue044);
  // (fading) not clippped
  PTValueProc[041]:=Unaligned(@FilPTValue040);
  // (fading) top-bottom clippped
  PTValueProc[043]:=Unaligned(@FilPTValue042);
  // (fading) left-right-top-bottom clippped
  PTValueProc[045]:=Unaligned(@FilPTValue044);

  {Darkened}
  // (constant) not clippped
  PTValueProc[050]:=Unaligned(@FilPTValue050);
  // (constant) top-bottom clippped
  PTValueProc[052]:=Unaligned(@FilPTValue052);
  // (constant) left-right-top-bottom clippped
  PTValueProc[054]:=Unaligned(@FilPTValue054);
  // (fading) not clippped
  PTValueProc[051]:=Unaligned(@FilPTValue050);
  // (fading) top-bottom clippped
  PTValueProc[053]:=Unaligned(@FilPTValue052);
  // (fading) left-right-top-bottom clippped
  PTValueProc[055]:=Unaligned(@FilPTValue054);

  {GrayscaleR}
  // (constant) not clippped
  PTValueProc[060]:=Unaligned(@FilPTValue060);
  // (constant) top-bottom clippped
  PTValueProc[062]:=Unaligned(@FilPTValue062);
  // (constant) left-right-top-bottom clippped
  PTValueProc[064]:=Unaligned(@FilPTValue064);
  // (fading) not clippped
  PTValueProc[061]:=Unaligned(@FilPTValue061);
  // (fading) top-bottom clippped
  PTValueProc[063]:=Unaligned(@FilPTValue063);
  // (fading) left-right-top-bottom clippped
  PTValueProc[065]:=Unaligned(@FilPTValue065);

  {GrayscaleG}
  // (constant) not clippped
  PTValueProc[070]:=Unaligned(@FilPTValue070);
  // (constant) top-bottom clippped
  PTValueProc[072]:=Unaligned(@FilPTValue072);
  // (constant) left-right-top-bottom clippped
  PTValueProc[074]:=Unaligned(@FilPTValue074);
  // (fading) not clippped
  PTValueProc[071]:=Unaligned(@FilPTValue071);
  // (fading) top-bottom clippped
  PTValueProc[073]:=Unaligned(@FilPTValue073);
  // (fading) left-right-top-bottom clippped
  PTValueProc[075]:=Unaligned(@FilPTValue075);

  {GrayscaleB}
  // (constant) not clippped
  PTValueProc[080]:=Unaligned(@FilPTValue080);
  // (constant) top-bottom clippped
  PTValueProc[082]:=Unaligned(@FilPTValue082);
  // (constant) left-right-top-bottom clippped
  PTValueProc[084]:=Unaligned(@FilPTValue084);
  // (fading) not clippped
  PTValueProc[081]:=Unaligned(@FilPTValue081);
  // (fading) top-bottom clippped
  PTValueProc[083]:=Unaligned(@FilPTValue083);
  // (fading) left-right-top-bottom clippped
  PTValueProc[085]:=Unaligned(@FilPTValue085);

  {Monochrome Noise}
  // (constant) not clippped
  PTValueProc[090]:=Unaligned(@FilPTValue090);
  // (constant) top-bottom clippped
  PTValueProc[092]:=Unaligned(@FilPTValue092);
  // (constant) left-right-top-bottom clippped
  PTValueProc[094]:=Unaligned(@FilPTValue094);
  // (fading) not clippped
  PTValueProc[091]:=Unaligned(@FilPTValue091);
  // (fading) top-bottom clippped
  PTValueProc[093]:=Unaligned(@FilPTValue093);
  // (fading) left-right-top-bottom clippped
  PTValueProc[095]:=Unaligned(@FilPTValue095);

  {ColorizeRM}
  // (constant) not clippped
  PTValueProc[100]:=Unaligned(@FilPTValue100);
  // (constant) top-bottom clippped
  PTValueProc[102]:=Unaligned(@FilPTValue102);
  // (constant) left-right-top-bottom clippped
  PTValueProc[104]:=Unaligned(@FilPTValue104);
  // (fading) not clippped
  PTValueProc[101]:=Unaligned(@FilPTValue100);
  // (fading) top-bottom clippped
  PTValueProc[103]:=Unaligned(@FilPTValue102);
  // (fading) left-right-top-bottom clippped
  PTValueProc[105]:=Unaligned(@FilPTValue104);

  {ColorizeRP}
  // (constant) not clippped
  PTValueProc[110]:=Unaligned(@FilPTValue110);
  // (constant) top-bottom clippped
  PTValueProc[112]:=Unaligned(@FilPTValue112);
  // (constant) left-right-top-bottom clippped
  PTValueProc[114]:=Unaligned(@FilPTValue114);
  // (fading) not clippped
  PTValueProc[111]:=Unaligned(@FilPTValue110);
  // (fading) top-bottom clippped
  PTValueProc[113]:=Unaligned(@FilPTValue112);
  // (fading) left-right-top-bottom clippped
  PTValueProc[115]:=Unaligned(@FilPTValue114);

  {ColorizeGM}
  // (constant) not clippped
  PTValueProc[120]:=Unaligned(@FilPTValue120);
  // (constant) top-bottom clippped
  PTValueProc[122]:=Unaligned(@FilPTValue122);
  // (constant) left-right-top-bottom clippped
  PTValueProc[124]:=Unaligned(@FilPTValue124);
  // (fading) not clippped
  PTValueProc[121]:=Unaligned(@FilPTValue120);
  // (fading) top-bottom clippped
  PTValueProc[123]:=Unaligned(@FilPTValue122);
  // (fading) left-right-top-bottom clippped
  PTValueProc[125]:=Unaligned(@FilPTValue124);

  {ColorizeGP}
  // (constant) not clippped
  PTValueProc[130]:=Unaligned(@FilPTValue130);
  // (constant) top-bottom clippped
  PTValueProc[132]:=Unaligned(@FilPTValue132);
  // (constant) left-right-top-bottom clippped
  PTValueProc[134]:=Unaligned(@FilPTValue134);
  // (fading) not clippped
  PTValueProc[131]:=Unaligned(@FilPTValue130);
  // (fading) top-bottom clippped
  PTValueProc[133]:=Unaligned(@FilPTValue132);
  // (fading) left-right-top-bottom clippped
  PTValueProc[135]:=Unaligned(@FilPTValue134);

  {ColorizeBM}
  // (constant) not clippped
  PTValueProc[140]:=Unaligned(@FilPTValue140);
  // (constant) top-bottom clippped
  PTValueProc[142]:=Unaligned(@FilPTValue142);
  // (constant) left-right-top-bottom clippped
  PTValueProc[144]:=Unaligned(@FilPTValue144);
  // (fading) not clippped
  PTValueProc[141]:=Unaligned(@FilPTValue140);
  // (fading) top-bottom clippped
  PTValueProc[143]:=Unaligned(@FilPTValue142);
  // (fading) left-right-top-bottom clippped
  PTValueProc[145]:=Unaligned(@FilPTValue144);

  {ColorizeBP}
  // (constant) not clippped
  PTValueProc[150]:=Unaligned(@FilPTValue150);
  // (constant) top-bottom clippped
  PTValueProc[152]:=Unaligned(@FilPTValue152);
  // (constant) left-right-top-bottom clippped
  PTValueProc[154]:=Unaligned(@FilPTValue154);
  // (fading) not clippped
  PTValueProc[151]:=Unaligned(@FilPTValue150);
  // (fading) top-bottom clippped
  PTValueProc[153]:=Unaligned(@FilPTValue152);
  // (fading) left-right-top-bottom clippped
  PTValueProc[155]:=Unaligned(@FilPTValue154);

  {BlurRGB}
  // (constant) not clippped
  PTValueProc[160]:=Unaligned(@FilPTValue160);
  // (constant) top-bottom clippped
  PTValueProc[162]:=Unaligned(@FilPTValue162);
  // (constant) left-right-top-bottom clippped
  PTValueProc[164]:=Unaligned(@FilPTValue164);
  // (fading) not clippped
  PTValueProc[161]:=Unaligned(@FilPTValue160);
  // (fading) top-bottom clippped
  PTValueProc[163]:=Unaligned(@FilPTValue162);
  // (fading) left-right-top-bottom clippped
  PTValueProc[165]:=Unaligned(@FilPTValue164);

  {BlurRRB}
  // (constant) not clippped
  PTValueProc[170]:=Unaligned(@FilPTValue170);
  // (constant) top-bottom clippped
  PTValueProc[172]:=Unaligned(@FilPTValue172);
  // (constant) left-right-top-bottom clippped
  PTValueProc[174]:=Unaligned(@FilPTValue174);
  // (fading) not clippped
  PTValueProc[171]:=Unaligned(@FilPTValue170);
  // (fading) top-bottom clippped
  PTValueProc[173]:=Unaligned(@FilPTValue172);
  // (fading) left-right-top-bottom clippped
  PTValueProc[175]:=Unaligned(@FilPTValue174);

  {BlurRGR}
  // (constant) not clippped
  PTValueProc[180]:=Unaligned(@FilPTValue180);
  // (constant) top-bottom clippped
  PTValueProc[182]:=Unaligned(@FilPTValue182);
  // (constant) left-right-top-bottom clippped
  PTValueProc[184]:=Unaligned(@FilPTValue184);
  // (fading) not clippped
  PTValueProc[181]:=Unaligned(@FilPTValue180);
  // (fading) top-bottom clippped
  PTValueProc[183]:=Unaligned(@FilPTValue182);
  // (fading) left-right-top-bottom clippped
  PTValueProc[185]:=Unaligned(@FilPTValue184);

  {BlurGGB}
  // (constant) not clippped
  PTValueProc[190]:=Unaligned(@FilPTValue190);
  // (constant) top-bottom clippped
  PTValueProc[192]:=Unaligned(@FilPTValue192);
  // (constant) left-right-top-bottom clippped
  PTValueProc[194]:=Unaligned(@FilPTValue194);
  // (fading) not clippped
  PTValueProc[191]:=Unaligned(@FilPTValue190);
  // (fading) top-bottom clippped
  PTValueProc[193]:=Unaligned(@FilPTValue192);
  // (fading) left-right-top-bottom clippped
  PTValueProc[195]:=Unaligned(@FilPTValue194);

  {BlurRGG}
  // (constant) not clippped
  PTValueProc[200]:=Unaligned(@FilPTValue200);
  // (constant) top-bottom clippped
  PTValueProc[202]:=Unaligned(@FilPTValue202);
  // (constant) left-right-top-bottom clippped
  PTValueProc[204]:=Unaligned(@FilPTValue204);
  // (fading) not clippped
  PTValueProc[201]:=Unaligned(@FilPTValue200);
  // (fading) top-bottom clippped
  PTValueProc[203]:=Unaligned(@FilPTValue202);
  // (fading) left-right-top-bottom clippped
  PTValueProc[205]:=Unaligned(@FilPTValue204);

  {BlurBGB}
  // (constant) not clippped
  PTValueProc[210]:=Unaligned(@FilPTValue210);
  // (constant) top-bottom clippped
  PTValueProc[212]:=Unaligned(@FilPTValue212);
  // (constant) left-right-top-bottom clippped
  PTValueProc[214]:=Unaligned(@FilPTValue214);
  // (fading) not clippped
  PTValueProc[211]:=Unaligned(@FilPTValue210);
  // (fading) top-bottom clippped
  PTValueProc[213]:=Unaligned(@FilPTValue212);
  // (fading) left-right-top-bottom clippped
  PTValueProc[215]:=Unaligned(@FilPTValue214);

  {BlurRBB}
  // (constant) not clippped
  PTValueProc[220]:=Unaligned(@FilPTValue220);
  // (constant) top-bottom clippped
  PTValueProc[222]:=Unaligned(@FilPTValue222);
  // (constant) left-right-top-bottom clippped
  PTValueProc[224]:=Unaligned(@FilPTValue224);
  // (fading) not clippped
  PTValueProc[221]:=Unaligned(@FilPTValue220);
  // (fading) top-bottom clippped
  PTValueProc[223]:=Unaligned(@FilPTValue222);
  // (fading) left-right-top-bottom clippped
  PTValueProc[225]:=Unaligned(@FilPTValue224);

  {BlurRRR}
  // (constant) not clippped
  PTValueProc[230]:=Unaligned(@FilPTValue230);
  // (constant) top-bottom clippped
  PTValueProc[232]:=Unaligned(@FilPTValue232);
  // (constant) left-right-top-bottom clippped
  PTValueProc[234]:=Unaligned(@FilPTValue234);
  // (fading) not clippped
  PTValueProc[231]:=Unaligned(@FilPTValue230);
  // (fading) top-bottom clippped
  PTValueProc[233]:=Unaligned(@FilPTValue232);
  // (fading) left-right-top-bottom clippped
  PTValueProc[235]:=Unaligned(@FilPTValue234);

  {BlurGGG}
  // (constant) not clippped
  PTValueProc[240]:=Unaligned(@FilPTValue240);
  // (constant) top-bottom clippped
  PTValueProc[242]:=Unaligned(@FilPTValue242);
  // (constant) left-right-top-bottom clippped
  PTValueProc[244]:=Unaligned(@FilPTValue244);
  // (fading) not clippped
  PTValueProc[241]:=Unaligned(@FilPTValue240);
  // (fading) top-bottom clippped
  PTValueProc[243]:=Unaligned(@FilPTValue242);
  // (fading) left-right-top-bottom clippped
  PTValueProc[245]:=Unaligned(@FilPTValue244);

  {BlurBBB}
  // (constant) not clippped
  PTValueProc[250]:=Unaligned(@FilPTValue250);
  // (constant) top-bottom clippped
  PTValueProc[252]:=Unaligned(@FilPTValue252);
  // (constant) left-right-top-bottom clippped
  PTValueProc[254]:=Unaligned(@FilPTValue254);
  // (fading) not clippped
  PTValueProc[251]:=Unaligned(@FilPTValue250);
  // (fading) top-bottom clippped
  PTValueProc[253]:=Unaligned(@FilPTValue252);
  // (fading) left-right-top-bottom clippped
  PTValueProc[255]:=Unaligned(@FilPTValue254);

  {Color of Curent Layer}
  // (constant) not clippped
  PTColorProc[000]:=Unaligned(@FilPTColor000);
  // (constant) top-bottom clippped
  PTColorProc[002]:=Unaligned(@FilPTColor002);
  // (constant) left-right-top-bottom clippped
  PTColorProc[004]:=Unaligned(@FilPTColor004);
  // (constant) image has transparent alpha channel
  PTColorProc[006]:=Unaligned(@FilPTColor006);
  // (fading) not clippped
  PTColorProc[001]:=Unaligned(@FilPTColor000);
  // (fading) top-bottom clippped
  PTColorProc[003]:=Unaligned(@FilPTColor002);
  // (fading) left-right-top-bottom clippped
  PTColorProc[005]:=Unaligned(@FilPTColor004);
  // (fading) image has transparent alpha channel
  PTColorProc[007]:=Unaligned(@FilPTColor006);

  {Color of Curent Layer(Additive)}
  // (constant) not clippped
  PTColorProc[010]:=Unaligned(@FilPTColor010);
  // (constant) top-bottom clippped
  PTColorProc[012]:=Unaligned(@FilPTColor012);
  // (constant) left-right-top-bottom clippped
  PTColorProc[014]:=Unaligned(@FilPTColor014);
  // (constant) image has monochrome color channel
  PTColorProc[016]:=Unaligned(@FilPTColor016);
  // (fading) not clippped
  PTColorProc[011]:=Unaligned(@FilPTColor011);
  // (fading) top-bottom clippped
  PTColorProc[013]:=Unaligned(@FilPTColor013);
  // (fading) left-right-top-bottom clippped
  PTColorProc[015]:=Unaligned(@FilPTColor015);
  // (fading) image has monochrome color channel
  PTColorProc[017]:=Unaligned(@FilPTColor016);

  {Color of Curent Layer(Alphablend)}
  // (constant) not clippped
  PTColorProc[020]:=Unaligned(@FilPTColor020);
  // (constant) top-bottom clippped
  PTColorProc[022]:=Unaligned(@FilPTColor022);
  // (constant) left-right-top-bottom clippped
  PTColorProc[024]:=Unaligned(@FilPTColor024);
  // (constant) image has transparent alpha channel
  PTColorProc[026]:=Unaligned(@FilPTColor006);
  // (fading) not clippped
  PTColorProc[021]:=Unaligned(@FilPTColor020);
  // (fading) top-bottom clippped
  PTColorProc[023]:=Unaligned(@FilPTColor022);
  // (fading) left-right-top-bottom clippped
  PTColorProc[025]:=Unaligned(@FilPTColor024);
  // (fading) image has transparent alpha channel
  PTColorProc[027]:=Unaligned(@FilPTColor006);

end; {$endregion}

// Tile Map Drawing:
// Fill Tile Map With Random Color:
procedure TFastImage.FilTileMap0; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst_0,rct_dst_1,rct_dst_2: TPtRect;
  bmp_bckgd_ptr2               : PInteger;
  pix_color_ptr                : PInteger;
  first_row_pix_ptr            : PInteger;
  nt_pix_intr_cnt_arr_ptr      : PInteger;
  nt_pix_intr_sht_arr_ptr      : PInteger;
  nt_pix_intr_sht_arr_ptr_mul  : integer;
  x,y,bmp_bckgd_width_mul_y    : integer;
begin
  rct_dst_0                    :=PtBounds(bmp_ftimg_left,bmp_ftimg_top+nt_pix_arr_row_mrg_top*tilemap_sprite_w_h.y,tilemap_sprite_w_h.x,tilemap_sprite_w_h.y);
  rct_dst_1                    :=rct_dst_0;
  bmp_bckgd_width_mul_y        :=bmp_bkgnd_width*tilemap_sprite_w_h.y;
  bmp_bckgd_ptr2               :=Unaligned(@bmp_bkgnd_ptr      [000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  first_row_pix_ptr            :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top*tilemap_sprite_w_h.y+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr      :=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr      :=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      rct_dst_1    :=rct_dst_0;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
          nt_pix_intr_sht_arr_ptr_mul:=nt_pix_intr_sht_arr_ptr^*tilemap_sprite_w_h.x;
          rct_dst_1.left             :=rct_dst_0.left +nt_pix_intr_sht_arr_ptr_mul;
          rct_dst_1.right            :=rct_dst_0.right+nt_pix_intr_sht_arr_ptr_mul;
          rct_dst_2                  :=ClippedRct(rct_clp_ptr^,rct_dst_1);
          PPFloodFill(bmp_bckgd_ptr2,rct_dst_2,bmp_bkgnd_width,Random($FFFFFF));
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width_mul_y);
      Inc(rct_dst_0.top    ,tilemap_sprite_w_h .y);
      Inc(rct_dst_0.bottom ,tilemap_sprite_w_h .y);
    end;
end; {$endregion}
// Fill Tile Map With Specified Sprite:
procedure TFastImage.FilTileMap1; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst_0,rct_dst_1,rct_dst_2: TPtRect;
  bmp_bckgd_ptr2               : PInteger;
  pix_color_ptr                : PInteger;
  first_row_pix_ptr            : PInteger;
  nt_pix_intr_cnt_arr_ptr      : PInteger;
  nt_pix_intr_sht_arr_ptr      : PInteger;
  nt_pix_intr_sht_arr_ptr_mul  : integer;
  i,j,bmp_bckgd_width_mul_y    : integer;
begin
  with tilemap_sprite_w_h do
    begin
      rct_dst_0                    :=PtBounds(bmp_ftimg_left,bmp_ftimg_top+nt_pix_arr_row_mrg_top*y,x,y);
      rct_dst_1                    :=rct_dst_0;
      bmp_bckgd_width_mul_y        :=bmp_bkgnd_width*y;
      bmp_bckgd_ptr2               :=Unaligned(@bmp_bkgnd_ptr      [00000000000000000000000000000000000000000000000000000000000000000000000]);
      first_row_pix_ptr            :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top*y+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr      :=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+00000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr      :=Unaligned(@nt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000000000000000000]);
      for j:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          rct_dst_1    :=rct_dst_0;
          for i:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              nt_pix_intr_sht_arr_ptr_mul:=nt_pix_intr_sht_arr_ptr^*x;
              rct_dst_1.left             :=rct_dst_0.left +nt_pix_intr_sht_arr_ptr_mul;
              rct_dst_1.right            :=rct_dst_0.right+nt_pix_intr_sht_arr_ptr_mul;
              with tilemap_sprite_ptr^ do
                begin
                  SetRctPos(rct_dst_1.left,rct_dst_1.top);
                  SdrProc[3];
                end;
              Inc(nt_pix_intr_sht_arr_ptr);
            end;
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bckgd_width_mul_y);
          Inc(rct_dst_0.top    ,                    y);
          Inc(rct_dst_0.bottom ,                    y);
        end;
    end;
end; {$endregion}
// Fill Tile Map With Rectangles:
procedure TFastImage.FilTileMap2; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst_0,rct_dst_1,rct_dst_2: TPtRect;
  bmp_bckgd_ptr2               : PInteger;
  pix_color_ptr                : PInteger;
  first_row_pix_ptr            : PInteger;
  nt_pix_intr_cnt_arr_ptr      : PInteger;
  nt_pix_intr_sht_arr_ptr      : PInteger;
  nt_pix_intr_sht_arr_ptr_mul  : integer;
  x,y,bmp_bckgd_width_mul_y    : integer;
begin
  rct_dst_0                    :=PtBounds(bmp_ftimg_left,bmp_ftimg_top+nt_pix_arr_row_mrg_top*tilemap_sprite_w_h.y,tilemap_sprite_w_h.x,tilemap_sprite_w_h.y);
  rct_dst_1                    :=rct_dst_0;
  bmp_bckgd_width_mul_y        :=bmp_bkgnd_width*tilemap_sprite_w_h.y;
  bmp_bckgd_ptr2               :=Unaligned(@bmp_bkgnd_ptr      [000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  first_row_pix_ptr            :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top*tilemap_sprite_w_h.y+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
  nt_pix_intr_cnt_arr_ptr      :=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr      :=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      pix_color_ptr:=first_row_pix_ptr;
      rct_dst_1    :=rct_dst_0;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
          nt_pix_intr_sht_arr_ptr_mul:=nt_pix_intr_sht_arr_ptr^*tilemap_sprite_w_h.x;
          rct_dst_1.left             :=rct_dst_0.left +nt_pix_intr_sht_arr_ptr_mul;
          rct_dst_1.right            :=rct_dst_0.right+nt_pix_intr_sht_arr_ptr_mul;
          rct_dst_2                  :=ClippedRct(rct_clp_ptr^,rct_dst_1);
          Rectangle
          (
            rct_dst_2.left+sln_prop_var.pts_rct_width__half-sln_prop_var.pts_rct_width__odd,
            rct_dst_2.top +sln_prop_var.pts_rct_height_half-sln_prop_var.pts_rct_height_odd,
            bmp_bckgd_ptr2,
            bmp_bkgnd_width,
            bmp_bkgnd_height,
            rct_dst_2,
            sln_prop_var);
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr,bmp_bckgd_width_mul_y);
      Inc(rct_dst_0.top    ,tilemap_sprite_w_h .y);
      Inc(rct_dst_0.bottom ,tilemap_sprite_w_h .y);
    end;
end; {$endregion}

// Full Image Drawing:
procedure TFastimage.ShaderInfo;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  pix_drw_type             :=0; //must be in range of [0..002]

  fx_cnt                   :=0; //must be in range of [0..255]

  fx_arr[0].rep_cnt        :=1; //must be in range of [0..255]

  fx_arr[0].nt_pix_srf_type:=1; //must be in range of [0..001]
  fx_arr[0].nt_pix_cfx_type:=0; //must be in range of [0..255]
  fx_arr[0].nt_pix_cng_type:=1; //must be in range of [0..001]

  fx_arr[0].pt_pix_srf_type:=1; //must be in range of [0..001]
  fx_arr[0].pt_pix_cfx_type:=0; //must be in range of [0..255]
  fx_arr[0].pt_pix_cng_type:=1; //must be in range of [0..001]

  fx_arr[1].rep_cnt        :=1; //must be in range of [0..255]

  fx_arr[1].nt_pix_srf_type:=1; //must be in range of [0..001]
  fx_arr[1].nt_pix_cfx_type:=4; //must be in range of [0..255]
  fx_arr[1].nt_pix_cng_type:=1; //must be in range of [0..001]

  fx_arr[1].pt_pix_srf_type:=1; //must be in range of [0..001]
  fx_arr[1].pt_pix_cfx_type:=4; //must be in range of [0..255]
  fx_arr[1].pt_pix_cng_type:=1; //must be in range of [0..001]

  nt_pix_srf_type          :=1; //must be in range of [0..002]
  nt_pix_cfx_type          :=0; //must be in range of [0..002]
  nt_pix_cng_type          :=0; //must be in range of [0..001]

  pt_pix_srf_type          :=1; //must be in range of [0..002]
  pt_pix_cfx_type          :=0; //must be in range of [0..002]
  pt_pix_cng_type          :=0; //must be in range of [0..001]

end; {$endregion}
procedure TFastimage.SetSdrType;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  sdr_type_ind:=3*img_kind+pix_drw_type;
end; {$endregion}
procedure TFastimage.SdrTypeInit; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType[000]:=Unaligned(@SdrType000);
  SdrType[001]:=Unaligned(@SdrType001);
  SdrType[002]:=Unaligned(@SdrType002);
  SdrType[003]:=Unaligned(@SdrType003);
  SdrType[004]:=Unaligned(@SdrType004);
  SdrType[005]:=Unaligned(@SdrType005);
  SdrType[006]:=Unaligned(@SdrType006);
  SdrType[007]:=Unaligned(@SdrType007);
  SdrType[008]:=Unaligned(@SdrType008);
  SdrType[009]:=Unaligned(@SdrType009);
  SdrType[010]:=Unaligned(@SdrType010);
  SdrType[011]:=Unaligned(@SdrType011);
  SdrType[012]:=Unaligned(@SdrType012);
  SdrType[013]:=Unaligned(@SdrType013);
  SdrType[014]:=Unaligned(@SdrType014);
  SdrType[015]:=Unaligned(@SdrType015);
  SdrType[016]:=Unaligned(@SdrType016);
  SdrType[017]:=Unaligned(@SdrType017);
  SdrType[018]:=Unaligned(@SdrType018);
  SdrType[019]:=Unaligned(@SdrType019);
  SdrType[020]:=Unaligned(@SdrType020);
  SdrType[021]:=Unaligned(@SdrType021);
  SdrType[022]:=Unaligned(@SdrType022);
  SdrType[023]:=Unaligned(@SdrType023);
  SdrType[024]:=Unaligned(@SdrType024);
  SdrType[025]:=Unaligned(@SdrType025);
  SdrType[026]:=Unaligned(@SdrType026);
  SdrType[027]:=Unaligned(@SdrType027);
  SdrType[028]:=Unaligned(@SdrType028);
  SdrType[029]:=Unaligned(@SdrType029);
  SdrType[030]:=Unaligned(@SdrType030);
  SdrType[031]:=Unaligned(@SdrType030);
  SdrType[032]:=Unaligned(@SdrType030);
  SdrType[033]:=Unaligned(@SdrType030);
  SdrType[034]:=Unaligned(@SdrType030);
  SdrType[035]:=Unaligned(@SdrType030);
  SdrType[036]:=Unaligned(@SdrType009);
  SdrType[037]:=Unaligned(@SdrType010);
  SdrType[038]:=Unaligned(@SdrType011);
end; {$endregion}
procedure TFastimage.SdrType000;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (nt_pix_srf_type<>0) then
    begin
      nt_begin_proc_ind:=((nt_pix_srf_type));
      nt_color_proc_ind:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_clp_type<<1+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
    end
  else
    begin
      nt_begin_proc_ind:=0;
      nt_color_proc_ind:=9;
    end;
  if (pt_pix_srf_type<>0) then
    begin
      pt_begin_proc_ind:=((pt_pix_srf_type));
      pt_color_proc_ind:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_clp_type<<1+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
    end
  else
    begin
      pt_begin_proc_ind:=0;
      pt_color_proc_ind:=9;
    end;
  fx_cnt:=0;
end; {$endregion}
procedure TFastimage.SdrType001;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
    end;
end; {$endregion}
procedure TFastimage.SdrType002;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  if (nt_pix_srf_type<>0) then
    begin
      nt_begin_proc_ind:=((nt_pix_srf_type));
      nt_color_proc_ind:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_clp_type<<1+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
    end
  else
    begin
      nt_begin_proc_ind:=0;
      nt_color_proc_ind:=9;
    end;
  if (pt_pix_srf_type<>0) then
    begin
      pt_begin_proc_ind:=((pt_pix_srf_type));
      pt_color_proc_ind:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_clp_type<<1+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
    end
  else
    begin
      pt_begin_proc_ind:=0;
      pt_color_proc_ind:=9;
    end;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
    end;
end; {$endregion}
procedure TFastimage.SdrType003;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  if (nt_pix_srf_type<>0) then
    begin
      nt_begin_proc_ind:=((nt_pix_srf_type));
      nt_color_proc_ind:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_clp_type<<1+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
    end
  else
    begin
      nt_begin_proc_ind:=0;
      nt_color_proc_ind:=9;
    end;
  fx_cnt:=0;
end; {$endregion}
procedure TFastimage.SdrType004;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=9;
    end;
end; {$endregion}
procedure TFastimage.SdrType005;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  if (nt_pix_srf_type<>0) then
    begin
      nt_begin_proc_ind:=((nt_pix_srf_type));
      nt_color_proc_ind:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_clp_type<<1+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
    end
  else
    begin
      nt_begin_proc_ind:=0;
      nt_color_proc_ind:=9;
    end;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=9;
    end;
end; {$endregion}
procedure TFastimage.SdrType006;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  if (pt_pix_srf_type<>0) then
    begin
      pt_begin_proc_ind:=((pt_pix_srf_type));
      pt_color_proc_ind:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_clp_type<<1+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
    end
  else
    begin
      pt_begin_proc_ind:=0;
      pt_color_proc_ind:=9;
    end;
  fx_cnt:=0;
end; {$endregion}
procedure TFastimage.SdrType007;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=9;
      fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
    end;
end; {$endregion}
procedure TFastimage.SdrType008;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  if (pt_pix_srf_type<>0) then
    begin
      pt_begin_proc_ind:=((pt_pix_srf_type));
      pt_color_proc_ind:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_clp_type<<1+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
    end
  else
    begin
      pt_begin_proc_ind:=0;
      pt_color_proc_ind:=9;
    end;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=9;
      fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
    end;
end; {$endregion}
procedure TFastimage.SdrType009;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  nt_pix_clp_type  :=3;
  nt_begin_proc_ind:=0;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  if (nt_pix_srf_type<>0) then
    nt_color_proc_ind:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_clp_type<<1+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9
  else
    nt_color_proc_ind:=9;
  fx_cnt:=0;
end; {$endregion}
procedure TFastimage.SdrType010;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_pix_clp_type  :=3;
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=9;
    end;
end; {$endregion}
procedure TFastimage.SdrType011;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_pix_clp_type  :=3;
  nt_begin_proc_ind:=0;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  if (nt_pix_srf_type<>0) then
    nt_color_proc_ind:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_clp_type<<1+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9
  else
    nt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=9;
    end;
end; {$endregion}
procedure TFastimage.SdrType012;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pt_pix_clp_type  :=3;
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  if (pt_pix_srf_type<>0) then
    pt_color_proc_ind:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_clp_type<<1+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9
  else
    pt_color_proc_ind:=9;
  fx_cnt:=0;
end; {$endregion}
procedure TFastimage.SdrType013;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  pt_pix_clp_type  :=3;
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=9;
    end;
end; {$endregion}
procedure TFastimage.SdrType014;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  pt_pix_clp_type  :=3;
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  if (pt_pix_srf_type<>0) then
    pt_color_proc_ind:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_clp_type<<1+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9
  else
    pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=9;
    end;
end; {$endregion}
procedure TFastimage.SdrType015;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  fx_cnt           :=0;
end; {$endregion}
procedure TFastimage.SdrType016;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
    end;
end; {$endregion}
procedure TFastimage.SdrType017;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
    end;
end; {$endregion}
procedure TFastimage.SdrType018;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  fx_cnt           :=0;
end; {$endregion}
procedure TFastimage.SdrType019;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=9;
    end;
end; {$endregion}
procedure TFastimage.SdrType020;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=9;
    end;
end; {$endregion}
procedure TFastimage.SdrType021;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  fx_cnt           :=0;
end; {$endregion}
procedure TFastimage.SdrType022;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=9;
      fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
    end;
end; {$endregion}
procedure TFastimage.SdrType023;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=9;
      fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
    end;
end; {$endregion}
procedure TFastimage.SdrType024;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  nt_pix_clp_type  :=3;
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  fx_cnt           :=0;
end; {$endregion}
procedure TFastimage.SdrType025;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_pix_clp_type  :=3;
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=9;
    end;
end; {$endregion}
procedure TFastimage.SdrType026;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_pix_clp_type  :=3;
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=9;
    end;
end; {$endregion}
procedure TFastimage.SdrType027;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  nt_pix_clp_type  :=3;
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  fx_cnt           :=0;
end; {$endregion}
procedure TFastimage.SdrType028;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_pix_clp_type  :=3;
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=9;
    end;
end; {$endregion}
procedure TFastimage.SdrType029;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  nt_pix_clp_type  :=3;
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  for i:=0 to fx_cnt-1 do
    begin
      fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
      fx_arr[i].pt_value_proc_ind:=9;
    end;
end; {$endregion}
procedure TFastimage.SdrType030;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  nt_begin_proc_ind:=0;
  nt_color_proc_ind:=9;
  pt_begin_proc_ind:=0;
  pt_color_proc_ind:=9;
  fx_cnt           :=0;
end; {$endregion}
procedure TFastimage.SdrType031;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {empty}
end; {$endregion}
procedure TFastimage.ShaderType;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin

  {Image Description} {$region -fold}
  {
    ----------------Image Has Alpha Channel And Color Channel---------------
    0:
    image has:  not monochrome alpha channel,
                not monochrome color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels>0;

    1:
    image has:  not monochrome alpha channel,
                not monochrome color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;

    2:
    image has:  not monochrome alpha channel,
                not monochrome color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels>0;

    3:
    image has:      monochrome alpha channel(white, not transparent),
                not monochrome color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;

    4:
    image has:      monochrome alpha channel(transparent),
                not monochrome color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels>0;


    ----------------------Image Has Only Alpha Channel----------------------
    5:
    image has:  not monochrome alpha channel,
                            no color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels>0;

    6:
    image has:  not monochrome alpha channel,
                            no color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;

    7:
    image has:  not monochrome alpha channel,
                            no color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels>0;

    8:
    image has:      monochrome alpha channel(white, not transparent),
                            no color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;

    9:
    image has:      monochrome alpha channel(transparent),
                            no color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels>0;


    --------------Image Has No Alpha Channel And Color Channel--------------
    10:
    image has:      no alpha channel(black, invisible),
                    no color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels=0;

    --------------------------Image is Value Array--------------------------
    11:
    count of    not transparent pixels>0;
    count of partly transparent pixels>0;

    --------------------------Image is Mask--------------------------
    12:
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;
  } {$endregion}

  {case img_kind of
    00   : {$region -fold}
      case pix_drw_type of
        0:
          begin
            if (nt_pix_srf_type<>0) then
              begin
                nt_begin_proc_ind:=((nt_pix_srf_type));
                nt_color_proc_ind:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_clp_type<<1+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
              end
            else
              begin
                nt_begin_proc_ind:=0;
                nt_color_proc_ind:=9;
              end;
            if (pt_pix_srf_type<>0) then
              begin
                pt_begin_proc_ind:=((pt_pix_srf_type));
                pt_color_proc_ind:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_clp_type<<1+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
              end
            else
              begin
                pt_begin_proc_ind:=0;
                pt_color_proc_ind:=9;
              end;
            fx_cnt:=0;
            Exit;
          end;
        1:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
              end;
            Exit;
          end;
        2:
          begin
            if (nt_pix_srf_type<>0) then
              begin
                nt_begin_proc_ind:=((nt_pix_srf_type));
                nt_color_proc_ind:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_clp_type<<1+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
              end
            else
              begin
                nt_begin_proc_ind:=0;
                nt_color_proc_ind:=9;
              end;
            if (pt_pix_srf_type<>0) then
              begin
                pt_begin_proc_ind:=((pt_pix_srf_type));
                pt_color_proc_ind:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_clp_type<<1+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
              end
            else
              begin
                pt_begin_proc_ind:=0;
                pt_color_proc_ind:=9;
              end;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
              end;
            Exit;
          end;
      end; {$endregion}
    01   : {$region -fold}
      case pix_drw_type of
        0:
          begin
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            if (nt_pix_srf_type<>0) then
              begin
                nt_begin_proc_ind:=((nt_pix_srf_type));
                nt_color_proc_ind:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_clp_type<<1+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
              end
            else
              begin
                nt_begin_proc_ind:=0;
                nt_color_proc_ind:=9;
              end;
            fx_cnt:=0;
            Exit;
          end;
        1:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=9;
              end;
            Exit;
          end;
        2:
          begin
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            if (nt_pix_srf_type<>0) then
              begin
                nt_begin_proc_ind:=((nt_pix_srf_type));
                nt_color_proc_ind:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_clp_type<<1+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
              end
            else
              begin
                nt_begin_proc_ind:=0;
                nt_color_proc_ind:=9;
              end;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=9;
              end;
            Exit;
          end;
      end; {$endregion}
    02   : {$region -fold}
      case pix_drw_type of
        0:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            if (pt_pix_srf_type<>0) then
              begin
                pt_begin_proc_ind:=((pt_pix_srf_type));
                pt_color_proc_ind:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_clp_type<<1+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
              end
            else
              begin
                pt_begin_proc_ind:=0;
                pt_color_proc_ind:=9;
              end;
            fx_cnt:=0;
            Exit;
          end;
        1:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=9;
                fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
              end;
            Exit;
          end;
        2:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            if (pt_pix_srf_type<>0) then
              begin
                pt_begin_proc_ind:=((pt_pix_srf_type));
                pt_color_proc_ind:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_clp_type<<1+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
              end
            else
              begin
                pt_begin_proc_ind:=0;
                pt_color_proc_ind:=9;
              end;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=9;
                fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
              end;
            Exit;
          end;
      end; {$endregion}
    03,12: {$region -fold}
      case pix_drw_type of
        0:
          begin
            nt_pix_clp_type  :=3;
            nt_begin_proc_ind:=0;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            if (nt_pix_srf_type<>0) then
              nt_color_proc_ind:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_clp_type<<1+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9
            else
              nt_color_proc_ind:=9;
            fx_cnt:=0;
            Exit;
          end;
        1:
          begin
            nt_pix_clp_type  :=3;
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=9;
              end;
            Exit;
          end;
        2:
          begin
            nt_pix_clp_type  :=3;
            nt_begin_proc_ind:=0;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            if (nt_pix_srf_type<>0) then
              nt_color_proc_ind:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_clp_type<<1+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9
            else
              nt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=9;
              end;
            Exit;
          end;
      end; {$endregion}
    04   : {$region -fold}
      case pix_drw_type of
        0:
          begin
            pt_pix_clp_type  :=3;
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            if (pt_pix_srf_type<>0) then
              pt_color_proc_ind:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_clp_type<<1+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9
            else
              pt_color_proc_ind:=9;
            fx_cnt:=0;
            Exit;
          end;
        1:
          begin
            pt_pix_clp_type  :=3;
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=9;
              end;
            Exit;
          end;
        2:
          begin
            pt_pix_clp_type  :=3;
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            if (pt_pix_srf_type<>0) then
              pt_color_proc_ind:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_clp_type<<1+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9
            else
              pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=9;
              end;
            Exit;
          end;
      end; {$endregion}
    05   : {$region -fold}
      case pix_drw_type of
        0:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            fx_cnt           :=0;
            Exit;
          end;
        1:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
              end;
            Exit;
          end;
        2:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
              end;
            Exit;
          end;
      end; {$endregion}
    06   : {$region -fold}
      case pix_drw_type of
        0:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            fx_cnt           :=0;
            Exit;
          end;
        1:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=9;
              end;
            Exit;
          end;
        2:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=9;
              end;
            Exit;
          end;
      end; {$endregion}
    07   : {$region -fold}
      case pix_drw_type of
        0:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            fx_cnt           :=0;
            Exit;
          end;
        1:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=9;
                fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
              end;
            Exit;
          end;
        2:
          begin
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=9;
                fx_arr[i].pt_value_proc_ind:=((fx_arr[i].pt_pix_srf_type+1)>>1)*(10*fx_arr[i].pt_pix_cfx_type+pt_pix_clp_type<<1+fx_arr[i].pt_pix_cng_type)+(1-(fx_arr[i].pt_pix_srf_type+1)>>1)*9;
              end;
            Exit;
          end;
      end; {$endregion}
    08   : {$region -fold}
      case pix_drw_type of
        0:
          begin
            nt_pix_clp_type  :=3;
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            fx_cnt           :=0;
            Exit;
          end;
        1:
          begin
            nt_pix_clp_type  :=3;
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=9;
              end;
            Exit;
          end;
        2:
          begin
            nt_pix_clp_type  :=3;
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=9;
              end;
            Exit;
          end;
      end; {$endregion}
    09   : {$region -fold}
      case pix_drw_type of
        0:
          begin
            nt_pix_clp_type  :=3;
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            fx_cnt           :=0;
            Exit;
          end;
        1:
          begin
            nt_pix_clp_type  :=3;
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=9;
              end;
            Exit;
          end;
        2:
          begin
            nt_pix_clp_type  :=3;
            nt_begin_proc_ind:=0;
            nt_color_proc_ind:=9;
            pt_begin_proc_ind:=0;
            pt_color_proc_ind:=9;
            for i:=0 to fx_cnt-1 do
              begin
                fx_arr[i].nt_value_proc_ind:=((fx_arr[i].nt_pix_srf_type+1)>>1)*(10*fx_arr[i].nt_pix_cfx_type+nt_pix_clp_type<<1+fx_arr[i].nt_pix_cng_type)+(1-(fx_arr[i].nt_pix_srf_type+1)>>1)*9;
                fx_arr[i].pt_value_proc_ind:=9;
              end;
            Exit;
          end;
      end; {$endregion}
    10,11: {$region -fold}
      begin
        nt_begin_proc_ind:=0;
        nt_color_proc_ind:=9;
        pt_begin_proc_ind:=0;
        pt_color_proc_ind:=9;
        fx_cnt           :=0;
      end; {$endregion}
  end;}

  case sdr_type_ind of
    000: SdrType000;
    001: SdrType001;
    002: SdrType002;
    003: SdrType003;
    004: SdrType004;
    005: SdrType005;
    006: SdrType006;
    007: SdrType007;
    008: SdrType008;
    009: SdrType009;
    010: SdrType010;
    011: SdrType011;
    012: SdrType012;
    013: SdrType013;
    014: SdrType014;
    015: SdrType015;
    016: SdrType016;
    017: SdrType017;
    018: SdrType018;
    019: SdrType019;
    020: SdrType020;
    021: SdrType021;
    022: SdrType022;
    023: SdrType023;
    024: SdrType024;
    025: SdrType025;
    026: SdrType026;
    027: SdrType027;
    028: SdrType028;
    029: SdrType029;
    030: SdrType030;
    031: SdrType030;
    032: SdrType030;
    033: SdrType030;
    034: SdrType030;
    035: SdrType030;
    036: SdrType009;
    037: SdrType010;
    038: SdrType011;
  end;

end; {$endregion}
procedure TFastimage.SdrProcInit; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrProc[0]:=@UberShader0;
  SdrProc[1]:=@UberShader1;
  SdrProc[2]:=@UberShader2;
  SdrProc[3]:=@UberShader3;
end; {$endregion}
procedure TFastimage.UberShader0; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TFastimage.UberShader1; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  fx_arr_ptr: PFX;
  i,j       : shortint;
begin

  {Sprite Bounding Rectangles}
  SetRctDst;
  SetRctSrc;

  {Sprite Shader Type}
  SetSdrType;
  SdrType    [sdr_type_ind     ]; {ShaderType;}

  {Sprite Drawing}
  NTBeginProc[nt_begin_proc_ind];
  NTColorProc[nt_color_proc_ind];

  {Sprite Post-Processing}
  fx_arr_ptr:=Unaligned(@fx_arr[0]);
  for i:=0 to fx_cnt-1 do
    begin
      for j:=0 to fx_arr_ptr^.rep_cnt-1 do
        begin
          {Sprite Settings}

          {Sprite Drawing}
          NTValueProc[fx_arr_ptr^.nt_value_proc_ind];
        end;
      Inc(fx_arr_ptr);
    end;

end; {$endregion}
procedure TFastimage.UberShader2; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  fx_arr_ptr: PFX;
  i,j       : shortint;
begin

  {Sprite Bounding Rectangles}
  SetRctDst;
  SetRctSrc;

  {Sprite Shader Type}
  SetSdrType;
  SdrType    [sdr_type_ind     ]; {ShaderType;}

  {Sprite Drawing}
  PTBeginProc[pt_begin_proc_ind];
  PTColorProc[pt_color_proc_ind];

  {Sprite Post-Processing}
  fx_arr_ptr:=Unaligned(@fx_arr[0]);
  for i:=0 to fx_cnt-1 do
    begin
      for j:=0 to fx_arr_ptr^.rep_cnt-1 do
        begin
          {Sprite Settings}

          {Sprite Drawing}
          PTValueProc[fx_arr_ptr^.pt_value_proc_ind];
        end;
      Inc(fx_arr_ptr);
    end;

end; {$endregion}
procedure TFastimage.UberShader3; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  fx_arr_ptr: PFX;
  i,j       : shortint;
begin

  {Sprite Bounding Rectangles}
  SetRctDst;
  SetRctSrc;

  {Sprite Shader Type}
  SetSdrType;
  SdrType    [sdr_type_ind     ]; {ShaderType;}

  {Sprite Drawing}
  NTBeginProc[nt_begin_proc_ind];
  NTColorProc[nt_color_proc_ind];
  PTBeginProc[pt_begin_proc_ind];
  PTColorProc[pt_color_proc_ind];

  {Sprite Post-Processing}
  fx_arr_ptr:=Unaligned(@fx_arr[0]);
  for i:=0 to fx_cnt-1 do
    begin
      for j:=0 to fx_arr_ptr^.rep_cnt-1 do
        begin
          {Sprite Settings}

          {Sprite Drawing}
          NTValueProc[fx_arr_ptr^.nt_value_proc_ind];
          PTValueProc[fx_arr_ptr^.pt_value_proc_ind];
        end;
      Inc(fx_arr_ptr);
    end;

end; {$endregion}

// Clear Background from Image:
procedure TFastimage.ClrBkgnd; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  NTBeginProc[2];
  NTColorProc[0];
end; {$endregion} {$endregion}

{Create Border Around the Image-----------------------} {$region -fold}
procedure TFastImage.CrtBorderBmp(constref arr_src:TColorArr; var arr_dst:TObjSelArr;                         constref arr_src_width,arr_dst_width:TColor; constref rect_left,rect_top,rect_width,rect_height:TColor; var brdr_pix_cnt:TColor; constref obj_kind,obj_id:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr      : PInteger;
  arr_dst_ptr      : PObjSel;
  d_width1,d_width2: integer;
  x_,y_            : integer;
begin
  brdr_pix_cnt     :=0;
  d_width1         :=                   arr_src_width- rect_width;
  d_width2         :=                   arr_dst_width- rect_width;
  arr_src_ptr      :=@arr_src[rect_left+arr_src_width*(rect_top+1)];
  arr_dst_ptr      :=@arr_dst[rect_left+arr_dst_width*(rect_top+1)];
  for y_:=0 to rect_height-3 do
    begin
      for x_:=0 to rect_width-1 do
        begin
          if (arr_src_ptr^<>0) then
            begin
              if ((arr_src_ptr-arr_src_width)^=0) then
                if ((arr_dst_ptr-arr_dst_width)^.obj_kind<>obj_kind) then
                  begin
                    (arr_dst_ptr-arr_dst_width)^.obj_kind:=obj_kind;
                    (arr_dst_ptr-arr_dst_width)^.obj_id  :=obj_id  ;
                    Inc(brdr_pix_cnt);
                  end;
              if ((arr_src_ptr+arr_src_width)^=0) then
                if ((arr_dst_ptr+arr_dst_width)^.obj_kind<>obj_kind) then
                  begin
                    (arr_dst_ptr+arr_dst_width)^.obj_kind:=obj_kind;
                    (arr_dst_ptr+arr_dst_width)^.obj_id  :=obj_id  ;
                    Inc(brdr_pix_cnt);
                  end;
            end;
          Inc(arr_src_ptr);
          Inc(arr_dst_ptr);
        end;
      Inc(arr_src_ptr,d_width1);
      Inc(arr_dst_ptr,d_width2);
    end;
end; {$endregion}
procedure TFastImage.BorderCalc1 (constref arr_src:TColorArr; var arr_dst:T1Byte1Arr;                         constref arr_src_width,arr_dst_width:TColor; constref rct_dst_:TPtRect                                                                                          ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  first_row_pix_ptr1     : PInteger;
  first_row_pix_ptr2     : PByte;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  arr_src_ptr1           : PInteger;
  arr_dst_ptr1           : PByte;
  arr_src_ptr2           : PInteger;
  arr_dst_ptr2           : PByte;
  x,y                    : integer;
begin
  if (nt_pix_cnt=0) or (rct_dst_.height<3) then
    Exit;
  first_row_pix_ptr1     :=Unaligned(@arr_src            [(nt_pix_arr_row_mrg_top+rct_dst_.top)*arr_src_width+rct_dst_.left]);
  first_row_pix_ptr2     :=Unaligned(@arr_dst            [(nt_pix_arr_row_mrg_top+rct_dst_.top)*arr_dst_width+rct_dst_.left]);
  nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+00000000000000000000000000000000000000000]);
  nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000000000000]);
  for y:=0 to rct_dst_.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
    begin
      arr_src_ptr1:=first_row_pix_ptr1;
      arr_dst_ptr1:=first_row_pix_ptr2;
      for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
        begin
          arr_src_ptr2:=nt_pix_intr_sht_arr_ptr^+arr_src_ptr1;
          arr_dst_ptr2:=nt_pix_intr_sht_arr_ptr^+arr_dst_ptr1;
          if (arr_src_ptr2^<>0) then
            begin
              if ((arr_src_ptr2-arr_src_width)^ =0) then
                  (arr_dst_ptr2-arr_dst_width)^:=1;
              if ((arr_src_ptr2+arr_src_width)^ =0) then
                  (arr_dst_ptr2+arr_dst_width)^:=1;
              if ((arr_src_ptr2-0000000000001)^ =0) then
                  (arr_dst_ptr2-0000000000001)^:=1;
              if ((arr_src_ptr2+0000000000001)^ =0) then
                  (arr_dst_ptr2+0000000000001)^:=1;
            end;
          Inc(nt_pix_intr_sht_arr_ptr);
        end;
      Inc(nt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr1,arr_src_width);
      Inc(first_row_pix_ptr2,arr_dst_width);
    end;
end; {$endregion}
procedure TFastImage.BorderCalc2 (constref arr_src:TColorArr; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; constref arr_src_width,arr_dst_width:TColor; constref rct_dst_:TPtRect; out line_cnt:TColor                                                                     ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  first_row_pix_ptr1     : PInteger;
  first_row_pix_ptr2     : PByte;
  pt_pix_intr_cnt_dec    : integer;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  arr_src_ptr2           : PInteger;
  arr_dst_ptr2           : PByte;
  line_kind_arr          : array[0..7] of boolean;
  line_kind              : qword absolute line_kind_arr;
  arr_alpha_ptr          : PFastAALine;
  arr_dst_left_ptr       : PByte;
  arr_dst_right_ptr      : PByte;
  line_first_pt_ptr      : PByte;
  y_,x_,i,d0,d1,d2       : integer;
  a,b,c,d                : boolean;
label
  label1,label2;
begin
  if (pt_pix_cnt=0) or (rct_dst_.height<3) then
    Exit;
  d0                     :=                               (pt_pix_arr_row_mrg_top+rct_dst_.top)*arr_src_width;
  first_row_pix_ptr1     :=Unaligned(@arr_src            [(pt_pix_arr_row_mrg_top+rct_dst_.top)*arr_src_width+rct_dst_.left]);
  first_row_pix_ptr2     :=Unaligned(@arr_dst            [(pt_pix_arr_row_mrg_top+rct_dst_.top)*arr_dst_width+rct_dst_.left]);
  arr_dst_left_ptr       :=Unaligned(@arr_dst            [(pt_pix_arr_row_mrg_top+rct_dst_.top)*arr_dst_width+rct_dst_.left]);
  pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+00000000000000000000000000000000000000000]);
  pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000000000000]);
  arr_alpha_ptr          :=Unaligned(@arr_alpha          [00000000000000000000000000000000000000000000000000000000000000000]);
  for y_:=0 to 6{rct_dst_.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1} do
    begin
      arr_dst_right_ptr  :=arr_dst_left_ptr+rct_dst_.left+rct_dst_.width-1;
      pt_pix_intr_cnt_dec:=pt_pix_intr_cnt_arr_ptr^-1;
      for x_:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
        begin
          if (pt_pix_intr_cnt_dec=0) then
            begin
              Inc(pt_pix_intr_sht_arr_ptr);
              goto label1;
            end;
          arr_src_ptr2:=pt_pix_intr_sht_arr_ptr^+first_row_pix_ptr1;
          arr_dst_ptr2:=pt_pix_intr_sht_arr_ptr^+first_row_pix_ptr2;
          if (arr_dst_ptr2^=1) then                                                          //  -01234----5678
            begin                                                                            //  01234500006789
              {Fill Horizontal Line} {$region -fold}                                         //   87654    3210
              if ((arr_dst_ptr2+1)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr2;
                  while (arr_dst_ptr2^=1) and (pt_pix_intr_cnt_dec<>0) do
                    begin
                      arr_dst_ptr2^:=2;
                      Inc(arr_dst_ptr2);

                      Dec(pt_pix_intr_cnt_dec);
                    end;
                  if (pt_pix_intr_cnt_dec=0) then
                    begin
                      arr_dst_ptr2^:=2;
                    end;
                  //Dec(pt_pix_intr_sht_arr_ptr);
                  {arr_alpha_ptr^.line_shift:=arr_dst_ptr2-line_first_pt_ptr;
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=arr_dst_ptr2     -arr_dst_left_ptr+d0;
                  line_kind_arr[3]         :=((arr_src_ptr2+d1-1)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr2+d2  )^<>0);
                  {line_kind=2----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=2;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=0,1,3} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr2+d1-1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr2+d1  -arr_src_width)^<>0);
                      line_kind_arr[2]:=((arr_src_ptr2+d2  -arr_src_width)^<>0);
                      line_kind_arr[5]:=((arr_src_ptr2+d1-1+arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr2+d1  +arr_src_width)^<>0);
                      line_kind_arr[7]:=((arr_src_ptr2+d2  +arr_src_width)^<>0);
                      case line_kind of
                        {line_kind=0} {$region -fold}
                        {can be rolled to line_kind=1}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001,
                        {00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000,
                        {00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000,
                        {00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001,
                        {00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000,
                        {00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001,
                        {01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000,
                        {01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001,
                        {01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001,
                        {01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000,
                        {01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000,
                        {01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001,
                        {01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000,
                        {01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001,
                        {01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000,
                        {11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000,
                        {10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000,
                        {11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000,
                        {10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001:
                          begin
                            arr_alpha_ptr^.line_kind :=0;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=1} {$region -fold}
                        {can be rolled to line_kind=0}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000,
                        {01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000,
                        {01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000,
                        {11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000,
                        {01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000,
                        {11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000,
                        {01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000,
                        {11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000,
                        {10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000,
                        {00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000,
                        {00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000,
                        {10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000,
                        {00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000,
                        {10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000,
                        {01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000,
                        {00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001,
                        {01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001,
                        {00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001,
                        {11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001:
                          begin
                            arr_alpha_ptr^.line_kind :=1;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=3} {$region -fold}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000:
                        if ((arr_src_ptr2+d2-arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000:
                        if ((arr_src_ptr2+d2+arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                }end; {$endregion}
              {
              {Fill Vertical Line--} {$region -fold}
              else
              if ((arr_dst_ptr2+arr_dst_width)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr2;
                  while (arr_dst_ptr2^=1) do
                    begin
                      arr_dst_ptr2^:=2;
                      Inc(arr_dst_ptr2,arr_dst_width);
                    end;
                  arr_alpha_ptr^.line_shift:=Trunc((arr_dst_ptr2-line_first_pt_ptr)/arr_dst_width);
                  Dec(arr_dst_ptr2,arr_dst_ptr2-line_first_pt_ptr);
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=d1+arr_src_width *arr_alpha_ptr^.line_shift;
                  line_kind_arr[3]         :=((arr_src_ptr2+d1-arr_src_width)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr2+d2              )^<>0);
                  {line_kind=7----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=7;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=5,6,8} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr2+d1+1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr2+d1+1              )^<>0);
                      line_kind_arr[2]:=((arr_src_ptr2+d2+1              )^<>0);
                      line_kind_arr[5]:=((arr_src_ptr2+d1-1-arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr2+d1-1              )^<>0);
                      line_kind_arr[7]:=((arr_src_ptr2+d2-1              )^<>0);
                      case line_kind of
                        {line_kind=5} {$region -fold}
                        {can be rolled to line_kind=6}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001,
                        {00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000,
                        {00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000,
                        {00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001,
                        {00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000,
                        {00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001,
                        {01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000,
                        {01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001,
                        {01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001,
                        {01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000,
                        {01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000,
                        {01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001,
                        {01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000,
                        {01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001,
                        {01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000,
                        {11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000,
                        {10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000,
                        {11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000,
                        {10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001:
                          begin
                            arr_alpha_ptr^.line_kind :=5;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=6} {$region -fold}
                        {can be rolled to line_kind=5}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000,
                        {01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000,
                        {01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000,
                        {11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000,
                        {01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000,
                        {11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000,
                        {01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000,
                        {11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000,
                        {10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000,
                        {00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000,
                        {00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000,
                        {10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000,
                        {00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000,
                        {10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000,
                        {01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000,
                        {00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001,
                        {01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001,
                        {00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001,
                        {11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001:
                          begin
                            arr_alpha_ptr^.line_kind :=6;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=8} {$region -fold}
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000:
                        if ((arr_src_ptr2+d2+1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                        {01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000:
                        if ((arr_src_ptr2+d2-1-arr_src_width)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              }
              {
              {Fill One Pixel------} {$region -fold}
              else
                begin
                  if (PInteger(pt_pix_intr_cnt_arr_ptr)-PInteger(@pt_pix_intr_cnt_arr[0])=0) then
                    a:=True
                  else
                    a:=((arr_dst_ptr2-arr_dst_width)^<>1);

                  if (arr_dst_ptr2=arr_dst_left_ptr) then
                    b:=True
                  else
                    b:=((arr_dst_ptr2-1)^<>1);

                  if (PInteger(pt_pix_intr_cnt_arr_ptr)-PInteger(@pt_pix_intr_cnt_arr[0])=rct_dst_.height) then
                    c:=True
                  else
                    c:=((arr_dst_ptr2+arr_dst_width)^<>1);

                  if (arr_dst_ptr2=arr_dst_right_ptr) then
                    d:=True
                  else
                    d:=((arr_dst_ptr2+1)^<>1);

                  if (a and b) or (c and d) then
                    begin
                      arr_dst_ptr2^             :=2;
                      arr_alpha_ptr^.line_kind :=10;
                      arr_alpha_ptr^.first_pt_x:=arr_dst_ptr2-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                      Inc(arr_alpha_ptr);
                    end;
                end; {$endregion}
              }
              //goto label2;
            end;
          //Inc(pt_pix_intr_sht_arr_ptr);
          //label2:
        end;
      label1:
      //Inc(pt_pix_intr_sht_arr_ptr);
      Inc(pt_pix_intr_cnt_arr_ptr);
      Inc(first_row_pix_ptr1,arr_src_width);
      Inc(first_row_pix_ptr2,arr_dst_width);
      Inc(arr_dst_left_ptr  ,arr_dst_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion} {$endregion}

{Image Clipping---------------------------------------} {$region -fold}
procedure TFastImage.UlsProcInit;                                                                           {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  NTUselessProc[0]:=Unaligned(@NTUseless0);
  NTUselessProc[1]:=Unaligned(@NTUseless1);
  NTUselessProc[2]:=Unaligned(@NTUseless2);
  PTUselessProc[0]:=Unaligned(@PTUseless0);
  PTUselessProc[1]:=Unaligned(@PTUseless1);
  PTUselessProc[2]:=Unaligned(@PTUseless2);
end; {$endregion}
procedure TFastImage.NTUseless0(var arr_dst:TColorArr; constref arr_dst_width:TColor; constref val:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_cnt_arr_ptr   : PInteger;
  nt_pix_intr_sht_arr_ptr   : PInteger;
  first_row_item_arr_dst_ptr: PInteger;
  arr_dst_ptr               : PInteger;
  nt_z_item_cnt             : TColor;
  x,y                       : integer;
begin
  if (nt_pix_cnt<>0) then
    begin
      nt_z_item_cnt             :=0;
      first_row_item_arr_dst_ptr:=Unaligned(@arr_dst            [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*arr_dst_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr   :=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr   :=Unaligned(@nt_pix_intr_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          arr_dst_ptr:=first_row_item_arr_dst_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              if ((nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                begin
                  (nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                  Inc(nt_z_item_cnt);
                end;
              Inc (nt_pix_intr_sht_arr_ptr);
            end;
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_item_arr_dst_ptr,arr_dst_width);
        end;
    end;
  if (nt_z_item_cnt=0) then
    nt_useless:=0
  else
    nt_useless:=1;
  //if (img_kind=3) then
end; {$endregion}
procedure TFastImage.NTUseless1(var arr_dst:TColorArr; constref arr_dst_width:TColor; constref val:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_cnt_arr_ptr   : PInteger;
  nt_pix_intr_sht_arr_ptr   : PInteger;
  first_row_item_arr_dst_ptr: PInteger;
  arr_dst_ptr               : PInteger;
  nt_z_item_cnt             : TColor;
  x,y                       : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr=Nil) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    begin
      nt_useless:=0;
      Exit;
    end;
  if (nt_pix_cnt<>0) then
    begin
      nt_z_item_cnt             :=0;
      first_row_item_arr_dst_ptr:=Unaligned(@arr_dst            [(rct_src.top+bmp_ftimg_top)*arr_dst_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr   :=Unaligned(@nt_pix_intr_cnt_arr[ rct_src.top+0000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr   :=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+0000000000000000000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          arr_dst_ptr:=first_row_item_arr_dst_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              if ((nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                begin
                  (nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                  Inc(nt_z_item_cnt);
                end;
              Inc (nt_pix_intr_sht_arr_ptr);
            end;
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_item_arr_dst_ptr,arr_dst_width);
        end;
    end;
  if (nt_z_item_cnt=0) then
    nt_useless:=0
  else
    nt_useless:=1;
  //if (img_kind=3) then
end; {$endregion}
procedure TFastImage.NTUseless2(var arr_dst:TColorArr; constref arr_dst_width:TColor; constref val:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_cnt_arr_ptr   : PInteger;
  nt_pix_intr_sht_arr_ptr   : PInteger;
  first_row_item_arr_dst_ptr: PInteger;
  arr_dst_ptr               : PInteger;
  first_sht_pix_ptr         : PInteger;
  nt_z_item_cnt             : TColor;
  x,y                       : integer;
  c,c1,c2                   : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (nt_cnt_ind_arr=Nil) then
    Exit;
  if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
    begin
      nt_useless:=0;
      Exit;
    end;
  if (nt_pix_cnt<>0) then
    begin
      nt_z_item_cnt             :=0;
      first_row_item_arr_dst_ptr:=Unaligned(@arr_dst            [rct_dst.pt_rct.top*arr_dst_width+rct_dst.pt_rct.left]);
      nt_pix_intr_cnt_arr_ptr   :=Unaligned(@nt_pix_intr_cnt_arr[rct_src.top+0000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr   :=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              arr_dst_ptr:=first_row_item_arr_dst_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc(nt_pix_intr_sht_arr_ptr,c1+1);
                  for x:=0 to (c2+1)-(c1+1)-1 do
                    begin
                      if ((nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                        begin
                          (nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                          Inc(nt_z_item_cnt);
                        end;
                      Inc(nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc(nt_pix_intr_sht_arr_ptr,c+1);
                  for x:=0 to nt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                    begin
                      if ((nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                        begin
                          (nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                          Inc(nt_z_item_cnt);
                        end;
                      Inc(nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
                  for x:=0 to c do
                    begin
                      if ((nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                        begin
                          (nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                          Inc(nt_z_item_cnt);
                        end;
                      Inc(nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                  begin
                    if ((nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                      begin
                        (nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                        Inc(nt_z_item_cnt);
                      end;
                    Inc(nt_pix_intr_sht_arr_ptr);
                  end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_item_arr_dst_ptr,arr_dst_width);
        end;
    end;
  if (nt_z_item_cnt=0) then
    nt_useless:=0
  else
    nt_useless:=1;
  //if (img_kind=3) then
end; {$endregion}
procedure TFastImage.PTUseless0(var arr_dst:TColorArr; constref arr_dst_width:TColor; constref val:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_intr_cnt_arr_ptr   : PInteger;
  pt_pix_intr_sht_arr_ptr   : PInteger;
  first_row_item_arr_dst_ptr: PInteger;
  arr_dst_ptr               : PInteger;
  pt_z_item_cnt             : integer;
  x,y                       : integer;
begin
  if (pt_pix_cnt<>0) then
    begin
      pt_z_item_cnt             :=0;
      first_row_item_arr_dst_ptr:=Unaligned(@arr_dst            [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*arr_dst_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr   :=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr   :=Unaligned(@pt_pix_intr_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          arr_dst_ptr:=first_row_item_arr_dst_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              if ((pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                begin
                  (pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                  Inc(pt_z_item_cnt);
                end;
              Inc (pt_pix_intr_sht_arr_ptr);
            end;
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_item_arr_dst_ptr,arr_dst_width);
        end;
    end;
  if (pt_z_item_cnt=0) then
    pt_useless:=0
  else
    pt_useless:=1;
  //if (img_kind=3) then
end; {$endregion}
procedure TFastImage.PTUseless1(var arr_dst:TColorArr; constref arr_dst_width:TColor; constref val:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_intr_cnt_arr_ptr   : PInteger;
  pt_pix_intr_sht_arr_ptr   : PInteger;
  first_row_item_arr_dst_ptr: PInteger;
  arr_dst_ptr               : PInteger;
  pt_z_item_cnt             : integer;
  x,y                       : integer;
begin
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr=Nil) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    begin
      pt_useless:=0;
      Exit;
    end;
  if (pt_pix_cnt<>0) then
    begin
      pt_z_item_cnt             :=0;
      first_row_item_arr_dst_ptr:=Unaligned(@arr_dst            [(rct_src.top+bmp_ftimg_top)*arr_dst_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr   :=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+0000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr   :=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+0000000000000000000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          arr_dst_ptr:=first_row_item_arr_dst_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              if ((pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                begin
                  (pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                  Inc(pt_z_item_cnt);
                end;
              Inc (pt_pix_intr_sht_arr_ptr);
            end;
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_item_arr_dst_ptr,arr_dst_width);
        end;
    end;
  if (pt_z_item_cnt=0) then
    pt_useless:=0
  else
    pt_useless:=1;
  //if (img_kind=3) then
end; {$endregion}
procedure TFastImage.PTUseless2(var arr_dst:TColorArr; constref arr_dst_width:TColor; constref val:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_intr_cnt_arr_ptr   : PInteger;
  pt_pix_intr_sht_arr_ptr   : PInteger;
  first_row_item_arr_dst_ptr: PInteger;
  arr_dst_ptr               : PInteger;
  first_sht_pix_ptr         : PInteger;
  pt_z_item_cnt             : integer;
  x,y                       : integer;
  c,c1,c2                   : integer;
label
  label1;
begin
  if (rct_src.width <=0) then
    Exit;
  if (rct_src.height<=0) then
    Exit;
  if (pt_cnt_ind_arr=Nil) then
    Exit;
  if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
    begin
      pt_useless:=0;
      Exit;
    end;
  if (pt_pix_cnt<>0) then
    begin
      pt_z_item_cnt             :=0;
      first_row_item_arr_dst_ptr:=Unaligned(@arr_dst            [rct_dst.pt_rct.top*arr_dst_width+rct_dst.pt_rct.left]);
      pt_pix_intr_cnt_arr_ptr   :=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+0000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr   :=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              arr_dst_ptr:=first_row_item_arr_dst_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc(pt_pix_intr_sht_arr_ptr,c1+1);
                  for x:=0 to (c2+1)-(c1+1)-1 do
                    begin
                      if ((pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                        begin
                          (pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                          Inc(pt_z_item_cnt);
                        end;
                      Inc(pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc(pt_pix_intr_sht_arr_ptr,c+1);
                  for x:=0 to pt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                    begin
                      if ((pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                        begin
                          (pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                          Inc(pt_z_item_cnt);
                        end;
                      Inc(pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
                  for x:=0 to c do
                    begin
                      if ((pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                        begin
                          (pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                          Inc(pt_z_item_cnt);
                        end;
                      Inc(pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                  begin
                    if ((pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                      begin
                        (pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                        Inc(pt_z_item_cnt);
                      end;
                    Inc(pt_pix_intr_sht_arr_ptr);
                  end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_item_arr_dst_ptr,arr_dst_width);
        end;
    end;
  if (pt_z_item_cnt=0) then
    pt_useless:=0
  else
    pt_useless:=1;
  //if (img_kind=3) then
end; {$endregion}
function  TFastImage.Useless: byte;                                                                 inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (nt_useless=0) and (pt_useless=0) then
    Result:=0;
  if (nt_useless=1) and (pt_useless=0) then
    Result:=1;
  if (nt_useless=0) and (pt_useless=1) then
    Result:=2;
  if (nt_useless=1) and (pt_useless=1) then
    Result:=3;
end; {$endregion}
procedure TFastImage.SetRctPos (rct    :TPtRect);                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct do
    begin
      bmp_ftimg_left  :=left  ;
      bmp_ftimg_top   :=top   ;
      bmp_ftimg_width :=width ;
      bmp_ftimg_height:=height;
      bmp_ftimg_right :=right ;
      bmp_ftimg_bottom:=bottom;
    end;
end; {$endregion}
procedure TFastImage.SetRctPos (x,y,w,h:integer);                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  bmp_ftimg_left  :=x;
  bmp_ftimg_top   :=y;
  bmp_ftimg_width :=w;
  bmp_ftimg_height:=h;
  bmp_ftimg_right :=bmp_ftimg_left+bmp_ftimg_width ;
  bmp_ftimg_bottom:=bmp_ftimg_top +bmp_ftimg_height;
end; {$endregion}
procedure TFastImage.SetRctPos (x,y    :integer);                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  bmp_ftimg_left  :=x;
  bmp_ftimg_top   :=y;
  bmp_ftimg_right :=bmp_ftimg_left+bmp_ftimg_width ;
  bmp_ftimg_bottom:=bmp_ftimg_top +bmp_ftimg_height;
end; {$endregion}
procedure TFastImage.SetRctPos (pvt    :TPtPosF);                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  bmp_ftimg_left  :=Trunc(pvt.x);
  bmp_ftimg_top   :=Trunc(pvt.y);
  bmp_ftimg_right :=bmp_ftimg_left+bmp_ftimg_width ;
  bmp_ftimg_bottom:=bmp_ftimg_top +bmp_ftimg_height;
end; {$endregion}
procedure TFastImage.SetRctDst;                                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  rct_dst:=PtRctB(bmp_ftimg_left,bmp_ftimg_top,bmp_ftimg_right,bmp_ftimg_bottom);
  rct_dst:=ClippedRctB(PtRct(rct_clp_ptr^.left  +rct_clp_mrg,
                             rct_clp_ptr^.top   +rct_clp_mrg,
                             rct_clp_ptr^.right -rct_clp_mrg,
                             rct_clp_ptr^.bottom-rct_clp_mrg),
                       rct_dst.pt_rct,
                       nt_pix_clp_type,
                       pt_pix_clp_type);
end; {$endregion}
procedure TFastImage.SetRctSrc;                                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  rct_src:=PtBounds(rct_dst.pt_rct.left  -bmp_ftimg_left,
                    rct_dst.pt_rct.top   -bmp_ftimg_top,
                    rct_dst.pt_rct.right -rct_dst.pt_rct.left,
                    rct_dst.pt_rct.bottom-rct_dst.pt_rct.top);
end; {$endregion} {$endregion}

{Init. Part-------------------------------------------} {$region -fold}
constructor TFastImage.Create  (constref bkgnd_ptr:PInteger; constref bkgnd_width,bkgnd_height:TColor; var rct_clp:TPtRect; constref bmp_src_rct:TPtRect; constref empty:TColor=0);                                                                                                                                       {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  {Set Max. Alpha Value-----------} {$region -fold}
  alpha_max:=maxbyte; {$endregion}

  {Set Drawing Surface(Background)} {$region -fold}
  SetBkgnd(bkgnd_ptr,bkgnd_width,bkgnd_height,rct_clp); {$endregion}

  {Misc. Precalc. Settings--------} {$region -fold}
  CmpProcInit;
  FilProcInit;
  SdrProcInit;
  UlsProcInit;
  SdrTypeInit;
  ShaderInfo;
  SetPPInfo; {$endregion}

  {Set Clipping Rectangle---------} {$region -fold}
  {SetClpRct(rct_clp);} {$endregion}

end; {$endregion}
constructor TFastImage.Create  (constref bkgnd_ptr:PInteger; constref bkgnd_width,bkgnd_height:TColor; var rct_clp:TPtRect; constref bmp_src_rct:TPtRect; constref location:string=''; constref ImgLstGetBmp:TProc1=Nil; constref img_ind:TColor=0; constref mask_tpl_calc:boolean=False; constref pic_src:TPicture=Nil); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  icn_src_pic       : TPicture=Nil;
  icn_src0          : TBitmap =Nil;
  icn_src           : TBitmap =Nil;
  icn_src_ptr       : PInteger=Nil;
  icn_src_pic_is_nil: boolean =True;
  icn_src0_is_nil   : boolean =True;
begin

  {Set Max. Alpha Value-----------} {$region -fold}
  alpha_max:=maxbyte; {$endregion}

  {Is Spite a Tile Map------------} {$region -fold}
  tile_map_calc:=mask_tpl_calc;
  if tile_map_calc then
    sln_prop_var:=curve_default_prop; {$endregion}

  {Set Drawing Surface(Background)} {$region -fold}
  SetBkgnd(bkgnd_ptr,bkgnd_width,bkgnd_height,rct_clp); {$endregion}

  {Misc. Precalc. Settings--------} {$region -fold}
  CmpProcInit;
  FilProcInit;
  SdrProcInit;
  UlsProcInit;
  SdrTypeInit;
  ShaderInfo;
  SetPPInfo; {$endregion}

  {Load Sprite--------------------} {$region -fold}
  if (pic_src<>Nil) then
    begin
      icn_src        :=CrtTBmpInst(pic_src.Bitmap,icn_src_ptr);
      icn_src0_is_nil:=False;
    end
  else
  if FileExists(location) then
    begin
      icn_src_pic       :=CrtTPicInstFromHDDSrc(location);
      icn_src           :=CrtTBmpInst(icn_src_pic.Bitmap,icn_src_ptr);
      icn_src_pic_is_nil:=False;
    end
  else
  if (ImgLstGetBmp<>Nil) then
    begin
      icn_src0       :=CrtTBmpInstFromImgLst(ImgLstGetBmp,img_ind);
      icn_src        :=CrtTBmpInst(icn_src0,icn_src_ptr);
      icn_src0_is_nil:=False;
    end;
  if (icn_src_ptr=Nil) then
    Exit; {$endregion}

  {Compress Sprite----------------} {$region -fold}
  SetValInfo(icn_src_ptr,icn_src_ptr,icn_src_ptr,icn_src.width,icn_src.height);
  bmp_src_rct_clp :=ClippedRct(PtBounds(0,0,icn_src.width,icn_src.height),bmp_src_rct);
  ImgToCImg;
  bmp_ftimg_width :=bmp_src_rct_clp.width;
  bmp_ftimg_height:=bmp_src_rct_clp.height; {$endregion}

  {Set Clipping Rectangle---------} {$region -fold}
  {SetClpRct(rct_clp);} {$endregion}

  {Clear Resources----------------} {$region -fold}
  DeleteObject(icn_src.Canvas.Handle);
  //DeleteObject(icn_src.Handle);
  //SrcDestroy  (icn_src);
  if (not icn_src_pic_is_nil) then
    SrcDestroy(icn_src_pic);
  if (not icn_src0_is_nil) then
    SrcDestroy(icn_src0);
  icn_src_ptr:=Nil; {$endregion}

end; {$endregion}
destructor  TFastImage.Destroy;                                                                                 {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  self.Free;
  inherited Destroy;
end; {$endregion}
procedure TFastImage.SetBkgnd  (constref bkgnd_ptr:PInteger; constref bkgnd_width,bkgnd_height:TColor; constref rct_clp:TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  bmp_bkgnd_ptr   :=bkgnd_ptr   ;
  bmp_bkgnd_width :=bkgnd_width ;
  bmp_bkgnd_height:=bkgnd_height;
  rct_clp_ptr     :=@rct_clp;
end; {$endregion}
procedure TFastImage.SetClpRct (constref rct_clp:TPtRect);                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  rct_clp_ptr:=Unaligned(@rct_clp);
end; {$endregion}
procedure TFastImage.SetValInfo(constref bmp_color_ptr_,bmp_alpha_ptr_,bmp_value_ptr_:PInteger; constref ftimg_width,ftimg_height:TColor); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  bmp_color_ptr          :=bmp_color_ptr_;
  bmp_alpha_ptr          :=bmp_alpha_ptr_;
  bmp_value_ptr          :=bmp_value_ptr_;
  bmp_ftimg_width        :=ftimg_width ;
  bmp_ftimg_height       :=ftimg_height;
  bmp_ftimg_width_origin :=ftimg_width ;
  bmp_ftimg_height_origin:=ftimg_height;
end; {$endregion}
procedure TFastImage.SetPPInfo (val:TColor=$00434D3E);                                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with col_trans_var do
    begin
      // set monochrome          value;
      monochrome_val    :=val;
      // set red   channel       value;
      r_val             :=Red  (monochrome_val);
      // set green channel       value;
      g_val             :=Green(monochrome_val);
      // set blue  channel       value;
      b_val             :=Blue (monochrome_val);
      // set monochrome noise    value;
      monochrome_val    :=RGB  (b_val,g_val,r_val);
    end;
end; {$endregion}
procedure TFastImage.SetGradVec(constref vec:TLnPos);                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  grad_vec:=vec;
end; {$endregion}
procedure TFastImage.SetGradVec(x0,y0,x1,y1:integer);                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  grad_vec.x0:=x0;
  grad_vec.y0:=y0;
  grad_vec.x1:=x1;
  grad_vec.y1:=y1;
end; {$endregion}
procedure TFastImage.SrcDestroy(bmp_src:TPicture  );                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  bmp_src.Free;
end; {$endregion}
procedure TFastImage.SrcDestroy(bmp_src:TBitmap   );                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  bmp_src.Free;
end; {$endregion}
procedure TFastImage.SrcDestroy(arr_src:TColorArr);                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(arr_src,0);
  Finalize (arr_src);
end; {$endregion}
procedure TFastImage.SrcDestroy(arr_src:TWordArr );                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(arr_src,0);
  Finalize (arr_src);
end; {$endregion}
procedure TFastImage.SrcDestroy(arr_src:T1Byte1Arr );                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(arr_src,0);
  Finalize (arr_src);
end; {$endregion} {$endregion}
{$endregion}



(**************************** Fast Actor Container ****************************) {$region -fold}

constructor TFastActorSet.Create(constref bkgnd_ptr:PInteger; constref bkgnd_width,bkgnd_height:TColor; var rct_clp:TPtRect; constref bmp_src_rct:TPtRect; constref location:string=''; constref ImgLstGetBmp:TProc1=Nil; constref d_icon_img_lst_ind:TColor=0); {$region -fold}
begin

  {Default Icon---} {$region -fold}
  d_icon:=TFastImage.Create(bkgnd_ptr,
                            bkgnd_width,
                            bkgnd_height,
                            rct_clp,
                            bmp_src_rct,
                            location,
                            ImgLstGetBmp,
                            d_icon_img_lst_ind); {$endregion}

  {Selection Field} {$region -fold}
  SetLength(sel_fld,bkgnd_width*bkgnd_height);
  PtrInit  (sel_fld_ptr,sel_fld); {$endregion}

end; {$endregion}
destructor TFastActorSet.Destroy; {$region -fold}
begin
  self.Free;
  inherited Destroy;
end; {$endregion}
procedure TFastActorSet.AddActor(x,y:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  Inc        (act_cnt);
  SetLength  (act_arr,
              act_cnt);
  SetLength  (act_pos_arr,
              act_cnt);
  act_arr    [act_cnt-1]  :=TFastActor.Create;
  act_pos_arr[act_cnt-1].x:=x-d_icon.bmp_ftimg_width >>1;
  act_pos_arr[act_cnt-1].y:=y-d_icon.bmp_ftimg_height>>1;

  with d_icon do
   begin
     SetRctPos(x,y);
     SdrProc[3];
   end;

end; {$endregion}
{$endregion}



(********************************* Fast Actor *********************************) {$region -fold}

constructor TFastActor.Create; {$region -fold}
begin
  SetLength(frm_arr,frm_cnt);
end; {$endregion}
destructor TFastActor.Destroy; {$region -fold}
begin
  self.Free;
  inherited Destroy;
end; {$endregion}
{$endregion}



(***************************** Fast Line Routines *****************************) {$region -fold}

{Init. Part--} {$region -fold}
constructor TFastLine.Create;                                                                                                                        {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  LineSInit;
end; {$endregion}
destructor TFastLine.Destroy;                                                                                                                        {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  self.Free;
  inherited Destroy;
end; {$endregion}
procedure TFastLine.GCCArrInit;                                                                                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  gcd_arr:=Nil;
  SetLength  (gcd_arr,ln_arr_width*ln_arr_height);
  LinePrecalc(        ln_arr_width,ln_arr_height);
end; {$endregion}
// Replace Lookup Table(Precalculated Array):
procedure TFastLine.GCCArrRepl(dst_fl_var:TFastLine);                                                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {gcd_arr:=Nil;
  SetLength(gcd_arr,ln_arr_width*ln_arr_height);
  gcd_arr:=dst_fl_var.gcd_arr;}
end; {$endregion}
procedure TFastLine.BuffersInit(w,h:TColor; ln_arr0_init:boolean; ln_arr1_init:boolean; ln_arr2_init:boolean; aa_buff_init:boolean);         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  if ((w=0) or (h=0)) then
    Exit;
  ln_arr_width :=w;
  ln_arr_height:=h;
  if ln_arr0_init then
    begin
      SetLength(ln_arr0,w*h);
      ln_arr0_ptr:=Unaligned(@ln_arr0[0]);
    end;
  if ln_arr1_init then
    begin
      SetLength(ln_arr1,w*h);
      ln_arr1_ptr:=Unaligned(@ln_arr1[0]);
    end;
  if ln_arr2_init then
    begin
      SetLength(ln_arr2,w);
      for i:=0 to w-1 do
        SetLength(ln_arr2[i],h);
    end;
  if aa_buff_init then
    begin
      SetLength(aa_arr1,w*h);
      SetLength(aa_arr2,w*h);
    end;
end; {$endregion}
procedure TFastLine.SetBkgnd(constref bmp_dst_ptr_:PInteger; constref bmp_dst_width_,bmp_dst_height_:TColor; constref rct_clp_ptr_:PPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  bmp_dst_ptr   :=bmp_dst_ptr_;
  bmp_dst_width :=bmp_dst_width_;
  bmp_dst_height:=bmp_dst_height_;
  rct_clp_ptr   :=rct_clp_ptr_;
end; {$endregion}
procedure TFastLine.MinimizeArrs(aa_buff_clear:boolean);                                                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Setlength(ln_arr0,0);
  Setlength(ln_arr1,0);
  Setlength(ln_arr2,0);
  if (not aa_buff_clear) then
    Exit;
  Setlength(aa_arr1,0);
  Setlength(aa_arr2,0);
end; {$endregion} {$endregion}

{Line Drawing} {$region -fold}
// (Fast Line Grid Precalculation) Предпросчет сетки для быстрой линии:
{class} procedure TFastLine.LinePrecalc(w,h:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  gcd_arr_ptr            : PGCDGrid; //^TFastLine.TGCDGrid;
  i,j,k,t1,t2,s1,s2,v1,v2: integer;

  {(Binary Stein Algorithm, which finds Greatest Common Divisor of two integer numbers) Бинарный алгоритм Стейна нахождения НСД двух натуральных чисел}
  function SteinGCD(a_,b_:integer): integer; {$region -fold}
  var
    k_: integer;
  begin
    k_:=1;
    while (a_<>0) and (a_<>0) do
      begin
        while (a_ and 1=0) and (b_ and 1=0) do
          begin
            a_:=a_>>1;
            b_:=b_>>1;
            k_:=k_<<1;
          end;
        while (a_ and 1=0) do
          a_:=a_>>1;
        while (b_ and 1=0) do
          b_:=b_>>1;
        if (a_>=b_) then
          a_:=a_-b_
        else
          b_:=b_-a_;
      end;
    Result:=b_*k_;
  end; {$endregion}

begin
  grid_pt_rad:=2;
  k:=2*grid_pt_rad;

  {Loop 1} {$region -fold}
  for j:=0 to h-1 do
    for i:=0 to w-1 do
      if (i>=j) then
        begin
          gcd_arr[i+j*w].a:=SteinGCD(i+1,j+1);
          if (gcd_arr[i+j*w].a<>1) then
            begin

              // Line1 Precalc.:
             {dx+1:=a*c;
              dy+1:=a;}
              if (gcd_arr[i+j*w].a=j+1) then {$region -fold}
                begin
                  gcd_arr[i+j*w].f_ln_kind:=1;
                  gcd_arr[i+j*w].b        :=0;
                  gcd_arr[i+j*w].c        :=Trunc((i+1)/(j+1));
                  Continue;
                end; {$endregion}

              // Line2 Precalc.:
             {dx+1:=c*(dy+1)+a:=a*b*c+a*(c+1):=a((b+1)*c+1);
              dy+1:=a*(b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-1) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) then {$region -fold}
                begin
                  gcd_arr[i+j*w].f_ln_kind:=2;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1));
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-1)/(gcd_arr[i+j*w].b+1));
                  Continue;
                end; {$endregion}

              // Line3 Precalc.:
             {dx+1:=c*(dy+1)+a*b:=a*c+a*b*(c+1):=a((b+1)*c+b);
              dy+1:=a*(b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-((j+1)/gcd_arr[i+j*w].a-1)) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) then {$region -fold}
                begin
                  gcd_arr[i+j*w].f_ln_kind:=3;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1));
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-gcd_arr[i+j*w].b)/(gcd_arr[i+j*w].b+1));
                  Continue;
                end; {$endregion}

              // Line4 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*b*c+a*(b+1)*(c+1):=a((2*b+1)*c+b+1);
              dy+1:=a*(2*b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-(((j+1)/gcd_arr[i+j*w].a-1)/2)-1) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) {$region -fold}
                 and
                 (Trunc((j+1)/gcd_arr[i+j*w].a) mod 2=1) then
                begin
                  gcd_arr[i+j*w].f_ln_kind:=4;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1)/2);
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-gcd_arr[i+j*w].b-1)/((2*gcd_arr[i+j*w].b)+1));
                  Continue;
                end; {$endregion}

              // Line5 Precalc.:
             {dx+1:=c*(dy+1)+a*b:=a*(b+1)*c+a*b*(c+1):=a((2*b+1)*c+b);
              dy+1:=a*(2*b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-(((j+1)/gcd_arr[i+j*w].a-1)/2)) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) {$region -fold}
                 and
                 (Trunc((j+1)/gcd_arr[i+j*w].a) mod 2=1) then
                begin
                  gcd_arr[i+j*w].f_ln_kind:=5;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1)/2);
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-gcd_arr[i+j*w].b)/((2*gcd_arr[i+j*w].b)+1));
                  Continue;
                end; {$endregion}

              // Line6 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*2*b*c+a*(b+1)*(c+1):=a((3*b+1)*c+b+1);
              dy+1:=a*(3*b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-(((j+1)/gcd_arr[i+j*w].a-1)/3)-1) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) {$region -fold}
                 and
                 (Trunc((j+1)/gcd_arr[i+j*w].a) mod 3=1) then
                begin
                  gcd_arr[i+j*w].f_ln_kind:=6;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1)/3);
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-gcd_arr[i+j*w].b-1)/((3*gcd_arr[i+j*w].b)+1));
                  Continue;
                end; {$endregion}

              // Line7 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*(2*b+1)*c+a*b*(c+1):=a((3*b+1)*c+b);
              dy+1:=a*(3*b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-(((j+1)/gcd_arr[i+j*w].a-1)/3)) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) {$region -fold}
                 and
                 (Trunc((j+1)/gcd_arr[i+j*w].a) mod 3=1) then
                begin
                  gcd_arr[i+j*w].f_ln_kind:=7;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1)/3);
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-gcd_arr[i+j*w].b)/((3*gcd_arr[i+j*w].b)+1));
                  Continue;
                end; {$endregion}

              // Line8 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*b*c+a*(2*b+1)*(c+1):=a((3*b+1)*c+2*b+1);
              dy+1:=a*(3*b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-2*(((j+1)/gcd_arr[i+j*w].a-1)/3)-1) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) {$region -fold}
                 and
                 (Trunc((j+1)/gcd_arr[i+j*w].a) mod 3=1) then
                begin
                  gcd_arr[i+j*w].f_ln_kind:=8;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1)/3);
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-2*gcd_arr[i+j*w].b-1)/((3*gcd_arr[i+j*w].b)+1));
                  Continue;
                end; {$endregion}

              // Line9 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*(b+1)*c+a*2*b*(c+1):=a((3*b+1)*c+2*b);
              dy+1:=a*(3*b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-2*(((j+1)/gcd_arr[i+j*w].a-1)/3)) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) {$region -fold}
                 and
                 (Trunc((j+1)/gcd_arr[i+j*w].a) mod 3=1) then
                begin
                  gcd_arr[i+j*w].f_ln_kind:=9;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1)/3);
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-2*gcd_arr[i+j*w].b)/((3*gcd_arr[i+j*w].b)+1));
                  Continue;
                end; {$endregion}

            end;
        end; {$endregion}

  {Loop 2} {$region -fold}
  for j:=0 to h-1 do
    for i:=0 to w-1 do
      if (i>j)                        then
        if (gcd_arr[i+j*w].f_ln_kind=0) then
          begin
            v1:=grid_pt_rad;
            v2:=grid_pt_rad;
            for t1:=0 to k do
              for t2:=0 to k do
                begin
                  s1:=t1-grid_pt_rad;
                  s2:=t2-grid_pt_rad;
                  if (i+s1>=0) and (i+s1<=w-1) and
                     (j+s2>=0) and (j+s2<=h-1) and
                     (gcd_arr[(i+s1)+(j+s2)*w].d<>-1) and
                     (gcd_arr[(i+s1)+(j+s2)*w].f_ln_kind<>0) and
                     (Max2(Abs(s1),Abs(s2))<Max2(Abs(v1),Abs(v2))) then
                    begin
                      v1:=s1;
                      v2:=s2;
                    end;
                end;
            if (i+v1>=0) and (i+v1<=w-1) and
               (j+v2>=0) and (j+v2<=h-1) then
              begin
                gcd_arr[i+j*w]  :=gcd_arr[(i+v1)+(j+v2)*w];
                gcd_arr[i+j*w].d:=-1;
              end;
          end; {$endregion}

  {Loop 3} {$region -fold}
  {2 alternative records of the same code block}
  {1.} {$region -fold}
  {for j:=0 to h-1 do
    for i:=0 to w-1 do
      if (i<j) then
        begin
          gcd_arr[i+j*w]          :=gcd_arr[j+i*w];
          gcd_arr[i+j*w].f_ln_kind:=gcd_arr[j+i*w].f_ln_kind+10;
        end;} {$endregion}
  {2.} {$region -fold}
  gcd_arr_ptr:=Unaligned(@gcd_arr[0]);
  for j:=0 to h-1 do
    for i:=0 to w-1 do
      begin
        if (i<j) then
          begin
            gcd_arr_ptr^          :=gcd_arr[j+i*w];
            gcd_arr_ptr^.f_ln_kind:=gcd_arr[j+i*w].f_ln_kind+10;
          end;
        Inc(gcd_arr_ptr);
      end; {$endregion} {$endregion}

end; {$endregion}

{Fast Line Solid (Width - 1 pixel)}

// (Solid Line Initialization) Инициализация сплошной линии:
procedure TFastLine.LineSInit; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  {Right Bottom Corner}
  {0°..-45°}
  LineProc[00]:=Unaligned(@LineS00   );
  LineProc[01]:=Unaligned(@LineS01RBC);
  LineProc[02]:=Unaligned(@LineS02RBC);
  LineProc[03]:=Unaligned(@LineS03RBC);
  LineProc[04]:=Unaligned(@LineS04RBC);
  LineProc[05]:=Unaligned(@LineS05RBC);
  LineProc[06]:=Unaligned(@LineS06RBC);
  LineProc[07]:=Unaligned(@LineS07RBC);
  LineProc[08]:=Unaligned(@LineS08RBC);
  LineProc[09]:=Unaligned(@LineS09RBC);
  {-45°..-90°}
  LineProc[10]:=Unaligned(@LineS10   );
  LineProc[11]:=Unaligned(@LineS11RBC);
  LineProc[12]:=Unaligned(@LineS12RBC);
  LineProc[13]:=Unaligned(@LineS13RBC);
  LineProc[14]:=Unaligned(@LineS14RBC);
  LineProc[15]:=Unaligned(@LineS15RBC);
  LineProc[16]:=Unaligned(@LineS16RBC);
  LineProc[17]:=Unaligned(@LineS17RBC);
  LineProc[18]:=Unaligned(@LineS18RBC);
  LineProc[19]:=Unaligned(@LineS19RBC);

  {Left Bottom Corner}
  {-135°..-180°}
  LineProc[20]:=Unaligned(@LineS20   );
  LineProc[21]:=Unaligned(@LineS21LBC);
  LineProc[22]:=Unaligned(@LineS22LBC);
  LineProc[23]:=Unaligned(@LineS23LBC);
  LineProc[24]:=Unaligned(@LineS24LBC);
  LineProc[25]:=Unaligned(@LineS25LBC);
  LineProc[26]:=Unaligned(@LineS26LBC);
  LineProc[27]:=Unaligned(@LineS27LBC);
  LineProc[28]:=Unaligned(@LineS28LBC);
  LineProc[29]:=Unaligned(@LineS29LBC);
  {-90°..-135°}
  LineProc[30]:=Unaligned(@LineS30   );
  LineProc[31]:=Unaligned(@LineS31LBC);
  LineProc[32]:=Unaligned(@LineS32LBC);
  LineProc[33]:=Unaligned(@LineS33LBC);
  LineProc[34]:=Unaligned(@LineS34LBC);
  LineProc[35]:=Unaligned(@LineS35LBC);
  LineProc[36]:=Unaligned(@LineS36LBC);
  LineProc[37]:=Unaligned(@LineS37LBC);
  LineProc[38]:=Unaligned(@LineS38LBC);
  LineProc[39]:=Unaligned(@LineS39LBC);

end; {$endregion}

{THE EXTREMELY FAST LINE ALGORITHM Variation E (Addition Fixed Point PreCalc) by Po-Han Lin on C++} {$region -fold}
(*
void myLine(SURFACE* surface, int x, int y, int x2, int y2) {
  bool yLonger=false;
  int shortLen=y2-y;
  int longLen=x2-x;
  if (abs(shortLen)>abs(longLen)) {
  	int swap=shortLen;
  	shortLen=longLen;
  	longLen=swap;
  	yLonger=true;
  }
  int decInc;
  if (longLen==0) decInc=0;
  else decInc = (shortLen << 16) / longLen;

  if (yLonger) {
  	if (longLen>0) {
  		longLen+=y;
  		for (int j=0x8000+(x<<16);y<=longLen;++y) {
  			myPixel(surface,j >> 16,y);
  			j+=decInc;
  		}
  		return;
  	}
  	longLen+=y;
  	for (int j=0x8000+(x<<16);y>=longLen;--y) {
  		myPixel(surface,j >> 16,y);
  		j-=decInc;
  	}
  	return;
  }

  if (longLen>0) {
	longLen+=x;
	for (int j=0x8000+(y<<16);x<=longLen;++x) {
		myPixel(surface,x,j >> 16);
		j+=decInc;
	}
	return;
  }
  longLen+=x;
  for (int j=0x8000+(y<<16);x>=longLen;--x) {
	myPixel(surface,x,j >> 16);
	j-=decInc;
  }

}
*) {$endregion}

// (Move Points) Перемещение точек:
procedure TFastLine.LinePHL00; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p0_shift                        : integer;
  i,short_len,long_len,swp,dec_inc: integer;
  yLonger                         : boolean;
begin

  yLonger  :=False;
  short_len:=p1-p0;
  long_len :=r1-r0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
    end;

  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);

  if (yLonger) then
    begin
      if (long_len>0) then
        begin
	  long_len+=p0;
          i:=$8000+(r0<<16);
          p0_shift:=p0*ln_arr_width;
          while (p0<=long_len) do
            begin
              ln_arr0[(i>>16)+p0_shift]:=1;
	      i+=dec_inc;
              Inc(p0);
              Inc(p0_shift,ln_arr_width);
            end;
          Exit;
        end;
      long_len+=p0;
      i:=$8000+(r0<<16);
      p0_shift:=p0*ln_arr_width;
      while (p0>=long_len) do
        begin
          ln_arr0[(i>>16)+p0_shift]:=1;
          i-=dec_inc;
          Dec(p0);
          Dec(p0_shift,ln_arr_width);
        end;
      Exit;
    end;

  if (long_len>0) then
    begin
      long_len+=r0;
      i:=$8000+(p0<<16);
      while (r0<=long_len) do
        begin
          ln_arr0[r0+(i>>16)*ln_arr_width]:=1;
          i+=dec_inc;
          Inc(r0);
        end;
      Exit;
    end;

  long_len+=r0;
  i:=$8000+(p0<<16);
  while (r0>=long_len) do
    begin
      ln_arr0[r0+(i>>16)*ln_arr_width]:=1;
      i-=dec_inc;
      Dec(r0);
    end;

end; {$endregion}
procedure TFastLine.LinePHL01; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p0_shift                        : integer;
  i,short_len,long_len,swp,dec_inc: integer;
  clip_shift                      : integer=0;
  yLonger                         : boolean;
begin

  yLonger  :=False;
  short_len:=p1-p0;
  long_len :=r1-r0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
      if (pix_cnt>short_len) then
        Exit;
    end
  else
    if (pix_cnt>long_len) then
      Exit;

  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);

  if (yLonger) then
    begin
      if (long_len>0) then
        begin
	  long_len+=p0;
          i:=$8000+(r0<<16);
          p0_shift:=p0*ln_arr_width;
          while (p0<=long_len) or (clip_shift=pix_cnt) do
            begin
              Inc(clip_shift);
              ln_arr0[(i>>16)+p0_shift]:=1;
	      i+=dec_inc;
              Inc(p0);
              Inc(p0_shift,ln_arr_width);
            end;
          Exit;
        end;
      long_len+=p0;
      i:=$8000+(r0<<16);
      p0_shift:=p0*ln_arr_width;
      while (p0>=long_len) or (clip_shift=pix_cnt) do
        begin
          Inc(clip_shift);
          ln_arr0[(i>>16)+p0_shift]:=1;
          i-=dec_inc;
          Dec(p0);
          Dec(p0_shift,ln_arr_width);
        end;
      Exit;
    end;

  if (long_len>0) then
    begin

      long_len+=r0;
      i:=$8000+(p0<<16);
      while (r0<=long_len) or (clip_shift=pix_cnt) do
        begin
          Inc(clip_shift);
          ln_arr0[r0+(i>>16)*ln_arr_width]:=1;
          i+=dec_inc;
          Inc(r0);
        end;
      Exit;
    end;

  long_len+=r0;
  i:=$8000+(p0<<16);
  while (r0>=long_len) or (clip_shift=pix_cnt) do
    begin
      Inc(clip_shift);
      ln_arr0[r0+(i>>16)*ln_arr_width]:=1;
      i-=dec_inc;
      Dec(r0);
    end;

end; {$endregion}
procedure TFastLine.LinePHL02; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p0_shift                        : integer;
  i,short_len,long_len,swp,dec_inc: integer;
  yLonger                         : boolean;
begin

  yLonger  :=False;
  short_len:=p1-p0;
  long_len :=r1-r0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
    end;

  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);

  if (yLonger) then
    begin
      if (long_len>0) then
        begin
	  long_len+=p0;
          i:=$8000+(r0<<16);
          p0_shift:=p0*ln_arr_width{<<10};
          while (p0<=long_len) do
            begin
              ln_arr0[(i>>16)+p0_shift]+=1;
	      i+=dec_inc;
              Inc(p0);
              Inc(p0_shift,ln_arr_width{ONE_MUL_1024});
            end;
          Exit;
        end;
      long_len+=p0;
      i:=$8000+(r0<<16);
      p0_shift:=p0*ln_arr_width{<<10};
      while (p0>=long_len) do
        begin
          ln_arr0[(i>>16)+p0_shift]+=1;
          i-=dec_inc;
          Dec(p0);
          Dec(p0_shift,ln_arr_width{ONE_MUL_1024});
        end;
      Exit;
    end;

  if (long_len>0) then
    begin
      long_len+=r0;
      i:=$8000+(p0<<16);
      while (r0<=long_len) do
        begin
          ln_arr0[r0+(i>>16)*ln_arr_width{<<10}]+=1;
          i+=dec_inc;
          Inc(r0);
        end;
      Exit;
    end;

  long_len+=r0;
  i:=$8000+(p0<<16);
  while (r0>=long_len) do
    begin
      ln_arr0[r0+(i>>16)*ln_arr_width{<<10}]+=1;
      i-=dec_inc;
      Dec(r0);
    end;

end; {$endregion}

// (Select Points) Выделение точек:
procedure TFastLine.LinePHL10; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_arr1_ptr2                    : PInteger;
  i,short_len,long_len,swp,dec_inc: integer;
  yLonger                         : boolean;
begin

  yLonger  :=False;
  short_len:=p1-p0;
  long_len :=r1-r0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
    end;

  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);

  if (yLonger) then
    begin
      if (long_len>0) then
        begin
	  long_len+=p0;
          i:=$8000+(r0<<16);
          ln_arr1_ptr2:=ln_arr1_ptr+p0*ln_arr_width;
          Prefetch(ln_arr1_ptr2);
          while (p0<=long_len) do
            begin
              ((i>>16)+ln_arr1_ptr2)^-=1;
	      i+=dec_inc;
              Inc(p0);
              Inc(ln_arr1_ptr2,ln_arr_width);
            end;
          Exit;
        end;
      long_len+=p0;
      i:=$8000+(r0<<16);
      ln_arr1_ptr2:=ln_arr1_ptr+p0*ln_arr_width;
      Prefetch(ln_arr1_ptr2);
      while (p0>=long_len) do
        begin
          ((i>>16)+ln_arr1_ptr2)^-=1;
          i-=dec_inc;
          Dec(p0);
          Dec(ln_arr1_ptr2,ln_arr_width);
        end;
      Exit;
    end;

  if (long_len>0) then
    begin
      long_len+=r0;
      i:=$8000+(p0<<16);
      Prefetch(ln_arr1_ptr);
      while (r0<=long_len) do
        begin
          (ln_arr1_ptr+r0+(i>>16)*ln_arr_width)^-=1;
          i+=dec_inc;
          Inc(r0);
        end;
      Exit;
    end;

  long_len+=r0;
  i:=$8000+(p0<<16);
  Prefetch(ln_arr1_ptr);
  while (r0>=long_len) do
    begin
      (ln_arr1_ptr+r0+(i>>16)*ln_arr_width)^-=1;
      i-=dec_inc;
      Dec(r0);
    end;

end; {$endregion}
procedure TFastLine.LinePHL11; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_arr1_ptr2                    : PInteger;
  i,short_len,long_len,swp,dec_inc: integer;
  clip_shift                      : integer=0;
  yLonger                         : boolean;
begin

  yLonger  :=False;
  short_len:=p1-p0;
  long_len :=r1-r0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
      if (pix_cnt>short_len) then
        Exit;
    end
  else
    if (pix_cnt>long_len) then
      Exit;

  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);

  if (yLonger) then
    begin
      if (long_len>0) then
        begin
	  long_len+=p0;
          i:=$8000+(r0<<16);
          ln_arr1_ptr2:=ln_arr1_ptr+p0*ln_arr_width;
          Prefetch(ln_arr1_ptr2);
          while (p0<=long_len) or (clip_shift=pix_cnt) do
            begin
              Inc(clip_shift);
              ((i>>16)+ln_arr1_ptr2)^-=1;
	      i+=dec_inc;
              Inc(p0);
              Inc(ln_arr1_ptr2,ln_arr_width);
            end;
          Exit;
        end;
      long_len+=p0;
      i:=$8000+(r0<<16);
      ln_arr1_ptr2:=ln_arr1_ptr+p0*ln_arr_width;
      Prefetch(ln_arr1_ptr2);
      while (p0>=long_len) or (clip_shift=pix_cnt) do
        begin
          Inc(clip_shift);
          ((i>>16)+ln_arr1_ptr2)^-=1;
          i-=dec_inc;
          Dec(p0);
          Dec(ln_arr1_ptr2,ln_arr_width);
        end;
      Exit;
    end;

  if (long_len>0) then
    begin
      long_len+=r0;
      i:=$8000+(p0<<16);
      Prefetch(ln_arr1_ptr);
      while (r0<=long_len) or (clip_shift=pix_cnt) do
        begin
          Inc(clip_shift);
          (ln_arr1_ptr+r0+(i>>16)*ln_arr_width)^-=1;
          i+=dec_inc;
          Inc(r0);
        end;
      Exit;
    end;

  long_len+=r0;
  i:=$8000+(p0<<16);
  Prefetch(ln_arr1_ptr);
  while (r0>=long_len) or (clip_shift=pix_cnt) do
    begin
      Inc(clip_shift);
      (ln_arr1_ptr+r0+(i>>16)*ln_arr_width)^-=1;
      i-=dec_inc;
      Dec(r0);
    end;

end; {$endregion}

// (Unselect Points) Снятие выделения точек:
procedure TFastLine.LinePHL20; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_arr1_ptr2                    : PInteger;
  i,short_len,long_len,swp,dec_inc: integer;
  yLonger                         : boolean;
begin

  yLonger  :=False;
  short_len:=p1-p0;
  long_len :=r1-r0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
    end;

  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);

  if (yLonger) then
    begin
      if (long_len>0) then
        begin
	  long_len+=p0;
          i:=$8000+(r0<<16);
          ln_arr1_ptr2:=ln_arr1_ptr+p0*ln_arr_width;
          while (p0<=long_len) do
            begin
              ((i>>16)+ln_arr1_ptr2)^+=1;
	      i+=dec_inc;
              Inc(p0);
              Inc(ln_arr1_ptr2,ln_arr_width);
            end;
          Exit;
        end;
      long_len+=p0;
      i:=$8000+(r0<<16);
      ln_arr1_ptr2:=ln_arr1_ptr+p0*ln_arr_width;
      while (p0>=long_len) do
        begin
          ((i>>16)+ln_arr1_ptr2)^+=1;
          i-=dec_inc;
          Dec(p0);
          Dec(ln_arr1_ptr2,ln_arr_width);
        end;
      Exit;
    end;

  if (long_len>0) then
    begin
      long_len+=r0;
      i:=$8000+(p0<<16);
      while (r0<=long_len) do
        begin
          (ln_arr1_ptr+r0+(i>>16)*ln_arr_width)^+=1;
          i+=dec_inc;
          Inc(r0);
        end;
      Exit;
    end;

  long_len+=r0;
  i:=$8000+(p0<<16);
  while (r0>=long_len) do
    begin
      (ln_arr1_ptr+r0+(i>>16)*ln_arr_width)^+=1;
      i-=dec_inc;
      Dec(r0);
    end;

end; {$endregion}
procedure TFastLine.LinePHL21; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_arr1_ptr2                    : PInteger;
  i,short_len,long_len,swp,dec_inc: integer;
  clip_shift                      : integer=0;
  yLonger                         : boolean;
begin

  yLonger  :=False;
  short_len:=p1-p0;
  long_len :=r1-r0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
      if (pix_cnt>short_len) then
        Exit;
    end
  else
    if (pix_cnt>long_len) then
      Exit;

  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);

  if (yLonger) then
    begin
      if (long_len>0) then
        begin
	  long_len+=p0;
          i:=$8000+(r0<<16);
          ln_arr1_ptr2:=ln_arr1_ptr+p0*ln_arr_width;
          while (p0<=long_len) or (clip_shift=pix_cnt) do
            begin
              Inc(clip_shift);
              ((i>>16)+ln_arr1_ptr2)^+=1;
	      i+=dec_inc;
              Inc(p0);
              Inc(ln_arr1_ptr2,ln_arr_width);
            end;
          Exit;
        end;
      long_len+=p0;
      i:=$8000+(r0<<16);
      ln_arr1_ptr2:=ln_arr1_ptr+p0*ln_arr_width;
      while (p0>=long_len) or (clip_shift=pix_cnt) do
        begin
          Inc(clip_shift);
          ((i>>16)+ln_arr1_ptr2)^+=1;
          i-=dec_inc;
          Dec(p0);
          Dec(ln_arr1_ptr2,ln_arr_width);
        end;
      Exit;
    end;

  if (long_len>0) then
    begin
      long_len+=r0;
      i:=$8000+(p0<<16);
      while (r0<=long_len) or (clip_shift=pix_cnt) do
        begin
          Inc(clip_shift);
          (ln_arr1_ptr+r0+(i>>16)*ln_arr_width)^+=1;
          i+=dec_inc;
          Inc(r0);
        end;
      Exit;
    end;

  long_len+=r0;
  i:=$8000+(p0<<16);
  while (r0>=long_len) or (clip_shift=pix_cnt) do
    begin
      Inc(clip_shift);
      (ln_arr1_ptr+r0+(i>>16)*ln_arr_width)^+=1;
      i-=dec_inc;
      Dec(r0);
    end;

end; {$endregion}

// (Direct Pixel Write) Непосредственная запись в битовую карту:
procedure TFastLine.LinePHL30; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  bmp_dst_ptr2                    : PInteger;
  i,short_len,long_len,swp,dec_inc: integer;
  yLonger                         : boolean;
begin

  yLonger  :=False;
  short_len:=p1-p0;
  long_len :=r1-r0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
    end;

  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);

  if (yLonger) then
    begin
      if (long_len>0) then
        begin
	  long_len+=p0;
          i:=$8000+(r0<<16);
          bmp_dst_ptr2:=bmp_dst_ptr+p0*bmp_dst_width;
          while (p0<=long_len) do
            begin
              ((i>>16)+bmp_dst_ptr2)^:=local_prop.eds_col_inv;
	      i+=dec_inc;
              Inc(p0);
              Inc(bmp_dst_ptr2,bmp_dst_width);
            end;
          Exit;
        end;
      long_len+=p0;
      i:=$8000+(r0<<16);
      bmp_dst_ptr2:=bmp_dst_ptr+p0*bmp_dst_width;
      while (p0>=long_len) do
        begin
          ((i>>16)+bmp_dst_ptr2)^:=local_prop.eds_col_inv;
          i-=dec_inc;
          Dec(p0);
          Dec(bmp_dst_ptr2,bmp_dst_width);
        end;
      Exit;
    end;

  if (long_len>0) then
    begin
      long_len+=r0;
      i:=$8000+(p0<<16);
      while (r0<=long_len) do
        begin
          (bmp_dst_ptr+r0+(i>>16)*bmp_dst_width)^:=local_prop.eds_col_inv;
          i+=dec_inc;
          Inc(r0);
        end;
      Exit;
    end;

  long_len+=r0;
  i:=$8000+(p0<<16);
  while (r0>=long_len) do
    begin
      (bmp_dst_ptr+r0+(i>>16)*bmp_dst_width)^:=local_prop.eds_col_inv;
      i-=dec_inc;
      Dec(r0);
    end;

end; {$endregion}
procedure TFastLine.LinePHL31; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  bmp_dst_ptr2                    : PInteger;
  i,short_len,long_len,swp,dec_inc: integer;
  clip_shift                      : integer=0;
  yLonger                         : boolean;
begin

  yLonger  :=False;
  short_len:=p1-p0;
  long_len :=r1-r0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
      if (pix_cnt>short_len) then
        Exit;
    end
  else
    if (pix_cnt>long_len) then
      Exit;

  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);

  if (yLonger) then
    begin
      if (long_len>0) then
        begin
	  long_len+=p0;
          i:=$8000+(r0<<16);
          bmp_dst_ptr2:=bmp_dst_ptr+p0*bmp_dst_width;
          //Prefetch(bmp_dst_ptr2);
          while (p0<=long_len) or (clip_shift=pix_cnt) do
            begin
              Inc(clip_shift);
              ((i>>16)+bmp_dst_ptr2)^:=local_prop.eds_col_inv;
	      i+=dec_inc;
              Inc(p0);
              Inc(bmp_dst_ptr2,bmp_dst_width);
            end;
          Exit;
        end;
      long_len+=p0;
      i:=$8000+(r0<<16);
      bmp_dst_ptr2:=bmp_dst_ptr+p0*bmp_dst_width;
      //Prefetch(bmp_dst_ptr2);
      while (p0>=long_len) or (clip_shift=pix_cnt) do
        begin
          Inc(clip_shift);
          ((i>>16)+bmp_dst_ptr2)^:=local_prop.eds_col_inv;
          i-=dec_inc;
          Dec(p0);
          Dec(bmp_dst_ptr2,bmp_dst_width);
        end;
      Exit;
    end;

  if (long_len>0) then
    begin
      long_len+=r0;
      i:=$8000+(p0<<16);
      //Prefetch(bmp_dst_ptr);
      while (r0<=long_len) or (clip_shift=pix_cnt) do
        begin
          Inc(clip_shift);
          (bmp_dst_ptr+r0+(i>>16)*bmp_dst_width)^:=local_prop.eds_col_inv;
          i+=dec_inc;
          Inc(r0);
        end;
      Exit;
    end;

  long_len+=r0;
  i:=$8000+(p0<<16);
  //Prefetch(bmp_dst_ptr);
  while (r0>=long_len) or (clip_shift=pix_cnt) do
    begin
      Inc(clip_shift);
      (bmp_dst_ptr+r0+(i>>16)*bmp_dst_width)^:=local_prop.eds_col_inv;
      i-=dec_inc;
      Dec(r0);
    end;

end; {$endregion}

{Right Bottom Corner}

{0°..-45°}
// 0: out of grid
procedure TFastLine.LineS00;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

end; {$endregion}
// 1: (c_n)
procedure TFastLine.LineS01RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
 {dx+1:=a*c;
  dy+1:=a;}
 {y0-=y1;    // меняем местами координаты по оси y начала и конца линии
  y1+=y0;    // ...
  y0:=y1-y0; // ...
  dy:=-dy;}
  for i:=0 to a-2 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 2: (c_n,c+1)
procedure TFastLine.LineS02RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a:=a*b*c+a*(c+1):=a((b+1)*c+1);
  dy+1:=a*(b+1);
  Если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1), что легко доказать.
  "Пусть a<>НСД(dx+1,dy+1), тогда dy+1:=a*r*v1, dx+1:=a*r*v2=a*(r*v1*c+1), что невозможно."}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 3: ((c+1)_n,c)
procedure TFastLine.LineS03RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*b:=a*c+a*b*(c+1):=a((b+1)*c+b);
  dy+1:=a*(b+1);
  Очевидно, что если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1)}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 4: ((c,c+1)_n,c+1)
procedure TFastLine.LineS04RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*(b+1):=a*b*c+a*(b+1)*(c+1):=a((2*b+1)*c+b+1);
  dy+1:=a*(2*b+1);
  Очевидно, что если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1)}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 5: ((c,c+1)_n,c)
procedure TFastLine.LineS05RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*b:=a*(b+1)*c+a*b*(c+1):=a((2*b+1)*c+b);
  dy+1:=a*(2*b+1);
  Очевидно, что если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1)}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 6: ((c,c+1,c)_n,c+1)
procedure TFastLine.LineS06RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*(b+1):=a*2*b*c+a*(b+1)*(c+1):=a((3*b+1)*c+b+1);
  dy+1:=a*(3*b+1);
  Очевидно, что если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1)}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 7: ((c,c+1,c)_n,c)
procedure TFastLine.LineS07RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*(b+1):=a*(2*b+1)*c+a*b*(c+1):=a((3*b+1)*c+b);
  dy+1:=a*(3*b+1);
  Очевидно, что если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1)}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 8: ((c,c+1,c+1)_n,c+1)
procedure TFastLine.LineS08RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*(b+1):=a*b*c+a*(2*b+1)*(c+1):=a((3*b+1)*c+2*b+1);
  dy+1:=a*(3*b+1);
  Очевидно, что если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1)}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 9: ((c+1,c,c+1)_n,c)
procedure TFastLine.LineS09RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*(b+1):=a*(b+1)*c+a*2*b*(c+1):=a((3*b+1)*c+2*b);
  dy+1:=a*(3*b+1);
  Очевидно, что если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1)}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
{-45°..-90°}
// 10: out of grid
procedure TFastLine.LineS10;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

end; {$endregion}
// 11: (c_n)
procedure TFastLine.LineS11RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to a-1 do
    FillByte(ln_arr2[p0+i+g,r0+i*c-g],c,1);
end; {$endregion}
// 12: (c_n,c+1)
procedure TFastLine.LineS12RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        FillByte(ln_arr2[p0+i*(b+1)+j+g,r0+i*((b+1)*c+1)+c*j-g],c,1);
      FillByte(ln_arr2[p0+i*(b+1)+b+g,r0+i*((b+1)*c+1)+c*b-g],c+1,1);
    end;
end; {$endregion}
// 13: ((c+1)_n,c)
procedure TFastLine.LineS13RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        FillByte(ln_arr2[p0+i*(b+1)+j+g,r0+i*((b+1)*(c+1)-1)+(c+1)*j-g],c+1,1);
      FillByte(ln_arr2[p0+i*(b+1)+b+g,r0+i*((b+1)*(c+1)-1)+(c+1)*b-g],c,1);
    end;
end; {$endregion}
// 14: ((c,c+1)_n,c+1)
procedure TFastLine.LineS14RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+(2*b+1)*i+2*j  +g,r0+(b*(2*c+1)+c+1)*i+(2*c+1)*j  -g],c,1);
          FillByte(ln_arr2[p0+(2*b+1)*i+2*j+1+g,r0+(b*(2*c+1)+c+1)*i+(2*c+1)*j+c-g],c+1,1);
        end;
      FillByte(ln_arr2[p0+(2*b+1)*i+2*b+g,r0+(b*(2*c+1)+c+1)*i+(2*c+1)*b-g],c+1,1);
    end;
end; {$endregion}
// 15: ((c,c+1)_n,c)
procedure TFastLine.LineS15RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+(2*b+1)*i+2*j  +g,r0+(b*(2*c+1)+c)*i+(2*c+1)*j  -g],c,1);
          FillByte(ln_arr2[p0+(2*b+1)*i+2*j+1+g,r0+(b*(2*c+1)+c)*i+(2*c+1)*j+c-g],c+1,1);
        end;
      FillByte(ln_arr2[p0+(2*b+1)*i+2*b+g,r0+(b*(2*c+1)+c)*i+(2*c+1)*b-g],c,1);
    end;
end; {$endregion}
// 16: ((c,c+1,c)_n,c+1)
procedure TFastLine.LineS16RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j  +g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*j      -g],c  ,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+1+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*j+c    -g],c+1,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+2+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*j+2*c+1-g],c  ,1);
        end;
      FillByte(ln_arr2[p0+(3*b+1)*i+3*b+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*b-g],c+1,1);
    end;
end; {$endregion}
// 17: ((c,c+1,c)_n,c)
procedure TFastLine.LineS17RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j  +g,r0+(b*(3*c+1)+c)*i+(3*c+1)*j      -g],c  ,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+1+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*j+c    -g],c+1,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+2+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*j+2*c+1-g],c  ,1);
        end;
      FillByte(ln_arr2[p0+(3*b+1)*i+3*b+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*b-g],c,1);
    end;
end; {$endregion}
// 18: ((c,c+1,c+1)_n,c+1)
procedure TFastLine.LineS18RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j  +g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*j      -g],c  ,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+1+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*j+c    -g],c+1,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+2+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*j+2*c+1-g],c+1,1);
        end;
      FillByte(ln_arr2[p0+(3*b+1)*i+3*b+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*b-g],c+1,1);
    end;
end; {$endregion}
// 19: ((c+1,c,c+1)_n,c)
procedure TFastLine.LineS19RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j  +g,r0+(b*(3*c+2)+c)*i+(3*c+2)*j      -g],c+1,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+1+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*j+c+1  -g],c,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+2+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*j+2*c+1-g],c+1,1);
        end;
      FillByte(ln_arr2[p0+(3*b+1)*i+3*b+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*b-g],c,1);
    end;
end; {$endregion}

{Left Bottom Corner}

{-135°..-180°}
// 20: out of grid
procedure TFastLine.LineS20;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

end; {$endregion}
// 21: (c_n)
procedure TFastLine.LineS21LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 22: (c_n,c+1)
procedure TFastLine.LineS22LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-2 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-2 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 23: ((c+1)_n,c)
procedure TFastLine.LineS23LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-2 do
        begin
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  for j:=0 to b-2 do
    begin
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m1);
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 24: ((c,c+1)_n,c+1)
procedure TFastLine.LineS24LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-2 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-2 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 25: ((c,c+1)_n,c)
procedure TFastLine.LineS25LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 26: ((c,c+1,c)_n,c+1)
procedure TFastLine.LineS26LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-2 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-2 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m1);
  FillByte(ln_arr0_ptr^,c,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 27: ((c,c+1,c)_n,c)
procedure TFastLine.LineS27LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 28: ((c,c+1,c+1)_n,c+1)
procedure TFastLine.LineS28LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-2 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-2 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 29: ((c+1,c,c+1)_n,c)
procedure TFastLine.LineS29LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-2 do
        begin
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  for j:=0 to b-2 do
    begin
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m1);
  FillByte(ln_arr0_ptr^,c,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m1);
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
{-90°..-135°}
// 30: out of grid
procedure TFastLine.LineS30;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

end; {$endregion}
// 31: (c_n)
procedure TFastLine.LineS31LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to a-1 do
    FillByte(ln_arr2[p0-i+g,r0+i*c-g],c,1);
end; {$endregion}
// 32: (c_n,c+1)
procedure TFastLine.LineS32LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        FillByte(ln_arr2[p0-i*(b+1)-j+g,r0+i*((b+1)*c+1)+c*j-g],c,1);
      FillByte(ln_arr2[p0-i*(b+1)-b+g,r0+i*((b+1)*c+1)+c*b-g],c+1,1);
    end;
end; {$endregion}
// 33: ((c+1)_n,c)
procedure TFastLine.LineS33LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        FillByte(ln_arr2[p0-i*(b+1)-j+g,r0+i*((b+1)*(c+1)-1)+(c+1)*j-g],c+1,1);
      FillByte(ln_arr2[p0-i*(b+1)-b+g,r0+i*((b+1)*(c+1)-1)+(c+1)*b-g],c,1);
    end;
end; {$endregion}
// 34: ((c,c+1)_n,c+1)
procedure TFastLine.LineS34LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0-(2*b+1)*i-2*j  +g,r0+(b*(2*c+1)+c+1)*i+(2*c+1)*j  -g],c  ,1);
          FillByte(ln_arr2[p0-(2*b+1)*i-2*j-1+g,r0+(b*(2*c+1)+c+1)*i+(2*c+1)*j+c-g],c+1,1);
        end;
      FillByte(ln_arr2[p0-(2*b+1)*i-2*b+g,r0+(b*(2*c+1)+c+1)*i+(2*c+1)*b-g],c+1,1);
    end;
end; {$endregion}
// 35: ((c,c+1)_n,c)
procedure TFastLine.LineS35LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0-(2*b+1)*i-2*j  +g,r0+(b*(2*c+1)+c)*i+(2*c+1)*j  -g],c  ,1);
          FillByte(ln_arr2[p0-(2*b+1)*i-2*j-1+g,r0+(b*(2*c+1)+c)*i+(2*c+1)*j+c-g],c+1,1);
        end;
      FillByte(ln_arr2[p0-(2*b+1)*i-2*b+g,r0+(b*(2*c+1)+c)*i+(2*c+1)*b-g],c,1);
    end;
end; {$endregion}
// 36: ((c,c+1,c)_n,c+1)
procedure TFastLine.LineS36LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j  +g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*j      -g],c  ,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-1+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*j+c    -g],c+1,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-2+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*j+2*c+1-g],c  ,1);
        end;
      FillByte(ln_arr2[p0-(3*b+1)*i-3*b+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*b-g],c+1,1);
    end;
end; {$endregion}
// 37: ((c,c+1,c)_n,c)
procedure TFastLine.LineS37LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j  +g,r0+(b*(3*c+1)+c)*i+(3*c+1)*j      -g],c  ,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-1+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*j+c    -g],c+1,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-2+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*j+2*c+1-g],c  ,1);
        end;
      FillByte(ln_arr2[p0-(3*b+1)*i-3*b+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*b-g],c,1);
    end;
end; {$endregion}
// 38: ((c,c+1,c+1)_n,c+1)
procedure TFastLine.LineS38LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j  +g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*j      -g],c  ,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-1+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*j+c    -g],c+1,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-2+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*j+2*c+1-g],c+1,1);
        end;
      FillByte(ln_arr2[p0-(3*b+1)*i-3*b+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*b-g],c+1,1);
    end;
end; {$endregion}
// 39: ((c+1,c,c+1)_n,c)
procedure TFastLine.LineS39LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j  +g,r0+(b*(3*c+2)+c)*i+(3*c+2)*j      -g],c+1,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-1+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*j+c+1  -g],c  ,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-2+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*j+2*c+1-g],c+1,1);
        end;
      FillByte(ln_arr2[p0-(3*b+1)*i-3*b+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*b-g],c,1);
    end;
end; {$endregion}

// (Solid Line Drawing) Рисование сплошной линии:
procedure TFastLine.LineSMN(constref x0,y0,x1,y1:integer);                                                         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {адрес n-ого элемента
   статического массива array[min..max] of type
   вычисляется по формуле array_addr+(n-min)*sizeof(type);
   адрес n-ого элемента
   динамического массива array of type
   вычисляется по формуле array_addr+n*sizeof(type);}
  dx:=x1-x0;
  dy:=y1-y0;
  if (Abs(dy)<<9<Abs(dx)*229) then
    begin
      if (dy>0) then {$region -fold}
        begin
          ln_kind_ptr:=Unaligned(@gcd_arr[Abs(dx)+dy*ln_arr_width].f_ln_kind);
          if (ln_kind_ptr^=0) or (ln_kind_ptr^=10) then
            begin
              if (dx<0) then
                begin
                  r0:=x1;
                  p0:=y1;
                  r1:=x0;
                  p1:=y0;
                end
              else
                begin
                  r0:=x0;
                  p0:=y0;
                  r1:=x1;
                  p1:=y1;
                end;
              LinePHL02;
              Exit;
            end
          else
            begin
              ln_arr0_ptr:=Unaligned(@ln_arr0[x0+y0*ln_arr_width]);
              a:=(ln_kind_ptr+1)^;
              b:=(ln_kind_ptr+2)^;
              c:=(ln_kind_ptr+3)^;
              {0°..-45°}
              if (dx>0) then
                begin
                  m1:=ln_arr_width+c+0;
                  m2:=ln_arr_width+c+1;
                  LineProc[ln_kind_ptr^];
                  Exit;
                end;
              {-135°..-180°}
              if (dx<0) then
                begin
                  m1:=ln_arr_width-c-0;
                  m2:=ln_arr_width-c-1;
                  LineProc[ln_kind_ptr^+20];
                  Exit;
                end;
            end;
        end; {$endregion}
      if (dy<0) then {$region -fold}
        begin
          ln_kind_ptr:=Unaligned(@gcd_arr[Abs(dx)-dy*ln_arr_width].f_ln_kind);
          if (ln_kind_ptr^=0) or (ln_kind_ptr^=10) then
            begin
              if (dx<0) then
                begin
                  r0:=x1;
                  p0:=y1;
                  r1:=x0;
                  p1:=y0;
                end
              else
                begin
                  r0:=x0;
                  p0:=y0;
                  r1:=x1;
                  p1:=y1;
                end;
              LinePHL02;
              Exit;
            end
          else
            begin
              ln_arr0_ptr:=Unaligned(@ln_arr0[x1+y1*ln_arr_width]);
              a:=(ln_kind_ptr+1)^;
              b:=(ln_kind_ptr+2)^;
              c:=(ln_kind_ptr+3)^;
              {-180°..-225°}
              if (dx<0) then
                begin
                  m1:=ln_arr_width+c+0;
                  m2:=ln_arr_width+c+1;
                  LineProc[ln_kind_ptr^];
                  Exit;
                end;
              {-315°..-360°}
              if (dx>0) then
                begin
                  m1:=ln_arr_width-c-0;
                  m2:=ln_arr_width-c-1;
                  LineProc[ln_kind_ptr^+20];
                  Exit;
                end;
            end;
        end; {$endregion}
      {Horizontal Line}
      if (dy=0) then {$region -fold}
        begin
          if (dx>0) then
            FillByte(ln_arr0[x0+y0*ln_arr_width],1+dx,1)
          else
            FillByte(ln_arr0[x1+y1*ln_arr_width],1-dx,1);
          Exit;
        end; {$endregion}
    end
  else
  if (Abs(dx)<<9<Abs(dy)*229) then
    begin
      if (dy>0) then {$region -fold}
        begin
          ln_kind_ptr:=Unaligned(@gcd_arr[Abs(dx)+dy*ln_arr_width].f_ln_kind);
          if (ln_kind_ptr^=0) or (ln_kind_ptr^=10) then
            begin
              if (dx<0) then
                begin
                  r0:=x1;
                  p0:=y1;
                  r1:=x0;
                  p1:=y0;
                end
              else
                begin
                  r0:=x0;
                  p0:=y0;
                  r1:=x1;
                  p1:=y1;
                end;
              LinePHL02;
              Exit;
            end
          else
            begin
              a:=(ln_kind_ptr+1)^;
              b:=(ln_kind_ptr+2)^;
              c:=(ln_kind_ptr+3)^;
              {-45°..-90°}
              if (dx>0) then
                begin
                  r0:=x0;
                  p0:=y0;
                  g:=r0-p0;
                  LineProc[ln_kind_ptr^];
                  Exit;
                end;
              {-90°..-135°}
              if (dx<0) then
                begin
                  r0:=x0;
                  p0:=y0;
                  g:=r0-p0;
                  LineProc[ln_kind_ptr^+20];
                  Exit;
                end;
              {Vertical Line Down}
              if (dx=0) then
                begin
                  FillByte(ln_arr2[x0,y0],dy,1);
                  Exit;
                end;
            end;
        end; {$endregion}
      if (dy<0) then {$region -fold}
        begin
          ln_kind_ptr:=Unaligned(@gcd_arr[Abs(dx)-dy*ln_arr_width].f_ln_kind);
          if (ln_kind_ptr^=0) or (ln_kind_ptr^=10) then
            begin
              if (dx<0) then
                begin
                  r0:=x1;
                  p0:=y1;
                  r1:=x0;
                  p1:=y0;
                end
              else
                begin
                  r0:=x0;
                  p0:=y0;
                  r1:=x1;
                  p1:=y1;
                end;
              LinePHL02;
              Exit;
            end
          else
            begin
              a:=(ln_kind_ptr+1)^;
              b:=(ln_kind_ptr+2)^;
              c:=(ln_kind_ptr+3)^;
              {-225°..-270°}
              if (dx<0) then
                begin
                  r0:=y1;
                  p0:=x1;
                  g :=0;
                  LineProc[ln_kind_ptr^];
                  Exit;
                end;
              {-270°..-315°}
              if (dx>0) then
                begin
                  r0:=y1;
                  p0:=x1;
                  g :=0;
                  LineProc[ln_kind_ptr^+20];
                  Exit;
                end;
              {Vertical Line Up}
              if (dx=0) then
                begin
                  FillByte(ln_arr2[x1,y1],-dy,1);
                  Exit;
                end;
            end;
        end; {$endregion}
    end
  else {$region -fold}
    begin
      if (dx<0) then
        begin
          r0:=x1;
          p0:=y1;
          r1:=x0;
          p1:=y0;
        end
      else
        begin
          r0:=x0;
          p0:=y0;
          r1:=x1;
          p1:=y1;
        end;
      LinePHL02;
      Exit;
    end; {$endregion}
end; {$endregion}
procedure TFastLine.LineSME(constref x0,y0,x1,y1:integer; constref proc_ptr_a:TProc0; constref proc_ptr_b:TProc0); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  LineSMN(x0,y0,x1,y1);
end; {$endregion}
procedure TFastLine.LinePHL(constref x0,y0,x1,y1:integer; constref proc_ptr_a:TProc0; constref proc_ptr_b:TProc0); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (x1<x0) then
    begin
      r0:=x1;
      p0:=y1;
      r1:=x0;
      p1:=y0;
    end
  else
    begin
      r0:=x0;
      p0:=y0;
      r1:=x1;
      p1:=y1;
    end;
  if (y1<>y0) then
    proc_ptr_a
  else
    proc_ptr_b;
end; {$endregion}

// Fast Line Solid Horizontal(Width - 1 pixel):
procedure TFastLine.LineSHL00; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (r1>r0) then
    begin
      FillByte(ln_arr0[r0+p0*ln_arr_width],r1-r0+1,1);
      Exit;
    end
  else
    begin
      FillByte(ln_arr0[r1+p0*ln_arr_width],r0-r1+1,1);
      Exit;
    end;
end; {$endregion}
procedure TFastLine.LineSHL10; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PInteger;
  i       : integer;
begin
  f_ln_ptr:=Unaligned(@ln_arr1_ptr[r0+p0*ln_arr_width]);
  for i:=0 to r1-r0 do
    (f_ln_ptr+i)^-=1;
end; {$endregion}
procedure TFastLine.LineSHL20; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PInteger;
  i       : integer;
begin
  f_ln_ptr:=Unaligned(@ln_arr1_ptr[r0+p0*ln_arr_width]);
  for i:=0 to r1-r0 do
    (f_ln_ptr+i)^+=1;
end; {$endregion}
procedure TFastLine.LineSHL30; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FillDWord((bmp_dst_ptr+r0+p0*bmp_dst_width)^,r1-r0+1,local_prop.eds_col_inv);
end; {$endregion}

// Fast Line Solid Vertical(Width - 1 pixel):
procedure TFastLine.LineSVL00; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (p1>p0) then
    begin
      FillByte(ln_arr2[r0,p0],p1-p0,1);
      Exit;
    end
  else
    begin
      FillByte(ln_arr2[r0,p1],p0-p1,1);
      Exit;
    end;
end; {$endregion}
procedure TFastLine.LineSVL10; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PInteger;
  i       : integer;
begin
  f_ln_ptr:=Unaligned(@ln_arr1_ptr[r0+p0*ln_arr_width]);
  for i:=0 to p1-p0 do
    begin
      f_ln_ptr^-=1;
      Inc(f_ln_ptr,ln_arr_width);
    end;
end; {$endregion}
procedure TFastLine.LineSVL20; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PInteger;
  i       : integer;
begin
  f_ln_ptr:=Unaligned(@ln_arr1_ptr[r0+p0*ln_arr_width]);
  for i:=0 to p1-p0 do
    begin
      f_ln_ptr^+=1;
      Inc(f_ln_ptr,ln_arr_width);
    end;
end; {$endregion}
procedure TFastLine.LineSVL30; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PInteger;
  i       : integer;
begin
  f_ln_ptr:=bmp_dst_ptr+r0+p0*bmp_dst_width;
  for i:=0 to p1-p0 do
    begin
      f_ln_ptr^:=local_prop.eds_col_inv;
      Inc(f_ln_ptr,bmp_dst_width);
    end;
end; {$endregion}

{Fast Line Clipping}

// Sobkow-Pospisil-Yang Algorithm:
procedure TFastLine.ClippedLine1(x0,y0,x1,y1:integer; const rct_clp:TPtRect; constref proc1:TProc3; constref proc2:TProc0; constref proc3:TProc0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_code: integer{byte}=0;

  procedure ClipLine    (                            var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    proc1(v0,w0,v1,w1,proc2,proc3);
  end; {$endregion}
  procedure Clip0_Left  (const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    w0+=Trunc(((w1-w0)*(custom_rect2.left-v0))/(v1-v0));
    v0:=custom_rect2.left;
  end; {$endregion}
  procedure Clip0_Top   (const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // inline induces SIGFPE ERROR in outer procedure
  begin
    v0+=Trunc(((v1-v0)*(custom_rect2.bottom-w0))/(w1-w0));
    w0:=custom_rect2.bottom;
  end; {$endregion}
  procedure Clip0_Right (const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    w0+=Trunc(((w1-w0)*(custom_rect2.right-v0))/(v1-v0));
    v0:=custom_rect2.right;
  end; {$endregion}
  procedure Clip0_Bottom(const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    v0+=Trunc(((v1-v0)*(custom_rect2.top-w0))/(w1-w0));
    w0:=custom_rect2.top;
  end; {$endregion}
  procedure Clip1_Left  (const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    w1+=Trunc(((w0-w1)*(custom_rect2.left-v1))/(v0-v1));
    v1:=custom_rect2.left;
  end; {$endregion}
  procedure Clip1_Top   (const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    v1+=Trunc(((v0-v1)*(custom_rect2.bottom-w1))/(w0-w1));
    w1:=custom_rect2.bottom;
  end; {$endregion}
  procedure Clip1_Right (const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    w1+=Trunc(((w0-w1)*(custom_rect2.right-v1))/(v0-v1));
    v1:=custom_rect2.right;
  end; {$endregion}
  procedure Clip1_Bottom(const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    v1+=Trunc(((v0-v1)*(custom_rect2.top-w1))/(w0-w1));
    w1:=custom_rect2.top;
  end; {$endregion}

begin
  {$region -fold}
  {Fast Clipping Algorithm}

   (*
    Алгоритм быстрого отсечения FC(Fast Clipping) Собкова-Поспишила-Янга
  (Sobkow-Pospisil-Yang), с кодированием линий. Отсекает отрезок, заданный
  координатами его точек (x0,y0), (x1,y1), по окну custom_rect.
    * Clip0_A - перемещение начальной точки (x0,y0) в точку пересечения отрезка
  со стороной A;
    * Clip1_A - перемещение конечной точки (x1,y1) в точку пересечения отрезка
  со стороной A;
    Схема кодирования концов отрезков:

                          1001    |  1000   |  1010
                                  |         |
                           0x9    |   0x8   |   0xA
                          _ _ _ _1| _ _ _ _2| _ _ _ _3
                                  |         |
                          0001    |  0000   |  0010
                                  |         |
                           0x1    |   0x0   |   0x2
                          _ _ _ _4| _ _ _ _5| _ _ _ _6
                                  |         |
                          0101    |  0100   |  0110
                                  |         |
                           0x5    |   0x4   |   0x6
                                 7|        8|        9

    Отрезок видим только в области 5, т.е. отрезок, координаты которого
  удовлетворяют условиям:

        Rect.Left < X < Rect.Right    и    Rect.Bottom < Y < Rect.Top,

  но поскольку в Lazarus-е координата Y отсчитывается от верхнего левого
  угла, то последнее неравенство перепишем как

                         Rect.Bottom > Y > Rect.Top,

  (Это обстоятельство также учтено в коде подпрограммы!!!)
    Каждая конечная точка отрезка V0V1 окажется с одной из этих областей.
  Комбинация кодов концов отрезка, называемая кодом линии, используется для
  определения возможных вариантов расположения отрезка и, следовательно,
  отсечения. Код линии формируется из кодов концов отрезка следующим образом:

                 LineCode(V0,V1) = (Code(V0) × 16) + Code(V1),

  здесь Code(V1) обозначает код конечной точки V1, Code(V0) × 16 означает сдвиг
  кода начальной точки V0 влево на 4 разряда.
    Так как каждый код может принимать одно из 9 значений, то всего имеется
  81 возможный вариант расположения отрезка.
   *)

  {Вычисление значения Code - кода отрезка.
  Биты 0-3 - для конечной точки(x1,y1), 4-7 - для начальной точки(x0,y0);}

  if (y1>rct_clp.Bottom) then
    line_code+=8
  else
    if (y1<rct_clp.Top) then
      line_code+=4;

  if (x1>rct_clp.Right) then
    line_code+=2
  else
    if (x1<rct_clp.Left) then
      line_code+=1;

  if (y0>rct_clp.Bottom) then
    line_code+=128
  else
    if (y0<rct_clp.Top) then
      line_code+=64;

  if (x0>rct_clp.Right) then
    line_code+=32
  else
    if (x0<rct_clp.Left) then
      line_code+=16;

  {Отсечение для каждого из 81-го случаев}
  case line_code of

    {Из центра}

    $00:
      begin
        ClipLine(x0,y0,x1,y1);
        Exit;
      end;
    $01:
      begin
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        ClipLine  (        x0,y0,x1,y1);
        Exit;
      end;
    $02:
      begin
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $04:
      begin
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $05:
      begin
        Clip1_Left    (rct_clp,x0,y0,x1,y1);
        if (y1<        rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $06:
      begin
        Clip1_Right   (rct_clp,x0,y0,x1,y1);
        if (y1<        rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $08:
      begin
        Clip1_Top(rct_clp,x0,y0,x1,y1);
        ClipLine (        x0,y0,x1,y1);
        Exit;
      end;
    $09:
      begin
        Clip1_Left (rct_clp,x0,y0,x1,y1);
        if (y1>     rct_clp.Bottom) then
          Clip1_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $0A:
      begin
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        if (y1>     rct_clp.Bottom) then
          Clip1_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;

    {Слева}

    $10:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        ClipLine  (        x0,y0,x1,y1);
        Exit;
      end;
    $11: Exit;                                                 // Отброшен
    $12:
      begin
        Clip0_Left (rct_clp,x0,y0,x1,y1);
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $14:
      begin
        Clip0_Left  (rct_clp,x0,y0,x1,y1);
        if (y0<      rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $15: Exit;                                                 // Отброшен
    $16:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        if (y0<    rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip1_Bottom (rct_clp,x0,y0,x1,y1);
        if (x1>       rct_clp.Right) then
          Clip1_Right(rct_clp,x0,y0,x1,y1);
        ClipLine     (        x0,y0,x1,y1);
        Exit;
      end;
    $18:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        if (y0>    rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip1_Top(rct_clp,x0,y0,x1,y1);
        ClipLine (        x0,y0,x1,y1);
        Exit;
      end;
    $19: Exit;                                                 // Отброшен
    $1A:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        if (y0>    rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip1_Top    (rct_clp,x0,y0,x1,y1);
        if (x1>       rct_clp.Right) then
          Clip1_Right(rct_clp,x0,y0,x1,y1);
        ClipLine     (        x0,y0,x1,y1);
        Exit;
      end;

    {Справа}

    $20:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $21:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        Clip1_Left (rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $22: Exit;                                                 // Отброшен
    $24:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0<     rct_clp.Top) then
          Exit;                                                 // Отброшен
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $25:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0<     rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        if (x1<      rct_clp.Left) then
          Clip1_Left(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $26: Exit;                                                 // Отброшен
    $28:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip1_Top  (rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $29:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip1_Top(rct_clp,x0,y0,x1,y1);
        if (x1<   rct_clp.Left) then
          Clip1_Left(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $2A: Exit;                                                 // Отброшен

    {Снизу}

    $40:
      begin
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $41:
      begin
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (x0<      rct_clp.Left) then
          Exit;                                                // Отброшен
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        if (y1<    rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $42:
      begin
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (x0>      rct_clp.Right) then
          Exit;                                                // Отброшен
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $44: Exit;                                                 // Отброшен
    $45: Exit;                                                 // Отброшен
    $46: Exit;                                                 // Отброшен
    $48:
      begin
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        Clip1_Top   (rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $49:
      begin
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (x0<      rct_clp.Left) then
          Exit;                                                // Отброшен
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        if (y1>    rct_clp.Bottom) then
          Clip1_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $4A:
      begin
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (x0>      rct_clp.Right) then
          Exit;                                                // Отброшен
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        if (y1>     rct_clp.Bottom) then
          Clip1_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;

    {Снизу слева}

    $50:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        if (y0<    rct_clp.Top) then
          Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $51: Exit;                                                 // Отброшен
    $52:
      begin
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        if (y1<     rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (x0<      rct_clp.Left) then
          Clip0_Left(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $54: Exit;                                                 // Отброшен
    $55: Exit;                                                 // Отброшен
    $56: Exit;                                                 // Отброшен
    $58:
      begin
        Clip1_Top(rct_clp,x0,y0,x1,y1);
        if (x1<   rct_clp.Left) then
          Exit;                                                // Отброшен
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (x0<      rct_clp.Left) then
          Clip0_Left(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $59: Exit;                                                 // Отброшен
    $5A:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        if (y0>    rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        if (y1<     rct_clp.Top) then
          Exit;                                                // Отброшен
        if (y0<        rct_clp.Top) then
          Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (y1>        rct_clp.Bottom) then
          Clip1_Top   (rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;

    {Снизу-справа}

    $60:
      begin
        Clip0_Right   (rct_clp,x0,y0,x1,y1);
        if (y0<        rct_clp.Top) then
          Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $61:
      begin
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        if (y1<    rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip0_Bottom (rct_clp,x0,y0,x1,y1);
        if (x0>       rct_clp.Right) then
          Clip0_Right(rct_clp,x0,y0,x1,y1);
        ClipLine     (        x0,y0,x1,y1);
        Exit;
      end;
    $62: Exit;                                                 // Отброшен
    $64: Exit;                                                 // Отброшен
    $65: Exit;                                                 // Отброшен
    $66: Exit;                                                 // Отброшен
    $68:
      begin
        Clip1_Top(rct_clp,x0,y0,x1,y1);
        if (x1>   rct_clp.Right) then
          Exit;                                                // Отброшен
        Clip0_Right   (rct_clp,x0,y0,x1,y1);
        if (y0<        rct_clp.Top) then
          Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $69:
      begin
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        if (y1<    rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Exit;                                                // Отброшен
        if (y1>        rct_clp.Bottom) then
          Clip1_Top   (rct_clp,x0,y0,x1,y1);
        if (y0<        rct_clp.Top) then
          Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $6A: ;                                                     // Отброшен

    {Сверху}

    $80:
      begin
        Clip0_Top(rct_clp,x0,y0,x1,y1);
        ClipLine (        x0,y0,x1,y1);
        Exit;
      end;
    $81:
      begin
        Clip0_Top(rct_clp,x0,y0,x1,y1);
        if (x0<   rct_clp.Left) then
          Exit;                                                // Отброшен
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        ClipLine  (        x0,y0,x1,y1);
        Exit;
      end;
    $82:
      begin
        Clip0_Top(rct_clp,x0,y0,x1,y1);
        if (x0>   rct_clp.Right) then
          Exit;                                                // Отброшен
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $84:
      begin
        Clip0_Top   (rct_clp,x0,y0,x1,y1);
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $85:
      begin
        Clip0_Top(rct_clp,x0,y0,x1,y1);
        if (x0<   rct_clp.Left) then
          Exit;                                                // Отброшен
        Clip1_Left    (rct_clp,x0,y0,x1,y1);
        if (y1<        rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $86:
      begin
        Clip0_Top(rct_clp,x0,y0,x1,y1);
        if (x0>   rct_clp.Right) then
          Exit;                                                // Отброшен
        Clip1_Right   (rct_clp,x0,y0,x1,y1);
        if (y1<        rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $88: Exit;                                                 // Отброшен
    $89: Exit;                                                 // Отброшен
    $8A: Exit;                                                 // Отброшен

    {Сверху-слева}

    $90:
      begin
        Clip0_Left (rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Clip0_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $91: Exit;                                                 // Отброшен
    $92:
      begin
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        if (y1>     rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip0_Top   (rct_clp,x0,y0,x1,y1);
        if (x0<      rct_clp.Left) then
          Clip0_Left(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $94:
      begin
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        if (x1<      rct_clp.Left) then
          Exit;                                                // Отброшен
        Clip0_Left (rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Clip0_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $95: Exit;                                                 // Отброшен
    $96:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        if (y0<    rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        if (y1>     rct_clp.Bottom) then
          Exit;                                                // Отброшен
        if (y0>        rct_clp.Bottom) then
          Clip0_Top   (rct_clp,x0,y0,x1,y1);
        if (y1<        rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $98: Exit;                                                 // Отброшен
    $99: Exit;                                                 // Отброшен
    $9A: Exit;                                                 // Отброшен

    {Сверху-справа}

    $A0:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Clip0_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $A1:
      begin
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        if (y1>    rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip0_Top    (rct_clp,x0,y0,x1,y1);
        if (x0>       rct_clp.Right) then
          Clip0_Right(rct_clp,x0,y0,x1,y1);
        ClipLine     (        x0,y0,x1,y1);
        Exit;
      end;
    $A2: Exit;                                                 // Отброшен
    $A4:
      begin
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        if (x1>      rct_clp.Right) then
          Exit;                                                // Отброшен
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Clip0_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $A5:
      begin
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        if (y1>    rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0<     rct_clp.Top) then
          Exit;                                                // Отброшен
        if (y1<        rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        if (y0>        rct_clp.Bottom) then
          Clip0_Top   (rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $A6: Exit;                                                 // Отброшен
    $A8: Exit;                                                 // Отброшен
    $A9: Exit;                                                 // Отброшен
    $AA: Exit;                                                 // Отброшен

  end;
  {$endregion}
end; {$endregion}

// Matthes-Drakopoulos  Algorithm:
procedure TFastLine.ClippedLine2(x0,y0,x1,y1:integer; const rct_clp:TPtRect; constref proc1:TProc3; constref proc2:TProc0; constref proc3:TProc0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x: array[0..1] of integer;
  y: array[0..1] of integer;
  i: byte;
begin
  if ((not ((x0<rct_clp.left) and (x1<rct_clp.left))) and (not ((x0>rct_clp.right ) and (x1>rct_clp.right )))) and
     ((not ((y0<rct_clp.top ) and (y1<rct_clp.top ))) and (not ((y0>rct_clp.bottom) and (y1>rct_clp.bottom)))) then
    begin
      x[0]:=x0;
      y[0]:=y0;
      x[1]:=x1;
      y[1]:=y1;
      i   :=0;
      repeat
        begin
          if (x[i]<rct_clp.left) then
            begin
              x[i]:=rct_clp.left;
              y[i]:=Trunc(((y1-y0)*(rct_clp.left  -x0))/(x1-x0)+y0);
            end
          else
          if (x[i]>rct_clp.right) then
            begin
              x[i]:=rct_clp.right;
              y[i]:=Trunc(((y1-y0)*(rct_clp.right -x0))/(x1-x0)+y0);
            end;
          if (y[i]<rct_clp.top) then
            begin
              y[i]:=rct_clp.top;
              x[i]:=Trunc(((x1-x0)*(rct_clp.top   -y0))/(y1-y0)+x0);
            end
          else
          if (y[i]>rct_clp.bottom) then
            begin
              y[i]:=rct_clp.bottom;
              x[i]:=Trunc(((x1-x0)*(rct_clp.bottom-y0))/(y1-y0)+x0);
            end;
          i:=i+1;
        end;
      until (i>1);
      if (not ((x[0]<rct_clp.left ) and (x[1]<rct_clp.left ))) and
         (not ((x[0]>rct_clp.right) and (x[1]>rct_clp.right))) then
        proc1(x[0],y[0],x[1],y[1],proc2,proc3);
    end;
end; {$endregion}
procedure TFastLine.ClippedLine2(x0,y0,x1,y1:integer; const rct_clp:TPtRect);                                                                      {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x: array[0..1] of integer;
  y: array[0..1] of integer;
  i: byte;
begin
  if ((not ((x0<rct_clp.left) and (x1<rct_clp.left))) and (not ((x0>rct_clp.right ) and (x1>rct_clp.right )))) and
     ((not ((y0<rct_clp.top ) and (y1<rct_clp.top ))) and (not ((y0>rct_clp.bottom) and (y1>rct_clp.bottom)))) then
    begin
      x[0]:=x0;
      y[0]:=y0;
      x[1]:=x1;
      y[1]:=y1;
      i   :=0;
      repeat
        begin
          if (x[i]<rct_clp.left) then
            begin
              x[i]:=rct_clp.left;
              y[i]:=Trunc(((y1-y0)*(rct_clp.left  -x0))/(x1-x0)+y0);
            end
          else
          if (x[i]>rct_clp.right) then
            begin
              x[i]:=rct_clp.right;
              y[i]:=Trunc(((y1-y0)*(rct_clp.right -x0))/(x1-x0)+y0);
            end;
          if (y[i]<rct_clp.top) then
            begin
              y[i]:=rct_clp.top;
              x[i]:=Trunc(((x1-x0)*(rct_clp.top   -y0))/(y1-y0)+x0);
            end
          else
          if (y[i]>rct_clp.bottom) then
            begin
              y[i]:=rct_clp.bottom;
              x[i]:=Trunc(((x1-x0)*(rct_clp.bottom-y0))/(y1-y0)+x0);
            end;
          i:=i+1;
        end;
      until (i>1);
      if (not ((x[0]<rct_clp.left ) and (x[1]<rct_clp.left ))) and
         (not ((x[0]>rct_clp.right) and (x[1]>rct_clp.right))) then
        with ln_pos do
          begin
            x0:=x[0];
            y0:=y[0];
            x1:=x[1];
            y1:=y[1];
          end;
    end;
end; {$endregion}

// Fill Buffer With Anti-Aliasing:
procedure TFastLine.FillBuffer(constref rct_clp:TPtRect); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct: TPtRect;
begin
  with local_prop do
    if (clp_stl<>csResilientEdges) then
      begin
        with rct_clp do
          rct:=PtRct(left+1,top+1,right-1,bottom-1);
        ArrAdd(ln_arr0,
               ln_arr2,
               rct_clp,
               ln_arr_width,
               ln_arr_height);

        {Fill Buffer---------} {$region -fold}
        ArrFillProc[Byte(eds_bld_stl)](ln_arr0,
                                       bmp_dst_ptr,
                                       ln_arr_width,
                                       ln_arr_height,
                                       rct_clp,
                                       eds_col); {$endregion}

        {Border Anti-Aliasing} {$region -fold}
        if eds_aa then
          begin
            BorderCalc1 (ln_arr0,
                         aa_arr1,
                         ln_arr_width,
                         ln_arr_width,
                         rct,
                         aa_nz_arr_items_cnt);
            BorderCalc22(ln_arr0,
                         aa_arr1,
                         aa_arr2,
                         ln_arr_width,
                         ln_arr_width,
                         rct,
                         aa_line_cnt);
            BorderFill  (aa_arr2,
                         0,
                         0,
                         bmp_dst_ptr,
                         ln_arr_width,
                         aa_line_cnt,
                         eds_col,
                         args,
                         PPDec2Proc[pp_dec_2_proc_ind]);
          end; {$endregion}

      end;
end; {$endregion} {$endregion}
{$endregion}



(***************************** Fast Text Routines *****************************) {$region -fold}

{Init. Part--} {$region -fold}
constructor TFastText.Create;                                                                                                               {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
destructor TFastText.Destroy;                                                                                                               {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  self.Free;
  inherited Destroy;
end; {$endregion} {$endregion}
{$endregion}



(****************************** Points Transform ******************************) {$region -fold}

// (Align Points to horizontal line, from left to right): Выровнять точки по горизонтали, слева направо:
procedure PtsRawH(var pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref pts_dist:TColor);                                                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr       : PPtPosF;
  i,pts_dist_acc: integer;
begin
  pts_ptr     :=Unaligned(@pts[start_ind]);
  pts_dist_acc:=Trunc(pts_ptr^.x);
  for i:=0 to end_ind-start_ind-1 do
    begin
      (pts_ptr+i)^.x:=pts_dist_acc;
      Inc(pts_dist_acc,pts_dist);
    end;
end; {$endregion}

// (Align Points to vertical line, from top to bottom): Выровнять точки по вертикали, сверху вниз:
procedure PtsRawV(var pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref pts_dist:TColor);                                                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr       : PPtPosF;
  i,pts_dist_acc: integer;
begin
  pts_ptr     :=Unaligned(@pts[start_ind]);
  pts_dist_acc:=Trunc(pts_ptr^.y);
  for i:=0 to end_ind-start_ind-1 do
    begin
      (pts_ptr+i)^.y:=pts_dist_acc;
      Inc(pts_dist_acc,pts_dist);
    end;
end; {$endregion}

// (Reset Points Position): Восстановить позицию точек:
procedure PtsRes (constref fst_pt_ptr1,fst_pt_ptr2:PPtPosF; constref pts_cnt:TColor; constref pt_pos_curr,pt_pos_prev:TPtPosF);                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  fst_pt_ptr3: PPtPosF;
  i,n1,n2    : integer;
  m          : byte;
begin
  n1:=Trunc(pt_pos_curr.x)-Trunc(pt_pos_prev.x);
  n2:=Trunc(pt_pos_curr.y)-Trunc(pt_pos_prev.y);
  for i:=0 to Trunc(pts_cnt/4)-1 do
    begin
       fst_pt_ptr3      :=fst_pt_ptr1+i<<2;
      (fst_pt_ptr3+0)^.x+=n1;
      (fst_pt_ptr3+0)^.y+=n2;
      (fst_pt_ptr3+1)^.x+=n1;
      (fst_pt_ptr3+1)^.y+=n2;
      (fst_pt_ptr3+2)^.x+=n1;
      (fst_pt_ptr3+2)^.y+=n2;
      (fst_pt_ptr3+3)^.x+=n1;
      (fst_pt_ptr3+3)^.y+=n2;
    end;
  m:=pts_cnt mod 4;
  if (m<>0) then
    for i:=0 to m-1 do
      begin
        (fst_pt_ptr2+i)^.x+=n1;
        (fst_pt_ptr2+i)^.y+=n2;
      end;
end; {$endregion}

// (Points Pivot) Ось точек:
procedure PtsPvt (var      pvt:TPtPosF; var pts:TPtPosFArr; constref pts_cnt:TColor);                                                                         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr: PPtPosF;
  p      : TPtPosF;
  i      : integer;
begin
  if (pts=Nil) then
    Exit;
  p      :=Default(TPtPosF);
  pvt    :=Default(TPtPosF);
  pts_ptr:=Unaligned(@pts[0]);
  for i  :=0 to pts_cnt-1 do
    begin
      p.x+=(pts_ptr+i)^.x;
      p.y+=(pts_ptr+i)^.y;
    end;
  pvt.x  :=p.x/pts_cnt;
  pvt.y  :=p.y/pts_cnt;
end; {$endregion}

// (Points Moving) Перемещение точек:
procedure PtsMov (constref pvt:TPtPos;  var pts:TPtPosFArr; constref fst_ind,lst_ind:TColor                                 );                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr: PPtPosF;
  i      : integer;
begin
  if (pts=Nil) then
    Exit;
  pts_ptr:=Unaligned(@pts[fst_ind]);
  for i:=0 to lst_ind-fst_ind do
    begin
      pts_ptr^.x-=pvt.x;
      pts_ptr^.y-=pvt.y;
      Inc(pts_ptr);
    end;
end; {$endregion}
procedure PtsMov (constref pvt:TPtPos;  var rct:TPtRect                                                                     );                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  rct.left  -=pvt.x;
  rct.top   -=pvt.y;
  rct.right -=pvt.x;
  rct.bottom-=pvt.y;
  rct.width :=rct.right -rct.left;
  rct.height:=rct.bottom-rct.top;
end; {$endregion}
procedure PtsMov (constref pvt:TPtPos;  var rct:TRect                                                                       );                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  rct.left  -=pvt.x;
  rct.top   -=pvt.y;
  rct.right -=pvt.x;
  rct.bottom-=pvt.y;
  rct.width :=rct.right -rct.left;
  rct.height:=rct.bottom-rct.top;
end; {$endregion}
procedure WndSht (constref outer_rect:TPtRect; constref inner_rect:TPtPosFArr; var shift_power:integer; constref mul:integer);                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m: integer;
begin
  m:=Max2(Trunc(inner_rect[1].x-
                inner_rect[0].x),
          Trunc(inner_rect[1].y-
                inner_rect[0].y));
  if (m>512) then
      shift_power:=Trunc(m/50);
  if (shift_power >Min3(outer_rect.width,
                       outer_rect.height)) then
      shift_power:=Min3(outer_rect.width,
                       outer_rect.height);
      shift_power*=mul>>4;
end; {$endregion}
procedure MDCalc (var rct:TRect; constref mov_dir:TMovingDirection; constref parallax_shift:TPtPos                          );                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct do
    case mov_dir of
      mdNone:
        Exit;
      mdLeft:
        begin
          left +=parallax_shift.x;
          right+=parallax_shift.x;
          width:=right-left;
        end;
      mdRight:
        begin
          left -=parallax_shift.x;
          right-=parallax_shift.x;
          width:=right-left;
        end;
      mdUp:
        begin
          top   +=parallax_shift.y;
          bottom+=parallax_shift.y;
          height:=bottom-top;
        end;
      mdDown:
        begin
          top   -=parallax_shift.y;
          bottom-=parallax_shift.y;
          height:=bottom-top;
        end;
      mdLeftUp:
        begin
          left  +=parallax_shift.x;
          right +=parallax_shift.x;
          width :=right-left;
          top   +=parallax_shift.y;
          bottom+=parallax_shift.y;
          height:=bottom-top;
        end;
      mdRightUp:
        begin
          left  -=parallax_shift.x;
          right -=parallax_shift.x;
          width :=right-left;
          top   +=parallax_shift.y;
          bottom+=parallax_shift.y;
          height:=bottom-top;
        end;
      mdLeftDown:
        begin
          left  +=parallax_shift.x;
          right +=parallax_shift.x;
          width :=right-left;
          top   -=parallax_shift.y;
          bottom-=parallax_shift.y;
          height:=bottom-top;
        end;
      mdRightDown:
        begin
          left  -=parallax_shift.x;
          right -=parallax_shift.x;
          width :=right-left;
          top   -=parallax_shift.y;
          bottom-=parallax_shift.y;
          height:=bottom-top;
        end;
    end;
end; {$endregion}

// (Points Scaling) Масштабирование точек:
procedure PtsScl (constref pvt:TPtPosF; var pts:TPtPosFArr; scl_mul:TPtPosF; constref scl_dir:TSclDir; fst_ind:TColor=0; lst_ind:TColor=0);                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr: PPtPosF;
  d1,d2  : double;
  i      : integer;
begin
  if (pts=Nil) then
    Exit;
  if (scl_dir=sdNone) then
    Exit;
  if (scl_dir=sdDown) then
    scl_mul:=PtPosF(1/scl_mul.x,
                    1/scl_mul.y);
  d1       :=pvt.x*(1-scl_mul.x){pvt.x-pvt.x*scl_mul.x};
  d2       :=pvt.y*(1-scl_mul.y){pvt.y-pvt.y*scl_mul.y};
  pts_ptr  :=Unaligned(@pts[fst_ind]);
  for i:=0 to lst_ind-fst_ind do
    begin
    //pts_ptr^.x:=scl_mul.x*pts_ptr^.x+d1;
      pts_ptr^.x*=scl_mul.x;
      pts_ptr^.x+=d1;
    //pts_ptr^.y:=scl_mul.y*pts_ptr^.y+d2;
      pts_ptr^.y*=scl_mul.y;
      pts_ptr^.y+=d2;
      Inc(pts_ptr);
    end;
end; {$endregion}
procedure PtsScl (constref pvt:TPtPosF; var rct:TPtRectF  ; scl_mul:TPtPosF; constref scl_dir:TSclDir                                    );                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  d1,d2: double;
begin
  if (scl_dir=sdNone) then
    Exit;
  if (scl_dir=sdDown) then
    scl_mul:=PtPosF(1/scl_mul.x,
                    1/scl_mul.y);
  d1       :=pvt.x*(1-scl_mul.x){pvt.x-pvt.x*scl_mul.x};
  d2       :=pvt.y*(1-scl_mul.y){pvt.y-pvt.y*scl_mul.y};
  with rct do
    begin
    //left  :=scl_mul.x*left   +d1;
      left  *=scl_mul.x;
      left  +=d1;
    //top   :=scl_mul.y*top    +d2;
      top   *=scl_mul.y;
      top   +=d2;
    //right :=scl_mul.x*=right +d1;
      right *=scl_mul.x;
      right +=d1;
    //bottom:=scl_mul.y*=bottom+d2;
      bottom*=scl_mul.y;
      bottom+=d2;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
procedure PtsScl (constref pvt:TPtPosF; var rct:TRect     ; scl_mul:TPtPosF; constref scl_dir:TSclDir                                    );                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  d1,d2: double;
begin
  if (scl_dir=sdNone) then
    Exit;
  if (scl_dir=sdDown) then
    scl_mul:=PtPosF(1/scl_mul.x,
                    1/scl_mul.y);
  d1       :=pvt.x*(1-scl_mul.x){pvt.x-pvt.x*scl_mul.x};
  d2       :=pvt.y*(1-scl_mul.y){pvt.y-pvt.y*scl_mul.y};
  with rct do
    begin
      left  :=Trunc (scl_mul.x*left  +d1);
      top   :=Trunc (scl_mul.y*top   +d2);
      right :=Trunc (scl_mul.x*right +d1);
      bottom:=Trunc (scl_mul.y*bottom+d2);
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function  GetDir1(prev_pos,curr_pos,pvt:TPtPosF): TSclDir;                                                                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  dist  : double;
begin
  Result:=sdNone;
  dist  :=PtDistSqr(pvt.x,pvt.y,curr_pos.x,curr_pos.y)-
          PtDistSqr(pvt.x,pvt.y,prev_pos.x,prev_pos.y);
  if (dist>0) then
    Result:=sdUp
  else
  if (dist<0) then
    Result:=sdDown
  else
  if (dist=0) then
    Result:=sdNone;
end; {$endregion}
function  GetDir2(prev_pos,curr_pos,pvt:TPtPosF): TSclDir;                                                                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=sdNone;
  if (curr_pos.x>prev_pos.x) then
    Result:=sdUp
  else
  if (curr_pos.x<prev_pos.x) then
    Result:=sdDown
  else
  if (curr_pos.x=prev_pos.x) then
    Result:=sdNone;
end; {$endregion}
procedure SetMul (prev_pos,curr_pos,pvt:TPtPosF;        var scl_mul:TPtPosF; constref scl_dir:TSclDir);                                                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  scl_mul:=PtPosF(DEFAULT_SCL_MUL,
                  DEFAULT_SCL_MUL);
  if (scl_dir=sdDown) then
    scl_mul:=PtPosF(1/scl_mul.x,
                    1/scl_mul.y);
end; {$endregion}

// (Points Rotation) Вращение точек:
procedure GetRot         (constref pvt:TPtPos    ;                          constref angle:double; var c,s,v,w:double                            );           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SinCos(pi*(1+angle/180),s,c);
  v:=pvt.x*c-pvt.y*s+pvt.x;
  w:=pvt.y*c+pvt.x*s+pvt.y;
end; {$endregion}
procedure GetRot         (constref pvt:TPtPos    ;                          constref angle:double; var c,s,v,w:integer; constref x,y    :integer );           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  c:=Trunc(cos(pi*(1+angle/180))*$10000);
  s:=Trunc(sin(pi*(1+angle/180))*$10000);
  v:=(pvt.x-x)*c-(pvt.y-y)*s+pvt.x<<16;
  w:=(pvt.y-y)*c+(pvt.x-x)*s+pvt.y<<16;
end; {$endregion}
procedure GetRot         (constref pvt:TPtPosF   ;                          constref angle:double; var c,s,v,w:double                            );           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SinCos(pi*(1+angle/180),s,c);
  v:=pvt.x*c-pvt.y*s+pvt.x;
  w:=pvt.y*c+pvt.x*s+pvt.y;
end; {$endregion}
procedure GetRotRound    (constref pvt:TPtPos    ;                          constref angle:double; var c,s,v,w:double;  constref x,y    :integer );           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  v:=x;
  w:=y;
  c:=Tan(pi*(angle-45)/360);
  s:=Sin(pi*(angle-45)/180);
  v-=Round(w*c);
  w+=Round(v*s);
  v-=Round(w*c);
  {
   c:=Round(Tan((pi*(1+angle/360))*$10000));
   s:=Round(Sin((pi*(1+angle/180))*$10000));
   pt.y:= pt.y  +pt.x-pt.y*c*s  ;
   pt.x:=-pt.y*c-pt.y+pt.y*c*s*c;
  }
  {c:=Trunc(cos(pi*(1+angle/180))*$10000);
  s:=Trunc(sin(pi*(1+angle/180))*$10000);
  v:=(pvt.x-x)*c-(pvt.y-y)*s+pvt.x<<16;
  w:=(pvt.y-y)*c+(pvt.x-x)*s+pvt.y<<16;}
end; {$endregion}
procedure GetRotNotRound (constref pvt:TPtPos    ;                          constref angle:double; var c,s,v,w:double;  constref x,y    :integer );           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  v:=x;
  w:=y;
  c:=Tan(pi*(angle-45)/360);
  s:=Sin(pi*(angle-45)/180);
  {v-={Round}(w*c);
  w+={Round}(v*s);
  v-={Round}(w*c);}


  //v:=x-y*c;
  w:=y+(x-y*c)*s;
  v:={x-y*c-(y+(x-y*c)*s)*c}{x-2*y*c-x*s*c+y*c*s*c}{x-2*y*c-x*s*c+y*c*s*c}x-(y<<1+(x-y*c)*s)*c;


  {
   c:=Round(Tan((pi*(1+angle/360))*$10000));
   s:=Round(Sin((pi*(1+angle/180))*$10000));
   pt.y:= pt.y  +pt.x-pt.y*c*s  ;
   pt.x:=-pt.y*c-pt.y+pt.y*c*s*c;
  }
  {c:=Trunc(cos(pi*(1+angle/180))*$10000);
  s:=Trunc(sin(pi*(1+angle/180))*$10000);
  v:=(pvt.x-x)*c-(pvt.y-y)*s+pvt.x<<16;
  w:=(pvt.y-y)*c+(pvt.x-x)*s+pvt.y<<16;}
end; {$endregion}
procedure GetRotNotRound2(constref pvt:TPtPos    ;                          constref angle:double; var c,s,v,w:integer; constref x,y    :integer );           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  c:=Trunc(Tan(pi*(angle-45)/360)*65536);
  s:=Trunc(Sin(pi*(angle-45)/180)*65536);
  w:=(y<<48+(x-y*c)*s)>>48;
  v:={x-((x-y*c)*s+y<<1)*c}(x<<48-2*y*c-x*s*c+y*c*s*c)>>48;


  {
   c:=Round(Tan((pi*(1+angle/360))*$10000));
   s:=Round(Sin((pi*(1+angle/180))*$10000));
   pt.y:= pt.y  +pt.x-pt.y*c*s  ;
   pt.x:=-pt.y*c-pt.y+pt.y*c*s*c;
  }
  {c:=Trunc(cos(pi*(1+angle/180))*$10000);
  s:=Trunc(sin(pi*(1+angle/180))*$10000);
  v:=(pvt.x-x)*c-(pvt.y-y)*s+pvt.x<<16;
  w:=(pvt.y-y)*c+(pvt.x-x)*s+pvt.y<<16;}
end; {$endregion}
procedure PtsRot         (var      pts:TPtPosFArr; constref pts_cnt:TColor; constref angle:double; var c,s,v,w:double;  constref fst_ind:TColor=0);           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr: PPtPosF;
  dx,dy  : double ;
  i      : integer;
begin
  if (pts=Nil) then
    Exit;
  if (Trunc(angle) mod 360=0) then
    Exit;
  pts_ptr:=Unaligned(@pts[fst_ind]);
  for i:=0 to pts_cnt-fst_ind-1 do
    begin
      dx        :=pts_ptr^.x;
      dy        :=pts_ptr^.y;
      pts_ptr^.x:=-dx*c+dy*s+v;
      pts_ptr^.y:=-dy*c-dx*s+w;
      Inc(pts_ptr);
    end;
end; {$endregion}
function  PtsRot         (         rct:TPtRectF  ;                          constref angle:double; var c,s,v,w:double;  constref margin :TColor=1): TPtRectF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x0,x1,x2,x3: double ;
  y0,y1,y2,y3: double ;
  i          : integer;
begin
  if (Trunc(angle) mod 360=0) then
    Exit;
  with rct do
    begin
      x0:=-left  *c+top   *s+v;
      x1:=-right *c+top   *s+v;
      x2:=-right *c+bottom*s+v;
      x3:=-left  *c+bottom*s+v;
      y0:=-top   *c-left  *s+w;
      y1:=-top   *c-right *s+w;
      y2:=-bottom*c-right *s+w;
      y3:=-bottom*c-left  *s+w;
    end;
  with Result do
    begin
      left  :=Min1(Min1(x0,x1),Min1(x2,x3))-margin;
      top   :=Min1(Min1(y0,y1),Min1(y2,y3))-margin;
      right :=Max1(Max1(x0,x1),Max1(x2,x3))+margin;
      bottom:=Max1(Max1(y0,y1),Max1(y2,y3))+margin;
      width :=right -left;
      height:=bottom-top;
    end;
end; {$endregion}
function  PtsRot         (         rct:TRect     ;                          constref angle:double; var c,s,v,w:double;  constref margin :TColor=1): TRect;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x0,x1,x2,x3: double ;
  y0,y1,y2,y3: double ;
  i          : integer;
begin
  if (Trunc(angle) mod 360=0) then
    Exit;
  with rct do
    begin
      x0:=-left  *c+top   *s+v;
      x1:=-right *c+top   *s+v;
      x2:=-right *c+bottom*s+v;
      x3:=-left  *c+bottom*s+v;
      y0:=-top   *c-left  *s+w;
      y1:=-top   *c-right *s+w;
      y2:=-bottom*c-right *s+w;
      y3:=-bottom*c-left  *s+w;
    end;
  with Result do
    begin
      left  :=Trunc(Min1(Min1(x0,x1),Min1(x2,x3)))-margin;
      top   :=Trunc(Min1(Min1(y0,y1),Min1(y2,y3)))-margin;
      right :=Trunc(Max1(Max1(x0,x1),Max1(x2,x3)))+margin;
      bottom:=Trunc(Max1(Max1(y0,y1),Max1(y2,y3)))+margin;
      width :=right -left;
      height:=bottom-top;
    end;
end; {$endregion}
function  PtsRot         (         rct:TPtRect   ;                          constref angle:double; var c,s,v,w:double;  constref margin :TColor=1): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x0,x1,x2,x3: double ;
  y0,y1,y2,y3: double ;
  i          : integer;
begin
  if (Trunc(angle) mod 360=0) then
    Exit;
  with rct do
    begin
      x0:=-left  *c+top   *s+v;
      x1:=-right *c+top   *s+v;
      x2:=-right *c+bottom*s+v;
      x3:=-left  *c+bottom*s+v;
      y0:=-top   *c-left  *s+w;
      y1:=-top   *c-right *s+w;
      y2:=-bottom*c-right *s+w;
      y3:=-bottom*c-left  *s+w;
    end;
  with Result do
    begin
      left  :=Trunc(Min1(Min1(x0,x1),Min1(x2,x3)))-margin;
      top   :=Trunc(Min1(Min1(y0,y1),Min1(y2,y3)))-margin;
      right :=Trunc(Max1(Max1(x0,x1),Max1(x2,x3)))+margin;
      bottom:=Trunc(Max1(Max1(y0,y1),Max1(y2,y3)))+margin;
      width :=right -left;
      height:=bottom-top;
    end;
end; {$endregion}

// (Points Simplification) Точечное упрощение:
{TODO}
{$endregion}



(************************** Miscellaneous Primitives **************************) {$region -fold}

// Color Info:
procedure SetColorInfo(constref pix_col_:TColor; var color_info:TColorInfo; alpha_max:byte=255); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with color_info do
    begin
      r       :=Red  (pix_col_);
      g       :=Green(pix_col_);
      b       :=Blue (pix_col_);
      pix_col :=RGB(b,g,r);
        alpha1:=180;
      d_alpha1:=alpha_max-alpha1;
        alpha2:=80;
      d_alpha2:=alpha_max-alpha2;
    end;
end; {$endregion}
procedure SetColorInfo(constref pix_col_:TColor; var color_info:TColorInfo; b_:boolean);         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with color_info do
    begin
      r      :=Red  (pix_col_);
      g      :=Green(pix_col_);
      b      :=Blue (pix_col_);
      pix_col:=RGB(b,g,r);
    end;
end; {$endregion}

// Line Segment: Отрезок:
function  LineS   (constref v0,w0,v1,w1,r0,r1:double                               ): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k,d0,d1: double;
begin
  with Result do
    begin
      if (v1=v0) then
        begin
          x0:=v0;
          y0+=r0;
          x1:=v1;
          y1+=r1;
          Exit;
        end;
      if (w1=w0) then
        begin
          x0+=r0;
          y0:=w0;
          x1+=r1;
          y1:=w1;
          Exit;
        end;
      k :=(w1-w0)/(v1-v0);
      d0:=r0*InvSqrt(1+k*k){r0/sqrt(1+k*k)}; // only with garbage init. ON
      x0:=v0+d0;
      y0:=k*d0+w0;
      d1:=r1*InvSqrt(1+k*k){r1/sqrt(1+k*k)}; // only with garbage init. ON
      x1:=v1+d1;
      y1:=k*d1+w1;
    end;
end; {$endregion}
function  LineS   (constref v0,w0,v1,w1,r    :double                               ): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k,d: double;
begin
  with Result do
    begin
      if (v1=v0) then
        begin
          x:=v1;
          y+=r;
          Exit;
        end;
      if (w1=w0) then
        begin
          x+=r;
          y:=w1;
          Exit;
        end;
      k :=(w1-w0)/(v1-v0);
      d :=r*InvSqrt(1+k*k){r/sqrt(1+k*k)}; // only with garbage init. ON
      x :=v1+d;
      y :=k*d+w1;
    end;
end; {$endregion}
function  LineS   (constref v0,w0,v1,w1,r    :double; constref dir_x,dir_y:shortint): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k,dx: double;
begin
  with Result do
    begin
      if (v1=v0) then
        begin
          x:=v1;
          y:=w1+r*dir_y;
          Exit;
        end;
      if (w1=w0) then
        begin
          x:=v1+r*dir_x;
          y:=w1;
          Exit;
        end;
      k :=(w1-w0)/(v1-v0);
      dx:=r*InvSqrt(1+k*k){r/sqrt(1+k*k)}; // only with garbage init. ON
      x :=v1+dir_x*dx;
      y :=w1+dir_y*dx*k;
    end;
end; {$endregion}

// Line Direction: Направление линии:
procedure LineD   (constref v0,w0,v1,w1      :double; var      dir_x,dir_y:shortint);          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (v1>v0) then
    begin
      if (w1=w0) then
        begin
          dir_x:=1;
          dir_y:=0;
          Exit;
        end
      else
        begin
          dir_x:=1;
          dir_y:=1;
          Exit;
        end;
    end
  else
    begin
      if (v1=v0) then
        begin
          if (w1>w0) then
            begin
              dir_x:=0;
              dir_y:=1;
              Exit;
            end
          else
            begin
              dir_x:=0;
              dir_y:=-1;
              Exit;
            end
        end;
      if (w1=w0) then
        begin
          dir_x:=-1;
          dir_y:=0;
          Exit;
        end
      else
        begin
          dir_x:=-1;
          dir_y:=-1;
          Exit;
        end;
    end
end; {$endregion}

// Monochrome Regular Line(Width - 1 pixel):
procedure Line    (x0,y0,x1,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  y0_shift                        : integer;
  i,short_len,long_len,swp,dec_inc: integer;
  yLonger                         : boolean;
begin
  with color_info do
    begin
      yLonger  :=False;
      short_len:=y1-y0;
      long_len :=x1-x0;
      if (Abs(short_len)>Abs(long_len)) then
        begin
          swp      :=short_len;
          short_len:=long_len;
          long_len :=swp;
          yLonger  :=True;
        end;
      if (long_len=0) then
        dec_inc:=0
      else
        dec_inc:=Trunc((short_len<<16)/long_len);
      if (yLonger) then
        begin
          if (long_len>0) then
            begin
    	      long_len+=y0;
              i:=$8000+(x0<<16);
              y0_shift:=y0*bmp_dst_width;
              while (y0<=long_len) do
                begin
                  (bmp_dst_ptr+(i>>16)+y0_shift)^:=pix_col;
    	          i+=dec_inc;
                  Inc(y0);
                  Inc(y0_shift,bmp_dst_width);
                end;
              Exit;
            end;
          long_len+=y0;
          i:=$8000+(x0<<16);
          y0_shift:=y0*bmp_dst_width;
          while (y0>=long_len) do
            begin
              (bmp_dst_ptr+(i>>16)+y0_shift)^:=pix_col;
              i-=dec_inc;
              Dec(y0);
              Dec(y0_shift,bmp_dst_width);
            end;
          Exit;
        end;
      if (long_len>0) then
        begin
          long_len+=x0;
          i:=$8000+(y0<<16);
          while (x0<=long_len) do
            begin
              (bmp_dst_ptr+x0+(i>>16)*bmp_dst_width)^:=pix_col;
              i+=dec_inc;
              Inc(x0);
            end;
          Exit;
        end;
      long_len+=x0;
      i:=$8000+(y0<<16);
      while (x0>=long_len) do
        begin
          (bmp_dst_ptr+x0+(i>>16)*bmp_dst_width)^:=pix_col;
          i-=dec_inc;
          Dec(x0);
        end;
    end;
end; {$endregion}
procedure Line    (x0,y0,x1,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref val       :TColor    ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  y0_shift                        : integer;
  i,short_len,long_len,swp,dec_inc: integer;
  yLonger                         : boolean;
begin
  yLonger  :=False;
  short_len:=y1-y0;
  long_len :=x1-x0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
    end;
  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);
  if (yLonger) then
    begin
      if (long_len>0) then
        begin
          long_len+=y0;
          i:=$8000+(x0<<16);
          y0_shift:=y0*bmp_dst_width;
          while (y0<=long_len) do
            begin
              (bmp_dst_ptr+(i>>16)+y0_shift)^:=val;
              i+=dec_inc;
              Inc(y0);
              Inc(y0_shift,bmp_dst_width);
            end;
          Exit;
        end;
      long_len+=y0;
      i:=$8000+(x0<<16);
      y0_shift:=y0*bmp_dst_width;
      while (y0>=long_len) do
        begin
          (bmp_dst_ptr+(i>>16)+y0_shift)^:=val;
          i-=dec_inc;
          Dec(y0);
          Dec(y0_shift,bmp_dst_width);
        end;
      Exit;
    end;
  if (long_len>0) then
    begin
      long_len+=x0;
      i:=$8000+(y0<<16);
      while (x0<=long_len) do
        begin
          (bmp_dst_ptr+x0+(i>>16)*bmp_dst_width)^:=val;
          i+=dec_inc;
          Inc(x0);
        end;
      Exit;
    end;
  long_len+=x0;
  i:=$8000+(y0<<16);
  while (x0>=long_len) do
    begin
      (bmp_dst_ptr+x0+(i>>16)*bmp_dst_width)^:=val;
      i-=dec_inc;
      Dec(x0);
    end;
end; {$endregion}
procedure Line    (x0,y0,x1,y1:integer; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width:TColor; constref val       :byte      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  y0_shift                        : integer;
  i,short_len,long_len,swp,dec_inc: integer;
  yLonger                         : boolean;
begin
  yLonger  :=False;
  short_len:=y1-y0;
  long_len :=x1-x0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
    end;
  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);
  if (yLonger) then
    begin
      if (long_len>0) then
        begin
          long_len+=y0;
          i:=$8000+(x0<<16);
          y0_shift:=y0*bmp_dst_width;
          while (y0<=long_len) do
            begin
              (bmp_dst_ptr+(i>>16)+y0_shift)^:=val;
              i+=dec_inc;
              Inc(y0);
              Inc(y0_shift,bmp_dst_width);
            end;
          Exit;
        end;
      long_len+=y0;
      i:=$8000+(x0<<16);
      y0_shift:=y0*bmp_dst_width;
      while (y0>=long_len) do
        begin
          (bmp_dst_ptr+(i>>16)+y0_shift)^:=val;
          i-=dec_inc;
          Dec(y0);
          Dec(y0_shift,bmp_dst_width);
        end;
      Exit;
    end;
  if (long_len>0) then
    begin
      long_len+=x0;
      i:=$8000+(y0<<16);
      while (x0<=long_len) do
        begin
          (bmp_dst_ptr+x0+(i>>16)*bmp_dst_width)^:=val;
          i+=dec_inc;
          Inc(x0);
        end;
      Exit;
    end;
  long_len+=x0;
  i:=$8000+(y0<<16);
  while (x0>=long_len) do
    begin
      (bmp_dst_ptr+x0+(i>>16)*bmp_dst_width)^:=val;
      i-=dec_inc;
      Dec(x0);
    end;
end; {$endregion}

// Line Segments Intersection:
function LineSI   (x0,y0,x1,y1,v0,w0,v1,w1:double ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  a0,a1,b0,b1: boolean;}
begin
  {a0:=((x0-x1)*(w0-y1)<=(y0-y1)*(v0-x1));
  a1:=((x0-x1)*(w1-y1)<=(y0-y1)*(v1-x1));
  b0:=((v1-v0)*(y1-w0)<=(w1-w0)*(x1-v0));
  b1:=((v1-v0)*(y0-w0)<=(w1-w0)*(x0-v0));
  Result:=((a0 and (not a1)) or (a1 and (not a0))) and
          ((b0 and (not b1)) or (b1 and (not b0)));}
  Result:=(((x0-x1)*(w0-y1)-(y0-y1)*(v0-x1))*
           ((x0-x1)*(w1-y1)-(y0-y1)*(v1-x1))<=0) and
          (((v1-v0)*(y1-w0)-(w1-w0)*(x1-v0))*
           ((v1-v0)*(y0-w0)-(w1-w0)*(x0-v0))<=0);
end; {$endregion}
function LineSI   (x0,y0,x1,y1,v0,w0,v1,w1:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  a0,a1,b0,b1: boolean;}
begin
  {a0:=((x0-x1)*(w0-y1)<=(y0-y1)*(v0-x1));
  a1:=((x0-x1)*(w1-y1)<=(y0-y1)*(v1-x1));
  b0:=((v1-v0)*(y1-w0)<=(w1-w0)*(x1-v0));
  b1:=((v1-v0)*(y0-w0)<=(w1-w0)*(x0-v0));
  Result:=((a0 and (not a1)) or (a1 and (not a0))) and
          ((b0 and (not b1)) or (b1 and (not b0)));}
  Result:=(((x0-x1)*(w0-y1)-(y0-y1)*(v0-x1))*
           ((x0-x1)*(w1-y1)-(y0-y1)*(v1-x1))<=0) and
          (((v1-v0)*(y1-w0)-(w1-w0)*(x1-v0))*
           ((v1-v0)*(y0-w0)-(w1-w0)*(x0-v0))<=0);
end; {$endregion}

// Line Clipping:
function LineC    (var x0,y0,x1,y1:integer; constref rct_clp:TPtRect): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x: array[0..1] of integer;
  y: array[0..1] of integer;
  i: byte;
begin
  Result:=False;
  if ((not ((x0<rct_clp.left) and (x1<rct_clp.left))) and (not ((x0>rct_clp.right ) and (x1>rct_clp.right )))) and
     ((not ((y0<rct_clp.top ) and (y1<rct_clp.top ))) and (not ((y0>rct_clp.bottom) and (y1>rct_clp.bottom)))) then
    begin
      x[0]:=x0;
      y[0]:=y0;
      x[1]:=x1;
      y[1]:=y1;
      i   :=0;
      repeat
        begin
          if (x[i]<rct_clp.left) then
            begin
              x[i]:=rct_clp.left;
              y[i]:=Trunc(((y1-y0)*(rct_clp.left  -x0))/(x1-x0)+y0);
            end
          else
          if (x[i]>rct_clp.right) then
            begin
              x[i]:=rct_clp.right;
              y[i]:=Trunc(((y1-y0)*(rct_clp.right -x0))/(x1-x0)+y0);
            end;
          if (y[i]<rct_clp.top) then
            begin
              y[i]:=rct_clp.top;
              x[i]:=Trunc(((x1-x0)*(rct_clp.top   -y0))/(y1-y0)+x0);
            end
          else
          if (y[i]>rct_clp.bottom) then
            begin
              y[i]:=rct_clp.bottom;
              x[i]:=Trunc(((x1-x0)*(rct_clp.bottom-y0))/(y1-y0)+x0);
            end;
          i:=i+1;
        end;
      until (i>1);
      if (not ((x[0]<rct_clp.left ) and (x[1]<rct_clp.left ))) and
         (not ((x[0]>rct_clp.right) and (x[1]>rct_clp.right))) then
        begin
          Result:=True;
          x0    :=x[0];
          y0    :=y[0];
          x1    :=x[1];
          y1    :=y[1];
        end;
    end;
end; {$endregion}

// Monochrome Horizontal Line(Width - 1 pixel):
function  LineHC  (var x0,y0,x1:integer; constref rct_clp:TPtRect): boolean;                                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_clp: array[0..7] of boolean;
  clp    : qword absolute arr_clp;
  x2     : integer;
begin
  Result:=True;
  if (y0<rct_clp.top) or (y0>=rct_clp.bottom) then
    begin
      Result:=False;
      Exit;
    end;
  if (x0>x1) then
    begin
      x2:=x1;
      x1:=x0;
      x0:=x2;
    end;
  arr_clp[00]:=(x0< rct_clp.left  );
  arr_clp[01]:=(x0>=rct_clp.left  ) and (x0<rct_clp.right);
  arr_clp[02]:=(x0>=rct_clp.right );
  arr_clp[03]:=(x1< rct_clp.left  );
  arr_clp[04]:=(x1>=rct_clp.left  ) and (x1<rct_clp.right);
  arr_clp[05]:=(x1>=rct_clp.right );
  arr_clp[06]:=False;
  arr_clp[07]:=False;
  case clp of
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000000000000000000001000000000000000000000001:
      begin
        Result:=False;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000000000000100000000000000000000000000000001:
      begin
        x0    :=rct_clp.left;
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000010000000000000000000000000000000000000001:
      begin
        x0    :=rct_clp.left;
        x1    :=rct_clp.right-1;
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000000000000100000000000000000000000100000000:
      begin
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000010000000000000000000000000000000100000000:
      begin
        x1    :=rct_clp.right-1;
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000010000000000000000000000010000000000000000:
      begin
        Result:=False;
        Exit;
      end;
  end;
end; {$endregion}
procedure LineH   (    x0,y0,x1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FillDWord((bmp_dst_ptr+x0+y0*bmp_dst_width)^,x1-x0+1,color_info.pix_col);
end; {$endregion}
procedure LineH   (    x0,y0,x1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref val       :TColor    ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FillDWord((bmp_dst_ptr+x0+y0*bmp_dst_width)^,x1-x0+1,val);
end; {$endregion}
procedure LineH   (    x0,y0,x1:integer; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width:TColor; constref val       :byte      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FillByte((bmp_dst_ptr+x0+y0*bmp_dst_width)^,x1-x0+1,val);
end; {$endregion}

// Monochrome Vertical Line(Width - 1 pixel):
function  LineVC  (var x0,y0,y1:integer; constref rct_clp:TPtRect): boolean;                                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_clp: array[0..7] of boolean;
  clp    : qword absolute arr_clp;
  y2     : integer;
begin
  Result:=True;
  if (x0<rct_clp.left) or (x0>=rct_clp.right) then
    begin
      Result:=False;
      Exit;
    end;
  if (y0>y1) then
    begin
      y2:=y1;
      y1:=y0;
      y0:=y2;
    end;
  arr_clp[00]:=(y0< rct_clp.top   );
  arr_clp[01]:=(y0>=rct_clp.top   ) and (y0<rct_clp.bottom);
  arr_clp[02]:=(y0>=rct_clp.bottom);
  arr_clp[03]:=(y1< rct_clp.top   );
  arr_clp[04]:=(y1>=rct_clp.top   ) and (y1<rct_clp.bottom);
  arr_clp[05]:=(y1>=rct_clp.bottom);
  arr_clp[06]:=False;
  arr_clp[07]:=False;
  case clp of
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000000000000000000001000000000000000000000001:
      begin
        Result:=False;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000000000000100000000000000000000000000000001:
      begin
        y0    :=rct_clp.top;
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000010000000000000000000000000000000000000001:
      begin
        y0    :=rct_clp.top;
        y1    :=rct_clp.bottom-1;
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000000000000100000000000000000000000100000000:
      begin
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000010000000000000000000000000000000100000000:
      begin
        y1    :=rct_clp.bottom-1;
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000010000000000000000000000010000000000000000:
      begin
        Result:=False;
        Exit;
      end;
  end;
end; {$endregion}
procedure LineV   (    x0,y0,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_ptr: PInteger;
  i     : integer;
begin
  ln_ptr:=bmp_dst_ptr+x0+y0*bmp_dst_width;
  for i:=0 to y1-y0 do
    begin
      ln_ptr^:=color_info.pix_col;
      Inc(ln_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure LineV   (    x0,y0,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref val       :TColor    ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_ptr: PInteger;
  i     : integer;
begin
  ln_ptr:=bmp_dst_ptr+x0+y0*bmp_dst_width;
  for i:=0 to y1-y0 do
    begin
      ln_ptr^:=val;
      Inc(ln_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure LineV   (    x0,y0,y1:integer; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width:TColor; constref val       :byte      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_ptr: PByte;
  i     : integer;
begin
  ln_ptr:=bmp_dst_ptr+x0+y0*bmp_dst_width;
  for i:=0 to y1-y0 do
    begin
      ln_ptr^:=val;
      Inc(ln_ptr,bmp_dst_width);
    end;
end; {$endregion}

// Monochrome Antialiased Line(Width - 1 pixel):
procedure LineA   (    x0,y0,x1,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo; alpha_max:byte=255      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  dx,dy,dydx                                         : double;
  df,deltax,deltay,loop,start,finish,dx_,dy_,loop_cnt: integer;
begin
  with color_info do
    begin
      deltax:=Abs(x1-x0);
      deltay:=Abs(y1-y0);
      {if (deltax=0) or (deltay=0) then
        Exit;}
      if (deltax>deltay) then
        begin
          if (y1>y0) then
            dydx:=-deltay/deltax
          else
            dydx:= deltay/deltax;
          if (x1<x0) then
            begin
              start :=x1;
              finish:=x0;
              dy    :=y1;
            end
          else
            begin
              start :=x0;
              finish:=x1;
              dy    :=y0;
              dydx  :=-dydx;
            end;
          for loop:=start to finish do
            begin
              dy_:=Trunc(dy);
              df :=Trunc(alpha_max*(dy-dy_));       //255*dy_0+255*loop*([deltay/deltax]+{deltay/deltax})=255*(dy_0+loop)+255*loop*{deltay/deltax}
              AlphaBlend(bmp_dst_ptr+loop+(dy_+0)*bmp_dst_width,r,g,b,          df);
              AlphaBlend(bmp_dst_ptr+loop+(dy_+1)*bmp_dst_width,r,g,b,alpha_max-df);
              dy+=dydx;
            end;
        end
      else
        begin
          if (x1>x0) then
            dydx:=-deltax/deltay
          else
            dydx:= deltax/deltay;
          if (y1<y0) then
            begin
              start :=y1;
              finish:=y0;
              dx    :=x1;
            end
          else
            begin
              start :=y0;
              finish:=y1;
              dx    :=x0;
              dydx  :=-dydx;
            end;
          loop_cnt:=start*bmp_dst_width;
          for loop:=start to finish do
            begin
              dx_:=Trunc(dx);
              df :=Trunc(alpha_max*(dx-dx_));
              AlphaBlend(bmp_dst_ptr+dx_+loop_cnt+0,r,g,b,          df);
              AlphaBlend(bmp_dst_ptr+dx_+loop_cnt+1,r,g,b,alpha_max-df);
              Inc(loop_cnt,bmp_dst_width);
              dx+=dydx;
            end;
        end;
    end;
end; {$endregion}
procedure LineAC  (var x0,y0,x1,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo; constref rct_clp:TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (y0=y1) then
    begin
      // Line Clipping:
      if LineHC(x0,y0,x1,rct_clp) then
        // Line Drawing:
        LineH(x0,y0,x1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
    end
  else
    begin
      // Line Clipping:
      if LineC(x0,y0,x1,y1,rct_clp) then
        // Line Drawing:
        LineA(x0,y0,x1,y1,bmp_dst_ptr,bmp_dst_width,color_info);
    end;
end; {$endregion}

// Monochrome Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineABC (constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo; constref rct_clp:TPtRect; constref shift:TPtPos; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr            : PPtPosF;
  x0,y0,x1,y1,i,d_ind: integer;
begin
  d_ind:=end_ind-start_ind;
  if (d_ind=0) then
    Exit;
  pts_ptr:=Unaligned(@pts[start_ind]);
  for i:=0 to d_ind-1 do
    begin
      x0:=Trunc((pts_ptr+0)^.x)+shift.x;
      y0:=Trunc((pts_ptr+0)^.y)+shift.y;
      x1:=Trunc((pts_ptr+1)^.x)+shift.x;
      y1:=Trunc((pts_ptr+1)^.y)+shift.y;
      if (y0=y1) then
        begin
          // Line Clipping:
          if LineHC(x0,y0,x1,rct_clp) then
            // Line Drawing:
            LineH(x0,y0,x1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        end
      else
        begin
          // Line Clipping:
          if LineC(x0,y0,x1,y1,rct_clp) then
            // Line Drawing:
            LineA(x0,y0,x1,y1,bmp_dst_ptr,bmp_dst_width,color_info);
        end;
      Inc(pts_ptr);
    end;
  if exp_ then
    begin
      pts_ptr:=Unaligned(@pts[start_ind]);
      x0     :=Trunc((pts_ptr+00000)^.x)+shift.x;
      y0     :=Trunc((pts_ptr+00000)^.y)+shift.y;
      x1     :=Trunc((pts_ptr+d_ind)^.x)+shift.x;
      y1     :=Trunc((pts_ptr+d_ind)^.y)+shift.y;
      if (y0=y1) then
        begin
          // Line Clipping:
          if LineHC(x0,y0,x1,rct_clp) then
            // Line Drawing:
            LineH(x0,y0,x1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        end
      else
        begin
          // Line Clipping:
          if LineC(x0,y0,x1,y1,rct_clp) then
            // Line Drawing:
            LineA(x0,y0,x1,y1,bmp_dst_ptr,bmp_dst_width,color_info);
        end;
    end;
end; {$endregion}

// Gradient(Highlight) Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineABCG(constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; var      color_info:TColorInfo; constref rct_clp:TPtRect; constref shift:TPtPos; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr              : PPtPosF;
  x0,y0,x1,y1,i,d_ind,p: integer;
  pix_col              : TColor;
begin
  d_ind:=end_ind-start_ind;
  if (d_ind=0) then
    Exit;
  p      :=0;
  pix_col:=color_info.pix_col;
  pts_ptr:=Unaligned(@pts[start_ind]);
  for i:=0 to d_ind-1 do
    begin
      x0:=Trunc((pts_ptr+0)^.x)+shift.x;
      y0:=Trunc((pts_ptr+0)^.y)+shift.y;
      x1:=Trunc((pts_ptr+1)^.x)+shift.x;
      y1:=Trunc((pts_ptr+1)^.y)+shift.y;
      SetColorInfo(Highlight(pix_col,0,0,0,0,0,p),color_info,False);
      if (y0=y1) then
        begin
          // Line Clipping:
          if LineHC(x0,y0,x1,rct_clp) then
            // Line Drawing:
            LineH(x0,y0,x1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        end
      else
        begin
          // Line Clipping:
          if LineC(x0,y0,x1,y1,rct_clp) then
            // Line Drawing:
            LineA(x0,y0,x1,y1,bmp_dst_ptr,bmp_dst_width,color_info);
        end;
      Inc(p);
      Inc(pts_ptr);
    end;
  if exp_ then
    begin
      pts_ptr:=Unaligned(@pts[start_ind]);
      x0     :=Trunc((pts_ptr+00000)^.x)+shift.x;
      y0     :=Trunc((pts_ptr+00000)^.y)+shift.y;
      x1     :=Trunc((pts_ptr+d_ind)^.x)+shift.x;
      y1     :=Trunc((pts_ptr+d_ind)^.y)+shift.y;
      SetColorInfo(Highlight(pix_col,0,0,0,0,0,p),color_info,False);
      if (y0=y1) then
        begin
          // Line Clipping:
          if LineHC(x0,y0,x1,rct_clp) then
            // Line Drawing:
            LineH(x0,y0,x1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        end
      else
        begin
          // Line Clipping:
          if LineC(x0,y0,x1,y1,rct_clp) then
            // Line Drawing:
            LineA(x0,y0,x1,y1,bmp_dst_ptr,bmp_dst_width,color_info);
        end;
    end;
end; {$endregion}

// Equidistant Line(Width - 1 pixel):
function  LineE1  (constref v0,w0,v1,w1,rad:double): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k,d,l0,l1: double;
begin
  with Result do
    begin
      if (v1=v0) then
        begin
          x0:=v0-rad;
          y0:=w0;
          x1:=x0;
          y1:=w1;
          Exit;
        end
      else
        begin
          if (w1=w0) then
            begin
              x0:=v0;
              y0:=w0-rad;
              x1:=v1;
              y1:=y0;
              Exit;
            end;
          k :=(w1-w0)/(v1-v0);
          d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
          l0:=rad*d*k;
          l1:=rad*d  ;
          x0:=v0-l0;
          y0:=w0+l1;
          x1:=v1-l0;
          y1:=w1+l1;
        end;
    end;
end; {$endregion}
function  LineE2  (constref v0,w0,v1,w1,rad:double): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k,d,l0,l1: double;
begin
  with Result do
    begin
      if (v1=v0) then
        begin
          x0:=v0+rad;
          y0:=w0;
          x1:=x0;
          y1:=w1;
          Exit;
        end
      else
        begin
          if (w1=w0) then
            begin
              x0:=v0;
              y0:=w0+rad;
              x1:=v1;
              y1:=y0;
              Exit;
            end;
          k :=(w1-w0)/(v1-v0);
          d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
          l0:=rad*d*k;
          l1:=rad*d  ;
          x0:=v0+l0;
          y0:=w0-l1;
          x1:=v1+l0;
          y1:=w1-l1;
        end;
    end;
end; {$endregion}

// Equidistant Curve for Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineABCE(constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo; constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    {if (Abs(x1-x0){*(x1-x0)}+Abs(y1-y0){*(y1-y0)}<2) then
      begin
        Inc(pts_ptr);
        Continue;
      end;}
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=x1-rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          LineA(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        v0:=x0+rad;
        w0:=y0;
        v1:=x1+rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          LineA(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          LineA(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          LineA(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            color_info.pix_col);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (end_ind-start_ind>0) then
    CircProc(d_ind);
end; {$endregion}

// Equidistant Curve for Not Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineBCE (constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo; constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    {if (Abs(x1-x0){*(x1-x0)}+Abs(y1-y0){*(y1-y0)}<2) then
      begin
        Inc(pts_ptr);
        Continue;
      end;}
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=x1-rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        v0:=x0+rad;
        w0:=y0;
        v1:=x1+rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            color_info.pix_col);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (end_ind-start_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE (constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref val       :TColor    ; constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=x1-rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        v0:=x0+rad;
        w0:=y0;
        v1:=x1+rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            val);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (end_ind-start_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE (constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width:TColor; constref val       :byte      ; constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=x1-rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        v0:=x0+rad;
        w0:=y0;
        v1:=x1+rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            val);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (end_ind-start_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE (constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor;                                 constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  pt_ind     : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0    :=Trunc((pts_ptr+i)^.x)+shift.x;
    y0    :=Trunc((pts_ptr+i)^.y)+shift.y;
    x1    :=Trunc((pts_ptr+j)^.x)+shift.x;
    y1    :=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=x1-rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0:=x0+rad;
        w0:=y0;
        v1:=x1+rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            pt_ind);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    begin
      pt_ind:=start_ind+i+1;
      LineProc(0,1);
    end;
  pts_ptr :=pts_ptr1;
  if exp_ then
    begin
      pt_ind:=-(start_ind+1);
      LineProc(0,d_ind);
    end;
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    begin
      pt_ind:=start_ind+i+1;
      CircProc(i);
    end;
  pts_ptr :=pts_ptr1;
  if (end_ind-start_ind>0) then
    begin
      pt_ind:=end_ind+1;
      CircProc(d_ind);
    end;
end; {$endregion}

// Equidistant Curve for Not Antialiased Broken Clipped Line(Width - 2 pixel):
procedure LineBCE2(constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo; constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end;
        v0:=x0+rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end;
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info);
              end;
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info);
              end;
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end;
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end;
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            color_info.pix_col);
    if (rad>1) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-1,
              bmp_dst_ptr,
              rct_clp,
              bmp_dst_width,
              color_info.pix_col);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (d_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE2(constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref val       :TColor    ; constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
        v0:=x0+rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end;
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end;
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            val);
    if (rad>1) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-1,
              bmp_dst_ptr,
              rct_clp,
              bmp_dst_width,
              val);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (d_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE2(constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width:TColor; constref val       :byte      ; constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
        v0:=x0+rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end;
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end;
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            val);
    if (rad>1) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-1,
              bmp_dst_ptr,
              rct_clp,
              bmp_dst_width,
              val);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (d_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE2(constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor;                                 constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  pt_ind     : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end;
        v0:=x0+rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end;
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
              end;
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
              end;
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end;
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end;
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            pt_ind);
    if (rad>1) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-1,
              bmp_dst_ptr,
              rct_clp,
              bmp_dst_width,
              pt_ind);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (d_ind>0) then
    CircProc(d_ind);
end; {$endregion}

// Equidistant Curve for Not Antialiased Broken Clipped Line(Width - 3 pixel):
procedure LineBCE3(constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo; constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0+rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        v0+=1;
        v1+=1;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        v0-=2;
        v1-=2;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        v0:=x0-rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        v0+=1;
        v1+=1;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        v0-=2;
        v1-=2;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            w0+=1;
            w1+=1;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            w0-=2;
            w1-=2;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            w0+=1;
            w1+=1;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            w0-=2;
            w1-=2;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );

        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            w0-=2;
            w1-=2;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
          end;

        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            w0-=2;
            w1-=2;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            v0-=2;
            v1-=2;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
          end;

      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            color_info.pix_col);
    if (rad>1) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-1,
              bmp_dst_ptr,
              rct_clp,
              bmp_dst_width,
              color_info.pix_col);
    if (rad>2) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-2,
              bmp_dst_ptr,
              rct_clp,
              bmp_dst_width,
              color_info.pix_col);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (d_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE3(constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor;                                 constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  pt_ind     : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0+rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0+=1;
        v1+=1;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0-=2;
        v1-=2;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0:=x0-rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0+=1;
        v1+=1;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0-=2;
        v1-=2;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            w0+=1;
            w1+=1;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            w0-=2;
            w1-=2;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            w0+=1;
            w1+=1;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            w0-=2;
            w1-=2;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            w0-=2;
            w1-=2;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end;
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            w0-=2;
            w1-=2;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            v0-=2;
            v1-=2;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end;
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  {var
    a,x,n: integer;}
  begin
    {if rad<(n>>1)+2 then
      Exit;
    if Odd(n) then
      a:=1
    else
      a:=0;
    for x:=-(n>>1) to (n>>1)-a do
      CircleC
      (
        Trunc((pts_ptr+i)^.x)+shift.x,
        Trunc((pts_ptr+i)^.y)+shift.y,
        rad+x,
        bmp_dst_ptr,
        rct_clp,
        bmp_dst_width,
        pt_ind
      );}
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            pt_ind);
    if (rad>1) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-1,
              bmp_dst_ptr,
              rct_clp,
              bmp_dst_width,
              pt_ind);
    if (rad>2) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-2,
              bmp_dst_ptr,
              rct_clp,
              bmp_dst_width,
              pt_ind);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    begin
      pt_ind:=start_ind+i+1;
      LineProc(0,1);
    end;
  pts_ptr :=pts_ptr1;
  if exp_ then
    begin
      pt_ind:=-(start_ind+1);
      LineProc(0,d_ind);
    end;
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    begin
      pt_ind:=start_ind+i+1;
      CircProc(i);
    end;
  pts_ptr :=pts_ptr1;
  if (end_ind-start_ind>0) then
    begin
      pt_ind:=end_ind+1;
      CircProc(d_ind);
    end;
end; {$endregion}

// Monochrome Resilient Line(Width - 1 pixel):
procedure LineR   (constref x0,y0,x1,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo; constref seg_cnt:TColor); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,dx,dy: double;
  i        : integer;
begin
      x:=x0;
      y:=y0;
  if (x1>x0) then
    begin
      dx:=(x1-x0)/seg_cnt;
      if  (y1>y0) then
        begin
          dy:=(y1-y0)/seg_cnt;
          for i:=0 to seg_cnt-2 do
            begin
              x+=dx;
              y+=dy;
              Point(Trunc(x),
                    Trunc(y),
                    bmp_dst_ptr,
                    bmp_dst_width,
                    color_info);
            end;
        end
      else
        begin
          dy:=(y0-y1)/seg_cnt;
          for i:=0 to seg_cnt-2 do
            begin
              x+=dx;
              y-=dy;
              Point(Trunc(x),
                    Trunc(y),
                    bmp_dst_ptr,
                    bmp_dst_width,
                    color_info);
            end;
        end;
    end
  else
    begin
      dx:=(x0-x1)/seg_cnt;
      if  (y1>y0) then
        begin
          dy:=(y1-y0)/seg_cnt;
          for i:=0 to seg_cnt-2 do
            begin
              x-=dx;
              y+=dy;
              Point(Trunc(x),
                    Trunc(y),
                    bmp_dst_ptr,
                    bmp_dst_width,
                    color_info);
            end;
        end
      else
        begin
          dy:=(y0-y1)/seg_cnt;
          for i:=0 to seg_cnt-2 do
            begin
              x-=dx;
              y-=dy;
              Point(Trunc(x),
                    Trunc(y),
                    bmp_dst_ptr,
                    bmp_dst_width,
                    color_info);
            end;
        end;
    end;
end; {$endregion}

// Point:
procedure Point        (constref x,y:integer; constref bmp_dst_ptr  :PInteger; constref bmp_dst_width:TColor    ; constref color_info:TColorInfo);                                                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pixel_ptr: PInteger;
begin
  with color_info do
    begin
      pixel_ptr:=bmp_dst_ptr+(x-1)+bmp_dst_width*(y-1);
      AlphaBlend(pixel_ptr,r,g,b,alpha1);
      Inc(pixel_ptr);
      AlphaBlend(pixel_ptr,r,g,b,alpha2);
      Inc(pixel_ptr);
      AlphaBlend(pixel_ptr,r,g,b,alpha1);
      Inc(pixel_ptr,bmp_dst_width-2);
      AlphaBlend(pixel_ptr,r,g,b,alpha2);
      Inc(pixel_ptr);
      pixel_ptr^:=pix_col;
      Inc(pixel_ptr);
      AlphaBlend(pixel_ptr,r,g,b,alpha2);
      Inc(pixel_ptr,bmp_dst_width-2);
      AlphaBlend(pixel_ptr,r,g,b,alpha1);
      Inc(pixel_ptr);
      AlphaBlend(pixel_ptr,r,g,b,alpha2);
      Inc(pixel_ptr);
      AlphaBlend(pixel_ptr,r,g,b,alpha1);
    end;
end; {$endregion}
procedure Point        (constref x,y:integer; constref bmp_dst_ptr  :PInteger; constref bmp_dst_width:TColor    ; constref color_info:TColorInfo; constref clip_rect:TPtRect);                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pixel_ptr: PInteger;
begin
  with clip_rect,color_info do
    if (x-1>left  ) and
       (x+1<right ) and
       (y-1>top   ) and
       (y+1<bottom) then
      begin
        pixel_ptr:=bmp_dst_ptr+(x-1)+bmp_dst_width*(y-1);
        AlphaBlend(pixel_ptr,r,g,b,alpha1);
        Inc(pixel_ptr);
        AlphaBlend(pixel_ptr,r,g,b,alpha2);
        Inc(pixel_ptr);
        AlphaBlend(pixel_ptr,r,g,b,alpha1);
        Inc(pixel_ptr,bmp_dst_width-2);
        AlphaBlend(pixel_ptr,r,g,b,alpha2);
        Inc(pixel_ptr);
        pixel_ptr^:=pix_col;
        Inc(pixel_ptr);
        AlphaBlend(pixel_ptr,r,g,b,alpha2);
        Inc(pixel_ptr,bmp_dst_width-2);
        AlphaBlend(pixel_ptr,r,g,b,alpha1);
        Inc(pixel_ptr);
        AlphaBlend(pixel_ptr,r,g,b,alpha2);
        Inc(pixel_ptr);
        AlphaBlend(pixel_ptr,r,g,b,alpha1);
    end;
end; {$endregion}
procedure Point        (constref x,y:integer; constref bmp_dst_ptr  :PInteger; constref bmp_dst_width:TColor    ; constref color_info:TColorInfo; constref clip_rect:TPtRect; constref alpha_fade:byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pixel_ptr: PInteger;
begin
  with clip_rect,color_info do
    if (x-1>left  ) and
       (x+1<right ) and
       (y-1>top   ) and
       (y+1<bottom) then
      begin
        pixel_ptr:=bmp_dst_ptr+(x-1)+bmp_dst_width*(y-1);
        AlphaBlendDec(pixel_ptr,r,g,b,alpha2,alpha_fade);
        Inc(pixel_ptr);
        AlphaBlendDec(pixel_ptr,r,g,b,alpha1,alpha_fade);
        Inc(pixel_ptr);
        AlphaBlendDec(pixel_ptr,r,g,b,alpha2,alpha_fade);
        Inc(pixel_ptr,bmp_dst_width-2);
        AlphaBlendDec(pixel_ptr,r,g,b,alpha1,alpha_fade);
        Inc(pixel_ptr);
        AlphaBlendDec(pixel_ptr,r,g,b,255   ,alpha_fade);
        Inc(pixel_ptr);
        AlphaBlendDec(pixel_ptr,r,g,b,alpha1,alpha_fade);
        Inc(pixel_ptr,bmp_dst_width-2);
        AlphaBlendDec(pixel_ptr,r,g,b,alpha2,alpha_fade);
        Inc(pixel_ptr);
        AlphaBlendDec(pixel_ptr,r,g,b,alpha1,alpha_fade);
        Inc(pixel_ptr);
        AlphaBlendDec(pixel_ptr,r,g,b,alpha2,alpha_fade);
    end;
end; {$endregion}
function  PointCollDraw(constref x,y:integer; constref arr_src_width:TColor  ; var      arr_src      :T1Byte1Arr; constref clip_rect :TPtRect): boolean;                                                 inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with clip_rect do
    if (x>left  ) and
       (x<right ) and
       (y>top   ) and
       (y<bottom) then
      begin
        if (arr_src[x+arr_src_width*y]=0) then
          begin
            Result:=False;
            arr_src[x+arr_src_width*y]:=1;
          end
        else
          Result:=True;
      end;
end; {$endregion}
function  PointCollDraw(constref x,y:integer; constref arr_src_width:TColor  ; constref arr_src      :T1Byte1Arr; constref clip_rect :TPtRect; constref b:byte): boolean;                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with clip_rect do
    if (x>clip_rect.left  ) and
       (x<clip_rect.right ) and
       (y>clip_rect.top   ) and
       (y<clip_rect.bottom) then
      Result:=(arr_src[x+arr_src_width*y]<>0);
end; {$endregion}

// Rectangle:
procedure SetRctDupId (var sln_prop_var:TCurveProp); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      dup_pts_id.arr[0]:=pts_rct_tns_left  ;
      dup_pts_id.arr[1]:=pts_rct_tns_top   ;
      dup_pts_id.arr[2]:=pts_rct_tns_right ;
      dup_pts_id.arr[3]:=pts_rct_tns_bottom;
      dup_pts_id.arr[4]:=pts_rct_inn_width ;
      dup_pts_id.arr[5]:=pts_rct_inn_height;
    end;
end; {$endregion}
procedure SetEdsWidth (var sln_prop_var:TCurveProp); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      eds_width_half:=Trunc(eds_width/2);
      if Odd(eds_width) then
        eds_width_odd:=0
      else
        eds_width_odd:=1;
    end;
end; {$endregion}
procedure SetRctWidth (var sln_prop_var:TCurveProp); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      pts_rct_width      :=pts_rct_tns_left +
                           pts_rct_tns_right+
                           pts_rct_inn_width;
      pts_rct_width__half:=pts_rct_width>>1;
      if Odd(pts_rct_width) then
        pts_rct_width__odd:=0
      else
        pts_rct_width__odd:=1;
      pts_width:=pts_rct_width;
    end;
end; {$endregion}
procedure SetRctHeight(var sln_prop_var:TCurveProp); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      pts_rct_height     :=pts_rct_tns_top   +
                           pts_rct_tns_bottom+
                           pts_rct_inn_height;
      pts_rct_height_half:=pts_rct_height>>1;
      if Odd(pts_rct_height) then
        pts_rct_height_odd:=0
      else
        pts_rct_height_odd:=1;
      pts_height:=pts_rct_height;
    end;
end; {$endregion}
procedure SetRctValues(var sln_prop_var:TCurveProp); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      rct_val_arr[0]:=-(pts_rct_inn_width >>1)-pts_rct_tns_left+pts_rct_width__odd;
      rct_val_arr[1]:=-(pts_rct_inn_height>>1)-pts_rct_tns_top +pts_rct_height_odd;
      rct_val_arr[2]:=+(pts_rct_inn_height>>1)+1;
      rct_val_arr[3]:=-(pts_rct_inn_height>>1)                 +pts_rct_height_odd;
      rct_val_arr[4]:=+(pts_rct_inn_width >>1)+1;
    end;
end; {$endregion}
procedure Rectangle   (constref x,y:integer; constref arr_dst_ptr:PInteger; constref arr_dst_width,arr_dst_height:TColor; constref rct_dst:TPtRect; constref sln_prop_var:TCurveProp                                   ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      // rct_top:
      PPFloodFill(arr_dst_ptr,
                  ClippedRct(rct_dst,
                             PtBounds(x+rct_val_arr[0],
                                      y+rct_val_arr[1],
                                      pts_rct_width,
                                      pts_rct_tns_top)),
                  arr_dst_width,
                  pts_col_inv);
      // rct_bottom:
      PPFloodFill(arr_dst_ptr,
                  ClippedRct(rct_dst,
                             PtBounds(x+rct_val_arr[0],
                                      y+rct_val_arr[2],
                                      pts_rct_width,
                                      pts_rct_tns_bottom)),
                  arr_dst_width,
                  pts_col_inv);
      // rct_left:
      PPFloodFill(arr_dst_ptr,
                  ClippedRct(rct_dst,
                             PtBounds(x+rct_val_arr[0],
                                      y+rct_val_arr[3],
                                      pts_rct_tns_left,
                                      pts_rct_inn_height)),
                  arr_dst_width,
                  pts_col_inv);
      // rct_right:
      PPFloodFill(arr_dst_ptr,
                  ClippedRct(rct_dst,
                             PtBounds(x+rct_val_arr[4],
                                      y+rct_val_arr[3],
                                      pts_rct_tns_right,
                                      pts_rct_inn_height)),
                  arr_dst_width,
                  pts_col_inv);
    end;
end; {$endregion}
procedure Rectangle   (constref x,y:integer; constref arr_dst_ptr:PInteger; constref arr_dst_width,arr_dst_height:TColor; constref rct_dst:TPtRect; constref sln_prop_var:TCurveProp; constref PPFloodFillProc:TProc4  ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      // rct_top:
      PPFloodFillProc(arr_dst_ptr,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[0],
                                          y+rct_val_arr[1],
                                          pts_rct_width,
                                          pts_rct_tns_top)),
                      arr_dst_width);
      // rct_bottom:
      PPFloodFillProc(arr_dst_ptr,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[0],
                                          y+rct_val_arr[2],
                                          pts_rct_width,
                                          pts_rct_tns_bottom)),
                      arr_dst_width);
      // rct_left:
      PPFloodFillProc(arr_dst_ptr,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[0],
                                          y+rct_val_arr[3],
                                          pts_rct_tns_left,
                                          pts_rct_inn_height)),
                      arr_dst_width);
      // rct_right:
      PPFloodFillProc(arr_dst_ptr,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[4],
                                          y+rct_val_arr[3],
                                          pts_rct_tns_right,
                                          pts_rct_inn_height)),
                      arr_dst_width);
    end;
end; {$endregion}
procedure Rectangle   (constref x,y:integer; constref arr_dst_ptr:PByte   ; constref arr_dst_width,arr_dst_height:TColor; constref rct_dst:TPtRect; constref sln_prop_var:TCurveProp; constref PPFloodFillProc:TProc4_1); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      // rct_top:
      PPFloodFillProc(arr_dst_ptr,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[0],
                                          y+rct_val_arr[1],
                                          pts_rct_width,
                                          pts_rct_tns_top)),
                      arr_dst_width);
      // rct_bottom:
      PPFloodFillProc(arr_dst_ptr,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[0],
                                          y+rct_val_arr[2],
                                          pts_rct_width,
                                          pts_rct_tns_bottom)),
                      arr_dst_width);
      // rct_left:
      PPFloodFillProc(arr_dst_ptr,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[0],
                                          y+rct_val_arr[3],
                                          pts_rct_tns_left,
                                          pts_rct_inn_height)),
                      arr_dst_width);
      // rct_right:
      PPFloodFillProc(arr_dst_ptr,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[4],
                                          y+rct_val_arr[3],
                                          pts_rct_tns_right,
                                          pts_rct_inn_height)),
                      arr_dst_width);
    end;
end; {$endregion}

// Rhombus:
{TODO}
procedure Rombus(constref x,y:integer;        constref bmp_dst_ptr:PInteger;                           constref bmp_dst_width:TColor; constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pixel_ptr: PInteger;
begin
  with color_info do
    begin

    end;
end; {$endregion}

// Circle Drawing(Midpoint Algorithm):
procedure Circle (constref x0,y0,rad:integer; constref bmp_dst_ptr:PInteger;                           constref bmp_dst_width:TColor; constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p   : PInteger;
  x,x1: integer;
  y,y1: integer;
  err : integer;
begin
  p   :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x   :=rad;
  y   :=0;
  err :=0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      (p+y-x1)^:=color_info.pix_col;
      (p+x-y1)^:=color_info.pix_col;
      (p+x+y1)^:=color_info.pix_col;
      (p+y+x1)^:=color_info.pix_col;
      (p-y+x1)^:=color_info.pix_col;
      (p-x+y1)^:=color_info.pix_col;
      (p-x-y1)^:=color_info.pix_col;
      (p-y-x1)^:=color_info.pix_col;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure Circle (constref x0,y0,rad:integer; constref bmp_dst_ptr:PInteger;                           constref bmp_dst_width:TColor; constref val       :TColor    ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p   : PInteger;
  x,x1: integer;
  y,y1: integer;
  err : integer;
begin
  p   :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x   :=rad;
  y   :=0;
  err :=0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      (p+y-x1)^:=val;
      (p+x-y1)^:=val;
      (p+x+y1)^:=val;
      (p+y+x1)^:=val;
      (p-y+x1)^:=val;
      (p-x+y1)^:=val;
      (p-x-y1)^:=val;
      (p-y-x1)^:=val;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure Circle (constref x0,y0,rad:integer; constref bmp_dst_ptr:PInteger;                           constref bmp_dst_width:TColor                                ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p   : PByte;
  x,x1: integer;
  y,y1: integer;
  err : integer;
begin
  p   :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x   :=rad;
  y   :=0;
  err :=0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      (p+y-x1)^+=1;
      (p+x-y1)^+=1;
      (p+x+y1)^+=1;
      (p+y+x1)^+=1;
      (p-y+x1)^+=1;
      (p-x+y1)^+=1;
      (p-x-y1)^+=1;
      (p-y-x1)^+=1;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure Circle (constref x0,y0,rad:integer; constref bmp_dst_ptr:PByte   ;                           constref bmp_dst_width:TColor; constref val       :byte      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p   : PByte;
  x,x1: integer;
  y,y1: integer;
  err : integer;
begin
  p   :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x   :=rad;
  y   :=0;
  err :=0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      (p+y-x1)^:=val;
      (p+x-y1)^:=val;
      (p+x+y1)^:=val;
      (p+y+x1)^:=val;
      (p-y+x1)^:=val;
      (p-x+y1)^:=val;
      (p-x-y1)^:=val;
      (p-y-x1)^:=val;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure Circle (constref x0,y0,rad:integer; constref bmp_dst_ptr:PByte   ;                           constref bmp_dst_width:TColor                                ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p   : PByte;
  x,x1: integer;
  y,y1: integer;
  err : integer;
begin
  p   :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x   :=rad;
  y   :=0;
  err :=0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      (p+y-x1)^+=1;
      (p+x-y1)^+=1;
      (p+x+y1)^+=1;
      (p+y+x1)^+=1;
      (p-y+x1)^+=1;
      (p-x+y1)^+=1;
      (p-x-y1)^+=1;
      (p-y-x1)^+=1;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure CircleC(constref x0,y0,rad:integer; constref bmp_dst_ptr:PInteger; constref rct_clp:TPtRect; constref bmp_dst_width:TColor; constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p          : PInteger;
  x,x1       : integer;
  y,y1       : integer;
  err        : integer;
  c0,c1,c2,c3: integer;
begin
  p  :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x  :=rad;
  y  :=0;
  err:=0;
  c0 := rct_clp.left  -x0;
  c1 := rct_clp.right -x0;
  c2 :=-rct_clp.top   +y0;
  c3 :=-rct_clp.bottom+y0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      if (y>=+c0) and (y<+c1) then
        begin
          if (x<=+c2) and (x>+c3) then
             (p+y-x1)^:=color_info.pix_col; //(x0+y)+(y0-x)*arr_dst_width
          if (x>=-c2) and (x<-c3) then
             (p+y+x1)^:=color_info.pix_col; //(x0+y)+(y0+x)*arr_dst_width
        end;
      if (x>=+c0) and (x<+c1) then
        begin
          if (y<=+c2) and (y>+c3) then
             (p+x-y1)^:=color_info.pix_col; //(x0+x)+(y0-y)*arr_dst_width
          if (y>=-c2) and (y<-c3) then
             (p+x+y1)^:=color_info.pix_col; //(x0+x)+(y0+y)*arr_dst_width
        end;
      if (y<=-c0) and (y>-c1) then
        begin
          if (x>=-c2) and (x<-c3) then
             (p-y+x1)^:=color_info.pix_col; //(x0-y)+(y0+x)*arr_dst_width
          if (x<=+c2) and (x>+c3) then
             (p-y-x1)^:=color_info.pix_col; //(x0-y)+(y0-x)*arr_dst_width
        end;
      if (x<=-c0) and (x>-c1) then
        begin
          if (y>=-c2) and (y<-c3) then
             (p-x+y1)^:=color_info.pix_col; //(x0-x)+(y0+y)*arr_dst_width
          if (y<=+c2) and (y>+c3) then
             (p-x-y1)^:=color_info.pix_col; //(x0-x)+(y0-y)*arr_dst_width
        end;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure CircleC(constref x0,y0,rad:integer; constref bmp_dst_ptr:PInteger; constref rct_clp:TPtRect; constref bmp_dst_width:TColor; constref val       :TColor    ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  p          : PInteger;
  rad2       : integer;
  f          : integer;
  d_x        : integer;
  d_y        : integer;
  x,x1       : integer;
  y,y1       : integer;
  c0,c1,c2,c3: integer;
begin
  p   :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  rad2:=rad-1;
  f   := 1-rad2;
  d_x := 0;
  d_y :=-(rad2<<1);
  x   :=0;
  y   :=rad2;
  c0  := rct_clp.left  -x0;
  c1  := rct_clp.right -x0;
  c2  :=-rct_clp.top   +y0;
  c3  :=-rct_clp.bottom+y0;
  (p+rad2*bmp_dst_width)^:=val;
  (p-rad2*bmp_dst_width)^:=val;
  (p+rad2              )^:=val;
  (p-rad2              )^:=val;
  while (x<y) do
    begin
      if (f>=0) then
        begin
          Dec(y);
          d_y+=2;
          f  +=d_y;
        end;
      Inc(x);
      d_x+=2;
      f  +=d_x+1;
      x1 :=x*bmp_dst_width;
      y1 :=y*bmp_dst_width;
      (p+x+y1)^:=val;
      (p-x+y1)^:=val;
      (p+x-y1)^:=val;
      (p-x-y1)^:=val;
      (p+y+x1)^:=val;
      (p-y+x1)^:=val;
      (p+y-x1)^:=val;
      (p-y-x1)^:=val;
    end;}
var
  p          : PInteger;
  x,x1       : integer;
  y,y1       : integer;
  err        : integer;
  c0,c1,c2,c3: integer;
begin
  p  :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x  :=rad;
  y  :=0;
  err:=0;
  c0 := rct_clp.left  -x0;
  c1 := rct_clp.right -x0;
  c2 :=-rct_clp.top   +y0;
  c3 :=-rct_clp.bottom+y0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      if (y>=+c0) and (y<+c1) then
        begin
          if (x<=+c2) and (x>+c3) then
             (p+y-x1)^:=val; //(x0+y)+(y0-x)*arr_dst_width
          if (x>=-c2) and (x<-c3) then
             (p+y+x1)^:=val; //(x0+y)+(y0+x)*arr_dst_width
        end;
      if (x>=+c0) and (x<+c1) then
        begin
          if (y<=+c2) and (y>+c3) then
             (p+x-y1)^:=val; //(x0+x)+(y0-y)*arr_dst_width
          if (y>=-c2) and (y<-c3) then
             (p+x+y1)^:=val; //(x0+x)+(y0+y)*arr_dst_width
        end;
      if (y<=-c0) and (y>-c1) then
        begin
          if (x>=-c2) and (x<-c3) then
             (p-y+x1)^:=val; //(x0-y)+(y0+x)*arr_dst_width
          if (x<=+c2) and (x>+c3) then
             (p-y-x1)^:=val; //(x0-y)+(y0-x)*arr_dst_width
        end;
      if (x<=-c0) and (x>-c1) then
        begin
          if (y>=-c2) and (y<-c3) then
             (p-x+y1)^:=val; //(x0-x)+(y0+y)*arr_dst_width
          if (y<=+c2) and (y>+c3) then
             (p-x-y1)^:=val; //(x0-x)+(y0-y)*arr_dst_width
        end;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure CircleC(constref x0,y0,rad:integer; constref bmp_dst_ptr:PInteger; constref rct_clp:TPtRect; constref bmp_dst_width:TColor                                ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p          : PInteger;
  x,x1       : integer;
  y,y1       : integer;
  err        : integer;
  c0,c1,c2,c3: integer;
begin
  p  :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x  :=rad;
  y  :=0;
  err:=0;
  c0 := rct_clp.left  -x0;
  c1 := rct_clp.right -x0;
  c2 :=-rct_clp.top   +y0;
  c3 :=-rct_clp.bottom+y0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      if (y>=+c0) and (y<+c1) then
        begin
          if (x<=+c2) and (x>+c3) then
             (p+y-x1)^+=1; //(x0+y)+(y0-x)*arr_dst_width
          if (x>=-c2) and (x<-c3) then
             (p+y+x1)^+=1; //(x0+y)+(y0+x)*arr_dst_width
        end;
      if (x>=+c0) and (x<+c1) then
        begin
          if (y<=+c2) and (y>+c3) then
             (p+x-y1)^+=1; //(x0+x)+(y0-y)*arr_dst_width
          if (y>=-c2) and (y<-c3) then
             (p+x+y1)^+=1; //(x0+x)+(y0+y)*arr_dst_width
        end;
      if (y<=-c0) and (y>-c1) then
        begin
          if (x>=-c2) and (x<-c3) then
             (p-y+x1)^+=1; //(x0-y)+(y0+x)*arr_dst_width
          if (x<=+c2) and (x>+c3) then
             (p-y-x1)^+=1; //(x0-y)+(y0-x)*arr_dst_width
        end;
      if (x<=-c0) and (x>-c1) then
        begin
          if (y>=-c2) and (y<-c3) then
             (p-x+y1)^+=1; //(x0-x)+(y0+y)*arr_dst_width
          if (y<=+c2) and (y>+c3) then
             (p-x-y1)^+=1; //(x0-x)+(y0-y)*arr_dst_width
        end;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure CircleC(constref x0,y0,rad:integer; constref bmp_dst_ptr:PByte   ; constref rct_clp:TPtRect; constref bmp_dst_width:TColor; constref val       :byte      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p          : PByte;
  x,x1       : integer;
  y,y1       : integer;
  err        : integer;
  c0,c1,c2,c3: integer;
begin
  p  :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x  :=rad;
  y  :=0;
  err:=0;
  c0 := rct_clp.left  -x0;
  c1 := rct_clp.right -x0;
  c2 :=-rct_clp.top   +y0;
  c3 :=-rct_clp.bottom+y0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      if (y>=+c0) and (y<+c1) then
        begin
          if (x<=+c2) and (x>+c3) then
             (p+y-x1)^:=val; //(x0+y)+(y0-x)*arr_dst_width
          if (x>=-c2) and (x<-c3) then
             (p+y+x1)^:=val; //(x0+y)+(y0+x)*arr_dst_width
        end;
      if (x>=+c0) and (x<+c1) then
        begin
          if (y<=+c2) and (y>+c3) then
             (p+x-y1)^:=val; //(x0+x)+(y0-y)*arr_dst_width
          if (y>=-c2) and (y<-c3) then
             (p+x+y1)^:=val; //(x0+x)+(y0+y)*arr_dst_width
        end;
      if (y<=-c0) and (y>-c1) then
        begin
          if (x>=-c2) and (x<-c3) then
             (p-y+x1)^:=val; //(x0-y)+(y0+x)*arr_dst_width
          if (x<=+c2) and (x>+c3) then
             (p-y-x1)^:=val; //(x0-y)+(y0-x)*arr_dst_width
        end;
      if (x<=-c0) and (x>-c1) then
        begin
          if (y>=-c2) and (y<-c3) then
             (p-x+y1)^:=val; //(x0-x)+(y0+y)*arr_dst_width
          if (y<=+c2) and (y>+c3) then
             (p-x-y1)^:=val; //(x0-x)+(y0-y)*arr_dst_width
        end;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure CircleC(constref x0,y0,rad:integer; constref bmp_dst_ptr:PByte   ; constref rct_clp:TPtRect; constref bmp_dst_width:TColor                                ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p          : PByte;
  x,x1       : integer;
  y,y1       : integer;
  err        : integer;
  c0,c1,c2,c3: integer;
begin
  p  :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x  :=rad;
  y  :=0;
  err:=0;
  c0 := rct_clp.left  -x0;
  c1 := rct_clp.right -x0;
  c2 :=-rct_clp.top   +y0;
  c3 :=-rct_clp.bottom+y0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      if (y>=+c0) and (y<+c1) then
        begin
          if (x<=+c2) and (x>+c3) then
             (p+y-x1)^+=1; //(x0+y)+(y0-x)*arr_dst_width
          if (x>=-c2) and (x<-c3) then
             (p+y+x1)^+=1; //(x0+y)+(y0+x)*arr_dst_width
        end;
      if (x>=+c0) and (x<+c1) then
        begin
          if (y<=+c2) and (y>+c3) then
             (p+x-y1)^+=1; //(x0+x)+(y0-y)*arr_dst_width
          if (y>=-c2) and (y<-c3) then
             (p+x+y1)^+=1; //(x0+x)+(y0+y)*arr_dst_width
        end;
      if (y<=-c0) and (y>-c1) then
        begin
          if (x>=-c2) and (x<-c3) then
             (p-y+x1)^+=1; //(x0-y)+(y0+x)*arr_dst_width
          if (x<=+c2) and (x>+c3) then
             (p-y-x1)^+=1; //(x0-y)+(y0-x)*arr_dst_width
        end;
      if (x<=-c0) and (x>-c1) then
        begin
          if (y>=-c2) and (y<-c3) then
             (p-x+y1)^+=1; //(x0-x)+(y0+y)*arr_dst_width
          if (y<=+c2) and (y>+c3) then
             (p-x-y1)^+=1; //(x0-x)+(y0-y)*arr_dst_width
        end;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}

// Wave Search:
function CircleW (constref x0,y0,rad:integer; constref arr_dst:TPtPos2Arr;                            constref arr_dst_width:TColor; var pt:TPtPosF): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p     : PPtPos2;
  x,x1  : integer;
  y,y1  : integer;
  err   : integer;
begin
  Result:=False;
  p     :=Unaligned(@arr_dst[x0+y0*arr_dst_width]);
  x     :=rad;
  y     :=0;
  err   :=0;
  while (x>=y) do
    begin
      x1:=x*arr_dst_width;
      y1:=y*arr_dst_width;
      if ((p+y-x1)^.obj_ind<>-1) then //(x0+y)+(y0-x)*arr_dst_width
        begin
          pt    :=PtPosF(x0+y,y0-x);
          Result:=True;
          Exit;
        end;
      if ((p+x-y1)^.obj_ind<>-1) then //(x0+x)+(y0-y)*arr_dst_width
        begin
          pt    :=PtPosF(x0+x,y0-y);
          Result:=True;
          Exit;
        end;
      if ((p+x+y1)^.obj_ind<>-1) then //(x0+x)+(y0+y)*arr_dst_width
        begin
          pt    :=PtPosF(x0+x,y0+y);
          Result:=True;
          Exit;
        end;
      if ((p+y+x1)^.obj_ind<>-1) then //(x0+y)+(y0+x)*arr_dst_width
        begin
          pt    :=PtPosF(x0+y,y0+x);
          Result:=True;
          Exit;
        end;
      if ((p-y+x1)^.obj_ind<>-1) then //(x0-y)+(y0+x)*arr_dst_width
        begin
          pt    :=PtPosF(x0-y,y0+x);
          Result:=True;
          Exit;
        end;
      if ((p-x+y1)^.obj_ind<>-1) then //(x0-x)+(y0+y)*arr_dst_width
        begin
          pt    :=PtPosF(x0-x,y0+y);
          Result:=True;
          Exit;
        end;
      if ((p-x-y1)^.obj_ind<>-1) then //(x0-x)+(y0-y)*arr_dst_width
        begin
          pt    :=PtPosF(x0-x,y0-y);
          Result:=True;
          Exit;
        end;
      if ((p-y-x1)^.obj_ind<>-1) then //(x0-y)+(y0-x)*arr_dst_width
        begin
          pt    :=PtPosF(x0-y,y0-x);
          Result:=True;
          Exit;
        end;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
function CircleWC(constref x0,y0,rad:integer; constref arr_dst:TPtPos2Arr;  constref rct_clp:TPtRect; constref arr_dst_width:TColor; var pt:TPtPosF): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p          : PPtPos2;
  x,x1       : integer;
  y,y1       : integer;
  err        : integer;
  c0,c1,c2,c3: integer;
begin
  Result:=False;
  p     :=Unaligned(@arr_dst[x0+y0*arr_dst_width]);
  x     :=rad;
  y     :=0;
  err   :=0;
  c0    := rct_clp.left  -x0;
  c1    := rct_clp.right -x0;
  c2    :=-rct_clp.top   +y0;
  c3    :=-rct_clp.bottom+y0;
  while (x>=y) do
    begin
      x1:=x*arr_dst_width;
      y1:=y*arr_dst_width;
      if (y>=+c0) and (y<+c1) then
        begin
          if (x<=+c2) and (x>+c3) and ((p+y-x1)^.obj_ind<>-1) then //(x0+y)+(y0-x)*arr_dst_width
            begin
              pt    :=PtPosF(x0+y,y0-x);
              Result:=True;
              Exit;
            end;
          if (x>=-c2) and (x<-c3) and ((p+y+x1)^.obj_ind<>-1) then //(x0+y)+(y0+x)*arr_dst_width
            begin
              pt    :=PtPosF(x0+y,y0+x);
              Result:=True;
              Exit;
            end;
        end;
      if (x>=+c0) and (x<+c1) then
        begin
          if (y<=+c2) and (y>+c3) and ((p+x-y1)^.obj_ind<>-1) then //(x0+x)+(y0-y)*arr_dst_width
            begin
              pt    :=PtPosF(x0+x,y0-y);
              Result:=True;
              Exit;
            end;
          if (y>=-c2) and (y<-c3) and ((p+x+y1)^.obj_ind<>-1) then //(x0+x)+(y0+y)*arr_dst_width
            begin
              pt    :=PtPosF(x0+x,y0+y);
              Result:=True;
              Exit;
            end;
        end;
      if (y<=-c0) and (y>-c1) then
        begin
          if (x>=-c2) and (x<-c3) and ((p-y+x1)^.obj_ind<>-1) then //(x0-y)+(y0+x)*arr_dst_width
            begin
              pt    :=PtPosF(x0-y,y0+x);
              Result:=True;
              Exit;
            end;
          if (x<=+c2) and (x>+c3) and ((p-y-x1)^.obj_ind<>-1) then //(x0-y)+(y0-x)*arr_dst_width
          begin
            pt    :=PtPosF(x0-y,y0-x);
            Result:=True;
            Exit;
          end;
        end;
      if (x<=-c0) and (x>-c1) then
        begin
          if (y>=-c2) and (y<-c3) and ((p-x+y1)^.obj_ind<>-1) then //(x0-x)+(y0+y)*arr_dst_width
            begin
              pt    :=PtPosF(x0-x,y0+y);
              Result:=True;
              Exit;
            end;
          if (y<=+c2) and (y>+c3) and ((p-x-y1)^.obj_ind<>-1) then //(x0-x)+(y0-y)*arr_dst_width
            begin
              pt    :=PtPosF(x0-x,y0-y);
              Result:=True;
              Exit;
            end;
        end;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}

// Circle FloodFill:
procedure CircleFloodFill(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref outer_rect:TPtRect; constref bmp_dst_width:TColor; constref color_info:TColorInfo; constref diam:TColor; constref pow:byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rect_dst : TPtRect;
  pixel_ptr: PInteger;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
  m        : byte;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  rad1_sqr :=rad1*rad1;
  rect_dst :=ClippedRct(outer_rect,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rect_dst.width=0) or (rect_dst.height=0) then
    Exit;
  rad2     :=x-rect_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y-rect_dst.top;
  d_width  :=bmp_dst_width -rect_dst.width;
  pixel_ptr:=bmp_dst_ptr   +rect_dst.left+rect_dst.top*bmp_dst_width;
  for j:=0 to rect_dst.height-1 do
    begin
      d_sqr:=(j-rad3)*(j-rad3)+rad2_sqr;
      for i:=0 to rect_dst.width-1 do
        begin
          dist_sqr:=i*i-rad2*i<<1+d_sqr;
          if (dist_sqr<rad1_sqr) and (pixel_ptr^>>24=0) then
            begin
              pixel_ptr^:=AlphaBlend(pixel_ptr^,
                                     color_info.r,
                                     color_info.g,
                                     color_info.b,
                                     0,
                                     pow)
                          {Highlight(pixel_ptr^,
                                     0,
                                     0,
                                     0,
                                     0,
                                     0,
                                     pow)};
              pixel_ptr^+=%00000001000000000000000000000000;
            end;
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}

// Spotlight:
procedure CircleHighlight(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref outer_rect:TPtRect; constref bmp_dst_width:TColor; constref color_info:TColorInfo; constref diam:TColor; constref pow:byte; alpha_max:byte=255); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rect_dst : TPtRect;
  pixel_ptr: PInteger;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
  m        : byte;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  rad1_sqr :=rad1*rad1;
  rect_dst :=ClippedRct(outer_rect,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rect_dst.width=0) or (rect_dst.height=0) then
    Exit;
  rad2     :=x-rect_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y-rect_dst.top;
  d_width  :=bmp_dst_width -rect_dst.width;
  pixel_ptr:=bmp_dst_ptr   +rect_dst.left+rect_dst.top*bmp_dst_width;
  for j:=0 to rect_dst.height-1 do
    begin
      d_sqr:=(j-rad3)*(j-rad3)+rad2_sqr;
      for i:=0 to rect_dst.width-1 do
        begin
          dist_sqr:=i*i-rad2*i<<1+d_sqr;
          if (dist_sqr<rad1_sqr) then
            begin
              m:=Max2(pow-Trunc(alpha_max*sqrt(dist_sqr)/rad1),0); // Abs(pow-Trunc(alpha_max*sqrt(dist_sqr)/rad1));
              if (m<>0) then
                pixel_ptr^:={ColorizeRMDec(pixel_ptr^,0,m)}{Darken(pixel_ptr^,0,0,0,0,0,m)}Highlight(pixel_ptr^,0,0,0,0,0,m);
            end;
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}

// (Transparent Text) Прозрачный текст:
procedure SetTextInfo(                      constref dst_canvas:TCanvas;                        constref height_:integer=27; constref font_color:TColor=$006C754A; constref font_name:string='AR CENA'; constref font_charset:TFontCharSet=ANSI_CHARSET; constref font_quality:TFontQuality=fqAntialiased; constref pen_mode:TFPPenMode=pmXor; constref brush_style:TFPBrushStyle=bsClear); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with dst_canvas do
    begin
      Font .height :=height_;
    //Font .size   :=height_;
      Font .color  :=font_color;
      Font .charset:=font_charset;
      Font .name   :=font_name;
      Font .quality:=font_quality;
      Pen  .mode   :=pen_mode;
      Brush.style  :=brush_style;
    end;
end; {$endregion}
procedure Text       (constref x,y:integer; constref dst_canvas:TCanvas; constref text_:string);                                                                                                                                                                                                                                                                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  dst_canvas.TextOut(x,y,text_);
end; {$endregion}
{$endregion}



(********************************** Blitters **********************************) {$region -fold}

// Get Bitmap Handle:
function  GetBmpHandle(bmp:Graphics.TBitmap): PInteger{pointer}; inline; {$region -fold}
var
  bmp_info: TBitmapInfo;
begin
  bmp_info.bmiHeader.biSize       :=SizeOf(BitmapInfo.bmiHeader);
  bmp_info.bmiHeader.biWidth      :=bmp.Width;
  bmp_info.bmiHeader.biHeight     :=-bmp.Height; // BitMap.Height will invert image on axis X
  bmp_info.bmiHeader.biPlanes     :=1;
  bmp_info.bmiHeader.biBitCount   :=32;
  bmp_info.bmiHeader.biCompression:=BI_RGB;
  bmp.Handle:=CreateDIBSection(bmp.Canvas.Handle,bmp_info,DIB_RGB_COLORS,GetBmpHandle,0,0);
end; {$endregion}
procedure GLBitmapInit(tex_id:TColor; bmp:Graphics.TBitmap; b:boolean); inline; {$region -fold}
begin
  if (not b) then
    glDisable(GL_TEXTURE_2D)
  else
    begin
      glEnable     (GL_TEXTURE_2D);
      glGenTextures(1,@tex_id);
      glBindTexture(GL_TEXTURE_2D,tex_id);
    end;
end; {$endregion}

// Copy One Canvas To Another:
procedure CnvToCnv(rct_dst:TPtRect; cnv_dst,cnv_src:TCanvas; copy_mode:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {$ifdef Windows}
  BitBlt
  (
    cnv_dst.Handle,
    rct_dst.left,
    rct_dst.top,
    rct_dst.width,
    rct_dst.height,
    cnv_src.Handle,
    0,
    0,
    copy_mode
  );
  {StretchBlt
  (
    cnv_dst.Handle,
    rct_dst.left,
    rct_dst.top,
    rct_dst.width,
    rct_dst.height,
    cnv_src.Handle,
    0,
    0,
    rct_dst.width,
    rct_dst.height,
    copy_mode
  );}
  {$else}
  cnv_dst.CopyMode:=copy_mode;
  cnv_dst.CopyRect
  (
    Rect
    (
      rct_dst.left,
      rct_dst.top,
      rct_dst.right,
      rct_dst.bottom
    ),
    cnv_src,
    Rect(0,0,rct_dst.width,rct_dst.height)
  );
  {$endif}
end; {$endregion}

// Blitter1:
procedure BitBlt1  (constref bmp_src_ptr,bmp_dst_ptr:PInteger ; constref rct_src:TPtRect;                             constref rct_dst_left,rct_dst_top,bmp_src_width,bmp_dst_width:integer); inline;                                {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  bits_per_line: integer;
  y            : integer;
begin
  bits_per_line:=rct_src.width<<2;
  src_pixel_ptr:=Unaligned(@bmp_src_ptr[rct_src.left+rct_src.top*bmp_src_width]);
  dst_pixel_ptr:=Unaligned(@bmp_dst_ptr[rct_dst_left+rct_dst_top*bmp_dst_width]);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1 do
    begin
      Move(src_pixel_ptr^,dst_pixel_ptr^,bits_per_line);
      Inc (src_pixel_ptr,bmp_src_width);
      Inc (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure BitBlt1  (constref bmp_src_ptr,bmp_dst_ptr:PInteger ; constref rct_src_left,rct_src_top,rct_src_width,rct_src_height,rct_dst_left,rct_dst_top,bmp_src_width,bmp_dst_width:integer); inline;                                {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  bits_per_line: integer;
  y            : integer;
begin
  bits_per_line:=rct_src_width<<2;
  src_pixel_ptr:=Unaligned(@bmp_src_ptr[rct_src_left+rct_src_top*bmp_src_width]);
  dst_pixel_ptr:=Unaligned(@bmp_dst_ptr[rct_dst_left+rct_dst_top*bmp_dst_width]);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src_height-1 do
    begin
      Move(src_pixel_ptr^,dst_pixel_ptr^,bits_per_line);
      Inc (src_pixel_ptr,bmp_src_width);
      Inc (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure BitBlt1  (var      arr_src                :TColorArr; constref                          rct_src_width,rct_src_height,rct_dst_left,rct_dst_top                            :integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_med       : TColorArr;
  arr_med_ptr   : PInteger;
  arr_src_ptr   : PInteger;
  bits_per_line : integer;
  y             : integer;
  arr_src_width : integer;
  arr_src_height: integer;
begin
  arr_src_width := rct_dst_left+rct_src_width;
  arr_src_height:= rct_dst_top +rct_src_height;
  SetLength     (  arr_med,    (rct_src_width*rct_src_height));
  arr_med       := arr_src;
  SetLength     (  arr_src     ,arr_src_width*arr_src_height);
  FillDWord     ( Unaligned(@arr_src[0])^,arr_src_width*arr_src_height,0);
  arr_med_ptr   :=Unaligned(@arr_med[00000000000000000000000000000000000000]);
  arr_src_ptr   :=Unaligned(@arr_src[rct_dst_left+rct_dst_top*arr_src_width]);
  bits_per_line := rct_src_width<<2;
  Prefetch(arr_med_ptr);
  Prefetch(arr_src_ptr);
  for y:=0 to rct_src_height-1 do
    begin
      Move(arr_med_ptr^,arr_src_ptr^,bits_per_line);
      Inc (arr_med_ptr,rct_src_width);
      Inc (arr_src_ptr,arr_src_width);
    end;
  SetLength(arr_med,0);
end; {$endregion}

// Blitter2:
procedure BitBlt2  (constref bmp_src_ptr,bmp_dst_ptr:PInteger ; constref rct_src:TPtRect;                             constref rct_dst_left,rct_dst_top,bmp_src_width,bmp_dst_width:integer); inline;                                {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(@bmp_src_ptr[rct_src.left+rct_src.width-1+(rct_src.top+rct_src.height-1)*bmp_src_width]);
  dst_pixel_ptr:=Unaligned(@bmp_dst_ptr[rct_dst_left+rct_src.width-1+(rct_dst_top+rct_src.height-1)*bmp_dst_width]);
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
              dst_pixel_ptr^:=
              src_pixel_ptr^;
          Dec(src_pixel_ptr);
          Dec(dst_pixel_ptr);
        end;
      Dec    (src_pixel_ptr,d_width1);
      Dec    (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
procedure BitBlt2  (constref bmp_src_ptr,bmp_dst_ptr:PInteger ; constref rct_src_left,rct_src_top,rct_src_width,rct_src_height,rct_dst_left,rct_dst_top,bmp_src_width,bmp_dst_width:integer); inline;                                {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  d_width1         :=bmp_src_width-rct_src_width;
  d_width2         :=bmp_dst_width-rct_src_width;
  src_pixel_ptr    :=Unaligned(@bmp_src_ptr[rct_src_left+rct_src_width-1+(rct_src_top+rct_src_height-1)*bmp_src_width]);
  dst_pixel_ptr    :=Unaligned(@bmp_dst_ptr[rct_dst_left+rct_src_width-1+(rct_dst_top+rct_src_height-1)*bmp_dst_width]);
  for y:=0 to rct_src_height-1 do
    begin
      for x:=0 to rct_src_width-1 do
        begin
              dst_pixel_ptr^:=
              src_pixel_ptr^;
          Dec(src_pixel_ptr);
          Dec(dst_pixel_ptr);
        end;
      Dec    (src_pixel_ptr,d_width1);
      Dec    (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
procedure BmpToBmp2(constref bmp_src_ptr,bmp_dst_ptr:PInteger ; constref bmp_src_width,bmp_dst_width:integer; constref clp_rct:TPtRect; constref inn_wnd_mrg_:integer);                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  BitBlt2(bmp_src_ptr,
          bmp_dst_ptr,
          clp_rct.left  -inn_wnd_mrg_,
          clp_rct.top   -inn_wnd_mrg_,
          clp_rct.width +inn_wnd_mrg_<<1,
          clp_rct.height+inn_wnd_mrg_<<1,
          clp_rct.left  -inn_wnd_mrg_,
          clp_rct.top   -inn_wnd_mrg_,
          bmp_src_width,
          bmp_dst_width);
end; {$endregion}

// Blitter3:
procedure BitBlt3  (constref bmp_src_ptr,bmp_dst_ptr:PInteger ; constref rct_src:TPtRect;                             constref rct_dst_left,rct_dst_top,bmp_src_width,bmp_dst_width:integer; transparent_color:TColor); inline; {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(@bmp_src_ptr[rct_src.left+rct_src.width-1+(rct_src.top+rct_src.height-1)*bmp_src_width]);
  dst_pixel_ptr:=Unaligned(@bmp_dst_ptr[rct_dst_left+rct_src.width-1+(rct_dst_top+rct_src.height-1)*bmp_dst_width]);
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
          if (src_pixel_ptr^<>transparent_color) then
              dst_pixel_ptr^:=src_pixel_ptr^;
          Dec(src_pixel_ptr);
          Dec(dst_pixel_ptr);
        end;
      Dec    (src_pixel_ptr,d_width1);
      Dec    (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
procedure BitBlt3  (constref bmp_src_ptr,bmp_dst_ptr:PInteger ; constref rct_src_left,rct_src_top,rct_src_width,rct_src_height,rct_dst_left,rct_dst_top,bmp_src_width,bmp_dst_width:integer; transparent_color:TColor); inline; {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  d_width1         :=bmp_src_width-rct_src_width;
  d_width2         :=bmp_dst_width-rct_src_width;
  src_pixel_ptr    :=Unaligned(@bmp_src_ptr[rct_src_left+rct_src_width-1+(rct_src_top+rct_src_height-1)*bmp_src_width]);
  dst_pixel_ptr    :=Unaligned(@bmp_dst_ptr[rct_dst_left+rct_src_width-1+(rct_dst_top+rct_src_height-1)*bmp_dst_width]);
  for y:=0 to rct_src_height-1 do
    begin
      for x:=0 to rct_src_width-1 do
        begin
          if (src_pixel_ptr^<>transparent_color) then
              dst_pixel_ptr^:=
              src_pixel_ptr^;
          Dec(src_pixel_ptr);
          Dec(dst_pixel_ptr);
        end;
      Dec    (src_pixel_ptr,d_width1);
      Dec    (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
{$endregion}



(****************************** Image Transform *******************************) {$region -fold}

// Scale:
procedure ImgScl(constref bmp_src_ptr:PInteger; constref bmp_dst_ptr:PInteger; constref bmp_dst_width,bmp_dst_height:TColor; constref ker_w,ker_h:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  bmp_src_ptr2: PInteger;
  bmp_src_ptr3: PInteger;
  bmp_dst_ptr2: PInteger;
  ker_prod_inv: double;
  ker_prod    : integer;
  ker_h_prod  : integer;
  ker_w_int   : integer;
  ker_h_int   : integer;
  d_width_ker : integer;
  width_j_prod: integer;
  w,h         : integer;
  x,y         : integer;
  i,j         : integer;
  r,g,b       : integer;
begin
  ker_w_int   :=ker_w-1;
  ker_h_int   :=ker_h-1;
  ker_prod    :=ker_w*ker_h;
  ker_prod_inv:=1/ker_prod;
  ker_h_prod  :=ker_h*bmp_dst_width;
  w           :=Trunc(bmp_dst_width /ker_w)-1;
  h           :=Trunc(bmp_dst_height/ker_h)-1;
  d_width_ker :=bmp_dst_width-w-1;
  bmp_src_ptr2:=bmp_src_ptr;
  bmp_dst_ptr2:=bmp_dst_ptr;
  for y:=0 to h do
    begin
      for x:=0 to w do
        begin
          bmp_src_ptr3:=Unaligned(bmp_src_ptr2+x*ker_w+y*ker_h_prod);
          width_j_prod:=0;
          r           :=0;
          for j:=0 to ker_h_int do
            begin
              for i:=0 to ker_w_int do
                r+=Red((bmp_src_ptr3+i+width_j_prod)^);
              Inc(width_j_prod,bmp_dst_width);
            end;
          width_j_prod:=0;
          g           :=0;
          for j:=0 to ker_h_int do
            begin
              for i:=0 to ker_w_int do
                g+=Green((bmp_src_ptr3+i+width_j_prod)^);
              Inc(width_j_prod,bmp_dst_width);
            end;
          width_j_prod:=0;
          b           :=0;
          for j:=0 to ker_h_int do
            begin
              for i:=0 to ker_w_int do
                b+=Blue((bmp_src_ptr3+i+width_j_prod)^);
              Inc(width_j_prod,bmp_dst_width);
            end;
          bmp_dst_ptr2^:=RGB(Trunc(r*ker_prod_inv),
                             Trunc(g*ker_prod_inv),
                             Trunc(b*ker_prod_inv));
          Inc(bmp_dst_ptr2);
        end;
      Inc(bmp_dst_ptr2,d_width_ker);
      //Application.ProcessMessages;
    end;
end; {$endregion}

{
procedure BlurLineX(src,dest:PInteger; w,rad,km:integer);
var
  c,x: integer;
begin
  c:=0;
  for x:=1 to rad-1 do
    c+=src[x];
  c+=c+src[0];
  for x:=0 to rad-1 do
    begin
      dest[x]:=c*km>>16;
      c+=src[rad+x+1];
      c-=src[rad-x];
    end;
  for x:=rad to w-rad-2 do
    begin
      dest[x]:=c*km>>16;
      c+=src[rad+x+1];
      c-=src[x-rad];
    end;
  for x:=w-rad-1 to w-1 do
    begin
      dest[x]:=c*km>>16;
      c+=src[w+w-x-rad-2];
      c-=src[x-rad];
    end;
end;

procedure BlurLineX(src,dest:PInteger; w,rad,km:integer);
var
  end_,dst_,beg_: PInteger;
  c        : integer;
begin
  end_:=src+1;
  dst_:=dest;
  c   :=0;
  while (end_<=src+rad) do
    begin
      c+=end_^;
      end_+=1;
    end;
  c+=c+src^;
  beg_:=end_-1;
  while (beg_>src) do
    begin
      dst_^++=c*km>>16;
      c-=beg_^;
      beg_^-=1;
      c+=end_^;
      end_+=1;
    end;
  while (end_<src+w-1) do
    begin
      dst_^++=c*km>>16;
      c-=beg_^;
      beg_^+=1;
      c+=end_^;
      end_^+=1;
    end;
  while (dst_<dest+w) do
    begin
      dst_^++=c*km>>16;
      c-=beg_^;
      beg_^+=1;
      c+=end_^;
      c_^-=1;
    end;
end;
}

// Rotate:
procedure ImgRotLoop0(                     constref rct_src        :TPtRect;          bmp_src_ptr,bmp_dst_ptr:PInteger; constref bmp_dst_width,d_width,c,s,v,w,lt,tp,rt,bt:integer; constref mask_alpha:TColor                                                                                       ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,i,j: integer;
begin
  for j:=0 to rct_src.height-1 do
    begin
      x:=v+j*s;
      y:=w-j*c;
      for i:=0 to rct_src.width-1 do
        begin
              bmp_dst_ptr[(x>>16)+(y>>16)*bmp_dst_width]:=
              bmp_src_ptr^;
          Inc(bmp_src_ptr);
          x-=c;
          y-=s;
        end;
      Inc(bmp_src_ptr,d_width);
    end;
end; {$endregion}
procedure ImgRotLoop1(                     constref rct_src        :TPtRect;          bmp_src_ptr,bmp_dst_ptr:PInteger; constref bmp_dst_width,d_width,c,s,v,w,lt,tp,rt,bt:integer; constref mask_alpha:TColor                                                                                       ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,i,j: integer;
begin
  for j:=0 to rct_src.height-1 do
    begin
      x:=v+j*s;
      y:=w-j*c;
      for i:=0 to rct_src.width-1 do
        begin
          if (x>lt) and (x<rt) and (y>tp) and (y<bt) then
              bmp_dst_ptr[(x>>16)+(y>>16)*bmp_dst_width]:=
              bmp_src_ptr^;
          Inc(bmp_src_ptr);
          x-=c;
          y-=s;
        end;
      Inc(bmp_src_ptr,d_width);
    end;
end; {$endregion}
procedure ImgRotLoop2(                     constref rct_src        :TPtRect;          bmp_src_ptr,bmp_dst_ptr:PInteger; constref bmp_dst_width,d_width,c,s,v,w,lt,tp,rt,bt:integer; constref mask_alpha:TColor                                                                                       ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,i,j: integer;
begin
  for j:=0 to rct_src.height-1 do
    begin
      x:=v+j*s;
      y:=w-j*c;
      for i:=0 to rct_src.width-1 do
        begin
              bmp_dst_ptr[(x>>16)+(y>>16)*bmp_dst_width]:=
              bmp_src_ptr^<<8>>8+mask_alpha;
          Inc(bmp_src_ptr);
          x-=c;
          y-=s;
        end;
      Inc(bmp_src_ptr,d_width);
    end;
end; {$endregion}
procedure ImgRotLoop3(                     constref rct_src        :TPtRect;          bmp_src_ptr,bmp_dst_ptr:PInteger; constref bmp_dst_width,d_width,c,s,v,w,lt,tp,rt,bt:integer; constref mask_alpha:TColor                                                                                       ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,i,j: integer;
begin
  for j:=0 to rct_src.height-1 do
    begin
      x:=v+j*s;
      y:=w-j*c;
      for i:=0 to rct_src.width-1 do
        begin
          if (x>lt) and (x<rt) and (y>tp) and (y<bt) then
              bmp_dst_ptr[(x>>16)+(y>>16)*bmp_dst_width]:=
              bmp_src_ptr^<<8>>8+mask_alpha;
          Inc(bmp_src_ptr);
          x-=c;
          y-=s;
        end;
      Inc(bmp_src_ptr,d_width);
    end;
end; {$endregion}
procedure ImgRotLoop4(                     constref rct_src        :TPtRect;          bmp_src_ptr,bmp_dst_ptr:PInteger; constref bmp_dst_width,d_width,c,s,v,w,lt,tp,rt,bt:integer; constref mask_alpha:TColor                                                                                       ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,i,j: integer;
begin
  for j:=0 to rct_src.height-1 do
    begin
      x:=v+j*s;
      y:=w-j*c;
      for i:=0 to rct_src.width-1 do
        begin
          bmp_dst_ptr[(x>>16)+(y>>16)*bmp_dst_width]:=mask_alpha;
          x-=c;
          y-=s;
        end;
    end;
end; {$endregion}
procedure ImgRotLoop5(                     constref rct_src        :TPtRect;          bmp_src_ptr,bmp_dst_ptr:PInteger; constref bmp_dst_width,d_width,c,s,v,w,lt,tp,rt,bt:integer; constref mask_alpha:TColor                                                                                       ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,i,j: integer;
begin
  for j:=0 to rct_src.height-1 do
    begin
      x:=v+j*s;
      y:=w-j*c;
      for i:=0 to rct_src.width-1 do
        begin
          if (x>lt) and (x<rt) and (y>tp) and (y<bt) then
            bmp_dst_ptr[(x>>16)+(y>>16)*bmp_dst_width]:=mask_alpha;
          x-=c;
          y-=s;
        end;
    end;
end; {$endregion}
procedure ImgRot1    (constref pvt:TPtPos; constref rct_src,rct_clp:TPtRect; constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref bmp_src_width,bmp_dst_width:TColor; constref angle:double; constref x,y :integer; constref add_alpha_mask:byte; var bounding_rct:TPtRect; constref mask_alpha:TColor); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst     : TPtRect;
  rct_src1    : TPtRect;
  rct_src2    : TPtRect;
  bmp_src_ptr2: PInteger;
  c           : double =0.0;
  s           : double =0.0;
  v           : double =0.0;
  w           : double =0.0;
  c2          : integer=000;
  s2          : integer=000;
  v2          : integer=000;
  w2          : integer=000;
  r,k,d_width : integer;
  lt,tp,rt,bt : integer;
  b           : byte   =001;
begin

  {} {$region -fold}
  if (Trunc(angle) mod 360=0) then
    begin
      rct_src1:=PtRct
      (
        x,
        y,
        x+rct_src.width,
        y+rct_src.height
      );
      rct_dst :=ClippedRct(rct_clp,rct_src1) ;
      if (rct_dst.width=0) or (rct_dst.height=0) then
        Exit;
      r       :=rct_src.width -(rct_dst.right -rct_dst.left);
      k       :=rct_src.height-(rct_dst.bottom-rct_dst.top );
      rct_src2:=PtRct
      (
        rct_src.left+r,
        rct_src.top +k,
        rct_src.right ,
        rct_src.bottom
      );
      BitBlt1
      (
        bmp_src_ptr,
        bmp_dst_ptr,
        rct_src2,
        rct_dst.left,
        rct_dst.top,
        bmp_src_width,
        bmp_dst_width
      );
      Exit;
    end; {$endregion}

  {} {$region -fold}
  GetRot
  (
    PtPos
    (
      x-rct_src.left+pvt.x,
      y-rct_src.top +pvt.y
    ),
    angle,
    c,
    s,
    v,
    w
  ); {$endregion}

  {} {$region -fold}
  b:=1;
  bounding_rct:=ClippedRctB
  (
    rct_clp,
    PtsRot
    (
      PtRct
      (
        x,
        y,
        x-rct_src.left+rct_src.right,
        y-rct_src.top +rct_src.bottom
      ),
      angle,
      c,
      s,
      v,
      w
    ),
    b
  ); {$endregion}

  {} {$region -fold}
  if (b=2) then
    Exit
  else
    begin
      GetRot
      (
        PtPos
        (
          x-rct_src.left+pvt.x,
          y-rct_src.top +pvt.y
        ),
        angle,
        c2,
        s2,
        v2,
        w2,
        x,
        y
      );
      lt          :=rct_clp.left  <<16;
      rt          :=rct_clp.right <<16;
      tp          :=rct_clp.top   <<16;
      bt          :=rct_clp.bottom<<16;
      d_width     :=bmp_src_width-rct_src.width;
      bmp_src_ptr2:=Unaligned(bmp_src_ptr+rct_src.left+rct_src.top*bmp_dst_width);
    end;
  {
  add_alpha_mask values:
  0: copy source to destination without mask;
  1: add mask to alpha channel of destination;
  2: fill destination with specifed value
  }
  case add_alpha_mask of
    0:
      begin
        if (b=0) then
          ImgRotLoop0(rct_src,bmp_src_ptr2,bmp_dst_ptr,bmp_dst_width,d_width,c2,s2,v2,w2,lt,tp,rt,bt,mask_alpha)
        else
          ImgRotLoop1(rct_src,bmp_src_ptr2,bmp_dst_ptr,bmp_dst_width,d_width,c2,s2,v2,w2,lt,tp,rt,bt,mask_alpha);
      end;
    1:
      begin
        if (b=0) then
          ImgRotLoop2(rct_src,bmp_src_ptr2,bmp_dst_ptr,bmp_dst_width,d_width,c2,s2,v2,w2,lt,tp,rt,bt,mask_alpha)
        else
          ImgRotLoop3(rct_src,bmp_src_ptr2,bmp_dst_ptr,bmp_dst_width,d_width,c2,s2,v2,w2,lt,tp,rt,bt,mask_alpha);
      end;
    2:
      begin
        if (b=0) then
          ImgRotLoop4(rct_src,bmp_src_ptr2,bmp_dst_ptr,bmp_dst_width,d_width,c2,s2,v2,w2,lt,tp,rt,bt,mask_alpha)
        else
          ImgRotLoop5(rct_src,bmp_src_ptr2,bmp_dst_ptr,bmp_dst_width,d_width,c2,s2,v2,w2,lt,tp,rt,bt,mask_alpha);
      end;
  end; {$endregion}

end; {$endregion}
procedure ImgRot2    (constref pvt:TPtPos; constref rct_src,rct_clp:TPtRect; constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref bmp_src_width,bmp_dst_width:TColor; constref angle:double; constref x,y,inn_wnd_mrg,bmp_src_height:integer                                                          ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst        : TPtRect;
  rct_src1       : TPtRect;
  rct_src2       : TPtRect;
  rct_src3       : TPtRect;
  bmp_src_ptr2   : PInteger;
  c              : double=0.0;
  s              : double=0.0;
  v              : double=0.0;
  w              : double=0.0;
  x_,y_          : double;
  i,j,r,k,d_width: integer;
  b              : byte;
  v2,w2,ssx,ssy,ssw,ssh,addy,xx,yy,L2,T2,R2,B2,sx,sy,dx,dy,sw,sh,dw,SinA,CosA: integer;
begin
  {if (Trunc(angle) mod 360=0) then
    begin
      rct_src1:=PtRct
      (
        x,
        y,
        x+rct_src.width,
        y+rct_src.height
      );
      rct_dst :=ClippedRct(rct_clp,rct_src1) ;
      if (rct_dst.width=0) or (rct_dst.height=0) then
        Exit;
      r       :=rct_src.width -(rct_dst.right -rct_dst.left);
      k       :=rct_src.height-(rct_dst.bottom-rct_dst.top );
      rct_src2:=PtRct
      (
        rct_src.left+r,
        rct_src.top +k,
        rct_src.right ,
        rct_src.bottom
      );
      BitBlt1
      (
        bmp_src_ptr,
        bmp_dst_ptr,
        rct_src2,
        rct_dst.left-pvt.x,
        rct_dst.top -pvt.y,
        bmp_src_width,
        bmp_dst_width
      );
      Exit;
    end;
  GetRot
  (
    PtPos
    (
      x-rct_src.left+pvt.x,
      y-rct_src.top +pvt.y
    ),
    angle,
    c,
    s,
    v,
    w
  );
  rct_src3:=ClippedRctB
  (
    rct_clp,
    PtsRot
    (
      PtRct
      (
        x,
        y,
        x-rct_src.left+rct_src.right,
        y-rct_src.top +rct_src.bottom
      ),
      angle,
      c,
      s,
      v,
      w
    ),
    b
  );
  if (b=2) then
    Exit
  else
    begin
      sx  :=pvt.x                                 ;
      sy  :=pvt.y                                 ;
      sw  :=bmp_src_width                         ;
      sh  :=bmp_src_height                        ;
      dx  :=x                                     ;
      dy  :=y                                     ;
      dw  :=bmp_dst_width                         ;
      L2  :=rct_src3.left                         ;
      T2  :=rct_src3.top                          ;
      R2  :=rct_src3.right                        ;
      B2  :=rct_src3.bottom                       ;
      CosA:=Round( cos(pi*(1+angle/180)+pi)*65536);
      SinA:=Round(-sin(pi*(1+angle/180)+pi)*65536);
      ssx :=(sx<<16)-(dx-L2)*CosA                 ;
      ssy :=(sy<<16)-(dx-L2)*SinA                 ;
      ssw := sw<<16                               ;
      ssh := sh<<16                               ;
      addy:= T2*dw                                ;
      T2  -= dy                                   ;
      B2  -= dy                                   ;
      xx  :=ssx-T2*SinA                           ;
      yy  :=ssy+T2*CosA                           ;
    end;
  if (b=0) then
    begin
      for j:=T2 to B2 do
        begin
          xx:=ssx-j*SinA;
          yy:=ssy+j*CosA;
          for i:=L2 to R2 do
            begin
              if ((xx>=0) and (xx<ssw) and (yy>=0) and (yy<ssh)) then
              {if (i>=rct_clp.left) and (i<(rct_clp.right -1)) and
                 (yy>>16>=rct_clp.top ) and (yy>>16<(rct_clp.bottom-1)) then}
                (bmp_dst_ptr+addy+i)^:={clGreen}(bmp_src_ptr+sw*(yy>>16)+(xx>>16))^;
              xx+=CosA;
              yy+=SinA;
            end;
          addy+=dw;
        end;
    end
  else
  if (b=1) then
    begin
      for j:=T2 to B2 do
        begin
          xx:=ssx-j*SinA;
          yy:=ssy+j*CosA;
          for i:=L2 to R2 do
            begin
              if ((xx>=0) and (xx<ssw) and (yy>=0) and (yy<ssh)) then
              {if (i>=rct_clp.left) and (i<(rct_clp.right -1)) and
                 (yy>>16>=rct_clp.top ) and (yy>>16<(rct_clp.bottom-1)) then}
                (bmp_dst_ptr+addy+i)^:={clGreen}(bmp_src_ptr+sw*(yy>>16)+(xx>>16))^;
              xx+=CosA;
              yy+=SinA;
            end;
          addy+=dw;
        end;
    end;}
end; {$endregion}
{$endregion}



(****************************** Post-Processing *******************************) {$region -fold}

procedure PPDec2ProcInit;  {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPDec2Proc[000]:=Unaligned(@AlphablendDec2);
  PPDec2Proc[001]:=Unaligned(@AdditiveDec2  );
  PPDec2Proc[002]:=Unaligned(@AlphablendDec2);
  PPDec2Proc[003]:=Unaligned(@InverseDec2   );
  PPDec2Proc[004]:=Unaligned(@HighlightDec2 );
  PPDec2Proc[005]:=Unaligned(@DarkenDec2    );
  PPDec2Proc[006]:=Unaligned(@GrayscaleRDec2);
  PPDec2Proc[007]:=Unaligned(@GrayscaleGDec2);
  PPDec2Proc[008]:=Unaligned(@GrayscaleBDec2);
  PPDec2Proc[009]:=Unaligned(@AlphablendDec2);
  PPDec2Proc[010]:=Unaligned(@ColorizeRMDec2);
  PPDec2Proc[011]:=Unaligned(@ColorizeRPDec2);
  PPDec2Proc[012]:=Unaligned(@ColorizeGMDec2);
  PPDec2Proc[013]:=Unaligned(@ColorizeGPDec2);
  PPDec2Proc[014]:=Unaligned(@ColorizeBMDec2);
  PPDec2Proc[015]:=Unaligned(@ColorizeBPDec2);
 {PPDec2Proc[016]:=Unaligned(@BlurRGBDec2   );
  PPDec2Proc[017]:=Unaligned(@BlurRRBDec2   );
  PPDec2Proc[018]:=Unaligned(@BlurRGRDec2   );
  PPDec2Proc[019]:=Unaligned(@BlurGGBDec2   );
  PPDec2Proc[020]:=Unaligned(@BlurRGGDec2   );
  PPDec2Proc[021]:=Unaligned(@BlurBGBDec2   );
  PPDec2Proc[022]:=Unaligned(@BlurRBBDec2   );
  PPDec2Proc[023]:=Unaligned(@BlurRRRDec2   );
  PPDec2Proc[024]:=Unaligned(@BlurGGGDec2   );
  PPDec2Proc[025]:=Unaligned(@BlurBBBDec2   );}
end; {$endregion}
procedure ArrFillProcInit; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  ArrFillProc[000]:=Unaligned(@ArrFillProc00);
  ArrFillProc[001]:=Unaligned(@ArrFillProc01);
  ArrFillProc[002]:=Unaligned(@ArrFillProc02);
  ArrFillProc[003]:=Unaligned(@ArrFillProc03);
  ArrFillProc[004]:=Unaligned(@ArrFillProc04);
  ArrFillProc[005]:=Unaligned(@ArrFillProc05);
  ArrFillProc[006]:=Unaligned(@ArrFillProc06);
  ArrFillProc[007]:=Unaligned(@ArrFillProc07);
  ArrFillProc[008]:=Unaligned(@ArrFillProc08);
  ArrFillProc[009]:=Unaligned(@ArrFillProc09);
  ArrFillProc[010]:=Unaligned(@ArrFillProc10);
  ArrFillProc[011]:=Unaligned(@ArrFillProc11);
  ArrFillProc[012]:=Unaligned(@ArrFillProc12);
  ArrFillProc[013]:=Unaligned(@ArrFillProc13);
  ArrFillProc[014]:=Unaligned(@ArrFillProc14);
  ArrFillProc[015]:=Unaligned(@ArrFillProc15);
  ArrFillProc[016]:=Unaligned(@ArrFillProc16);
  ArrFillProc[017]:=Unaligned(@ArrFillProc17);
  ArrFillProc[018]:=Unaligned(@ArrFillProc18);
  ArrFillProc[019]:=Unaligned(@ArrFillProc19);
  ArrFillProc[020]:=Unaligned(@ArrFillProc20);
  ArrFillProc[021]:=Unaligned(@ArrFillProc21);
  ArrFillProc[022]:=Unaligned(@ArrFillProc22);
  ArrFillProc[023]:=Unaligned(@ArrFillProc23);
  ArrFillProc[024]:=Unaligned(@ArrFillProc24);
  ArrFillProc[025]:=Unaligned(@ArrFillProc25);
end; {$endregion}
procedure PPBlurProcInit;  {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPBlurProc[00]:=Unaligned(@PPBlurProc00);
  PPBlurProc[01]:=Unaligned(@PPBlurProc01);
  PPBlurProc[02]:=Unaligned(@PPBlurProc02);
  PPBlurProc[03]:=Unaligned(@PPBlurProc03);
  PPBlurProc[04]:=Unaligned(@PPBlurProc04);
  PPBlurProc[05]:=Unaligned(@PPBlurProc05);
  PPBlurProc[06]:=Unaligned(@PPBlurProc06);
  PPBlurProc[07]:=Unaligned(@PPBlurProc07);
  PPBlurProc[08]:=Unaligned(@PPBlurProc08);
  PPBlurProc[09]:=Unaligned(@PPBlurProc09);
  PPBlurProc[10]:=Unaligned(@PPBlurProc10);
  PPBlurProc[11]:=Unaligned(@PPBlurProc11);
end; {$endregion}

// (Flood Fill) Заливка:
procedure PPFloodFillAdd     (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor);                                                     {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
             (dst_pixel_ptr)^-=-1;
          Inc(dst_pixel_ptr);
        end;
      Inc    (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPFloodFillSub     (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor);                                                     {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
             (dst_pixel_ptr)^-=1;
          Inc(dst_pixel_ptr);
        end;
      Inc    (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPFloodFill        (                  constref             bmp_dst_ptr:PByte;                              constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor);                                                     {$region -fold}
var
  dst_pixel_ptr: PByte;
  y            : integer;
begin
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      FillByte(dst_pixel_ptr^,rct_dst.width,1);
      Inc     (dst_pixel_ptr ,bmp_dst_width  );
    end;
end; {$endregion}
procedure PPFloodFill        (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor; constref col:TColor);                                {$region -fold}
var
  dst_pixel_ptr: PInteger;
  y            : integer;
begin
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      FillDWord(dst_pixel_ptr^,rct_dst.width,col);
      Inc      (dst_pixel_ptr ,bmp_dst_width    );
    end;
end; {$endregion}
procedure PPFloodFill        (                  constref             bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_dst_width,rct_dst_height,first_pix_pos:integer;       constref col:TColor);                                {$region -fold}
var
  dst_pixel_ptr: PInteger;
  pix          : integer;
  x,y          : integer;
begin
  if (rct_dst_width=0) or (rct_dst_height=0) then
    Exit;
  pix          :=RGB(Blue(col),Green(col),Red(col));
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+first_pix_pos);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst_height-1 do
    begin
      FillDWord(dst_pixel_ptr^,rct_dst_width,pix);
      Inc      (dst_pixel_ptr ,bmp_dst_width    );
    end;
end; {$endregion}
procedure PPFloodFill        (                  constref             bmp_dst:Graphics.TBitmap;                                                                                               constref col:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  raw_image     : TRawImage;
  pixel_ptr     : PInteger;
  pixel_row_ptr : PInteger;
  byte_per_pixel: integer;
  x,y           : integer;
begin
  bmp_dst.BeginUpdate(False);
  bmp_dst.PixelFormat:=pf32bit;
  raw_image      :=bmp_dst.RawImage;
  pixel_row_ptr  :=PInteger(raw_image.Data);
  byte_per_pixel :=Trunc(raw_image.Description.BitsPerPixel>>3);
  for y:=0 to bmp_dst.height-1 do
    begin
      pixel_ptr:=pixel_row_ptr;
      for x:=0 to bmp_dst.width-1 do
        begin
                    pixel_ptr^:=col;
          Inc(PByte(pixel_ptr),byte_per_pixel);
        end;
      Inc(PByte(pixel_row_ptr),raw_image.Description.BytesPerLine);
    end;
  bmp_dst.EndUpdate(False);
end; {$endregion}
procedure PPFloodFill        (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor; constref col:TColor; flood_fill_inc:boolean);        {$region -fold}
var
  dst_pixel_ptr    : PInteger;
  y,bmp_dst_width_ : integer;
    rct_dst_height_: integer;
begin
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  bmp_dst_width_:=bmp_dst_width<<1;
  if flood_fill_inc then
    begin
      dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+(rct_dst.top+0)*bmp_dst_width);
      if Odd(rct_dst.height) then
        rct_dst_height_:=rct_dst.height>>1
      else
        rct_dst_height_:=rct_dst.height>>1-1;
    end
  else
    begin
      dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+(rct_dst.top+1)*bmp_dst_width);
      if not Odd(rct_dst.height) then
        rct_dst_height_:=rct_dst.height>>1
      else
        rct_dst_height_:=rct_dst.height>>1-1;
    end;
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst_height_ do
    begin
      FillDWord(dst_pixel_ptr^,rct_dst.width,col);
      Inc      (dst_pixel_ptr ,bmp_dst_width_   );
    end;
end; {$endregion}

// (Additive) Аддитивное смешивание:
procedure PPAdditive         (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect ; constref               bmp_dst_width:TColor; constref col:TColor                      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  r,g,b        : byte;
begin
  r            :=Red  (col);
  g            :=Green(col);
  b            :=Blue (col);
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(@bmp_dst_ptr[rct_dst.left+rct_dst.top*bmp_dst_width]);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                   dst_pixel_ptr^:=
          Additive(dst_pixel_ptr^,b,g,r);
          Inc     (dst_pixel_ptr);
        end;
      Inc         (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPAdditive         (                  constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref rct_src:TPtRect; constref rct_dst:TPtRectB; constref bmp_src_width,bmp_dst_width:TColor                                           ); {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(bmp_src_ptr+rct_src.       left+rct_src.       top*bmp_src_width);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.pt_rct.left+rct_dst.pt_rct.top*bmp_dst_width);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
                   dst_pixel_ptr^  :=
          Additive(dst_pixel_ptr^  ,
             Blue (src_pixel_ptr^) ,
             Green(src_pixel_ptr^) ,
             Red  (src_pixel_ptr^));
          Inc     (src_pixel_ptr ) ;
          Inc     (dst_pixel_ptr ) ;
        end;
      Inc         (src_pixel_ptr,d_width1);
      Inc         (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
procedure PPAdditiveDec      (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect ; constref               bmp_dst_width:TColor; constref col:TColor; constref pow:byte=64); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  r,g,b        : byte;
begin
  r            :=Red  (col);
  g            :=Green(col);
  b            :=Blue (col);
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                      dst_pixel_ptr^:=
          AdditiveDec(dst_pixel_ptr^,b,g,r,pow);
          Inc        (dst_pixel_ptr);
        end;
      Inc            (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPAdditiveDec      (                  constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref rct_src:TPtRect; constref rct_dst:TPtRectB; constref bmp_src_width,bmp_dst_width:TColor;                      constref pow:byte=64); {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(bmp_src_ptr+rct_src.       left+rct_src.       top*bmp_src_width);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.pt_rct.left+rct_dst.pt_rct.top*bmp_dst_width);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
                      dst_pixel_ptr^ :=
          AdditiveDec(dst_pixel_ptr^ ,
                Blue (src_pixel_ptr^),
                Green(src_pixel_ptr^),
                Red  (src_pixel_ptr^),
                pow);
          Inc        (src_pixel_ptr );
          Inc        (dst_pixel_ptr );
        end;
      Inc            (src_pixel_ptr,d_width1);
      Inc            (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}

// (AlphaBlend) Полупрозрачность:
procedure PPAlphaBlend       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect ; constref               bmp_dst_width:TColor; constref col:TColor; constref pow:byte=64; alpha_max:byte=255); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  r,g,b        : byte;
  alpha,d_alpha: byte;
begin
  r            :=Red  (col);
  g            :=Green(col);
  b            :=Blue (col);
  alpha        :=pow;
  d_alpha      :=alpha_max-alpha;
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                     dst_pixel_ptr^:=
          AlphaBlend(dst_pixel_ptr^,b,g,r,alpha,d_alpha);
          Inc       (dst_pixel_ptr);
        end;
      Inc           (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPAlphaBlend       (                  constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref rct_src:TPtRect; constref rct_dst:TPtRectB; constref bmp_src_width,bmp_dst_width:TColor;                      constref pow:byte=64; alpha_max:byte=255); {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(bmp_src_ptr+rct_src.       left+rct_src.       top*bmp_src_width);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.pt_rct.left+rct_dst.pt_rct.top*bmp_dst_width);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
                     dst_pixel_ptr^ :=
          AlphaBlend(dst_pixel_ptr^ ,
               Blue (src_pixel_ptr^),
               Green(src_pixel_ptr^),
               Red  (src_pixel_ptr^),
                   pow,
         alpha_max-pow);
          Inc       (src_pixel_ptr );
          Inc       (dst_pixel_ptr );
        end;
      Inc           (src_pixel_ptr,d_width1);
      Inc           (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}

// (Inverse) Инверсия:
procedure PPInverse          (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor                      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                   dst_pixel_ptr^ :=
          Inverse (dst_pixel_ptr^);
          Inc     (dst_pixel_ptr );
        end;
      Inc         (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPInverseDec       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor; constref pow:byte=64); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                     dst_pixel_ptr^:=
          InverseDec(dst_pixel_ptr^,pow);
          Inc       (dst_pixel_ptr);
        end;
      Inc           (dst_pixel_ptr,d_width);
    end;
end; {$endregion}

// (HighLight) Подсветка:
procedure PPHighlight        (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor; constref pow:byte=64); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                    dst_pixel_ptr^:=
          Highlight(dst_pixel_ptr^,0,0,0,0,0,pow);
          Inc      (dst_pixel_ptr);
        end;
      Inc          (dst_pixel_ptr,d_width);
    end;
end; {$endregion}

// (Darken) Затемнение:
procedure PPDarken           (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor; constref pow:byte=64); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                 dst_pixel_ptr^:=
          Darken(dst_pixel_ptr^,0,0,0,0,0,pow);
          Inc   (dst_pixel_ptr);
        end;
      Inc       (dst_pixel_ptr,d_width);
    end;
end; {$endregion}

// (GrayscaleR) Серый оттенок: красный канал:
procedure PPGrayscaleR       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor                      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                     dst_pixel_ptr^ :=
          GrayscaleR(dst_pixel_ptr^);
          Inc       (dst_pixel_ptr );
        end;
      Inc           (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPGrayscaleRDec    (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor; constref pow:byte=64); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                        dst_pixel_ptr^:=
          GrayscaleRDec(dst_pixel_ptr^,pow);
          Inc          (dst_pixel_ptr);
        end;
      Inc              (dst_pixel_ptr,d_width);
    end;
end; {$endregion}

// (GrayscaleG) Серый оттенок: зеленый канал:
procedure PPGrayscaleG       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor                      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                     dst_pixel_ptr^ :=
          GrayscaleG(dst_pixel_ptr^);
          Inc       (dst_pixel_ptr );
        end;
      Inc           (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPGrayscaleGDec    (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor; constref pow:byte=64); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                        dst_pixel_ptr^:=
          GrayscaleGDec(dst_pixel_ptr^,pow);
          Inc          (dst_pixel_ptr);
        end;
      Inc              (dst_pixel_ptr,d_width);
    end;
end; {$endregion}

// (GrayscaleB) Серый оттенок: синий   канал:
procedure PPGrayscaleB       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor                      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                     dst_pixel_ptr^ :=
          GrayscaleB(dst_pixel_ptr^);
          Inc       (dst_pixel_ptr );
        end;
      Inc           (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPGrayscaleBDec    (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor; constref pow:byte=64); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                        dst_pixel_ptr^:=
          GrayscaleBDec(dst_pixel_ptr^,pow);
          Inc          (dst_pixel_ptr);
        end;
      Inc              (dst_pixel_ptr,d_width);
    end;
end; {$endregion}

// (Monochrome Noise) Монохромный шум:
procedure PPMonoNoise        (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor; constref col:TColor                                          ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if Odd(dst_pixel_ptr^) then
                 dst_pixel_ptr^:=col;
          Inc   (dst_pixel_ptr);
        end;
      Inc       (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPMonoNoiseDec     (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor; constref col:TColor; constref pow:byte=64; alpha_max:byte=255); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  r,g,b        : byte;
  alpha,d_alpha: byte;
begin
  r            :=Red  (col);
  g            :=Green(col);
  b            :=Blue (col);
  alpha        :=pow;
  d_alpha      :=alpha_max-pow;
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if Odd    (dst_pixel_ptr^) then
                     dst_pixel_ptr^:=
          AlphaBlend(dst_pixel_ptr^,b,g,r,alpha,d_alpha);
          Inc       (dst_pixel_ptr);
        end;
      Inc           (dst_pixel_ptr,d_width);
    end;
end; {$endregion}

// (Blur) Размытие:
procedure PPBlurProc00       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          BlurRGB(pixel_ptr4,bmp_dst_width);
          Inc    (pixel_ptr4);
        end;
      Inc        (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc01       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          BlurRRB(pixel_ptr4,bmp_dst_width);
          Inc    (pixel_ptr4);
        end;
      Inc        (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc02       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          BlurRGR(pixel_ptr4,bmp_dst_width);
          Inc    (pixel_ptr4);
        end;
      Inc        (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc03       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          BlurGGB(pixel_ptr4,bmp_dst_width);
          Inc    (pixel_ptr4);
        end;
      Inc        (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc04       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          BlurRGG(pixel_ptr4,bmp_dst_width);
          Inc    (pixel_ptr4);
        end;
      Inc        (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc05       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          BlurBGB(pixel_ptr4,bmp_dst_width);
          Inc    (pixel_ptr4);
        end;
      Inc        (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc06       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          BlurRBB(pixel_ptr4,bmp_dst_width);
          Inc    (pixel_ptr4);
        end;
      Inc        (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc07       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
  r          : byte;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          r:=(Red((pixel_ptr4+0                 )^)+
              Red((pixel_ptr4+2                 )^)+
              Red((pixel_ptr4+0+bmp_dst_width<<1)^)+
              Red((pixel_ptr4+2+bmp_dst_width<<1)^))>>2;
                  (pixel_ptr4+  bmp_dst_width+ 1)^:=RGB(r,r,r);
          Inc     (pixel_ptr4);
        end;
      Inc         (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc08       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
  g          : byte;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          g:=(Green((pixel_ptr4+0                 )^)+
              Green((pixel_ptr4+2                 )^)+
              Green((pixel_ptr4+0+bmp_dst_width<<1)^)+
              Green((pixel_ptr4+2+bmp_dst_width<<1)^))>>2;
                    (pixel_ptr4+  bmp_dst_width+ 1)^:=RGB(g,g,g);
          Inc       (pixel_ptr4);
        end;
      Inc           (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc09       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
  b          : byte;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          b:=(Blue((pixel_ptr4+0                 )^)+
              Blue((pixel_ptr4+2                 )^)+
              Blue((pixel_ptr4+0+bmp_dst_width<<1)^)+
              Blue((pixel_ptr4+2+bmp_dst_width<<1)^))>>2;
                   (pixel_ptr4+  bmp_dst_width+ 1)^:=RGB(b,b,b);
          Inc      (pixel_ptr4);
        end;
      Inc          (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc10       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
                         (pixel_ptr4+bmp_dst_width+1)^:=
          RGB((Byte(    ((pixel_ptr4)^)>>00)+
               Byte(    ((pixel_ptr4+1)^)>>00)+
               Byte(    ((pixel_ptr4+2)^)>>00)+
               Byte(    ((pixel_ptr4+bmp_dst_width)^)>>00)+
               Byte(    ((pixel_ptr4+bmp_dst_width+2)^)>>00)+
               Byte(    ((pixel_ptr4+bmp_dst_width<<1)^)>>00)+
               Byte(    ((pixel_ptr4+bmp_dst_width<<1+1)^)>>00)+
               Byte(    ((pixel_ptr4+bmp_dst_width<<1+2)^)>>00))>>3,
              (Byte(Word((pixel_ptr4)^)>>08)+
               Byte(Word((pixel_ptr4+1)^)>>08)+
               Byte(Word((pixel_ptr4+2)^)>>08)+
               Byte(Word((pixel_ptr4+bmp_dst_width)^)>>08)+
               Byte(Word((pixel_ptr4+bmp_dst_width+2)^)>>08)+
               Byte(Word((pixel_ptr4+bmp_dst_width<<1)^)>>08)+
               Byte(Word((pixel_ptr4+bmp_dst_width<<1+1)^)>>08)+
               Byte(Word((pixel_ptr4+bmp_dst_width<<1+2)^)>>08))>>3,
              (Byte(    ((pixel_ptr4)^)>>16)+
               Byte(    ((pixel_ptr4+1)^)>>16)+
               Byte(    ((pixel_ptr4+2)^)>>16)+
               Byte(    ((pixel_ptr4+bmp_dst_width)^)>>16)+
               Byte(    ((pixel_ptr4+bmp_dst_width+2)^)>>16)+
               Byte(    ((pixel_ptr4+bmp_dst_width<<1)^)>>16)+
               Byte(    ((pixel_ptr4+bmp_dst_width<<1+1)^)>>16)+
               Byte(    ((pixel_ptr4+bmp_dst_width<<1+2)^)>>16))>>3);
          Inc            (pixel_ptr4);
        end;
      Inc                (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc11       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          if (Byte(    ((pixel_ptr4+bmp_dst_width+1)^)>>00)>200) and
             (Byte(Word((pixel_ptr4+bmp_dst_width+1)^)>>08)>200) and
             (Byte(    ((pixel_ptr4+bmp_dst_width+1)^)>>16)>200) then
                        (pixel_ptr4+bmp_dst_width+1)^:=
         RGB((Byte(    ((pixel_ptr4+0)^)>>00)+
              Byte(    ((pixel_ptr4+2)^)>>00)+
              Byte(    ((pixel_ptr4+bmp_dst_width<<1)^)>>00)+
              Byte(    ((pixel_ptr4+bmp_dst_width<<1+2)^)>>00))>>2,
             (Byte(Word((pixel_ptr4+0)^)>>08)+
              Byte(Word((pixel_ptr4+2)^)>>08)+
              Byte(Word((pixel_ptr4+bmp_dst_width<<1)^)>>08)+
              Byte(Word((pixel_ptr4+bmp_dst_width<<1+2)^)>>08))>>2,
             (Byte(    ((pixel_ptr4+0)^)>>16)+
              Byte(    ((pixel_ptr4+2)^)>>16)+
              Byte(    ((pixel_ptr4+bmp_dst_width<<1)^)>>16)+
              Byte(    ((pixel_ptr4+bmp_dst_width<<1+2)^)>>16))>>2);
          Inc           (pixel_ptr4);
        end;
      Inc               (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlur             (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor; constref blur_type:byte=0; constref border_filter:TBorderFilter=efNotTiled); {$region -fold}
var
  pixel_ptr0,pixel_ptr1,pixel_ptr2,pixel_ptr3,pixel_ptr4: PInteger;
  i,j,d_width                                           : integer;
  r0,r1,r2,r3,r4,r5,r6,r7,r8                            : byte;
  g0,g1,g2,g3,g4,g5,g6,g7,g8                            : byte;
  b0,b1,b2,b3,b4,b5,b6,b7,b8                            : byte;
  r,g,b                                                 : byte;
begin

  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  {
  d_width:=bmp_dst_width-rct_dst.width;

  // left -top    pixel
  pixel_ptr0:=Unaligned(bmp_dst_ptr+rct_dst.left+                bmp_dst_width* rct_dst.top                  );
  // right-top    pixel
  pixel_ptr1:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.width-1+bmp_dst_width* rct_dst.top                  );
  // left -bottom pixel
  pixel_ptr2:=Unaligned(bmp_dst_ptr+rct_dst.left+                bmp_dst_width*(rct_dst.top+rct_dst.height-1));
  // right-bottom pixel
  pixel_ptr3:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.width-1+bmp_dst_width*(rct_dst.top+rct_dst.height-1));

  pixel_ptr4:=pixel_ptr0;

  {Borders-------------} {$region -fold}

  case border_filter of

    efNotTiled:
      begin

        {Left-Top Pixel----} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
        pixel_ptr4^:=RGB((Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+1)^)+Red  ((pixel_ptr4+bmp_dst_width+0)^)+Red  ((pixel_ptr4+bmp_dst_width+1)^))>>2,
                         (Green((pixel_ptr4+0)^)+Green((pixel_ptr4+1)^)+Green((pixel_ptr4+bmp_dst_width+0)^)+Green((pixel_ptr4+bmp_dst_width+1)^))>>2,
                         (Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+1)^)+Blue ((pixel_ptr4+bmp_dst_width+0)^)+Blue ((pixel_ptr4+bmp_dst_width+1)^))>>2); {$endregion}

        {Right-Top Pixel---} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.width-1+bmp_dst_width*rct_dst.top);
        pixel_ptr4^:=RGB((Red  ((pixel_ptr4-1)^)+Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+bmp_dst_width-1)^)+Red  ((pixel_ptr4+bmp_dst_width+0)^))>>2,
                         (Green((pixel_ptr4-1)^)+Green((pixel_ptr4+0)^)+Green((pixel_ptr4+bmp_dst_width-1)^)+Green((pixel_ptr4+bmp_dst_width+0)^))>>2,
                         (Blue ((pixel_ptr4-1)^)+Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+bmp_dst_width-1)^)+Blue ((pixel_ptr4+bmp_dst_width+0)^))>>2); {$endregion}

        {Left-Bottom Pixel-} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*(rct_dst.top+rct_dst.height-1));
        pixel_ptr4^:=RGB((Red  ((pixel_ptr4-bmp_dst_width+0)^)+Red  ((pixel_ptr4-bmp_dst_width+1)^)+Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+1)^))>>2,
                         (Green((pixel_ptr4-bmp_dst_width+0)^)+Green((pixel_ptr4-bmp_dst_width+1)^)+Green((pixel_ptr4+0)^)+Green((pixel_ptr4+1)^))>>2,
                         (Blue ((pixel_ptr4-bmp_dst_width+0)^)+Blue ((pixel_ptr4-bmp_dst_width+1)^)+Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+1)^))>>2); {$endregion}

        {Right-Bottom Pixel} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.width-1+bmp_dst_width*(rct_dst.top+rct_dst.height-1));
        pixel_ptr4^:=RGB((Red  ((pixel_ptr4-bmp_dst_width-1)^)+Red  ((pixel_ptr4-bmp_dst_width+0)^)+Red  ((pixel_ptr4-1)^)+Red  ((pixel_ptr4+0)^))>>2,
                         (Green((pixel_ptr4-bmp_dst_width-1)^)+Green((pixel_ptr4-bmp_dst_width+0)^)+Green((pixel_ptr4-1)^)+Green((pixel_ptr4+0)^))>>2,
                         (Blue ((pixel_ptr4-bmp_dst_width-1)^)+Blue ((pixel_ptr4-bmp_dst_width+0)^)+Blue ((pixel_ptr4-1)^)+Blue ((pixel_ptr4+0)^))>>2); {$endregion}

        {Top Line----------} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+1+bmp_dst_width*rct_dst.top);
        for i:=0 to rct_dst.width-3 do
          begin
            pixel_ptr4^:=RGB(Trunc((Red  ((pixel_ptr4-1)^)+Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+1)^)+Red  ((pixel_ptr4+bmp_dst_width-1)^)+Red  ((pixel_ptr4+bmp_dst_width+0)^)+Red  ((pixel_ptr4+bmp_dst_width+1)^))/6),
                             Trunc((Green((pixel_ptr4-1)^)+Green((pixel_ptr4+0)^)+Green((pixel_ptr4+1)^)+Green((pixel_ptr4+bmp_dst_width-1)^)+Green((pixel_ptr4+bmp_dst_width+0)^)+Green((pixel_ptr4+bmp_dst_width+1)^))/6),
                             Trunc((Blue ((pixel_ptr4-1)^)+Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+1)^)+Blue ((pixel_ptr4+bmp_dst_width-1)^)+Blue ((pixel_ptr4+bmp_dst_width+0)^)+Blue ((pixel_ptr4+bmp_dst_width+1)^))/6));
            Inc(pixel_ptr4);
          end; {$endregion}

        {Left Line---------} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*(rct_dst.top+1));
        for j:=0 to rct_dst.height-3 do
          begin
            pixel_ptr4^:=RGB(Trunc((Red  ((pixel_ptr4-bmp_dst_width)^)+Red  ((pixel_ptr4-bmp_dst_width+1)^)+Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+1)^)+Red  ((pixel_ptr4+bmp_dst_width+0)^)+Red  ((pixel_ptr4+bmp_dst_width+1)^))/6),
                             Trunc((Green((pixel_ptr4-bmp_dst_width)^)+Green((pixel_ptr4-bmp_dst_width+1)^)+Green((pixel_ptr4+0)^)+Green((pixel_ptr4+1)^)+Green((pixel_ptr4+bmp_dst_width+0)^)+Green((pixel_ptr4+bmp_dst_width+1)^))/6),
                             Trunc((Blue ((pixel_ptr4-bmp_dst_width)^)+Blue ((pixel_ptr4-bmp_dst_width+1)^)+Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+1)^)+Blue ((pixel_ptr4+bmp_dst_width+0)^)+Blue ((pixel_ptr4+bmp_dst_width+1)^))/6));
            Inc(pixel_ptr4,bmp_dst_width);
          end; {$endregion}

        {Right Line--------} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.width-1+bmp_dst_width*(rct_dst.top+1));
        for j:=0 to rct_dst.height-3 do
          begin
            pixel_ptr4^:=RGB(Trunc((Red  ((pixel_ptr4-bmp_dst_width-1)^)+Red  ((pixel_ptr4-bmp_dst_width+0)^)+Red  ((pixel_ptr4-1)^)+Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+bmp_dst_width-1)^)+Red  ((pixel_ptr4+bmp_dst_width+0)^))/6),
                             Trunc((Green((pixel_ptr4-bmp_dst_width-1)^)+Green((pixel_ptr4-bmp_dst_width+0)^)+Green((pixel_ptr4-1)^)+Green((pixel_ptr4+0)^)+Green((pixel_ptr4+bmp_dst_width-1)^)+Green((pixel_ptr4+bmp_dst_width+0)^))/6),
                             Trunc((Blue ((pixel_ptr4-bmp_dst_width-1)^)+Blue ((pixel_ptr4-bmp_dst_width+0)^)+Blue ((pixel_ptr4-1)^)+Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+bmp_dst_width-1)^)+Blue ((pixel_ptr4+bmp_dst_width+0)^))/6));
            Inc(pixel_ptr4,bmp_dst_width);
          end; {$endregion}

        {Bottom Line-------} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+1+bmp_dst_width*(rct_dst.top+rct_dst.height-1));
        for i:=0 to rct_dst.width-3 do
          begin
            pixel_ptr4^:=RGB(Trunc((Red  ((pixel_ptr4-bmp_dst_width-1)^)+Red  ((pixel_ptr4-bmp_dst_width+0)^)+Red  ((pixel_ptr4-bmp_dst_width+1)^)+Red  ((pixel_ptr4-1)^)+Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+1)^))/6),
                             Trunc((Green((pixel_ptr4-bmp_dst_width-1)^)+Green((pixel_ptr4-bmp_dst_width+0)^)+Green((pixel_ptr4-bmp_dst_width+1)^)+Green((pixel_ptr4-1)^)+Green((pixel_ptr4+0)^)+Green((pixel_ptr4+1)^))/6),
                             Trunc((Blue ((pixel_ptr4-bmp_dst_width-1)^)+Blue ((pixel_ptr4-bmp_dst_width+0)^)+Blue ((pixel_ptr4-bmp_dst_width+1)^)+Blue ((pixel_ptr4-1)^)+Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+1)^))/6));
            Inc(pixel_ptr4);
          end; {$endregion}

      end;

    efTiled:  {TODO}
      begin

        {Left-Top Pixel----} {$region -fold}
        pixel_ptr4 :=Unaligned(@bmp_dst_ptr[rct_dst.left+bmp_dst_width*rct_dst.top]);
        pixel_ptr4^:=RGB((Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+1)^)+Red  ((pixel_ptr4+bmp_dst_width+0)^)+Red  ((pixel_ptr4+bmp_dst_width+1)^))>>2,
                         (Green((pixel_ptr4+0)^)+Green((pixel_ptr4+1)^)+Green((pixel_ptr4+bmp_dst_width+0)^)+Green((pixel_ptr4+bmp_dst_width+1)^))>>2,
                         (Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+1)^)+Blue ((pixel_ptr4+bmp_dst_width+0)^)+Blue ((pixel_ptr4+bmp_dst_width+1)^))>>2); {$endregion}
        {r0:=pixel_ptr3^{shr 0};
        g0:=pixel_ptr3^ shr 8 ;
        b0:=pixel_ptr3^ shr 16;
        r1:=pixel_ptr2^{shr 0};
        g1:=pixel_ptr2^ shr 8 ;
        b1:=pixel_ptr2^ shr 16;
        Inc(pixel_ptr2);
        r2:=pixel_ptr2^{shr 0};
        g2:=pixel_ptr2^ shr 8 ;
        b2:=pixel_ptr2^ shr 16;
        r3:=pixel_ptr1^{shr 0};
        g3:=pixel_ptr1^ shr 8 ;
        b3:=pixel_ptr1^ shr 16;
        r4:=pixel_ptr0^{shr 0};
        g4:=pixel_ptr0^ shr 8 ;
        b4:=pixel_ptr0^ shr 16;
        Inc(pixel_ptr0);
        r5:=pixel_ptr0^{shr 0};
        g5:=pixel_ptr0^ shr 8 ;
        b5:=pixel_ptr0^ shr 16;
        Inc(pixel_ptr1,bmp_dst_width);
        r6:=pixel_ptr1^{shr 0};
        g6:=pixel_ptr1^ shr 8 ;
        b6:=pixel_ptr1^ shr 16;
        Inc(pixel_ptr0,bmp_dst_width-1);
        r7:=pixel_ptr0^{shr 0};
        g7:=pixel_ptr0^ shr 8 ;
        b7:=pixel_ptr0^ shr 16;
        Inc(pixel_ptr0);
        r8:=pixel_ptr0^{shr 0};
        g8:=pixel_ptr0^ shr 8 ;
        b8:=pixel_ptr0^ shr 16;
        Dec(pixel_ptr0,bmp_dst_width+1); // Reset left -top    pixel pointer
        Dec(pixel_ptr1,bmp_dst_width);   // Reset right-top    pixel pointer
        Dec(pixel_ptr2);                 // Reset left -bottom pixel pointer
        r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
        g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
        b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
        pixel_ptr0^:=RGB(r,g,b); {$endregion}}

        {Right-Top Pixel---} {$region -fold}
        Dec(pixel_ptr3);
        r0:=pixel_ptr3^>>00;
        g0:=pixel_ptr3^>>08;
        b0:=pixel_ptr3^>>16;
        Inc(pixel_ptr3);
        r1:=pixel_ptr3^>>00;
        g1:=pixel_ptr3^>>08;
        b1:=pixel_ptr3^>>16;
        r2:=pixel_ptr2^>>00;
        g2:=pixel_ptr2^>>08;
        b2:=pixel_ptr2^>>16;
        Dec(pixel_ptr1);
        r3:=pixel_ptr1^>>00;
        g3:=pixel_ptr1^>>08;
        b3:=pixel_ptr1^>>16;
        Inc(pixel_ptr1);
        r4:=pixel_ptr1^>>00;
        g4:=pixel_ptr1^>>08;
        b4:=pixel_ptr1^>>16;
        r5:=pixel_ptr0^>>00;
        g5:=pixel_ptr0^>>08;
        b5:=pixel_ptr0^>>16;
        Inc(pixel_ptr1,bmp_dst_width-1);
        r6:=pixel_ptr1^>>00;
        g6:=pixel_ptr1^>>08;
        b6:=pixel_ptr1^>>16;
        Inc(pixel_ptr1);
        r7:=pixel_ptr1^>>00;
        g7:=pixel_ptr1^>>08;
        b7:=pixel_ptr1^>>16;
        Inc(pixel_ptr0,bmp_dst_width);
        r8:=pixel_ptr0^>>00;
        g8:=pixel_ptr0^>>08;
        b8:=pixel_ptr0^>>16;
        Dec(pixel_ptr0,bmp_dst_width); // Reset left -top pixel pointer
        Dec(pixel_ptr1,bmp_dst_width); // Reset right-top pixel pointer
        r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
        g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
        b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
        pixel_ptr1^:=RGB(r,g,b); {$endregion}

        {Left-Bottom Pixel-} {$region -fold}
        Dec(pixel_ptr3,bmp_dst_width);
        r0:=pixel_ptr3^>>00;
        g0:=pixel_ptr3^>>08;
        b0:=pixel_ptr3^>>16;
        Dec(pixel_ptr2,bmp_dst_width);
        r1:=pixel_ptr2^>>00;
        g1:=pixel_ptr2^>>08;
        b1:=pixel_ptr2^>>16;
        Inc(pixel_ptr2);
        r2:=pixel_ptr2^>>00;
        g2:=pixel_ptr2^>>08;
        b2:=pixel_ptr2^>>16;
        Inc(pixel_ptr3,bmp_dst_width);
        r3:=pixel_ptr3^>>00;
        g3:=pixel_ptr3^>>08;
        b3:=pixel_ptr3^>>16;
        Inc(pixel_ptr2,bmp_dst_width-1);
        r4:=pixel_ptr2^>>00;
        g4:=pixel_ptr2^>>08;
        b4:=pixel_ptr2^>>16;
        Inc(pixel_ptr2);
        r5:=pixel_ptr2^>>00;
        g5:=pixel_ptr2^>>08;
        b5:=pixel_ptr2^>>16;
        r6:=pixel_ptr1^>>00;
        g6:=pixel_ptr1^>>08;
        b6:=pixel_ptr1^>>16;
        r7:=pixel_ptr0^>>00;
        g7:=pixel_ptr0^>>08;
        b7:=pixel_ptr0^>>16;
        Inc(pixel_ptr0);
        r8:=pixel_ptr0^>>00;
        g8:=pixel_ptr0^>>08;
        b8:=pixel_ptr0^>>16;
        Dec(pixel_ptr0); // Reset left-top    pixel pointer
        Dec(pixel_ptr2); // Reset left-bottom pixel pointer
        r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
        g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
        b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
        pixel_ptr2^:=RGB(r,g,b); {$endregion}

        {Right-Bottom Pixel} {$region -fold}
        Dec(pixel_ptr3,bmp_dst_width+1);
        r0:=pixel_ptr3^>>00;
        g0:=pixel_ptr3^>>08;
        b0:=pixel_ptr3^>>16;
        Inc(pixel_ptr3);
        r1:=pixel_ptr3^>>00;
        g1:=pixel_ptr3^>>08;
        b1:=pixel_ptr3^>>16;
        Dec(pixel_ptr2,bmp_dst_width);
        r2:=pixel_ptr2^>>00;
        g2:=pixel_ptr2^>>08;
        b2:=pixel_ptr2^>>16;
        Inc(pixel_ptr3,bmp_dst_width-1);
        r3:=pixel_ptr3^>>00;
        g3:=pixel_ptr3^>>08;
        b3:=pixel_ptr3^>>16;
        Inc(pixel_ptr3);
        r4:=pixel_ptr3^>>00;
        g4:=pixel_ptr3^>>08;
        b4:=pixel_ptr3^>>16;
        Inc(pixel_ptr2,bmp_dst_width);
        r5:=pixel_ptr2^>>00;
        g5:=pixel_ptr2^>>08;
        b5:=pixel_ptr2^>>16;
        Dec(pixel_ptr1);
        r6:=pixel_ptr1^>>00;
        g6:=pixel_ptr1^>>08;
        b6:=pixel_ptr1^>>16;
        Inc(pixel_ptr1);
        r7:=pixel_ptr1^>>00;
        g7:=pixel_ptr1^>>08;
        b7:=pixel_ptr1^>>16;
        r8:=pixel_ptr0^>>00;
        g8:=pixel_ptr0^>>08;
        b8:=pixel_ptr0^>>16;
        r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
        g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
        b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
        pixel_ptr3^:=RGB(r,g,b); {$endregion}

        {Top Line----------} {$region -fold}
        for i:=1 to rct_dst.width-2 do
          begin
            r0:=pixel_ptr2^>>00;
            g0:=pixel_ptr2^>>08;
            b0:=pixel_ptr2^>>16;
            Inc(pixel_ptr2);
            r1:=pixel_ptr2^>>00;
            g1:=pixel_ptr2^>>08;
            b1:=pixel_ptr2^>>16;
            Inc(pixel_ptr2);
            r2:=pixel_ptr2^>>00;
            g2:=pixel_ptr2^>>08;
            b2:=pixel_ptr2^>>16;
            r3:=pixel_ptr0^>>00;
            g3:=pixel_ptr0^>>08;
            b3:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r4:=pixel_ptr0^>>00;
            g4:=pixel_ptr0^>>08;
            b4:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r5:=pixel_ptr0^>>00;
            g5:=pixel_ptr0^>>08;
            b5:=pixel_ptr0^>>16;
            Inc(pixel_ptr0,bmp_dst_width-2);
            r6:=pixel_ptr0^>>00;
            g6:=pixel_ptr0^>>08;
            b6:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r7:=pixel_ptr0^>>00;
            g7:=pixel_ptr0^>>08;
            b7:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r8:=pixel_ptr0^>>00;
            g8:=pixel_ptr0^>>08;
            b8:=pixel_ptr0^>>16;
            Dec(pixel_ptr0,bmp_dst_width+1);
            Dec(pixel_ptr2);
            r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
            g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
            b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
            pixel_ptr0^:=RGB(r,g,b);
          end;
        Dec(pixel_ptr0,rct_dst.width-2); // Reset left-top    pixel pointer
        Dec(pixel_ptr2,rct_dst.width-2); // Reset left-bottom pixel pointer
        {$endregion}

        {Left Line---------} {$region -fold}
        for j:=1 to rct_dst.height-2 do
          begin
            r0:=pixel_ptr1^>>00;
            g0:=pixel_ptr1^>>08;
            b0:=pixel_ptr1^>>16;
            r1:=pixel_ptr0^>>00;
            g1:=pixel_ptr0^>>08;
            b1:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r2:=pixel_ptr0^>>00;
            g2:=pixel_ptr0^>>08;
            b2:=pixel_ptr0^>>16;
            Inc(pixel_ptr1,bmp_dst_width);
            r3:=pixel_ptr1^>>00;
            g3:=pixel_ptr1^>>08;
            b3:=pixel_ptr1^>>16;
            Inc(pixel_ptr0,bmp_dst_width-1);
            r4:=pixel_ptr0^>>00;
            g4:=pixel_ptr0^>>08;
            b4:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r5:=pixel_ptr0^>>00;
            g5:=pixel_ptr0^>>08;
            b5:=pixel_ptr0^>>16;
            Inc(pixel_ptr1,bmp_dst_width);
            r6:=pixel_ptr1^>>00;
            g6:=pixel_ptr1^>>08;
            b6:=pixel_ptr1^>>16;
            Inc(pixel_ptr0,bmp_dst_width-1);
            r7:=pixel_ptr0^>>00;
            g7:=pixel_ptr0^>>08;
            b7:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r8:=pixel_ptr0^>>00;
            g8:=pixel_ptr0^>>08;
            b8:=pixel_ptr0^>>16;
            Dec(pixel_ptr0,bmp_dst_width+1);
            Dec(pixel_ptr1,bmp_dst_width);
            r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
            g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
            b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
            pixel_ptr0^:=RGB(r,g,b);
          end;
        Dec(pixel_ptr0,bmp_dst_width*(rct_dst.height-2)); // Reset left -top pixel pointer
        Dec(pixel_ptr1,bmp_dst_width*(rct_dst.height-2)); // Reset right-top pixel pointer
        {$endregion}

        {Right Line--------} {$region -fold}
        Dec(pixel_ptr1);
        for j:=1 to rct_dst.height-2 do
          begin
            r0:=pixel_ptr1^>>00;
            g0:=pixel_ptr1^>>08;
            b0:=pixel_ptr1^>>16;
            Inc(pixel_ptr1);
            r1:=pixel_ptr1^>>00;
            g1:=pixel_ptr1^>>08;
            b1:=pixel_ptr1^>>16;
            r2:=pixel_ptr0^>>00;
            g2:=pixel_ptr0^>>08;
            b2:=pixel_ptr0^>>16;
            Inc(pixel_ptr1,bmp_dst_width-1);
            r3:=pixel_ptr1^>>00;
            g3:=pixel_ptr1^>>08;
            b3:=pixel_ptr1^>>16;
            Inc(pixel_ptr1);
            r4:=pixel_ptr1^>>00;
            g4:=pixel_ptr1^>>08;
            b4:=pixel_ptr1^>>16;
            Inc(pixel_ptr0,bmp_dst_width);
            r5:=pixel_ptr0^>>00;
            g5:=pixel_ptr0^>>08;
            b5:=pixel_ptr0^>>16;
            Inc(pixel_ptr1,bmp_dst_width-1);
            r6:=pixel_ptr1^>>00;
            g6:=pixel_ptr1^>>08;
            b6:=pixel_ptr1^>>16;
            Inc(pixel_ptr1);
            r7:=pixel_ptr1^>>00;
            g7:=pixel_ptr1^>>08;
            b7:=pixel_ptr1^>>16;
            Inc(pixel_ptr0,bmp_dst_width);
            r8:=pixel_ptr0^>>00;
            g8:=pixel_ptr0^>>08;
            b8:=pixel_ptr0^>>16;
            Dec(pixel_ptr0,bmp_dst_width);
            Dec(pixel_ptr1,bmp_dst_width);
            r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
            g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
            b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
            pixel_ptr1^:=RGB(r,g,b);
            Dec(pixel_ptr1);
          end;
        Dec(pixel_ptr0,bmp_dst_width*(rct_dst.height-2));   // Reset left -top pixel pointer
        Dec(pixel_ptr1,bmp_dst_width*(rct_dst.height-2)-1); // Reset right-top pixel pointer
        {$endregion}

        {Bottom Line-------} {$region -fold}
        Dec(pixel_ptr2,bmp_dst_width);
        for i:=1 to rct_dst.width-2 do
          begin
            r0:=pixel_ptr2^>>00;
            g0:=pixel_ptr2^>>08;
            b0:=pixel_ptr2^>>16;
            Inc(pixel_ptr2);
            r1:=pixel_ptr2^>>00;
            g1:=pixel_ptr2^>>08;
            b1:=pixel_ptr2^>>16;
            Inc(pixel_ptr2);
            r2:=pixel_ptr2^>>00;
            g2:=pixel_ptr2^>>08;
            b2:=pixel_ptr2^>>16;
            Inc(pixel_ptr2,bmp_dst_width-2);
            r3:=pixel_ptr2^>>00;
            g3:=pixel_ptr2^>>08;
            b3:=pixel_ptr2^>>16;
            Inc(pixel_ptr2);
            r4:=pixel_ptr2^>>00;
            g4:=pixel_ptr2^>>08;
            b4:=pixel_ptr2^>>16;
            Inc(pixel_ptr2);
            r5:=pixel_ptr2^>>00;
            g5:=pixel_ptr2^>>08;
            b5:=pixel_ptr2^>>16;
            r6:=pixel_ptr0^>>00;
            g6:=pixel_ptr0^>>08;
            b6:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r7:=pixel_ptr0^>>00;
            g7:=pixel_ptr0^>>08;
            b7:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r8:=pixel_ptr0^>>00;
            g8:=pixel_ptr0^>>08;
            b8:=pixel_ptr0^>>16;
            Dec(pixel_ptr2);
            r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
            g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
            b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
            pixel_ptr2^:=RGB(r,g,b);
            Dec(pixel_ptr0);               // Reset left-top    pixel pointer
            Dec(pixel_ptr2,bmp_dst_width); // Reset left-bottom pixel pointer
          end;
        Dec(pixel_ptr0,rct_dst.width-2); // Reset left-top    pixel pointer
        Inc(pixel_ptr2,d_width+2);       // Reset left-bottom pixel pointer
        {$endregion}

      end;

  end; {$endregion}
  }
  {Inner Rectangle Area} {$region -fold}
  {
  blur_type:
    00: {Fast----}
    01: {g to r--}
    02: {b to r--}
    03: {r to g--}
    04: {b to g--}
    05: {r to b--}
    06: {g to b--}
    07: {b,g to r}
    08: {r,b to g}
    09: {r,g to b}
    10: {Slow----}
  }
  PPBlurProc[blur_type](bmp_dst_ptr,rct_dst,bmp_dst_width); {$endregion}

end; {$endregion}
procedure PPBlur             (                  constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref rct_src:TPtRect; constref rct_dst:TPtRectB; constref bmp_src_width,bmp_dst_width:TColor; constref blur_type:byte=0                                                 ); {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  if (rct_src.width<=0) or (rct_src.height<=0) then
    Exit;
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(bmp_src_ptr+rct_src.       left+rct_src.       top*bmp_src_width);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.pt_rct.left+rct_dst.pt_rct.top*bmp_dst_width);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
          if (src_pixel_ptr^>>24<>0) then
            dst_pixel_ptr^:=RGB((Byte(    ((dst_pixel_ptr-bmp_dst_width-1)^)>>00)+Byte(    ((dst_pixel_ptr-bmp_dst_width+1)^)>>00)+Byte(    ((dst_pixel_ptr+bmp_dst_width-1)^)>>00)+Byte(    ((dst_pixel_ptr+bmp_dst_width+1)^)>>00))>>2,
                                (Byte(Word((dst_pixel_ptr-bmp_dst_width-1)^)>>08)+Byte(Word((dst_pixel_ptr-bmp_dst_width+1)^)>>08)+Byte(Word((dst_pixel_ptr+bmp_dst_width-1)^)>>08)+Byte(Word((dst_pixel_ptr+bmp_dst_width+1)^)>>08))>>2,
                                (Byte(    ((dst_pixel_ptr-bmp_dst_width-1)^)>>16)+Byte(    ((dst_pixel_ptr-bmp_dst_width+1)^)>>16)+Byte(    ((dst_pixel_ptr+bmp_dst_width-1)^)>>16)+Byte(    ((dst_pixel_ptr+bmp_dst_width+1)^)>>16))>>2);
          Inc(src_pixel_ptr);
          Inc(dst_pixel_ptr);
        end;
      Inc(src_pixel_ptr,d_width1);
      Inc(dst_pixel_ptr,d_width2);
    end;
end; {$endregion}

// (Color Correction) Цветокоррекция:
procedure PPColorCorrectionM0(ColorizeM:TFunc0; constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor; constref pow:byte=32; alpha_max:byte=255); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  d            : smallint;
begin
  if (pow>=128) then
    Exit;
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  d            :=(pow-128)<<1;
  d_width      := bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
              dst_pixel_ptr^:=ColorizeM(dst_pixel_ptr^,0,0,0,0,0,0,d);
          Inc(dst_pixel_ptr);
        end;
      Inc(dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPColorCorrectionP0(ColorizeP:TFunc0; constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor; constref pow:byte=32; alpha_max:byte=255); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  d            : smallint;
begin
  if (pow<128) then
    Exit;
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  d            :=(pow-128)<<1;
  d_width      := bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
              dst_pixel_ptr^:=ColorizeP(dst_pixel_ptr^,0,0,0,0,0,0,d);
          Inc(dst_pixel_ptr);
        end;
      Inc(dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPColorCorrectionM0(ColorizeM:TFunc0; constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref rct_src:TPtRect; constref rct_dst:TPtRectB; constref bmp_src_width,bmp_dst_width:TColor; constref pow:byte=32; alpha_max:byte=255); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  d_width1     : integer;
  d_width2     : integer;
  x,y          : integer;
  d            : smallint;
begin
  if (pow>=128) then
    Exit;
  if (rct_src.width<=0) or (rct_src.height<=0) then
    Exit;
  d            :=(pow-128)<<1;
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(bmp_src_ptr+rct_src.       left+rct_src.       top*bmp_src_width);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.pt_rct.left+rct_dst.pt_rct.top*bmp_dst_width);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
          if (src_pixel_ptr^>>24<>0) then
            dst_pixel_ptr^:=ColorizeM(dst_pixel_ptr^,0,0,0,0,0,0,d);
          Inc(src_pixel_ptr);
          Inc(dst_pixel_ptr);
        end;
      Inc(src_pixel_ptr,d_width1);
      Inc(dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
procedure PPColorCorrectionP0(ColorizeP:TFunc0; constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref rct_src:TPtRect; constref rct_dst:TPtRectB; constref bmp_src_width,bmp_dst_width:TColor; constref pow:byte=32; alpha_max:byte=255); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  d_width1     : integer;
  d_width2     : integer;
  x,y          : integer;
  d            : smallint;
begin
  if (pow<128) then
    Exit;
  if (rct_src.width<=0) or (rct_src.height<=0) then
    Exit;
  d            :=(pow-128)<<1;
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(bmp_src_ptr+rct_src.       left+rct_src.       top*bmp_src_width);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.pt_rct.left+rct_dst.pt_rct.top*bmp_dst_width);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
          if (src_pixel_ptr^>>24<>0) then
            dst_pixel_ptr^:=ColorizeP(dst_pixel_ptr^,0,0,0,0,0,0,d);
          Inc(src_pixel_ptr);
          Inc(dst_pixel_ptr);
        end;
      Inc(src_pixel_ptr,d_width1);
      Inc(dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
procedure PPColorCorrectionM1(ColorizeM:TFunc1; constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref rct_src:TPtRect; constref rct_dst:TPtRectB; constref bmp_src_width,bmp_dst_width:TColor; constref pow:byte=32; alpha_max:byte=255); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  d_width1     : integer;
  d_width2     : integer;
  x,y          : integer;
  d            : smallint;
begin
  if (pow>=128) then
    Exit;
  if (rct_src.width<=0) or (rct_src.height<=0) then
    Exit;
  d            :=(pow-128)<<1;
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(bmp_src_ptr+rct_src.       left+rct_src.       top*bmp_src_width);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.pt_rct.left+rct_dst.pt_rct.top*bmp_dst_width);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
          if (src_pixel_ptr^>>24=alpha_max) then
            dst_pixel_ptr^:=ColorizeM(dst_pixel_ptr^,0,d)
          else
          if (src_pixel_ptr^>>24<alpha_max) and (src_pixel_ptr^>>24>0) then
            dst_pixel_ptr^:=ColorizeM(dst_pixel_ptr^,alpha_max-src_pixel_ptr^>>24,d);
          Inc(src_pixel_ptr);
          Inc(dst_pixel_ptr);
        end;
      Inc(src_pixel_ptr,d_width1);
      Inc(dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
procedure PPColorCorrectionP1(ColorizeP:TFunc1; constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref rct_src:TPtRect; constref rct_dst:TPtRectB; constref bmp_src_width,bmp_dst_width:TColor; constref pow:byte=32; alpha_max:byte=255); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  d_width1     : integer;
  d_width2     : integer;
  x,y          : integer;
  d            : smallint;
begin
  if (pow<128) then
    Exit;
  if (rct_src.width<=0) or (rct_src.height<=0) then
    Exit;
  d            :=(pow-128)<<1;
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(bmp_src_ptr+rct_src.       left+rct_src.       top*bmp_src_width);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.pt_rct.left+rct_dst.pt_rct.top*bmp_dst_width);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
          if (src_pixel_ptr^>>24=alpha_max) then
            dst_pixel_ptr^:=ColorizeP(dst_pixel_ptr^,0,d)
          else
          if (src_pixel_ptr^>>24<alpha_max) and (src_pixel_ptr^>>24>0) then
            dst_pixel_ptr^:=ColorizeP(dst_pixel_ptr^,alpha_max-src_pixel_ptr^>>24,d);
          Inc(src_pixel_ptr);
          Inc(dst_pixel_ptr);
        end;
      Inc(src_pixel_ptr,d_width1);
      Inc(dst_pixel_ptr,d_width2);
    end;
end; {$endregion}

// (GradientTBH(Fading Highlight from Top to Bottom)) Градиент - уменьшение подсветки сверху вниз: {TODO}
procedure PPGradientTBH      (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect ; constref               bmp_dst_width:TColor; constref pow:byte=32); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  r,g,b        : byte;
begin

end; {$endregion}

// (Contrast) Контрастность:
procedure PPContrast1        (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor; constref pow:byte=64); {$region -fold}
var
  contrast_pow : double;
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  r,g,b        : byte;
  pow2         : shortint;
begin
  r   :=128;
  g   :=128;
  b   :=128;
  pow2:=pow;
  if (pow2>0) then
    contrast_pow:=1+(pow2/10)
  else
    contrast_pow:=1-(Sqrt(-pow2)/10);
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          Contrast(dst_pixel_ptr,r,g,b,contrast_pow);
          Inc     (dst_pixel_ptr);
        end;
      Inc         (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPContrast2        (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor; constref pow:byte=64); {$region -fold}
var
  contrast_pow : double;
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  r,g,b        : byte;
  r_,g_,b_     : longword;
  pow2         : shortint;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  r_           :=0;
  g_           :=0;
  b_           :=0;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          Inc(r_,Red  ((dst_pixel_ptr)^));
          Inc(g_,Green((dst_pixel_ptr)^));
          Inc(b_,Blue ((dst_pixel_ptr)^));
          Inc          (dst_pixel_ptr);
        end;
      Inc              (dst_pixel_ptr,d_width);
    end;
  r:=Trunc(r_/(rct_dst.width*rct_dst.height));
  g:=Trunc(g_/(rct_dst.width*rct_dst.height));
  b:=Trunc(b_/(rct_dst.width*rct_dst.height));
  pow2:=pow;
  if (pow2>0) then
    contrast_pow:=1+(pow2/10)
  else
    contrast_pow:=1-(Sqrt(-pow2)/10);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          Contrast(dst_pixel_ptr,r,g,b,contrast_pow);
          Inc     (dst_pixel_ptr);
        end;
      Inc         (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
{$endregion}

end.

unit Fast_Primitives;

{This file contains some routines for fast drawing of primitives like a line,
rectangle,circle,rhombus and their miscellaneous variations, filters, blitters,
CSR-sprites processing etc.}

{$mode objfpc}{$H+,R-,Q-}{$modeswitch advancedrecords}

interface

uses

  {$ifdef Windows}Windows,{$endif}Graphics, Classes, FPCanvas, GraphType, Math, Types, TypInfo, SysUtils, GL;

const

  C_INT              =$10000;

  ONE_SHL_10         =1<<10;

  ONE_SHL_16         =1<<16;
  ONE_SHL_16_M_1     =1<<16-1;

  DEFAULT_SCL_MUL    =6/5;
  DEFAULT_SCL_MUL_INV=5/6;

  FULL_ROT           =pi/180;
  ONE_DIV_BY_FULL_ROT=1/FULL_ROT;

  LN_0_95            =Ln(0.95);

  MAX_SPRITE_WIDTH   =8192{4096};
  MAX_SPRITE_HEIGHT  =8192{4096};

  NT_BIT_MASK_ALPHA  =$FF000000;

  NZ_ITEM_COEFF10    =1+Trunc(Ln(MAXBYTE )/Ln(2));
  NZ_ITEM_COEFF20    =1<<NZ_ITEM_COEFF10-1;
  NZ_ITEM_COEFF11    =1+Trunc(Ln(MAXWORD )/Ln(2));
  NZ_ITEM_COEFF21    =1<<NZ_ITEM_COEFF11-1;
  NZ_ITEM_COEFF12    =1+Trunc(Ln(MAXDWORD)/Ln(2));
  NZ_ITEM_COEFF22    =1<<NZ_ITEM_COEFF12-1;
                      {l.b. - last bit:             l.b.    l.b.    l.b.    l.b.    l.b.    l.b.    l.b.    l.b.   }
  AA_LINE_KIND000    ={00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001;
  AA_LINE_KIND001    ={00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000;
  AA_LINE_KIND002    ={00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000;
  AA_LINE_KIND003    ={00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001;
  AA_LINE_KIND004    ={00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000;
  AA_LINE_KIND005    ={00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001;
  AA_LINE_KIND006    ={01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000;
  AA_LINE_KIND007    ={01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001;
  AA_LINE_KIND008    ={01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001;
  AA_LINE_KIND009    ={01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000;
  AA_LINE_KIND010    ={01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000;
  AA_LINE_KIND011    ={01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001;
  AA_LINE_KIND012    ={01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000;
  AA_LINE_KIND013    ={01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001;
  AA_LINE_KIND014    ={01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000;
  AA_LINE_KIND015    ={11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000;
  AA_LINE_KIND016    ={10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000;
  AA_LINE_KIND017    ={11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000;
  AA_LINE_KIND018    ={10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001;
                      {l.b. - last bit:             l.b.    l.b.    l.b.    l.b.    l.b.    l.b.    l.b.    l.b.   }
  AA_LINE_KIND100    ={11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000;
  AA_LINE_KIND101    ={01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000;
  AA_LINE_KIND102    ={01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000;
  AA_LINE_KIND103    ={11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000;
  AA_LINE_KIND104    ={01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000;
  AA_LINE_KIND105    ={11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000;
  AA_LINE_KIND106    ={01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000;
  AA_LINE_KIND107    ={11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000;
  AA_LINE_KIND108    ={10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000;
  AA_LINE_KIND109    ={00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000;
  AA_LINE_KIND110    ={00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000;
  AA_LINE_KIND111    ={10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000;
  AA_LINE_KIND112    ={00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000;
  AA_LINE_KIND113    ={10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000;
  AA_LINE_KIND114    ={01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000;
  AA_LINE_KIND115    ={00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001;
  AA_LINE_KIND116    ={01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001;
  AA_LINE_KIND117    ={00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001;
  AA_LINE_KIND118    ={11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001;
                      {l.b. - last bit:             l.b.    l.b.    l.b.    l.b.    l.b.    l.b.    l.b.    l.b.   }
  AA_LINE_KIND300    ={00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000;
  AA_LINE_KIND301    ={01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000;

type

  {Some abbreviations:
   - aa   =anti-aliasing;
   - arr  =array;
   - bkgnd=background;
   - bmp  =bitmap;
   - col  =color;
   - clp  =clipped;
   - clr  =clear;
   - crc  =circle;
   - dst  =destination;
   - fil  =fill;
   - ftimg=fast image;
   - grad =gradient;
   - grv  =gradient (vertical);
   - img  =image;
   - inn  =inner;
   - intr =integer;
   - it   =item;
   - ln   =line;
   - mov  =move;
   - mrg  =margin;
   - op   =operation;
   - out  =outer;
   - pix  =pixel;
   - pp   =post-processing;
   - pt   =point(another meaning of the word: partly transparent; depending on the context);
   - ptr  =pointer;
   - pts  =points;
   - rct  =rect=rectangle;
   - reg  =regular;
   - scl  =scale;
   - sel  =select;
   - src  =source;
   - vec  =vector;}

  // Exdended to Be Able to Have ABGR Color Format: !!!!!!!!!!!!!!!!!!!!!!!!!!!!
  PInteger           =PLongWord;
  TColor             =LongWord{-$7FFFFFFF-1..$7FFFFFFF};
  PColor             =^TColor;
  TColorArr          =array of TColor;
  PColorArr          =^TColorArr;
  TColor2Arr         =array of array of TColor;
  PColor2Arr         =^TColor2Arr;



  {Forward Declarations********************************************************}
  TFastActorSet      =class;
  TFastActor         =class;
  TFastImageItem     =class;
  TFastImageProc     =class;
  TFastLine          =class;
  TFastText          =class;
  {****************************************************************************}



  {Miscellaneous Types ********************************************************}
  {Direction Type}
  TMovingDirection   =(mdLeft,
                       mdRight,
                       mdUp,
                       mdDown,
                       mdLeftUp,
                       mdRightUp,
                       mdLeftDown,
                       mdRightDown,
                       mdNone);
  PMovingDirection   =^TMovingDirection;

  {Drawing Style}
  TDrawingStyle      =(dsMonochrome,
                       dsAdditive  ,
                       dsAlphablend,
                       dsInverse   ,
                       dsHighlight ,
                       dsDarken    ,
                       dsGrayscaleR,
                       dsGrayscaleG,
                       dsGrayscaleB,
                       dsNoise     ,
                       dsColorizeR ,
                       dsColorizeG ,
                       dsColorizeB ,
                       dsBlurRGB   ,
                       dsBlurRRB   ,
                       dsBlurRGR   ,
                       dsBlurGGB   ,
                       dsBlurRGG   ,
                       dsBlurBGB   ,
                       dsBlurRBB   ,
                       dsBlurRRR   ,
                       dsBlurGGG   ,
                       dsBlurBBB   ,
                       dsContrast  );
  PDrawingStyle      =^TDrawingStyle;

  TDynamicsStyle     =(dsNone,
                       dsNative,
                       dsSoft,
                       dsSpring,
                       dsRigid);
  PDynamicsStyle     =^TDynamicsStyle;

  {Spline Type}
  TSplineType        =(stFreeHand,
                       stFormula,
                       stRandom,
                       stLoad);
  PSplineType        =^TSplineType;

  {Spline Mode}
  TSplineMode        =(smContinuous,
                       smDiscrete,
                       smSpray);
  PSplineMode        =^TSplineMode;

  {Selection}
  TSubgraphOp        =(soSub,
                       soAdd);
  PSubgraphOp        =^TSubgraphOp;

  {Selection Mode}
  TSelectionMode     =(smCircle,
                       smBrush,
                       smRectangle,
                       smRegion,
                       smSelectAll);
  PSelectionMode     =^TSelectionMode;

  {Background Post-Processing}
  TBackgroundStyle   =(bsGrayscale,
                       bsBlur,
                       bsBoth,
                       bsNone);
  PBackgroundStyle   =^TBackgroundStyle;

  {Clipping}
  TClipStyle         =(csClippedEdges1,
                       csClippedEdges2,
                       csRemoveEdges,
                       csResilientEdges,
                       csAdvancedClip);
  PClipStyle         =^TClipStyle;

  {Blur}
  TBorderFilter      =(efNotTiled,
                       efTiled);
  PBorderFilter      =^TBorderFilter;

  {SplineFormula}
  TSplineFormula     =(sfCycloid,
                       sfEpicycloid,
                       sfHypocycloid,
                       sfRose,
                       sfSpiral,
                       sfSuperellipse);
  PSplineFormula     =^TSplineFormula;

  PByteBool          =^boolean;

  TParamType         =(ptLeft,
                       ptTop);
  PParamType         =^TParamType;

  TSclDir            =(sdUp,
                       sdDown,
                       sdNone);
  PSclDir            =^TSclDir;

  TEnum0             =0..3;
  PEnum0             =^TEnum0;

  TEnum1             =0..4;
  PEnum1             =^TEnum1;

  TEnum0Arr          =packed array of TEnum0;
  PEnum0Arr          =^TEnum0Arr;

  TEnum1Arr          =packed array of TEnum1;
  PEnum1Arr          =^TEnum1Arr;

  TEnum2Arr          =array[0..3] of integer;
  PEnum2Arr          =^TEnum2Arr;

  TFunc0Args         =packed record {$region -fold}
    r      :byte;
    g      :byte;
    b      :byte;
    alpha  :byte;
    d_alpha:byte;
    pow    :byte;
    d      :smallint;
  end; {$endregion}
  PFunc0Args         =^TFunc0Args;

  TObjSel            ={packed} record {$region -fold}
    // kind   of selected object(spline, sprite, etc.,...)
    obj_kind:integer;
    // number of selected object inside array of this kind
    obj_id  :integer;
  end; {$endregion}
  PObjSel            =^TObjSel;

  TPtRect            ={packed} record {$region -fold}
    left  : integer;
    top   : integer;
    width : integer;
    height: integer;
    right : integer;
    bottom: integer;
  end; {$endregion}
  PPtRect            =^TPtRect;

  TPtRectF           =packed record {$region -fold}
    left  : double;
    top   : double;
    width : double;
    height: double;
    right : double;
    bottom: double;
  end; {$endregion}
  PPtRectF           =^TPtRectF;

  TPtRectB           =packed record {$region -fold}
    pt_rct  : TPtRect;
    b_left  : boolean;
    b_top   : boolean;
    b_right : boolean;
    b_bottom: boolean;
  end; {$endregion}
  PPtRectB           =^TPtRectB;

  TPtPos             =packed record {$region -fold}
    x,y: integer;
    class operator =(r1,r2:TPtPos): boolean; inline; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PPtPos             =^TPtPos;

  TPtPos2            =packed record {$region -fold}
    x,y: TColor;
    class operator =(r1,r2:TPtPos2): boolean; inline; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PPtPos2            =^TPtPos2;

  TPtPos3            =record        {$region -fold}
    arr        : array[0..5] of word;
    obj_ind    : integer;
    pts_ind    : integer;
    dup_pts_cnt: integer;
    weight     : integer;
    class operator    =(r1,r2      :TPtPos3): boolean; inline; {$ifdef Linux}[local];{$endif}
    class operator    *(r1,r2      :TPtPos3): boolean; inline; {$ifdef Linux}[local];{$endif}
    procedure SetEqual0(var      r1:TPtPos3;
                        constref r2:TPtPos3);          inline; {$ifdef Linux}[local];{$endif}
    procedure SetEqual1(var      r1:TPtPos3;
                        constref r2:TPtPos3);          inline; {$ifdef Linux}[local];{$endif}
    procedure SetEqual2(var      r1:TPtPos3;
                        constref r2:TPtPos3);          inline; {$ifdef Linux}[local];{$endif}
    function  IsEqual  (         r1,
                                 r2:TPtPos3): boolean; inline; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PPtPos3            =^TPtPos3;

  TPtPosF            =packed record {$region -fold}
    x,y: double{single};
    class operator =(r1,r2:TPtPosF): boolean; inline; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PPtPosF            =^TPtPosF;

  TCrPos             ={packed} record {$region -fold}
    x,y,r: integer;
  end; {$endregion}
  PCrPos             =^TCrPos;

  TCrPosF            =packed record {$region -fold}
    x,y,r: double;
  end; {$endregion}
  PCrPosF            =^TCrPosF;

  TLnPos             ={packed} record {$region -fold}
    x0,y0,x1,y1: integer;
  end; {$endregion}
  PLnPos             =^TLnPos;

  TLnPosF            ={packed} record {$region -fold}
    x0,y0,x1,y1: double;
  end; {$endregion}
  PLnPosF            =^TLnPosF;

  TLnPosF2           =packed record {$region -fold}
    x0,y0,x1,y1: double;
    b          : boolean;
  end; {$endregion}
  PLnPosF2           =^TLnPosF2;

  TEdge              ={packed} record {$region -fold}
    first_point: TColor;
    last_point : TColor;
    obj_ind    : TColor;
  end; {$endregion}
  PEdge              =^TEdge;

  TSlPt              ={packed} record {$region -fold}
    point  : TColor;
    obj_ind: TColor;
  end; {$endregion}
  PSlPt              =^TSlPt;

  TRGBA              ={packed} record {$region -fold}
    r,g,b,a: byte;
  end; {$endregion}
  PRGBA              =^TRGBA;

  TRGB               ={packed} record {$region -fold}
    r,g,b: byte;
  end; {$endregion}
  PRGB               =^TRGB;

  TClip              ={packed} record {$region -fold}
    main_part,clip_part: byte;
  end; {$endregion}
  PClip              =^TClip;

  TFX                =packed record {$region -fold}

    // Proc.Indices:
    nt_begin_proc_ind: TClip;//byte{word};
    pt_begin_proc_ind: TClip;//byte{word};
    nt_color_proc_ind: TClip;//byte{word};
    pt_color_proc_ind: TClip;//byte{word};
    nt_value_proc_ind: TClip;//byte{word};
    pt_value_proc_ind: TClip;//byte{word};

    col_pow0         : TColor;
    col_pow1         : TColor;
    cfx_pow0         : byte;
    cfx_pow1         : byte;
    rep_cnt          : byte;
    is_fx_visible    : boolean;
    is_fx_animate    : boolean;
    pt_as_nt         : boolean;
    {Type of Surface-------} {$region -fold}
    // [0..001]
    // 0 - nothing;
    // 1 - src. image;
    nt_pix_srf_type: byte;
    pt_pix_srf_type: byte; {$endregion}
    {Type of Color Effect--} {$region -fold}
    // [0..255]
    // 00 - monochrome       ;
    // 01 - additive         ;
    // 02 - alphablend       ;
    // 03 - inverse          ;
    // 04 - highlight        ;
    // 05 - darken           ;
    // 06 - grayscale r      ;
    // 07 - grayscale g      ;
    // 08 - grayscale b      ;
    // 09 - monochrome noise ;
    // 10 - colorize r       ;
    // 11 - colorize g       ;
    // 12 - colorize b       ;
    // 13 - blurRGB          ;
    // 14 - blurRRB          ;
    // 15 - blurRGR          ;
    // 16 - blurGGB          ;
    // 17 - blurRGG          ;
    // 18 - blurBGB          ;
    // 19 - blurRBB          ;
    // 20 - blurRRR          ;
    // 21 - blurGGG          ;
    // 22 - blurBBB          ;
    // 23 - contrast         ;
    nt_pix_cfx_type: byte;
    pt_pix_cfx_type: byte; {$endregion}
    {Type of Image Changing} {$region -fold}
    // [0..001]
    // 0 - constant;
    // 1 - fading;
    nt_pix_cng_type: byte;
    pt_pix_cng_type: byte; {$endregion}
  end; {$endregion}
  PFX                =^TFX;

  TByteDstFld        =packed record {$region -fold}
    v0,v1: byte
  end; {$endregion}
  PByteDstFld        =^TByteDstFld;

  TBckgdStngs        =packed record {$region -fold}
    // outer(clipping) rectangle:
    rct_clp       :TPtRect;
    // handle of drawing destination surface(background):
    bmp_dst_ptr   :PInteger;
    // width of drawing destination surface(background):
    bmp_dst_width :TColor;
    // height of drawing destination surface(background):
    bmp_dst_height:TColor;
  end; {$endregion}
  PBckgdStngs        =^TBckgdStngs;

  PIList             =^TIList;
  TIList             =packed record {$region -fold}
    next_item: PIList;
    x_ptr    : ^integer;
  end; {$endregion}

  PFList             =^TFList;
  TFList             =packed record {$region -fold}
    next_item: PFList;
    x,y      : double;
  end; {$endregion}

  TGCDGrid           ={packed} record {$region -fold}
    f_ln_kind,a,b,c,d: integer;
  end; {$endregion}
  PGCDGrid           =^TGCDGrid;

  TIntrC4RGB         ={packed} record {$region -fold}
    r,g,b,a: integer;
  end; {$endregion}
  PIntrC4RGB         =^TIntrC4RGB;

  TColor4RGB         ={packed} record {$region -fold}
    r,g,b,a: TColor;
  end; {$endregion}
  PColor4RGB         =^TColor4RGB;

  TGradProp          =packed record {$region -fold}
    y_grad_rng_div_vec: TColor4RGB;
      grad_rng_div_vec: TColor4RGB;
    grad_col_dif      : TIntrC4RGB;
    grad_vec_dif      : integer;
    grad_col0         : TRGBA;
    grad_col1         : TRGBA;
  end; {$endregion}
  PGradProp          =^TGradProp;
  {****************************************************************************}



  {Anti-Aliasing **************************************************************}
  TFastAALine        =packed record {$region -fold}
    first_pt_x: integer;
    first_pt_y: integer;
    line_shift: integer;
    line_kind : byte;
    // 00 - horizontal line: 2 points from left to right;
    // 01 - horizontal line: 2 points from right to left;
    // 02 - horizontal line: outer line from ends to middle;
    // 03 - horizontal line: inner line from middle to ends;
    // 04 - horizontal line: const fill;

    // 05 - vertical   line: 2 points from top to bottom;
    // 06 - vertical   line: 2 points from bottom to top;
    // 07 - vertical   line: inner line from ends to middle;
    // 08 - vertical   line: outer line from middle to ends;
    // 09 - vertical   line: const fill;

    // 10 - 1 point;
    // 11 - circle;
  end; {$endregion}
  PFastAALine        =^TFastAALine;
  {****************************************************************************}



  {Miscellaneous Array Types **************************************************}
  TFastImageItemArr  =array of TFastImageItem;
  PFastImageItemArr  =^TFastImageItemArr;

  TPictArr           =array of TPicture;
  PPictArr           =^TPictArr;

  TFLnArr            =array of TFastLine;
  PFLnArr            =^TFLnArr;

  TFTxArr            =array of TFastText;
  PFTxArr            =^TFTxArr;

  TAALnArr           =array of TFastAALine;
  PAALnArr           =^TAALnArr;

  TObjSelArr         =array of TObjSel;
  PObjSelArr         =^TObjSelArr;

  TRectArr           =array of TRect;
  PRectArr           =^TRectArr;

  T2PtPosFArr        =array of array of TPtPosF;
  P2PtPosFArr        =^T2PtPosFArr;

  TPtPosFArr         =array of TPtPosF;
  PPtPosFArr         =^TPtPosFArr;

  TPtPosArr          =array of TPtPos;
  PPtPosArr          =^TPtPosArr;

  TPtPos3Arr         =array of TPtPos3;
  PPtPos3Arr         =^TPtPos3Arr;

  TEdgeArr           =array of TEdge;
  PEdgeArr           =^TEdgeArr;

  TSlPtArr           =array of TSlPt;
  PSlPtArr           =^TSlPtArr;

  TRGBAArr           =array[0..3] of byte;

  TRctValArr         =array[0..4] of integer;
  PRctValArr         =^TRctValArr;

  TFXArr             =array[{byte}0..15] of TFX;
  PFXArr             =^TFXArr;

  TFX2Arr            =array of TFX;
  PFX2Arr            =^TFX2Arr;

  TDublArr           =array of double;
  PDublArr           =^TDublArr;

  TIntrArr           =array of integer;
  PIntrArr           =^TIntrArr;

  TSmIntArr          =array of smallint;
  PSmIntArr          =^TSmIntArr;

  TShIntArr          =array of shortint;
  PShIntArr          =^TShIntArr;

  TLWordArr          =array of longword;
  PLWordArr          =^TLWordArr;

  TWordArr           =array of word;
  PWordArr           =^TWordArr;

  T1Byte1Arr         =array of byte;
  P1Byte1Arr         =^T1Byte1Arr;

  T1Byte2Arr         =array[{byte}0..15] of byte;
  P1Byte2Arr         =^T1Byte2Arr;

  T2ByteArr          =array of array of byte;
  P2ByteArr          =^T2ByteArr;

  TByteDstFldArr     =array of TByteDstFld;
  PByteDstFldArr     =^TByteDstFldArr;

  TBool1Arr          =array of boolean;
  PBool1Arr          =^TBool1Arr;

  TBool2Arr          =array[0..100] of boolean;
  PBool2Arr          =^TBool2Arr;

  TGCDArr            =array of TGCDGrid;
  PGCDArr            =TGCDArr;

  TStringArr         =array of string;
  PStringArr         =^TStringArr;

  TFontArr           =array of TFont;
  PFontArr           =^TFontArr;
  {****************************************************************************}



  {Procedure Types ************************************************************}
  TProc0             =procedure of object;
  PProc0             =^TProc0;

  TProc1             =procedure(         index           :integer;
                                         image           :TCustomBitmap)  of object;
  PProc1             =^TProc1;

  TProc2             =procedure(var      arr_dst         :TColorArr;
                                constref arr_dst_width   :TColor;
                                constref val             :TColor)         of object;
  PProc2             =^TProc2;

  TProc3             =procedure(constref x0,y0,x1,y1     :integer;
                                constref proc_ptr_a,
                                         proc_ptr_b,
                                         proc_ptr_c      :TProc0)         of object;
  PProc3             =^TProc3;

  TProc4             =procedure(constref bmp_dst_ptr     :PInteger;
                                constref rct_dst         :TPtRect;
                                constref bmp_dst_width   :TColor);
  PProc4             =^TProc4;

  TProc4_1           =procedure(constref bmp_dst_ptr     :PByte;
                                constref rct_dst         :TPtRect;
                                constref bmp_dst_width   :TColor);
  PProc4_1           =^TProc4_1;

  TProc5             =procedure(constref arr0            :T1Byte1Arr;
                                constref bmp_ptr         :PInteger;
                                constref bmp_width,
                                         bmp_height      :TColor;
                                constref rct_dst         :TPtRect;
                                constref col             :TColor;
                                constref alpha           :byte=120);
  PProc5             =^TProc5;

  TProc6             =procedure(constref bmp_dst_ptr     :PInteger;
                                constref rct_dst         :TPtRect;
                                constref bmp_dst_width   :TColor);
  PProc6             =^TProc6;

  TProc7             =procedure(constref x,y             :integer)        of object;
  PProc7             =^TProc7;

  TProc8             =procedure(         pixel_ptr       :PInteger;
                                         bmp_dst_width   :TColor);
  PProc8             =^TProc8;

  TProc9             =procedure(         bmp_src_ptr,
                                         bmp_dst_ptr     :PInteger;
                                constref bmp_dst_width   :TColor;
                                constref rct_src         :TPtRect;
                                constref d_width,
                                         c,s,v,w,
                                         lt,tp,rt,bt     :integer);
  PProc9             =^TProc9;

  TProc10            =procedure(         x,y             :integer;
                                constref pvt             :TPtPosF;
                                var      pts             :TPtPosFArr;
                                constref bmp_dst_ptr     :PInteger;
                                constref rct_clp         :TPtRect)        of object;
  PProc10            =^TProc10;

  TProc11            =procedure(         x,y             :integer;
                                constref pvt             :TPtPosF;
                                var      pts             :TPtPosFArr;
                                constref bmp_dst_ptr     :PInteger;
                                constref rct1,rct2       :TPtRect)        of object;
  PProc11            =^TProc11;

  TProc12            =procedure(         x,y             :integer;
                                var      sel_pts_rect    :TPtRectF)       of object;
  PProc12            =^TProc12;

  TProc13            =procedure(         x,y             :integer)        of object;
  PProc13            =^TProc13;

  TProc14            =procedure(         sender          :TObject)        of object;
  PProc14            =^TProc14;

  TProc16            =procedure(var      pixel           :TColor;
                                constref alpha_fade      :byte;
                                constref pow             :byte=64);
  PProc16            =^TProc16;

  TProc17            =procedure(var      pixel           :TColor;
                                constref alpha_fade      :byte);
  PProc17            =^TProc17;

  TProc18            =procedure(var      pixel           :TColor;
                                constref alpha_fade      :byte;
                                constref d               :smallint);
  PProc18            =^TProc18;

  TProc19            =procedure(         pixel_ptr       :PInteger;
                                         bmp_dst_width   :TColor;
                                constref alpha_fade      :byte);
  PProc19            =^TProc19;

  TFunc0             =function (         pixel           :TColor;
                                constref r               :byte    =000;
                                constref g               :byte    =000;
                                constref b               :byte    =000;
                                constref alpha           :byte    =000;
                                constref d_alpha         :byte    =MAXBYTE;
                                constref pow             :byte    =064;
                                constref d               :smallint=000): TColor;
  PFunc0             =^TFunc0;

  TFunc1             =function (         pixel           :TColor;
                                constref alpha_fade      :byte;
                                constref d               :smallint): TColor;
  PFunc1             =^TFunc1;

  TFunc2             =function (         pixel           :TColor;
                                constref r,g,b           :byte;
                                         alpha,d_alpha   :byte;
                                constref alpha_fade      :byte;
                                constref pow             :byte;
                                constref d               :smallint): TColor;
  PFunc2             =^TFunc2;

  TFunc3             =function (         pixel           :TColor;
                                constref pow             :byte): TColor;
  PFunc3             =^TFunc3;
  {****************************************************************************}



  {Text Properties(Attributes) ************************************************}
  TFTextProp         =packed record {$region -fold}
    // background color:
    bkgnd_col    : TColor;
    // background drawing:
    bkgnd_draw   : boolean;
    // background random color:
    bkgnd_rnd_col: boolean;
  end; {$endregion}
  PFTextProp         =^TFTextProp;
  {****************************************************************************}



  {Spline Properties(Attributes) **********************************************}
  TCurveProp         =packed record {$region -fold}

    {Miscellaneous}
    // duplicated points id:
    dup_pts_id               : TPtPos3;
    // global spline object index:
    curve_obj_ind            : TColor;
    // spline points count:
    pts_cnt                  : TColor;
    //
    pts_cnt_val              : TColor;
    // edges simplification angle:
    eds_smpl_angle           : single;

    {Edges Bounds}
    // edges bounds color(pointer ):
    rct_eds_col_ptr          : PColor;
    // edges bounds color(value   ):
    rct_eds_col              : TColor;
    // edges bounds color(inverted):
    rct_eds_col_inv          : TColor;
    // edges bounds color(random  ):
    rct_eds_col_rnd          : boolean;
    // edges bounds color(fall-off):
    rct_eds_col_fall_off     : boolean;
    rct_eds_col_fall_off_inc : byte;

    {Points Bounds}
    // points bounds color(pointer ):
    rct_pts_col_ptr          : PColor;
    // points bounds color(value   ):
    rct_pts_col              : TColor;
    // points bounds color(inverted):
    rct_pts_col_inv          : TColor;
    // points bounds color(random  ):
    rct_pts_col_rnd          : boolean;
    // points bounds color(fall-off):
    rct_pts_col_fall_off     : boolean;
    rct_pts_col_fall_off_inc : byte;

    {Edges}
    // edges color(pointer ):
    eds_col_ptr              : PColor;
    // edges color(value   ):
    eds_col                  : TColor;
    // edges color(inverted):
    eds_col_inv              : TColor;
    // edges color(random  ):
    eds_col_rnd              : boolean;
    // edges color(fall-off):
    eds_col_fall_off         : boolean;
    eds_col_fall_off_inc     : byte;
    // edges width:
    eds_width                : TColor;
    // edges width half:
    eds_width_half           : TColor;
    // edges width parity:
    eds_width_odd            : TColor;
    // edges anti-aliasing:
    eds_aa                   : boolean;
    // points color pointer:

    {Points}
    // points color(pointer ):
    pts_col_ptr              : PInteger;
    // points color(value   ):
    pts_col                  : TColor;
    // points color(inverted):
    pts_col_inv              : TColor;
    // points color(random  ):
    pts_col_rnd              : boolean;
    // points color(fall-off):
    pts_col_fall_off         : boolean;
    pts_col_fall_off_inc     : byte;
    // point width:
    pts_width                : TColor;
    // point width  half:
    pts_width__half          : TColor;
    // point width parity:
    pts_width__odd           : TColor;
    // point height:
    pts_height               : TColor;
    // point height half:
    pts_height_half          : TColor;
    // point height parity:
    pts_height_odd           : TColor;

    {Custom Point-Rectangle}
    rct_val_arr              : TRctValArr;
    // point rectangle width:
    pts_rct_width            : TColor;
    // point rectangle width half:
    pts_rct_width__half      : TColor;
    // point rectangle width parity:
    pts_rct_width__odd       : TColor;
    // point rectangle height:
    pts_rct_height           : TColor;
    // point rectangle height half:
    pts_rct_height_half      : TColor;
    // point rectangle height parity:
    pts_rct_height_odd       : TColor;
    // point rectangle thickness left:
    pts_rct_tns_left         : TColor;
    // point rectangle thickness top:
    pts_rct_tns_top          : TColor;
    // point rectangle thickness right:
    pts_rct_tns_right        : TColor;
    // point rectangle thickness bottom:
    pts_rct_tns_bottom       : TColor;
    // point rectangle inner width:
    pts_rct_inn_width        : TColor;
    // point rectangle inner width parity:
    pts_rct_inn_width__odd   : TColor;
    // point rectangle inner height:
    pts_rct_inn_height       : TColor;
    // point rectangle inner height parity:
    pts_rct_inn_height_odd   : TColor;

    {Custom Point-Circle}
    // point inner radius:
    pts_crc_diam_inn         : TColor;
    // point inner radius half:
    pts_crc_diam_inn_half    : TColor;
    // point outer radius:
    pts_crc_diam_out         : TColor;
    // point outer radius half:
    pts_crc_diam_out_half    : TColor;

    {Custom Point-Polygon}
    // point polygon width:
    pts_plg_diam             : TColor;
    // point polygon width half:
    pts_plg_diam_half        : TColor;
    // point polygon angles count:
    pts_plg_ang_cnt          : TColor;

    {Custom Point-Sprite}
    // point sprite width:
    pts_srt_width            : TColor;
    // point sprite height:
    pts_srt_height           : TColor;

    // points drawing frequance:
    sln_pts_frq              : word;
    // spline type:
    sln_type                 : TSplineType;
    // spline mode:
    sln_mode                 : TSplineMode;
    // spray radius:
    spray_rad                : TColor;
    // edges  blending:
    eds_bld_stl              : TDrawingStyle;
    // points blending:
    pts_bld_stl              : TDrawingStyle;
    // edges  bounds blending:
    rct_eds_bld_stl          : TDrawingStyle;
    // points bounds blending:
    rct_pts_bld_stl          : TDrawingStyle;
    // edges clipping:
    clp_stl                  : TClipStyle;
    // edges level of details:
    eds_lod                  : boolean;
    // simplification angle
    eds_simpl_angle          : double;
    // hidden-line elimination:
    hid_ln_elim              : boolean;
    // best regular(not grid) clipping quality:
    best_ends_quality        : boolean;
    // best precision for hidden-line elimination:
    best_precision           : boolean;
    // lazy_repaint:
    lazy_repaint             : boolean;
    lazy_repaint_prev        : boolean;
    // byte mode:
    byte_mode                : boolean;
    better_quality           : boolean;
    // grid clipping:
    grid_clipping_eds        : boolean;
    grid_clipping_pts        : boolean;
    grid_clipping_obj        : boolean;
    // only fit to window:
    only_fit_to_wnd_calc     : boolean;
    // free memory on out of window:
    free_mem_on_out_of_wnd   : boolean;
    // free memory on scale down:
    free_mem_on_scale_down   : boolean;
    // reallocate memory if previous pixels count is less than current pixels count:
    realloc_mem              : boolean;
    // remove brunching:
    remove_brunching         : boolean;
    // edges bounding rectangle:
    rct_eds_show             : boolean;
    // points bounding rectangle:
    rct_pts_show             : boolean;
    // edges  visibility:
    eds_show                 : boolean;
    // points visibility:
    pts_show                 : boolean;
    // connect ends:
    cnc_ends                 : boolean;
    // invert points indices order:
    pts_ord_inv              : boolean;
    // is object out of window:
    is_out_of_wnd            : boolean;
    // dynamics style:
    dyn_stl                  : TDynamicsStyle;

    // formula type:
    fml_type                 : TSplineFormula;

    {Cycloid}
    // points count:
    cycloid_pts_cnt          : TColor;
    // loops count:
    cycloid_loop_cnt         : TColor;
    // loop radius:
    cycloid_loop_rad         : double;
    // curvature:
    cycloid_curvature        : double;
    // curve direction on axis x:
    cycloid_dir_x            : TMovingDirection;
    // curve direction on axis y:
    cycloid_dir_y            : TMovingDirection;

    {Epicycloid}
    // points count:
    epicycloid_pts_cnt       : TColor;
    // petals count:
    epicycloid_petals_cnt    : double;
    // curve radius:
    epicycloid_rad           : double;
    // rotation angle:
    epicycloid_rot           : double;
    // cut on angle:
    epicycloid_angle         : double;

    {Rose}
    // points count:
    rose_pts_cnt             : TColor;
    // petals count:
    rose_petals_cnt          : double;
    // curve radius:
    rose_rad                 : double;
    // rotation angle:
    rose_rot                 : double;
    // cut on angle:
    rose_angle               : double;
    // mobius_grid:
    rose_mobius_grid         : boolean;

    {Spiral}
    // points count:
    spiral_pts_cnt           : TColor;
    // coil step:
    spiral_coil_step         : double;
    // curve radius:
    spiral_rad               : double;
    // rotation angle:
    spiral_rot               : double;
    // cut on angle:
    spiral_angle             : double;

    {Superellipse}
    // points count:
    superellipse_pts_cnt     : TColor;
    // curvature:
    superellipse_curvature0  : double;
    superellipse_curvature1  : double;
    superellipse_curvature2  : double;
    superellipse_curvature3  : double;
    // curve radius:
    superellipse_rad         : double;
    // rotation angle:
    superellipse_rot         : double;
    // cut on angle:
    superellipse_angle       : double;

    {TODO}

  end; {$endregion}
  PCurveProp         =^TCurveProp;
  {****************************************************************************}



  {Select Items Properties(Attributes) ****************************************}
  TSelItProp         =packed record {$region -fold}
    bkgnd_style   : TBackgroundStyle;
    selection_mode: TSelectionMode;
  end; {$endregion}
  PSelItProp         =^TSelItProp;
  {****************************************************************************}



  {Color Information **********************************************************}
  TEquidistantCurve  =packed record {$region -fold}
    pts     : TColorArr;

    //...
  end; {$endregion}
  PEquidistantCurve  =^TEquidistantCurve;
  {****************************************************************************}



  {Color Information **********************************************************}
  TColorInfo         =packed record {$region -fold}
    pix_col : TColor;
    r,g,b   : byte;
      alpha1: byte;
    d_alpha1: byte;
      alpha2: byte;
    d_alpha2: byte;
  end; {$endregion}
  PColorInfo         =^TColorInfo;
  {****************************************************************************}



  {Fast Actors Container ******************************************************}
  TFastActorSet      =class {$region -fold}
    // list of actors:
    act_arr       : array of TFastActor;
    // dummy icon:
    d_icon        : TFastImageItem;
    // array of actors positions:
    act_pos_arr   : TPtPosFArr;
    // selection field:
    sel_fld       : TColorArr;
    sel_fld_ptr   : PInteger;
    // actors count:
    act_cnt       : TColor;
    // first frame rect:
    first_frm_rect: TPtRect;
    // init. part:
    constructor Create(constref bkgnd_ptr         :PInteger;
                       constref bkgnd_width,
                                bkgnd_height      :TColor;
                       var      rct_clp           :TPtRect;
                       constref bmp_src_rct       :TPtRect;
                       constref location          :string='';
                       constref ImgLstGetBmp      :TProc1=Nil;
                       constref d_icon_img_lst_ind:TColor=0);  {$ifdef Linux}[local];{$endif}
    destructor  Destroy;                             override; {$ifdef Linux}[local];{$endif}
    // add actor;
    procedure AddActor(x,y                        :integer);   {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PFastActorSet      =^TFastActorSet;
  {****************************************************************************}



  {Fast Image Container *******************************************************}
  TFastActorInstInfo =packed record {$region -fold}
    frm_ind         : integer;
    bmp_ftimg_left  : integer;
    bmp_ftimg_top   : integer;
    bmp_ftimg_right : integer;
    bmp_ftimg_bottom: integer;
    monochrome_val  : TColor;
    fx_arr          : TFXArr;
    fx_cnt          : byte;
    {Type of Image Drawing-------} {$region -fold}
    // 0 - color;
    // 1 - value;
    // 2 - color
    // and value;
    pix_drw_type    : byte; {$endregion}
    {Type of Surface-------------} {$region -fold}
    // 0 - nothing;
    // 1 - src. image;
    // 2 - dst. background;
    nt_pix_srf_type : byte;
    pt_pix_srf_type : byte; {$endregion}
    {Type of Color Effect--------} {$region -fold}
    // 0 - monochrome;
    // 1 - additive;
    // 2 - alphablend;
    nt_pix_cfx_type : byte;
    pt_pix_cfx_type : byte; {$endregion}
    {Type of Image Clipping------} {$region -fold}
    // 0 - not clippped;
    // 1 - top-bottom clippped;
    // 2 - left-right-top-bottom clippped;
    nt_pix_clp_type : byte;
    pt_pix_clp_type : byte; {$endregion}
    {Type of Image Changing------} {$region -fold}
    // 0 - constant;
    // 1 - fading;
    nt_pix_cng_type : byte;
    pt_pix_cng_type : byte; {$endregion}
  end; {$endregion}
  PFastActorInstInfo =^TFastActorInstInfo;

  TFastActor         =class {$region -fold}
    // list of frames
    frm_arr      : array of TFastImageItem;
    // list of instances:
    act_inst_arr : array of array of TFastActorInstInfo;
    // list of paths for actor:
    path_ind_arr : TColorArr;
    //
    src_img_color: TBitmap;
    // frames count;
    frm_cnt      : TColor;
    constructor Create;                                      {$ifdef Linux}[local];{$endif}
    destructor  Destroy;                           override; {$ifdef Linux}[local];{$endif}
    {procedure   BakeRot(var      rot_img_:TFastImage;
                        constref angle_  :double); inline;   {$ifdef Linux}[local];{$endif}}
    {Turn One Image          Into Frames}
    //procedure ImgToFrames;           {$ifdef Linux}[local];{$endif}
    {Turn     Image Sequance Into Frames}
    //procedure SqcToFrames;           {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PFastActor         =^TFastActor;
  {****************************************************************************}



  {Fast Image *****************************************************************}
  // Allows to store array in CSR(Compressed Sparse Row) format:
  TRenderType        =(rtDynamic,rtStatic);
  PRenderType        =^TRenderType;

  TFastImageData     =record {$region -fold}

    {Misc. data------------------} {$region -fold}
    nt_pix_intr_arr_ptr   : PInteger;
    pt_pix_intr_arr_ptr   : PInteger;

    // Shader Type Proc. Table:
    sdr_type_ind          : byte;

    // Shader Uber Proc. Table:
    sdr_proc_ind          : byte; {$endregion}

    {Gradient vector-------------} {$region -fold}
    set_grad_to_vis_area  : boolean;
    grad_vec              : TPtPos;
    grad_vec2             : TPtPos;
    grad_col              : TPtPos2;
    grad_prop             : TGradProp; {$endregion}

    {Color and value info--------} {$region -fold}
    monochrome_val        : TColor;
    cfx_pow0              : byte;
    cfx_pow1              : byte;
    pt_as_nt              : boolean;
    // effects param.s array:
    fx_arr                : TFXArr;
    // count of effects:
    fx_cnt                : byte; {$endregion}

    {Color/Alpha of current layer} {$region -fold}
    // NT - not transparent pixels:
    nt_pix_intr_ccl_arr   : TColorArr;

    // PT - partly transparent pixels:
    // color channel:
    pt_pix_intr_ccl_arr   : TColorArr;
    // alpha channel:
    pt_pix_byte_acl_arr   : T1Byte1Arr; {$endregion}

    {Color       of lower   layer} {$region -fold}
    // NT - not transparent pixels:
    nt_pix_intr_cll_arr   : TColorArr;

    // PT - partly transparent pixels:
    pt_pix_intr_cll_arr   : TColorArr; {$endregion}

    {Value       of current layer} {$region -fold}
    // NT - not transparent pixels:
    nt_pix_intr_val_arr   : TColorArr;

    // PT - partly transparent pixels; reserved:
    pt_pix_intr_val_arr   : TColorArr; {$endregion}

    {Items counts in rows--------} {$region -fold}
    // NT - not transparent pixels:
    nt_pix_intr_cnt_arr   : TColorArr;

    // PT - partly transparent pixels:
    pt_pix_intr_cnt_arr   : TColorArr; {$endregion}

    {CSR-Items shifts------------} {$region -fold}
    // NT - not transparent pixels:
    nt_pix_intr_sht_arr   : TColorArr;

    // PT - partly transparent pixels:
    pt_pix_intr_sht_arr   : TColorArr; {$endregion}

    {CSR-Image kind--------------} {$region -fold}
    public
      var
        img_kind              : byte;
        {
        ----------------Image Has Alpha Channel And Color Channel---------------
        0:
        image has:  not monochrome alpha channel,
                    not monochrome color channel,
        count of    not transparent pixels>0;
        count of partly transparent pixels>0;

        1:
        image has:  not monochrome alpha channel,
                    not monochrome color channel,
        count of    not transparent pixels>0;
        count of partly transparent pixels=0;

        2:
        image has:  not monochrome alpha channel,
                    not monochrome color channel,
        count of    not transparent pixels=0;
        count of partly transparent pixels>0;

        3:
        image has:      monochrome alpha channel(white, not transparent),
                    not monochrome color channel,
        count of    not transparent pixels>0;
        count of partly transparent pixels=0;

        4:
        image has:      monochrome alpha channel(transparent),
                    not monochrome color channel,
        count of    not transparent pixels=0;
        count of partly transparent pixels>0;


        ----------------------Image Has Only Alpha Channel----------------------
        5:
        image has:  not monochrome alpha channel,
                                no color channel,
        count of    not transparent pixels>0;
        count of partly transparent pixels>0;

        6:
        image has:  not monochrome alpha channel,
                                no color channel,
        count of    not transparent pixels>0;
        count of partly transparent pixels=0;

        7:
        image has:  not monochrome alpha channel,
                                no color channel,
        count of    not transparent pixels=0;
        count of partly transparent pixels>0;

        8:
        image has:      monochrome alpha channel(white, not transparent),
                                no color channel,
        count of    not transparent pixels>0;
        count of partly transparent pixels=0;

        9:
        image has:      monochrome alpha channel(transparent),
                                no color channel,
        count of    not transparent pixels=0;
        count of partly transparent pixels>0;


        --------------Image Has No Alpha Channel And Color Channel--------------
        10:
        image has:      no alpha channel(black, invisible),
                        no color channel,
        count of    not transparent pixels=0;
        count of partly transparent pixels=0;

        --------------------------Image is Value Array--------------------------
        11:
        count of    not transparent pixels>0;
        count of partly transparent pixels>0;

        ------------------------------Image is Mask-----------------------------
        12:
        count of    not transparent pixels>0;
        count of partly transparent pixels=0;
        } {$endregion}

    {CSR-Image metrics-----------} {$region -fold}
    // pointer to background image(where sprite will be drawn):
    bmp_bkgnd_ptr          : PInteger;
    // background image width:
    bmp_bkgnd_width        : TColor;
    // background image height:
    bmp_bkgnd_height       : TColor;
    //
    bmp_color_ptr          : PInteger;
    //
    bmp_alpha_ptr          : PInteger;
    bmp_alpha_ptr2         : PByte;
    //
    bmp_value_ptr          : PInteger;
    //
    bmp_ftimg_width_origin : TColor;
    bmp_ftimg_width        : TColor;
    //
    bmp_ftimg_height_origin: TColor;
    bmp_ftimg_height       : TColor;
    //
    bmp_ftimg_left         : integer;
    //
    bmp_ftimg_top          : integer;
    //
    bmp_ftimg_right        : integer;
    //
    bmp_ftimg_bottom       : integer;
    //
    scl_mul                : TPtPosF;
    //
    nt_pix_arr_row_mrg_top : TColor;
    //
    nt_pix_arr_row_mrg_btm : TColor;
    //
    pt_pix_arr_row_mrg_top : TColor;
    //
    pt_pix_arr_row_mrg_btm : TColor;
    //
    width_parity           : boolean;
    //
    height_parity          : boolean;
    //
    tile_map_calc          : boolean;
    //
    render_type            : TRenderType;
    //
    alpha_max              : byte;
    //
    remove_brunching       : boolean;
    //
    better_quality         : boolean;
    //
    need_store_value       : boolean;
    //
    realloc_mem            : boolean;
    //
    are_all_fx_animated    : boolean; {$endregion}

    {CSR-Image clipping----------} {$region -fold}
    {Precalculated Table of Counts Vertically(Image Clipping)}
    // NT - not transparent pixels:
    nt_cnt_ind_arr        : TColorArr;
    // PT - partly transparent pixels:
    pt_cnt_ind_arr        : TColorArr;
    //
    rct_clp_ptr           : PPtRect;
    //
    bmp_src_rct_clp       : TPtRect;
    //
    rct_clp_mrg           : TPtRect;
    //
    rct_dst_mrg           : TPtRect;
    //
    rct_src               : TPtRect;
    //
    rct_dst               : TPtRect;
    //
    arr_src_sht           : integer; {$endregion}

    {Tiles copying---------------} {$region -fold}
    // array of tiles bounding rectangles inside one bitmap:
    rect_src_arr          : array of TPtRect;
    // tiles count:
    tiles_cnt             : TColor; {$endregion}

    {Total count of pixels-------} {$region -fold}
    // all pixels:
    al_pix_cnt            : TColor;
    // not    transparent pixels count:
    nt_pix_cnt            : TColor;
    nt_pix_cnt_prev       : TColor;
    // partly transparent pixels count:
    pt_pix_cnt            : TColor;
    pt_pix_cnt_prev       : TColor;
    // count of zero(black) color pixels:
    zr_pix_cnt            : TColor;
    // count of pixels which are equal to first pixel:
    pt_pix_cng_cnt        : TColor; {$endregion}

    {Type of image drawing-------} {$region -fold}
    // 0 - color:
    // 1 - value:
    // 2 - color
    // and value:
    pix_drw_type          : byte; {$endregion}

    {Type of CSR-Image clipping--} {$region -fold}
    // Clipping Proc. Table:
    NTUselessProc         : array[0..002] of TProc2;
    PTUselessProc         : array[0..002] of TProc2;

    // 0 - not clippped;
    // 1 - top-bottom clippped;
    // 2 - left-right-top-bottom clippped;
    // 3 - out of clipping rectangle;
   {nt_pix_clp_type       : byte;
    pt_pix_clp_type       : byte;}
       pix_clp_type       : byte; {$endregion}

    {Type of CSR-Image processing} {$region -fold}
    // 0 - not to draw image(exclude shader);
    // 1 -        draw image(include shader);
    nt_useless            : byte;
    pt_useless            : byte; {$endregion}

    {Tilemap---------------------} {$region -fold}
    //map spline properties:
    sln_prop_var          : TCurveProp;
    //tile map handle:
    tilemap_sprite_ind    : integer;
    //width and height of sprite at mask:
    tilemap_sprite_w_h    : TPtPos; {$endregion}

  end; {$endregion}
  PFastImageData     =^TFastImageData;

  TFastImageItem     =class  {$region -fold}
    fast_image_data: TFastImageData;
    constructor Create  (constref bkgnd_ptr     :PInteger;
                         constref bkgnd_width,
                                  bkgnd_height  :TColor;
                         var      rct_clp       :TPtRect;
                         constref bmp_src_rct   :TPtRect;
                         constref empty         :TColor=0);     {$ifdef Linux}[local];{$endif}
    constructor Create  (constref bkgnd_ptr     :PInteger;
                         constref bkgnd_width,
                                  bkgnd_height  :TColor;
                         var      rct_clp       :TPtRect;
                         constref bmp_src_rct   :TPtRect;
                         constref location      :string  ='';
                         constref ImgLstGetBmp  :TProc1  =Nil;
                         constref img_ind       :TColor  =0;
                         constref tile_map_calc_:boolean =False;
                         constref pic_src       :TPicture=Nil); {$ifdef Linux}[local];{$endif}
    destructor  Destroy; override;                              {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PFastImageItem     =^TFastImageItem;

  TFastImageProc     =class  {$region -fold}

    fast_image_data_ptr0: PFastImageData;
    fast_image_data_ptr1: PFastImageData;
    fast_image_data_ptr2: PFastImageData;

    // Reserved:
    res_var0            : integer;
    res_var1            : integer;
    res_var2            : integer;

    {Proc. Table-----------------} {$region -fold}
    // Image Compression:
    CmpProc             : array[0..012] of TProc0;

    // Image Drawing:
    // NT - not transparent pixels:
    NTValueProc         : array[0..300] of TProc0;
    NTColorProc         : array[0..029] of TProc0;
    NTBeginProc         : array[0..002] of TProc0;
    // PT - partly transparent pixels:
    PTValueProc         : array[0..300] of TProc0;
    PTColorProc         : array[0..029] of TProc0;
    PTBeginProc         : array[0..002] of TProc0;

    // Shader Type Proc. Table:
    SdrType             : array[0..038] of TProc0;

    // Shader Uber Proc. Table:
    SdrProc             : array[0..003] of TProc0;

    // Clipping Proc. Table:
    NTUselessProc       : array[0..002] of TProc2;
    PTUselessProc       : array[0..002] of TProc2; {$endregion}

    {CSR-Image Routines----------} {$region -fold}

    {Clear Arrays------------------------------------------} {$region -fold}
    procedure ClrArr(arr_clear_val:word); inline; {$ifdef Linux}[local];{$endif}
    procedure ClrArr;                     inline; {$ifdef Linux}[local];{$endif} {$endregion}

    {Define Image Kind-------------------------------------} {$region -fold}
    procedure DetImageKind; {$ifdef Linux}[local];{$endif} {$endregion}

    {Create Array    of Items Counts  in Rows from Bitmap--} {$region -fold}
    //** color and alpha are in separate bitmaps
    // NT - not transparent pixels:
    procedure CrtNTCountBmpS; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure CrtPTCountBmpS; {$ifdef Linux}[local];{$endif}
    //** color and alpha are in one bitmap
    // NT - not transparent pixels:
    procedure CrtNTCountBmpO; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure CrtPTCountBmpO; {$ifdef Linux}[local];{$endif} {$endregion}

    {Create Array    of Items Counts  in Rows from Array---} {$region -fold}
    // NT - not transparent pixels:
    procedure CrtNTCountArrA; {$ifdef Linux}[local];{$endif}
    procedure CrtNTCountArrB; {$ifdef Linux}[local];{$endif}
    procedure CrtNTCountArrC; {$ifdef Linux}[local];{$endif}
    procedure CrtNTCountArrD; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure CrtPTCountArrA; {$ifdef Linux}[local];{$endif}
    procedure CrtPTCountArrB; {$ifdef Linux}[local];{$endif}
    procedure CrtPTCountArrC; {$ifdef Linux}[local];{$endif}
    procedure CrtPTCountArrD; {$ifdef Linux}[local];{$endif} {$endregion}

    {Create Array    of Items Shifts  in Rows from Bitmap--} {$region -fold}
    //** color and alpha are in separate bitmaps
    // NT - not transparent pixels:
    procedure CrtNTShiftBmpS; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure CrtPTShiftBmpS; {$ifdef Linux}[local];{$endif}
    //** color and alpha are in one bitmap
    // NT - not transparent pixels:
    procedure CrtNTShiftBmpO; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure CrtPTShiftBmpO; {$ifdef Linux}[local];{$endif} {$endregion}

    {Create Array    of Items Shifts  in Rows from Array---} {$region -fold}
    // NT - not transparent pixels:
    procedure CrtNTShiftArrA; {$ifdef Linux}[local];{$endif}
    procedure CrtNTShiftArrB; {$ifdef Linux}[local];{$endif}
    procedure CrtNTShiftArrC; {$ifdef Linux}[local];{$endif}
    procedure CrtNTShiftArrD; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure CrtPTShiftArrA; {$ifdef Linux}[local];{$endif}
    procedure CrtPTShiftArrB; {$ifdef Linux}[local];{$endif}
    procedure CrtPTShiftArrC; {$ifdef Linux}[local];{$endif}
    procedure CrtPTShiftArrD; {$ifdef Linux}[local];{$endif} {$endregion}

    {Store Color     of Current Layer         from Bmp/Arr-} {$region -fold}
    // NT - not transparent pixels:
    {store color channel}
    procedure StrNTColorBmpA; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    {store color channel}
    procedure StrPTColorBmpA; {$ifdef Linux}[local];{$endif}
    //** color and alpha are in separate bitmaps
    {store alpha channel into byte array---}
    procedure StrPTAlphaArrS; {$ifdef Linux}[local];{$endif}
    {store alpha channel into color channel}
    procedure StrPTAlphaBmpS; {$ifdef Linux}[local];{$endif}
    //** color and alpha are in one bitmap
    {store alpha channel into byte array---}
    procedure StrPTAlphaArrO; {$ifdef Linux}[local];{$endif}
    {store alpha channel into color channel}
    procedure StrPTAlphaBmpO; {$ifdef Linux}[local];{$endif} {$endregion}

    {Store Color     of Lower   Layer         from Bitmap--} {$region -fold}
    // NT - not transparent pixels:
    procedure StrNTLowerBmpA; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure StrPTLowerBmpA; {$ifdef Linux}[local];{$endif}
    // store alpha from byte array:
    procedure StrPTLowerArrA; {$ifdef Linux}[local];{$endif} {$endregion}

    {Store Value     of Current Layer         from Array---} {$region -fold}
    procedure StrNTValueArrA; {$ifdef Linux}[local];{$endif} {$endregion}

    {Set Chess Order of Alpha Channel in Rows from Bitmap--} {$region -fold}
    // calculation of image sides parity
    procedure CalcSidesParity; {$ifdef Linux}[local];{$endif}
    // color and alpha are in separate bitmaps
    // NT - not transparent pixels:
    procedure SetNTChessBmpS0; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure SetPTChessBmpS0; {$ifdef Linux}[local];{$endif}
    // color and alpha are in one bitmap
    // NT - not transparent pixels:
    procedure SetNTChessBmpO0; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure SetPTChessBmpO0; {$ifdef Linux}[local];{$endif} {$endregion}

    {Create Array of Tiles Bounding Rectangles-------------} {$region -fold}
    procedure CrtRectArr; inline; {$ifdef Linux}[local];{$endif} {$endregion}

    {CSR-Image Compression---------------------------------} {$region -fold}
    // img. kind: 000:
    procedure CmpProc000 ; inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 001:
    procedure CmpProc001 ; inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 002:
    procedure CmpProc002 ; inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 003:
    procedure CmpProc003 ; inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 004:
    procedure CmpProc004 ; inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 005:
    procedure CmpProc005 ; inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 006:
    procedure CmpProc006 ; inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 007:
    procedure CmpProc007 ; inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 008:
    procedure CmpProc008 ; inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 009:
    procedure CmpProc009 ; inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 010:
    procedure CmpProc010 ; inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 011:
    procedure CmpProc011 ; inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 012:
    procedure CmpProc012 ; inline; {$ifdef Linux}[local];{$endif}

    procedure CmpProcInit; inline; {$ifdef Linux}[local];{$endif}
    procedure ImgToCImg  ; inline; {$ifdef Linux}[local];{$endif} {$endregion}

    {CSR-Image Drawing-------------------------------------} {$region -fold}

    {Color    FloodFill------------------------------------} {$region -fold}

    // NT - not transparent pixels:

    // auxiliary procedures:
    procedure RegNTColorA_0; inline; {$ifdef Linux}[local];{$endif}
    procedure RegNTColorA_1; inline; {$ifdef Linux}[local];{$endif}

    {Empty}
    procedure RegNTColor009; {$ifdef Linux}[local];{$endif}

    {Color of Curent Layer}
    // (constant) auxiliary procedure:
    procedure RegNTColorA00; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegNTColor000; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTColor002; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTColor004; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTColor006; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Color of Curent Layer(Additive)}
    // (constant) auxiliary procedure:
    procedure RegNTColorA10; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegNTColor010; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTColor012; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTColor014; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTColor016; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedure:
    procedure RegNTColorA11; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure RegNTColor011; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegNTColor013; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegNTColor015; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTColor017; {$ifdef Linux}[local];{$endif}

    {Color of Curent Layer(AlphaBlend)}
    // (constant) auxiliary procedure:
    procedure RegNTColorA20; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegNTColor020; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTColor022; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTColor024; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTColor026; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    // PT - partly transparent pixels;

    // auxiliary procedures:
    procedure RegPTColorA_0; inline; {$ifdef Linux}[local];{$endif}
    procedure RegPTColorA_1; inline; {$ifdef Linux}[local];{$endif}

    {Empty}
    procedure RegPTColor009; {$ifdef Linux}[local];{$endif}

    {Color of Curent Layer}
    // (constant) auxiliary procedures:
    procedure RegPTColorA00; {$ifdef Linux}[local];{$endif}
    procedure RegPTColorB00; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTColor000; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTColor002; {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTColorA04; {$ifdef Linux}[local];{$endif}
    procedure RegPTColorB04; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTColor004; {$ifdef Linux}[local];{$endif}
    // (constant) image has transparent alpha channel:
    procedure RegPTColor006; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Color of Curent Layer(Additive)}
    // (constant) auxiliary procedures:
    procedure RegPTColorA10; {$ifdef Linux}[local];{$endif}
    procedure RegPTColorB10; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTColor010; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTColor012; {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTColorA14; {$ifdef Linux}[local];{$endif}
    procedure RegPTColorB14; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTColor014; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegPTColor016; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTColorA11; {$ifdef Linux}[local];{$endif}
    procedure RegPTColorB11; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure RegPTColor011; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegPTColor013; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTColorA15; {$ifdef Linux}[local];{$endif}
    procedure RegPTColorB15; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegPTColor015; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    // same as (constant);

    {Color of Curent Layer(AlphaBlend)}
    // (constant) auxiliary procedures:
    procedure RegPTColorA20; {$ifdef Linux}[local];{$endif}
    procedure RegPTColorB20; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTColor020; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTColor022; {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTColorA24; {$ifdef Linux}[local];{$endif}
    procedure RegPTColorB24; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTColor024; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {Regular  FloodFill------------------------------------} {$region -fold}

    // NT - not transparent pixels:

    {Value} {$region -fold}

    // auxiliary procedures:
    procedure RegNTValueA_0; inline; {$ifdef Linux}[local];{$endif}
    procedure RegNTValueA_1; inline; {$ifdef Linux}[local];{$endif}

    // not clippped:
    procedure RegNTProc0_0 (constref args :TFunc0Args;
                                     Func0:TFunc0); {$ifdef Linux}[local];{$endif}
    // top-bottom clippped:
    procedure RegNTProc0_2 (constref args :TFunc0Args;
                                     Func0:TFunc0); {$ifdef Linux}[local];{$endif}
    // left-right-top-bottom clippped:
    procedure RegNTProc0_4 (constref args :TFunc0Args;
                                     Func0:TFunc0); {$ifdef Linux}[local];{$endif}
    // not clippped:
    procedure RegNTProc1_0 (         Proc8:TProc8); {$ifdef Linux}[local];{$endif}
    // top-bottom clippped:
    procedure RegNTProc1_2 (         Proc8:TProc8); {$ifdef Linux}[local];{$endif}
    // left-right-top-bottom clippped:
    procedure RegNTProc1_4 (         Proc8:TProc8); {$ifdef Linux}[local];{$endif}

    {Empty}
    procedure RegNTValue009; {$ifdef Linux}[local];{$endif}

    {Monochrome}
    // (constant) auxiliary procedure:
    procedure RegNTValueA00; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegNTValue000; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTValue002; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTValue004; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue006; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Additive}
    // (constant) not clipped:
    procedure RegNTValue010; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTValue012; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTValue014; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue016; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedure:
    procedure RegNTValueA11; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure RegNTValue011; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegNTValue013; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegNTValue015; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue017; {$ifdef Linux}[local];{$endif}

    {Alphablend}
    // (constant) auxiliary procedure:
    procedure RegNTValueA20; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegNTValue020; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTValue022; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTValue024; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue026; {$ifdef Linux}[local];{$endif}
    // (fading)
    //same;

    {Inverse}
    // (constant) auxiliary procedure:
    procedure RegNTValueA30; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegNTValue030; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTValue032; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTValue034; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue036; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedure:
    procedure RegNTValueA31; {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegNTValue031; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegNTValue033; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegNTValue035; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue037; {$ifdef Linux}[local];{$endif}

    {Highlight}
    // (constant) not clipped:
    procedure RegNTValue040; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTValue042; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTValue044; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue046; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Darken}
    // (constant) not clipped:
    procedure RegNTValue050; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTValue052; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTValue054; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue056; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleR}
    // (constant) not clipped:
    procedure RegNTValue060; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTValue062; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTValue064; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue066; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedure:
    procedure RegNTValueA61; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure RegNTValue061; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegNTValue063; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegNTValue065; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue067; {$ifdef Linux}[local];{$endif}

    {GrayscaleG}
    // (constant) not clipped:
    procedure RegNTValue070; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTValue072; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTValue074; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue076; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedure:
    procedure RegNTValueA71; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure RegNTValue071; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegNTValue073; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegNTValue075; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue077; {$ifdef Linux}[local];{$endif}

    {GrayscaleB}
    // (constant) not clipped:
    procedure RegNTValue080; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTValue082; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTValue084; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue086; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedure:
    procedure RegNTValueA81; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure RegNTValue081; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegNTValue083; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegNTValue085; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue087; {$ifdef Linux}[local];{$endif}

    {Monochrome Noise}
    // (constant) auxiliary procedure:
    procedure RegNTValueA90; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegNTValue090; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTValue092; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTValue094; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue096; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedure:
    procedure RegNTValueA91; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure RegNTValue091; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegNTValue093; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegNTValue095; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue097; {$ifdef Linux}[local];{$endif}

    {ColorizeR}
    // (constant) auxiliary procedure:
    procedure RegNTValue10A; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegNTValue100; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTValue102; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTValue104; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue106; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeG}
    // (constant) auxiliary procedure:
    procedure RegNTValue11A; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegNTValue110; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTValue112; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTValue114; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue116; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeB}
    // (constant) auxiliary procedure:
    procedure RegNTValue12A; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegNTValue120; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTValue122; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTValue124; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue126; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGB}
    // (constant) not clipped:
    procedure RegNTValue130; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTValue132; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTValue134; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue136; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedure:
    procedure RegNTValueC31; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure RegNTValue131; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegNTValue133; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegNTValue135; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue137; {$ifdef Linux}[local];{$endif}

    {BlurRRB}
    // (constant) not clipped:
    procedure RegNTValue140; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTValue142; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTValue144; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue146; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedure:
    procedure RegNTValueC41; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure RegNTValue141; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegNTValue143; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegNTValue145; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue147; {$ifdef Linux}[local];{$endif}

    {BlurRGR}
    // (constant) not clipped:
    procedure RegNTValue150; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTValue152; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTValue154; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue156; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedure:
    procedure RegNTValueC51; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure RegNTValue151; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegNTValue153; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegNTValue155; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue157; {$ifdef Linux}[local];{$endif}

    {BlurGGB}
    // (constant) not clipped:
    procedure RegNTValue160; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTValue162; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTValue164; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue166; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedure:
    procedure RegNTValueC61; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure RegNTValue161; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegNTValue163; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegNTValue165; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue167; {$ifdef Linux}[local];{$endif}

    {BlurRGG}
    // (constant) not clipped:
    procedure RegNTValue170; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTValue172; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTValue174; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue176; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedure:
    procedure RegNTValueC71; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure RegNTValue171; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegNTValue173; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegNTValue175; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue177; {$ifdef Linux}[local];{$endif}

    {BlurBGB}
    // (constant) not clipped:
    procedure RegNTValue180; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTValue182; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTValue184; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue186; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedure:
    procedure RegNTValueC81; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure RegNTValue181; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegNTValue183; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegNTValue185; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue187; {$ifdef Linux}[local];{$endif}

    {BlurRBB}
    // (constant) not clipped:
    procedure RegNTValue190; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTValue192; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTValue194; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue196; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedure:
    procedure RegNTValueC91; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure RegNTValue191; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegNTValue193; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegNTValue195; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue197; {$ifdef Linux}[local];{$endif}

    {BlurRRR}
    // (constant) not clipped:
    procedure RegNTValue200; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTValue202; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTValue204; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue206; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedure:
    procedure RegNTValueD01; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure RegNTValue201; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegNTValue203; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegNTValue205; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue207; {$ifdef Linux}[local];{$endif}

    {BlurGGG}
    // (constant) not clipped:
    procedure RegNTValue210; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTValue212; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTValue214; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue216; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedure:
    procedure RegNTValueD11; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure RegNTValue211; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegNTValue213; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegNTValue215; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue217; {$ifdef Linux}[local];{$endif}

    {BlurBBB}
    // (constant) not clipped:
    procedure RegNTValue220; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTValue222; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTValue224; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue226; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedure:
    procedure RegNTValueD21; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure RegNTValue221; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegNTValue223; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegNTValue225; {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue227; {$ifdef Linux}[local];{$endif}

    {Contrast}
    // (constant) auxiliary procedure:
    procedure RegNTValue23A; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegNTValue230; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegNTValue232; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegNTValue234; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue236; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {Noise} {$region -fold}



    {$endregion}

    // PT - partly transparent pixels;

    {Value} {$region -fold}

    // auxiliary procedures:
    procedure RegPTValueA_0; inline; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueA_1; inline; {$ifdef Linux}[local];{$endif}

    // auxiliary procedures:
    // (constant) not clippped and top-bottom clippped:
    procedure RegPTProcC_0(Proc19:TProc19); {$ifdef Linux}[local];{$endif}
    procedure RegPTProcD_0(Proc8 :TProc8 ); {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTProcC_4(Proc19:TProc19); {$ifdef Linux}[local];{$endif}
    procedure RegPTProcD_4(Proc8 :TProc8 ); {$ifdef Linux}[local];{$endif}
    // (fading) not clippped and top-bottom clippped:
    procedure RegPTProcC_1(Proc19:TProc19); {$ifdef Linux}[local];{$endif}
    procedure RegPTProcD_1(Proc19:TProc19); {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegPTProcC_5(Proc19:TProc19); {$ifdef Linux}[local];{$endif}
    procedure RegPTProcD_5(Proc19:TProc19); {$ifdef Linux}[local];{$endif}

    {Empty}
    procedure RegPTValue009; {$ifdef Linux}[local];{$endif}

    {Monochrome}
    // (constant) auxiliary procedures:
    procedure RegPTValueA00; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB00; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue000; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTValue002; {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueA04; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB04; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped :
    procedure RegPTValue004; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Additive}
    // (constant) auxiliary procedures:
    procedure RegPTValueA10; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB10; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue010; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTValue012; {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueA14; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB14; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTValue014; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTValueA11; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB11; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure RegPTValue011; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegPTValue013; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTValueA15; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB15; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegPTValue015; {$ifdef Linux}[local];{$endif}

    {Alphablend}
    // (constant) auxiliary procedures:
    procedure RegPTValueA20; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB20; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue020; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTValue022; {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueA24; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB24; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTValue024; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Inverse}
    // (constant) auxiliary procedures:
    procedure RegPTValueA30; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB30; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue030; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTValue032; {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueA34; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB34; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTValue034; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTValueA31; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB31; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure RegPTValue031; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegPTValue033; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTValueA35; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB35; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegPTValue035; {$ifdef Linux}[local];{$endif}

    {Highlight}
    // (constant) auxiliary procedures:
    procedure RegPTValueA40; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB40; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue040; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTValue042; {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueA44; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB44; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTValue044; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Darken}
    // (constant) auxiliary procedures:
    procedure RegPTValueA50; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB50; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue050; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTValue052; {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueA54; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB54; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTValue054; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleR}
    // (constant) auxiliary procedures:
    procedure RegPTValueA60; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB60; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue060; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTValue062; {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueA64; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB64; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTValue064; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTValueA61; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB61; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure RegPTValue061; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegPTValue063; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTValueA65; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB65; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegPTValue065; {$ifdef Linux}[local];{$endif}

    {GrayscaleG}
    // (constant) auxiliary procedures:
    procedure RegPTValueA70; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB70; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue070; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTValue072; {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueA74; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB74; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTValue074; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTValueA71; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB71; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure RegPTValue071; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegPTValue073; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTValueA75; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB75; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegPTValue075; {$ifdef Linux}[local];{$endif}

    {GrayscaleB}
    // (constant) auxiliary procedures:
    procedure RegPTValueA80; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB80; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue080; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTValue082; {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueA84; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB84; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTValue084; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTValueA81; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB81; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure RegPTValue081; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegPTValue083; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTValueA85; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB85; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegPTValue085; {$ifdef Linux}[local];{$endif}

    {Monochrome Noise}
    // (constant) auxiliary procedures:
    procedure RegPTValueA90; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB90; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue090; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTValue092; {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueA94; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB94; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTValue094; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTValueA91; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB91; {$ifdef Linux}[local];{$endif}
    // (fading) not clippped:
    procedure RegPTValue091; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegPTValue093; {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTValueA95; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB95; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegPTValue095; {$ifdef Linux}[local];{$endif}

    {ColorizeR}
    // (constant) auxiliary procedures:
    procedure RegPTValueC00; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueD00; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue100; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTValue102; {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueC04; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueD04; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTValue104; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeG}
    // (constant) auxiliary procedures:
    procedure RegPTValueC10; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueD10; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue110; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTValue112; {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueC14; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueD14; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTValue114; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeB}
    // (constant) auxiliary procedures:
    procedure RegPTValueC20; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueD20; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue120; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTValue122; {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueC24; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueD24; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTValue124; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGB}
    // (constant) not clipped:
    procedure RegPTValue130; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTValue132; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTValue134; {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue131; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegPTValue133; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegPTValue135; {$ifdef Linux}[local];{$endif}

    {BlurRRB}
    // (constant) not clipped:
    procedure RegPTValue140; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTValue142; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTValue144; {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue141; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegPTValue143; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegPTValue145; {$ifdef Linux}[local];{$endif}

    {BlurRGR}
    // (constant) not clipped:
    procedure RegPTValue150; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTValue152; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTValue154; {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue151; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegPTValue153; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegPTValue155; {$ifdef Linux}[local];{$endif}

    {BlurGGB}
    // (constant) not clipped:
    procedure RegPTValue160; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTValue162; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTValue164; {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue161; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegPTValue163; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegPTValue165; {$ifdef Linux}[local];{$endif}

    {BlurRGG}
    // (constant) not clipped:
    procedure RegPTValue170; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTValue172; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTValue174; {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue171; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegPTValue173; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegPTValue175; {$ifdef Linux}[local];{$endif}

    {BlurBGB}
    // (constant) not clipped:
    procedure RegPTValue180; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTValue182; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTValue184; {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue181; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegPTValue183; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegPTValue185; {$ifdef Linux}[local];{$endif}

    {BlurRBB}
    // (constant) not clipped:
    procedure RegPTValue190; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTValue192; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTValue194; {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue191; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegPTValue193; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegPTValue195; {$ifdef Linux}[local];{$endif}

    {BlurRRR}
    // (constant) not clipped:
    procedure RegPTValue200; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTValue202; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTValue204; {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue201; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegPTValue203; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegPTValue205; {$ifdef Linux}[local];{$endif}

    {BlurGGG}
    // (constant) not clipped:
    procedure RegPTValue210; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTValue212; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTValue214; {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue211; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegPTValue213; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegPTValue215; {$ifdef Linux}[local];{$endif}

    {BlurBBB}
    // (constant) not clipped:
    procedure RegPTValue220; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTValue222; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTValue224; {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue221; {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clippped:
    procedure RegPTValue223; {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clippped:
    procedure RegPTValue225; {$ifdef Linux}[local];{$endif}

    {Contrast}
    // (constant) auxiliary procedures:
    procedure RegPTValueE30; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueF30; {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue230; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure RegPTValue232; {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueE34; {$ifdef Linux}[local];{$endif}
    procedure RegPTValueF34; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure RegPTValue234; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {Noise} {$region -fold}



    {$endregion}

    {$endregion}

    {Gradient FloodFill(Vertical)--------------------------} {$region -fold}

    // NT - not transparent pixels:

    {Value} {$region -fold}

    // auxiliary procedures:
    procedure GrVNTValueA_0; inline; {$ifdef Linux}[local];{$endif}
    procedure GrVNTValueA_1; inline; {$ifdef Linux}[local];{$endif}

    // (constant) auxiliary procedure:
    procedure GrVNTValueA0(Proc16:TProc16); inline; {$ifdef Linux}[local];{$endif}
    procedure GrVNTValueA4(Proc16:TProc16); inline; {$ifdef Linux}[local];{$endif}
    procedure GrVNTValueB0(Proc17:TProc17); inline; {$ifdef Linux}[local];{$endif}
    procedure GrVNTValueB4(Proc17:TProc17); inline; {$ifdef Linux}[local];{$endif}
    procedure GrVNTValueC0(Proc18:TProc18); inline; {$ifdef Linux}[local];{$endif}
    procedure GrVNTValueC4(Proc18:TProc18); inline; {$ifdef Linux}[local];{$endif}
    procedure GrVNTValueD0(Proc19:TProc19); inline; {$ifdef Linux}[local];{$endif}
    procedure GrVNTValueD4(Proc19:TProc19); inline; {$ifdef Linux}[local];{$endif}

    {Empty}
    procedure GrVNTValue009; {$ifdef Linux}[local];{$endif}

    {Monochrome}
    // (constant) auxiliary procedure:
    procedure GrVNTValueA00; inline; {$ifdef Linux}[local];{$endif}
    // (constant) not clippped:
    procedure GrVNTValue000; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVNTValue002; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVNTValue004; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue006; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Additive}
    // (constant) auxiliary procedure:
    procedure GrVNTValueA10; inline; {$ifdef Linux}[local];{$endif}
    // (constant) not clippped:
    procedure GrVNTValue010; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVNTValue012; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVNTValue014; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue016; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {AlphaBlend}
    // (constant) auxiliary procedure:
    procedure GrVNTValueA20; inline; {$ifdef Linux}[local];{$endif}
    // (constant) not clippped:
    procedure GrVNTValue020; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVNTValue022; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVNTValue024; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue026; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Inverse}
    // (constant) auxiliary procedure:
    procedure GrVNTValueA30; inline; {$ifdef Linux}[local];{$endif}
    // (constant) not clippped:
    procedure GrVNTValue030; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVNTValue032; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVNTValue034; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue036; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Highlight}
    // (constant) not clippped:
    procedure GrVNTValue040; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVNTValue042; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVNTValue044; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue046; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Darken}
    // (constant) not clippped:
    procedure GrVNTValue050; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVNTValue052; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVNTValue054; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue056; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleR}
    // (constant) not clippped:
    procedure GrVNTValue060; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVNTValue062; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVNTValue064; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue066; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleG}
    // (constant) not clippped:
    procedure GrVNTValue070; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVNTValue072; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVNTValue074; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue076; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleB}
    // (constant) not clippped:
    procedure GrVNTValue080; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVNTValue082; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVNTValue084; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue086; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Monochrome Noise}
    // (constant) auxiliary procedure:
    procedure GrVNTValueA90; inline; {$ifdef Linux}[local];{$endif}
    // (constant) not clippped:
    procedure GrVNTValue090; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVNTValue092; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVNTValue094; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue096; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeR}
    // (constant) not clippped:
    procedure GrVNTValue100; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVNTValue102; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVNTValue104; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue106; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeG}
    // (constant) not clippped:
    procedure GrVNTValue110; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVNTValue112; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVNTValue114; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue116; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeB}
    // (constant) not clippped:
    procedure GrVNTValue120; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVNTValue122; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVNTValue124; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue126; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGB}
    // (constant) not clippped:
    procedure GrVNTValue130; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVNTValue132; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVNTValue134; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue136; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRRB}
    // (constant) not clippped:
    procedure GrVNTValue140; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVNTValue142; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVNTValue144; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue146; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGR}
    // (constant) not clippped:
    procedure GrVNTValue150; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVNTValue152; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVNTValue154; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue156; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurGGB}
    // (constant) not clippped:
    procedure GrVNTValue160; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVNTValue162; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVNTValue164; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue166; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGG}
    // (constant) not clippped:
    procedure GrVNTValue170; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVNTValue172; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVNTValue174; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue176; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurBGB}
    // (constant) not clippped:
    procedure GrVNTValue180; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVNTValue182; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVNTValue184; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue186; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRBB}
    // (constant) not clippped:
    procedure GrVNTValue190; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVNTValue192; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVNTValue194; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue196; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRRR}
    // (constant) not clippped:
    procedure GrVNTValue200; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVNTValue202; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVNTValue204; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue206; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurGGG}
    // (constant) not clippped:
    procedure GrVNTValue210; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVNTValue212; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVNTValue214; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue216; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurBBB}
    // (constant) not clippped:
    procedure GrVNTValue220; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVNTValue222; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVNTValue224; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue226; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Contrast}
    // (constant) auxiliary procedure:
    procedure GrVNTValue23A; inline; {$ifdef Linux}[local];{$endif}
    // (constant) not clippped:
    procedure GrVNTValue230; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVNTValue232; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVNTValue234; {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue236; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {Noise} {$region -fold}



    {$endregion}

    // PT - partly transparent pixels:

    {Value} {$region -fold}

    // auxiliary procedures:
    procedure GrVPTValueA_0; inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueA_1; inline; {$ifdef Linux}[local];{$endif}

    // (constant) auxiliary procedure:
    procedure GrVPTValueA0(Proc16:TProc16); inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueB0(Proc16:TProc16); inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueA4(Proc16:TProc16); inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueB4(Proc16:TProc16); inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueC0(Proc17:TProc17); inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueD0(Proc17:TProc17); inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueC4(Proc17:TProc17); inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueD4(Proc17:TProc17); inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueE0(Proc18:TProc18); inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueF0(Proc18:TProc18); inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueE4(Proc18:TProc18); inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueF4(Proc18:TProc18); inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueG0(Proc19:TProc19); inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueH0(Proc19:TProc19); inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueG4(Proc19:TProc19); inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueH4(Proc19:TProc19); inline; {$ifdef Linux}[local];{$endif}

    {Empty}
    procedure GrVPTValue009; {$ifdef Linux}[local];{$endif}

    {Monochrome}
    // (constant) auxiliary procedure:
    procedure GrVPTValueA00; inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueB00; inline; {$ifdef Linux}[local];{$endif}
    // (constant) not clippped:
    procedure GrVPTValue000; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVPTValue002; {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedure:
    procedure GrVPTValueA04; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueB04; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVPTValue004; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Additive}
    // (constant) auxiliary procedure:
    procedure GrVPTValueA10; inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueB10; inline; {$ifdef Linux}[local];{$endif}
    // (constant) not clippped:
    procedure GrVPTValue010; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVPTValue012; {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedure:
    procedure GrVPTValueA14; inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueB14; inline; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVPTValue014; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {AlphaBlend}
    // (constant) auxiliary procedure:
    procedure GrVPTValueA20; inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueB20; inline; {$ifdef Linux}[local];{$endif}
    // (constant) not clippped:
    procedure GrVPTValue020; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVPTValue022; {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedure:
    procedure GrVPTValueA24; inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueB24; inline; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVPTValue024; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Inverse}
    // (constant) auxiliary procedure:
    procedure GrVPTValueA30; inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueB30; inline; {$ifdef Linux}[local];{$endif}
    // (constant) not clippped:
    procedure GrVPTValue030; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVPTValue032; {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedure:
    procedure GrVPTValueA34; inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueB34; inline; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVPTValue034; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Highlight}
    // (constant) not clippped:
    procedure GrVPTValue040; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVPTValue042; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVPTValue044; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Darken}
    // (constant) not clippped:
    procedure GrVPTValue050; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVPTValue052; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVPTValue054; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleR}
    // (constant) not clippped:
    procedure GrVPTValue060; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVPTValue062; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVPTValue064; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleG}
    // (constant) not clippped:
    procedure GrVPTValue070; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVPTValue072; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVPTValue074; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleB}
    // (constant) not clippped:
    procedure GrVPTValue080; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVPTValue082; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVPTValue084; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Monochrome Noise}
    // (constant) auxiliary procedure:
    procedure GrVPTValueA90; inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueB90; inline; {$ifdef Linux}[local];{$endif}
    // (constant) not clippped:
    procedure GrVPTValue090; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVPTValue092; {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedure:
    procedure GrVPTValueA94; inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueB94; inline; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVPTValue094; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeR}
    // (constant) not clippped:
    procedure GrVPTValue100; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVPTValue102; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVPTValue104; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeG}
    // (constant) not clippped:
    procedure GrVPTValue110; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVPTValue112; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVPTValue114; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeB}
    // (constant) not clippped:
    procedure GrVPTValue120; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVPTValue122; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVPTValue124; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGB}
    // (constant) not clippped:
    procedure GrVPTValue130; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVPTValue132; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVPTValue134; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRRB}
    // (constant) not clippped:
    procedure GrVPTValue140; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVPTValue142; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVPTValue144; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGR}
    // (constant) not clippped:
    procedure GrVPTValue150; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVPTValue152; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVPTValue154; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurGGB}
    // (constant) not clippped:
    procedure GrVPTValue160; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVPTValue162; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVPTValue164; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGG}
    // (constant) not clippped:
    procedure GrVPTValue170; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVPTValue172; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVPTValue174; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurBGB}
    // (constant) not clippped:
    procedure GrVPTValue180; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVPTValue182; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVPTValue184; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRBB}
    // (constant) not clippped:
    procedure GrVPTValue190; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVPTValue192; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVPTValue194; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRRR}
    // (constant) not clippped:
    procedure GrVPTValue200; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVPTValue202; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVPTValue204; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurGGG}
    // (constant) not clippped:
    procedure GrVPTValue210; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVPTValue212; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVPTValue214; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurBBB}
    // (constant) not clippped:
    procedure GrVPTValue220; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVPTValue222; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVPTValue224; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Contrast}
    // (constant) auxiliary procedure:
    procedure GrVPTValueI30; inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueJ30; inline; {$ifdef Linux}[local];{$endif}
    // (constant) not clippped:
    procedure GrVPTValue230; {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clippped:
    procedure GrVPTValue232; {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedure:
    procedure GrVPTValueI34; inline; {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueJ34; inline; {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clippped:
    procedure GrVPTValue234; {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {Noise} {$region -fold}



    {$endregion}

    {$endregion}

    {Scale Image-------------------------------------------} {$region -fold}

    // NT - not transparent pixels:

    // scale down:
    // color:
    procedure FilNTColorScaleDownMip0; {$ifdef Linux}[local];{$endif}
    procedure FilNTColorScaleDownMip1; {$ifdef Linux}[local];{$endif}
    procedure FilNTColorScaleDownMip2; {$ifdef Linux}[local];{$endif}
    procedure FilNTColorScaleDownMip3; {$ifdef Linux}[local];{$endif}
    procedure FilNTColorScaleDownMAll; {$ifdef Linux}[local];{$endif}
    procedure BlrNTColorScaleDown;     {$ifdef Linux}[local];{$endif}
    // value:
    procedure FilNTValueScaleDown;     {$ifdef Linux}[local];{$endif}
    // scale up:
    // color:
    procedure FilNTColorScaleUp  ;     {$ifdef Linux}[local];{$endif}
    // value:
    procedure FilNTValueScaleUp  ;     {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    // scale down:
    // color:
    procedure FilPTColorScaleDownMip0; {$ifdef Linux}[local];{$endif}
    procedure FilPTColorScaleDownMip1; {$ifdef Linux}[local];{$endif}
    procedure FilPTColorScaleDownMAll; {$ifdef Linux}[local];{$endif}
    procedure BlrPTColorScaleDown;     {$ifdef Linux}[local];{$endif}
    // value:
    procedure FilPTValueScaleDown;     {$ifdef Linux}[local];{$endif}
    // scale up:
    // color:
    procedure FilPTColorScaleUp  ;     {$ifdef Linux}[local];{$endif}
    // value:
    procedure FilPTValueScaleUp  ;     {$ifdef Linux}[local];{$endif}

    {$endregion}

    {Fill Array at Specified Rectangle with Specified Value} {$region -fold}
    procedure FilNTValueArrA(var      arr_src         :TColorArr;
                             constref bmp_ftimg_width_:TColor;
                             constref val             :TColor=0); {$ifdef Linux}[local];{$endif}
    procedure FilNTValueArrB(var      arr_src         :T1Byte1Arr;
                             constref bmp_ftimg_width_:TColor;
                             constref val             :byte=0);   {$ifdef Linux}[local];{$endif}
    procedure FilPTValueArrA(var      arr_src         :TColorArr;
                             constref bmp_ftimg_width_:TColor;
                             constref val             :TColor=0); {$ifdef Linux}[local];{$endif}
    procedure FilPTValueArrB(var      arr_src         :T1Byte1Arr;
                             constref bmp_ftimg_width_:TColor;
                             constref val             :byte=0);   {$ifdef Linux}[local];{$endif}
    {$endregion}

    {Restore Source Image from Compressed Image------------} {$region -fold}
    procedure ResNTValueArr(var      arr_src         :TColorArr;
                            constref bmp_ftimg_width_:TColor); {$ifdef Linux}[local];{$endif}
    {$endregion}

    {Misc. Init Proc.--------------------------------------} {$region -fold}

    // Check NTValueArr:
    function  ChkNTValueArr: boolean; inline; {$ifdef Linux}[local];{$endif}

    // NT - not transparent pixels:
    procedure SetNTNilToPtr;                  {$ifdef Linux}[local];{$endif}
    procedure SetNTCCLToPtr;                  {$ifdef Linux}[local];{$endif}
    procedure SetNTCLLToPtr;                  {$ifdef Linux}[local];{$endif}

    // PT - partly transparent pixels:
    procedure SetPTNilToPtr;                  {$ifdef Linux}[local];{$endif}
    procedure SetPTCCLToPtr;                  {$ifdef Linux}[local];{$endif}
    procedure SetPTCLLToPtr;                  {$ifdef Linux}[local];{$endif}

    // Procedures Table Init.:
    procedure FilProcInit;                    {$ifdef Linux}[local];{$endif}

    // Table of Counts Vertically Init.(Image Clipping):
    procedure CrtNTCntIndArr;                 {$ifdef Linux}[local];{$endif}
    procedure CrtPTCntIndArr;                 {$ifdef Linux}[local];{$endif}

    {$endregion}

    {Tile Map Drawing--------------------------------------} {$region -fold}

    // Fill Tile Map With Random Color:
    procedure FilTileMap0; {$ifdef Linux}[local];{$endif}
    // Fill Tile Map With Specified Sprite:
    procedure FilTileMap1; {$ifdef Linux}[local];{$endif}
    // Fill Tile Map With Rectangles(Empty):
    procedure FilTileMap2; {$ifdef Linux}[local];{$endif}
    // Fill Tile Map With Rectangles(FloodFill):
    procedure FilTileMap3; {$ifdef Linux}[local];{$endif}

    {$endregion}

    {Full CSR-Image Drawing--------------------------------} {$region -fold}

    procedure SdrAnimCng(b:boolean); inline; {$ifdef Linux}[local];{$endif}
    procedure SdrTypeCng ; inline; {$ifdef Linux}[local];{$endif}
    procedure ShaderInfo ; inline; {$ifdef Linux}[local];{$endif}
    procedure SetSdrType ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrTypeInit; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType000 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType001 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType002 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType003 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType004 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType005 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType006 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType007 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType008 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType009 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType010 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType011 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType012 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType013 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType014 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType015 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType016 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType017 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType018 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType019 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType020 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType021 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType022 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType023 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType024 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType025 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType026 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType027 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType028 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType029 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType030 ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrType031 ; inline; {$ifdef Linux}[local];{$endif}
    procedure ShaderType ; inline; {$ifdef Linux}[local];{$endif}
    procedure SdrProcInit; inline; {$ifdef Linux}[local];{$endif}
    procedure UberShader0; inline; {$ifdef Linux}[local];{$endif}
    procedure UberShader1; inline; {$ifdef Linux}[local];{$endif}
    procedure UberShader2; inline; {$ifdef Linux}[local];{$endif}
    procedure UberShader3; inline; {$ifdef Linux}[local];{$endif}

    // Clear Background from Image:
    procedure ClrBkgnd;    inline; {$ifdef Linux}[local];{$endif}

    {$endregion}

    {CSR-Image Anti-Aliasing-------------------------------} {$region -fold}
    procedure CrtBorderBmp(constref arr_src      :TColorArr;
                           var arr_dst           :TObjSelArr;
                           constref arr_src_width,
                                    arr_dst_width:TColor;
                           constref rect_left,
                                    rect_top,
                                    rect_width,
                                    rect_height  :TColor;
                           var brdr_pix_cnt      :TColor;
                           constref obj_kind,
                                    obj_id       :TColor);  {$ifdef Linux}[local];{$endif}
    procedure BorderCalc1 (constref arr_src      :TColorArr;
                           var      arr_dst      :T1Byte1Arr;
                           constref arr_src_width,
                                    arr_dst_width:TColor;
                           constref rct_dst_     :TPtRect); {$ifdef Linux}[local];{$endif}
    procedure BorderCalc2 (constref arr_src      :TColorArr;
                           var      arr_dst      :T1Byte1Arr;
                           var      arr_alpha    :TAALnArr;
                           constref arr_src_width,
                                    arr_dst_width:TColor;
                           constref rct_dst_     :TPtRect;
                           out      line_cnt     :TColor);  {$ifdef Linux}[local];{$endif}
    {$endregion}

    {$endregion}

    {CSR-Image Clipping------------------------------------} {$region -fold}
    procedure UlsProcInit;                                         {$ifdef Linux}[local];{$endif}
    procedure NTUseless0(var      arr_dst      :TColorArr;
                         constref arr_dst_width:TColor;
                         constref val          :TColor);          {$ifdef Linux}[local];{$endif}
    procedure NTUseless1(var      arr_dst      :TColorArr;
                         constref arr_dst_width:TColor;
                         constref val          :TColor);          {$ifdef Linux}[local];{$endif}
    procedure NTUseless2(var      arr_dst      :TColorArr;
                         constref arr_dst_width:TColor;
                         constref val          :TColor);          {$ifdef Linux}[local];{$endif}
    procedure PTUseless0(var      arr_dst      :TColorArr;
                         constref arr_dst_width:TColor;
                         constref val          :TColor);          {$ifdef Linux}[local];{$endif}
    procedure PTUseless1(var      arr_dst      :TColorArr;
                         constref arr_dst_width:TColor;
                         constref val          :TColor);          {$ifdef Linux}[local];{$endif}
    procedure PTUseless2(var      arr_dst      :TColorArr;
                         constref arr_dst_width:TColor;
                         constref val          :TColor);          {$ifdef Linux}[local];{$endif}
    function  Useless: byte;                              inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctPos (         rct          :TPtRect); inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctPos (         x,y,w,h      :integer); inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctPos (         x,y          :integer); inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctPos (         pvt          :TPtPosF); inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctDst;                                  inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctSrc;                                  inline; {$ifdef Linux}[local];{$endif} {$endregion}

    {Init. Part--------------------------------------------} {$region -fold}
    constructor Create;                                                                         {$ifdef Linux}[local];{$endif}
    destructor  Destroy;           override;                                                    {$ifdef Linux}[local];{$endif}
    // Set the basic properties of the drawing target surface(bkgnd):
    procedure SetBkgnd            (constref bkgnd_ptr               :PInteger;
                                   constref bkgnd_width,
                                            bkgnd_height            :TColor;
                                   constref rct_clp                 :TPtRect);          inline; {$ifdef Linux}[local];{$endif}
    procedure SetClpRct           (constref rct_clp                 :TPtRect);          inline; {$ifdef Linux}[local];{$endif}
    procedure SetValInfo          (constref bmp_color_ptr_,
                                            bmp_alpha_ptr_,
                                            bmp_value_ptr_          :PInteger;
                                   constref ftimg_width,
                                            ftimg_height            :TColor);           inline; {$ifdef Linux}[local];{$endif}
    procedure SetPPInfo           (const    val                     :TColor=$00434D3E); inline; {$ifdef Linux}[local];{$endif}
    procedure FXInit;                                                                   inline; {$ifdef Linux}[local];{$endif}
    // Set the start and end             of the gradient on the axis y:
    procedure SetGradVec          (         x,y                     :integer);          inline; {$ifdef Linux}[local];{$endif}
    // Set     start and end color value of the gradient:
    procedure SetGradCol          (         x,y                     :TColor);           inline; {$ifdef Linux}[local];{$endif}
    procedure SrcDestroy          (         bmp_src                 :TPicture  );       inline; {$ifdef Linux}[local];{$endif}
    procedure SrcDestroy          (         bmp_src                 :TBitmap   );       inline; {$ifdef Linux}[local];{$endif}
    procedure SrcDestroy          (         arr_src                 :TColorArr );       inline; {$ifdef Linux}[local];{$endif}
    procedure SrcDestroy          (         arr_src                 :TWordArr  );       inline; {$ifdef Linux}[local];{$endif}
    procedure SrcDestroy          (         arr_src                 :T1Byte1Arr);       inline; {$ifdef Linux}[local];{$endif} {$endregion}

    {$endregion}

  end; {$endregion}
  PFastImageProc     =^TFastImageProc;
  {****************************************************************************}



  {Fast Line ******************************************************************}
  // Allows to draw lines but can be usefull for drawing other primitives:
  TFastLine          =class {$region -fold}

    {State Machine for Line Drawing Routines--------} {$region -fold}
    protected
      var
        LineProc: array[0..39] of TProc0; {$endregion}

    {Edges and Points Pixels Buffers----------------} {$region -fold}
    public
      var
        {spline sprite}
        //fast_image         : TFastImageItem;

        {static edges buffer : for "vertical"   lines}
        ln_arr2              : T2ByteArr;

        {static edges buffer : for "regular"    lines}
        ln_arr1              : TColorArr;

        {static edges buffer : for "horizontal" lines}
        ln_arr0              : T1Byte1Arr;

        {destination bitmap(background)}
        bmp_dst_ptr          : PInteger;
        bmp_dst_width        : TColor;
        bmp_dst_height       : TColor;

        {source array}
        ln_arr1_ptr          : PInteger;
        ln_arr0_ptr          : PByte;
        ln_arr_width         : TColor;
        ln_arr_height        : TColor;

        {line kind pointer}
        ln_kind_ptr          : PInteger; {$endregion}

    {Misc. Variables: Line Drawing------------------} {$region -fold}
    protected
      var
        k_ ,b_ ,dx_,dy_                     : double ;
        r0 ,p0 ,r1 ,p1 ,g  ,t_k_,t_b_,j0 ,j1: integer;
        dx ,dy ,a  ,b  ,c  ,m1  ,m2         : integer;
       {k_inv,n_                            : double;
        t0,t1,m_                            : integer;} {$endregion}

    {Hidden-Line Elimination------------------------} {$region -fold}
    public
     {is line visible array:
      0 - line is invisible;
      1 - line is   visible}
      useless_arr: T1Byte1Arr;
     {hidden  lines count}
      hid_ln_cnt : TColor;
     {visible lines count}
      vis_ln_cnt : TColor;
     {existing lines count}
      has_ln_cnt : TColor; {$endregion}

    {Misc. Variables: Clipping----------------------} {$region -fold}
    public
      {drawing window rectangle pointer}
      rct_clp_ptr: PPtRect;
      ln_pos     : TLnPos;
      color_info : TColorInfo;
      pix_cnt    : TColor;
      mov_dir    : TMovingDirection; {$endregion}

    {Resilient Line---------------------------------} {$region -fold}
    res_ln_pts_cnt: TColorArr; {$endregion}

    {Precalculated Table of Greatest Common Divisors} {$region -fold}
    {public
      {class} var
        {array of greatest common divisors}
        gcd_arr    : TGCDArr;
        {precision of calculation}
        grid_pt_rad: TColor;} {$endregion}

    {Spline Local Properties------------------------} {$region -fold}
    public
      var
        local_prop: TCurveProp; {$endregion}

    {Bounding Rectangles of Spline Object-----------} {$region -fold}
    public
      var
        {spline entire rectangle}
        rct_ent  : TPtRectF;
        {spline entire rectangle with offset}
        rct_ent_2: TPtRect;
        {spline visible(clipped by inner window) rectangle}
        rct_vis  : TPtRect;
        {spline window(inner window) rectangle}
        rct_wnd  : TRect; {$endregion}

    {Post-Processing--------------------------------} {$region -fold}
    args             : TFunc0Args;
    pp_dec_2_proc_ind: byte; {$endregion}

    {Edge Anti-Aliasing-----------------------------} {$region -fold}
    public
      var
        {alpha border of anti-aliased spline}
        aa_arr2            : TAALnArr;
        {alpha border of anti-aliased spline}
        aa_arr1            : T1Byte1Arr;
        {antialiased lines count}
        aa_line_cnt        : TColor;
        aa_nz_arr_items_cnt: TColor; {$endregion}

    {Misc. Routines---------------------------------} {$region -fold}
    public
      constructor Create;                                                       {$ifdef Linux}[local];{$endif}
      destructor  Destroy; override;                                            {$ifdef Linux}[local];{$endif}
      procedure GCCArrInit;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure GCCArrRepl        (         dst_fl_var     :TFastLine); inline; {$ifdef Linux}[local];{$endif}
      procedure BuffersInit       (         w,h            :TColor;
                                            ln_arr0_init   :boolean;
                                            ln_arr1_init   :boolean;
                                            ln_arr2_init   :boolean;
                                            aa_buff_init   :boolean);   inline; {$ifdef Linux}[local];{$endif}
      procedure SetBkgnd          (constref bmp_dst_ptr_   :PInteger;
                                   constref bmp_dst_width_,
                                            bmp_dst_height_:TColor;
                                   constref rct_clp_ptr_   :PPtRect);   inline; {$ifdef Linux}[local];{$endif}
      procedure MinimizeArrs      (         aa_buff_clear  :boolean);   inline; {$ifdef Linux}[local];{$endif}
      {Fast Line Grid Precalculation}
    {class} procedure LinePrecalc (         w,h            :TColor);            {$ifdef Linux}[local];{$endif}
      {Solid Line Initialization}
      procedure LineSInit;                                              inline; {$ifdef Linux}[local];{$endif}
      //
      procedure SwapArgs          (         x0,y0,x1,y1    : double);   inline; {$ifdef Linux}[local];{$endif}
      //
      procedure GetLCoef0         (         x0,y0,x1,y1    : double);   inline; {$ifdef Linux}[local];{$endif}
      procedure GetLCoef1;                                              inline; {$ifdef Linux}[local];{$endif}
      procedure GetLCoef2;                                              inline; {$ifdef Linux}[local];{$endif}
      // (Move Points) Перемещение точек:
      procedure LinePHL00         (         x0,y0,x1,y1    : double);   inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL01;                                              inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL02;                                              inline; {$ifdef Linux}[local];{$endif}
      // (Select Points) Выделение точек:
      procedure LinePHL10         (         x0,y0,x1,y1    : double);   inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL11;                                              inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL12;                                              inline; {$ifdef Linux}[local];{$endif}
      // (Unselect Points) Снятие выделения точе
      procedure LinePHL20         (         x0,y0,x1,y1    : double);   inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL21;                                              inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL22;                                              inline; {$ifdef Linux}[local];{$endif}
      // (Direct Pixel Write) Непосредственная запись в битовую карту:
      procedure LinePHL30         (         x0,y0,x1,y1    : double);   inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL31;                                              inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL32;                                              inline; {$ifdef Linux}[local];{$endif}
      // (Advanced Byte Mode) Продвинутый байт-режим:
      procedure LinePHL40         (         x0,y0,x1,y1    : double);   inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL41;                                              inline; {$ifdef Linux}[local];{$endif}
      procedure LinePHL42;                                              inline; {$ifdef Linux}[local];{$endif}

    protected
      {Right Bottom Corner}
      {0°..-45°}
      procedure LineS00;                                                inline; {$ifdef Linux}[local];{$endif}
      procedure LineS01RBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS02RBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS03RBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS04RBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS05RBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS06RBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS07RBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS08RBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS09RBC;                                             inline; {$ifdef Linux}[local];{$endif}
      {-45°..-90°}
      procedure LineS10;                                                inline; {$ifdef Linux}[local];{$endif}
      procedure LineS11RBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS12RBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS13RBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS14RBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS15RBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS16RBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS17RBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS18RBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS19RBC;                                             inline; {$ifdef Linux}[local];{$endif}
      {Left Bottom Corner}
      {-135°..-180°}
      procedure LineS20;                                                inline; {$ifdef Linux}[local];{$endif}
      procedure LineS21LBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS22LBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS23LBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS24LBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS25LBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS26LBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS27LBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS28LBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS29LBC;                                             inline; {$ifdef Linux}[local];{$endif}
      {-90°..-135°}
      procedure LineS30;                                                inline; {$ifdef Linux}[local];{$endif}
      procedure LineS31LBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS32LBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS33LBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS34LBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS35LBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS36LBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS37LBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS38LBC;                                             inline; {$ifdef Linux}[local];{$endif}
      procedure LineS39LBC;                                             inline; {$ifdef Linux}[local];{$endif}

    public
      {Solid Line Drawing}
      {Fast Line Solid Mode Normal}
      procedure LineSMN           (constref x0,y0,x1,y1    :integer);   inline; {$ifdef Linux}[local];{$endif}
      {Fast Line Solid Mode Extended}
      procedure LineSME           (constref x0,y0,x1,y1    :integer;
                                   constref proc_ptr_a,
                                            proc_ptr_b,
                                            proc_ptr_c     :TProc0);    inline; {$ifdef Linux}[local];{$endif}

      {Solid Horizontal Line Drawing}
      procedure LineSHL00;                                              inline; {$ifdef Linux}[local];{$endif}
      procedure LineSHL10;                                              inline; {$ifdef Linux}[local];{$endif}
      procedure LineSHL20;                                              inline; {$ifdef Linux}[local];{$endif}
      procedure LineSHL30;                                              inline; {$ifdef Linux}[local];{$endif}
      procedure LineSHL40;                                              inline; {$ifdef Linux}[local];{$endif}
      {Solid Vertical Line Drawing}
      procedure LineSVL00;                                              inline; {$ifdef Linux}[local];{$endif}
      procedure LineSVL10;                                              inline; {$ifdef Linux}[local];{$endif}
      procedure LineSVL20;                                              inline; {$ifdef Linux}[local];{$endif}
      procedure LineSVL30;                                              inline; {$ifdef Linux}[local];{$endif}
      procedure LineSVL40;                                              inline; {$ifdef Linux}[local];{$endif}
      {Fast Line Clipping}
      procedure ClippedLine1      (         x0,y0,x1,y1    :integer;
                                   const    rct_clp        :TPtRect;
                                   constref proc1          :TProc3;
                                   constref proc2,
                                            proc3,
                                            proc4          :TProc0);            {$ifdef Linux}[local];{$endif}
      procedure ClippedLine2      (         x0,y0,x1,y1    :integer;
                                   const    rct_clp        :TPtRect;
                                   constref proc1          :TProc3;
                                   constref proc2,
                                            proc3,
                                            proc4          :TProc0);            {$ifdef Linux}[local];{$endif}
      procedure ClippedLine2      (         x0,y0,x1,y1    :double;
                                   const    rct_clp        :TPtRect;
                                   constref proc2,
                                            proc3,
                                            proc4,
                                            proc5          :TProc0);            {$ifdef Linux}[local];{$endif}
      procedure ClippedLine2      (         x0,y0,x1,y1    :integer;
                                   const    rct_clp        :TPtRect);           {$ifdef Linux}[local];{$endif}
      procedure FilBuffer         (constref rct_clp        :TPtRect);           {$ifdef Linux}[local];{$endif} {$endregion}

  end; {$endregion}
  PFastLine          =^TFastLine;
  {****************************************************************************}



  {Fast Text ******************************************************************}
  // Parametric text stored in CSR format:
  TFastText          =class {$region -fold}
    public
      var
        {text sprite}
        fst_img   : TFastImageItem;
        {Text Local Properties}
        local_prop: TFTextProp;
      constructor Create;            {$ifdef Linux}[local];{$endif}
      destructor  Destroy; override; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PFastText          =^TFastText;
  {****************************************************************************}



{Color Transform}
function Red                    (         pixel              :TColor): byte;           inline; {$ifdef Linux}[local];{$endif}
function Green                  (         pixel              :TColor): byte;           inline; {$ifdef Linux}[local];{$endif}
function Blue                   (         pixel              :TColor): byte;           inline; {$ifdef Linux}[local];{$endif}
function Alpha                  (         pixel              :TColor): byte;           inline; {$ifdef Linux}[local];{$endif}
function RGB                    (         r,g,b              :byte  ): TColor;         inline; {$ifdef Linux}[local];{$endif}
function RGBA                   (         r,g,b,a            :byte  ): TColor;         inline; {$ifdef Linux}[local];{$endif}
function SetColorInv            (         pixel              :TColor;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=MAXBYTE;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): TColor;     inline; {$ifdef Linux}[local];{$endif}
function Color                  (         pixel              :TColor    ): TColor;     inline; {$ifdef Linux}[local];{$endif}
function Color0                 (         pixel              :TColor;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=MAXBYTE;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): TColor;     inline; {$ifdef Linux}[local];{$endif}
function Additive0              (         pixel              :TColor;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=MAXBYTE;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): TColor;     inline; {$ifdef Linux}[local];{$endif}
function AdditiveA              (         dst_pix,
                                          src_pix            :TColor    ): TColor;     inline; {$ifdef Linux}[local];{$endif}
function AdditiveB              (         dst_pix,
                                          src_pix            :TColor    ): TColor;     inline; {$ifdef Linux}[local];{$endif}
function AlphaBlend0            (         pixel              :TColor;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=MAXBYTE;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): TColor;     inline; {$ifdef Linux}[local];{$endif}
procedure AlphaBlend1           (         pixel_ptr          :PInteger;
                                 constref r,g,b              :byte;
                                 constref d_alpha            :byte);                   inline; {$ifdef Linux}[local];{$endif}
function AlphaBlendA            (         dst_pix,
                                          src_pix            :TColor;
                                 constref alpha              :byte=0    ): TColor;     inline; {$ifdef Linux}[local];{$endif}
function AlphaBlendB            (         dst_pix,
                                          src_pix            :TColor;
                                 constref alpha              :byte=0    ): TColor;     inline; {$ifdef Linux}[local];{$endif}
function Inverse0               (         pixel              :TColor;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=MAXBYTE;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): TColor;     inline; {$ifdef Linux}[local];{$endif}
function InverseA               (         pixel              :TColor    ): TColor;     inline; {$ifdef Linux}[local];{$endif}
function Highlight0             (         pixel              :TColor;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=MAXBYTE;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): TColor;     inline; {$ifdef Linux}[local];{$endif}
function HighlightA             (         pixel              :TColor;
                                 constref pow                :byte=64   ): TColor;     inline; {$ifdef Linux}[local];{$endif}
function Darken0                (         pixel              :TColor;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=MAXBYTE;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): TColor;     inline; {$ifdef Linux}[local];{$endif}
function DarkenA                (         pixel              :TColor;
                                 constref pow                :byte=64   ): TColor;     inline; {$ifdef Linux}[local];{$endif}
function GrayscaleR0            (         pixel              :TColor;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=MAXBYTE;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): TColor;     inline; {$ifdef Linux}[local];{$endif}
function GrayscaleG0            (         pixel              :TColor;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=MAXBYTE;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): TColor;     inline; {$ifdef Linux}[local];{$endif}
function GrayscaleB0            (         pixel              :TColor;
                                 constref r                  :byte=0;
                                 constref g                  :byte=0;
                                 constref b                  :byte=0;
                                 constref alpha              :byte=0;
                                 constref d_alpha            :byte=MAXBYTE;
                                 constref pow                :byte=64;
                                 constref d                  :smallint=0): TColor;     inline; {$ifdef Linux}[local];{$endif}
function ColorizeR              (         pixel              :TColor;
                                 constref pow                :byte): TColor;           inline; {$ifdef Linux}[local];{$endif}
function ColorizeG              (         pixel              :TColor;
                                 constref pow                :byte): TColor;           inline; {$ifdef Linux}[local];{$endif}
function ColorizeB              (         pixel              :TColor;
                                 constref pow                :byte): TColor;           inline; {$ifdef Linux}[local];{$endif}
function  BlurRGB4              (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor): TColor;         inline; {$ifdef Linux}[local];{$endif}
function  BlurRGB5              (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor): TColor;         inline; {$ifdef Linux}[local];{$endif}
function  BlurRGB9              (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor): TColor;         inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGB               (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRB               (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGR               (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGB               (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGG               (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure BlurBGB               (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure BlurRBB               (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRR               (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGG               (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure BlurBBB               (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
function  ContrastPrecalc       (constref contrast_pow       :double): TColor;         inline; {$ifdef Linux}[local];{$endif}
procedure Contrast              (         pixel_ptr          :PInteger;
                                          r,g,b              :byte;
                                          pow                :double);                 inline; {$ifdef Linux}[local];{$endif}
procedure Contrast2             (         pixel_ptr          :PInteger;
                                          r,g,b              :byte;
                                          pow                :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure AdditiveDec           (var      pixel              :TColor;
                                 constref r,g,b              :byte;
                                 constref alpha_fade         :byte);                   inline; {$ifdef Linux}[local];{$endif}
function AdditiveDec2           (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
function AdditiveDecA           (         dst_pix,src_pix    :TColor;
                                 constref alpha_fade         :byte): TColor;           inline; {$ifdef Linux}[local];{$endif}
function AdditiveDecB           (         dst_pix,src_pix    :TColor;
                                 constref alpha_fade         :byte): TColor;           inline; {$ifdef Linux}[local];{$endif}
function AdditiveDecC           (         dst_pix,src_pix    :TColor): TColor;         inline; {$ifdef Linux}[local];{$endif}
procedure AlphaBlendDec         (         pixel_ptr          :PInteger;
                                 constref r,g,b              :byte;
                                          alpha              :byte;
                                 constref alpha_fade         :byte);                   inline; {$ifdef Linux}[local];{$endif}
function AlphaBlendDec2         (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
function AlphaBlendDecA         (         dst_pix,src_pix    :TColor;
                                          alpha              :byte;
                                 constref alpha_fade         :byte): TColor;           inline; {$ifdef Linux}[local];{$endif}
function AlphaBlendDecB         (         dst_pix,src_pix    :TColor;
                                          alpha              :byte;
                                 constref alpha_fade         :byte): TColor;           inline; {$ifdef Linux}[local];{$endif}
function AlphaBlendDecC         (         dst_pix,src_pix    :TColor;
                                 constref alpha_fade         :byte): TColor;           inline; {$ifdef Linux}[local];{$endif}
procedure InverseDec            (var      pixel              :TColor;
                                 constref alpha_fade         :byte);                   inline; {$ifdef Linux}[local];{$endif}
function InverseDec2            (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
procedure HighlightDec          (var      pixel              :TColor;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte=64);                inline; {$ifdef Linux}[local];{$endif}
function HighlightDec2          (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
procedure DarkenDec             (var      pixel              :TColor;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte=64);                inline; {$ifdef Linux}[local];{$endif}
function DarkenDec2             (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
procedure GrayscaleRDec         (var      pixel              :TColor;
                                 constref alpha_fade         :byte);                   inline; {$ifdef Linux}[local];{$endif}
function GrayscaleRDec2         (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
procedure GrayscaleGDec         (var      pixel              :TColor;
                                 constref alpha_fade         :byte);                   inline; {$ifdef Linux}[local];{$endif}
function GrayscaleGDec2         (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
procedure GrayscaleBDec         (var      pixel              :TColor;
                                 constref alpha_fade         :byte);                   inline; {$ifdef Linux}[local];{$endif}
function GrayscaleBDec2         (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
procedure ColorizeRDec          (var      pixel              :TColor;
                                 constref alpha_fade         :byte;
                                 constref d                  :smallint);               inline; {$ifdef Linux}[local];{$endif}
function ColorizeRDec2          (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
procedure ColorizeGDec          (var      pixel              :TColor;
                                 constref alpha_fade         :byte;
                                 constref d                  :smallint);               inline; {$ifdef Linux}[local];{$endif}
function ColorizeGDec2          (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
procedure ColorizeBDec          (var      pixel              :TColor;
                                 constref alpha_fade         :byte;
                                 constref d                  :smallint);               inline; {$ifdef Linux}[local];{$endif}
function ColorizeBDec2          (         pixel              :TColor;
                                 constref r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :byte;
                                 constref d                  :smallint): TColor;       inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGBDec            (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor;
                                 constref alpha_fade         :byte);                   inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRBDec            (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor;
                                 constref alpha_fade         :byte);                   inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGRDec            (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor;
                                 constref alpha_fade         :byte);                   inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGBDec            (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor;
                                 constref alpha_fade         :byte);                   inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGGDec            (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor;
                                 constref alpha_fade         :byte);                   inline; {$ifdef Linux}[local];{$endif}
procedure BlurBGBDec            (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor;
                                 constref alpha_fade         :byte);                   inline; {$ifdef Linux}[local];{$endif}
procedure BlurRBBDec            (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor;
                                 constref alpha_fade         :byte);                   inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRRDec            (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor;
                                 constref alpha_fade         :byte);                   inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGGDec            (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor;
                                 constref alpha_fade         :byte);                   inline; {$ifdef Linux}[local];{$endif}
procedure BlurBBBDec            (         pixel_ptr          :PInteger;
                                          bmp_dst_width      :TColor;
                                 constref alpha_fade         :byte);                   inline; {$ifdef Linux}[local];{$endif}
function ContrastDec            (         pixel_ptr          :PInteger;
                                 constref r,g,b              :byte;
                                 constref alpha_fade         :byte;
                                 constref pow                :integer): TColor;        inline; {$ifdef Linux}[local];{$endif}
function ContrastDecA           (         dst_pix,src_pix    :TColor;
                                 constref alpha_fade         :byte;
                                 constref pow                :integer): TColor;        inline; {$ifdef Linux}[local];{$endif}
function ContrastDecB           (         dst_pix,src_pix    :TColor;
                                 constref alpha_fade         :byte;
                                 constref pow                :integer): TColor;        inline; {$ifdef Linux}[local];{$endif}

{Misc. Routines}
// (Swapping two values) Поменять местами два значения:
procedure Swap1                 (var      x,y                :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure Swap2                 (var      x,y                :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure Swap3                 (var      x,y                :double);                 inline; {$ifdef Linux}[local];{$endif}
//
function GetEnumVal             (         enum               :TDrawingStyle): TColor;  inline; {$ifdef Linux}[local];{$endif}
function GetEnumVal             (         enum               :TDrawingStyle): integer; inline; {$ifdef Linux}[local];{$endif}
// (Minimum of values):
function Min1                   (constref a1,a2              :double ): double ;       inline; {$ifdef Linux}[local];{$endif}
function Min2                   (constref a1,a2              :integer): integer;       inline; {$ifdef Linux}[local];{$endif}
function Min3                   (constref a1,a2              :TColor ): TColor;        inline; {$ifdef Linux}[local];{$endif}
function Min4                   (constref arr                :TIntrArr;
                                 constref max_item_val       :integer;
                                 constref item_cnt           :integer): integer;       inline; {$ifdef Linux}[local];{$endif}
function Min5                   (constref arr                :TColorArr;
                                 constref max_item_val       :TColor;
                                 constref item_cnt           :TColor): TColor;         inline; {$ifdef Linux}[local];{$endif}
function Min6                   (constref arr                :TIntrArr;
                                 constref max_item_val       :integer;
                                 constref item_cnt           :integer;
                                 constref b                  :boolean): integer;       inline; {$ifdef Linux}[local];{$endif}
function Min7                   (constref arr                :TColorArr;
                                 constref max_item_val       :TColor;
                                 constref item_cnt           :TColor;
                                 constref b                  :boolean): TColor;        inline; {$ifdef Linux}[local];{$endif}
function Min8                   (constref arr                :TEdgeArr;
                                 constref max_item_val       :integer;
                                 constref item_cnt           :integer): integer;       inline; {$ifdef Linux}[local];{$endif}
function Min9                   (constref arr                :TEdgeArr;
                                 constref max_item_val       :TColor;
                                 constref item_cnt           :TColor): TColor;         inline; {$ifdef Linux}[local];{$endif}
// (Maximum of values):
function Max1                   (constref a1,a2              :double ): double ;       inline; {$ifdef Linux}[local];{$endif}
function Max2                   (constref a1,a2              :integer): integer;       inline; {$ifdef Linux}[local];{$endif}
function Max3                   (constref a1,a2              :TColor ): TColor;        inline; {$ifdef Linux}[local];{$endif}
function Max4                   (constref arr                :TIntrArr;
                                 constref min_item_val       :integer;
                                 constref item_cnt           :integer): integer;       inline; {$ifdef Linux}[local];{$endif}
function Max5                   (constref arr                :TColorArr;
                                 constref min_item_val       :TColor;
                                 constref item_cnt           :TColor): TColor;         inline; {$ifdef Linux}[local];{$endif}
function Max6                   (constref arr                :TIntrArr;
                                 constref min_item_val       :integer;
                                 constref item_cnt           :integer;
                                 constref b                  :boolean): integer;       inline; {$ifdef Linux}[local];{$endif}
function Max7                   (constref arr                :TColorArr;
                                 constref min_item_val       :TColor;
                                 constref item_cnt           :TColor;
                                 constref b                  :boolean): TColor;        inline; {$ifdef Linux}[local];{$endif}
function Max8                   (constref arr                :TEdgeArr;
                                 constref min_item_val       :integer;
                                 constref item_cnt           :integer): integer;       inline; {$ifdef Linux}[local];{$endif}
function Max9                   (constref arr                :TEdgeArr;
                                 constref min_item_val       :TColor;
                                 constref item_cnt           :TColor): TColor;         inline; {$ifdef Linux}[local];{$endif}
// (MinSubMax:important condition!: c>d):
function MinSubMax              (const    a,b,c,d            :integer): integer;       inline; {$ifdef Linux}[local];{$endif}
//
function InvSqrt                (constref x                  :single): single;         inline; {$ifdef Linux}[local];{$endif}
//
function Limit                  (         x                  :integer): byte;          inline; {$ifdef Linux}[local];{$endif}
//
procedure PtrInit               (var      ptr                :PInteger;
                                 constref arr                :TIntrArr);               inline; {$ifdef Linux}[local];{$endif}
procedure PtrInit               (var      ptr                :PInteger;
                                 constref arr                :TColorArr);              inline; {$ifdef Linux}[local];{$endif}
//
procedure MaxSpriteWHRctInit    (var      rct                :TPtRect);                inline; {$ifdef Linux}[local];{$endif}
//
function ArcTan4                (constref x0,y0,x1,y1        :double): double;         inline; {$ifdef Linux}[local];{$endif}
//
function IndexOfSubStr          (const    list               :TStrings;
                                 var      sub_string         :string): integer;        inline; {$ifdef Linux}[local];{$endif}
// (Binary Search) Бинарный поиск:
function BinarySearch           (constref n                  :TColor;
                                 constref arr_item_ptr       :PInteger;
                                 constref right_border       :integer): integer;       inline; {$ifdef Linux}[local];{$endif}
// (Store Color Channel into Integer Array) Сохранить цветовой канал в целочисленный массив:
procedure BmpToArr              (constref bmp_src_ptr        :PInteger;
                                 var      bmp_dst_ptr        :PInteger;
                                 var      arr_dst            :TColorArr;
                                 constref bmp_src_rct        :TPtRect;
                                 constref bmp_src_width,
                                          bmp_src_height     :TColor;
                                 var      bmp_dst_width,
                                          bmp_dst_height     :TColor);                 inline; {$ifdef Linux}[local];{$endif}
// (Checks if both values x and y have not equal signs) Проверяет, имеют ли оба значения x и y не одинаковые знаки:
// returns True if x and y are not equal 0 and have not equal signs, otherwise returns False.
function NotEqualSign           (         x,y                :double): boolean;        inline; {$ifdef Linux}[local];{$endif}
// (Calculation of the global axis shift error during the movement of the block motion of the layer) Вычисление ошибки смещения глобальной оси при блочном движении слоя:
procedure ShiftErrorCalc0       (         x0,x1              :double;
                                 var      err                :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure ShiftErrorCalc1       (         x0,x1              :double;
                                 var      err                :integer);                inline; {$ifdef Linux}[local];{$endif}



(******************************* Bitmap Loading *******************************)

function CrtTPicInstFromHDDSrc  (constref location           :string): TPicture;       inline; {$ifdef Linux}[local];{$endif}
function CrtTBmpInstFromImgLst  (constref ImgLstGetBmp       :TProc1;
                                 constref img_ind            :TColor=0): TBitmap;      inline; {$ifdef Linux}[local];{$endif}
function CrtTBmpInst            (constref bmp_src            :TBitmap;
                                 var      bmp_dst_ptr        :PInteger): TBitmap;      inline; {$ifdef Linux}[local];{$endif}
function CrtTBmpInst            (constref bmp_dst_width,
                                          bmp_dst_height     :TColor;
                                 var      bmp_src_ptr        :PInteger): TBitmap;      inline; {$ifdef Linux}[local];{$endif}

{Arrays Addition}
procedure ArrAdd                (constref arr_src1,
                                          arr_src2           :T1Byte1Arr;
                                 var      arr_dst            :TColorArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (constref arr_src1,
                                          arr_src2           :TDublArr;
                                 var      arr_dst            :TDublArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (constref arr_src1,
                                          arr_src2           :TColorArr;
                                 var      arr_dst            :TColorArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (constref arr_src1,
                                          arr_src2           :TWordArr;
                                 var      arr_dst            :TWordArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (constref arr_src1,
                                          arr_src2           :T1Byte1Arr;
                                 var      arr_dst            :T1Byte1Arr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (constref arr_src1           :TColorArr;
                                 constref arr_src2           :T1Byte1Arr;
                                 constref width,
                                          height             :TColor;
                                 constref val                :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (constref arr_src1           :T1Byte1Arr;
                                 constref arr_src2           :T2ByteArr;
                                 constref arr_dst            :TColorArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (constref arr_src1           :T1Byte1Arr;
                                 constref arr_src2           :T2ByteArr;
                                 constref arr_dst            :T1Byte1Arr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (var      arr_src1           :T1Byte1Arr;
                                 constref arr_src2           :T2ByteArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrAdd                (var      arr_src1           :T1Byte1Arr;
                                 constref arr_src2           :T2ByteArr;
                                 constref rct_dst            :TPtrect;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}

{Arrays Subtraction}
procedure ArrSub                (constref arr_src1,
                                          arr_src2           :TDublArr;
                                 var      arr_dst            :TDublArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrSub                (constref arr_src1,
                                          arr_src2           :TIntrArr;
                                 var      arr_dst            :TIntrArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrSub                (constref arr_src1,
                                          arr_src2           :TColorArr;
                                 var      arr_dst            :TColorArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrSub                (constref arr_src1,
                                          arr_src2           :TWordArr;
                                 var      arr_dst            :TWordArr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrSub                (constref arr_src1,
                                          arr_src2           :T1Byte1Arr;
                                 var      arr_dst            :T1Byte1Arr;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor);                         {$ifdef Linux}[local];{$endif}
procedure ArrSub                (constref arr_src            :T1Byte1Arr;
                                 constref arr_dst            :TIntrArr;
                                 constref width,height       :TColor;
                                 constref val                :TColor);                         {$ifdef Linux}[local];{$endif}

{2D Array to 1D Array}
procedure Arr2DTo1D             (constref arr_src            :T2ByteArr;
                                 var      arr_dst            :T1Byte1Arr;
                                 constref arr_src_width,
                                          arr_src_height     :TColor);                         {$ifdef Linux}[local];{$endif}

{Clear Arrays}
procedure BmpClr                (         bmp                :Graphics.TBitmap);       inline; {$ifdef Linux}[local];{$endif}
procedure ArrClr                (         arr1_ptr           :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref arr_width          :TColor;
                                 constref val                :TColor=0);               inline; {$ifdef Linux}[local];{$endif}
procedure ArrClr                (var      arr0               :T1Byte1Arr;
                                 constref rct_dst            :TPtRect;
                                 constref arr_width          :TColor;
                                 constref val                :byte=0);                 inline; {$ifdef Linux}[local];{$endif}
procedure ArrClr                (var      arr1               :TColorArr;
                                 constref rct_dst            :TPtRect;
                                 constref arr_width          :TColor;
                                 constref val                :TColor=0);               inline; {$ifdef Linux}[local];{$endif}
procedure ArrClr                (var      arr1_ptr           :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref arr_width          :TColor;
                                          f1,f2,f3,f4        :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure ArrClr                (var      arr2               :T2ByteArr;
                                 constref rct_dst            :TPtRect;
                                 constref val                :byte=0);                 inline; {$ifdef Linux}[local];{$endif}
procedure ArrClr                (var      arr3               :TPtPos3Arr;
                                 constref rct_dst            :TPtRect;
                                 constref arr_width          :TColor);                 inline; {$ifdef Linux}[local];{$endif}

// Clear Alpha Channel:
function ArrClr                 (         arr1_ptr           :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref arr_width          :TColor;
                                 constref val                :TColor=0;
                                          b                  :boolean=False):byte;     inline; {$ifdef Linux}[local];{$endif}

{Fill Arrays On Bitmap}
procedure ArrFilProc00          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc01          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc02          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc03          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc04          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc05          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc06          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc07          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc08          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc09          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc10          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc11          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc12          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc13          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc14          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc15          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc16          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc17          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc18          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc19          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc20          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc21          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc22          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc23          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc24          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
procedure ArrFilProc25          (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor;
                                 constref alpha              :byte=120);
//
procedure ArrFil                (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtrect;
                                          b                  : boolean);

procedure ArrFil                (constref arr0               :TColorArr ;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtrect;
                                 constref col                :TColor);
procedure ArrFil                (constref arr0               :TPtPos3Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtrect;
                                 constref col                :TColor);
procedure ArrFil                (constref arr0               :TPtPos3Arr;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtrect);
procedure ArrFil                (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtrect);
//
procedure ArrFilTest            (constref arr0               :T1Byte1Arr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                          bmp_height         :TColor;
                                 constref rct_dst            :TPtrect;
                                 constref col                :TColor);
procedure ArrFilTest            (constref arr0               :TIntrArr;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width,
                                 bmp_height                  :TColor;
                                 constref rct_dst            :TPtrect;
                                 constref col                :TColor);

// Sum Of Array Elements:
function ArrNzItSum             (constref arr                :T1Byte1Arr): TColor;             {$ifdef Linux}[local];{$endif}
function ArrNzItSum             (constref arr                :TWordArr  ): TColor;             {$ifdef Linux}[local];{$endif}
function ArrNzItSum             (constref arr                :TColorArr ): TColor;             {$ifdef Linux}[local];{$endif}

// Non-Zero Items Count:
function ArrNzItCnt             (constref arr                :T1Byte1Arr): TColor;             {$ifdef Linux}[local];{$endif}
function ArrNzItCnt             (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref col                :TColor): TColor;                 {$ifdef Linux}[local];{$endif}
function ArrNzItCnt             (constref arr1_ptr           :PShortInt;
                                 constref arr2_ptr           :PByte;
                                 constref length             :integer): TColor;                {$ifdef Linux}[local];{$endif}
function ArrNzItCnt             (constref arr1_ptr           :PShortInt;
                                 constref length             :integer;
                                          b                  :boolean): TColor;                {$ifdef Linux}[local];{$endif}
function ArrNzItCnt             (constref arr                :T1Byte1Arr;
                                 constref max_arr_it_val     :TColor=MAXBYTE ): TColor;        {$ifdef Linux}[local];{$endif}
function ArrNzItCnt             (constref arr                :TWordArr;
                                 constref max_arr_it_val     :TColor=MAXWORD ): TColor;        {$ifdef Linux}[local];{$endif}
function ArrNzItCnt             (constref arr                :TColorArr;
                                 constref max_arr_it_val     :TColor=MAXDWORD): TColor;        {$ifdef Linux}[local];{$endif}

// Create Array With "Visible" Items:
procedure ArrNzItCrt            (constref arr1_src_ptr       :PShortInt;
                                 constref arr2_src_ptr       :PByte;
                                          arr_dst_ptr        :PColor;
                                 constref length1,
                                          length2            :integer);                        {$ifdef Linux}[local];{$endif}
procedure ArrNzItCrt            (constref arr1_src_ptr       :PShortInt;
                                          arr_dst_ptr        :PColor;
                                 constref length1,
                                          length2            :integer);                        {$ifdef Linux}[local];{$endif}

// Copy One Array To Another:
procedure ArrToArr1             (         arr_src_ptr        :PPtPosF;
                                          arr_dst_ptr        :PPtPosF;
                                          pts_cnt            :integer);                        {$ifdef Linux}[local];{$endif}
procedure ArrToArr2             (         arr_src_ptr        :PPtPosF;
                                          arr_dst_ptr        :PPtPosF;
                                          pts_cnt            :integer);                        {$ifdef Linux}[local];{$endif}

// Search For The First Element Not Equal To The Given Value(val) Starting From data_start, length is the number of items to check:
function NotIndexByte           (         data_start         :PByte;
                                          length             :integer): integer;               {$ifdef Linux}[local];{$endif}
function NotIndexWord           (         data_start         :PWord;
                                          length             :integer): integer;               {$ifdef Linux}[local];{$endif}
function NotIndexDWord          (         data_start         :PDWord;
                                          length             :integer): integer;               {$ifdef Linux}[local];{$endif}
function NotIndexQWord          (         data_start         :PQWord;
                                          length             :integer): integer;               {$ifdef Linux}[local];{$endif}

procedure FillRectangleOnArray0 (constref arr_ptr            :PInteger;
                                 var      rct_inn,rct_out    :TPtRectF;
                                          grid_density       :TPtPos;
                                          val                :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure FillRectangleOnArray1 (constref arr_ptr            :PInteger;
                                 var      rct_inn,rct_out    :TPtRectF;
                                          grid_density       :TPtPos;
                                          val                :integer);                inline; {$ifdef Linux}[local];{$endif}

{Linked Lists}
procedure AddListItem           (constref pt_x               :integer;
                                 var      first_item,p1,p2   :PIList);
procedure AddListItem           (constref pt                 :TPtPosF;
                                 var      first_item,p1,p2   :PFList);
procedure ArrToList1            (constref arr_src            :TIntrArr;
                                 var      first_item,p1,p2   :PIList);
procedure ArrToList2            (constref arr_src            :TIntrArr;
                                 var      first_item,p1,p2   :PIList);
procedure ListToArr             (var      arr_dst            :TIntrArr;
                                 var      first_item,p1,p2   :PIList);
procedure ListToArr             (var      arr_dst            :TPtPosFArr;
                                 var      first_item,p1,p2   :PFList);
procedure FreeList1             (var      first_item,p1,p2   :PIList);
procedure FreeList2             (var      first_item,p1,p2   :PFList);


{Edge Antialiasing}
procedure BorderCalc00          (constref arr_src            :T1Byte1Arr;
                                 var      arr_dst            :T1Byte1Arr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 var      aa_nz_arr_it_cnt   :TColor);                         {$ifdef Linux}[local];{$endif}
procedure BorderCalc0           (constref arr_src_ptr        :PInteger;
                                 var      arr_dst            :T1Byte1Arr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 var      aa_nz_arr_it_cnt   :TColor;
                                 constref background_color   :TColor);                         {$ifdef Linux}[local];{$endif}
procedure BorderCalc1           (constref arr_src_ptr        :PInteger;
                                 var      arr_dst            :T1Byte1Arr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 var      aa_nz_arr_it_cnt   :TColor);                         {$ifdef Linux}[local];{$endif}
procedure BorderCalc1           (constref arr_src            :TColorArr;
                                 var      arr_dst            :T1Byte1Arr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 var      aa_nz_arr_it_cnt   :TColor);                         {$ifdef Linux}[local];{$endif}
procedure BorderCalc1           (constref arr_src            :T1Byte1Arr;
                                 var      arr_dst            :T1Byte1Arr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 var      aa_nz_arr_it_cnt   :TColor);                         {$ifdef Linux}[local];{$endif}

// Mixed: Image Has Circle And Other Contours:
procedure BorderCalc20          (constref arr_src_ptr        :PInteger;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                         {$ifdef Linux}[local];{$endif}
procedure BorderCalc20          (constref arr_src            :TColorArr;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                         {$ifdef Linux}[local];{$endif}
procedure BorderCalc20          (constref arr_src            :T1Byte1Arr;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                         {$ifdef Linux}[local];{$endif}

// Image Has Only Circle Contours:
procedure BorderCalc21          (constref arr_src_ptr        :PInteger;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                         {$ifdef Linux}[local];{$endif}
procedure BorderCalc21          (constref arr_src            :TColorArr;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                         {$ifdef Linux}[local];{$endif}
procedure BorderCalc21          (constref arr_src            :T1Byte1Arr;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                         {$ifdef Linux}[local];{$endif}

// Image Has No Circle Contours:
procedure BorderCalc22          (constref arr_src_ptr        :PInteger;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                         {$ifdef Linux}[local];{$endif}
procedure BorderCalc22          (constref arr_src            :TColorArr;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                         {$ifdef Linux}[local];{$endif}
procedure BorderCalc22          (constref arr_src            :T1Byte1Arr;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                         {$ifdef Linux}[local];{$endif}

procedure BorderFill            (constref arr_src            :TAALnArr;
                                 constref rct_dst_left,
                                          rct_dst_top        :integer;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width          :TColor;
                                 constref line_cnt           :TColor;
                                 constref col                :TColor;
                                          args               :TFunc0Args;
                                          Func2              :TFunc2);
procedure BorderFill            (constref arr_src            :TAALnArr;
                                 constref rct_dst_left,
                                          rct_dst_top        :integer;
                                 constref bmp_ptr            :PInteger;
                                 constref bmp_width          :TColor;
                                 constref line_cnt           :TColor;
                                 constref col                :TColor;
                                          args               :TFunc0Args);
procedure BorderFill            (constref arr_src            :TAALnArr;
                                 constref rct_dst_left,
                                          rct_dst_top        :integer;
                                 constref bmp_ptr            :PByte;
                                 constref bmp_width          :TColor;
                                 constref line_cnt           :TColor;
                                 constref col                :TColor;
                                          args               :TFunc0Args);

// One-Pixel Border-Blur Calculation:
procedure BorderPixCh           (         arr_src_ptr        :PInteger;
                                 constref arr_src_width      :TColor;
                                 constref background_color   :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure BorderPixCh           (         arr_src_ptr        :PInteger;
                                 constref arr_src_width      :TColor;
                                 constref alpha_color        :byte);                   inline; {$ifdef Linux}[local];{$endif}
procedure BorderPixCh           (         arr_src_ptr        :PInteger;
                                 constref arr_src_width      :TColor;
                                 constref alpha_color        :byte;
                                 constref alpha_mask         :TColor);                 inline; {$ifdef Linux}[local];{$endif}

// Border Blur:
procedure BorderBlur            (constref arr_src_ptr        :PInteger;
                                 var      arr_dst            :T1Byte1Arr;
                                 constref arr_src_width,
                                          arr_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref background_color   :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure BorderBlur            (constref arr_src_ptr        :PInteger;
                                 constref arr_src_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref alpha_color        :byte);                   inline; {$ifdef Linux}[local];{$endif}
procedure BorderBlur            (constref arr_src_ptr        :PInteger;
                                 constref arr_src_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref alpha_color        :byte;
                                 constref mask               :TColor);                 inline; {$ifdef Linux}[local];{$endif}

procedure EdgeAATest            (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref val1,val2          :byte);                   inline; {$ifdef Linux}[local];{$endif}



(****************************** Points Transform ******************************)

// (Align Points to horizontal line, from left to right): Выровнять точки по горизонтали, слева направо:
procedure PtsRawH               (var      pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref pts_dist           :TColor);                 inline; {$ifdef Linux}[local];{$endif}

// (Align Points to vertical line, from top to bottom): Выровнять точки по вертикали, сверху вниз:
procedure PtsRawV               (var      pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref pts_dist           :TColor);                 inline; {$ifdef Linux}[local];{$endif}

// (Reset Points Position): Восстановить позицию точек:
procedure PtsRes                (constref fst_pt_ptr1,
                                          fst_pt_ptr2        :PPtPosF;
                                 constref pts_cnt            :TColor;
                                 constref pt_pos_curr,
                                          pt_pos_prev        :TPtPosF);                inline; {$ifdef Linux}[local];{$endif}

// (Points Pivot) Ось точек:
procedure PtsPvt                (var      pvt                :TPtPosF;
                                 var      pts                :TPtPosFArr;
                                 constref pts_cnt            :TColor);                 inline; {$ifdef Linux}[local];{$endif}

// (Points Moving) Перемещение точек:
procedure PtsMov                (constref pvt                :TPtPos;
                                 var      pts                :TPtPosFArr;
                                 constref fst_ind,
                                          lst_ind            :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure PtsMov                (constref pvt                :TPtPos;
                                 var      rct                :TPtRect);                inline; {$ifdef Linux}[local];{$endif}
procedure PtsMov                (constref pvt                :TPtPos;
                                 var      rct                :TRect);                  inline; {$ifdef Linux}[local];{$endif}
procedure PtsMov                (constref pvt                :TPtPos;
                                 var      rct                :TPtRectF);               inline; {$ifdef Linux}[local];{$endif}

procedure WndSht                (constref outer_rect         :TPtRect;
                                 constref inner_rect         :TPtPosFArr;
                                 var      shift_power        :integer;
                                 constref mul                :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure MDCalc                (var      rct                :TPtRectF;
                                 constref mov_dir            :TMovingDirection;
                                 constref parallax_shift     :TPtPosF);                inline; {$ifdef Linux}[local];{$endif}

// (Points Scaling) Масштабирование точек:
procedure PtsScl                (constref pvt                :TPtPosF;
                                 var      pts                :TPtPosFArr;
                                          scl_mul            :TPtPosF;
                                 constref scl_dir            :TSclDir;
                                          fst_ind            :TColor=0;
                                          lst_ind            :TColor=0);               inline; {$ifdef Linux}[local];{$endif}
procedure PtsScl                (constref pvt                :TPtPosF;
                                 var      rct                :TPtRectF;
                                          scl_mul            :TPtPosF;
                                 constref scl_dir            :TSclDir);                inline; {$ifdef Linux}[local];{$endif}
procedure PtsScl                (constref pvt                :TPtPosF;
                                 var      rct                :TRect;
                                          scl_mul            :TPtPosF;
                                 constref scl_dir            :TSclDir);                inline; {$ifdef Linux}[local];{$endif}
function  GetDir1               (         prev_pos,
                                          curr_pos,
                                          pvt                :TPtPosF): TSclDir;       inline; {$ifdef Linux}[local];{$endif}
function  GetDir2               (         prev_pos,
                                          curr_pos,
                                          pvt                :TPtPosF): TSclDir;       inline; {$ifdef Linux}[local];{$endif}
procedure SetMul                (         prev_pos,
                                          curr_pos,
                                          pvt                :TPtPosF;
                                 var      scl_mul            :TPtPosF;
                                 constref scl_dir            :TSclDir);                inline; {$ifdef Linux}[local];{$endif}

// (Points Rotation) Вращение точек:
procedure GetRot                (constref pvt                :TPtPos;
                                 constref angle              :double;
                                 var      c,s,v,w            :double);                 inline; {$ifdef Linux}[local];{$endif}
procedure GetRot                (constref pvt                :TPtPos;
                                 constref angle              :double;
                                 var      c,s,v,w            :integer;
                                 constref x,y                :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure GetRot                (constref pvt                :TPtPosF;
                                 constref angle              :double;
                                 var      c,s,v,w            :double);                 inline; {$ifdef Linux}[local];{$endif}
procedure GetRotRound           (constref pvt                :TPtPos;
                                 constref angle              :double;
                                 var      c,s,v,w            :double;
                                 constref x,y                :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure GetRotNotRound        (constref pvt                :TPtPos;
                                 constref angle              :double;
                                 var      c,s,v,w            :double;
                                 constref x,y                :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure GetRotNotRound2       (constref pvt                :TPtPos;
                                 constref angle              :double;
                                 var      c,s,v,w            :integer;
                                 constref x,y                :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure PtsRot                (var      pts                :TPtPosFArr;
                                 constref pts_cnt            :TColor;
                                 constref angle              :double;
                                 var      c,s,v,w            :double;
                                 constref fst_ind            :TColor=0);               inline; {$ifdef Linux}[local];{$endif}
function  PtsRot                (         rct                :TPtRectF;
                                 constref angle              :double;
                                 var      c,s,v,w            :double;
                                 constref margin             :TColor=1): TPtRectF;     inline; {$ifdef Linux}[local];{$endif}
function  PtsRot                (         rct                :TRect;
                                 constref angle              :double;
                                 var      c,s,v,w            :double;
                                 constref margin             :TColor=1): TRect;        inline; {$ifdef Linux}[local];{$endif}
function  PtsRot                (         rct                :TPtRect;
                                 constref angle              :double;
                                 var      c,s,v,w            :double;
                                 constref margin             :TColor=1): TPtRect;      inline; {$ifdef Linux}[local];{$endif}



(************************** Miscellaneous Primitives **************************)

// Color Info:
procedure SetColorInfo          (constref pix_col_           :TColor;
                                 var      color_info         :TColorInfo;
                                          alpha_max          :byte=MAXBYTE);           inline; {$ifdef Linux}[local];{$endif}
procedure SetColorInfo          (constref pix_col_           :TColor;
                                 var      color_info         :TColorInfo;
                                          b_                 :boolean);                inline; {$ifdef Linux}[local];{$endif}

// Line Segment: Отрезок:
function  LineS                 (constref v0,w0,v1,w1,r0,r1  :double): TLnPosF;        inline; {$ifdef Linux}[local];{$endif}
function  LineS                 (constref v0,w0,v1,w1,r      :double): TPtPosF;        inline; {$ifdef Linux}[local];{$endif}
function  LineS                 (constref v0,w0,v1,w1,r      :double;
                                 constref dir_x,dir_y        :shortint): TPtPosF;      inline; {$ifdef Linux}[local];{$endif}

// Line Direction: Направление линии:
procedure LineD                 (constref v0,w0,v1,w1        :double;
                                 var      dir_x,dir_y        :shortint);               inline; {$ifdef Linux}[local];{$endif}

// Monochrome Line:
procedure Line                  (         x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo);             inline; {$ifdef Linux}[local];{$endif}
procedure Line                  (         x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure Line                  (         x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :byte);                   inline; {$ifdef Linux}[local];{$endif}
// Line Segments Intersection:
function  LineSI                (         x0,y0,x1,y1,
                                          v0,w0,v1,w1        :double ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  LineSI                (         x0,y0,x1,y1,
                                          v0,w0,v1,w1        :integer): boolean;       inline; {$ifdef Linux}[local];{$endif}

// Line Clipping:
function  LineC                 (var      x0,y0,x1,y1        :integer;
                                 constref rct_clp            :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}

// Monochrome Antialiased Line(Width - 1 pixel):
procedure LineA                 (         x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo;
                                          alpha_max          :byte=MAXBYTE);           inline; {$ifdef Linux}[local];{$endif}
procedure LineAC                (var      x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo;
                                 constref rct_clp            :TPtRect);                inline; {$ifdef Linux}[local];{$endif}

// Monochrome Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineABC               (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}

// Gradient(Highlight) Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineABCG              (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 var      color_info         :TColorInfo;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}

// Equidistant Line(Width - 1 pixel):
function  LineE1                (constref v0,w0,v1,w1,rad    :double): TLnPosF;        inline; {$ifdef Linux}[local];{$endif}
function  LineE2                (constref v0,w0,v1,w1,rad    :double): TLnPosF;        inline; {$ifdef Linux}[local];{$endif}

// Equidistant Curve for Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineABCE              (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}

// Equidistant Curve for Not Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineBCE               (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE               (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE               (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :byte;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE               (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}

// Equidistant Curve for Not Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineBCE2              (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE2              (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE2              (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :byte;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE2              (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}

// Equidistant Curve for Not Antialiased Broken Clipped Line(Width - 3 pixel):
procedure LineBCE3              (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE3              (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);          inline; {$ifdef Linux}[local];{$endif}

// Resilient Line(Width - 1 pixel):
procedure LineR                 (constref x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo;
                                 constref seg_cnt            :TColor);                 inline; {$ifdef Linux}[local];{$endif}

// Monochrome Horizontal Line(Width - 1 pixel):
function  LineHC                (var      x0,y0,x1           :integer;
                                 constref rct_clp            :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
procedure LineH                 (         x0,y0,x1           :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo);             inline; {$ifdef Linux}[local];{$endif}
procedure LineH                 (         x0,y0,x1           :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure LineH                 (         x0,y0,x1           :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :byte);                   inline; {$ifdef Linux}[local];{$endif}

// Monochrome Vertical Line(Width - 1 pixel):
function  LineVC                (var      x0,y0,y1           :integer;
                                 constref rct_clp            :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
procedure LineV                 (         x0,y0,y1           :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo);             inline; {$ifdef Linux}[local];{$endif}
procedure LineV                 (         x0,y0,y1           :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure LineV                 (         x0,y0,y1           :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :byte);                   inline; {$ifdef Linux}[local];{$endif}

// Point
procedure Point                 (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo);             inline; {$ifdef Linux}[local];{$endif}
procedure Point                 (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo;
                                 constref clip_rect          :TPtRect);                inline; {$ifdef Linux}[local];{$endif}
procedure Point                 (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo;
                                 constref clip_rect          :TPtRect;
                                 constref alpha_fade         :byte);                   inline; {$ifdef Linux}[local];{$endif}

// Point Collisin Drawing on Array
function PointCollDraw          (constref x,y                :integer;
                                 constref arr_src_width      :TColor;
                                 var      arr_src            :T1Byte1Arr;
                                 constref clip_rect          :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
function PointCollDraw          (constref x,y                :integer;
                                 constref arr_src_width      :TColor;
                                 constref arr_src            :T1Byte1Arr;
                                 constref clip_rect          :TPtRect;
                                 constref b                  :byte   ): boolean;       inline; {$ifdef Linux}[local];{$endif}

// Rectangle
procedure SetRctDupId           (var      sln_prop_var       :TCurveProp);             inline; {$ifdef Linux}[local];{$endif}
procedure SetEdsWidth           (var      sln_prop_var       :TCurveProp);             inline; {$ifdef Linux}[local];{$endif}
procedure SetRctWidth           (var      sln_prop_var       :TCurveProp);             inline; {$ifdef Linux}[local];{$endif}
procedure SetRctHeight          (var      sln_prop_var       :TCurveProp);             inline; {$ifdef Linux}[local];{$endif}
procedure SetRctValues          (var      sln_prop_var       :TCurveProp);             inline; {$ifdef Linux}[local];{$endif}
procedure Rectangle             (constref x,y                :integer;
                                 constref arr_dst_ptr        :PInteger;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref sln_prop_var       :TCurveProp);             inline; {$ifdef Linux}[local];{$endif}
procedure Rectangle             (constref x,y                :integer;
                                 constref arr_dst_ptr        :PInteger;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref sln_prop_var       :TCurveProp;
                                 constref PPFloodFillProc    :TProc4);                 inline; {$ifdef Linux}[local];{$endif}
procedure Rectangle             (constref x,y                :integer;
                                 constref arr_dst_ptr        :PByte;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref sln_prop_var       :TCurveProp;
                                 constref PPFloodFillProc    :TProc4_1);               inline; {$ifdef Linux}[local];{$endif}
procedure Rectangle             (constref arr_dst_ptr        :PInteger;
                                 constref arr_dst_width,
                                          arr_dst_height     :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor);                 inline; {$ifdef Linux}[local];{$endif}

// Rhombus:
procedure Rombus                (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo);             inline; {$ifdef Linux}[local];{$endif}

// Circle Drawing(Midpoint Algorithm):
procedure Circle                (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo);             inline; {$ifdef Linux}[local];{$endif}
procedure Circle                (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure Circle                (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure Circle                (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :byte);                   inline; {$ifdef Linux}[local];{$endif}
procedure Circle                (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure CircleC               (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref rct_clp            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo);             inline; {$ifdef Linux}[local];{$endif}
procedure CircleC               (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref rct_clp            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure CircleC               (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref rct_clp            :TPtRect;
                                 constref bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure CircleC               (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref rct_clp            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :byte);                   inline; {$ifdef Linux}[local];{$endif}
procedure CircleC               (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref rct_clp            :TPtRect;
                                 constref bmp_dst_width      :TColor);                 inline; {$ifdef Linux}[local];{$endif}

// Wave Search:
function CircleW                (constref x0,y0,rad          :integer;
                                 constref arr_dst            :TPtPos3Arr;
                                 constref arr_dst_width      :TColor;
                                 var      pt                 :TPtPosF): boolean;       inline; {$ifdef Linux}[local];{$endif}
function CircleWC               (constref x0,y0,rad          :integer;
                                 constref arr_dst            :TPtPos3Arr;
                                 constref rct_clp            :TPtRect;
                                 constref arr_dst_width      :TColor;
                                 var      pt                 :TPtPosF): boolean;       inline; {$ifdef Linux}[local];{$endif}

// Circle FloodFill:
procedure CircleFloodFill       (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref rct_out            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo;
                                 constref diam               :TColor;
                                 constref pow                :byte);                   inline; {$ifdef Linux}[local];{$endif}

// SpotLight
procedure CircleHighlight       (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref rct_out            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo;
                                 constref diam               :TColor;
                                 constref pow                :byte;
                                          alpha_max          :byte=MAXBYTE);           inline; {$ifdef Linux}[local];{$endif}

// Text
procedure SetTextInfo           (constref dst_canvas         :TCanvas;
                                 constref height_            :integer      =27;
                                 constref font_color         :TColor       =$006C754A;
                                 constref font_name          :string       ='AR CENA';
                                 constref font_charset       :TFontCharSet =ANSI_CHARSET;
                                 constref font_quality       :TFontQuality =fqAntialiased;
                                 constref pen_mode           :TFPPenMode   =pmXor;
                                 constref brush_style        :TFPBrushStyle=bsClear);  inline; {$ifdef Linux}[local];{$endif}
procedure Text                  (constref x,y                :integer;
                                 constref dst_canvas         :TCanvas;
                                 constref text_              :string);                 inline; {$ifdef Linux}[local];{$endif}



(***************************** Some Basic Routines ****************************)

// (Set Point) Установить точку:
function PtPos                  (constref pt                 :TPtPosF): TPtPos;        inline; {$ifdef Linux}[local];{$endif}
function PtPos                  (constref pos_x,pos_y        :integer): TPtPos;        inline; {$ifdef Linux}[local];{$endif}
function PtPos                  (constref pos_x,pos_y        :double ): TPtPos;        inline; {$ifdef Linux}[local];{$endif}
function PtPos2                 (constref pt                 :TPtPosF): TPtPos2;       inline; {$ifdef Linux}[local];{$endif}
function PtPos2                 (constref pos_x,pos_y        :TColor ): TPtPos2;       inline; {$ifdef Linux}[local];{$endif}
function PtPos2                 (constref pos_x,pos_y        :double ): TPtPos2;       inline; {$ifdef Linux}[local];{$endif}
function PtPosF                 (constref pt                 :TPtPos ): TPtPosF;       inline; {$ifdef Linux}[local];{$endif}
function PtPosF                 (constref pos_x,pos_y        :double ): TPtPosF;       inline; {$ifdef Linux}[local];{$endif}
function PtPosF                 (constref pos_x,pos_y        :integer): TPtPosF;       inline; {$ifdef Linux}[local];{$endif}
function PtPosF                 (constref pt                 :TPtPos2): TPtPosF;       inline; {$ifdef Linux}[local];{$endif}

// (Set Line) Установить линию:
function GetLnC                 (constref vec                :TLnPosF): TPtPosF;       inline; {$ifdef Linux}[local];{$endif}
function LnPos                  (constref vec                :TLnPosF): TLnPos;        inline; {$ifdef Linux}[local];{$endif}
function LnPos                  (constref x0,y0,x1,y1        :integer): TLnPos;        inline; {$ifdef Linux}[local];{$endif}
function LnPosF                 (constref vec                :TLnPos ): TLnPosF;       inline; {$ifdef Linux}[local];{$endif}
function LnPosF                 (constref x0,y0,x1,y1        :double ): TLnPosF;       inline; {$ifdef Linux}[local];{$endif}
function LnPosF                 (constref x0,y0,x1,y1        :integer): TLnPosF;       inline; {$ifdef Linux}[local];{$endif}

// (Bounding Rectangle of Points Set) Ограничиваюший прямоугольник множества точек:
function PtsRngRctCalc          (constref pts                :TPtPosFArr;
                                 var      rct_bnd_ind_arr    :TEnum2Arr;
                                 constref start_pts_ind      :TColor=0;
                                 constref end_pts_ind        :TColor=0): TRect;                {$ifdef Linux}[local];{$endif}
function PtsRngRctCalc2         (constref pts                :TPtPosFArr;
                                 var      rct_bnd_ind_arr    :TEnum2Arr;
                                 constref start_pts_ind      :TColor=0;
                                 constref end_pts_ind        :TColor=0): TPtRectF;             {$ifdef Linux}[local];{$endif}
function PtsRngIndsRctCalc      (constref pts                :TPtPosFArr;
                                 constref sel_pts_inds       :TColorArr;
                                 constref pts_cnt            :TColor  ): TRect;                {$ifdef Linux}[local];{$endif}

// (Set Rectangle) Установить прямоугольник:
procedure PtRct                 (constref pts                :TPtPosFArr;
                                 constref rct_bnd_ind_arr    :TEnum2Arr;
                                 var      rct                :TRect);                  inline; {$ifdef Linux}[local];{$endif}
procedure PtRctF                (constref pts                :TPtPosFArr;
                                 constref rct_bnd_ind_arr    :TEnum2Arr;
                                 var      rct                :TPtRectF);               inline; {$ifdef Linux}[local];{$endif}
function PtRctB                 (constref rct_left,
                                          rct_top,
                                          rct_right,
                                          rct_bottom         :integer   ): TPtRectB;   inline; {$ifdef Linux}[local];{$endif}
function PtRct                  (constref rct_left,
                                          rct_top,
                                          rct_right,
                                          rct_bottom         :integer   ): TPtRect;    inline; {$ifdef Linux}[local];{$endif}
function PtRct                  (constref rct                :TRect     ): TPtRect;    inline; {$ifdef Linux}[local];{$endif}
function PtRct                  (constref rct                :TPtRectF  ): TPtRect;    inline; {$ifdef Linux}[local];{$endif}
function PtRct                  (constref rct                :TPtPosFArr): TPtRect;    inline; {$ifdef Linux}[local];{$endif}
function PtBounds               (constref rct_left,
                                          rct_top,
                                          rct_width,
                                          rct_height         :integer   ): TPtRect;    inline; {$ifdef Linux}[local];{$endif}
function PtBounds               (constref rct                :TRect     ): TPtRect;    inline; {$ifdef Linux}[local];{$endif}
function PtBoundsF              (constref rct_left,
                                          rct_top,
                                          rct_width,
                                          rct_height         :integer   ): TPtRectF;   inline; {$ifdef Linux}[local];{$endif}

// (Inner Clipped Rectangle) Внутренний обрезанный прямоугольник:
function ClippedRctB            (constref out_rct,
                                          inn_rct            :TPtRect;
                                 var      b                  :byte)    : TPtRect;      inline; {$ifdef Linux}[local];{$endif}
function ClippedRctB            (constref out_rct,
                                          inn_rct            :TPtRect) : TPtRectB;     inline; {$ifdef Linux}[local];{$endif}
function ClippedRct             (constref out_rct,
                                          mrg_rct,
                                          inn_rct            :TPtRect;
                                 var      pix_clp_type       :byte)    : TPtRect;      inline; {$ifdef Linux}[local];{$endif}
function ClippedRct             (constref out_rct,
                                          inn_rct            :TPtRect) : TPtRect;      inline; {$ifdef Linux}[local];{$endif}
function ClippedRct             (constref out_rct            :TPtRect;
                                 constref inn_rct            :TPtRectF): TPtRect;      inline; {$ifdef Linux}[local];{$endif}
function ClippedRct             (constref out_rct,
                                          inn_rct            :TRect)   : TPtRect;      inline; {$ifdef Linux}[local];{$endif}
function ClippedRct             (constref out_rct            :TPtRect;
                                 constref inn_rct            :TRect)   : TPtRect;      inline; {$ifdef Linux}[local];{$endif}
function ClippedRct             (constref out_rct            :TRect;
                                 constref inn_rct            :TPtRect) : TPtRect;      inline; {$ifdef Linux}[local];{$endif}
function ClippedRct             (constref out_rct            :TRect;
                                 constref inn_rct            :TPtRectF): TPtRect;      inline; {$ifdef Linux}[local];{$endif}
function ClippedRct             (constref out_rct            :TPtRect;
                                 constref inn_rct            :TRect;
                                          b                  :boolean) : TRect;        inline; {$ifdef Linux}[local];{$endif}
function ClippedRct             (constref out_rct,
                                          inn_rct            :TRect;
                                          b                  :boolean) : TRect;        inline; {$ifdef Linux}[local];{$endif}
function ClippedArr             (constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRectB;
                                 constref arr_src_width      :longword): integer;      inline; {$ifdef Linux}[local];{$endif}

// (Find Rectangle with Not Coprime Width and Height(GCD(src_rect.Width,src_rect.Height)<>1) for source rectangle src_rect) Находит прямоугольник с не взаимно простыми сторонами(GCD(src_rect.Width,src_rect.Height)<>1) для исходного прямоугольника src_rect:
function NCSRectCalc            (constref rct_src            :TRect;
                                 constref bucket_width,
                                          bucket_heigth      :integer): TRect;         inline; {$ifdef Linux}[local];{$endif}
function NCSRectCalc            (constref rct_src            :TPtRectF;
                                 constref bucket_width,
                                          bucket_heigth      :integer): TPtRectF;      inline; {$ifdef Linux}[local];{$endif}

// (Two Rectangles Bounding Rectangle 1) Ограничивающий прямоугольник для двух заданных прямоугольников:
function TwoRctsBoundingRct     (constref rct1,
                                          rct2               :TRect)  : TRect;         inline; {$ifdef Linux}[local];{$endif}
function TwoRctsBoundingRct     (constref rct1,
                                          rct2               :TPtRect): TPtRect;       inline; {$ifdef Linux}[local];{$endif}

// (Rectangle in Rectangle) Прямоугольник в прямоугольнике:
function IsRct1InRct2           (constref rct1,
                                          rct2               :TRect)  : boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsRct1InRct2           (constref rct1,
                                          rct2               :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsRct1InRct2           (constref rct1               :TRect;
                                 constref rct2               :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}

// (Rectangle out of Rectangle) Прямоугольник вне прямоугольника:
function IsRct1OutOfRct2        (constref rct1,
                                          rct2               :TRect)  : boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsRct1OutOfRct2        (constref rct1,
                                          rct2               :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsRct1OutOfRct2        (constref rct1               :TRect;
                                 constref rct2               :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsRct1OutOfRct2        (constref rct1               :TPtRectF;
                                 constref rct2               :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}

// (Line Bounding Rectangle) Ограничивающий линию прямоугольник:
function LineBndRct             (constref x0,y0,x1,y1,
                                          ln_width           :integer): TPtRect;       inline; {$ifdef Linux}[local];{$endif}

// (Point in Rectangle) Точка в прямоугольнике:
function IsPtInRct              (constref x,y,
                                          rct_dst_left,
                                          rct_dst_top,
                                          rct_dst_right,
                                          rct_dst_bottom     :integer): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInRct              (constref x,y                :integer;
                                 constref rct_dst            :TRect)  : boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInRct              (constref x,y                :integer;
                                 constref rct_dst            :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInRct              (constref x,y                :double;
                                 constref rct_dst            :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInRct              (constref pt                 :TPtPos;
                                 constref rct_dst            :TRect)  : boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInRct              (constref pt                 :TPtPos;
                                 constref rct_dst            :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInRct              (constref pt                 :TPtPosF;
                                 constref rct_dst            :TRect)  : boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInRct              (constref pt                 :TPtPosF;
                                 constref rct_dst            :TPtRect): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInRct              (constref pt                 :TPtPosF;
                                 constref rct_dst            :TPtRect;
                                 constref rad                :integer): boolean;       inline; {$ifdef Linux}[local];{$endif}

// (Point in Circle) Точка в окружности:
function IsPtInCrc              (constref x,y                :integer;
                                 constref crc_dst            :TCrPos;
                                 constref prec               :integer): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInCrc              (constref x,y                :integer;
                                 constref crc_dst            :TCrPosF;
                                 constref prec               :integer): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInCrc              (constref x,y                :double;
                                 constref crc_dst            :TCrPosF;
                                 constref prec               :integer): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInCrc              (constref x,y                :double;
                                 constref crc_x,
                                          crc_y,
                                          crc_r              :integer;
                                 constref prec               :integer): boolean;       inline; {$ifdef Linux}[local];{$endif}
function IsPtInCrc              (constref x,y                :integer;
                                 constref crc_x,
                                          crc_y,
                                          crc_r              :integer;
                                 constref prec               :integer): boolean;       inline; {$ifdef Linux}[local];{$endif}

// (Distance Between Two Points) Расстояние между двумя точками:
function PtDist                 (constref x0,y0,x1,y1        :integer): double ;       inline; {$ifdef Linux}[local];{$endif}
function PtDist                 (constref x0,y0,x1,y1        :double ): double ;       inline; {$ifdef Linux}[local];{$endif}
function PtDistSqr              (constref x0,y0,x1,y1        :integer): integer;       inline; {$ifdef Linux}[local];{$endif}
function PtDistSqr              (constref x0,y0,x1,y1        :integer): double ;       inline; {$ifdef Linux}[local];{$endif}
function PtDistSqr              (constref x0,y0,x1,y1        :double ): double ;       inline; {$ifdef Linux}[local];{$endif}

// (Line-Line Intersection Point) Точка пересечения двух линий:
function LineLineIntPt          (constref x0,y0,x1,y1,
                                          v0,w0,v1,w1        :double): TPtPosF;        inline; {$ifdef Linux}[local];{$endif}

// (Line-Circle Intersection Points) Точки пересечения линии и окружности:
function LineCrcIntPt           (constref x0,y0,x1,y1        :double;
                                 constref crc_dst            :TCrPosF): TLnPosF;       inline; {$ifdef Linux}[local];{$endif}
function LineCrcIntPt           (constref x0,y0,x1,y1        :double;
                                 constref x,y,r              :double ): TLnPosF;       inline; {$ifdef Linux}[local];{$endif}
function LineCrcIntPt           (constref x0,y0,x1,y1        :integer;
                                 constref x,y,r,v            :double ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function CrcPosF                (constref x,y,r              :double ): TCrPosF;       inline; {$ifdef Linux}[local];{$endif}

// (Circle-Circle Intersection) Пересечение двух окружностей:
function CrcCrcInt              (constref x0,y0,r0,x1,y1,r1  :double ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function CrcCrcInt              (constref x0,y0,r0,x1,y1,r1  :integer): boolean;       inline; {$ifdef Linux}[local];{$endif}
function CrcCrcInt              (constref crc0,crc1          :TCrPosF): boolean;       inline; {$ifdef Linux}[local];{$endif}
function CrcCrcInt              (constref crc0,crc1          :TCrPos ): boolean;       inline; {$ifdef Linux}[local];{$endif}

// (Rectangle-Circle Intersection) Пересечение прямоугольника и окружности:
function RctCrcInt              (constref rct                :TRect;
                                 constref x,y,r              :integer): boolean;       inline; {$ifdef Linux}[local];{$endif}
function RctCrcInt              (constref rct                :TPtRect;
                                 constref x,y,r              :integer): boolean;       inline; {$ifdef Linux}[local];{$endif}

// (Angle Between Two Connected Segments,(x1,y1) - Connection Point) Угол между двумя соединенными сегментами,(x1,y1) - точка соединения:
function Angle1                 (constref x0,y0,x1,y1,x2,y2  :double): double;         inline; {$ifdef Linux}[local];{$endif}
function Angle2                 (constref x0,y0,x1,y1,x2,y2  :double): double;         inline; {$ifdef Linux}[local];{$endif}

// (Gauss's Area Formula) Формула площади Гаусса:
function GaussPolygonArea       (pt_cnt                      :integer;
                                 first_pt_ptr                :PPtPosF): double;        inline; {$ifdef Linux}[local];{$endif}
function GaussSumTrisArea       (pt_cnt                      :integer;
                                 first_pt_ptr,pt_out         :PPtPosF): double;        inline; {$ifdef Linux}[local];{$endif}



(********************************** Blitters **********************************)

function  GetBmpHandle          (         bmp                :TBitmap): PInteger{pointer}; inline;
procedure GLBitmapInit          (         tex_id             :TColor;
                                          bmp                :Graphics.TBitmap;
                                          b                  :boolean);                inline;
procedure CnvToCnv              (         rct_dst            :TPtRect;
                                          cnv_dst,
                                          cnv_src            :TCanvas;
                                          copy_mode          :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure BitBlt1               (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst_left,
                                          rct_dst_top,
                                          bmp_src_width,
                                          bmp_dst_width      :integer);                inline;
procedure BitBlt1               (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src_left,
                                          rct_src_top,
                                          rct_src_width,
                                          rct_src_height,
                                          rct_dst_left,
                                          rct_dst_top,
                                          bmp_src_width,
                                          bmp_dst_width      :integer);                inline;
procedure BitBlt1               (var      arr_src            :TColorArr;
                                 constref rct_src_width,
                                          rct_src_height,
                                          rct_dst_left,
                                          rct_dst_top        :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure BitBlt2               (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst_left,
                                          rct_dst_top,
                                          bmp_src_width,
                                          bmp_dst_width      :integer);                inline;
procedure BitBlt2               (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src_left,
                                          rct_src_top,
                                          rct_src_width,
                                          rct_src_height,
                                          rct_dst_left,
                                          rct_dst_top,
                                          bmp_src_width,
                                          bmp_dst_width      :integer);                inline;
procedure BmpToBmp2             (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref bmp_src_width,
                                          bmp_dst_width      :integer;
                                 constref clp_rct            :TPtRect;
                                 constref inn_wnd_mrg_       :integer);                inline; {$ifdef Linux}[local];{$endif}
procedure BitBlt3               (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst_left,
                                          rct_dst_top,
                                          bmp_src_width,
                                          bmp_dst_width      :integer;
                                          transparent_color  :TColor);                 inline;
procedure BitBlt3               (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src_left,
                                          rct_src_top,
                                          rct_src_width,
                                          rct_src_height,
                                          rct_dst_left,
                                          rct_dst_top,
                                          bmp_src_width,
                                          bmp_dst_width      :integer;
                                          transparent_color  :TColor);                 inline; {$ifdef Linux}[local];{$endif}



(******************************* Image Transform ******************************)

// Scale:
procedure ImgScl                (constref bmp_src_ptr        :PInteger;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width,
                                          bmp_dst_height     :TColor;
                                 constref ker_w,
                                          ker_h              :integer);                inline; {$ifdef Linux}[local];{$endif} deprecated;

// Rotate:
procedure ImgRotLoop0           (constref rct_src            :TPtRect;
                                          bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width,
                                          d_width,
                                          c,s,v,w,
                                          lt,tp,rt,bt        :integer;
                                 constref mask_alpha         :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure ImgRotLoop1           (constref rct_src            :TPtRect;
                                          bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width,
                                          d_width,
                                          c,s,v,w,
                                          lt,tp,rt,bt        :integer;
                                 constref mask_alpha         :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure ImgRotLoop2           (constref rct_src            :TPtRect;
                                          bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width,
                                          d_width,
                                          c,s,v,w,
                                          lt,tp,rt,bt        :integer;
                                 constref mask_alpha         :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure ImgRotLoop3           (constref rct_src            :TPtRect;
                                          bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width,
                                          d_width,
                                          c,s,v,w,
                                          lt,tp,rt,bt        :integer;
                                 constref mask_alpha         :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure ImgRotLoop4           (constref rct_src            :TPtRect;
                                          bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width,
                                          d_width,
                                          c,s,v,w,
                                          lt,tp,rt,bt        :integer;
                                 constref mask_alpha         :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure ImgRotLoop5           (constref rct_src            :TPtRect;
                                          bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width,
                                          d_width,
                                          c,s,v,w,
                                          lt,tp,rt,bt        :integer;
                                 constref mask_alpha         :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure ImgRot1               (constref pvt                :TPtPos;
                                 constref rct_src,
                                          rct_clp            :TPtRect;
                                 constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 constref angle              :double;
                                 constref x,
                                          y                  :integer;
                                 constref add_alpha_mask     :byte;
                                 var      bounding_rct       :TPtRect;
                                 constref mask_alpha         :TColor);                 inline; {$ifdef Linux}[local];{$endif}
procedure ImgRot2               (constref pvt                :TPtPos;
                                 constref rct_src,
                                          rct_clp            :TPtRect;
                                 constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 constref angle              :double;
                                 constref x,
                                          y,
                                          inn_wnd_mrg,
                                          bmp_src_height     :integer);                inline; {$ifdef Linux}[local];{$endif}



(******************************* Post-Processing ******************************)

procedure PPDec2ProcInit;                                                                      {$ifdef Linux}[local];{$endif}
procedure ArrFilProcInit;                                                                      {$ifdef Linux}[local];{$endif}
procedure PPBlurProcInit;                                                                      {$ifdef Linux}[local];{$endif}

// (Flood Fill) Заливка:
procedure PPFloodFillAdd        (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPFloodFillSub        (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPFloodFill           (constref bmp_dst_ptr        :PByte;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPFloodFill           (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref col                :TColor);
procedure PPFloodFill           (constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_dst_width,
                                          rct_dst_height,
                                          first_pix_pos      :integer;
                                 constref col                :TColor);
procedure PPFloodFill           (constref bmp_dst            :Graphics.TBitmap;
                                 constref col                :TColor);                         {$ifdef Linux}[local];{$endif}
procedure PPFloodFill           (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref col                :TColor;
                                          flood_fill_inc     :boolean);

// (Additive) Аддитивное смешивание:
procedure PPAdditive            (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref col                :TColor);
procedure PPAdditive            (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_src_width,
                                          bmp_dst_width      :TColor);
procedure PPAdditiveDec         (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref col                :TColor;
                                 constref pow                :byte=64);
procedure PPAdditiveDec         (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 constref pow                :byte=64);

// (AlphaBlend) Полупрозрачность:
procedure PPAlphaBlend          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref col                :TColor;
                                 constref pow                :byte=64;
                                          alpha_max          :byte=MAXBYTE);
procedure PPAlphaBlend          (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 constref pow                :byte=64;
                                          alpha_max          :byte=MAXBYTE);

// (Inverse) Инверсия:
procedure PPInverse             (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPInverseDec          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref pow                :byte=64);

// (HighLight) Подсветка:
procedure PPHighlight           (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref pow                :byte=64);

// (Darken) Затемнение:
procedure PPDarken              (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref pow                :byte=64);

// (GrayscaleR) Оттенок серого: красный канал:
procedure PPGrayscaleR          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPGrayscaleRDec       (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref pow                :byte=64);

// (GrayscaleG) Оттенок серого: красный канал:
procedure PPGrayscaleG          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPGrayscaleGDec       (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref pow                :byte=64);

// (GrayscaleB) Оттенок серого: красный канал:
procedure PPGrayscaleB          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPGrayscaleBDec       (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref pow                :byte=64);

// (Monochrome Noise) Монохромный шум:
procedure PPMonoNoise           (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref col                :TColor);
procedure PPMonoNoiseDec        (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref col                :TColor;
                                 constref pow                :byte=64;
                                          alpha_max          :byte=MAXBYTE);

// (Colorize) Окраска:
procedure PPColorCorrectionM0   (         ColorizeM          :TFunc3;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref pow                :byte=32;
                                          alpha_max          :byte=MAXBYTE);
procedure PPColorCorrectionP0   (         ColorizeP          :TFunc3;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref pow                :byte=32;
                                          alpha_max          :byte=MAXBYTE);
procedure PPColorCorrectionM0   (         ColorizeM          :TFunc3;
                                 constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 constref pow                :byte=32;
                                          alpha_max          :byte=MAXBYTE);
procedure PPColorCorrectionP0   (         ColorizeP          :TFunc3;
                                 constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 constref pow                :byte=32;
                                          alpha_max          :byte=MAXBYTE);
procedure PPColorCorrectionM1   (         ColorizeM          :TFunc1;
                                 constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 constref pow                :byte=32;
                                          alpha_max          :byte=MAXBYTE);
procedure PPColorCorrectionP1   (         ColorizeP          :TFunc1;
                                 constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 constref pow                :byte=32;
                                          alpha_max          :byte=MAXBYTE);

// (Vertical Gradient) Вертикальный градиент:
procedure PPGrVMonochrome       (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                          grad_prop          :TGradProp);
procedure PPGrVAdditive         (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                          grad_prop          :TGradProp);
procedure PPGrVAlphablend       (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                          grad_prop          :TGradProp);
procedure PPGrVInverse          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                          grad_prop          :TGradProp);
procedure PPGrV16               (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                          grad_prop          :TGradProp;
                                          Proc16             :TProc16);
procedure PPGrV17               (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                          grad_prop          :TGradProp;
                                          Proc17             :TProc17);
procedure PPGrVMonoNoise        (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                          grad_prop          :TGradProp);
procedure PPGrV18               (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                          grad_prop          :TGradProp;
                                          Proc18             :TProc18);
procedure PPGrV19               (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                          grad_prop          :TGradProp;
                                          Proc19             :TProc19);
procedure PPGrVContrast         (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                          grad_prop          :TGradProp);

// (Contrast) Контрастность:
procedure PPContrast1           (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref pow                :byte=64);
procedure PPContrast2           (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref pow                :byte=64);

// (Blur) Размытие:
procedure PPBlurProc00          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPBlurProc01          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPBlurProc02          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPBlurProc03          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPBlurProc04          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPBlurProc05          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPBlurProc06          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPBlurProc07          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPBlurProc08          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPBlurProc09          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPBlurProc10          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPBlurProc11          (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor);
procedure PPBlur                (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref blur_type          :byte=0;
                                 constref border_filter      :TBorderFilter=efNotTiled);
procedure PPBlur                (constref bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 constref rct_src            :TPtRect;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 constref blur_type          :byte=0);
procedure PPBDec                (constref bmp_dst_ptr        :PInteger;
                                 constref rct_dst            :TPtRect;
                                 constref bmp_dst_width      :TColor;
                                 constref alpha              :byte;
                                          PPBDecProc         :TProc19);

var

  fast_image_proc_var : TFastImageProc;

  {Precalculated Table of Greatest Common Divisors}
  {array of greatest common divisors}
  gcd_arr             : TGCDArr;
  {precision of calculation}
  grid_pt_rad         : TColor;

  DefaultParallaxShift: TPtPos=(x:16; y:16);
  PPDec2Proc          : array[0..29] of TFunc2;
  ArrFilProc          : array[0..29] of TProc5;
  PPBlurProc          : array[0..11] of TProc6;
  curve_default_prop  : TCurveProp={$region -fold}
  (
    dup_pts_id               : (arr:(0,0,0,0,0,0); obj_ind:-1; pts_ind:-1; dup_pts_cnt:0; weight:0);
    curve_obj_ind            : 0;
    pts_cnt                  : 0;
    pts_cnt_val              : 256;
    eds_smpl_angle           : 2.0;

    rct_eds_col_ptr          : Nil;
    rct_eds_col              : $00D95BBA;
    rct_eds_col_inv          : $00000000;
    rct_eds_col_rnd          : False;
    rct_eds_col_fall_off     : False;
    rct_eds_col_fall_off_inc : 1;

    rct_pts_col_ptr          : Nil;
    rct_pts_col              : $00922176;
    rct_pts_col_inv          : $00000000;
    rct_pts_col_rnd          : False;
    rct_pts_col_fall_off     : False;
    rct_pts_col_fall_off_inc : 1;

    eds_col_ptr              : Nil;
    eds_col                  : $00CBC97C;
    eds_col_inv              : $00000000;
    eds_col_rnd              : False;
    eds_col_fall_off         : False;
    eds_col_fall_off_inc     : 1;
    eds_width                : 1;
    eds_width_half           : 0;
    eds_width_odd            : 0;
    eds_aa                   : True;

    pts_col_ptr              : Nil;
    pts_col                  : $006A692B;
    pts_col_inv              : $00000000;
    pts_col_rnd              : False;
    pts_col_fall_off         : False;
    pts_col_fall_off_inc     : 1;
    pts_width                : 5;
    pts_width__half          : 2;
    pts_width__odd           : 0;
    pts_height               : 5;
    pts_height_half          : 2;
    pts_height_odd           : 0;

    {rectangle}
    rct_val_arr              : (-2,-2,2,-1,2);
    pts_rct_width            : 5;
    pts_rct_width__half      : 2;
    pts_rct_width__odd       : 0;
    pts_rct_height           : 5;
    pts_rct_height_half      : 2;
    pts_rct_height_odd       : 0;
    pts_rct_tns_left         : 1;
    pts_rct_tns_top          : 1;
    pts_rct_tns_right        : 1;
    pts_rct_tns_bottom       : 1;
    pts_rct_inn_width        : 3;
    pts_rct_inn_width__odd   : 1;
    pts_rct_inn_height       : 3;
    pts_rct_inn_height_odd   : 1;

    {circle}
    pts_crc_diam_inn         : 5;
    pts_crc_diam_inn_half    : 2;
    pts_crc_diam_out         : 5;
    pts_crc_diam_out_half    : 2;

    {polygon}
    pts_plg_diam             : 5;
    pts_plg_diam_half        : 2;
    pts_plg_ang_cnt          : 3;

    {sprite}
    pts_srt_width            : 5;
    pts_srt_height           : 5;

    sln_pts_frq              : 16;
    sln_type                 : TSplineType(0);
    sln_mode                 : TSplineMode(0);
    spray_rad                : 32;
    eds_bld_stl              : TDrawingStyle(0);
    pts_bld_stl              : TDrawingStyle(0);
    rct_eds_bld_stl          : TDrawingStyle(2);
    rct_pts_bld_stl          : TDrawingStyle(2);
    clp_stl                  : TClipStyle(0);
    eds_lod                  : False;
    eds_simpl_angle          : 20.0;
    hid_ln_elim              : True;
    best_ends_quality        : True;
    best_precision           : False;
    lazy_repaint             : True;
    lazy_repaint_prev        : False;
    byte_mode                : True;
    better_quality           : False;
    grid_clipping_eds        : False;
    grid_clipping_pts        : True;
    grid_clipping_obj        : False;
    only_fit_to_wnd_calc     : False;
    free_mem_on_out_of_wnd   : True;
    free_mem_on_scale_down   : False;
    realloc_mem              : False;
    remove_brunching         : False;
    rct_eds_show             : False;
    rct_pts_show             : False;
    eds_show                 : False;
    pts_show                 : False;
    cnc_ends                 : False;
    pts_ord_inv              : False;
    is_out_of_wnd            : False;
    dyn_stl                  : dsNone;

    fml_type                 : TSplineFormula(0);

    {Cycloid}
    cycloid_pts_cnt          : 256;
    cycloid_loop_cnt         : 003;
    cycloid_loop_rad         : 064.0;
    cycloid_curvature        : 001.0;
    cycloid_dir_x            : TMovingDirection(1);
    cycloid_dir_y            : TMovingDirection(2);

    {Epicycloid}
    epicycloid_pts_cnt       : 256;
    epicycloid_petals_cnt    : 008.0;
    epicycloid_rad           : 256.0;
    epicycloid_rot           : 000.0;
    epicycloid_angle         : 360.0;

    {Rose}
    rose_pts_cnt             : 256;
    rose_petals_cnt          : 007.0;
    rose_rad                 : 256.0;
    rose_rot                 : 000.0;
    rose_angle               : 180.0;
    rose_mobius_grid         : False;

    {Spiral}
    spiral_pts_cnt           : 256;
    spiral_coil_step         : 001.0;
    spiral_rad               : 256.0;
    spiral_rot               : 000.0;
    spiral_angle             : 720.0;

    {Superellipse}
    superellipse_pts_cnt     : 256;
    superellipse_curvature0  : 006.0;
    superellipse_curvature1  : 006.0;
    superellipse_curvature2  : 000.1;
    superellipse_curvature3  : 000.1;
    superellipse_rad         : 006.0;
    superellipse_rot         : 000.0;
    superellipse_angle       : 360.0;

  ); {$endregion}
  ftext_default_prop  : TFTextProp={$region -fold}
  (
    bkgnd_col    : clWhite;
    bkgnd_draw   : False;
    bkgnd_rnd_col: false;
  ); {$endregion}
  selit_default_prop  : TSelItProp={$region -fold}
  (
    bkgnd_style   : bsBoth;
    selection_mode: smCircle;
  ); {$endregion}

implementation

(******************************** Misc. Routines ******************************) {$region -fold}

//
class operator TPtPos. =(r1,r2:TPtPos ): boolean;                                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(r1.x=r2.x) and (r1.y=r2.y);
end;  {$endregion}
class operator TPtPos2.=(r1,r2:TPtPos2): boolean;                                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(r1.x=r2.x) and (r1.y=r2.y);
end;  {$endregion}
//
class operator TPtPosF.=(r1,r2:TPtPosF): boolean;                                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(r1.x=r2.x) and (r1.y=r2.y);
end;  {$endregion}
class operator TPtPos3.=(r1,r2:TPtPos3): boolean;                                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(r1*r2) and (r1.obj_ind=r2.obj_ind) and (r1.dup_pts_cnt=r2.dup_pts_cnt);
end;  {$endregion}
class operator TPtPos3.*(r1,r2:TPtPos3): boolean;                                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(r1.arr[0]=r2.arr[0]) and
          (r1.arr[1]=r2.arr[1]) and
          (r1.arr[2]=r2.arr[2]) and
          (r1.arr[3]=r2.arr[3]) and
          (r1.arr[4]=r2.arr[4]) and
          (r1.arr[5]=r2.arr[5]);
end;  {$endregion}
//
procedure      TPtPos3.SetEqual0(var r1:TPtPos3; constref r2:TPtPos3);                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  r1.dup_pts_cnt:=r2.dup_pts_cnt;
  r1.arr[0]     :=r2.arr[0];
  r1.arr[1]     :=r2.arr[1];
  r1.arr[2]     :=r2.arr[2];
  r1.arr[3]     :=r2.arr[3];
  r1.arr[4]     :=r2.arr[4];
  r1.arr[5]     :=r2.arr[5];
  //SetEqual2(r1,r2);
end; {$endregion}
procedure      TPtPos3.SetEqual1(var r1:TPtPos3; constref r2:TPtPos3);                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  r1.obj_ind    :=-1{r2.obj_ind};
  r1.pts_ind    :=-1{r2.pts_ind};
  r1.dup_pts_cnt:=r2.dup_pts_cnt;
  r1.arr[0]     :=r2.arr[0];
  r1.arr[1]     :=r2.arr[1];
  r1.arr[2]     :=r2.arr[2];
  r1.arr[3]     :=r2.arr[3];
  r1.arr[4]     :=r2.arr[4];
  r1.arr[5]     :=r2.arr[5];
  //SetEqual2(r1,r2);
end; {$endregion}
procedure      TPtPos3.SetEqual2(var r1:TPtPos3; constref r2:TPtPos3);                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  r1.arr[0]:=r2.arr[0];
  r1.arr[1]:=r2.arr[1];
  r1.arr[2]:=r2.arr[2];
  r1.arr[3]:=r2.arr[3];
  r1.arr[4]:=r2.arr[4];
  r1.arr[5]:=r2.arr[5];
end; {$endregion}
//
function       TPtPos3.IsEqual  (r1,r2 :TPtPos3): boolean;                                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=
  (r1.arr[0]=r2.arr[0]) and
  (r1.arr[1]=r2.arr[1]) and
  (r1.arr[2]=r2.arr[2]) and
  (r1.arr[3]=r2.arr[3]) and
  (r1.arr[4]=r2.arr[4]) and
  (r1.arr[5]=r2.arr[5]);
end; {$endregion}
// (Swapping two values) Поменять местами два значения:
procedure Swap1(var x,y:integer);                                                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  x:=x xor y;
  y:=x xor y;
  x:=x xor y;
end; {$endregion}
procedure Swap2(var x,y:integer);                                                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  x-=y;
  y+=x;
  x:=y-x;
end; {$endregion}
procedure Swap3(var x,y:double);                                                                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  t: double;
begin
  t:=x;
  x:=y;
  y:=t;
end; {$endregion}
//
function GetEnumVal(enum:TDrawingStyle): integer;                                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=GetEnumValue(TypeInfo(enum),GetEnumName(TypeInfo(enum),Ord(enum)));
end; {$endregion}
function GetEnumVal(enum:TDrawingStyle): TColor;                                                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=GetEnumValue(TypeInfo(enum),GetEnumName(TypeInfo(enum),Ord(enum)));
end; {$endregion}
// (Minimum of values):
function Min1(constref a1,a2:double                                                                               ): double;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (a1<a2) then
    Result:=a1
  else
    Result:=a2;
end; {$endregion}
function Min2(constref a1,a2:integer                                                                              ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (a1<a2) then
    Result:=a1
  else
    Result:=a2;
end; {$endregion}
function Min3(constref a1,a2:TColor                                                                               ): TColor;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (a1<a2) then
    Result:=a1
  else
    Result:=a2;
end; {$endregion}
function Min4(constref arr:TIntrArr;  constref max_item_val:integer; constref item_cnt:integer                    ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=max_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]<=Result) then
      Result:=arr[i];
end; {$endregion}
function Min5(constref arr:TColorArr; constref max_item_val:TColor;  constref item_cnt:TColor                     ): TColor;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=max_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]<=Result) then
      Result:=arr[i];
end; {$endregion}
function Min6(constref arr:TIntrArr;  constref max_item_val:integer; constref item_cnt:integer; constref b:boolean): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,a: integer;
begin
  Result:=0;
  a  :=max_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]<=a) then
      begin
        a  :=arr[i];
        Result:=i;
      end;
end; {$endregion}
function Min7(constref arr:TColorArr; constref max_item_val:TColor;  constref item_cnt:TColor;  constref b:boolean): TColor;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
  a: TColor;
begin
  Result:=0;
  a     :=max_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]<=a) then
      begin
        a     :=arr[i];
        Result:=i;
      end;
end; {$endregion}
function Min8(constref arr:TEdgeArr;  constref max_item_val:integer; constref item_cnt:integer                    ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=max_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i].obj_ind<=Result) then
      Result:=arr[i].obj_ind;
end; {$endregion}
function Min9(constref arr:TEdgeArr;  constref max_item_val:TColor;  constref item_cnt:TColor                     ): TColor;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=max_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i].obj_ind<=Result) then
      Result:=arr[i].obj_ind;
end; {$endregion}
// (Maximum of values):
function Max1(constref a1,a2:double                                                                               ): double;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (a1>a2) then
    Result:=a1
  else
    Result:=a2;
end; {$endregion}
function Max2(constref a1,a2:integer                                                                              ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (a1>a2) then
    Result:=a1
  else
    Result:=a2;
end; {$endregion}
function Max3(constref a1,a2:TColor                                                                               ): TColor;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (a1>a2) then
    Result:=a1
  else
    Result:=a2;
end; {$endregion}
function Max4(constref arr:TIntrArr;  constref min_item_val:integer; constref item_cnt:integer                    ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=min_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]>=Result) then
      Result:=arr[i];
end; {$endregion}
function Max5(constref arr:TColorArr; constref min_item_val:TColor;  constref item_cnt:TColor                     ): TColor;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=min_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]>=Result) then
      Result:=arr[i];
end; {$endregion}
function Max6(constref arr:TIntrArr;  constref min_item_val:integer; constref item_cnt:integer; constref b:boolean): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,a: integer;
begin
  Result:=0;
  a     :=min_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]>=a) then
      begin
        a     :=arr[i];
        Result:=i;
      end;
end; {$endregion}
function Max7(constref arr:TColorArr; constref min_item_val:TColor;  constref item_cnt:TColor;  constref b:boolean): TColor;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
  a: TColor;
begin
  Result:=0;
  a     :=min_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]>=a) then
      begin
        a     :=arr[i];
        Result:=i;
      end;
end; {$endregion}
function Max8(constref arr:TEdgeArr;  constref min_item_val:integer; constref item_cnt:integer                    ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=min_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i].obj_ind>=Result) then
      Result:=arr[i].obj_ind;
end; {$endregion}
function Max9(constref arr:TEdgeArr;  constref min_item_val:TColor;  constref item_cnt:TColor                     ): TColor;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=min_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i].obj_ind>=Result) then
      Result:=arr[i].obj_ind;
end; {$endregion}
// (MinSubMax:important condition!: c>d):
function MinSubMax(const a,b,c,d:integer                                                                          ): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (a>b) then
    Result:=b+d-a
  else
    Result:=a+c-b;
end; {$endregion}
//
function InvSqrt(constref x:single): single;                                                                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  result_as_int: UInt32 absolute Result;
begin
  Result       :=x;
  result_as_int:=$5F3759DF-(result_as_int>>1);
  Result       *=(1.5-(x*0.5*Result*Result));
end; {$endregion}
//
function Limit(x:integer): byte;                                                                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (x<0) then
    Result:=0
  else
  if (x>MAXBYTE) then
    Result:=MAXBYTE
  else
    Result:=x;
end; {$endregion}
//
procedure PtrInit(var ptr:PInteger; constref arr:TIntrArr );                                                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (Length(arr)<>0) then
    ptr:=@arr[0];
end; {$endregion}
procedure PtrInit(var ptr:PInteger; constref arr:TColorArr);                                                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (Length(arr)<>0) then
    ptr:=@arr[0];
end; {$endregion}
//
procedure MaxSpriteWHRctInit(var rct:TPtRect);                                                                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  rct:=PtBounds
  (
    0,
    0,
    MAX_SPRITE_WIDTH,
    MAX_SPRITE_HEIGHT
  )
end; {$endregion}
function ArcTan4(constref x0,y0,x1,y1:double): double;                                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v1,w1,k,b,dx: double;
  angle       : double;
begin
  if (x1=x0) then
    begin
      Result:=pi/2;
      Exit;
    end;
  if (y1=y0) then
    begin
      Result:=0;
      Exit;
    end;
  angle:=Abs(ArcTan((y1-y0)/(x1-x0)));
  if ((y1>y0) and (x1>x0)) or
     ((y1<y0) and (x1<x0)) then
    Result:=angle
  else
  if ((y1>y0) and (x1<x0)) or
     ((y1<y0) and (x1>x0)) then
    Result:=pi-angle;
end; {$endregion}
// (Finding a Substring in a TStrings) Поиск подстроки в строке:
function IndexOfSubStr(const list:TStrings; var sub_string:string): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  index: integer;
begin
  Result:=-1;
  if list.Count=0 then
    Exit;
  sub_string:=UpperCase(sub_string);
  for index:=0 to list.Count-1 do
    if (Pos(sub_string,UpperCase(list[index]))>0) then
      begin
        Result:=index;
        Break;
      end;
end; {$endregion}
// (Binary Search) Бинарный поиск:
function BinarySearch(constref n:TColor; constref arr_item_ptr:PInteger; constref right_border:integer): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  a,b: integer;
begin
  a:=0;
  b:=n-1;
  Result:=(a+b)>>1;
  while ((b-a)>1) do
    begin
      if ((arr_item_ptr+Result)^<right_border) then
        a:=Result
      else
        b:=Result;
      Result:=(a+b)>>1;
    end;
end; {$endregion}
// (Interpolation Search) Интерполирующий поиск:
{TODO}
// (Store Color Channel into Integer Array) Сохранить цветовой канал в целочисленный массив:
procedure BmpToArr(constref bmp_src_ptr:PInteger; var bmp_dst_ptr:PInteger; var arr_dst:TColorArr; constref bmp_src_rct:TPtRect; constref bmp_src_width,bmp_src_height:TColor; var bmp_dst_width,bmp_dst_height:TColor); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  bmp_src_rct_clp: TPtRect;
begin
  with bmp_src_rct_clp do
    begin
      bmp_src_rct_clp:=ClippedRct(PtBounds(0,0,bmp_src_width,bmp_src_height),bmp_src_rct);
      SetLength(arr_dst,width*height);
      bmp_dst_ptr:=Unaligned(@arr_dst[0]);
      if (width=bmp_src_width) and (height=bmp_src_height) then
        Move(bmp_src_ptr^,(@arr_dst[0])^,(width*height)<<2)
      else
        BitBlt2(bmp_src_ptr,bmp_dst_ptr,bmp_src_rct_clp,0,0,bmp_src_width,width);
      bmp_dst_width :=width;
      bmp_dst_height:=height;
    end;
end; {$endregion}
// (Checks if both values x and y have not equal signs) Проверяет, имеют ли оба значения x и y не одинаковые знаки:
function NotEqualSign(x,y:double): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=((x>0) and (y<0)) or ((x<0) and (y>0));
end; {$endregion}
// (Calculation of the global axis shift error during the movement of the block motion of the layer) Вычисление ошибки смещения глобальной оси при блочном движении слоя:
procedure ShiftErrorCalc0(x0,x1:double; var err:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f0,f1,df:double;
begin
  err:=0;
  f0 :=Frac(x0);
  f1 :=Frac(x1);
  df :=f0- (f1);
  if (df<0{f0<f1}) then
    err:=1;
  if NotEqualSign(f0,f1) then
    begin
      err-=1;
      if ({Abs}(Trunc(df))=0) then
        err+=1;
    end;
end; {$endregion}
procedure ShiftErrorCalc1(x0,x1:double; var err:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f0,f1,df:double;
begin
  err:=0;
  f0 :=Frac(x0);
  f1 :=Frac(x1);
  df :=f0- (f1);
  if (df>0{f0>f1}) then
    err:=1;
  if NotEqualSign(f0,f1) then
    begin
      err-=1;
      if ({Abs}(Trunc(df))=0) then
        err+=1;
    end;
end; {$endregion}

{$endregion}



(******************************* Color Transform ******************************) {$region -fold}

function  Red            (pixel:TColor): byte;   inline; {$ifdef Linux}[local]; {$endif} {$region -fold}
begin
  Result:=TRGBA(pixel).r{(pixel>>00)}{ and $000000ff};
end; {$endregion}
function  Green          (pixel:TColor): byte;   inline; {$ifdef Linux}[local]; {$endif} {$region -fold}
begin
  Result:=TRGBA(pixel).g{(pixel>>08)}{ and $000000ff};
end; {$endregion}
function  Blue           (pixel:TColor): byte;   inline; {$ifdef Linux}[local]; {$endif} {$region -fold}
begin
  Result:=TRGBA(pixel).b{(pixel>>16)}{ and $000000ff};
end; {$endregion}
function  Alpha          (pixel:TColor): byte;   inline; {$ifdef Linux}[local]; {$endif} {$region -fold}
begin
  Result:=TRGBA(pixel).a{(pixel>>24)}{ and $000000ff};
end; {$endregion}
function  RGB            (r,g,b:byte  ): TColor; inline; {$ifdef Linux}[local]; {$endif} {$region -fold}
begin
  Result:=(b<<16) or (g<<08) or r;
end; {$endregion}
function  RGBA           (r,g,b,a:byte): TColor; inline; {$ifdef Linux}[local]; {$endif} {$region -fold}
begin
  Result:=(a<<24) or (b<<16) or (g<<08) or r;
end; {$endregion}
// Regular Effect:
function  SetColorInv    (pixel:TColor; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=MAXBYTE; constref pow:byte=64; constref d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(TRGBA(pixel).b,
              TRGBA(pixel).g,
              TRGBA(pixel).r);
end; {$endregion}
function  Color          (pixel:TColor                                                                                                                                                            ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=pixel;
end; {$endregion}
function  Color0         (pixel:TColor; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=MAXBYTE; constref pow:byte=64; constref d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=pixel+d;
end; {$endregion}
function  Additive0      (pixel:TColor; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=MAXBYTE; constref pow:byte=64; constref d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Min(TRGBA(pixel).r+b,MAXBYTE),
              Min(TRGBA(pixel).g+g,MAXBYTE),
              Min(TRGBA(pixel).b+r,MAXBYTE));
end; {$endregion}
function  AdditiveA      (dst_pix,src_pix:TColor                                                                                                                                                  ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Min(TRGBA(dst_pix).r+TRGBA(src_pix).r,MAXBYTE),
              Min(TRGBA(dst_pix).g+TRGBA(src_pix).g,MAXBYTE),
              Min(TRGBA(dst_pix).b+TRGBA(src_pix).b,MAXBYTE));
end; {$endregion}
function  AdditiveB      (dst_pix,src_pix:TColor                                                                                                                                                  ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Min(TRGBA(dst_pix).r+TRGBA(src_pix).b,MAXBYTE),
              Min(TRGBA(dst_pix).g+TRGBA(src_pix).g,MAXBYTE),
              Min(TRGBA(dst_pix).b+TRGBA(src_pix).r,MAXBYTE));
end; {$endregion}
function  AlphaBlend0    (pixel:TColor; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=MAXBYTE; constref pow:byte=64; constref d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=   (((TRGBA(pixel).b-r)*d_alpha)>>8+r)<<16+
             (((TRGBA(pixel).g-g)*d_alpha)>>8+g)<<08+
             (((TRGBA(pixel).r-b)*d_alpha)>>8+b)<<00;
         {RGB(((Red  (pixel)-b)*d_alpha+b<<8-b)>>8,
              ((Green(pixel)-g)*d_alpha+g<<8-g)>>8,
              ((Blue (pixel)-r)*d_alpha+r<<8-r)>>8);}
         {RGB(((Red  (pixel)-b)*d_alpha)>>8+b,
              ((Green(pixel)-g)*d_alpha)>>8+g,
              ((Blue (pixel)-r)*d_alpha)>>8+r);}
         {RGB((Red  (pixel)*d_alpha+b*alpha)>>8,
              (Green(pixel)*d_alpha+g*alpha)>>8,
              (Blue (pixel)*d_alpha+r*alpha)>>8);}
end; {$endregion}
procedure AlphaBlend1    (pixel_ptr:PInteger; constref r,g,b:byte;                                                      constref d_alpha:byte                                                     );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=(((PRGBA(pixel_ptr)^.b-r)*d_alpha)>>8+r)<<16+
              (((PRGBA(pixel_ptr)^.g-g)*d_alpha)>>8+g)<<08+
              (((PRGBA(pixel_ptr)^.r-b)*d_alpha)>>8+b)<<00;
end; {$endregion}
function  AlphaBlendA    (dst_pix,src_pix:TColor;                                                constref alpha:byte=0                                                                            ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(((TRGBA(dst_pix).b-TRGBA(src_pix).r)*alpha)>>8+TRGBA(src_pix).r)<<16+
          (((TRGBA(dst_pix).g-TRGBA(src_pix).g)*alpha)>>8+TRGBA(src_pix).g)<<08+
          (((TRGBA(dst_pix).r-TRGBA(src_pix).b)*alpha)>>8+TRGBA(src_pix).b)<<00;
end; {$endregion}
function  AlphaBlendB    (dst_pix,src_pix:TColor;                                                constref alpha:byte=0                                                                            ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(((TRGBA(dst_pix).b-TRGBA(src_pix).b)*alpha)>>8+TRGBA(src_pix).b)<<16+
          (((TRGBA(dst_pix).g-TRGBA(src_pix).g)*alpha)>>8+TRGBA(src_pix).g)<<08+
          (((TRGBA(dst_pix).r-TRGBA(src_pix).r)*alpha)>>8+TRGBA(src_pix).r)<<00;
end; {$endregion}
function  InverseA       (pixel:TColor                                                                                                                                                            ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:={Integer}($ffffffff-pixel);
end; {$endregion}
function  Inverse0       (pixel:TColor; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=MAXBYTE; constref pow:byte=64; constref d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=Integer($ffffffff-pixel);
end; {$endregion}
function  Highlight0     (pixel:TColor; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=MAXBYTE; constref pow:byte=64; constref d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Min3(TRGBA (pixel).r+pow,MAXBYTE),
              Min3(TRGBA (pixel).g+pow,MAXBYTE),
              Min3(TRGBA (pixel).b+pow,MAXBYTE));
end; {$endregion}
function  HighlightA     (pixel:TColor;                                                                                                                constref pow:byte=64                       ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Min3(TRGBA (pixel).r+pow,MAXBYTE),
              Min3(TRGBA (pixel).g+pow,MAXBYTE),
              Min3(TRGBA (pixel).b+pow,MAXBYTE));
end; {$endregion}
function  Darken0        (pixel:TColor; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=MAXBYTE; constref pow:byte=64; constref d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Max2(TRGBA (pixel).r-pow,0),
              Max2(TRGBA (pixel).g-pow,0),
              Max2(TRGBA (pixel).b-pow,0));
end; {$endregion}
function  DarkenA        (pixel:TColor;                                                                                                                constref pow:byte=64                       ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Max2(TRGBA (pixel).r-pow,0),
              Max2(TRGBA (pixel).g-pow,0),
              Max2(TRGBA (pixel).b-pow,0));
end; {$endregion}
function  GrayscaleR0    (pixel:TColor; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=MAXBYTE; constref pow:byte=64; constref d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(TRGBA(pixel).r,
              TRGBA(pixel).r,
              TRGBA(pixel).r);
end; {$endregion}
function  GrayscaleG0    (pixel:TColor; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=MAXBYTE; constref pow:byte=64; constref d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(TRGBA(pixel).g,
              TRGBA(pixel).g,
              TRGBA(pixel).g);
end; {$endregion}
function  GrayscaleB0    (pixel:TColor; constref r:byte=0; constref g:byte=0; constref b:byte=0; constref alpha:byte=0; constref d_alpha:byte=MAXBYTE; constref pow:byte=64; constref d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(TRGBA(pixel).b,
              TRGBA(pixel).b,
              TRGBA(pixel).b);
end; {$endregion}
function  ColorizeR      (pixel:TColor; constref pow:byte                                                                                                                                         ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=pixel-TRGBA(pixel).b<<16+Byte(TRGBA(pixel).r+pow>>1-64)<<16;
end; {$endregion}
function  ColorizeG      (pixel:TColor; constref pow:byte                                                                                                                                         ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=pixel-TRGBA(pixel).g<<08+Byte(TRGBA(pixel).g+pow>>1-64)<<08;
end; {$endregion}
function  ColorizeB      (pixel:TColor; constref pow:byte                                                                                                                                         ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=pixel-TRGBA(pixel).r<<00+Byte(TRGBA(pixel).b+pow>>1-64)<<00;
end; {$endregion}
function  BlurRGB4       (pixel_ptr:PInteger; bmp_dst_width:TColor                                                                                                                                ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v0,v1,v2,v3: TColor;
begin
  v0    :=(pixel_ptr+0                 )^;
  v1    :=(pixel_ptr+2                 )^;
  v2    :=(pixel_ptr+bmp_dst_width<<1  )^;
  v3    :=(pixel_ptr+bmp_dst_width<<1+2)^;
  Result:=RGB((Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00)+Byte(    (v3)>>00))>>2,
              (Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08))>>2,
              (Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16)+Byte(    (v3)>>16))>>2);
end; {$endregion}
function  BlurRGB5       (pixel_ptr:PInteger; bmp_dst_width:TColor                                                                                                                                ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v0,v1,v2,v3,v4: TColor;
begin
  v0    :=(pixel_ptr+0                 )^;
  v1    :=(pixel_ptr+2                 )^;
  v2    :=(pixel_ptr+bmp_dst_width<<1  )^;
  v3    :=(pixel_ptr+bmp_dst_width<<0+1)^;
  v4    :=(pixel_ptr+bmp_dst_width<<1  )^;
  Result:=RGB(Trunc((Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00)+Byte(    (v3)>>00)+Byte(    (v4)>>00))/5),
              Trunc((Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08)+Byte(Word(v4)>>08))/5),
              Trunc((Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16)+Byte(    (v3)>>16)+Byte(    (v4)>>16))/5));
end; {$endregion}
function  BlurRGB9       (pixel_ptr:PInteger; bmp_dst_width:TColor                                                                                                                                ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v0,v1,v2,v3,v4,v5,v6,v7,v8: TColor;
begin
  v0    :=(pixel_ptr+0                 )^;
  v1    :=(pixel_ptr+1                 )^;
  v2    :=(pixel_ptr+2)^;
  v3    :=(pixel_ptr+bmp_dst_width<<0+0)^;
  v4    :=(pixel_ptr+bmp_dst_width<<0+1)^;
  v5    :=(pixel_ptr+bmp_dst_width<<0+2)^;
  v6    :=(pixel_ptr+bmp_dst_width<<1+0)^;
  v7    :=(pixel_ptr+bmp_dst_width<<1+1)^;
  v8    :=(pixel_ptr+bmp_dst_width<<1+2)^;
  Result:=RGB(Trunc((Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00)+Byte(    (v3)>>00)+Byte(    (v4)>>00)+Byte(    (v5)>>00)+Byte(    (v6)>>00)+Byte(    (v7)>>00)+Byte(    (v8)>>00))/9),
              Trunc((Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08)+Byte(Word(v4)>>08)+Byte(Word(v5)>>08)+Byte(Word(v6)>>08)+Byte(Word(v7)>>08)+Byte(Word(v8)>>08))/9),
              Trunc((Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16)+Byte(    (v3)>>16)+Byte(    (v4)>>16)+Byte(    (v5)>>16)+Byte(    (v6)>>16)+Byte(    (v7)>>16)+Byte(    (v8)>>16))/9));
end; {$endregion}
procedure BlurRGB        (pixel_ptr:PInteger; bmp_dst_width:TColor                                                                                                                                );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v0,v1,v2,v3: TColor;
begin
  v0                          :=(pixel_ptr+0                 )^;
  v1                          :=(pixel_ptr+2                 )^;
  v2                          :=(pixel_ptr+bmp_dst_width<<1  )^;
  v3                          :=(pixel_ptr+bmp_dst_width<<1+2)^;
  (pixel_ptr+bmp_dst_width+1)^:=RGB((Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00)+Byte(    (v3)>>00))>>2,
                                    (Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08))>>2,
                                    (Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16)+Byte(    (v3)>>16))>>2);
end; {$endregion}
procedure BlurRRB        (pixel_ptr:PInteger; bmp_dst_width:TColor                                                                                                                                );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v0,v1,v2,v3: TColor;
  r          : byte;
begin
  v0                          :=(pixel_ptr+0                 )^;
  v1                          :=(pixel_ptr+2                 )^;
  v2                          :=(pixel_ptr+bmp_dst_width<<1  )^;
  v3                          :=(pixel_ptr+bmp_dst_width<<1+2)^;
  r                           :=        (Byte((v0)>>00)+Byte((v1)>>00)+Byte((v2)>>00)+Byte((v3)>>00))>>2;
  (pixel_ptr+bmp_dst_width+1)^:=RGB(r,r,(Byte((v0)>>16)+Byte((v1)>>16)+Byte((v2)>>16)+Byte((v3)>>16))>>2);
end; {$endregion}
procedure BlurRGR        (pixel_ptr:PInteger; bmp_dst_width:TColor                                                                                                                                );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v0,v1,v2,v3: TColor;
  r          : byte;
begin
  v0                          :=(pixel_ptr+0                 )^;
  v1                          :=(pixel_ptr+2                 )^;
  v2                          :=(pixel_ptr+bmp_dst_width<<1  )^;
  v3                          :=(pixel_ptr+bmp_dst_width<<1+2)^;
  r                           :=      (Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00)+Byte(    (v3)>>00))>>2;
  (pixel_ptr+bmp_dst_width+1)^:=RGB(r,(Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08))>>2,r);
end; {$endregion}
procedure BlurGGB        (pixel_ptr:PInteger; bmp_dst_width:TColor                                                                                                                                );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v0,v1,v2,v3: TColor;
  g          : byte;
begin
  v0                          :=(pixel_ptr+0                 )^;
  v1                          :=(pixel_ptr+2                 )^;
  v2                          :=(pixel_ptr+bmp_dst_width<<1  )^;
  v3                          :=(pixel_ptr+bmp_dst_width<<1+2)^;
  g                           :=        (Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08))>>2;
  (pixel_ptr+bmp_dst_width+1)^:=RGB(g,g,(Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16)+Byte(    (v3)>>16))>>2);
end; {$endregion}
procedure BlurRGG        (pixel_ptr:PInteger; bmp_dst_width:TColor                                                                                                                                );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v0,v1,v2,v3: TColor;
  g          : byte;
begin
  v0                          :=(pixel_ptr+0                 )^;
  v1                          :=(pixel_ptr+2                 )^;
  v2                          :=(pixel_ptr+bmp_dst_width<<1  )^;
  v3                          :=(pixel_ptr+bmp_dst_width<<1+2)^;
  g                           :=    (Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08))>>2;
  (pixel_ptr+bmp_dst_width+1)^:=RGB((Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00)+Byte(    (v3)>>00))>>2,g,g);
end; {$endregion}
procedure BlurBGB        (pixel_ptr:PInteger; bmp_dst_width:TColor                                                                                                                                );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v0,v1,v2,v3: TColor;
  b          : byte;
begin
  v0                          :=(pixel_ptr+0                 )^;
  v1                          :=(pixel_ptr+2                 )^;
  v2                          :=(pixel_ptr+bmp_dst_width<<1  )^;
  v3                          :=(pixel_ptr+bmp_dst_width<<1+2)^;
  b                           :=      (Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16)+Byte(    (v3)>>16))>>2;
  (pixel_ptr+bmp_dst_width+1)^:=RGB(b,(Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08))>>2,b);
end; {$endregion}
procedure BlurRBB        (pixel_ptr:PInteger; bmp_dst_width:TColor                                                                                                                                );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v0,v1,v2,v3: TColor;
  b          : byte;
begin
  v0                          :=(pixel_ptr+0                 )^;
  v1                          :=(pixel_ptr+2                 )^;
  v2                          :=(pixel_ptr+bmp_dst_width<<1  )^;
  v3                          :=(pixel_ptr+bmp_dst_width<<1+2)^;
  b                           :=    (Byte((v0)>>16)+Byte((v1)>>16)+Byte((v2)>>16)+Byte((v3)>>16))>>2;
  (pixel_ptr+bmp_dst_width+1)^:=RGB((Byte((v0)>>00)+Byte((v1)>>00)+Byte((v2)>>00)+Byte((v3)>>00))>>2,b,b);
end; {$endregion}
procedure BlurRRR        (pixel_ptr:PInteger; bmp_dst_width:TColor                                                                                                                                );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r:=(Red((pixel_ptr+0                 )^)+
      Red((pixel_ptr+2                 )^)+
      Red((pixel_ptr+0+bmp_dst_width<<1)^)+
      Red((pixel_ptr+2+bmp_dst_width<<1)^))>>2;
          (pixel_ptr+bmp_dst_width+1)^:=RGB(r,r,r);
end; {$endregion}
procedure BlurGGG        (pixel_ptr:PInteger; bmp_dst_width:TColor                                                                                                                                );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g:=(Green((pixel_ptr+0                 )^)+
      Green((pixel_ptr+2                 )^)+
      Green((pixel_ptr+0+bmp_dst_width<<1)^)+
      Green((pixel_ptr+2+bmp_dst_width<<1)^))>>2;
            (pixel_ptr+bmp_dst_width+1)^:=RGB(g,g,g);
end; {$endregion}
procedure BlurBBB        (pixel_ptr:PInteger; bmp_dst_width:TColor                                                                                                                                );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b:=(Blue((pixel_ptr+0                 )^)+
      Blue((pixel_ptr+2                 )^)+
      Blue((pixel_ptr+0+bmp_dst_width<<1)^)+
      Blue((pixel_ptr+2+bmp_dst_width<<1)^))>>2;
           (pixel_ptr+bmp_dst_width+1)^:=RGB(b,b,b);
end; {$endregion}
function  ContrastPrecalc(constref contrast_pow:double                                                                                                                                            ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=Trunc(contrast_pow*C_INT);
end; {$endregion}
procedure Contrast       (pixel_ptr:PInteger; r,g,b:byte; pow:double                                                                                                                              );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(Limit(r+Trunc((PRGBA(pixel_ptr)^.r-r)*pow)),
                  Limit(g+Trunc((PRGBA(pixel_ptr)^.g-g)*pow)),
                  Limit(b+Trunc((PRGBA(pixel_ptr)^.b-b)*pow)));
end; {$endregion}
procedure Contrast2      (pixel_ptr:PInteger; r,g,b:byte; pow:integer                                                                                                                             );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(Limit(r+((PRGBA(pixel_ptr)^.r-r)*pow)>>16),
                  Limit(g+((PRGBA(pixel_ptr)^.g-g)*pow)>>16),
                  Limit(b+((PRGBA(pixel_ptr)^.b-b)*pow)>>16));
end; {$endregion}
// Decrease Effect:
procedure AdditiveDec    (var pixel:TColor;   constref r,g,b:byte;                     constref alpha_fade:byte                                        );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2: TColor;
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(pixel).r;
  g_  :=TRGBA(pixel).g;
  b_  :=TRGBA(pixel).b;
  m0  :=Min3(r_+b,MAXBYTE);
  if   (m0>  r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  m1  :=Min3(g_+g,MAXBYTE);
  if   (m1>  g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  m2  :=Min3(b_+r,MAXBYTE);
  if   (m2>  b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  pixel:=RGB(r_,g_,b_);
end; {$endregion}
function  AdditiveDec2   (pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2: TColor;
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(pixel).r;
  g_  :=TRGBA(pixel).g;
  b_  :=TRGBA(pixel).b;
  m0  :=Min3(r_+b,MAXBYTE);
  if   (m0>  r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  m1  :=Min3(g_+g,MAXBYTE);
  if   (m1>  g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  m2  :=Min3(b_+r,MAXBYTE);
  if   (m2>  b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  Result:=RGB(r_,g_,b_);
end; {$endregion}
function  AdditiveDecA   (dst_pix,src_pix:TColor;                                      constref alpha_fade:byte                                        ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2: TColor;
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(dst_pix).r;
  g_  :=TRGBA(dst_pix).g;
  b_  :=TRGBA(dst_pix).b;
  m0  :=Min3(r_+TRGBA(src_pix).b,MAXBYTE);
  if   (m0>  r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  m1  :=Min3(g_+TRGBA(src_pix).g,MAXBYTE);
  if   (m1>  g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  m2  :=Min3(b_+TRGBA(src_pix).r,MAXBYTE);
  if   (m2>  b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  Result:=RGB(r_,g_,b_);
end; {$endregion}
function  AdditiveDecB   (dst_pix,src_pix:TColor;                                      constref alpha_fade:byte                                        ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2: TColor;
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(dst_pix).r;
  g_  :=TRGBA(dst_pix).g;
  b_  :=TRGBA(dst_pix).b;
  m0  :=Min3(r_+TRGBA(src_pix).r,MAXBYTE);
  if   (m0>  r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  m1  :=Min3(g_+TRGBA(src_pix).g,MAXBYTE);
  if   (m1>  g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  m2  :=Min3(b_+TRGBA(src_pix).b,MAXBYTE);
  if   (m2>  b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  Result:=RGB(r_,g_,b_);
end; {$endregion}
function  AdditiveDecC   (dst_pix,src_pix:TColor                                                                                                       ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2: TColor;
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(dst_pix).r;
  g_  :=TRGBA(dst_pix).g;
  b_  :=TRGBA(dst_pix).b;
  m0  :=Min3(r_+TRGBA(src_pix).b,MAXBYTE);
  if   (m0>  r_) then
    r_:=m0-(TRGBA(src_pix).a*( m0-r_))>>8
  else
    r_:=m0+(TRGBA(src_pix).a*(-m0+r_))>>8;
  m1  :=Min3(g_+TRGBA(src_pix).g,MAXBYTE);
  if   (m1>  g_) then
    g_:=m1-(TRGBA(src_pix).a*( m1-g_))>>8
  else
    g_:=m1+(TRGBA(src_pix).a*(-m1+g_))>>8;
  m2  :=Min3(b_+TRGBA(src_pix).r,MAXBYTE);
  if   (m2>  b_) then
    b_:=m2-(TRGBA(src_pix).a*( m2-b_))>>8
  else
    b_:=m2+(TRGBA(src_pix).a*(-m2+b_))>>8;
  Result:=RGB(r_,g_,b_);
end; {$endregion}
procedure AlphaBlendDec  (pixel_ptr:PInteger; constref r,g,b:byte; alpha        :byte; constref alpha_fade:byte                                        );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  d_alpha:byte;
begin
  d_alpha:=MAXBYTE-Max2(alpha-alpha_fade,0);
  pixel_ptr^:=(((PRGBA(pixel_ptr)^.b-r)*d_alpha)>>8+r)<<16+
              (((PRGBA(pixel_ptr)^.g-g)*d_alpha)>>8+g)<<08+
              (((PRGBA(pixel_ptr)^.r-b)*d_alpha)>>8+b)<<00;
end; {$endregion}
function  AlphaBlendDec2 (pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  alpha  :=Max2(alpha-Byte(d),0);
  d_alpha:=MAXBYTE-alpha;
  Result:=(((TRGBA(pixel).b-r)*d_alpha)>>8+r)<<16+
          (((TRGBA(pixel).g-g)*d_alpha)>>8+g)<<08+
          (((TRGBA(pixel).r-b)*d_alpha)>>8+b)<<00;
end; {$endregion}
function  AlphaBlendDecA (dst_pix,src_pix:TColor;                  alpha        :byte; constref alpha_fade:byte                                        ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  d_alpha:byte;
begin
  d_alpha:=MAXBYTE-Max2(alpha-alpha_fade,0);
  Result :=(((TRGBA(dst_pix).b-TRGBA(src_pix).r)*d_alpha)>>8+TRGBA(src_pix).r)<<16+
           (((TRGBA(dst_pix).g-TRGBA(src_pix).g)*d_alpha)>>8+TRGBA(src_pix).g)<<08+
           (((TRGBA(dst_pix).r-TRGBA(src_pix).b)*d_alpha)>>8+TRGBA(src_pix).b)<<00;
end; {$endregion}
function  AlphaBlendDecB (dst_pix,src_pix:TColor;                  alpha        :byte; constref alpha_fade:byte                                        ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  d_alpha:byte;
begin
  d_alpha:=MAXBYTE-Max2(alpha-alpha_fade,0);
  Result :=(((TRGBA(dst_pix).b-TRGBA(src_pix).b)*d_alpha)>>8+TRGBA(src_pix).b)<<16+
           (((TRGBA(dst_pix).g-TRGBA(src_pix).g)*d_alpha)>>8+TRGBA(src_pix).g)<<08+
           (((TRGBA(dst_pix).r-TRGBA(src_pix).r)*d_alpha)>>8+TRGBA(src_pix).r)<<00;
end; {$endregion}
function  AlphaBlendDecC (dst_pix,src_pix:TColor;                                      constref alpha_fade:byte                                        ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  d_alpha:byte;
begin
  d_alpha:=MAXBYTE-Max2(TRGBA(src_pix).a-alpha_fade,0);
  Result :=          (((TRGBA(dst_pix).b-TRGBA(src_pix).b)*d_alpha)>>8+TRGBA(src_pix).b)<<16+
                     (((TRGBA(dst_pix).g-TRGBA(src_pix).g)*d_alpha)>>8+TRGBA(src_pix).g)<<08+
                     (((TRGBA(dst_pix).r-TRGBA(src_pix).r)*d_alpha)>>8+TRGBA(src_pix).r)<<00;
end; {$endregion}
procedure InverseDec     (var pixel:TColor;                                            constref alpha_fade:byte                                        );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(pixel).r;
  g_  :=TRGBA(pixel).g;
  b_  :=TRGBA(pixel).b;
  if   (MAXBYTE>r_<<1) then
    r_:=MAXBYTE-r_-(alpha_fade*( MAXBYTE-r_<<1))>>8
  else
    r_:=MAXBYTE-r_+(alpha_fade*(-MAXBYTE+r_<<1))>>8;
  if   (MAXBYTE>g_<<1) then
    g_:=MAXBYTE-g_-(alpha_fade*( MAXBYTE-g_<<1))>>8
  else
    g_:=MAXBYTE-g_+(alpha_fade*(-MAXBYTE+g_<<1))>>8;
  if   (MAXBYTE>b_<<1) then
    b_:=MAXBYTE-b_-(alpha_fade*( MAXBYTE-b_<<1))>>8
  else
    b_:=MAXBYTE-b_+(alpha_fade*(-MAXBYTE+b_<<1))>>8;
  pixel:=RGB(r_,g_,b_);
end; {$endregion}
function  InverseDec2    (pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(pixel).r;
  g_  :=TRGBA(pixel).g;
  b_  :=TRGBA(pixel).b;
  if   (MAXBYTE>r_<<1) then
    r_:=MAXBYTE-r_-(alpha_fade*( MAXBYTE-r_<<1))>>8
  else
    r_:=MAXBYTE-r_+(alpha_fade*(-MAXBYTE+r_<<1))>>8;
  if   (MAXBYTE>g_<<1) then
    g_:=MAXBYTE-g_-(alpha_fade*( MAXBYTE-g_<<1))>>8
  else
    g_:=MAXBYTE-g_+(alpha_fade*(-MAXBYTE+g_<<1))>>8;
  if   (MAXBYTE>b_<<1) then
    b_:=MAXBYTE-b_-(alpha_fade*( MAXBYTE-b_<<1))>>8
  else
    b_:=MAXBYTE-b_+(alpha_fade*(-MAXBYTE+b_<<1))>>8;
  Result:=RGB(r_,g_,b_);
end; {$endregion}
procedure HighlightDec   (var pixel:TColor;                                            constref alpha_fade:byte; constref pow:byte=64                  );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2: TColor;
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(pixel).r;
  g_  :=TRGBA(pixel).g;
  b_  :=TRGBA(pixel).b;
  m0  :=Min3(r_+pow,MAXBYTE);
  if   (m0>  r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  m1  :=Min3(g_+pow,MAXBYTE);
  if   (m1>  g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  m2  :=Min3(b_+pow,MAXBYTE);
  if   (m2>  b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  pixel:=RGB(r_,g_,b_);
end; {$endregion}
function  HighlightDec2  (pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2: TColor;
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(pixel).r;
  g_  :=TRGBA(pixel).g;
  b_  :=TRGBA(pixel).b;
  m0  :=Min3(r_+pow,MAXBYTE);
  if   (m0>  r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  m1  :=Min3(g_+pow,MAXBYTE);
  if   (m1>  g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  m2  :=Min3(b_+pow,MAXBYTE);
  if   (m2>  b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  Result:=RGB(r_,g_,b_);
end; {$endregion}
procedure DarkenDec      (var pixel:TColor;                                            constref alpha_fade:byte; constref pow:byte=64                  );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2: integer;
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(pixel).r;
  g_  :=TRGBA(pixel).g;
  b_  :=TRGBA(pixel).b;
  m0  :=Max2(r_-pow,0);
  if   (m0>  r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  m1  :=Max2(g_-pow,0);
  if   (m1>  g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  m2  :=Max2(b_-pow,0);
  if   (m2>  b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  pixel:=RGB(r_,g_,b_);
end; {$endregion}
function  DarkenDec2     (pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2: integer;
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(pixel).r;
  g_  :=TRGBA(pixel).g;
  b_  :=TRGBA(pixel).b;
  m0  :=Max2(r_-pow,0);
  if   (m0>  r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  m1  :=Max2(g_-pow,0);
  if   (m1>  g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  m2  :=Max2(b_-pow,0);
  if   (m2>  b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  Result:=RGB(r_,g_,b_);
end; {$endregion}
procedure GrayscaleRDec  (var pixel:TColor;                                            constref alpha_fade:byte                                        );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(pixel).r;
  g_  :=TRGBA(pixel).g;
  b_  :=TRGBA(pixel).b;
  if   (g_>r_) then
    g_:=g_-(alpha_fade*( g_-r_))>>8
  else
    g_:=g_+(alpha_fade*(-g_+r_))>>8;
  if   (b_>r_) then
    b_:=b_-(alpha_fade*( b_-r_))>>8
  else
    b_:=b_+(alpha_fade*(-b_+r_))>>8;
  pixel:=RGB(r_,g_,b_);
end; {$endregion}
function  GrayscaleRDec2 (pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(pixel).r;
  g_  :=TRGBA(pixel).g;
  b_  :=TRGBA(pixel).b;
  if   (g_>r_) then
    g_:=g_-(alpha_fade*( g_-r_))>>8
  else
    g_:=g_+(alpha_fade*(-g_+r_))>>8;
  if   (b_>r_) then
    b_:=b_-(alpha_fade*( b_-r_))>>8
  else
    b_:=b_+(alpha_fade*(-b_+r_))>>8;
  Result:=RGB(r_,g_,b_);
end; {$endregion}
procedure GrayscaleGDec  (var pixel:TColor;                                            constref alpha_fade:byte                                        );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(pixel).r;
  g_  :=TRGBA(pixel).g;
  b_  :=TRGBA(pixel).b;
  if   (r_>g_) then
    r_:=r_-(alpha_fade*( r_-g_))>>8
  else
    r_:=r_+(alpha_fade*(-r_+g_))>>8;
  if   (b_>g_) then
    b_:=b_-(alpha_fade*( b_-g_))>>8
  else
    b_:=b_+(alpha_fade*(-b_+g_))>>8;
  pixel:=RGB(r_,g_,b_);
end; {$endregion}
function  GrayscaleGDec2 (pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(pixel).r;
  g_  :=TRGBA(pixel).g;
  b_  :=TRGBA(pixel).b;
  if   (r_>g_) then
    r_:=r_-(alpha_fade*( r_-g_))>>8
  else
    r_:=r_+(alpha_fade*(-r_+g_))>>8;
  if   (b_>g_) then
    b_:=b_-(alpha_fade*( b_-g_))>>8
  else
    b_:=b_+(alpha_fade*(-b_+g_))>>8;
  Result:=RGB(r_,g_,b_);
end; {$endregion}
procedure GrayscaleBDec  (var pixel:TColor;                                            constref alpha_fade:byte                                        );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(pixel).r;
  g_  :=TRGBA(pixel).g;
  b_  :=TRGBA(pixel).b;
  if   (r_>b_) then
    r_:=r_-(alpha_fade*( r_-b_))>>8
  else
    r_:=r_+(alpha_fade*(-r_+b_))>>8;
  if   (g_>b_) then
    g_:=g_-(alpha_fade*( g_-b_))>>8
  else
    g_:=g_+(alpha_fade*(-g_+b_))>>8;
  pixel:=RGB(r_,g_,b_);
end; {$endregion}
function  GrayscaleBDec2 (pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(pixel).r;
  g_  :=TRGBA(pixel).g;
  b_  :=TRGBA(pixel).b;
  if   (r_>b_) then
    r_:=r_-(alpha_fade*( r_-b_))>>8
  else
    r_:=r_+(alpha_fade*(-r_+b_))>>8;
  if   (g_>b_) then
    g_:=g_-(alpha_fade*( g_-b_))>>8
  else
    g_:=g_+(alpha_fade*(-g_+b_))>>8;
  Result:=RGB(r_,g_,b_);
end; {$endregion}
procedure ColorizeRDec   (var pixel:TColor;                                            constref alpha_fade:byte;                    constref d:smallint);         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v : integer;
  b_: byte;
begin
  v :=Byte(Red(pixel)+d>>1-64);
  if   (v>Blue(pixel)) then
    b_:=v-(alpha_fade*( v-Blue(pixel)))>>8
  else
    b_:=v+(alpha_fade*(-v+Blue(pixel)))>>8;
  pixel:=pixel-Blue(pixel)<<16+b_<<16;
end; {$endregion}
function  ColorizeRDec2  (pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v : integer;
  b_: byte;
begin
  v :=Byte(Red(pixel)+pow>>1-64);
  if   (v>Blue(pixel)) then
    b_:=v-(alpha_fade*( v-Blue(pixel)))>>8
  else
    b_:=v+(alpha_fade*(-v+Blue(pixel)))>>8;
  Result:=pixel-Blue(pixel)<<16+b_<<16;
end; {$endregion}
procedure ColorizeGDec   (var pixel:TColor;                                            constref alpha_fade:byte;                    constref d:smallint);         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v : integer;
  g_: byte;
begin
  v :=Byte(Green(pixel)+d>>1-64);
  if   (v>Green(pixel)) then
    g_:=v-(alpha_fade*( v-Green(pixel)))>>8
  else
    g_:=v+(alpha_fade*(-v+Green(pixel)))>>8;
  pixel:=pixel-Green(pixel)<<08+g_<<08;
end; {$endregion}
function  ColorizeGDec2  (pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v : integer;
  g_: byte;
begin
  v :=Byte(Green(pixel)+pow>>1-64);
  if   (v>Green(pixel)) then
    g_:=v-(alpha_fade*( v-Green(pixel)))>>8
  else
    g_:=v+(alpha_fade*(-v+Green(pixel)))>>8;
  Result:=pixel-Green(pixel)<<08+g_<<08;
end; {$endregion}
procedure ColorizeBDec   (var pixel:TColor;                                            constref alpha_fade:byte;                    constref d:smallint);         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v : integer;
  r_: byte;
begin
  v :=Byte(Blue(pixel)+d>>1-64);
  if   (v>Red(pixel)) then
    r_:=v-(alpha_fade*( v-Red(pixel)))>>8
  else
    r_:=v+(alpha_fade*(-v+Red(pixel)))>>8;
  pixel:=pixel-Red(pixel)<<00+r_<<00;
end; {$endregion}
function  ColorizeBDec2  (pixel    :TColor;   constref r,g,b:byte; alpha,d_alpha:byte; constref alpha_fade:byte; constref pow:byte; constref d:smallint): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v : integer;
  r_: byte;
begin
  v :=Byte(Blue(pixel)+pow>>1-64);
  if   (v>Red(pixel)) then
    r_:=v-(alpha_fade*( v-Red(pixel)))>>8
  else
    r_:=v+(alpha_fade*(-v+Red(pixel)))>>8;
  Result:=pixel-Red(pixel)<<00+r_<<00;
end; {$endregion}
procedure BlurRGBDec     (pixel_ptr:PInteger; bmp_dst_width:TColor;                    constref alpha_fade:byte                                        );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2   : TColor;
  v0,v1,v2,v3: TColor;
  r_,g_,b_   : byte;
begin
  v0  :=     ((pixel_ptr+0                 )^);
  v1  :=     ((pixel_ptr+2                 )^);
  v2  :=     ((pixel_ptr+bmp_dst_width<<1  )^);
  v3  :=     ((pixel_ptr+bmp_dst_width<<1+2)^);
  r_  :=Red  ((pixel_ptr+bmp_dst_width   +1)^);
  g_  :=Green((pixel_ptr+bmp_dst_width   +1)^);
  b_  :=Blue ((pixel_ptr+bmp_dst_width   +1)^);
  m0  :=(Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00)+Byte(    (v3)>>00))>>2;
  m1  :=(Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08))>>2;
  m2  :=(Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16)+Byte(    (v3)>>16))>>2;
  {Red}
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  {Green}
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  {Blue}
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  {Color output}
  (pixel_ptr+bmp_dst_width+1)^:=RGB(r_,g_,b_);
end; {$endregion}
procedure BlurRRBDec     (pixel_ptr:PInteger; bmp_dst_width:TColor;                    constref alpha_fade:byte                                        );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2   : TColor;
  v0,v1,v2,v3: TColor;
  r_,g_,b_   : byte;
begin
  v0  :=     ((pixel_ptr+0                 )^);
  v1  :=     ((pixel_ptr+2                 )^);
  v2  :=     ((pixel_ptr+bmp_dst_width<<1  )^);
  v3  :=     ((pixel_ptr+bmp_dst_width<<1+2)^);
  r_  :=Red  ((pixel_ptr+bmp_dst_width   +1)^);
  g_  :=Green((pixel_ptr+bmp_dst_width   +1)^);
  b_  :=Blue ((pixel_ptr+bmp_dst_width   +1)^);
  m0  :=(Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00)+Byte(    (v3)>>00))>>2;
  m1  :=m0;
  m2  :=(Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16)+Byte(    (v3)>>16))>>2;
  {Red}
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  {Green}
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  {Blue}
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  {Color output}
  (pixel_ptr+bmp_dst_width+1)^:=RGB(r_,g_,b_);
end; {$endregion}
procedure BlurRGRDec     (pixel_ptr:PInteger; bmp_dst_width:TColor;                    constref alpha_fade:byte                                        );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2   : TColor;
  v0,v1,v2,v3: TColor;
  r_,g_,b_   : byte;
begin
  v0  :=     ((pixel_ptr+0                 )^);
  v1  :=     ((pixel_ptr+2                 )^);
  v2  :=     ((pixel_ptr+bmp_dst_width<<1  )^);
  v3  :=     ((pixel_ptr+bmp_dst_width<<1+2)^);
  r_  :=Red  ((pixel_ptr+bmp_dst_width   +1)^);
  g_  :=Green((pixel_ptr+bmp_dst_width   +1)^);
  b_  :=Blue ((pixel_ptr+bmp_dst_width   +1)^);
  m0  :=(Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00)+Byte(    (v3)>>00))>>2;
  m1  :=(Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08))>>2;
  m2  :=m0;
  {Red}
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  {Green}
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  {Blue}
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  {Color output}
  (pixel_ptr+bmp_dst_width+1)^:=RGB(r_,g_,b_);
end; {$endregion}
procedure BlurGGBDec     (pixel_ptr:PInteger; bmp_dst_width:TColor;                    constref alpha_fade:byte                                        );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2   : TColor;
  v0,v1,v2,v3: TColor;
  r_,g_,b_   : byte;
begin
  v0  :=     ((pixel_ptr+0                 )^);
  v1  :=     ((pixel_ptr+2                 )^);
  v2  :=     ((pixel_ptr+bmp_dst_width<<1  )^);
  v3  :=     ((pixel_ptr+bmp_dst_width<<1+2)^);
  r_  :=Red  ((pixel_ptr+bmp_dst_width   +1)^);
  g_  :=Green((pixel_ptr+bmp_dst_width   +1)^);
  b_  :=Blue ((pixel_ptr+bmp_dst_width   +1)^);
  m1  :=(Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08))>>2;
  m0  :=m1;
  m2  :=(Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16)+Byte(    (v3)>>16))>>2;
  {Red}
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  {Green}
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  {Blue}
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  {Color output}
  (pixel_ptr+bmp_dst_width+1)^:=RGB(r_,g_,b_);
end; {$endregion}
procedure BlurRGGDec     (pixel_ptr:PInteger; bmp_dst_width:TColor;                    constref alpha_fade:byte                                        );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2   : TColor;
  v0,v1,v2,v3: TColor;
  r_,g_,b_   : byte;
begin
  v0  :=     ((pixel_ptr+0                 )^);
  v1  :=     ((pixel_ptr+2                 )^);
  v2  :=     ((pixel_ptr+bmp_dst_width<<1  )^);
  v3  :=     ((pixel_ptr+bmp_dst_width<<1+2)^);
  r_  :=Red  ((pixel_ptr+bmp_dst_width   +1)^);
  g_  :=Green((pixel_ptr+bmp_dst_width   +1)^);
  b_  :=Blue ((pixel_ptr+bmp_dst_width   +1)^);
  m0  :=(Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00)+Byte(    (v3)>>00))>>2;
  m1  :=(Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08))>>2;
  m2  :=m1;
  {Red}
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  {Green}
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  {Blue}
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  {Color output}
  (pixel_ptr+bmp_dst_width+1)^:=RGB(r_,g_,b_);
end; {$endregion}
procedure BlurBGBDec     (pixel_ptr:PInteger; bmp_dst_width:TColor;                    constref alpha_fade:byte                                        );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2   : TColor;
  v0,v1,v2,v3: TColor;
  r_,g_,b_   : byte;
begin
  v0  :=     ((pixel_ptr+0                 )^);
  v1  :=     ((pixel_ptr+2                 )^);
  v2  :=     ((pixel_ptr+bmp_dst_width<<1  )^);
  v3  :=     ((pixel_ptr+bmp_dst_width<<1+2)^);
  r_  :=Red  ((pixel_ptr+bmp_dst_width   +1)^);
  g_  :=Green((pixel_ptr+bmp_dst_width   +1)^);
  b_  :=Blue ((pixel_ptr+bmp_dst_width   +1)^);
  m2  :=(Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16)+Byte(    (v3)>>16))>>2;
  m0  :=m2;
  m1  :=(Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08))>>2;
  {Red}
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  {Green}
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  {Blue}
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  {Color output}
  (pixel_ptr+bmp_dst_width+1)^:=RGB(r_,g_,b_);
end; {$endregion}
procedure BlurRBBDec     (pixel_ptr:PInteger; bmp_dst_width:TColor;                    constref alpha_fade:byte                                        );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2   : TColor;
  v0,v1,v2,v3: TColor;
  r_,g_,b_   : byte;
begin
  v0  :=     ((pixel_ptr+0                 )^);
  v1  :=     ((pixel_ptr+2                 )^);
  v2  :=     ((pixel_ptr+bmp_dst_width<<1  )^);
  v3  :=     ((pixel_ptr+bmp_dst_width<<1+2)^);
  r_  :=Red  ((pixel_ptr+bmp_dst_width   +1)^);
  g_  :=Green((pixel_ptr+bmp_dst_width   +1)^);
  b_  :=Blue ((pixel_ptr+bmp_dst_width   +1)^);
  m0  :=(Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00)+Byte(    (v3)>>00))>>2;
  m2  :=(Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16)+Byte(    (v3)>>16))>>2;
  m1  :=m2;
  {Red}
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  {Green}
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  {Blue}
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  {Color output}
  (pixel_ptr+bmp_dst_width+1)^:=RGB(r_,g_,b_);
end; {$endregion}
procedure BlurRRRDec     (pixel_ptr:PInteger; bmp_dst_width:TColor;                    constref alpha_fade:byte                                        );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2   : TColor;
  v0,v1,v2,v3: TColor;
  r_,g_,b_   : byte;
begin
  v0  :=     ((pixel_ptr+0                 )^);
  v1  :=     ((pixel_ptr+2                 )^);
  v2  :=     ((pixel_ptr+bmp_dst_width<<1  )^);
  v3  :=     ((pixel_ptr+bmp_dst_width<<1+2)^);
  r_  :=Red  ((pixel_ptr+bmp_dst_width   +1)^);
  g_  :=Green((pixel_ptr+bmp_dst_width   +1)^);
  b_  :=Blue ((pixel_ptr+bmp_dst_width   +1)^);
  m0  :=(Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00)+Byte(    (v3)>>00))>>2;
  m1  :=m0;
  m2  :=m0;
  {Red}
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  {Green}
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  {Blue}
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  {Color output}
  (pixel_ptr+bmp_dst_width+1)^:=RGB(r_,g_,b_);
end; {$endregion}
procedure BlurGGGDec     (pixel_ptr:PInteger; bmp_dst_width:TColor;                    constref alpha_fade:byte                                        );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2   : TColor;
  v0,v1,v2,v3: TColor;
  r_,g_,b_   : byte;
begin
  v0  :=     ((pixel_ptr+0                 )^);
  v1  :=     ((pixel_ptr+2                 )^);
  v2  :=     ((pixel_ptr+bmp_dst_width<<1  )^);
  v3  :=     ((pixel_ptr+bmp_dst_width<<1+2)^);
  r_  :=Red  ((pixel_ptr+bmp_dst_width   +1)^);
  g_  :=Green((pixel_ptr+bmp_dst_width   +1)^);
  b_  :=Blue ((pixel_ptr+bmp_dst_width   +1)^);
  m1  :=(Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08))>>2;
  m0  :=m1;
  m2  :=m1;
  {Red}
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  {Green}
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  {Blue}
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  {Color output}
  (pixel_ptr+bmp_dst_width+1)^:=RGB(r_,g_,b_);
end; {$endregion}
procedure BlurBBBDec     (pixel_ptr:PInteger; bmp_dst_width:TColor;                    constref alpha_fade:byte                                        );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2   : TColor;
  v0,v1,v2,v3: TColor;
  r_,g_,b_   : byte;
begin
  v0  :=     ((pixel_ptr+0                 )^);
  v1  :=     ((pixel_ptr+2                 )^);
  v2  :=     ((pixel_ptr+bmp_dst_width<<1  )^);
  v3  :=     ((pixel_ptr+bmp_dst_width<<1+2)^);
  r_  :=Red  ((pixel_ptr+bmp_dst_width   +1)^);
  g_  :=Green((pixel_ptr+bmp_dst_width   +1)^);
  b_  :=Blue ((pixel_ptr+bmp_dst_width   +1)^);
  m2  :=(Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16)+Byte(    (v3)>>16))>>2;
  m0  :=m2;
  m1  :=m2;
  {Red}
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  {Green}
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  {Blue}
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  {Color output}
  (pixel_ptr+bmp_dst_width+1)^:=RGB(r_,g_,b_);
end; {$endregion}
function  ContrastDec    (pixel_ptr:PInteger; constref r,g,b:byte;                     constref alpha_fade:byte; constref pow:integer                  ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2: TColor;
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(pixel_ptr^).r;
  g_  :=TRGBA(pixel_ptr^).g;
  b_  :=TRGBA(pixel_ptr^).b;
  m0  :=Limit(r+((r_-r)*pow)>>16);
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  m1  :=Limit(g+((g_-g)*pow)>>16);
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  m2  :=Limit(b+((b_-b)*pow)>>16);
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  Result:=RGB{ToColor}(r_,g_,b_);
end; {$endregion}
function  ContrastDecA   (dst_pix,src_pix:TColor;                                      constref alpha_fade:byte; constref pow:integer                  ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2: TColor;
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(dst_pix).r;
  g_  :=TRGBA(dst_pix).g;
  b_  :=TRGBA(dst_pix).b;
  m0  :=Limit(TRGBA(src_pix).r+((r_-TRGBA(src_pix).r)*pow)>>16);
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  m1  :=Limit(TRGBA(src_pix).g+((g_-TRGBA(src_pix).g)*pow)>>16);
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  m2  :=Limit(TRGBA(src_pix).b+((b_-TRGBA(src_pix).b)*pow)>>16);
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  Result:=RGB{ToColor}(r_,g_,b_);
end; {$endregion}
function  ContrastDecB   (dst_pix,src_pix:TColor;                                      constref alpha_fade:byte; constref pow:integer                  ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2: TColor;
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(dst_pix).r;
  g_  :=TRGBA(dst_pix).g;
  b_  :=TRGBA(dst_pix).b;
  m0  :=Limit(TRGBA(src_pix).b+((r_-TRGBA(src_pix).b)*pow)>>16);
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  m1  :=Limit(TRGBA(src_pix).g+((g_-TRGBA(src_pix).g)*pow)>>16);
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  m2  :=Limit(TRGBA(src_pix).r+((b_-TRGBA(src_pix).r)*pow)>>16);
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  Result:=RGB{ToColor}(r_,g_,b_);
end; {$endregion}

{$endregion}



(***************************** Some Basic Routines ****************************) {$region -fold}

// (Set Point) Установить точку:
function PtPos (constref pt:TPtPosF         ): TPtPos;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=Trunc(pt.x);
  Result.y:=Trunc(pt.y);
end; {$endregion}
function PtPos (constref pos_x,pos_y:integer): TPtPos;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=pos_x;
  Result.y:=pos_y;
end; {$endregion}
function PtPos (constref pos_x,pos_y:double ): TPtPos;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=Trunc(pos_x);
  Result.y:=Trunc(pos_y);
end; {$endregion}
function PtPos2(constref pt:TPtPosF         ): TPtPos2; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=Trunc(pt.x);
  Result.y:=Trunc(pt.y);
end; {$endregion}
function PtPos2(constref pos_x,pos_y:TColor ): TPtPos2; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=pos_x;
  Result.y:=pos_y;
end; {$endregion}
function PtPos2(constref pos_x,pos_y:double ): TPtPos2; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=Trunc(pos_x);
  Result.y:=Trunc(pos_y);
end; {$endregion}
function PtPosF(constref pt:TPtPos          ): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=pt.x;
  Result.y:=pt.y;
end; {$endregion}
function PtPosF(constref pos_x,pos_y:double ): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=pos_x;
  Result.y:=pos_y;
end; {$endregion}
function PtPosF(constref pos_x,pos_y:integer): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=pos_x;
  Result.y:=pos_y;
end; {$endregion}
function PtPosF(constref pt:TPtPos2         ): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=pt.x;
  Result.y:=pt.y;
end; {$endregion}
// (Set Line) Установить линию:
function GetLnC(constref vec:TLnPosF        ): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      x:=(vec.y1-vec.y0)/
         (vec.x1-vec.x0);
      y:= vec.y1-vec.x1*x;
    end;
end; {$endregion}
function LnPos (constref vec:TLnPosF        ): TLnPos;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      x0:=Trunc(vec.x0);
      y0:=Trunc(vec.y0);
      x1:=Trunc(vec.x1);
      y1:=Trunc(vec.y1);
    end;
end; {$endregion}
function LnPos (constref x0,y0,x1,y1:integer): TLnPos;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x0:=x0;
  Result.y0:=y0;
  Result.x1:=x1;
  Result.y1:=y1;
end; {$endregion}
function LnPosF(constref vec:TLnPos         ): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      x0:=vec.x0;
      y0:=vec.y0;
      x1:=vec.x1;
      y1:=vec.y1;
    end;
end; {$endregion}
function LnPosF(constref x0,y0,x1,y1:double ): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x0:=x0;
  Result.y0:=y0;
  Result.x1:=x1;
  Result.y1:=y1;
end; {$endregion}
function LnPosF(constref x0,y0,x1,y1:integer): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x0:=x0;
  Result.y0:=y0;
  Result.x1:=x1;
  Result.y1:=y1;
end; {$endregion}
// (Bounding Rectangle of Points Set) Ограничиваюший прямоугольник множества точек:
function PtsRngRctCalc    (constref pts:TPtPosFArr; var rct_bnd_ind_arr  :TEnum2Arr; constref start_pts_ind:TColor=0; constref end_pts_ind:TColor=0): TRect;    {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr                                : PPtPosF;
  min_x,min_y,max_x,max_y                : double;
  ind_min_x,ind_min_y,ind_max_x,ind_max_y: integer;
  i                                      : integer;
begin

  {Misc. Precalc.-----------------} {$region -fold}
  Result:=Default(TRect);

  ind_min_x:=0;
  ind_min_y:=0;
  ind_max_x:=0;
  ind_max_y:=0;

  with pts[start_pts_ind] do
    begin
      min_x:=x;
      min_y:=y;
      max_x:=x;
      max_y:=y;
    end; {$endregion}

  {Calc. of Rectangle-------------} {$region -fold}
  pts_ptr:=Unaligned(@pts[start_pts_ind]);
  for i:=start_pts_ind to end_pts_ind do
    begin
      if ({Trunc(}pts_ptr^.x{)}<=min_x) then
        begin
          min_x    :={Trunc(}pts_ptr^.x{)};
          ind_min_x:=i;
        end;
      if ({Trunc(}pts_ptr^.y{)}<=min_y) then
        begin
          min_y    :={Trunc(}pts_ptr^.y{)};
          ind_min_y:=i;
        end;
      if ({Trunc(}pts_ptr^.x{)}>=max_x) then
        begin
          max_x    :={Trunc(}pts_ptr^.x{)};
          ind_max_x:=i;
        end;
      if ({Trunc(}pts_ptr^.y{)}>=max_y) then
        begin
          max_y    :={Trunc(}pts_ptr^.y{)};
          ind_max_y:=i;
        end;
      Inc(pts_ptr);
    end; {$endregion}

  {Set Rectangle------------------} {$region -fold}
  with Result do
    begin
      left  :=Trunc(pts[ind_min_x].x)+0;
      top   :=Trunc(pts[ind_min_y].y)+0;
      right :=Trunc(pts[ind_max_x].x)+1;
      bottom:=Trunc(pts[ind_max_y].y)+1;
      width :=right-left;
      height:=bottom-top;
    end; {$endregion}

  {Save Indices of Borders(Points)} {$region -fold}
  rct_bnd_ind_arr[0]:=ind_min_x;
  rct_bnd_ind_arr[1]:=ind_min_y;
  rct_bnd_ind_arr[2]:=ind_max_x;
  rct_bnd_ind_arr[3]:=ind_max_y; {$endregion}

end; {$endregion}
function PtsRngRctCalc2   (constref pts:TPtPosFArr; var rct_bnd_ind_arr  :TEnum2Arr; constref start_pts_ind:TColor=0; constref end_pts_ind:TColor=0): TPtRectF; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr                                : PPtPosF;
  min_x,min_y,max_x,max_y                : double;
  ind_min_x,ind_min_y,ind_max_x,ind_max_y: integer;
  i                                      : integer;
begin

  {Misc. Precalc.-----------------} {$region -fold}
  Result:=Default(TPtRectF);

  ind_min_x:=0;
  ind_min_y:=0;
  ind_max_x:=0;
  ind_max_y:=0;

  with pts[start_pts_ind] do
    begin
      min_x:=x;
      min_y:=y;
      max_x:=x;
      max_y:=y;
    end; {$endregion}

  {Calc. of Rectangle-------------} {$region -fold}
  pts_ptr:=Unaligned(@pts[start_pts_ind]);
  for i:=start_pts_ind to end_pts_ind do
    begin
      if (pts_ptr^.x<=min_x) then
        begin
          min_x    :=pts_ptr^.x;
          ind_min_x:=i;
        end;
      if (pts_ptr^.y<=min_y) then
        begin
          min_y    :=pts_ptr^.y;
          ind_min_y:=i;
        end;
      if (pts_ptr^.x>=max_x) then
        begin
          max_x    :=pts_ptr^.x;
          ind_max_x:=i;
        end;
      if (pts_ptr^.y>=max_y) then
        begin
          max_y    :=pts_ptr^.y;
          ind_max_y:=i;
        end;
      Inc(pts_ptr);
    end; {$endregion}

  {Set Rectangle------------------} {$region -fold}
  with Result do
    begin
      left  :=pts[ind_min_x].x+0;
      top   :=pts[ind_min_y].y+0;
      right :=pts[ind_max_x].x+1;
      bottom:=pts[ind_max_y].y+1;
      width :=right-left;
      height:=bottom-top;
    end; {$endregion}

  {Save Indices of Borders(Points)} {$region -fold}
  rct_bnd_ind_arr[0]:=ind_min_x;
  rct_bnd_ind_arr[1]:=ind_min_y;
  rct_bnd_ind_arr[2]:=ind_max_x;
  rct_bnd_ind_arr[3]:=ind_max_y; {$endregion}

end; {$endregion}
function PtsRngIndsRctCalc(constref pts:TPtPosFArr; constref sel_pts_inds:TColorArr; constref pts_cnt:TColor                                       ): TRect;    {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr                                : PPtPosF;
  sel_pts_inds_ptr                       : PInteger;
  min_x,min_y,max_x,max_y                : double;
  ind_min_x,ind_min_y,ind_max_x,ind_max_y: integer;
  i                                      : integer;
begin

  {Misc. Precalc.----} {$region -fold}
  Result:=Default(TRect);

  ind_min_x:=0;
  ind_min_y:=0;
  ind_max_x:=0;
  ind_max_y:=0;

  with pts[sel_pts_inds[0]] do
    begin
      min_x:=x;
      min_y:=y;
      max_x:=x;
      max_y:=y;
    end; {$endregion}

  {Calc. of Rectangle} {$region -fold}
  pts_ptr         :=Unaligned(@pts         [0]);
  sel_pts_inds_ptr:=Unaligned(@sel_pts_inds[0]);
  for i:=0 to pts_cnt-1 do
    begin
      if ((pts_ptr+sel_pts_inds_ptr^)^.x<=min_x) then
        begin
          min_x    :=(pts_ptr+sel_pts_inds_ptr^)^.x;
          ind_min_x:=sel_pts_inds_ptr^;
        end;
      if ((pts_ptr+sel_pts_inds_ptr^)^.y<=min_y) then
        begin
          min_y    :=(pts_ptr+sel_pts_inds_ptr^)^.y;
          ind_min_y:=sel_pts_inds_ptr^;
        end;
      if ((pts_ptr+sel_pts_inds_ptr^)^.x>=max_x) then
        begin
          max_x    :=(pts_ptr+sel_pts_inds_ptr^)^.x;
          ind_max_x:=sel_pts_inds_ptr^;
        end;
      if ((pts_ptr+sel_pts_inds_ptr^)^.y>=max_y) then
        begin
          max_y    :=(pts_ptr+sel_pts_inds_ptr^)^.y;
          ind_max_y:=sel_pts_inds_ptr^;
        end;
      Inc(sel_pts_inds_ptr);
    end; {$endregion}

  {Set Rectangle-----} {$region -fold}
  with Result do
    begin
      left  :=Trunc(pts[ind_min_x].x)+0;
      top   :=Trunc(pts[ind_min_y].y)+0;
      right :=Trunc(pts[ind_max_x].x)+1;
      bottom:=Trunc(pts[ind_max_y].y)+1;
      width :=right-left;
      height:=bottom-top;
    end; {$endregion}

end; {$endregion}
// (Set Rectangle) Установить прямоугольник:
procedure PtRct   (constref pts:TPtPosFArr; constref rct_bnd_ind_arr:TEnum2Arr; var rct:TRect   ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct do
    begin
      left  :=Trunc(pts[rct_bnd_ind_arr[0]].x)+0;
      top   :=Trunc(pts[rct_bnd_ind_arr[1]].y)+0;
      right :=Trunc(pts[rct_bnd_ind_arr[2]].x)+1;
      bottom:=Trunc(pts[rct_bnd_ind_arr[3]].y)+1;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
procedure PtRctF  (constref pts:TPtPosFArr; constref rct_bnd_ind_arr:TEnum2Arr; var rct:TPtRectF); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct do
    begin
      left  :=pts[rct_bnd_ind_arr[0]].x+0;
      top   :=pts[rct_bnd_ind_arr[1]].y+0;
      right :=pts[rct_bnd_ind_arr[2]].x+1;
      bottom:=pts[rct_bnd_ind_arr[3]].y+1;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function PtRctB   (constref rct_left,rct_top,rct_right,rct_bottom:integer): TPtRectB;              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=Default(TPtrectB);
  with Result.pt_rct do
    begin
      left  :=rct_left  ;
      top   :=rct_top   ;
      right :=rct_right ;
      bottom:=rct_bottom;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function PtRct    (constref rct_left,rct_top,rct_right,rct_bottom:integer): TPtRect;               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct_left  ;
      top   :=rct_top   ;
      right :=rct_right ;
      bottom:=rct_bottom;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function PtRct    (constref rct:TRect                                    ): TPtRect;               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct.left  ;
      top   :=rct.top   ;
      right :=rct.right ;
      bottom:=rct.bottom;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function PtRct    (constref rct:TPtRectF                                 ): TPtRect;               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=Trunc(rct.left  );
      top   :=Trunc(rct.top   );
      right :=Trunc(rct.right );
      bottom:=Trunc(rct.bottom);
      width :=right -left;
      height:=bottom-top ;
    end;
end; {$endregion}
function PtRct    (constref rct:TPtPosFArr                               ): TPtRect;               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=Trunc(rct[0].x);
      top   :=Trunc(rct[0].y);
      right :=Trunc(rct[1].x);
      bottom:=Trunc(rct[1].y);
      width :=right -left;
      height:=bottom-top ;
    end;
end; {$endregion}
function PtBounds (constref rct_left,rct_top,rct_width,rct_height:integer): TPtRect;               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct_left  ;
      top   :=rct_top   ;
      width :=rct_width ;
      height:=rct_height;
      right :=left+width;
      bottom:=top+height;
    end;
end; {$endregion}
function PtBounds (constref rct:TRect                                    ): TPtRect;               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct.left  ;
      top   :=rct.top   ;
      width :=rct.width ;
      height:=rct.height;
      right :=left+width;
      bottom:=top+height;
    end;
end; {$endregion}
function PtBoundsF(constref rct_left,rct_top,rct_width,rct_height:integer): TPtRectF;              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct_left  ;
      top   :=rct_top   ;
      width :=rct_width ;
      height:=rct_height;
      right :=left+width;
      bottom:=top+height;
    end;
end; {$endregion}
// (Inner Clipped Rectangle) Внутренний обрезанный прямоугольник:
function ClippedRctB(constref out_rct,                  inn_rct:TPtRect; var b           :byte           ): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b0,b1,b2,b3: boolean;
begin
  b0:=(out_rct.left  <=inn_rct.left  );
  b1:=(out_rct.top   <=inn_rct.top   );
  b2:=(out_rct.right >=inn_rct.right );
  b3:=(out_rct.bottom>=inn_rct.bottom);
  {Inner Rectangle Is In Outer Rectangle}
  if (b0 and b1 and b2 and b3) then
    begin
      Result:=inn_rct;
      b     :=0;
      Exit;
    end
  else
  {Inner Rectangle Is Out Of Outer Rectangle}
  if (out_rct.left  >=inn_rct.right ) or
     (out_rct.top   >=inn_rct.bottom) or
     (out_rct.right <=inn_rct.left  ) or
     (out_rct.bottom<=inn_rct.top   ) then
    begin
      Result:=Default(TPtRect);
      b     :=2;
      Exit;
    end
  else
  {Inner Rectangle Is Clipped By Outer Rectangle}
  with Result do
    begin
      b:=1;
      if b0 then
        left  :=inn_rct.left
      else
        left  :=out_rct.left;
      if b1 then
        top   :=inn_rct.top
      else
        top   :=out_rct.top;
      if b2 then
        right :=inn_rct.right
      else
        right :=out_rct.right;
      if b3 then
        bottom:=inn_rct.bottom
      else
        bottom:=out_rct.bottom;
      width   :=right -left;
      height  :=bottom-top;
    end;
end; {$endregion}
function ClippedRctB(constref out_rct,                  inn_rct:TPtRect                                  ): TPtRectB; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      b_left  :=(out_rct.left  >=inn_rct.left  );
      b_top   :=(out_rct.top   >=inn_rct.top   );
      b_right :=(out_rct.right <=inn_rct.right );
      b_bottom:=(out_rct.bottom<=inn_rct.bottom);
      with pt_rct do
        begin
          if b_left then
            left  :=out_rct.left
          else
            left  :=inn_rct.left;
          if b_top then
            top   :=out_rct.top
          else
            top   :=inn_rct.top;
          if b_right then
            right :=out_rct.right
          else
            right :=inn_rct.right;
          if b_bottom then
            bottom:=out_rct.bottom
          else
            bottom:=inn_rct.bottom;
          width :=right -left;
          height:=bottom-top;
        end;
    end;
end; {$endregion}
function ClippedRct (constref out_rct,mrg_rct,          inn_rct:TPtRect; var pix_clp_type:byte           ): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  clp_arr: array[0..3] of boolean;
  mrg_arr: array[0..3] of boolean;
  clp    : longword absolute clp_arr;
  mrg    : longword absolute mrg_arr;
begin
  with Result do
    begin
      if IsRct1OutOfRct2(inn_rct,out_rct) then
        begin
          pix_clp_type:=3;
          Exit;
        end;
      clp_arr[0]:=(out_rct.left  >=inn_rct.left  );
      clp_arr[1]:=(out_rct.top   >=inn_rct.top   );
      clp_arr[2]:=(out_rct.right <=inn_rct.right );
      clp_arr[3]:=(out_rct.bottom<=inn_rct.bottom);
      mrg_arr[0]:=(mrg_rct.left  <>00000000000000);
      mrg_arr[1]:=(mrg_rct.top   <>00000000000000);
      mrg_arr[2]:=(mrg_rct.right <>00000000000000);
      mrg_arr[3]:=(mrg_rct.bottom<>00000000000000);
      //PLongWord(@b_left)^:=clp;
      {l.b. - last bit}
      case clp of
        {No Clip----------------------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        0       {%00000000000000000000000000000000}: {$region -fold}
          begin
            left  :=inn_rct.left;
            top   :=inn_rct.top;
            right :=inn_rct.right;
            bottom:=inn_rct.bottom;
            width :=right -left;
            height:=bottom-top;
            case mrg of
                      { l.b.    l.b.    l.b.    l.b.    }
              0       {%00000000000000000000000000000000}: {$region -fold}
                begin
                  pix_clp_type:=0;
                  Exit;
                end; {$endregion}
                      { l.b.    l.b.    l.b.    l.b.    }
              256     {%00000000000000000000000100000000},
              16777216{%00000001000000000000000000000000},
              16777472{%00000001000000000000000100000000}: {$region -fold}
                begin
                  pix_clp_type:=1;
                  Exit;
                end; {$endregion}
              otherwise                                    {$region -fold}
                begin
                  pix_clp_type:=2;
                  Exit;
                end; {$endregion}
            end;
          end; {$endregion}
        {Top-Clipped------------------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        256     {%00000000000000000000000100000000},
        {Bottom-Clipped---------------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        16777216{%00000001000000000000000000000000},
        {Top-Bottom-Clipped-----------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        16777472{%00000001000000000000000100000000}: {$region -fold}
          begin
            left  :=inn_rct.left;
            top   :=Max(out_rct.top,inn_rct.top);
            right :=inn_rct.right;
            bottom:=Min(out_rct.bottom,inn_rct.bottom);
            width :=right -left;
            height:=bottom-top;
            case mrg of
                { l.b.    l.b.    l.b.    l.b.    }
              0       {%00000000000000000000000000000000},
              256     {%00000000000000000000000100000000},
              16777216{%00000001000000000000000000000000},
              16777472{%00000001000000000000000100000000}: {$region -fold}
                begin
                  pix_clp_type:=1;
                  Exit;
                end; {$endregion}
              otherwise                                    {$region -fold}
                begin
                  pix_clp_type:=2;
                  Exit;
                end; {$endregion}
            end;
          end; {$endregion}
        otherwise                                    {$region -fold}
       {{Left-Clipped-----------------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        1       {%00000000000000000000000000000001},
        {Left-Top-Clipped-------------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        257     {%00000000000000000000000100000001},
        {Left-Bottom-Clipped----------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        16777217{%00000001000000000000000000000001},
        {Top-Left-Bottom-Clipped------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        16777473{%00000001000000000000000100000001},
        {Right-Clipped----------------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        65536   {%00000000000000010000000000000000},
        {Right-Top-Clipped------------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        65792   {%00000000000000010000000100000000},
        {Right-Bottom-Clipped---------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        16842752{%00000001000000010000000000000000},
        {Top-Right-Bottom-Clipped-----------------}
                { l.b.    l.b.    l.b.    l.b.    }
        16843008{%00000001000000010000000100000000},
        {Left-Top-Right-Clipped-------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        65793   {%00000000000000010000000100000001},
        {Left-Bottom-Right-Clipped----------------}
                { l.b.    l.b.    l.b.    l.b.    }
        16842753{%00000001000000010000000000000001},
        {Left-Right-Clipped-----------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        65537   {%00000000000000010000000000000001},
        {Left-Top-Right-Bottom-Clipped------------}
                { l.b.    l.b.    l.b.    l.b.    }
        16843009{%00000001000000010000000100000001}:}
          begin
            left        :=Max(out_rct.left  ,inn_rct.left  );
            top         :=Max(out_rct.top   ,inn_rct.top   );
            right       :=Min(out_rct.right ,inn_rct.right );
            bottom      :=Min(out_rct.bottom,inn_rct.bottom);
            width       :=right -left;
            height      :=bottom-top;
            pix_clp_type:=2;
          end; {$endregion}
      end;
    end;
end; {$endregion}
function ClippedRct (constref out_rct,                  inn_rct:TPtRect                                  ): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (out_rct.left  >=inn_rct.left  ) then
        left  :=out_rct.left
      else
        left  :=inn_rct.left;
      if (out_rct.top   >=inn_rct.top   ) then
        top   :=out_rct.top
      else
        top   :=inn_rct.top;
      if (out_rct.right <=inn_rct.right ) then
        right :=out_rct.right
      else
        right :=inn_rct.right;
      if (out_rct.bottom<=inn_rct.bottom) then
        bottom:=out_rct.bottom
      else
        bottom:=inn_rct.bottom;
      if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedRct (constref out_rct:TPtRect; constref inn_rct:TPtRectF                                 ): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (out_rct.left  >=inn_rct.left  ) then
        left  :=Trunc(out_rct.left)
      else
        left  :=Trunc(inn_rct.left);
      if (out_rct.top   >=inn_rct.top   ) then
        top   :=Trunc(out_rct.top)
      else
        top   :=Trunc(inn_rct.top);
      if (out_rct.right <=inn_rct.right ) then
        right :=Trunc(out_rct.right)
      else
        right :=Trunc(inn_rct.right);
      if (out_rct.bottom<=inn_rct.bottom) then
        bottom:=Trunc(out_rct.bottom)
      else
        bottom:=Trunc(inn_rct.bottom);
      if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedRct (constref out_rct,                  inn_rct:TRect                                    ): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (out_rct.left  >=inn_rct.left  ) then
        left  :=out_rct.left
      else
        left  :=inn_rct.left;
      if (out_rct.top   >=inn_rct.top   ) then
        top   :=out_rct.top
      else
        top   :=inn_rct.top;
      if (out_rct.right <=inn_rct.right ) then
        right :=out_rct.right
      else
        right :=inn_rct.right;
      if (out_rct.bottom<=inn_rct.bottom) then
        bottom:=out_rct.bottom
      else
        bottom:=inn_rct.bottom;
      if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedRct (constref out_rct:TPtRect; constref inn_rct:TRect                                    ): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (out_rct.left  >=inn_rct.left  ) then
        left  :=out_rct.left
      else
        left  :=inn_rct.left;
      if (out_rct.top   >=inn_rct.top   ) then
        top   :=out_rct.top
      else
        top   :=inn_rct.top;
      if (out_rct.right <=inn_rct.right ) then
        right :=out_rct.right
      else
        right :=inn_rct.right;
      if (out_rct.bottom<=inn_rct.bottom) then
        bottom:=out_rct.bottom
      else
        bottom:=inn_rct.bottom;
      if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedRct (constref out_rct:TRect;   constref inn_rct:TPtRect                                  ): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (out_rct.left  >=inn_rct.left  ) then
        left  :=out_rct.left
      else
        left  :=Trunc(inn_rct.left);
      if (out_rct.top   >=inn_rct.top   ) then
        top   :=out_rct.top
      else
        top   :=Trunc(inn_rct.top);
      if (out_rct.right <=inn_rct.right ) then
        right :=out_rct.right
      else
        right :=Trunc(inn_rct.right);
      if (out_rct.bottom<=inn_rct.bottom) then
        bottom:=out_rct.bottom
      else
        bottom:=Trunc(inn_rct.bottom);
      if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedRct (constref out_rct:TRect;   constref inn_rct:TPtRectF                                 ): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (out_rct.left  >=inn_rct.left  ) then
        left  :=out_rct.left
      else
        left  :=Trunc(inn_rct.left);
      if (out_rct.top   >=inn_rct.top   ) then
        top   :=out_rct.top
      else
        top   :=Trunc(inn_rct.top);
      if (out_rct.right <=inn_rct.right ) then
        right :=out_rct.right
      else
        right :=Trunc(inn_rct.right);
      if (out_rct.bottom<=inn_rct.bottom) then
        bottom:=out_rct.bottom
      else
        bottom:=Trunc(inn_rct.bottom);
      if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedRct (constref out_rct:TPtRect; constref inn_rct:TRect; b:boolean                         ): TRect;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (out_rct.left  >=inn_rct.left  ) then
        left  :=out_rct.left
      else
        left  :=inn_rct.left;
      if (out_rct.top   >=inn_rct.top   ) then
        top   :=out_rct.top
      else
        top   :=inn_rct.top;
      if (out_rct.right <=inn_rct.right ) then
        right :=out_rct.right
      else
        right :=inn_rct.right;
      if (out_rct.bottom<=inn_rct.bottom) then
        bottom:=out_rct.bottom
      else
        bottom:=inn_rct.bottom;
      if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedRct (constref out_rct,                  inn_rct:TRect; b:boolean                         ): TRect;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (out_rct.left  >=inn_rct.left  ) then
        left  :=out_rct.left
      else
        left  :=inn_rct.left;
      if (out_rct.top   >=inn_rct.top   ) then
        top   :=out_rct.top
      else
        top   :=inn_rct.top;
      if (out_rct.right <=inn_rct.right ) then
        right :=out_rct.right
      else
        right :=inn_rct.right;
      if (out_rct.bottom<=inn_rct.bottom) then
        bottom:=out_rct.bottom
      else
        bottom:=inn_rct.bottom;
      if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedArr (constref rct_src:TPtRect; constref rct_dst:TPtRectB; constref arr_src_width:longword): integer;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b_coll_arr   : array[0..3] of boolean;
  b_coll       : longword absolute b_coll_arr;
begin
  Result:=0;
  b_coll_arr[0]:=rct_dst.b_left  ;
  b_coll_arr[1]:=rct_dst.b_top   ;
  b_coll_arr[2]:=rct_dst.b_right ;
  b_coll_arr[3]:=rct_dst.b_bottom;
  case b_coll of
    {No Clip--------------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    0       {%00000000000000000000000000000000},
    {Left-Clipped---------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    1       {%00000000000000000000000000000001},
    {Top-Clipped----------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    256     {%00000000000000000000000100000000},
    {Bottom-Clipped-------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16777216{%00000001000000000000000000000000},
    {Left-Top-Clipped-----------------}
             { |e.b.   |e.b.   |e.b.   |e.b.   }
    257     {%00000000000000000000000100000001},
    {Left-Bottom-Clipped--------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16777217{%00000001000000000000000000000001},
    {Top-Bottom-Clipped---------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16777472{%00000001000000000000000100000000},
    {Top-Left-Bottom-Clipped----------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16777473{%00000001000000000000000100000001}:
      Result:=rct_src.left;
    {Right-Clipped--------------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    65536   {%00000000000000010000000000000000},
    {Right-Top-Clipped----------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    65792   {%00000000000000010000000100000000},
    {Right-Bottom-Clipped-------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16842752{%00000001000000010000000000000000},
    {Top-Right-Bottom-Clipped---------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16843008{%00000001000000010000000100000000},
    {Left-Top-Right-Clipped-----------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    65793   {%00000000000000010000000100000001},
    {Left-Bottom-Right-Clipped--------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16842753{%00000001000000010000000000000001},
    {Left-Right-Clipped---------------}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    65537   {%00000000000000010000000000000001},
    {Left-Top-Right-Bottom-Clipped----}
            { |e.b.   |e.b.   |e.b.   |e.b.   }
    16843009{%00000001000000010000000100000001}:
      Result:=arr_src_width-rct_src.width;
  end;
end; {$endregion}
// (Find Rectangle with Not Coprime Width and Height(GCD(src_rect.Width,src_rect.Height)<>1) for source rectangle src_rect) Находит прямоугольник с не взаимно простыми сторонами(GCD(src_rect.Width,src_rect.Height)<>1) для исходного прямоугольника src_rect:
function NCSRectCalc(constref rct_src:TRect   ; constref bucket_width,bucket_heigth:integer): TRect   ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct_src.left;
      top   :=rct_src.top ;
      width :=(Trunc(rct_src.width /bucket_width )+1)*bucket_width ;
      height:=(Trunc(rct_src.height/bucket_heigth)+1)*bucket_heigth;
      right :=left+width;
      bottom:=top+height;
    end;
end; {$endregion}
function NCSRectCalc(constref rct_src:TPtRectF; constref bucket_width,bucket_heigth:integer): TPtRectF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct_src.left;
      top   :=rct_src.top ;
      width :=(Trunc(rct_src.width /bucket_width )+1)*bucket_width ;
      height:=(Trunc(rct_src.height/bucket_heigth)+1)*bucket_heigth;
      right :=left+width;
      bottom:=top+height;
    end;
end; {$endregion}
// (Two Rectangles Bounding Rectangle 1) Ограничивающий прямоугольник для двух заданных прямоугольников:
function TwoRctsBoundingRct(constref rct1,rct2:TRect  ): TRect;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=Min2(rct1.left  ,rct2.left  );
      top   :=Min2(rct1.top   ,rct2.top   );
      right :=Max2(rct1.right ,rct2.right );
      bottom:=Max2(rct1.bottom,rct2.bottom);
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function TwoRctsBoundingRct(constref rct1,rct2:TPtRect): TPtRect; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=Min2(rct1.left  ,rct2.left  );
      top   :=Min2(rct1.top   ,rct2.top   );
      right :=Max2(rct1.right ,rct2.right );
      bottom:=Max2(rct1.bottom,rct2.bottom);
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
// (Rectangle in Rectangle) Прямоугольник в прямоугольнике:
function IsRct1InRct2(constref rct1,                rct2:TRect  ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.left  >=rct2.left  ) and
          (rct1.top   >=rct2.top   ) and
          (rct1.right <=rct2.right ) and
          (rct1.bottom<=rct2.bottom);
end; {$endregion}
function IsRct1InRct2(constref rct1,                rct2:TPtRect): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.left  >=rct2.left  ) and
          (rct1.top   >=rct2.top   ) and
          (rct1.right <=rct2.right ) and
          (rct1.bottom<=rct2.bottom);
end; {$endregion}
function IsRct1InRct2(constref rct1:TRect; constref rct2:TPtRect): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.left  >=rct2.left  ) and
          (rct1.top   >=rct2.top   ) and
          (rct1.right <=rct2.right ) and
          (rct1.bottom<=rct2.bottom);
end; {$endregion}
// (Rectangle out of Rectangle) Прямоугольник вне прямоугольника:
function IsRct1OutOfRct2(constref rct1,                   rct2:TRect  ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.right <=rct2.left  ) or
          (rct1.bottom<=rct2.top   ) or
          (rct1.left  >=rct2.right ) or
          (rct1.top   >=rct2.bottom);
end; {$endregion}
function IsRct1OutOfRct2(constref rct1,                   rct2:TPtRect): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.right <=rct2.left  ) or
          (rct1.bottom<=rct2.top   ) or
          (rct1.left  >=rct2.right ) or
          (rct1.top   >=rct2.bottom);
end; {$endregion}
function IsRct1OutOfRct2(constref rct1:TRect   ; constref rct2:TPtRect): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.right <=rct2.left  ) or
          (rct1.bottom<=rct2.top   ) or
          (rct1.left  >=rct2.right ) or
          (rct1.top   >=rct2.bottom);
end; {$endregion}
function IsRct1OutOfRct2(constref rct1:TPtRectF; constref rct2:TPtRect): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.right <=rct2.left  ) or
          (rct1.bottom<=rct2.top   ) or
          (rct1.left  >=rct2.right ) or
          (rct1.top   >=rct2.bottom);
end; {$endregion}
// (Line Bounding Rectangle) Ограничивающий линию прямоугольник:
function LineBndRct(constref x0,y0,x1,y1,ln_width:integer): TPtRect; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_width2: integer;
begin
  ln_width2:=ln_width>>1;
  with Result do
    begin
      if (x0=x1) then
        begin
          left :=x0-ln_width2;
          right:=x0+ln_width2;
        end
      else
      if (x0<x1) then
        begin
          left :=x0-ln_width2;
          right:=x1+ln_width2;
        end
      else
        begin
          left :=x1-ln_width2;
          right:=x0+ln_width2;
        end;
      if (y0=y1) then
        begin
          top   :=y0-ln_width2;
          bottom:=y0+ln_width2;
        end
      else
      if (y0<y1) then
        begin
          top   :=y0-ln_width2;
          bottom:=y1+ln_width2;
        end
      else
        begin
          top   :=y1-ln_width2;
          bottom:=y0+ln_width2;
        end;
    end;
end; {$endregion}
// (Point in Rectangle) Точка в прямоугольнике:
function IsPtInRct(constref x,y,rct_dst_left,rct_dst_top,rct_dst_right,rct_dst_bottom:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct_dst_left  <=x) and
          (rct_dst_top   <=y) and
          (rct_dst_right > x) and
          (rct_dst_bottom> y);
end; {$endregion}
function IsPtInRct(constref x,y:integer; constref rct_dst:TRect                              ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct_dst.left  <=x) and
          (rct_dst.top   <=y) and
          (rct_dst.right > x) and
          (rct_dst.bottom> y);
end; {$endregion}
function IsPtInRct(constref x,y:integer; constref rct_dst:TPtRect                            ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct_dst.left  <=x) and
          (rct_dst.top   <=y) and
          (rct_dst.right > x) and
          (rct_dst.bottom> y);
end; {$endregion}
function IsPtInRct(constref x,y:double ; constref rct_dst:TPtRect                            ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct_dst.left  <=x) and
          (rct_dst.top   <=y) and
          (rct_dst.right > x) and
          (rct_dst.bottom> y);
end; {$endregion}
function IsPtInRct(constref pt:TPtPos  ; constref rct_dst:TRect                              ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with pt do
    Result:=(rct_dst.left  <=x) and
            (rct_dst.top   <=y) and
            (rct_dst.right > x) and
            (rct_dst.bottom> y);
end; {$endregion}
function IsPtInRct(constref pt:TPtPos  ; constref rct_dst:TPtRect                            ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with pt do
    Result:=(rct_dst.left  <=x) and
            (rct_dst.top   <=y) and
            (rct_dst.right > x) and
            (rct_dst.bottom> y);
end; {$endregion}
function IsPtInRct(constref pt:TPtPosF ; constref rct_dst:TRect                              ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with pt do
    Result:=(rct_dst.left  <=x) and
            (rct_dst.top   <=y) and
            (rct_dst.right > x) and
            (rct_dst.bottom> y);
end; {$endregion}
function IsPtInRct(constref pt:TPtPosF ; constref rct_dst:TPtRect                            ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with pt do
    Result:=(rct_dst.left  <=x) and
            (rct_dst.top   <=y) and
            (rct_dst.right > x) and
            (rct_dst.bottom> y);
end; {$endregion}
function IsPtInRct(constref pt:TPtPosF ; constref rct_dst:TPtRect; constref rad:integer      ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with pt do
    Result:=(rct_dst.left  <=x-rad) and
            (rct_dst.top   <=y-rad) and
            (rct_dst.right > x+rad) and
            (rct_dst.bottom> y+rad);
end; {$endregion}
// (Point in Circle) Точка в окружности:
function IsPtInCrc(constref x,y:integer; constref crc_dst          :TCrPos ; constref prec:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x-crc_dst.x)*(x-crc_dst.x)+(y-crc_dst.y)*(y-crc_dst.y)<=(crc_dst.r+prec)*(crc_dst.r+prec);
end; {$endregion}
function IsPtInCrc(constref x,y:integer; constref crc_dst          :TCrPosF; constref prec:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x-crc_dst.x)*(x-crc_dst.x)+(y-crc_dst.y)*(y-crc_dst.y)<=(crc_dst.r+prec)*(crc_dst.r+prec);
end; {$endregion}
function IsPtInCrc(constref x,y:double ; constref crc_dst          :TCrPosF; constref prec:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x-crc_dst.x)*(x-crc_dst.x)+(y-crc_dst.y)*(y-crc_dst.y)<=(crc_dst.r+prec)*(crc_dst.r+prec);
end; {$endregion}
function IsPtInCrc(constref x,y:double ; constref crc_x,crc_y,crc_r:integer; constref prec:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x-crc_x)*(x-crc_x)+(y-crc_y)*(y-crc_y)<=(crc_r+prec)*(crc_r+prec);
end; {$endregion}
function IsPtInCrc(constref x,y:integer; constref crc_x,crc_y,crc_r:integer; constref prec:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x-crc_x)*(x-crc_x)+(y-crc_y)*(y-crc_y)<=(crc_r+prec)*(crc_r+prec);
end; {$endregion}
// (Distance Between Two Points) Расстояние между двумя точками:
function PtDist   (constref x0,y0,x1,y1:integer): double ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=sqrt((x1-x0)*(x1-x0)+(y1-y0)*(y1-y0));
end; {$endregion}
function PtDist   (constref x0,y0,x1,y1:double ): double ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=sqrt((x1-x0)*(x1-x0)+(y1-y0)*(y1-y0));
end; {$endregion}
function PtDistSqr(constref x0,y0,x1,y1:integer): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x1-x0)*(x1-x0)+(y1-y0)*(y1-y0);
end; {$endregion}
function PtDistSqr(constref x0,y0,x1,y1:integer): double ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x1-x0)*(x1-x0)+(y1-y0)*(y1-y0);
end; {$endregion}
function PtDistSqr(constref x0,y0,x1,y1:double ): double ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x1-x0)*(x1-x0)+(y1-y0)*(y1-y0);
end; {$endregion}
// (Line-Line Intersection Point) Точка пересечения двух линий:
function LineLineIntPt(constref x0,y0,x1,y1,v0,w0,v1,w1:double):TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=-((x1-x0)*(v1*w0-v0*w1)-(v1-v0)*(x1*y0-x0*y1))/((x1-x0)*(w1-w0)-(v1-v0)*(y1-y0));
  Result.y:= ((y1-y0)*Result.x     +        (x1*y0-x0*y1))/ (x1-x0);
end; {$endregion}
// (Line-Circle Intersection Points) Точки пересечения линии и окружности:
function LineCrcIntPt(constref x0,y0,x1,y1:double ; constref crc_dst:TCrPosF): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  dx,dy,dz,b,g,s,one_div_dx,one_div_dz: double;
begin
  dx        :=x1-x0;
  dy        :=y1-y0;
  dz        :=sqr(dx)+sqr(dy);
  b         :=x1*y0-x0*y1;
  g         :=b-crc_dst.y*dx;
  s         :=sqrt(dz*sqr(crc_dst.r)-sqr(g+crc_dst.x*dy));
  one_div_dx:=1/dx;
  one_div_dz:=1/dz;
  Result.x0 :=one_div_dz*(-dy*g-s*dx+crc_dst.x*sqr(dx));
  Result.x1 :=one_div_dz*(-dy*g+s*dx+crc_dst.x*sqr(dx));
  Result.y0 :=one_div_dx*( dy*Result.x0+b );
  Result.y1 :=one_div_dx*( dy*Result.x1+b );
end; {$endregion}
function LineCrcIntPt(constref x0,y0,x1,y1:double ; constref x,y,r  :double ): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  dx,dy,dz,b,g,s,one_div_dx,one_div_dz: double;
begin
  dx        :=x1-x0;
  dy        :=y1-y0;
  dz        :=sqr(dx)+sqr(dy);
  b         :=x1*y0-x0*y1;
  g         :=b-y*dx;
  s         :=sqrt(dz*sqr(r)-sqr(g+x*dy));
  one_div_dx:=1/dx;
  one_div_dz:=1/dz;
  Result.x0 :=one_div_dz*(-dy*g-s*dx+x*sqr(dx));
  Result.x1 :=one_div_dz*(-dy*g+s*dx+x*sqr(dx));
  Result.y0 :=one_div_dx*( dy*Result.x0+b );
  Result.y1 :=one_div_dx*( dy*Result.x1+b );
end; {$endregion}
function LineCrcIntPt(constref x0,y0,x1,y1:integer; constref x,y,r,v:double ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=((sqr(x1-x0)+sqr(y1-y0))*sqr(r)-sqr(x1*y0-x0*y1+x*(y1-y0)-y*(x1-x0))>=0);
end; {$endregion}
function CrcPosF     (                              constref x,y,r  :double ): TCrPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=x;
  Result.y:=y;
  Result.r:=r;
end; {$endregion}
// (Circle-Circle Intersection) Пересечение двух окружностей:
function CrcCrcInt(constref x0,y0,r0,x1,y1,r1:double ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(sqr(r1+r0)<=sqr(x1-x0)+sqr(y1-y0));
end; {$endregion}
function CrcCrcInt(constref x0,y0,r0,x1,y1,r1:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(sqr(r1+r0)<=sqr(x1-x0)+sqr(y1-y0));
end; {$endregion}
function CrcCrcInt(constref crc0,crc1        :TCrPosF): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(sqr(crc1.r+crc0.r)<=sqr(crc1.x-crc0.x)+sqr(crc1.y-crc0.y));
end; {$endregion}
function CrcCrcInt(constref crc0,crc1        :TCrPos ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(sqr(crc1.r+crc0.r)<=sqr(crc1.x-crc0.x)+sqr(crc1.y-crc0.y));
end; {$endregion}
// (Rectangle-Circle Intersection) Пересечение прямоугольника и окружности:
function RctCrcInt(constref rct:TRect  ; constref x,y,r:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=False;
  if (rct.width =0) then
    Exit;
  if (rct.height=0) then
    Exit;
  with rct do
    Result:=IsPtInRct(x,y,left-r,top   ,right+r,bottom  ) or
            IsPtInRct(x,y,left  ,top-r ,right  ,bottom+r) or
            IsPtInCrc(x,y,left  ,top   ,r,0) or
            IsPtInCrc(x,y,left  ,bottom,r,0) or
            IsPtInCrc(x,y,right ,top   ,r,0) or
            IsPtInCrc(x,y,right ,bottom,r,0);
end; {$endregion}
function RctCrcInt(constref rct:TPtRect; constref x,y,r:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=False;
  if (rct.width =0) then
    Exit;
  if (rct.height=0) then
    Exit;
  with rct do
    Result:=IsPtInRct(x,y,left-r,top   ,right+r,bottom  ) or
            IsPtInRct(x,y,left  ,top-r ,right  ,bottom+r) or
            IsPtInCrc(x,y,left  ,top   ,r,0) or
            IsPtInCrc(x,y,left  ,bottom,r,0) or
            IsPtInCrc(x,y,right ,top   ,r,0) or
            IsPtInCrc(x,y,right ,bottom,r,0);
end; {$endregion}
// (Angle Between Two Connected Segments,(x1,y1) - Connection Point) Угол между двумя соединенными сегментами,(x1,y1) - точка соединения:
function Angle1(constref x0,y0,x1,y1,x2,y2:double): double; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=     ONE_DIV_BY_FULL_ROT*ArcCos(((x0-x1)*(x2-x1)+(y0-y1)*(y2-y1))/Sqrt((Sqr(x0-x1)+Sqr(y0-y1))*(Sqr(x2-x1)+Sqr(y2-y1))));
end; {$endregion}
function Angle2(constref x0,y0,x1,y1,x2,y2:double): double; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=180-(ONE_DIV_BY_FULL_ROT*ArcCos(((x0-x1)*(x2-x1)+(y0-y1)*(y2-y1))/Sqrt((Sqr(x0-x1)+Sqr(y0-y1))*(Sqr(x2-x1)+Sqr(y2-y1)))));
end; {$endregion}
// (Gauss's Area Formula) Формула площади Гаусса:
function GaussPolygonArea(pt_cnt:integer; first_pt_ptr       :PPtPosF): double; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  s1: double=0;
  s2: double=0;
  i : integer;
begin
  for i :=0 to pt_cnt-2 do
    s1  +=(first_pt_ptr+i+0)^.x*
          (first_pt_ptr+i+1)^.y;
  for i :=0 to pt_cnt-2 do
    s2  +=(first_pt_ptr+i+0)^.y*
          (first_pt_ptr+i+1)^.x;
  Result:=Abs(s1-s2+(first_pt_ptr+pt_cnt-1)^.x*
                    (first_pt_ptr+00000000)^.y-
                    (first_pt_ptr+pt_cnt-1)^.y*
                    (first_pt_ptr+00000000)^.x){/2};
end; {$endregion}
function GaussSumTrisArea(pt_cnt:integer; first_pt_ptr,pt_out:PPtPosF): double; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;

  function GaussTriArea(pt0,pt1,pt2:TPtPosF): double; {$region -fold}
  begin
    Result:=Abs(pt0.x*(pt1.y-pt2.y)+pt1.x*(pt2.y-pt0.y)+pt2.x*(pt0.y-pt1.y)){/2};
  end; {$endregion}

begin
  Result  :=0;
  for i   :=0 to pt_cnt-2 do
    Result+=GaussTriArea((first_pt_ptr+i+000000)^,(first_pt_ptr+i+1)^,pt_out^);
    Result+=GaussTriArea((first_pt_ptr+pt_cnt-1)^,(first_pt_ptr+000)^,pt_out^);
end; {$endregion}

{$endregion}



(******************************* Array Operation ******************************) {$region -fold}

// Arrays Addition:
procedure ArrAdd(constref arr_src1,arr_src2:T1Byte1Arr;                              var      arr_dst:TColorArr ; constref arr_dst_width,arr_dst_height:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PByte;
  arr_src2_ptr: PByte;
  arr_dst_ptr : PInteger;
  i,w_h_mul   : integer;
begin
  w_h_mul     :=arr_dst_width*arr_dst_height;
  SetLength(arr_dst,w_h_mul);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to w_h_mul-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^+arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrAdd(constref arr_src1,arr_src2:TDublArr  ;                              var      arr_dst:TDublArr  ; constref arr_dst_width,arr_dst_height:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PDouble;
  arr_src2_ptr: PDouble;
  arr_dst_ptr : PDouble;
  i,w_h_mul   : integer;
begin
  w_h_mul     :=arr_dst_width*arr_dst_height;
  SetLength(arr_dst,w_h_mul);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to w_h_mul-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^+arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrAdd(constref arr_src1,arr_src2:TColorArr ;                              var      arr_dst:TColorArr ; constref arr_dst_width,arr_dst_height:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PInteger;
  arr_src2_ptr: PInteger;
  arr_dst_ptr : PInteger;
  i,w_h_mul   : integer;
begin
  w_h_mul     :=arr_dst_width*arr_dst_height;
  SetLength(arr_dst,w_h_mul);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to w_h_mul-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^+arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrAdd(constref arr_src1,arr_src2:TWordArr  ;                              var      arr_dst:TWordArr  ; constref arr_dst_width,arr_dst_height:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PWord;
  arr_src2_ptr: PWord;
  arr_dst_ptr : PWord;
  i,w_h_mul   : integer;
begin
  w_h_mul     :=arr_dst_width*arr_dst_height;
  SetLength(arr_dst,w_h_mul);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to w_h_mul-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^+arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrAdd(constref arr_src1,arr_src2:T1Byte1Arr;                              var      arr_dst:T1Byte1Arr; constref arr_dst_width,arr_dst_height:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PByte;
  arr_src2_ptr: PByte;
  arr_dst_ptr : PByte;
  i,w_h_mul   : integer;
begin
  w_h_mul     :=arr_dst_width*arr_dst_height;
  SetLength(arr_dst,w_h_mul);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to w_h_mul-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^+arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrAdd(constref arr_src1         :TColorArr ; constref arr_src2:T1Byte1Arr;                             constref         width,        height:TColor; constref val:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PInteger;
  arr_src2_ptr: PByte;
  i           : integer;
begin
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  for i:=0 to width*height-1 do
    begin
      if (arr_src2_ptr^<>0) then
        arr_src1_ptr^+=val;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
    end;
end; {$endregion}
procedure ArrAdd(constref arr_src1         :T1Byte1Arr; constref arr_src2:T2ByteArr; constref arr_dst:TColorArr ; constref arr_dst_width,arr_dst_height:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
 {arr_dst_ptr : PInteger;
  arr_src1_ptr: PByte;
  arr_src2_ptr: PByte;}
 {ptr10,ptr11 : PInteger;
  ptr20,ptr21 : PByte;}
  x,y,v       : integer;
begin
  v:=0;
  for y:=0 to arr_dst_height-1 do
    begin
      for x:=0 to arr_dst_width-1 do
        arr_dst[x+v]:=arr_src1[x+v]+arr_src2[x,y];
      Inc(v,arr_dst_width);
    end;
 {for x:=0 to arr_dst_width-1 do
    begin
      arr_dst_ptr :=@arr_dst [x];
      arr_src1_ptr:=@arr_src1[x];
      arr_src2_ptr:=@arr_src2[x,0];
      for y:=0 to arr_dst_height-1 do
        begin
          arr_dst_ptr^:=arr_src1_ptr^+arr_src2_ptr^;
          Inc(arr_dst_ptr ,arr_dst_width);
          Inc(arr_src1_ptr,arr_dst_width);
          Inc(arr_src2_ptr);
        end;
    end;}
 {ptr11:=@arr_dst [0];
  ptr21:=@arr_src1[0];
  for x:=0 to arr_dst_width-1 do
    begin
      ptr10:=ptr11;
      ptr20:=ptr21;
      arr_src2_ptr:=@arr_src2[x,0];
      for y:=0 to arr_dst_height-1 do
        begin
          ptr10^:=ptr20^+arr_src2_ptr^;
          Inc(ptr10,arr_dst_width);
          Inc(ptr20,arr_dst_width);
          Inc(arr_src2_ptr);
        end;
      Inc(ptr11);
      Inc(ptr21);
    end;}
end; {$endregion}
procedure ArrAdd(constref arr_src1         :T1Byte1Arr; constref arr_src2:T2ByteArr; constref arr_dst:T1Byte1Arr; constref arr_dst_width,arr_dst_height:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,v: integer;
begin
  v:=0;
  Prefetch(arr_dst );
  Prefetch(arr_src1);
  Prefetch(arr_src2);
  for y:=0 to arr_dst_height-1 do
    begin
      for x:=0 to arr_dst_width-1 do
        arr_dst[x+v]:=arr_src1[x+v]+arr_src2[x,y];
      Inc(v,arr_dst_width);
    end;
end; {$endregion}
procedure ArrAdd(var      arr_src1         :T1Byte1Arr; constref arr_src2:T2ByteArr;                              constref arr_dst_width,arr_dst_height:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,v: integer;
begin
  v:=0;
  Prefetch(arr_src1);
  Prefetch(arr_src2);
  for y:=0 to arr_dst_height-1 do
    begin
      for x:=0 to arr_dst_width-1 do
        arr_src1[x+v]+=arr_src2[x,y];
      Inc(v,arr_dst_width);
    end;
end; {$endregion}
procedure ArrAdd(var      arr_src1         :T1Byte1Arr; constref arr_src2:T2ByteArr; constref rct_dst:TPtrect   ; constref arr_dst_width,arr_dst_height:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,v: integer;
begin
  v :=arr_dst_width*rct_dst.top;
  Prefetch(arr_src1);
  Prefetch(arr_src2);
  for y:=rct_dst.top to rct_dst.bottom-1 do
    begin
      for x:=rct_dst.left to rct_dst.right-1 do
        arr_src1[x+v]+=arr_src2[x,y];
      Inc(v,arr_dst_width);
    end;
end; {$endregion}
// Arrays Subtraction:
procedure ArrSub(constref arr_src1,arr_src2:TDublArr  ; var      arr_dst:TDublArr  ; constref arr_dst_width,arr_dst_height:TColor);      {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PDouble;
  arr_src2_ptr: PDouble;
  arr_dst_ptr : PDouble;
  i           : integer;
begin
  SetLength(arr_dst,arr_dst_width*arr_dst_height);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to arr_dst_width*arr_dst_height-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^-arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrSub(constref arr_src1,arr_src2:TIntrArr  ; var      arr_dst:TIntrArr  ; constref arr_dst_width,arr_dst_height:TColor);      {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PInteger;
  arr_src2_ptr: PInteger;
  arr_dst_ptr : PInteger;
  i           : integer;
begin
  SetLength(arr_dst,arr_dst_width*arr_dst_height);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to arr_dst_width*arr_dst_height-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^-arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrSub(constref arr_src1,arr_src2:TColorArr ; var      arr_dst:TColorArr ; constref arr_dst_width,arr_dst_height:TColor);      {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PLongWord;
  arr_src2_ptr: PLongWord;
  arr_dst_ptr : PLongWord;
  i           : integer;
begin
  SetLength(arr_dst,arr_dst_width*arr_dst_height);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to arr_dst_width*arr_dst_height-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^-arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrSub(constref arr_src1,arr_src2:TWordArr  ; var      arr_dst:TWordArr  ; constref arr_dst_width,arr_dst_height:TColor);      {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PWord;
  arr_src2_ptr: PWord;
  arr_dst_ptr : PWord;
  i           : integer;
begin
  SetLength(arr_dst,arr_dst_width*arr_dst_height);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to arr_dst_width*arr_dst_height-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^-arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrSub(constref arr_src1,arr_src2:T1Byte1Arr; var      arr_dst:T1Byte1Arr; constref arr_dst_width,arr_dst_height:TColor);      {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src1_ptr: PByte;
  arr_src2_ptr: PByte;
  arr_dst_ptr : PByte;
  i           : integer;
begin
  SetLength(arr_dst,arr_dst_width*arr_dst_height);
  arr_src1_ptr:=Unaligned(@arr_src1[0]);
  arr_src2_ptr:=Unaligned(@arr_src2[0]);
  arr_dst_ptr :=Unaligned(@arr_dst [0]);
  for i:=0 to arr_dst_width*arr_dst_height-1 do
    begin
      arr_dst_ptr^:=arr_src1_ptr^-arr_src2_ptr^;
      Inc(arr_src1_ptr);
      Inc(arr_src2_ptr);
      Inc(arr_dst_ptr );
    end;
end; {$endregion}
procedure ArrSub(constref arr_src          :T1Byte1Arr; constref arr_dst:TIntrArr  ; constref width,height:TColor; constref val:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_dst_ptr: PInteger;
  arr_src_ptr: PByte;
  i           : integer;
begin
  arr_dst_ptr:=Unaligned(@arr_dst[0]);
  arr_src_ptr:=Unaligned(@arr_src[0]);
  for i:=0 to width*height-1 do
    begin
      if (arr_src_ptr^<>0) then
        arr_dst_ptr^-=val;
      Inc(arr_dst_ptr);
      Inc(arr_src_ptr);
    end;
end; {$endregion}
// 2D Array to 1D Array:
procedure Arr2DTo1D(constref arr_src:T2ByteArr; var arr_dst:T1Byte1Arr; constref arr_src_width,arr_src_height:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr: PByte;
  arr_dst_ptr: PByte;
  x,y        : integer;
begin
  SetLength(arr_dst,arr_src_width*arr_src_height);
  for x:=0 to arr_src_width-1 do
    begin
      arr_src_ptr:=Unaligned(@arr_src[x,0]);
      arr_dst_ptr:=Unaligned(@arr_dst[x  ]);
      for y:=0 to arr_src_height-1 do
        begin
          arr_dst_ptr^:=arr_src_ptr^;
          Inc(arr_dst_ptr,arr_src_width);
          Inc(arr_src_ptr);
        end;
    end;
end; {$endregion}
// Clear Arrays:
procedure BmpClr(bmp:Graphics.TBitmap);                                                                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  //PatBlt(bmp.Canvas.Handle,0,0,bmp.width,bmp.height,WHITENESS);
  bmp.Canvas.Clear;
end; {$endregion}
procedure ArrClr(    arr1_ptr:PInteger;   constref rct_dst:TPtRect; constref arr_width:TColor; constref val:TColor=0); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to rct_dst.height-1 do
    begin
      FillByte(arr1_ptr^,rct_dst.width,val);
      Inc(arr1_ptr,arr_width);
    end;
end; {$endregion}
procedure ArrClr(var arr0    :T1Byte1Arr; constref rct_dst:TPtRect; constref arr_width:TColor; constref val:byte  =0); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p: PByte;
  i: integer;
begin
  p:=Unaligned(@arr0[rct_dst.left+arr_width*rct_dst.top]);
  for i:=0 to rct_dst.height-1 do
    begin
      FillByte(p^,rct_dst.width,val);
      Inc(p,arr_width);
    end;
end; {$endregion}
procedure ArrClr(var arr1    :TColorArr;  constref rct_dst:TPtRect; constref arr_width:TColor; constref val:TColor=0); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p: PInteger;
  i: integer;
begin
  p:=Unaligned(@arr1[rct_dst.left+arr_width*rct_dst.top]);
  for i:=0 to rct_dst.height-1 do
    begin
      FillDWord(p^,rct_dst.width,val);
      Inc(p,arr_width);
    end;
end; {$endregion}
procedure ArrClr(var arr1_ptr:PInteger;   constref rct_dst:TPtRect; constref arr_width:TColor; f1,f2,f3,f4:integer  ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p: PInteger;
  i: integer;
begin
  p:=Unaligned(@arr1_ptr[0{rct_dst.left+arr_width*rct_dst.top}]);
  for i:=0 to rct_dst.height-1 do
    begin
      FillDWord(p^,arr_width,0);
      Inc(p,arr_width);
    end;
end; {$endregion}
procedure ArrClr(var arr2    :T2ByteArr;  constref rct_dst:TPtRect;                            constref val:byte  =0); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to rct_dst.width-1 do
    FillByte(arr2[rct_dst.left+i,rct_dst.top],rct_dst.height,val);
end; {$endregion}
procedure ArrClr(var arr3    :TPtPos3Arr; constref rct_dst:TPtRect; constref arr_width:TColor                       ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p      : PPtPos3;
  i,j    : integer;
  d_width: integer;
begin
  d_width:=arr_width-rct_dst.width;
  p      :=Unaligned(@arr3[rct_dst.left+arr_width*rct_dst.top]);
  for j:=0 to rct_dst.height-1 do
    begin
      for i:=0 to rct_dst.width-1 do
        begin
          if (p^.obj_ind<>-1) then
            p^.SetEqual1(p^,Default(TPtPos3));
          Inc(p);
        end;
      Inc(p,d_width);
    end;
end; {$endregion}
// Clear Alpha Channel:
function  ArrClr(    arr1_ptr:PInteger;   constref rct_dst:TPtRect; constref arr_width:TColor; constref val:TColor=0; b:boolean=False):byte; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p  : PInteger;
  x,y: integer;
label
  emd;
begin
  Result:=00000000000000000000000000000000000000000000000000000000;
  p     :=Unaligned(@arr1_ptr[rct_dst.left+arr_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          (p+x)^:=(p+x)^<<8>>8;
          {if (((p+x)^>>24)<>0) then
            begin
              Result:=1;
              goto emd;
            end;}
        end;
      Inc(p,arr_width);
    end;
  emd:
end; {$endregion}
// Fill Arrays On Bitmap:
procedure ArrFilProc00(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
//pixel_ptr0 : PInteger;
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(TRGBA(col).b,TRGBA(col).g,TRGBA(col).r);
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
//pixel_ptr0 :=pixel_ptr;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
  {chess order}
  {for y:=0 to Trunc(rct_dst.height/2)-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
          if Odd(PInteger(pixel_ptr+x+1)-PInteger(pixel_ptr0)) then
            (pixel_ptr+x)^:=pix_color;
      Inc(pixel_ptr  ,bmp_width);
      Inc(f_arr_0_ptr,bmp_width);
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
          if Odd(PInteger(pixel_ptr+x)-PInteger(pixel_ptr0)) then
            (pixel_ptr+x)^:=pix_color;
      Inc(pixel_ptr  ,bmp_width);
      Inc(f_arr_0_ptr,bmp_width);
    end;}
end; {$endregion}
procedure ArrFilProc01(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
  r,g,b      : byte;
begin
  r          :=TRGBA(col).r;
  g          :=TRGBA(col).g;
  b          :=TRGBA(col).b;
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:={Additive0(pixel_ptr^,r,g,b);} RGB(Min(TRGBA(pixel_ptr^).r+b,MAXBYTE),
                                                           Min(TRGBA(pixel_ptr^).g+g,MAXBYTE),
                                                           Min(TRGBA(pixel_ptr^).b+r,MAXBYTE));
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFilProc02(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
  d_alpha1   : byte;
begin
  d_alpha1   :=MAXBYTE-alpha;
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:=AlphaBlendA(pixel_ptr^,col,d_alpha1);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFilProc03(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:=InverseA(pixel_ptr^);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFilProc04(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:=HighlightA(pixel_ptr^);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFilProc05(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:=DarkenA(pixel_ptr^);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFilProc06(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:=GrayscaleR0(pixel_ptr^);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFilProc07(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:=GrayscaleG0(pixel_ptr^);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFilProc08(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:=GrayscaleB0(pixel_ptr^);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFilProc09(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(TRGBA(col).b,TRGBA(col).g,TRGBA(col).r);
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) and Odd(pixel_ptr^) then
            pixel_ptr^:=pix_color;
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFilProc10(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(TRGBA(col).b,TRGBA(col).g,TRGBA(col).r);
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFilProc11(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(TRGBA(col).b,TRGBA(col).g,TRGBA(col).r);
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFilProc12(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(TRGBA(col).b,TRGBA(col).g,TRGBA(col).r);
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFilProc13(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(TRGBA(col).b,TRGBA(col).g,TRGBA(col).r);
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFilProc14(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(TRGBA(col).b,TRGBA(col).g,TRGBA(col).r);
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFilProc15(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(TRGBA(col).b,TRGBA(col).g,TRGBA(col).r);
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFilProc16(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(TRGBA(col).b,TRGBA(col).g,TRGBA(col).r);
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFilProc17(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(TRGBA(col).b,TRGBA(col).g,TRGBA(col).r);
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFilProc18(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(TRGBA(col).b,TRGBA(col).g,TRGBA(col).r);
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFilProc19(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(TRGBA(col).b,TRGBA(col).g,TRGBA(col).r);
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFilProc20(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(TRGBA(col).b,TRGBA(col).g,TRGBA(col).r);
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFilProc21(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(TRGBA(col).b,TRGBA(col).g,TRGBA(col).r);
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFilProc22(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(TRGBA(col).b,TRGBA(col).g,TRGBA(col).r);
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFilProc23(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(TRGBA(col).b,TRGBA(col).g,TRGBA(col).r);
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFilProc24(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(TRGBA(col).b,TRGBA(col).g,TRGBA(col).r);
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFilProc25(constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor; constref alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(TRGBA(col).b,TRGBA(col).g,TRGBA(col).r);
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
//
procedure ArrFil      (constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; b:boolean);           {$region -fold}
var
  pixel_ptr: PInteger;
  arr0_ptr : PByte;
  x,y      : integer;
begin
  pixel_ptr:=Unaligned(@bmp_ptr[0]);
  arr0_ptr :=Unaligned(@arr0   [0]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if ((arr0_ptr +x)^=1{<>0}) then
              (pixel_ptr+x+10+bmp_width*10)^:=clGreen
          else
          if ((arr0_ptr +x)^=2{<>0}) then
            (pixel_ptr+x+10+bmp_width*10)^:=clBlue
          else
          if ((arr0_ptr +x)^>2{<>0}) then
            (pixel_ptr+x+10+bmp_width*10)^:=clRed
        end;
      Inc(arr0_ptr ,bmp_width);
      Inc(pixel_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFil      (constref arr0:TColorArr ; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor); {$region -fold}
var
  pixel_ptr: PInteger;
  arr0_ptr : PInteger;
  x,y      : integer;
  pix_color: TColor;
begin
  pix_color:=RGB(TRGBA(col).b,TRGBA(col).g,TRGBA(col).r);
  pixel_ptr:=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  arr0_ptr :=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((arr0_ptr +x)^ <>0) then
            (pixel_ptr+x)^:=pix_color;
      Inc(arr0_ptr ,bmp_width);
      Inc(pixel_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFil      (constref arr0:TPtPos3Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PPtPos3;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^.obj_ind<>-1) then
            pixel_ptr^:=col;
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFil      (constref arr0:TPtPos3Arr;                            constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect);                      {$region -fold}
var
  f_arr_0_ptr: PPtPos3;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  f_arr_0_ptr:=Unaligned(@arr0[rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          f_arr_0_ptr^.obj_ind:=-1;
          Inc(f_arr_0_ptr);
        end;
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFil      (constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect);                      {$region -fold}
var
  pixel_ptr: PInteger;
  d_width  : integer;
  x,y      : integer;
begin
  d_width  :=bmp_width-rct_dst.width;
  pixel_ptr:=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (pixel_ptr^<>0) then
            arr0[pixel_ptr^-1]:=1;
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFilTest  (constref arr0:T1Byte1Arr; constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
begin
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^=1) then
          (pixel_ptr+x)^:=col;
      Inc (pixel_ptr  ,bmp_width);
      Inc (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
procedure ArrFilTest  (constref arr0:TIntrArr;   constref bmp_ptr:PInteger; constref bmp_width,bmp_height:TColor; constref rct_dst:TPtrect; constref col:TColor); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PInteger;
  x,y        : integer;
begin
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^=1) then
          (pixel_ptr+x)^:=col;
      Inc (pixel_ptr  ,bmp_width);
      Inc (f_arr_0_ptr,bmp_width);
    end;
end; {$endregion}
// Sum Of Array Elements:
function ArrNzItSum(constref arr:T1Byte1Arr): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=0;
  for i:=0 to Length(arr)-1 do
    Inc(Result,arr[i]);
end; {$endregion}
function ArrNzItSum(constref arr:TWordArr  ): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=0;
  for i:=0 to Length(arr)-1 do
    Inc(Result,arr[i]);
end; {$endregion}
function ArrNzItSum(constref arr:TColorArr ): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=0;
  for i:=0 to Length(arr)-1 do
    Inc(Result,arr[i]);
end; {$endregion}
// Non-Zero Items Count:
function ArrNzItCnt(constref arr:T1Byte1Arr                                                                                    ): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_ptr: PByte;
  i      : integer;
begin
  Result :=0;
  arr_ptr:=Unaligned(@arr[0]);
  for i:=0 to Length(arr)-1 do
    if ((arr_ptr+i)^=1) then
      Inc(Result);
end; {$endregion}
function ArrNzItCnt(constref bmp_dst_ptr:PInteger; constref rct_dst:TPtRect; constref bmp_dst_width:TColor; constref col:TColor): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  Result       :=0;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((dst_pixel_ptr+x)^=col) then
          Inc(Result);
      Inc (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
function ArrNzItCnt(constref arr1_ptr:PShortInt;   constref arr2_ptr:PByte;  constref length:integer                           ): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=0;
  for i:=0 to length-1 do
    if ((arr1_ptr+i)^=0) and
       ((arr2_ptr+i)^=1) then
      Inc(Result);
end; {$endregion}
function ArrNzItCnt(constref arr1_ptr:PShortInt;                             constref length:integer; b:boolean                ): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=0;
  for i:=0 to length-1 do
    if ((arr1_ptr+i)^=0) then
      Inc(Result);
end; {$endregion}
function ArrNzItCnt(constref arr:T1Byte1Arr;       constref max_arr_it_val:TColor=MAXBYTE                                      ): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  //n,m: TColor;
  i  : integer;
begin
  Result:=0;
  {n     :=1+Trunc(Ln(Double(max_arr_it_val-1))/Ln(2)); // instead of max_arr_it_val, you can substitute any other number in the interval [2**Trunc(Ln(Double(max_arr_it_val))/Ln(2))+1;+inf)
  m     :=1<<n-1;}
  for i:=0 to Length(arr)-1 do
    Inc(Result,(arr[i]+NZ_ITEM_COEFF20{m})>>NZ_ITEM_COEFF10{n}); // Inc(Result,Ord(arr[i]<>0));// the less array is sparse the faster it is
                                                                                               // as compared with:
                                                                                               // "if arr[i]<>0 then
                                                                                               //    Inc(Result);"
end; {$endregion}
function ArrNzItCnt(constref arr:TWordArr;         constref max_arr_it_val:TColor=MAXWORD                                      ): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  //n,m: TColor;
  i  : integer;
begin
  Result:=0;
  {n     :=1+Trunc(Ln(Double(max_arr_it_val-1))/Ln(2)); // instead of max_arr_it_val, you can substitute any other number in the interval [2**Trunc(Ln(Double(max_arr_it_val))/Ln(2))+1;+inf)
  m     :=1<<n-1;}
  for i:=0 to Length(arr)-1 do
    Inc(Result,(arr[i]+NZ_ITEM_COEFF21{m})>>NZ_ITEM_COEFF11{n}); // Inc(Result,Ord(arr[i]<>0));// the less array is sparse the faster it is
                                                                                               // as compared with:
                                                                                               // "if arr[i]<>0 then
                                                                                               //    Inc(Result);"
end; {$endregion}
function ArrNzItCnt(constref arr:TColorArr;        constref max_arr_it_val:TColor=MAXDWORD                                     ): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  //n,m: TColor;
  i  : integer;
begin
  Result:=0;
  {n     :=1+Trunc(Ln(Double(max_arr_it_val-1))/Ln(2)); // instead of max_arr_it_val, you can substitute any other number in the interval [2**Trunc(Ln(Double(max_arr_it_val))/Ln(2))+1;+inf)
  m     :=1<<n-1;}
  for i:=0 to Length(arr)-1 do
    Inc(Result,(arr[i]+NZ_ITEM_COEFF22{m})>>NZ_ITEM_COEFF12{n}); // Inc(Result,Ord(arr[i]<>0));// the less array is sparse the faster it is
                                                                                               // as compared with:
                                                                                               // "if arr[i]<>0 then
                                                                                               //    Inc(Result);"
end; {$endregion}
// Create Array With "Visible" Items:
procedure ArrNzItCrt(constref arr1_src_ptr:PShortInt; constref arr2_src_ptr:PByte; arr_dst_ptr:PColor; constref length1,length2:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_dst_ptr0: PColor;
  i           : integer;
begin
  arr_dst_ptr0:=arr_dst_ptr;
  for i:=0 to length1-1 do
    if ((arr1_src_ptr+i)^=0) and
       ((arr2_src_ptr+i)^=1) then
      begin
        arr_dst_ptr^:=i;
        Inc(arr_dst_ptr);
        if (arr_dst_ptr-arr_dst_ptr0=length2) then
          Break;
      end;
end; {$endregion}
procedure ArrNzItCrt(constref arr1_src_ptr:PShortInt;                              arr_dst_ptr:PColor; constref length1,length2:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_dst_ptr0: PColor;
  i           : integer;
begin
  arr_dst_ptr0:=arr_dst_ptr;
  for i:=0 to length1-1 do
    if ((arr1_src_ptr+i)^=0) then
      begin
        arr_dst_ptr^:=i;
        Inc(arr_dst_ptr);
        if (arr_dst_ptr-arr_dst_ptr0=length2) then
          Break;
      end;
end; {$endregion}
// Copy One Array To Another:
procedure ArrToArr1(arr_src_ptr:PPtPosF; arr_dst_ptr:PPtPosF; pts_cnt:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to pts_cnt-1 do
    (arr_dst_ptr+i)^:=(arr_src_ptr+i)^;
end; {$endregion}
procedure ArrToArr2(arr_src_ptr:PPtPosF; arr_dst_ptr:PPtPosF; pts_cnt:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to pts_cnt-1 do
    (arr_src_ptr+i)^:=(arr_dst_ptr+i)^;
end; {$endregion}
// Search For The First Element Not Equal To Zero Starting From data_start, length is the number of items to check:
function NotIndexByte (data_start:PByte ; length:integer): integer; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j,k,n: integer;
begin
  Result:=-1;
  k     :=00;
  for i:=0 to length>>3-1 do
    if ((PQWord(data_start+i<<3))^<>0) then
      begin
        Result:=i<<3;
        Break;
      end;
  if (Result=-1) then
    begin
      k         :=Trunc(length/8)<<3;
      data_start+=k;
    end
  else
    Exit;
  n:=-1;
  for j:=0 to Min(7,length-k) do
    if (PByte(data_start+j<<0)^<>0) then
      begin
        k+=j<<0;
        n:=0;
        Break;
      end;
  if (n<>-1) then
    Result:=k;
end; {$endregion}
function NotIndexWord (data_start:PWord ; length:integer): integer; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j,k,n: integer;
begin
  Result:=-1;
  k     :=00;
  for i:=0 to length>>2-1 do
    if ((PQWord(data_start+i<<2))^<>0) then
      begin
        Result:=i<<2;
        Break;
      end;
  if (Result=-1) then
    begin
      k         :=Trunc(length/4)<<2;
      data_start+=k;
    end
  else
    Exit;
  n:=-1;
  for j:=0 to Min(3,length-k) do
    if (PWord(data_start+j<<0)^<>0) then
      begin
        k+=j<<0;
        n:=0;
        Break;
      end;
  if (n<>-1) then
    Result:=k;
end; {$endregion}
function NotIndexDWord(data_start:PDWord; length:integer): integer; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j,k,n: integer;
begin
  Result:=-1;
  k     :=00;
  for i:=0 to length>>1-1 do
    if ((PQWord(data_start+i<<1))^<>0) then
      begin
        Result:=i<<1;
        Break;
      end;
  if (Result=-1) then
    begin
      k         :=Trunc(length/2)<<1;
      data_start+=k;
    end
  else
    Exit;
  n:=-1;
  for j:=0 to Min(1,length-k) do
    if (PDWord(data_start+j<<0)^<>0) then
      begin
        k+=j<<0;
        n:=0;
        Break;
      end;
  if (n<>-1) then
    Result:=k;
end; {$endregion}
function NotIndexQWord(data_start:PQWord; length:integer): integer; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=-1;
  for i:=0 to length>>0-1 do
    if (PQWord(data_start+i<<0)^<>0) then
      begin
        Result:=i<<0;
        Break;
      end;
end; {$endregion}
//
procedure FillRectangleOnArray0(constref arr_ptr:PInteger; var rct_inn,rct_out:TPtRectF; grid_density:TPtPos; val:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_ptr2           : PInteger;
  v0,v1              : double;
  i0,i1,j0,j1,di,dj,j: integer;
begin
  v0:=grid_density.x/rct_out.width;
  v1:=grid_density.y/rct_out.height;
  i0:=Trunc((rct_inn.left  -rct_out.left)*v0);
  i1:=Trunc((rct_inn.right -rct_out.left)*v0);
  if (i1=   (rct_inn.right -rct_out.left)*v0) then
    i1-=1;
  j0:=Trunc((rct_inn.top   -rct_out.top )*v1);
  j1:=Trunc((rct_inn.bottom-rct_out.top )*v1);
  if (j1=   (rct_inn.bottom-rct_out.top )*v1) then
    j1-=1;
  di      :=i1-i0+1;
  dj      :=j1-j0;
  arr_ptr2:=arr_ptr+i0+j0*grid_density.x;
  for j:=0 to dj do
    begin
      FillDWord(arr_ptr2^,di,val);
      Inc(arr_ptr2,grid_density.x);
    end;
end; {$endregion}
procedure FillRectangleOnArray1(constref arr_ptr:PInteger; var rct_inn,rct_out:TPtRectF; grid_density:TPtPos; val:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_ptr2             : PInteger;
  v0,v1                : double;
  i0,i1,j0,j1,di,dj,j,i: integer;
begin
  v0:=grid_density.x/rct_out.width;
  v1:=grid_density.y/rct_out.height;
  i0:=Trunc((rct_inn.left  -rct_out.left)*v0);
  i1:=Trunc((rct_inn.right -rct_out.left)*v0);
  if (i1=   (rct_inn.right -rct_out.left)*v0) then
    i1-=1;
  j0:=Trunc((rct_inn.top   -rct_out.top )*v1);
  j1:=Trunc((rct_inn.bottom-rct_out.top )*v1);
  if (j1=   (rct_inn.bottom-rct_out.top )*v1) then
    j1-=1;
  di      :=i1-i0;
  dj      :=j1-j0;
  arr_ptr2:=arr_ptr+i0+j0*grid_density.x;
  for j:=0 to dj do
    begin
      for i:=0 to di do
        (arr_ptr2+i)^+=val;
      Inc(arr_ptr2,grid_density.x);
    end;
end; {$endregion}

{$endregion}



(******************************** Linked Lists ********************************) {$region -fold}

procedure AddListItem(constref pt_x   :integer;    var first_item,p1,p2:PIList); {$region -fold}
begin
  New(p1);
  New(p1^.x_ptr);
  p1^.x_ptr^:=pt_x;
  if (first_item=Nil) then
    first_item:=p1
  else
    p2^.next_item:=p1;
  p2:=p1;
end; {$endregion}
procedure AddListItem(constref pt     :TPtPosF;    var first_item,p1,p2:PFList); {$region -fold}
begin
  New(p1);
  p1^.x:=pt.x;
  p1^.y:=pt.y;
  if (first_item=Nil) then
    first_item:=p1
  else
    p2^.next_item:=p1;
  p2:=p1;
end; {$endregion}
procedure ArrToList1 (constref arr_src:TIntrArr;   var first_item,p1,p2:PIList); {$region -fold}
var
  arr_src_ptr:^integer;
  i          : integer;
begin
  arr_src_ptr:=@arr_src[0];
  first_item :=Nil;
  for i:=0 to Length(arr_src)-1 do
    begin
      New(p1);
      p1^.x_ptr:=arr_src_ptr;
      if (first_item=Nil) then
        first_item:=p1
      else
        p2^.next_item:=p1;
      p2:=p1;
      Inc(arr_src_ptr);
    end;
  p2^.next_item:=Nil;
end; {$endregion}
procedure ArrToList2 (constref arr_src:TIntrArr;   var first_item,p1,p2:PIList); {$region -fold}
var
  arr_src_ptr:^integer;
  i          : integer;
begin
  arr_src_ptr:=@arr_src[0];
  first_item :=Nil;
  for i:=0 to Length(arr_src)-1 do
    begin
      New(p1);
      New(p1^.x_ptr);
      p1^.x_ptr^:=arr_src_ptr^;
      if (first_item=Nil) then
        first_item:=p1
      else
        p2^.next_item:=p1;
      p2:=p1;
      Inc(arr_src_ptr);
    end;
  p2^.next_item:=Nil;
end; {$endregion}
procedure ListToArr  (var      arr_dst:TIntrArr;   var first_item,p1,p2:PIList); {$region -fold}
var
  arr_dst_ptr:^integer;
  i          : integer;
begin
  arr_dst_ptr:=@arr_dst[0];
  p1         :=first_item;
  for i:=0 to Length(arr_dst)-1 do
    begin
      arr_dst_ptr^:=p1^.x_ptr^;
      p1          :=p1^.next_item;
      Inc(arr_dst_ptr);
    end;
  p2^.next_item:=Nil;
end; {$endregion}
procedure ListToArr  (var      arr_dst:TPtPosFArr; var first_item,p1,p2:PFList); {$region -fold}
var
  arr_dst_ptr: PPtPosF;
  i          : integer;
begin
  arr_dst_ptr:=@arr_dst[0];
  p1         :=first_item;
  for i:=0 to Length(arr_dst)-1 do
    begin
      arr_dst_ptr^.x:=p1^.x;
      arr_dst_ptr^.y:=p1^.y;
      p1            :=p1^.next_item;
      Inc(arr_dst_ptr);
    end;
  p2^.next_item:=Nil;
end; {$endregion}
procedure FreeList1 (                              var first_item,p1,p2:PIList); {$region -fold}
var
  t:PIList;
begin
  p1:=first_item;
  while (p1<>Nil) do
    begin
      t :=p1;
      p1:=p1^.next_item;
      Dispose(t);
    end;
  first_item:=Nil;
  p1        :=Nil;
  p2        :=Nil;
end; {$endregion}
procedure FreeList2 (                              var first_item,p1,p2:PFList); {$region -fold}
var
  t:PFList;
begin
  p1:=first_item;
  while (p1<>Nil) do
    begin
      t :=p1;
      p1:=p1^.next_item;
      Dispose(t);
    end;
  first_item:=Nil;
  p1        :=Nil;
  p2        :=Nil;
end; {$endregion}
{
type

  T1IntrArr=array of integer;

  PCnvlList=^TCnvlList;
  TCnvlList=packed record
    next_item: PCnvlList;
    arr_item : PInteger;
  end;

var
  first_item,p1,p2: PCnvlList;
  arr,arr2        : array of integer;


procedure CreateArray(var arr_src1,arr_src2:T1IntrArr); {$region -fold}
begin

  SetLength(arr_src1,8);
  arr_src1[0]:=0;
  arr_src1[1]:=3;
  arr_src1[2]:=0;
  arr_src1[3]:=1;
  arr_src1[4]:=3;
  arr_src1[5]:=2;
  arr_src1[6]:=1;
  arr_src1[7]:=1;

  SetLength(arr_src2,8);
  arr_src2[0]:=2;
  arr_src2[1]:=5;
  arr_src2[2]:=1;
  arr_src2[3]:=0;
  arr_src2[4]:=7;
  arr_src2[5]:=3;
  arr_src2[6]:=1;
  arr_src2[7]:=5;

end; {$endregion}

procedure ShowArr(constref arr_src1,arr_src2:T1IntrArr; constref arr_src_length:integer); {$region -fold}
var
  i: integer;
begin
  Writeln;
  for i:=0 to arr_src_length-1 do
    Write(arr_src1[i],' ');
  Writeln('Done');
  for i:=0 to arr_src_length-1 do
    Write(arr_src2[i],' ');
  Writeln('Done');
end; {$endregion}

procedure ArrToList1(constref arr_src:T1IntrArr; constref arr_src_length:integer); {$region -fold}
var
  arr_src_ptr:^integer;
  i          : integer;
begin
  arr_src_ptr:=@arr_src[0];
  first_item :=Nil;
  for i:=0 to arr_src_length-1 do
    begin
      New(p1);
      p1^.arr_item:=arr_src_ptr;
      if (first_item=Nil) then
        first_item:=p1
      else
        p2^.next_item:=p1;
      p2:=p1;
      Inc(arr_src_ptr);
    end;
  p2^.next_item:=Nil;
end; {$endregion}
procedure ArrToList2(constref arr_src:T1IntrArr; constref arr_src_length:integer); {$region -fold}
var
  arr_src_ptr:^integer;
  i          : integer;
begin
  arr_src_ptr:=@arr_src[0];
  first_item :=Nil;
  for i:=0 to arr_src_length-1 do
    begin
      New(p1);
      New(p1^.arr_item);
      p1^.arr_item^:=arr_src_ptr^;
      if (first_item=Nil) then
        first_item:=p1
      else
        p2^.next_item:=p1;
      p2:=p1;
      Inc(arr_src_ptr);
    end;
  p2^.next_item:=Nil;
end; {$endregion}

procedure ListToArr(var arr_src:T1IntrArr; constref arr_src_length:integer); {$region -fold}
var
  arr_src_ptr:^integer;
  i          : integer;
begin
  arr_src_ptr:=@arr_src[0];
  p1:=first_item;
  for i:=0 to arr_src_length-1 do
    begin
      arr_src_ptr^:=p1^.arr_item^;
      p1:=p1^.next_item;
      Inc(arr_src_ptr);
    end;
end; {$endregion}

procedure ShowList; {$region -fold}
var
  v_ptr:^integer;
  i    : integer;
begin
  Writeln;
  p1:=first_item;
  {v_ptr:=p1^.arr_item;
  for i:=0 to 7{Length(arr)-1} do
    Write((v_ptr+i)^,' ');}
  while (p1<>Nil) do
    begin
      Write({Integer(@p1^.arr_item)}p1^.arr_item^,' ');
      p1:=p1^.next_item;
    end;
end; {$endregion}

begin
  CreateArray(arr,arr2);
  ShowArr    (arr,arr2,8);
  ArrToList2 (arr,8);
  {arr :=Nil;
  arr2:=Nil;}
  ShowList;
  ListToArr (arr,8);
  ShowArr   (arr,arr2,8);
  //AddListAndArr(arr2,10);
  //ShowArr(arr,arr2,8,8);
  Readln;
end.
}

{$endregion}



(****************************** Edge Antialiasing *****************************) {$region -fold}

{$region -fold}
{procedure BorderCalc0(constref arr_src    :T1IntrArr; var arr_dst:T1ByteArr;                          constref arr_src_width,arr_dst_width:integer; constref rct_dst:TPtRect; var aa_nz_arr_it_cnt:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr          : PInteger;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
  pix_cnt_btw_pts      : integer;
begin
  pix_cnt_btw_pts      :=0;
  aa_nz_arr_it_cnt     :=0;
  d_width1             :=                                arr_src_width- rct_dst.width;
  d_width2             :=                                arr_dst_width- rct_dst.width;
  arr_src_ptr          :=Unaligned(@arr_src[rct_dst.left+arr_src_width*(rct_dst.top+1)]);
  arr_dst_ptr          :=Unaligned(@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr^<>0) then
            begin
              arr_dst_ptr^:=3;
              Inc(pix_cnt_btw_pts);
              while (arr_dst_ptr^<>3) do
                begin
                  if ((arr_src_ptr+arr_src_width-1)^<>0) then
                    begin
                      arr_src_ptr +=arr_src_width-1;
                      arr_dst_ptr +=arr_dst_width-1;
                      arr_dst_ptr^:=1;
                      Inc(pix_cnt_btw_pts);
                    end
                  else
                  if ((arr_src_ptr+arr_src_width)^<>0) then
                    begin
                      arr_src_ptr +=arr_src_width;
                      arr_dst_ptr +=arr_dst_width;
                      arr_dst_ptr^:=1;
                      Inc(pix_cnt_btw_pts);
                    end
                  else
                  if ((arr_src_ptr+arr_src_width+1)^<>0) then
                    begin
                      arr_src_ptr +=arr_src_width+1;
                      arr_dst_ptr +=arr_dst_width+1;
                      arr_dst_ptr^:=1;
                      Inc(pix_cnt_btw_pts);
                    end
                  else
                  if ((arr_src_ptr+1)^<>0) then
                    begin
                      arr_src_ptr +=1;
                      arr_dst_ptr +=1;
                      arr_dst_ptr^:=1;
                      Inc(pix_cnt_btw_pts);
                    end
                  else
                  if ((arr_src_ptr-arr_src_width+1)^<>0) then
                    begin
                      arr_src_ptr -=arr_src_width+1;
                      arr_dst_ptr -=arr_dst_width+1;
                      arr_dst_ptr^:=1;
                      Inc(pix_cnt_btw_pts);
                    end
                  else
                  if ((arr_src_ptr+arr_src_width)^<>0) then
                    begin
                      arr_src_ptr -=arr_src_width;
                      arr_dst_ptr -=arr_dst_width;
                      arr_dst_ptr^:=1;
                      Inc(pix_cnt_btw_pts);
                    end
                  else
                  if ((arr_src_ptr-arr_src_width-1)^<>0) then
                    begin
                      arr_src_ptr -=arr_src_width-1;
                      arr_dst_ptr -=arr_dst_width-1;
                      arr_dst_ptr^:=1;
                      Inc(pix_cnt_btw_pts);
                    end
                  else
                  if ((arr_src_ptr-1)^<>0) then
                    begin
                      arr_src_ptr -=1;
                      arr_dst_ptr -=1;
                      arr_dst_ptr^:=1;
                      Inc(pix_cnt_btw_pts);
                    end;
                end;
            end;
          Inc(arr_src_ptr);
          Inc(arr_dst_ptr);
        end;
      Inc(arr_src_ptr,d_width1);
      Inc(arr_dst_ptr,d_width2);
    end;
end; {$endregion}}
{$endregion}
//
procedure BorderCalc00(constref arr_src    :T1Byte1Arr; var arr_dst:T1Byte1Arr;                         constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; var aa_nz_arr_it_cnt:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr          : PByte;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
  pix_cnt_btw_pts      : integer;
  p                    : byte=0;
label
  l1;
begin
  pix_cnt_btw_pts      :=0;
  aa_nz_arr_it_cnt     :=0;
  d_width1             :=                                arr_src_width- rct_dst.width;
  d_width2             :=                                arr_dst_width- rct_dst.width;
  arr_src_ptr          :=Unaligned(@arr_src[rct_dst.left+arr_src_width*(rct_dst.top+1)]);
  arr_dst_ptr          :=Unaligned(@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr^<>0) then
            goto l1;
          Inc(arr_src_ptr);
          Inc(arr_dst_ptr);
        end;
      Inc(arr_src_ptr,d_width1);
      Inc(arr_dst_ptr,d_width2);
    end;
  l1:
  arr_dst_ptr^:=3;

  //Inc(pix_cnt_btw_pts);
  while (arr_dst_ptr^<>3) and (p=1) do//repeat
    begin
      {0 0 0
       1 0 0
       0 0 0}
      if ((arr_src_ptr-1)^<>0) and ((arr_dst_ptr-1)^=0) then
        begin
          arr_src_ptr +=arr_src_width-1;
          arr_dst_ptr +=arr_dst_width-1;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {0 0 0
       0 0 0
       1 0 0}
      if ((arr_src_ptr+arr_src_width-1)^<>0) and ((arr_dst_ptr+arr_src_width-1)^=0) then
        begin
          arr_src_ptr +=arr_src_width-1;
          arr_dst_ptr +=arr_dst_width-1;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {0 0 0
       0 0 0
       0 1 0}
      if ((arr_src_ptr+arr_src_width)^<>0) and ((arr_dst_ptr+arr_src_width)^=0) then
        begin
          arr_src_ptr +=arr_src_width;
          arr_dst_ptr +=arr_dst_width;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {0 0 0
       0 0 0
       0 0 1}
      if ((arr_src_ptr+arr_src_width+1)^<>0) and ((arr_dst_ptr+arr_src_width+1)^=0) then
        begin
          arr_src_ptr +=arr_src_width+1;
          arr_dst_ptr +=arr_dst_width+1;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {0 0 0
       0 0 1
       0 0 0}
      if ((arr_src_ptr+1)^<>0) and ((arr_dst_ptr+1)^=0) then
        begin
          arr_src_ptr +=1;
          arr_dst_ptr +=1;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {0 0 1
       0 0 0
       0 0 0}
      if ((arr_src_ptr-arr_src_width+1)^<>0) and ((arr_dst_ptr-arr_src_width+1)^=0) then
        begin
          arr_src_ptr -=arr_src_width+1;
          arr_dst_ptr -=arr_dst_width+1;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {0 1 0
       0 0 0
       0 0 0}
      if ((arr_src_ptr-arr_src_width)^<>0) and ((arr_dst_ptr-arr_src_width)^=0) then
        begin
          arr_src_ptr -=arr_src_width;
          arr_dst_ptr -=arr_dst_width;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {1 0 0
       0 0 0
       0 0 0}
      if ((arr_src_ptr-arr_src_width-1)^<>0) and ((arr_dst_ptr-arr_src_width-1)^=0) then
        begin
          arr_src_ptr -=arr_src_width-1;
          arr_dst_ptr -=arr_dst_width-1;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end;
    end;
    //until (arr_dst_ptr^<>3);
end; {$endregion}
//
procedure BorderCalc0 (constref arr_src_ptr:PInteger  ; var arr_dst:T1Byte1Arr;                         constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; var      aa_nz_arr_it_cnt:TColor; constref background_color:TColor                  ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2         : PInteger;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
begin
  aa_nz_arr_it_cnt:=0;
  d_width1        :=                                    arr_src_width- rct_dst.width   ;
  d_width2        :=                                    arr_dst_width- rct_dst.width   ;
  arr_src_ptr2    :=Unaligned( arr_src_ptr+rct_dst.left+arr_src_width*(rct_dst.top+1) );
  arr_dst_ptr     :=Unaligned(@arr_dst    [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  Prefetch(arr_src_ptr2);
  Prefetch(arr_dst_ptr );
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr2^<>background_color) then
            begin
              if ((arr_src_ptr2-arr_src_width)^=background_color) then
                begin
                  (arr_dst_ptr-arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr2+arr_src_width)^=background_color) then
                begin
                  (arr_dst_ptr+arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr2-1)^=background_color) then
                begin
                  (arr_dst_ptr-1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr2+1)^=background_color) then
                begin
                  (arr_dst_ptr+1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
            end;
          Inc(arr_src_ptr2);
          Inc(arr_dst_ptr );
        end;
      Inc(arr_src_ptr2,d_width1);
      Inc(arr_dst_ptr ,d_width2);
    end;
end; {$endregion}
procedure BorderCalc1 (constref arr_src_ptr:PInteger  ; var arr_dst:T1Byte1Arr;                         constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; var      aa_nz_arr_it_cnt:TColor                                                    ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2         : PInteger;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
begin
  aa_nz_arr_it_cnt     :=0;
  d_width1             :=                                    arr_src_width- rct_dst.width   ;
  d_width2             :=                                    arr_dst_width- rct_dst.width   ;
  arr_src_ptr2         :=Unaligned( arr_src_ptr+rct_dst.left+arr_src_width*(rct_dst.top+1) );
  arr_dst_ptr          :=Unaligned(@arr_dst    [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  Prefetch(arr_src_ptr2);
  Prefetch(arr_dst_ptr );
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr2^<>0) then
            begin
              if ((arr_src_ptr2-arr_src_width)^=0) then
                begin
                  (arr_dst_ptr-arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr2+arr_src_width)^=0) then
                begin
                  (arr_dst_ptr+arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr2-1)^=0) then
                begin
                  (arr_dst_ptr-1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr2+1)^=0) then
                begin
                  (arr_dst_ptr+1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
            end;
          Inc(arr_src_ptr2);
          Inc(arr_dst_ptr );
        end;
      Inc(arr_src_ptr2,d_width1);
      Inc(arr_dst_ptr ,d_width2);
    end;
end; {$endregion}
procedure BorderCalc1 (constref arr_src    :TColorArr ; var arr_dst:T1Byte1Arr;                         constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; var      aa_nz_arr_it_cnt:TColor                                                    ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr          : PInteger;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
begin
  aa_nz_arr_it_cnt     :=0;
  d_width1             :=                                arr_src_width- rct_dst.width;
  d_width2             :=                                arr_dst_width- rct_dst.width;
  arr_src_ptr          :=Unaligned(@arr_src[rct_dst.left+arr_src_width*(rct_dst.top+1)]);
  arr_dst_ptr          :=Unaligned(@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr^<>0) then
            begin
              if ((arr_src_ptr-arr_src_width)^=0) then
                begin
                  (arr_dst_ptr-arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr+arr_src_width)^=0) then
                begin
                  (arr_dst_ptr+arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr-1)^=0) then
                begin
                  (arr_dst_ptr-1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr+1)^=0) then
                begin
                  (arr_dst_ptr+1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
            end;
          Inc(arr_src_ptr);
          Inc(arr_dst_ptr);
        end;
      Inc(arr_src_ptr,d_width1);
      Inc(arr_dst_ptr,d_width2);
    end;
end; {$endregion}
procedure BorderCalc1 (constref arr_src    :T1Byte1Arr; var arr_dst:T1Byte1Arr;                         constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; var      aa_nz_arr_it_cnt:TColor                                                    ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr          : PByte;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
begin
  aa_nz_arr_it_cnt     :=0;
  d_width1             :=                                arr_src_width- rct_dst.width;
  d_width2             :=                                arr_dst_width- rct_dst.width;
  arr_src_ptr          :=Unaligned(@arr_src[rct_dst.left+arr_src_width*(rct_dst.top+1)]);
  arr_dst_ptr          :=Unaligned(@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr^<>0) then
            begin
              if ((arr_src_ptr-arr_src_width)^=0) then
                begin
                  (arr_dst_ptr-arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr+arr_src_width)^=0) then
                begin
                  (arr_dst_ptr+arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr-1)^=0) then
                begin
                  (arr_dst_ptr-1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr+1)^=0) then
                begin
                  (arr_dst_ptr+1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
            end;
          Inc(arr_src_ptr);
          Inc(arr_dst_ptr);
        end;
      Inc(arr_src_ptr,d_width1);
      Inc(arr_dst_ptr,d_width2);
    end;
end; {$endregion}
// Mixed: Image Has Circle And Other Contours:
procedure BorderCalc20(constref arr_src_ptr:PInteger  ; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; out      line_cnt        :TColor                                                    ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Circle----------} {$region -fold}
              if //((arr_dst_ptr                 -1)^=0) and ((arr_dst_ptr                 +1)^=0) and
                 ((arr_dst_ptr+arr_dst_width   -1)^=1) and ((arr_dst_ptr+arr_dst_width   +1)^=1) and
                 //((arr_dst_ptr+arr_dst_width<<1-1)^=0) and ((arr_dst_ptr+arr_dst_width<<1+1)^=0) and
                 ((arr_dst_ptr+arr_dst_width<<1  )^=1) then
                begin
                   arr_dst_ptr^                  :=2;
                  (arr_dst_ptr+arr_dst_width -1)^:=2;
                  (arr_dst_ptr+arr_dst_width +1)^:=2;
                  (arr_dst_ptr+arr_dst_width<<1)^:=2;
                  arr_alpha_ptr^.line_kind       :=11;
                  arr_alpha_ptr^.first_pt_x      :=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y      :=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end {$endregion}
              {Fill Horizontal Line-} {$region -fold}
              else
              if ((arr_dst_ptr+1)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr);
                    end;
                  arr_alpha_ptr^.line_shift:=arr_dst_ptr-line_first_pt_ptr;
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=arr_dst_ptr      -arr_dst_left_ptr+d0;
                  line_kind_arr[3]         :=((arr_src_ptr+d1-1)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2  )^<>0);
                  {line_kind=2----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=2;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=0,1,3} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1  -arr_src_width)^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2  -arr_src_width)^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1+arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1  +arr_src_width)^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2  +arr_src_width)^<>0);
                      case line_kind of
                        {line_kind=0} {$region -fold}
                        {can be rolled to line_kind=1}
                        AA_LINE_KIND000,AA_LINE_KIND001,AA_LINE_KIND002,AA_LINE_KIND003,AA_LINE_KIND004,AA_LINE_KIND005,
                        AA_LINE_KIND006,AA_LINE_KIND007,AA_LINE_KIND008,AA_LINE_KIND009,AA_LINE_KIND010,AA_LINE_KIND011,
                        AA_LINE_KIND012,AA_LINE_KIND013,AA_LINE_KIND014,AA_LINE_KIND015,AA_LINE_KIND016,AA_LINE_KIND017,
                        AA_LINE_KIND018:
                          begin
                            arr_alpha_ptr^.line_kind :=0;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=1} {$region -fold}
                        {can be rolled to line_kind=0}
                        AA_LINE_KIND100,AA_LINE_KIND101,AA_LINE_KIND102,AA_LINE_KIND103,AA_LINE_KIND104,AA_LINE_KIND105,
                        AA_LINE_KIND106,AA_LINE_KIND107,AA_LINE_KIND108,AA_LINE_KIND109,AA_LINE_KIND110,AA_LINE_KIND111,
                        AA_LINE_KIND112,AA_LINE_KIND113,AA_LINE_KIND114,AA_LINE_KIND115,AA_LINE_KIND116,AA_LINE_KIND117,
                        AA_LINE_KIND118:
                          begin
                            arr_alpha_ptr^.line_kind :=1;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=3} {$region -fold}
                        AA_LINE_KIND300:
                        if ((arr_src_ptr+d2-arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        AA_LINE_KIND301:
                        if ((arr_src_ptr+d2+arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill Vertical Line---} {$region -fold}
              else
              if ((arr_dst_ptr+arr_dst_width)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr,arr_dst_width);
                    end;
                  arr_alpha_ptr^.line_shift:=Trunc((arr_dst_ptr-line_first_pt_ptr)/arr_dst_width);
                  Dec(arr_dst_ptr,arr_dst_ptr-line_first_pt_ptr);
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=d1+arr_src_width*arr_alpha_ptr^.line_shift;
                  line_kind_arr[3]         :=((arr_src_ptr+d1 -arr_src_width)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2               )^<>0);
                  {line_kind=7----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=7;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=5,6,8} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1+1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1+1              )^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2+1              )^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1-1              )^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2-1              )^<>0);
                      case line_kind of
                        {line_kind=5} {$region -fold}
                        {can be rolled to line_kind=6}
                        AA_LINE_KIND000,AA_LINE_KIND001,AA_LINE_KIND002,AA_LINE_KIND003,AA_LINE_KIND004,AA_LINE_KIND005,
                        AA_LINE_KIND006,AA_LINE_KIND007,AA_LINE_KIND008,AA_LINE_KIND009,AA_LINE_KIND010,AA_LINE_KIND011,
                        AA_LINE_KIND012,AA_LINE_KIND013,AA_LINE_KIND014,AA_LINE_KIND015,AA_LINE_KIND016,AA_LINE_KIND017,
                        AA_LINE_KIND018:
                          begin
                            arr_alpha_ptr^.line_kind :=5;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=6} {$region -fold}
                        {can be rolled to line_kind=5}
                        AA_LINE_KIND100,AA_LINE_KIND101,AA_LINE_KIND102,AA_LINE_KIND103,AA_LINE_KIND104,AA_LINE_KIND105,
                        AA_LINE_KIND106,AA_LINE_KIND107,AA_LINE_KIND108,AA_LINE_KIND109,AA_LINE_KIND110,AA_LINE_KIND111,
                        AA_LINE_KIND112,AA_LINE_KIND113,AA_LINE_KIND114,AA_LINE_KIND115,AA_LINE_KIND116,AA_LINE_KIND117,
                        AA_LINE_KIND118:
                          begin
                            arr_alpha_ptr^.line_kind :=6;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=8} {$region -fold}
                        AA_LINE_KIND300:
                        if ((arr_src_ptr+d2+1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        AA_LINE_KIND301:
                        if ((arr_src_ptr+d2-1-arr_src_width)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill One Pixel-------} {$region -fold}
              else
              if (((arr_dst_ptr-arr_dst_width)^<>1) and ((arr_dst_ptr-1)^<>1)) or
                 (((arr_dst_ptr+arr_dst_width)^<>1) and ((arr_dst_ptr+1)^<>1)) then
                begin
                  arr_dst_ptr^             :=2;
                  arr_alpha_ptr^.line_kind :=10;
                  arr_alpha_ptr^.first_pt_x:=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end; {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
procedure BorderCalc20(constref arr_src    :TColorArr ; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; out      line_cnt        :TColor                                                    ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_src_ptr           : PInteger;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_src_ptr     :=Unaligned(@arr_src  [000000000000000000000000000000000000000000]);
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Circle----------} {$region -fold}
              if //((arr_dst_ptr                 -1)^=0) and ((arr_dst_ptr                 +1)^=0) and
                 ((arr_dst_ptr+arr_dst_width   -1)^=1) and ((arr_dst_ptr+arr_dst_width   +1)^=1) and
                 //((arr_dst_ptr+arr_dst_width<<1-1)^=0) and ((arr_dst_ptr+arr_dst_width<<1+1)^=0) and
                 ((arr_dst_ptr+arr_dst_width<<1  )^=1) then
                begin
                   arr_dst_ptr^                  :=2;
                  (arr_dst_ptr+arr_dst_width -1)^:=2;
                  (arr_dst_ptr+arr_dst_width +1)^:=2;
                  (arr_dst_ptr+arr_dst_width<<1)^:=2;
                  arr_alpha_ptr^.line_kind       :=11;
                  arr_alpha_ptr^.first_pt_x      :=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y      :=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end {$endregion}
              {Fill Horizontal Line-} {$region -fold}
              else
              if ((arr_dst_ptr+1)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr);
                    end;
                  arr_alpha_ptr^.line_shift:=arr_dst_ptr-line_first_pt_ptr;
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=arr_dst_ptr      -arr_dst_left_ptr+d0;
                  line_kind_arr[3]         :=((arr_src_ptr+d1-1)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2  )^<>0);
                  {line_kind=2----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=2;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=0,1,3} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1  -arr_src_width)^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2  -arr_src_width)^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1+arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1  +arr_src_width)^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2  +arr_src_width)^<>0);
                      case line_kind of
                        {line_kind=0} {$region -fold}
                        {can be rolled to line_kind=1}
                        AA_LINE_KIND000,AA_LINE_KIND001,AA_LINE_KIND002,AA_LINE_KIND003,AA_LINE_KIND004,AA_LINE_KIND005,
                        AA_LINE_KIND006,AA_LINE_KIND007,AA_LINE_KIND008,AA_LINE_KIND009,AA_LINE_KIND010,AA_LINE_KIND011,
                        AA_LINE_KIND012,AA_LINE_KIND013,AA_LINE_KIND014,AA_LINE_KIND015,AA_LINE_KIND016,AA_LINE_KIND017,
                        AA_LINE_KIND018:
                          begin
                            arr_alpha_ptr^.line_kind :=0;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=1} {$region -fold}
                        {can be rolled to line_kind=0}
                        AA_LINE_KIND100,AA_LINE_KIND101,AA_LINE_KIND102,AA_LINE_KIND103,AA_LINE_KIND104,AA_LINE_KIND105,
                        AA_LINE_KIND106,AA_LINE_KIND107,AA_LINE_KIND108,AA_LINE_KIND109,AA_LINE_KIND110,AA_LINE_KIND111,
                        AA_LINE_KIND112,AA_LINE_KIND113,AA_LINE_KIND114,AA_LINE_KIND115,AA_LINE_KIND116,AA_LINE_KIND117,
                        AA_LINE_KIND118:
                          begin
                            arr_alpha_ptr^.line_kind :=1;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=3} {$region -fold}
                        AA_LINE_KIND300:
                        if ((arr_src_ptr+d2-arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        AA_LINE_KIND301:
                        if ((arr_src_ptr+d2+arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill Vertical Line---} {$region -fold}
              else
              if ((arr_dst_ptr+arr_dst_width)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr,arr_dst_width);
                    end;
                  arr_alpha_ptr^.line_shift:=Trunc((arr_dst_ptr-line_first_pt_ptr)/arr_dst_width);
                  Dec(arr_dst_ptr,arr_dst_ptr-line_first_pt_ptr);
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=d1+arr_src_width*arr_alpha_ptr^.line_shift;
                  line_kind_arr[3]         :=((arr_src_ptr+d1 -arr_src_width)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2               )^<>0);
                  {line_kind=7----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=7;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=5,6,8} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1+1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1+1              )^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2+1              )^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1-1              )^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2-1              )^<>0);
                      case line_kind of
                        {line_kind=5} {$region -fold}
                        {can be rolled to line_kind=6}
                        AA_LINE_KIND000,AA_LINE_KIND001,AA_LINE_KIND002,AA_LINE_KIND003,AA_LINE_KIND004,AA_LINE_KIND005,
                        AA_LINE_KIND006,AA_LINE_KIND007,AA_LINE_KIND008,AA_LINE_KIND009,AA_LINE_KIND010,AA_LINE_KIND011,
                        AA_LINE_KIND012,AA_LINE_KIND013,AA_LINE_KIND014,AA_LINE_KIND015,AA_LINE_KIND016,AA_LINE_KIND017,
                        AA_LINE_KIND018:
                          begin
                            arr_alpha_ptr^.line_kind :=5;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=6} {$region -fold}
                        {can be rolled to line_kind=5}
                        AA_LINE_KIND100,AA_LINE_KIND101,AA_LINE_KIND102,AA_LINE_KIND103,AA_LINE_KIND104,AA_LINE_KIND105,
                        AA_LINE_KIND106,AA_LINE_KIND107,AA_LINE_KIND108,AA_LINE_KIND109,AA_LINE_KIND110,AA_LINE_KIND111,
                        AA_LINE_KIND112,AA_LINE_KIND113,AA_LINE_KIND114,AA_LINE_KIND115,AA_LINE_KIND116,AA_LINE_KIND117,
                        AA_LINE_KIND118:
                          begin
                            arr_alpha_ptr^.line_kind :=6;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=8} {$region -fold}
                        AA_LINE_KIND300:
                        if ((arr_src_ptr+d2+1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        AA_LINE_KIND301:
                        if ((arr_src_ptr+d2-1-arr_src_width)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill One Pixel-------} {$region -fold}
              else
              if (((arr_dst_ptr-arr_dst_width)^<>1) and ((arr_dst_ptr-1)^<>1)) or
                 (((arr_dst_ptr+arr_dst_width)^<>1) and ((arr_dst_ptr+1)^<>1)) then
                begin
                  arr_dst_ptr^             :=2;
                  arr_alpha_ptr^.line_kind :=10;
                  arr_alpha_ptr^.first_pt_x:=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end; {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
procedure BorderCalc20(constref arr_src    :T1Byte1Arr; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; out      line_cnt        :TColor                                                    ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_src_ptr           : PByte;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_src_ptr     :=Unaligned(@arr_src  [000000000000000000000000000000000000000000]);
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Circle----------} {$region -fold}
              if //((arr_dst_ptr                 -1)^=0) and ((arr_dst_ptr                 +1)^=0) and
                 ((arr_dst_ptr+arr_dst_width   -1)^=1) and ((arr_dst_ptr+arr_dst_width   +1)^=1) and
                 //((arr_dst_ptr+arr_dst_width<<1-1)^=0) and ((arr_dst_ptr+arr_dst_width<<1+1)^=0) and
                 ((arr_dst_ptr+arr_dst_width<<1  )^=1) then
                begin
                   arr_dst_ptr^                  :=2;
                  (arr_dst_ptr+arr_dst_width -1)^:=2;
                  (arr_dst_ptr+arr_dst_width +1)^:=2;
                  (arr_dst_ptr+arr_dst_width<<1)^:=2;
                  arr_alpha_ptr^.line_kind       :=11;
                  arr_alpha_ptr^.first_pt_x      :=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y      :=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end {$endregion}
              {Fill Horizontal Line-} {$region -fold}
              else
              if ((arr_dst_ptr+1)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr);
                    end;
                  arr_alpha_ptr^.line_shift:=arr_dst_ptr-line_first_pt_ptr;
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=arr_dst_ptr      -arr_dst_left_ptr+d0;
                  line_kind_arr[3]         :=((arr_src_ptr+d1-1)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2  )^<>0);
                  {line_kind=2----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=2;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=0,1,3} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1  -arr_src_width)^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2  -arr_src_width)^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1+arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1  +arr_src_width)^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2  +arr_src_width)^<>0);
                      case line_kind of
                        {line_kind=0} {$region -fold}
                        {can be rolled to line_kind=1}
                        AA_LINE_KIND000,AA_LINE_KIND001,AA_LINE_KIND002,AA_LINE_KIND003,AA_LINE_KIND004,AA_LINE_KIND005,
                        AA_LINE_KIND006,AA_LINE_KIND007,AA_LINE_KIND008,AA_LINE_KIND009,AA_LINE_KIND010,AA_LINE_KIND011,
                        AA_LINE_KIND012,AA_LINE_KIND013,AA_LINE_KIND014,AA_LINE_KIND015,AA_LINE_KIND016,AA_LINE_KIND017,
                        AA_LINE_KIND018:
                          begin
                            arr_alpha_ptr^.line_kind :=0;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=1} {$region -fold}
                        {can be rolled to line_kind=0}
                        AA_LINE_KIND100,AA_LINE_KIND101,AA_LINE_KIND102,AA_LINE_KIND103,AA_LINE_KIND104,AA_LINE_KIND105,
                        AA_LINE_KIND106,AA_LINE_KIND107,AA_LINE_KIND108,AA_LINE_KIND109,AA_LINE_KIND110,AA_LINE_KIND111,
                        AA_LINE_KIND112,AA_LINE_KIND113,AA_LINE_KIND114,AA_LINE_KIND115,AA_LINE_KIND116,AA_LINE_KIND117,
                        AA_LINE_KIND118:
                          begin
                            arr_alpha_ptr^.line_kind :=1;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=3} {$region -fold}
                        AA_LINE_KIND300:
                        if ((arr_src_ptr+d2-arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        AA_LINE_KIND301:
                        if ((arr_src_ptr+d2+arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill Vertical Line---} {$region -fold}
              else
              if ((arr_dst_ptr+arr_dst_width)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr,arr_dst_width);
                    end;
                  arr_alpha_ptr^.line_shift:=Trunc((arr_dst_ptr-line_first_pt_ptr)/arr_dst_width);
                  Dec(arr_dst_ptr,arr_dst_ptr-line_first_pt_ptr);
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=d1+arr_src_width*arr_alpha_ptr^.line_shift;
                  line_kind_arr[3]         :=((arr_src_ptr+d1 -arr_src_width)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2               )^<>0);
                  {line_kind=7----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=7;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=5,6,8} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1+1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1+1              )^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2+1              )^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1-1              )^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2-1              )^<>0);
                      case line_kind of
                        {line_kind=5} {$region -fold}
                        {can be rolled to line_kind=6}
                        AA_LINE_KIND000,AA_LINE_KIND001,AA_LINE_KIND002,AA_LINE_KIND003,AA_LINE_KIND004,AA_LINE_KIND005,
                        AA_LINE_KIND006,AA_LINE_KIND007,AA_LINE_KIND008,AA_LINE_KIND009,AA_LINE_KIND010,AA_LINE_KIND011,
                        AA_LINE_KIND012,AA_LINE_KIND013,AA_LINE_KIND014,AA_LINE_KIND015,AA_LINE_KIND016,AA_LINE_KIND017,
                        AA_LINE_KIND018:
                          begin
                            arr_alpha_ptr^.line_kind :=5;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=6} {$region -fold}
                        {can be rolled to line_kind=5}
                        AA_LINE_KIND100,AA_LINE_KIND101,AA_LINE_KIND102,AA_LINE_KIND103,AA_LINE_KIND104,AA_LINE_KIND105,
                        AA_LINE_KIND106,AA_LINE_KIND107,AA_LINE_KIND108,AA_LINE_KIND109,AA_LINE_KIND110,AA_LINE_KIND111,
                        AA_LINE_KIND112,AA_LINE_KIND113,AA_LINE_KIND114,AA_LINE_KIND115,AA_LINE_KIND116,AA_LINE_KIND117,
                        AA_LINE_KIND118:
                          begin
                            arr_alpha_ptr^.line_kind :=6;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=8} {$region -fold}
                        AA_LINE_KIND300:
                        if ((arr_src_ptr+d2+1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        AA_LINE_KIND301:
                        if ((arr_src_ptr+d2-1-arr_src_width)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill One Pixel-------} {$region -fold}
              else
              if (((arr_dst_ptr-arr_dst_width)^<>1) and ((arr_dst_ptr-1)^<>1)) or
                 (((arr_dst_ptr+arr_dst_width)^<>1) and ((arr_dst_ptr+1)^<>1)) then
                begin
                  arr_dst_ptr^             :=2;
                  arr_alpha_ptr^.line_kind :=10;
                  arr_alpha_ptr^.first_pt_x:=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end; {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
// Image Has Only Circle Contours:
procedure BorderCalc21(constref arr_src_ptr:PInteger  ; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; out      line_cnt        :TColor                                                    ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Circle----------} {$region -fold}
              if //((arr_dst_ptr                 -1)^=0) and ((arr_dst_ptr                 +1)^=0) and
                 ((arr_dst_ptr+arr_dst_width   -1)^=1) and ((arr_dst_ptr+arr_dst_width   +1)^=1) and
                 //((arr_dst_ptr+arr_dst_width<<1-1)^=0) and ((arr_dst_ptr+arr_dst_width<<1+1)^=0) and
                 ((arr_dst_ptr+arr_dst_width<<1  )^=1) then
                begin
                   arr_dst_ptr^                  :=2;
                  (arr_dst_ptr+arr_dst_width -1)^:=2;
                  (arr_dst_ptr+arr_dst_width +1)^:=2;
                  (arr_dst_ptr+arr_dst_width<<1)^:=2;
                  arr_alpha_ptr^.line_kind       :=11;
                  arr_alpha_ptr^.first_pt_x      :=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y      :=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end; {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
procedure BorderCalc21(constref arr_src    :TColorArr ; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; out      line_cnt        :TColor                                                    ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_src_ptr           : PInteger;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_src_ptr     :=Unaligned(@arr_src  [000000000000000000000000000000000000000000]);
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Circle----------} {$region -fold}
              if //((arr_dst_ptr                 -1)^=0) and ((arr_dst_ptr                 +1)^=0) and
                 ((arr_dst_ptr+arr_dst_width   -1)^=1) and ((arr_dst_ptr+arr_dst_width   +1)^=1) and
                 //((arr_dst_ptr+arr_dst_width<<1-1)^=0) and ((arr_dst_ptr+arr_dst_width<<1+1)^=0) and
                 ((arr_dst_ptr+arr_dst_width<<1  )^=1) then
                begin
                   arr_dst_ptr^                  :=2;
                  (arr_dst_ptr+arr_dst_width -1)^:=2;
                  (arr_dst_ptr+arr_dst_width +1)^:=2;
                  (arr_dst_ptr+arr_dst_width<<1)^:=2;
                  arr_alpha_ptr^.line_kind       :=11;
                  arr_alpha_ptr^.first_pt_x      :=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y      :=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
procedure BorderCalc21(constref arr_src    :T1Byte1Arr; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; out      line_cnt        :TColor                                                    ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_src_ptr           : PByte;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_src_ptr     :=Unaligned(@arr_src  [000000000000000000000000000000000000000000]);
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Circle----------} {$region -fold}
              if //((arr_dst_ptr                 -1)^=0) and ((arr_dst_ptr                 +1)^=0) and
                 ((arr_dst_ptr+arr_dst_width   -1)^=1) and ((arr_dst_ptr+arr_dst_width   +1)^=1) and
                 //((arr_dst_ptr+arr_dst_width<<1-1)^=0) and ((arr_dst_ptr+arr_dst_width<<1+1)^=0) and
                 ((arr_dst_ptr+arr_dst_width<<1  )^=1) then
                begin
                   arr_dst_ptr^                  :=2;
                  (arr_dst_ptr+arr_dst_width -1)^:=2;
                  (arr_dst_ptr+arr_dst_width +1)^:=2;
                  (arr_dst_ptr+arr_dst_width<<1)^:=2;
                  arr_alpha_ptr^.line_kind       :=11;
                  arr_alpha_ptr^.first_pt_x      :=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y      :=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
// Image Has No Circle Contours:
procedure BorderCalc22(constref arr_src_ptr:PInteger  ; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; out      line_cnt        :TColor                                                    ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Horizontal Line-} {$region -fold}
              if ((arr_dst_ptr+1)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr);
                    end;
                  arr_alpha_ptr^.line_shift:=arr_dst_ptr-line_first_pt_ptr;
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=arr_dst_ptr      -arr_dst_left_ptr+d0;
                  line_kind_arr[3]         :=((arr_src_ptr+d1-1)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2  )^<>0);
                  {line_kind=2----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=2;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=0,1,3} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1  -arr_src_width)^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2  -arr_src_width)^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1+arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1  +arr_src_width)^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2  +arr_src_width)^<>0);
                      case line_kind of
                        {line_kind=0} {$region -fold}
                        {can be rolled to line_kind=1}
                        AA_LINE_KIND000,AA_LINE_KIND001,AA_LINE_KIND002,AA_LINE_KIND003,AA_LINE_KIND004,AA_LINE_KIND005,
                        AA_LINE_KIND006,AA_LINE_KIND007,AA_LINE_KIND008,AA_LINE_KIND009,AA_LINE_KIND010,AA_LINE_KIND011,
                        AA_LINE_KIND012,AA_LINE_KIND013,AA_LINE_KIND014,AA_LINE_KIND015,AA_LINE_KIND016,AA_LINE_KIND017,
                        AA_LINE_KIND018:
                          begin
                            arr_alpha_ptr^.line_kind :=0;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=1} {$region -fold}
                        {can be rolled to line_kind=0}
                        AA_LINE_KIND100,AA_LINE_KIND101,AA_LINE_KIND102,AA_LINE_KIND103,AA_LINE_KIND104,AA_LINE_KIND105,
                        AA_LINE_KIND106,AA_LINE_KIND107,AA_LINE_KIND108,AA_LINE_KIND109,AA_LINE_KIND110,AA_LINE_KIND111,
                        AA_LINE_KIND112,AA_LINE_KIND113,AA_LINE_KIND114,AA_LINE_KIND115,AA_LINE_KIND116,AA_LINE_KIND117,
                        AA_LINE_KIND118:
                          begin
                            arr_alpha_ptr^.line_kind :=1;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=3} {$region -fold}
                        AA_LINE_KIND300:
                        if ((arr_src_ptr+d2-arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        AA_LINE_KIND301:
                        if ((arr_src_ptr+d2+arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill Vertical Line---} {$region -fold}
              else
              if ((arr_dst_ptr+arr_dst_width)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr,arr_dst_width);
                    end;
                  arr_alpha_ptr^.line_shift:=Trunc((arr_dst_ptr-line_first_pt_ptr)/arr_dst_width);
                  Dec(arr_dst_ptr,arr_dst_ptr-line_first_pt_ptr);
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=d1+arr_src_width*arr_alpha_ptr^.line_shift;
                  line_kind_arr[3]         :=((arr_src_ptr+d1 -arr_src_width)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2               )^<>0);
                  {line_kind=7----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=7;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=5,6,8} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1+1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1+1              )^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2+1              )^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1-1              )^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2-1              )^<>0);
                      case line_kind of
                        {line_kind=5} {$region -fold}
                        {can be rolled to line_kind=6}
                        AA_LINE_KIND000,AA_LINE_KIND001,AA_LINE_KIND002,AA_LINE_KIND003,AA_LINE_KIND004,AA_LINE_KIND005,
                        AA_LINE_KIND006,AA_LINE_KIND007,AA_LINE_KIND008,AA_LINE_KIND009,AA_LINE_KIND010,AA_LINE_KIND011,
                        AA_LINE_KIND012,AA_LINE_KIND013,AA_LINE_KIND014,AA_LINE_KIND015,AA_LINE_KIND016,AA_LINE_KIND017,
                        AA_LINE_KIND018:
                          begin
                            arr_alpha_ptr^.line_kind :=5;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=6} {$region -fold}
                        {can be rolled to line_kind=5}
                        AA_LINE_KIND100,AA_LINE_KIND101,AA_LINE_KIND102,AA_LINE_KIND103,AA_LINE_KIND104,AA_LINE_KIND105,
                        AA_LINE_KIND106,AA_LINE_KIND107,AA_LINE_KIND108,AA_LINE_KIND109,AA_LINE_KIND110,AA_LINE_KIND111,
                        AA_LINE_KIND112,AA_LINE_KIND113,AA_LINE_KIND114,AA_LINE_KIND115,AA_LINE_KIND116,AA_LINE_KIND117,
                        AA_LINE_KIND118:
                          begin
                            arr_alpha_ptr^.line_kind :=6;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=8} {$region -fold}
                        AA_LINE_KIND300:
                        if ((arr_src_ptr+d2+1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        AA_LINE_KIND301:
                        if ((arr_src_ptr+d2-1-arr_src_width)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill One Pixel-------} {$region -fold}
              else
              if (((arr_dst_ptr-arr_dst_width)^<>1) and ((arr_dst_ptr-1)^<>1)) or
                 (((arr_dst_ptr+arr_dst_width)^<>1) and ((arr_dst_ptr+1)^<>1)) then
                begin
                  arr_dst_ptr^             :=2;
                  arr_alpha_ptr^.line_kind :=10;
                  arr_alpha_ptr^.first_pt_x:=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end; {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
procedure BorderCalc22(constref arr_src    :TColorArr ; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; out      line_cnt        :TColor                                                    ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_src_ptr           : PInteger;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_src_ptr     :=Unaligned(@arr_src  [000000000000000000000000000000000000000000]);
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Horizontal Line-} {$region -fold}
              if ((arr_dst_ptr+1)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr);
                    end;
                  arr_alpha_ptr^.line_shift:=arr_dst_ptr-line_first_pt_ptr;
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=arr_dst_ptr      -arr_dst_left_ptr+d0;
                  line_kind_arr[3]         :=((arr_src_ptr+d1-1)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2  )^<>0);
                  {line_kind=2----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=2;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=0,1,3} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1  -arr_src_width)^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2  -arr_src_width)^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1+arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1  +arr_src_width)^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2  +arr_src_width)^<>0);
                      case line_kind of
                        {line_kind=0} {$region -fold}
                        {can be rolled to line_kind=1}
                        AA_LINE_KIND000,AA_LINE_KIND001,AA_LINE_KIND002,AA_LINE_KIND003,AA_LINE_KIND004,AA_LINE_KIND005,
                        AA_LINE_KIND006,AA_LINE_KIND007,AA_LINE_KIND008,AA_LINE_KIND009,AA_LINE_KIND010,AA_LINE_KIND011,
                        AA_LINE_KIND012,AA_LINE_KIND013,AA_LINE_KIND014,AA_LINE_KIND015,AA_LINE_KIND016,AA_LINE_KIND017,
                        AA_LINE_KIND018:
                          begin
                            arr_alpha_ptr^.line_kind :=0;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=1} {$region -fold}
                        {can be rolled to line_kind=0}
                        AA_LINE_KIND100,AA_LINE_KIND101,AA_LINE_KIND102,AA_LINE_KIND103,AA_LINE_KIND104,AA_LINE_KIND105,
                        AA_LINE_KIND106,AA_LINE_KIND107,AA_LINE_KIND108,AA_LINE_KIND109,AA_LINE_KIND110,AA_LINE_KIND111,
                        AA_LINE_KIND112,AA_LINE_KIND113,AA_LINE_KIND114,AA_LINE_KIND115,AA_LINE_KIND116,AA_LINE_KIND117,
                        AA_LINE_KIND118:
                          begin
                            arr_alpha_ptr^.line_kind :=1;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=3} {$region -fold}
                        AA_LINE_KIND300:
                        if ((arr_src_ptr+d2-arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        AA_LINE_KIND301:
                        if ((arr_src_ptr+d2+arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill Vertical Line---} {$region -fold}
              else
              if ((arr_dst_ptr+arr_dst_width)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr,arr_dst_width);
                    end;
                  arr_alpha_ptr^.line_shift:=Trunc((arr_dst_ptr-line_first_pt_ptr)/arr_dst_width);
                  Dec(arr_dst_ptr,arr_dst_ptr-line_first_pt_ptr);
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=d1+arr_src_width*arr_alpha_ptr^.line_shift;
                  line_kind_arr[3]         :=((arr_src_ptr+d1 -arr_src_width)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2               )^<>0);
                  {line_kind=7----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=7;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=5,6,8} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1+1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1+1              )^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2+1              )^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1-1              )^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2-1              )^<>0);
                      case line_kind of
                        {line_kind=5} {$region -fold}
                        {can be rolled to line_kind=6}
                        AA_LINE_KIND000,AA_LINE_KIND001,AA_LINE_KIND002,AA_LINE_KIND003,AA_LINE_KIND004,AA_LINE_KIND005,
                        AA_LINE_KIND006,AA_LINE_KIND007,AA_LINE_KIND008,AA_LINE_KIND009,AA_LINE_KIND010,AA_LINE_KIND011,
                        AA_LINE_KIND012,AA_LINE_KIND013,AA_LINE_KIND014,AA_LINE_KIND015,AA_LINE_KIND016,AA_LINE_KIND017,
                        AA_LINE_KIND018:
                          begin
                            arr_alpha_ptr^.line_kind :=5;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=6} {$region -fold}
                        {can be rolled to line_kind=5}
                        AA_LINE_KIND100,AA_LINE_KIND101,AA_LINE_KIND102,AA_LINE_KIND103,AA_LINE_KIND104,AA_LINE_KIND105,
                        AA_LINE_KIND106,AA_LINE_KIND107,AA_LINE_KIND108,AA_LINE_KIND109,AA_LINE_KIND110,AA_LINE_KIND111,
                        AA_LINE_KIND112,AA_LINE_KIND113,AA_LINE_KIND114,AA_LINE_KIND115,AA_LINE_KIND116,AA_LINE_KIND117,
                        AA_LINE_KIND118:
                          begin
                            arr_alpha_ptr^.line_kind :=6;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=8} {$region -fold}
                        AA_LINE_KIND300:
                        if ((arr_src_ptr+d2+1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        AA_LINE_KIND301:
                        if ((arr_src_ptr+d2-1-arr_src_width)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill One Pixel-------} {$region -fold}
              else
              if (((arr_dst_ptr-arr_dst_width)^<>1) and ((arr_dst_ptr-1)^<>1)) or
                 (((arr_dst_ptr+arr_dst_width)^<>1) and ((arr_dst_ptr+1)^<>1)) then
                begin
                  arr_dst_ptr^             :=2;
                  arr_alpha_ptr^.line_kind :=10;
                  arr_alpha_ptr^.first_pt_x:=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end; {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
procedure BorderCalc22(constref arr_src    :T1Byte1Arr; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; out      line_cnt        :TColor                                                    ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_src_ptr           : PByte;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_src_ptr     :=Unaligned(@arr_src  [000000000000000000000000000000000000000000]);
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Horizontal Line-} {$region -fold}
              if ((arr_dst_ptr+1)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr);
                    end;
                  arr_alpha_ptr^.line_shift:=arr_dst_ptr-line_first_pt_ptr;
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=arr_dst_ptr      -arr_dst_left_ptr+d0;
                  line_kind_arr[3]         :=((arr_src_ptr+d1-1)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2  )^<>0);
                  {line_kind=2----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=2;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=0,1,3} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1  -arr_src_width)^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2  -arr_src_width)^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1+arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1  +arr_src_width)^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2  +arr_src_width)^<>0);
                      case line_kind of
                        {line_kind=0} {$region -fold}
                        {can be rolled to line_kind=1}
                        AA_LINE_KIND000,AA_LINE_KIND001,AA_LINE_KIND002,AA_LINE_KIND003,AA_LINE_KIND004,AA_LINE_KIND005,
                        AA_LINE_KIND006,AA_LINE_KIND007,AA_LINE_KIND008,AA_LINE_KIND009,AA_LINE_KIND010,AA_LINE_KIND011,
                        AA_LINE_KIND012,AA_LINE_KIND013,AA_LINE_KIND014,AA_LINE_KIND015,AA_LINE_KIND016,AA_LINE_KIND017,
                        AA_LINE_KIND018:
                          begin
                            arr_alpha_ptr^.line_kind :=0;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=1} {$region -fold}
                        AA_LINE_KIND100,AA_LINE_KIND101,AA_LINE_KIND102,AA_LINE_KIND103,AA_LINE_KIND104,AA_LINE_KIND105,
                        AA_LINE_KIND106,AA_LINE_KIND107,AA_LINE_KIND108,AA_LINE_KIND109,AA_LINE_KIND110,AA_LINE_KIND111,
                        AA_LINE_KIND112,AA_LINE_KIND113,AA_LINE_KIND114,AA_LINE_KIND115,AA_LINE_KIND116,AA_LINE_KIND117,
                        AA_LINE_KIND118:
                          begin
                            arr_alpha_ptr^.line_kind :=1;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=3} {$region -fold}
                        AA_LINE_KIND300:
                        if ((arr_src_ptr+d2-arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        AA_LINE_KIND301:
                        if ((arr_src_ptr+d2+arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill Vertical Line---} {$region -fold}
              else
              if ((arr_dst_ptr+arr_dst_width)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr,arr_dst_width);
                    end;
                  arr_alpha_ptr^.line_shift:=Trunc((arr_dst_ptr-line_first_pt_ptr)/arr_dst_width);
                  Dec(arr_dst_ptr,arr_dst_ptr-line_first_pt_ptr);
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=d1+arr_src_width*arr_alpha_ptr^.line_shift;
                  line_kind_arr[3]         :=((arr_src_ptr+d1 -arr_src_width)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2               )^<>0);
                  {line_kind=7----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=7;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=5,6,8} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1+1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1+1              )^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2+1              )^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1-1              )^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2-1              )^<>0);
                      case line_kind of
                        {line_kind=5} {$region -fold}
                        {can be rolled to line_kind=6}
                        AA_LINE_KIND000,AA_LINE_KIND001,AA_LINE_KIND002,AA_LINE_KIND003,AA_LINE_KIND004,AA_LINE_KIND005,
                        AA_LINE_KIND006,AA_LINE_KIND007,AA_LINE_KIND008,AA_LINE_KIND009,AA_LINE_KIND010,AA_LINE_KIND011,
                        AA_LINE_KIND012,AA_LINE_KIND013,AA_LINE_KIND014,AA_LINE_KIND015,AA_LINE_KIND016,AA_LINE_KIND017,
                        AA_LINE_KIND018:
                          begin
                            arr_alpha_ptr^.line_kind :=5;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=6} {$region -fold}
                        {can be rolled to line_kind=5}
                        AA_LINE_KIND100,AA_LINE_KIND101,AA_LINE_KIND102,AA_LINE_KIND103,AA_LINE_KIND104,AA_LINE_KIND105,
                        AA_LINE_KIND106,AA_LINE_KIND107,AA_LINE_KIND108,AA_LINE_KIND109,AA_LINE_KIND110,AA_LINE_KIND111,
                        AA_LINE_KIND112,AA_LINE_KIND113,AA_LINE_KIND114,AA_LINE_KIND115,AA_LINE_KIND116,AA_LINE_KIND117,
                        AA_LINE_KIND118:
                          begin
                            arr_alpha_ptr^.line_kind :=6;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=8} {$region -fold}
                        AA_LINE_KIND300:
                        if ((arr_src_ptr+d2+1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        AA_LINE_KIND301:
                        if ((arr_src_ptr+d2-1-arr_src_width)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill One Pixel-------} {$region -fold}
              else
              if (((arr_dst_ptr-arr_dst_width)^<>1) and ((arr_dst_ptr-1)^<>1)) or
                 (((arr_dst_ptr+arr_dst_width)^<>1) and ((arr_dst_ptr+1)^<>1)) then
                begin
                  arr_dst_ptr^             :=2;
                  arr_alpha_ptr^.line_kind :=10;
                  arr_alpha_ptr^.first_pt_x:=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end; {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
//
procedure BorderFill  (constref arr_src    :TAALnArr;   constref rct_dst_left,rct_dst_top:integer; constref bmp_ptr:PInteger; constref bmp_width:TColor;                       constref line_cnt        :TColor; constref col:TColor; args:TFunc0Args; Func2:TFunc2); {$region -fold}
var
  arr_src_ptr : PFastAALine;
  pixel_ptr   : Pinteger;
  i,j         : integer;
  alpha_shift3: integer;
  alpha_shift2: integer;
  alpha_shift1: byte;
    alpha1    : byte;
  d_alpha1    : byte;
    alpha2    : byte;
  d_alpha2    : byte;
begin
  if (line_cnt=0) then
    Exit;
  with args do
    begin
      r           :=TRGBA(col).r;
      g           :=TRGBA(col).g;
      b           :=TRGBA(col).b;
      alpha1      :=alpha;
      d_alpha1    :=MAXBYTE-alpha1;
      alpha_shift1:=MAXBYTE-alpha;
      arr_src_ptr :=Unaligned(@arr_src[0]);
      for i:=0 to line_cnt-1 do
        begin
          pixel_ptr:=Unaligned(bmp_ptr+arr_src_ptr^.first_pt_x+rct_dst_left+bmp_width*(arr_src_ptr^.first_pt_y+rct_dst_top));
          case arr_src_ptr^.line_kind of
            00{00 - horizontal line: 2 points from left to right---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=alpha1+j*alpha_shift3;
                    d_alpha2  :=MAXBYTE-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clFuchsia);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                    Inc  (alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            01{01 - horizontal line: 2 points from right to left---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=MAXBYTE-alpha_shift3-j*alpha_shift3;
                    d_alpha2  :=MAXBYTE-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clBlue);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                    Dec  (alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            02{02 - horizontal line: outer line from ends to middle}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=alpha1+j*alpha_shift3;
                    d_alpha2  :=MAXBYTE-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                    Inc  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                    alpha2    :=MAXBYTE-alpha_shift3;
                    d_alpha2  :=        alpha_shift3;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                  end;
                alpha2:=MAXBYTE-alpha_shift3;
                for j:=0 to     alpha_shift2-1 do
                  begin
                  //alpha2    :=MAXBYTE-j*alpha_shift3;
                    d_alpha2  :=MAXBYTE-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                    Dec  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=
                  //SetColorInv({clGreen}clPurple);
                  Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
              end; {$endregion}
            03{03 - horizontal line: inner line from middle to ends}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=MAXBYTE-j*alpha_shift3;
                    d_alpha2  :=MAXBYTE-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clWhite);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                    Dec  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                    alpha2    :=MAXBYTE+alpha_shift3;
                    d_alpha2  :=       -alpha_shift3;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                  end;
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=alpha1+j*alpha_shift3;
                    d_alpha2  :=MAXBYTE-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clWhite);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                    Inc  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=
                  //SetColorInv({clGreen}clWhite);
                  Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
              end; {$endregion}
            04{04 - horizontal line: const fill--------------------}: {$region -fold}
              begin

              end; {$endregion}
            05{05 - vertical   line: 2 points from top to bottom---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=alpha1+j*alpha_shift3;
                    d_alpha2  :=MAXBYTE-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clFuchsia);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                    Inc  (alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            06{06 - vertical   line: 2 points from bottom to top---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=MAXBYTE-alpha_shift3-j*alpha_shift3;
                    d_alpha2  :=MAXBYTE-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clBlue);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                    Dec  (alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            07{07 - vertical   line: inner line from ends to middle}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                    //alpha2    :=alpha1+j*alpha_shift3;
                    d_alpha2  :=MAXBYTE-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                    Inc  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                    alpha2    :=MAXBYTE-alpha_shift3;
                    d_alpha2  :=        alpha_shift3;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                  end;
                alpha2:=MAXBYTE-alpha_shift3;
                for j:=0 to     alpha_shift2-1 do
                  begin
                    //alpha2  :=MAXBYTE-j*alpha_shift3;
                    d_alpha2  :=MAXBYTE-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                    Dec  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=
                  //SetColorInv({clGreen}clPurple);
                  Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
              end; {$endregion}
            08{08 - vertical   line: outer line from middle to ends}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                    //alpha2  :=MAXBYTE-j*alpha_shift3;
                    d_alpha2  :=MAXBYTE-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clWhite);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                    Dec  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                    alpha2    :=MAXBYTE+alpha_shift3;
                    d_alpha2  :=       -alpha_shift3;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                  end;
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                    //alpha2  :=alpha1+j*alpha_shift3;
                    d_alpha2  :=MAXBYTE-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clWhite);
                    Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                    Inc  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=
                  //SetColorInv({clGreen}clWhite);
                  Func2(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
              end; {$endregion}
            09{09 - vertical   line: const fill--------------------}: {$region -fold}
              begin

              end; {$endregion}
            10{10 - 1 point----------------------------------------}: {$region -fold}
              begin
                pixel_ptr^:=
                //SetColorInv(clRed);
                Func2(pixel_ptr^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
              end; {$endregion}
            11{11 - circle-----------------------------------------}: {$region -fold}
              begin
                (pixel_ptr               )^:=Func2((pixel_ptr               )^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
                (pixel_ptr+bmp_width   -1)^:=Func2((pixel_ptr+bmp_width   -1)^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
                (pixel_ptr+bmp_width   +1)^:=Func2((pixel_ptr+bmp_width   +1)^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
                (pixel_ptr+bmp_width<<1+0)^:=Func2((pixel_ptr+bmp_width<<1+0)^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
                (pixel_ptr             -1)^:=Func2((pixel_ptr             -1)^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
                (pixel_ptr             +1)^:=Func2((pixel_ptr             +1)^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
                (pixel_ptr+bmp_width<<1-1)^:=Func2((pixel_ptr+bmp_width<<1-1)^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
                (pixel_ptr+bmp_width<<1+1)^:=Func2((pixel_ptr+bmp_width<<1+1)^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
              end; {$endregion}
          end;
          Inc(arr_src_ptr);
        end;
    end;
end; {$endregion}
procedure BorderFill  (constref arr_src    :TAALnArr;   constref rct_dst_left,rct_dst_top:integer; constref bmp_ptr:PInteger; constref bmp_width:TColor;                       constref line_cnt        :TColor; constref col:TColor; args:TFunc0Args              ); {$region -fold}
var
  arr_src_ptr : PFastAALine;
  pixel_ptr   : Pinteger;
  i,j         : integer;
  alpha_shift3: integer;
  alpha_shift2: integer;
  alpha_shift1: byte;
    alpha1    : byte;
  d_alpha1    : byte;
    alpha2    : byte;
  d_alpha3    : TColor;
  d_alpha4    : TColor;
begin
  if (line_cnt=0) then
    Exit;
  with args do
    begin
      alpha1      :=0000000+alpha;
      d_alpha1    :=MAXBYTE-alpha;
      d_alpha3    :=d_alpha1<<24;
      d_alpha4    :=Max2(d_alpha1-150,0)<<24;
      alpha_shift1:=d_alpha1;
      arr_src_ptr :=Unaligned(@arr_src[0]);
      for i:=0 to line_cnt-1 do
        begin
          pixel_ptr:=Unaligned(bmp_ptr+arr_src_ptr^.first_pt_x+rct_dst_left+bmp_width*(arr_src_ptr^.first_pt_y+rct_dst_top));
          case arr_src_ptr^.line_kind of
            00{00 - horizontal line: 2 points from left to right---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(MAXBYTE-alpha2)<<24;
                    Inc(pixel_ptr);
                    Inc(alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            01{01 - horizontal line: 2 points from right to left---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(MAXBYTE-alpha2)<<24;
                    Inc(pixel_ptr);
                    Dec(alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            02{02 - horizontal line: outer line from ends to middle}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(MAXBYTE-alpha2)<<24;
                    Inc(pixel_ptr);
                    Inc(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                        pixel_ptr^:=alpha_shift3<<24;
                    Inc(pixel_ptr);
                  end;
                alpha2:=MAXBYTE-alpha_shift3;
                for j:=0 to     alpha_shift2-1 do
                  begin
                    pixel_ptr^:=(MAXBYTE-alpha2)<<24;
                    Inc  (pixel_ptr);
                    Dec  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=alpha_shift3<<24;
              end; {$endregion}
            03{03 - horizontal line: inner line from middle to ends}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(MAXBYTE-alpha2)<<24;
                    Inc(pixel_ptr);
                    Dec(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                        pixel_ptr^:=(-alpha_shift3)<<24;
                    Inc(pixel_ptr);
                  end;
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(MAXBYTE-alpha2)<<24;
                    Inc(pixel_ptr);
                    Inc(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=(MAXBYTE-alpha2)<<24;
              end; {$endregion}
            04{04 - horizontal line: const fill--------------------}: {$region -fold}
              begin

              end; {$endregion}
            05{05 - vertical   line: 2 points from top to bottom---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(MAXBYTE-alpha2)<<24;
                    Inc(pixel_ptr,bmp_width);
                    Inc(alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            06{06 - vertical   line: 2 points from bottom to top---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(MAXBYTE-alpha2)<<24;
                    Inc(pixel_ptr,bmp_width);
                    Dec(alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            07{07 - vertical   line: inner line from ends to middle}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(MAXBYTE-alpha2)<<24;
                    Inc(pixel_ptr,bmp_width);
                    Inc(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                    pixel_ptr^:=alpha_shift3<<24;
                    Inc(pixel_ptr,bmp_width);
                  end;
                alpha2:=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(MAXBYTE-alpha2)<<24;
                    Inc(pixel_ptr,bmp_width);
                    Dec(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=(MAXBYTE-alpha2)<<24;
              end; {$endregion}
            08{08 - vertical   line: outer line from middle to ends}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(MAXBYTE-alpha2)<<24;
                    Inc(pixel_ptr,bmp_width);
                    Dec(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                        pixel_ptr^:=(-alpha_shift3)<<24;
                    Inc(pixel_ptr,bmp_width);
                  end;
                alpha2:=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(MAXBYTE-alpha2)<<24;
                    Inc(pixel_ptr,bmp_width);
                    Inc(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=(MAXBYTE-alpha2)<<24;
              end; {$endregion}
            09{09 - vertical   line: const fill--------------------}: {$region -fold}
              begin

              end; {$endregion}
            10{10 - 1 point----------------------------------------}: {$region -fold}
              pixel_ptr^:=d_alpha1<<24; {$endregion}
            11{11 - circle-----------------------------------------}: {$region -fold}
              begin
                (pixel_ptr               )^:=d_alpha3;
                (pixel_ptr+bmp_width   -1)^:=d_alpha3;
                (pixel_ptr+bmp_width   +1)^:=d_alpha3;
                (pixel_ptr+bmp_width<<1+0)^:=d_alpha3;
                (pixel_ptr             -1)^:=d_alpha4;
                (pixel_ptr             +1)^:=d_alpha4;
                (pixel_ptr+bmp_width<<1-1)^:=d_alpha4;
                (pixel_ptr+bmp_width<<1+1)^:=d_alpha4;
              end; {$endregion}
          end;
          Inc(arr_src_ptr);
        end;
    end;
end; {$endregion}
procedure BorderFill  (constref arr_src    :TAALnArr;   constref rct_dst_left,rct_dst_top:integer; constref bmp_ptr:PByte   ; constref bmp_width:TColor;                       constref line_cnt        :TColor; constref col:TColor; args:TFunc0Args              ); {$region -fold}
var
  arr_src_ptr : PFastAALine;
  pixel_ptr   : PByte;
  i,j         : integer;
  alpha_shift3: integer;
  alpha_shift2: integer;
  alpha_shift1: byte;
    alpha1    : byte;
  d_alpha1    : byte;
    alpha2    : byte;
//d_alpha3    : byte;
  d_alpha4    : byte;
begin
  if (line_cnt=0) then
    Exit;
  with args do
    begin
      alpha1      :=0000000+alpha;
      d_alpha1    :=MAXBYTE-alpha;
      d_alpha4    :=Max2(d_alpha1-150,0);
      alpha_shift1:=d_alpha1;
      arr_src_ptr :=Unaligned(@arr_src[0]);
      for i:=0 to line_cnt-1 do
        begin
          pixel_ptr:=Unaligned(bmp_ptr+arr_src_ptr^.first_pt_x+rct_dst_left+bmp_width*(arr_src_ptr^.first_pt_y+rct_dst_top));
          case arr_src_ptr^.line_kind of
            00{00 - horizontal line: 2 points from left to right---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=MAXBYTE-alpha2;
                    Inc(pixel_ptr);
                    Inc(alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            01{01 - horizontal line: 2 points from right to left---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=MAXBYTE-alpha2;
                    Inc(pixel_ptr);
                    Dec(alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            02{02 - horizontal line: outer line from ends to middle}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=MAXBYTE-alpha2;
                    Inc(pixel_ptr);
                    Inc(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                        pixel_ptr^:=alpha_shift3;
                    Inc(pixel_ptr);
                  end;
                alpha2:=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                    pixel_ptr^:=MAXBYTE-alpha2;
                    Inc  (pixel_ptr);
                    Dec  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=alpha_shift3;
              end; {$endregion}
            03{03 - horizontal line: inner line from middle to ends}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=MAXBYTE-alpha2;
                    Inc(pixel_ptr);
                    Dec(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                        pixel_ptr^:=-alpha_shift3;
                    Inc(pixel_ptr);
                  end;
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=MAXBYTE-alpha2;
                    Inc(pixel_ptr);
                    Inc(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=MAXBYTE-alpha2;
              end; {$endregion}
            04{04 - horizontal line: const fill--------------------}: {$region -fold}
              begin

              end; {$endregion}
            05{05 - vertical   line: 2 points from top to bottom---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=MAXBYTE-alpha2;
                    Inc(pixel_ptr,bmp_width);
                    Inc(alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            06{06 - vertical   line: 2 points from bottom to top---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=MAXBYTE-alpha2;
                    Inc(pixel_ptr,bmp_width);
                    Dec(alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            07{07 - vertical   line: inner line from ends to middle}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=MAXBYTE-alpha2;
                    Inc(pixel_ptr,bmp_width);
                    Inc(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                    pixel_ptr^:=alpha_shift3;
                    Inc(pixel_ptr,bmp_width);
                  end;
                alpha2:=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=MAXBYTE-alpha2;
                    Inc(pixel_ptr,bmp_width);
                    Dec(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=MAXBYTE-alpha2;
              end; {$endregion}
            08{08 - vertical   line: outer line from middle to ends}: {$region -fold}
              begin
                alpha_shift2:=Trunc((arr_src_ptr^.line_shift)/2);
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=MAXBYTE-alpha2;
                    Inc(pixel_ptr,bmp_width);
                    Dec(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                        pixel_ptr^:=-alpha_shift3;
                    Inc(pixel_ptr,bmp_width);
                  end;
                alpha2:=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=MAXBYTE-alpha2;
                    Inc(pixel_ptr,bmp_width);
                    Inc(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=MAXBYTE-alpha2;
              end; {$endregion}
            09{09 - vertical   line: const fill--------------------}: {$region -fold}
              begin

              end; {$endregion}
            10{10 - 1 point----------------------------------------}: {$region -fold}
              pixel_ptr^:=d_alpha1; {$endregion}
            11{11 - circle-----------------------------------------}: {$region -fold}
              begin
                (pixel_ptr               )^:=d_alpha1;
                (pixel_ptr+bmp_width   -1)^:=d_alpha1;
                (pixel_ptr+bmp_width   +1)^:=d_alpha1;
                (pixel_ptr+bmp_width<<1+0)^:=d_alpha1;
                (pixel_ptr             -1)^:=d_alpha4;
                (pixel_ptr             +1)^:=d_alpha4;
                (pixel_ptr+bmp_width<<1-1)^:=d_alpha4;
                (pixel_ptr+bmp_width<<1+1)^:=d_alpha4;
              end; {$endregion}
          end;
          Inc(arr_src_ptr);
        end;
    end;
end; {$endregion}
// One-Pixel Border-Blur Calculation:
procedure BorderPixCh (arr_src_ptr:PInteger; constref arr_src_width:TColor; constref background_color:TColor                          ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2              : PInteger;
  non_zero_pix_cnt          : byte=0;
  r0,r1,r2,r3,r4,r5,r6,r7,r8: byte;
  g0,g1,g2,g3,g4,g5,g6,g7,g8: byte;
  b0,b1,b2,b3,b4,b5,b6,b7,b8: byte;
begin
  // pixel-border scheme:
  // 012
  // 345
  // 678
  // 4 - arr_src_ptr;
  // 0,1,2,3,5,6,7,8 - pixel-border;
  arr_src_ptr2:=arr_src_ptr-arr_src_width-1;
  if (arr_src_ptr2^<>background_color) then
    begin
      r0:=arr_src_ptr2^{shr 00};
      g0:=arr_src_ptr2^ shr 08 ;
      b0:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r0:=0;
      g0:=0;
      b0:=0;
    end;
  arr_src_ptr2:=arr_src_ptr-arr_src_width;
  if (arr_src_ptr2^<>background_color) then
    begin
      r1:=arr_src_ptr2^{shr 00};
      g1:=arr_src_ptr2^ shr 08 ;
      b1:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r1:=0;
      g1:=0;
      b1:=0;
    end;
  arr_src_ptr2:=arr_src_ptr-arr_src_width+1;
  if (arr_src_ptr2^<>background_color) then
    begin
      r2:=arr_src_ptr2^{shr 00};
      g2:=arr_src_ptr2^ shr 08 ;
      b2:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r2:=0;
      g2:=0;
      b2:=0;
    end;
  arr_src_ptr2:=arr_src_ptr-1;
  if (arr_src_ptr2^<>background_color) then
    begin
      r3:=arr_src_ptr2^{shr 00};
      g3:=arr_src_ptr2^ shr 08 ;
      b3:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r3:=0;
      g3:=0;
      b3:=0;
    end;
  if (arr_src_ptr^<>background_color) then
    begin
      r4:=arr_src_ptr^{shr 00};
      g4:=arr_src_ptr^ shr 08 ;
      b4:=arr_src_ptr^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r4:=0;
      g4:=0;
      b4:=0;
    end;
  arr_src_ptr2:=arr_src_ptr+1;
  if (arr_src_ptr2^<>background_color) then
    begin
      r5:=arr_src_ptr2^{shr 00};
      g5:=arr_src_ptr2^ shr 08 ;
      b5:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r5:=0;
      g5:=0;
      b5:=0;
    end;
  arr_src_ptr2:=arr_src_ptr+arr_src_width-1;
  if (arr_src_ptr2^<>background_color) then
    begin
      r6:=arr_src_ptr2^{shr 00};
      g6:=arr_src_ptr2^ shr 08 ;
      b6:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r6:=0;
      g6:=0;
      b6:=0;
    end;
  arr_src_ptr2:=arr_src_ptr+arr_src_width;
  if (arr_src_ptr2^<>background_color) then
    begin
      r7:=arr_src_ptr2^{shr 00};
      g7:=arr_src_ptr2^ shr 08 ;
      b7:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r7:=0;
      g7:=0;
      b7:=0;
    end;
  arr_src_ptr2:=arr_src_ptr+arr_src_width+1;
  if (arr_src_ptr2^<>background_color) then
    begin
      r8:=arr_src_ptr2^{shr 00};
      g8:=arr_src_ptr2^ shr 08 ;
      b8:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r8:=0;
      g8:=0;
      b8:=0;
    end;
  arr_src_ptr^:={clRed}RGB(Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/non_zero_pix_cnt),
                           Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/non_zero_pix_cnt),
                           Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/non_zero_pix_cnt));
end; {$endregion}
procedure BorderPixCh (arr_src_ptr:PInteger; constref arr_src_width:TColor; constref alpha_color     :byte                            ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2              : PInteger;
  non_zero_pix_cnt          : byte=0;
  r0,r1,r2,r3,r4,r5,r6,r7,r8: byte;
  g0,g1,g2,g3,g4,g5,g6,g7,g8: byte;
  b0,b1,b2,b3,b4,b5,b6,b7,b8: byte;
begin
  // pixel-border scheme:
  // 012
  // 345
  // 678
  // 4 - arr_src_ptr;
  // 0,1,2,3,5,6,7,8 - pixel-border;
  arr_src_ptr2:=arr_src_ptr-arr_src_width-1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r0:=arr_src_ptr2^{shr 00};
      g0:=arr_src_ptr2^ shr 08 ;
      b0:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r0:=0;
      g0:=0;
      b0:=0;
    end;
  arr_src_ptr2:=arr_src_ptr-arr_src_width;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r1:=arr_src_ptr2^{shr 00};
      g1:=arr_src_ptr2^ shr 08 ;
      b1:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r1:=0;
      g1:=0;
      b1:=0;
    end;
  arr_src_ptr2:=arr_src_ptr-arr_src_width+1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r2:=arr_src_ptr2^{shr 00};
      g2:=arr_src_ptr2^ shr 08 ;
      b2:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r2:=0;
      g2:=0;
      b2:=0;
    end;
  arr_src_ptr2:=arr_src_ptr-1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r3:=arr_src_ptr2^{shr 00};
      g3:=arr_src_ptr2^ shr 08 ;
      b3:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r3:=0;
      g3:=0;
      b3:=0;
    end;
  {if (arr_src_ptr^>>24<>alpha_color) then
    begin
      r4:=arr_src_ptr^{shr 00};
      g4:=arr_src_ptr^ shr 08 ;
      b4:=arr_src_ptr^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r4:=0;
      g4:=0;
      b4:=0;
    end;}
  arr_src_ptr2:=arr_src_ptr+1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r5:=arr_src_ptr2^{shr 00};
      g5:=arr_src_ptr2^ shr 08 ;
      b5:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r5:=0;
      g5:=0;
      b5:=0;
    end;
  arr_src_ptr2:=arr_src_ptr+arr_src_width-1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r6:=arr_src_ptr2^{shr 00};
      g6:=arr_src_ptr2^ shr 08 ;
      b6:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r6:=0;
      g6:=0;
      b6:=0;
    end;
  arr_src_ptr2:=arr_src_ptr+arr_src_width;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r7:=arr_src_ptr2^{shr 00};
      g7:=arr_src_ptr2^ shr 08 ;
      b7:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r7:=0;
      g7:=0;
      b7:=0;
    end;
  arr_src_ptr2:=arr_src_ptr+arr_src_width+1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r8:=arr_src_ptr2^{shr 00};
      g8:=arr_src_ptr2^ shr 08 ;
      b8:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r8:=0;
      g8:=0;
      b8:=0;
    end;
  if (non_zero_pix_cnt in [0..4]) then
    Exit;
  arr_src_ptr^:={clRed}RGB(Trunc((r0+r1+r2+r3{+r4}+r5+r6+r7+r8)/non_zero_pix_cnt),
                           Trunc((g0+g1+g2+g3{+g4}+g5+g6+g7+g8)/non_zero_pix_cnt),
                           Trunc((b0+b1+b2+b3{+b4}+b5+b6+b7+b8)/non_zero_pix_cnt));
end; {$endregion}
procedure BorderPixCh (arr_src_ptr:PInteger; constref arr_src_width:TColor; constref alpha_color     :byte; constref alpha_mask:TColor); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2              : PInteger;
  non_zero_pix_cnt          : byte=0;
  r0,r1,r2,r3,r4,r5,r6,r7,r8: byte;
  g0,g1,g2,g3,g4,g5,g6,g7,g8: byte;
  b0,b1,b2,b3,b4,b5,b6,b7,b8: byte;
begin
  // pixel-border scheme:
  // 012
  // 345
  // 678
  // 4 - arr_src_ptr;
  // 0,1,2,3,5,6,7,8 - pixel-border;
  arr_src_ptr2:=arr_src_ptr-arr_src_width-1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r0:=arr_src_ptr2^{shr 00};
      g0:=arr_src_ptr2^ shr 08 ;
      b0:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r0:=0;
      g0:=0;
      b0:=0;
    end;
  arr_src_ptr2:=arr_src_ptr-arr_src_width;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r1:=arr_src_ptr2^{shr 00};
      g1:=arr_src_ptr2^ shr 08 ;
      b1:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r1:=0;
      g1:=0;
      b1:=0;
    end;
  arr_src_ptr2:=arr_src_ptr-arr_src_width+1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r2:=arr_src_ptr2^{shr 00};
      g2:=arr_src_ptr2^ shr 08 ;
      b2:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r2:=0;
      g2:=0;
      b2:=0;
    end;
  arr_src_ptr2:=arr_src_ptr-1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r3:=arr_src_ptr2^{shr 00};
      g3:=arr_src_ptr2^ shr 08 ;
      b3:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r3:=0;
      g3:=0;
      b3:=0;
    end;
  {if (arr_src_ptr^>>24<>alpha_color) then
    begin
      r4:=arr_src_ptr^{shr 00};
      g4:=arr_src_ptr^ shr 08 ;
      b4:=arr_src_ptr^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r4:=0;
      g4:=0;
      b4:=0;
    end;}
  arr_src_ptr2:=arr_src_ptr+1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r5:=arr_src_ptr2^{shr 00};
      g5:=arr_src_ptr2^ shr 08 ;
      b5:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r5:=0;
      g5:=0;
      b5:=0;
    end;
  arr_src_ptr2:=arr_src_ptr+arr_src_width-1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r6:=arr_src_ptr2^{shr 00};
      g6:=arr_src_ptr2^ shr 08 ;
      b6:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r6:=0;
      g6:=0;
      b6:=0;
    end;
  arr_src_ptr2:=arr_src_ptr+arr_src_width;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r7:=arr_src_ptr2^{shr 00};
      g7:=arr_src_ptr2^ shr 08 ;
      b7:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r7:=0;
      g7:=0;
      b7:=0;
    end;
  arr_src_ptr2:=arr_src_ptr+arr_src_width+1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    begin
      r8:=arr_src_ptr2^{shr 00};
      g8:=arr_src_ptr2^ shr 08 ;
      b8:=arr_src_ptr2^ shr 16 ;
      Inc(non_zero_pix_cnt);
    end
  else
    begin
      r8:=0;
      g8:=0;
      b8:=0;
    end;
  if (non_zero_pix_cnt in [0..4{6}]) then
    Exit;
  arr_src_ptr^:={clRed}RGB(Trunc((r0+r1+r2+r3{+r4}+r5+r6+r7+r8)/non_zero_pix_cnt),
                           Trunc((g0+g1+g2+g3{+g4}+g5+g6+g7+g8)/non_zero_pix_cnt),
                           Trunc((b0+b1+b2+b3{+b4}+b5+b6+b7+b8)/non_zero_pix_cnt))<<8>>8+alpha_mask;
end; {$endregion}
// Border Blur:
procedure BorderBlur  (constref arr_src_ptr:PInteger ; var arr_dst:T1Byte1Arr; constref arr_src_width,arr_dst_width:TColor; constref rct_dst:TPtRect; constref background_color:TColor                    ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2         : PInteger;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
begin

  d_width1        :=                                    arr_src_width- rct_dst.width   ;
  d_width2        :=                                    arr_dst_width- rct_dst.width   ;
  arr_src_ptr2    :=Unaligned( arr_src_ptr+rct_dst.left+arr_src_width*(rct_dst.top+1) );
  arr_dst_ptr     :=Unaligned(@arr_dst    [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  Prefetch(arr_src_ptr2);
  Prefetch(arr_dst_ptr );
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_dst_ptr^=1) then
            BorderPixCh(arr_src_ptr2,arr_src_width,background_color);
          Inc(arr_src_ptr2);
          Inc(arr_dst_ptr );
        end;
      Inc(arr_src_ptr2,d_width1);
      Inc(arr_dst_ptr ,d_width2);
    end;
end; {$endregion}
procedure BorderBlur  (constref arr_src_ptr:PInteger ;                         constref arr_src_width              :TColor; constref rct_dst:TPtRect; constref alpha_color     :byte                      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2: PInteger;
  d_width,x,y : integer;
begin

  d_width     :=0000000000000000000000000000000000+arr_src_width- rct_dst.width  ;
  arr_src_ptr2:=Unaligned(arr_src_ptr+rct_dst.left+arr_src_width*(rct_dst.top+1));
  Prefetch(arr_src_ptr2);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr2^>>24=alpha_color) then
            {arr_src_ptr2^:=clRed;}BorderPixCh(arr_src_ptr2,arr_src_width,alpha_color);
          Inc(arr_src_ptr2);
        end;
      Inc(arr_src_ptr2,d_width);
    end;
end; {$endregion}
procedure BorderBlur  (constref arr_src_ptr:PInteger ;                         constref arr_src_width              :TColor; constref rct_dst:TPtRect; constref alpha_color     :byte; constref mask:TColor); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2: PInteger;
  d_width,x,y : integer;
begin
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  d_width     :=0000000000000000000000000000000000+arr_src_width- rct_dst.width  ;
  arr_src_ptr2:=Unaligned(arr_src_ptr+rct_dst.left+arr_src_width*(rct_dst.top+1));
  Prefetch(arr_src_ptr2);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr2^>>24=alpha_color) then
            {arr_src_ptr2^:=clRed;}BorderPixCh(arr_src_ptr2,arr_src_width,alpha_color,mask);
          Inc(arr_src_ptr2);
        end;
      Inc(arr_src_ptr2,d_width);
    end;
end; {$endregion}
//
procedure EdgeAATest  (constref bmp_dst_ptr:PInteger; constref rct_dst:TPtRect; constref bmp_dst_width:TColor; constref val1,val2:byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  dst_pixel_ptr             : PInteger;
  d_width                   : integer;
  x,y                       : integer;
  r0,r1,r2,r3,r4,r5,r6,r7,r8: boolean;
  v1,v2,v3                  : boolean;
begin
  {d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(@bmp_dst_ptr[rct_dst.left+rct_dst.top*bmp_dst_width]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          r0:=Abs((dst_pixel_ptr^>>00)-((dst_pixel_ptr+              1)^>>00))>=val1;
          r1:=Abs((dst_pixel_ptr^>>08)-((dst_pixel_ptr+              1)^>>08))>=val1;
          r2:=Abs((dst_pixel_ptr^>>16)-((dst_pixel_ptr+              1)^>>16))>=val1;
          v1:=r0 and r1 and r2;
          r3:=Abs((dst_pixel_ptr^>>00)-((dst_pixel_ptr+bmp_dst_width+1)^>>00))>=val1;
          r4:=Abs((dst_pixel_ptr^>>08)-((dst_pixel_ptr+bmp_dst_width+1)^>>08))>=val1;
          r5:=Abs((dst_pixel_ptr^>>16)-((dst_pixel_ptr+bmp_dst_width+1)^>>16))>=val1;
          v2:=r3 and r4 and r5;
          r6:=Abs((dst_pixel_ptr^>>00)-((dst_pixel_ptr+bmp_dst_width  )^>>00))>=val1;
          r7:=Abs((dst_pixel_ptr^>>08)-((dst_pixel_ptr+bmp_dst_width  )^>>08))>=val1;
          r8:=Abs((dst_pixel_ptr^>>16)-((dst_pixel_ptr+bmp_dst_width  )^>>16))>=val1;
          v3:=r6 and r7 and r8;
          if v1 and v2 and (not v3) then
            BlurRGB(dst_pixel_ptr-1,bmp_dst_width) //(dst_pixel_ptr+bmp_dst_width)^:={clRed};
          else
          if v1 and (not v2) and v3 then
            BlurRGB(dst_pixel_ptr,bmp_dst_width) //(dst_pixel_ptr+bmp_dst_width)^:={clRed};
          else
          if (not v1) and v2 and v3 then
            BlurRGB(dst_pixel_ptr-bmp_dst_width-1,bmp_dst_width); //(dst_pixel_ptr+bmp_dst_width)^:={clRed};
          Inc     (dst_pixel_ptr);
        end;
      Inc         (dst_pixel_ptr,d_width);
    end;}
end; {$endregion}

{$endregion}



(******************************* Bitmap Loading *******************************) {$region -fold}

function CrtTPicInstFromHDDSrc(constref location:string): TPicture;                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=TPicture.Create;
  Result.LoadFromFile(location);
end; {$endregion}
function CrtTBmpInstFromImgLst(constref ImgLstGetBmp:TProc1; constref img_ind:TColor=0): TBitmap;                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=TBitmap.Create;
  ImgLstGetBmp(img_ind,Result);
end; {$endregion}
function CrtTBmpInst          (constref bmp_src:TBitmap; var bmp_dst_ptr:PInteger): TBitmap;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      Result     :=TBitmap.Create;
      Width      :=bmp_src.width;
      Height     :=bmp_src.height;
      bmp_dst_ptr:=GetBmpHandle(Result);
      Canvas.Draw(0,0,bmp_src);
    end;
end; {$endregion}
function CrtTBmpInst          (constref bmp_dst_width,bmp_dst_height:TColor; var bmp_src_ptr:PInteger): TBitmap; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      Result     :=TBitmap.Create;
      PixelFormat:=pf32bit;
      Width      :=bmp_dst_width;
      Height     :=bmp_dst_height;
      bmp_src_ptr:=GetBmpHandle(Result);
    end;
end; {$endregion}

{$endregion}



(***************************** CSR-Image Routines *****************************) {$region -fold}

{Clear All Specified Buffers---------------------------} {$region -fold}
procedure TFastImageProc.ClrArr(arr_clear_val:word); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin

      {Color/Alpha of Current Layer} {$region -fold}

      // NT - not transparent pixels;
      if Odd(arr_clear_val>>10) then
        begin
          nt_pix_intr_ccl_arr:=Nil;
          {SetLength(nt_pix_intr_ccl_arr,1);
          nt_pix_intr_ccl_arr[0]:=0;}
        end;

      // PT - partly transparent pixels;
      // color channel;
      if Odd(arr_clear_val>>09) then
        begin
          pt_pix_intr_ccl_arr:=Nil;
          {SetLength(pt_pix_intr_ccl_arr,1);
          pt_pix_intr_ccl_arr[0]:=0;}
        end;
      // alpha channel
      if Odd(arr_clear_val>>08) then
        begin
          pt_pix_byte_acl_arr:=Nil;
          {SetLength(pt_pix_byte_acl_arr,1);
          pt_pix_byte_acl_arr[0]:=0;}
        end; {$endregion}

      {Color       of Lower   Layer} {$region -fold}

      // NT - not transparent pixels;
      if Odd(arr_clear_val>>07) then
        begin
          //nt_pix_intr_cll_arr:=Nil;
          {SetLength(nt_pix_intr_cll_arr,1);
          nt_pix_intr_cll_arr[0]:=0;}
        end;

      // PT - partly transparent pixels;
      if Odd(arr_clear_val>>06) then
        begin
          //pt_pix_intr_cll_arr:=Nil;
          {SetLength(pt_pix_intr_cll_arr,1);
          pt_pix_intr_cll_arr[0]:=0;}
        end; {$endregion}

      {Value       of Current Layer} {$region -fold}

      // NT - not transparent pixels;
      if Odd(arr_clear_val>>05) then
        begin
          //nt_pix_intr_val_arr:=Nil;
          {SetLength(nt_pix_intr_val_arr,1);
          nt_pix_intr_val_arr[0]:=0;}
        end;

      // PT - partly transparent pixels; reserved;
      if Odd(arr_clear_val>>04) then
        begin
          //pt_pix_intr_val_arr:=Nil;
          {SetLength(pt_pix_intr_val_arr,1);
          pt_pix_intr_val_arr[0]:=0;}
        end; {$endregion}

      {Counts of Items in Rows-----} {$region -fold}

      // NT - not transparent pixels;
      if Odd(arr_clear_val>>03) then
        begin
          nt_pix_intr_cnt_arr:=Nil;
          {SetLength(nt_pix_intr_cnt_arr,1);
          nt_pix_intr_cnt_arr[0]:=0;}
        end;

      // PT - partly transparent pixels;
      if Odd(arr_clear_val>>02) then
        begin
          pt_pix_intr_cnt_arr:=Nil;
          {SetLength(pt_pix_intr_cnt_arr,1);
          pt_pix_intr_cnt_arr[0]:=0;}
        end; {$endregion}

      {Items Shifts----------------} {$region -fold}

      // NT - not transparent pixels;
      if Odd(arr_clear_val>>01) then
        begin
          //nt_pix_intr_sht_arr:=Nil;
          {SetLength(nt_pix_intr_sht_arr,1);
          nt_pix_intr_sht_arr[0]:=0;}
        end;

      // PT - partly transparent pixels;
      if Odd(arr_clear_val>>00) then
        begin
          //pt_pix_intr_sht_arr:=Nil;
          {SetLength(pt_pix_intr_sht_arr,1);
          pt_pix_intr_sht_arr[0]:=0;}
        end; {$endregion}

    end;
end; {$endregion}
procedure TFastImageProc.ClrArr;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin

      {Color       of Lower   Layer} {$region -fold}
      // NT - not transparent pixels;
      nt_pix_intr_cll_arr:=Nil;
      // PT - partly transparent pixels;
      pt_pix_intr_cll_arr:=Nil; {$endregion}

      {Value       of Current Layer} {$region -fold}
      // NT - not transparent pixels;
      nt_pix_intr_val_arr:=Nil;
      // PT - partly transparent pixels; reserved;
      pt_pix_intr_val_arr:=Nil; {$endregion}

      {Items Shifts----------------} {$region -fold}
      // NT - not transparent pixels;
      nt_pix_intr_sht_arr:=Nil;
      // PT - partly transparent pixels;
      pt_pix_intr_sht_arr:=Nil; {$endregion}

    end;
end; {$endregion} {$endregion}

{Define Image Kind-------------------------------------} {$region -fold}
procedure TFastImageProc.DetImageKind; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr  : PInteger;
  first_pix_alpha: TColor;
  x,y            : integer;
  d_width        : integer;
begin

  with fast_image_data_ptr0^ do
    begin

      if (bmp_ftimg_width =0) or (bmp_src_rct_clp.width =0) or
         (bmp_ftimg_height=0) or (bmp_src_rct_clp.height=0) then
        begin
          img_kind  :=10;
          nt_pix_cnt:=0;
          pt_pix_cnt:=0;
          Exit;
        end;

      if (img_kind=11) then
        begin
          nt_pix_cnt:=0;
          pt_pix_cnt:=0;
          Exit;
        end;

      d_width        := bmp_ftimg_width-bmp_src_rct_clp.width;
      pix_color_ptr  :=@bmp_color_ptr  [bmp_src_rct_clp.left+
                        bmp_ftimg_width*bmp_src_rct_clp.top];
      first_pix_alpha:=pix_color_ptr^>>24;
      zr_pix_cnt     :=0;
      pt_pix_cng_cnt :=0;
      nt_pix_cnt     :=0;
      pt_pix_cnt     :=0;
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          for x:=0 to bmp_src_rct_clp.width-1 do
            begin
              if (pix_color_ptr^<<08=000) then
                Inc(zr_pix_cnt);
              if (pix_color_ptr^>>24=alpha_max) then
                Inc(nt_pix_cnt);
              if (pix_color_ptr^>>24>000) and (pix_color_ptr^>>24<alpha_max) then
                begin
                  if (pix_color_ptr^>>24=first_pix_alpha) then
                    Inc(pt_pix_cng_cnt);
                  Inc(pt_pix_cnt);
                end;
              Inc(pix_color_ptr);
            end;
          Inc(pix_color_ptr,d_width)
        end;

      if tile_map_calc then
        begin
          img_kind          :=12;
          fx_arr[0].cfx_pow0:=first_pix_alpha;
          Exit;
        end;

      if (pt_pix_cng_cnt<>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
         (zr_pix_cnt    <>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
         (nt_pix_cnt     >0)                                            and
         (pt_pix_cnt     >0)                                            then
        img_kind:=0;

      if (pt_pix_cng_cnt<>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
         (zr_pix_cnt    <>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
         (nt_pix_cnt     >0)                                            and
         (pt_pix_cnt     =0)                                            then
        img_kind:=1;

      if (pt_pix_cng_cnt<>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
         (zr_pix_cnt    <>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
         (nt_pix_cnt     =0)                                            and
         (pt_pix_cnt     >0)                                            then
        img_kind:=2;

      if (pt_pix_cng_cnt<>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
         (zr_pix_cnt    <>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
        ((nt_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) or
         (nt_pix_cnt     =0))                                           and
         (pt_pix_cnt     =0)                                            then
        img_kind:=3;

      if (pt_pix_cng_cnt =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
         (zr_pix_cnt    <>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
         (nt_pix_cnt     =0)                                            and
         (pt_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) then
        begin
          fx_arr[0].cfx_pow0:=first_pix_alpha;
          img_kind:=4;
        end;

      if (pt_pix_cng_cnt<>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
         (zr_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
         (nt_pix_cnt     >0)                                            and
         (pt_pix_cnt     >0)                                            then
        img_kind:=5;

      if (pt_pix_cng_cnt<>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
         (zr_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
         (nt_pix_cnt     >0)                                            and
         (pt_pix_cnt     =0)                                            then
        img_kind:=6;

      if (pt_pix_cng_cnt<>bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
         (zr_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
         (nt_pix_cnt     =0)                                            and
         (pt_pix_cnt     >0)                                            then
        img_kind:=7;

      if (pt_pix_cng_cnt =0)                                            and
         (zr_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
         (nt_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
         (pt_pix_cnt     =0)                                            then
        img_kind:=8;

      if (pt_pix_cng_cnt =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
         (zr_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
         (nt_pix_cnt     =0)                                            and
         (pt_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) then
        img_kind:=9;

      if (pt_pix_cng_cnt =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
         (zr_pix_cnt     =bmp_src_rct_clp.width*bmp_src_rct_clp.height) and
         (nt_pix_cnt     =0)                                            and
         (pt_pix_cnt     =0)                                            then
        img_kind:=10;

     {nt_pix_cnt:=0;
      pt_pix_cnt:=0;}

    end;

end; {$endregion} {$endregion}

{Create Array    of Items Counts  in Rows from Bitmap--} {$region -fold}
// color and alpha are in separate bitmaps
// NT - not transparent pixels;
procedure TFastImageProc.CrtNTCountBmpS; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr             : PInteger;
  nt_pix_intr_cnt_arr_ptr   : PInteger;
  nt_pix_arr_row_mrg_btm_ptr: PInteger;
  nt_pix_cnt_row            : integer=0;
  x,y,i                     : integer;
  d_width                   : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        Exit;
      SetLength(nt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
      d_width                :=bmp_ftimg_width-bmp_src_rct_clp.width;
      nt_pix_cnt             :=0;
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000]);
      pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          for x:=0 to bmp_src_rct_clp.width-1 do
            begin
              if (pix_alpha_ptr^=$FFFFFF) then
                Inc(nt_pix_cnt_row);
              Inc(pix_alpha_ptr);
            end;
          if (nt_pix_cnt_row<>0) then
            begin
              nt_pix_intr_cnt_arr_ptr^:=nt_pix_cnt_row;
              nt_pix_cnt              +=nt_pix_cnt_row;
              nt_pix_cnt_row          :=0;
            end;
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(pix_alpha_ptr,d_width);
        end;
      if (nt_pix_cnt=0) then
        Exit;

      {Find Top Margin Value}
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[0]);
      for i:=0 to bmp_src_rct_clp.height-1 do
        if ((nt_pix_intr_cnt_arr_ptr+i)^<>0) then
          begin
            nt_pix_arr_row_mrg_top:=i;
            Break;
          end;

      {Find Bottom Margin Value}
      if (nt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
        begin
          nt_pix_arr_row_mrg_btm_ptr:=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
          nt_pix_intr_cnt_arr_ptr   :=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
          for i:=0 to Abs(bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-2) do
            begin
              if (nt_pix_intr_cnt_arr_ptr^<>0) then
                  nt_pix_arr_row_mrg_btm_ptr:=
                  nt_pix_intr_cnt_arr_ptr;
              Inc(nt_pix_intr_cnt_arr_ptr);
            end;
          if     (nt_pix_intr_cnt_arr_ptr^<>0) then
                  nt_pix_arr_row_mrg_btm_ptr:=
                  nt_pix_intr_cnt_arr_ptr;
                  nt_pix_arr_row_mrg_btm:=
        PInteger(@nt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-
        PInteger( nt_pix_arr_row_mrg_btm_ptr);
        end;
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImageProc.CrtPTCountBmpS; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr             : PInteger;
  pt_pix_intr_cnt_arr_ptr   : PInteger;
  pt_pix_arr_row_mrg_btm_ptr: PInteger;
  pt_pix_cnt_row            : integer=0;
  x,y,i                     : integer;
  d_width                   : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        Exit;
      SetLength(pt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
      d_width                :=bmp_ftimg_width-bmp_src_rct_clp.width;
      pt_pix_cnt             :=0;
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000]);
      pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          for x:=0 to bmp_src_rct_clp.width-1 do
            begin
              if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<alpha_max) then
                Inc(pt_pix_cnt_row);
              Inc(pix_alpha_ptr,4);
            end;
          if (pt_pix_cnt_row<>0) then
            begin
              pt_pix_intr_cnt_arr_ptr^:=pt_pix_cnt_row;
              pt_pix_cnt              +=pt_pix_cnt_row;
              pt_pix_cnt_row          :=0;
            end;
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(pix_alpha_ptr,d_width<<2);
        end;
      if (pt_pix_cnt=0) then
        Exit;

      {Find Top Margin Value}
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[0]);
      for i:=0 to bmp_src_rct_clp.height-1 do
        if ((pt_pix_intr_cnt_arr_ptr+i)^<>0) then
          begin
            pt_pix_arr_row_mrg_top:=i;
            Break;
          end;

      {Find Bottom Margin Value}
      if (pt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
        begin
          pt_pix_arr_row_mrg_btm_ptr:=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
          pt_pix_intr_cnt_arr_ptr   :=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
          for i:=0 to Abs(bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-2) do
            begin
              if (pt_pix_intr_cnt_arr_ptr^<>0) then
                  pt_pix_arr_row_mrg_btm_ptr:=
                  pt_pix_intr_cnt_arr_ptr;
              Inc(pt_pix_intr_cnt_arr_ptr);
            end;
          if     (pt_pix_intr_cnt_arr_ptr^<>0) then
                  pt_pix_arr_row_mrg_btm_ptr:=
                  pt_pix_intr_cnt_arr_ptr;
                  pt_pix_arr_row_mrg_btm:=
        PInteger(@pt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-
        PInteger( pt_pix_arr_row_mrg_btm_ptr);
        end;
    end;
end; {$endregion}
// color and alpha are in one bitmap
// NT - not transparent pixels;
procedure TFastImageProc.CrtNTCountBmpO; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr             : PInteger;
  nt_pix_intr_cnt_arr_ptr   : PInteger;
  nt_pix_arr_row_mrg_btm_ptr: PInteger;
  nt_pix_cnt_row            : integer=0;
  x,y,i                     : integer;
  d_width                   : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        Exit;
      SetLength(nt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
      d_width                :=bmp_ftimg_width-bmp_src_rct_clp.width;
      nt_pix_cnt             :=0;
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000]);
      pix_color_ptr          :=Unaligned(@bmp_color_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          for x:=0 to bmp_src_rct_clp.width-1 do
            begin
              if (pix_color_ptr^>>24=alpha_max) then
                Inc(nt_pix_cnt_row);
              Inc(pix_color_ptr);
            end;
          if (nt_pix_cnt_row<>0) then
            begin
              nt_pix_intr_cnt_arr_ptr^:=nt_pix_cnt_row;
              nt_pix_cnt              +=nt_pix_cnt_row;
              nt_pix_cnt_row          :=0;
            end;
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(pix_color_ptr,d_width);
        end;
      if (nt_pix_cnt=0) then
        Exit;

      {Find Top Margin Value}
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[0]);
      for i:=0 to bmp_src_rct_clp.height-1 do
        if ((nt_pix_intr_cnt_arr_ptr+i)^<>0) then
          begin
            nt_pix_arr_row_mrg_top:=i;
            Break;
          end;

      {Find Bottom Margin Value}
      if (nt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
        begin
          nt_pix_arr_row_mrg_btm_ptr:=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
          nt_pix_intr_cnt_arr_ptr   :=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
          for i:=0 to Abs(bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-2) do
            begin
              if (nt_pix_intr_cnt_arr_ptr^<>0) then
                  nt_pix_arr_row_mrg_btm_ptr:=
                  nt_pix_intr_cnt_arr_ptr;
              Inc(nt_pix_intr_cnt_arr_ptr);
            end;
          if     (nt_pix_intr_cnt_arr_ptr^<>0) then
                  nt_pix_arr_row_mrg_btm_ptr:=
                  nt_pix_intr_cnt_arr_ptr;
                  nt_pix_arr_row_mrg_btm:=
        PInteger(@nt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-
        PInteger( nt_pix_arr_row_mrg_btm_ptr);
        end;
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImageProc.CrtPTCountBmpO; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr             : PInteger;
  pt_pix_intr_cnt_arr_ptr   : PInteger;
  pt_pix_arr_row_mrg_btm_ptr: PInteger;
  pt_pix_cnt_row            : integer=0;
  x,y,i                     : integer;
  d_width                   : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        Exit;
      SetLength(pt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
      d_width                :=bmp_ftimg_width-bmp_src_rct_clp.width;
      pt_pix_cnt             :=0;
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000]);
      pix_color_ptr          :=Unaligned(@bmp_color_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          for x:=0 to bmp_src_rct_clp.width-1 do
            begin
              if (pix_color_ptr^>>24>0) and (pix_color_ptr^>>24<alpha_max) then
                Inc(pt_pix_cnt_row);
              Inc(pix_color_ptr);
            end;
          if (pt_pix_cnt_row<>0) then
            begin
              pt_pix_intr_cnt_arr_ptr^:=pt_pix_cnt_row;
              pt_pix_cnt              +=pt_pix_cnt_row;
              pt_pix_cnt_row          :=0;
            end;
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(pix_color_ptr,d_width);
        end;
      if (pt_pix_cnt=0) then
        Exit;

      {Find Top Margin Value}
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[0]);
      for i:=0 to bmp_src_rct_clp.height-1 do
        if ((pt_pix_intr_cnt_arr_ptr+i)^<>0) then
          begin
            pt_pix_arr_row_mrg_top:=i;
            Break;
          end;

      {Find Bottom Margin Value}
      if (pt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
        begin
          pt_pix_arr_row_mrg_btm_ptr:=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
          pt_pix_intr_cnt_arr_ptr   :=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
          for i:=0 to Abs(bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-2) do
            begin
              if (pt_pix_intr_cnt_arr_ptr^<>0) then
                  pt_pix_arr_row_mrg_btm_ptr:=
                  pt_pix_intr_cnt_arr_ptr;
              Inc(pt_pix_intr_cnt_arr_ptr);
            end;
          if     (pt_pix_intr_cnt_arr_ptr^<>0) then
                  pt_pix_arr_row_mrg_btm_ptr:=
                  pt_pix_intr_cnt_arr_ptr;
                  pt_pix_arr_row_mrg_btm:=
        PInteger(@pt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-
        PInteger( pt_pix_arr_row_mrg_btm_ptr);
        end;
    end;
end; {$endregion} {$endregion}

{Create Array    of Items Counts  in Rows from Array---} {$region -fold}
// NT - not transparent pixels;
procedure TFastImageProc.CrtNTCountArrA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr             : PInteger;
  nt_pix_intr_cnt_arr_ptr   : PInteger;
  nt_pix_arr_row_mrg_btm_ptr: PInteger;
  nt_pix_cnt_row            : integer=0;
  x,y,i,j,n,m               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      nt_pix_cnt_prev:=nt_pix_cnt;
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        begin
          nt_pix_cnt:=0;
          Exit;
        end;
      SetLength(nt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
      nt_pix_cnt             :=0;
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000]);
      pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          j:=NotIndexDWord(pix_alpha_ptr,bmp_src_rct_clp.width);
          if (j<>-1) then
            for x:=j to bmp_src_rct_clp.width-1 do
              if ((pix_alpha_ptr+x)^<>0) then
                Inc(nt_pix_cnt_row);
          if (nt_pix_cnt_row<>0) then
            begin
              nt_pix_intr_cnt_arr_ptr^:=nt_pix_cnt_row;
              nt_pix_cnt              +=nt_pix_cnt_row;
              nt_pix_cnt_row          :=0;
            end;
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(pix_alpha_ptr,bmp_ftimg_width);
        end;
      if (nt_pix_cnt=0) then
        Exit;

      {Find Top Margin Value}
      m:=NotIndexDWord(@nt_pix_intr_cnt_arr[0],bmp_src_rct_clp.height-1);
      if (m=-1) then
        nt_pix_arr_row_mrg_top:=0
      else
        nt_pix_arr_row_mrg_top:=m;

      {Find Bottom Margin Value}
      if (nt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
        begin
          nt_pix_arr_row_mrg_btm    :=0;
          nt_pix_arr_row_mrg_btm_ptr:=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
          nt_pix_intr_cnt_arr_ptr   :=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
          for i:=0 to Abs(bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-2) do
            begin
              if      (nt_pix_intr_cnt_arr_ptr^<>0) then
                       nt_pix_arr_row_mrg_btm_ptr:=
                       nt_pix_intr_cnt_arr_ptr;
              Inc     (nt_pix_intr_cnt_arr_ptr);
            end;
          if          (nt_pix_intr_cnt_arr_ptr^<>0) then
                       nt_pix_arr_row_mrg_btm_ptr:=
                       nt_pix_intr_cnt_arr_ptr;
          n:=PInteger(@nt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-
             PInteger( nt_pix_arr_row_mrg_btm_ptr);
          if (n>0) then
                       nt_pix_arr_row_mrg_btm:=n;
        end;
    end;
end; {$endregion}
procedure TFastImageProc.CrtNTCountArrB; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr             : PByte;
  nt_pix_intr_cnt_arr_ptr   : PInteger;
  nt_pix_arr_row_mrg_btm_ptr: PInteger;
  nt_pix_cnt_row            : integer=0;
  x,y,i,j,n,m               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      nt_pix_cnt_prev:=nt_pix_cnt;
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        begin
          nt_pix_cnt:=0;
          Exit;
        end;
      SetLength(nt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
      nt_pix_cnt             :=0;
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000]);
      pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr2     [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          j:=NotIndexByte(pix_alpha_ptr,bmp_src_rct_clp.width);
          if (j<>-1) then
            for x:=j to bmp_src_rct_clp.width-1 do
              if ((pix_alpha_ptr+x)^<>0) then
                Inc(nt_pix_cnt_row);
          if (nt_pix_cnt_row<>0) then
            begin
              nt_pix_intr_cnt_arr_ptr^:=nt_pix_cnt_row;
              nt_pix_cnt              +=nt_pix_cnt_row;
              nt_pix_cnt_row          :=0;
            end;
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(pix_alpha_ptr,bmp_ftimg_width);
        end;
      if (nt_pix_cnt=0) then
        Exit;

      {Find Top Margin Value}
      m:=NotIndexDWord(@nt_pix_intr_cnt_arr[0],bmp_src_rct_clp.height-1);
      if (m=-1) then
        nt_pix_arr_row_mrg_top:=0
      else
        nt_pix_arr_row_mrg_top:=m;

      {Find Bottom Margin Value}
      if (nt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
        begin
          nt_pix_arr_row_mrg_btm    :=0;
          nt_pix_arr_row_mrg_btm_ptr:=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
          nt_pix_intr_cnt_arr_ptr   :=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
          for i:=0 to Abs(bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-2) do
            begin
              if      (nt_pix_intr_cnt_arr_ptr^<>0) then
                       nt_pix_arr_row_mrg_btm_ptr:=
                       nt_pix_intr_cnt_arr_ptr;
              Inc     (nt_pix_intr_cnt_arr_ptr);
            end;
          if          (nt_pix_intr_cnt_arr_ptr^<>0) then
                       nt_pix_arr_row_mrg_btm_ptr:=
                       nt_pix_intr_cnt_arr_ptr;
          n:=PInteger(@nt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-
             PInteger( nt_pix_arr_row_mrg_btm_ptr);
          if (n>0) then
                       nt_pix_arr_row_mrg_btm:=n;
        end;
    end;
end; {$endregion}
procedure TFastImageProc.CrtNTCountArrC; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr             : PInteger;
  nt_pix_intr_cnt_arr_ptr   : PInteger;
  nt_pix_arr_row_mrg_btm_ptr: PInteger;
  nt_pix_cnt_row            : integer=0;
  x,y,i,j,n,m               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      nt_pix_cnt_prev:=nt_pix_cnt;
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        begin
          nt_pix_cnt:=0;
          Exit;
        end;
      SetLength(nt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
      nt_pix_cnt             :=0;
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000]);
      pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          j:=NotIndexDWord(pix_alpha_ptr,bmp_src_rct_clp.width);
          if (j<>-1) then
            for x:=j to bmp_src_rct_clp.width-1 do
              Inc(nt_pix_cnt_row,((pix_alpha_ptr+x)^+NZ_ITEM_COEFF22)>>NZ_ITEM_COEFF12);
          if (nt_pix_cnt_row<>0) then
            begin
              nt_pix_intr_cnt_arr_ptr^:=nt_pix_cnt_row;
              nt_pix_cnt              +=nt_pix_cnt_row;
              nt_pix_cnt_row          :=0;
            end;
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(pix_alpha_ptr,bmp_ftimg_width);
        end;
      if (nt_pix_cnt=0) then
        Exit;

      {Find Top Margin Value}
      m:=NotIndexDWord(@nt_pix_intr_cnt_arr[0],bmp_src_rct_clp.height-1);
      if (m=-1) then
        nt_pix_arr_row_mrg_top:=0
      else
        nt_pix_arr_row_mrg_top:=m;

      {Find Bottom Margin Value}
      if (nt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
        begin
          nt_pix_arr_row_mrg_btm    :=0;
          nt_pix_arr_row_mrg_btm_ptr:=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
          nt_pix_intr_cnt_arr_ptr   :=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
          for i:=0 to Abs(bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-2) do
            begin
              if      (nt_pix_intr_cnt_arr_ptr^<>0) then
                       nt_pix_arr_row_mrg_btm_ptr:=
                       nt_pix_intr_cnt_arr_ptr;
              Inc     (nt_pix_intr_cnt_arr_ptr);
            end;
          if          (nt_pix_intr_cnt_arr_ptr^<>0) then
                       nt_pix_arr_row_mrg_btm_ptr:=
                       nt_pix_intr_cnt_arr_ptr;
          n:=PInteger(@nt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-
             PInteger( nt_pix_arr_row_mrg_btm_ptr);
          if (n>0) then
                       nt_pix_arr_row_mrg_btm:=n;
        end;
    end;
end; {$endregion}
procedure TFastImageProc.CrtNTCountArrD; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr             : PByte;
  nt_pix_intr_cnt_arr_ptr   : PInteger;
  nt_pix_arr_row_mrg_btm_ptr: PInteger;
  nt_pix_cnt_row            : integer=0;
  x,y,i,j,n,m               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      nt_pix_cnt_prev:=nt_pix_cnt;
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        begin
          nt_pix_cnt:=0;
          Exit;
        end;
      SetLength(nt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
      nt_pix_cnt             :=0;
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000]);
      pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr2     [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          j:=NotIndexByte(pix_alpha_ptr,bmp_src_rct_clp.width);
          if (j<>-1) then
            for x:=j to bmp_src_rct_clp.width-1 do
              Inc(nt_pix_cnt_row,((pix_alpha_ptr+x)^+NZ_ITEM_COEFF20)>>NZ_ITEM_COEFF10);
          if (nt_pix_cnt_row<>0) then
            begin
              nt_pix_intr_cnt_arr_ptr^:=nt_pix_cnt_row;
              nt_pix_cnt              +=nt_pix_cnt_row;
              nt_pix_cnt_row          :=0;
            end;
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(pix_alpha_ptr,bmp_ftimg_width);
        end;
      if (nt_pix_cnt=0) then
        Exit;

      {Find Top Margin Value}
      m:=NotIndexDWord(@nt_pix_intr_cnt_arr[0],bmp_src_rct_clp.height-1);
      if (m=-1) then
        nt_pix_arr_row_mrg_top:=0
      else
        nt_pix_arr_row_mrg_top:=m;

      {Find Bottom Margin Value}
      if (nt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
        begin
          nt_pix_arr_row_mrg_btm    :=0;
          nt_pix_arr_row_mrg_btm_ptr:=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
          nt_pix_intr_cnt_arr_ptr   :=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
          for i:=0 to Abs(bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-2) do
            begin
              if      (nt_pix_intr_cnt_arr_ptr^<>0) then
                       nt_pix_arr_row_mrg_btm_ptr:=
                       nt_pix_intr_cnt_arr_ptr;
              Inc     (nt_pix_intr_cnt_arr_ptr);
            end;
          if          (nt_pix_intr_cnt_arr_ptr^<>0) then
                       nt_pix_arr_row_mrg_btm_ptr:=
                       nt_pix_intr_cnt_arr_ptr;
          n:=PInteger(@nt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-
             PInteger( nt_pix_arr_row_mrg_btm_ptr);
          if (n>0) then
                       nt_pix_arr_row_mrg_btm:=n;
        end;
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImageProc.CrtPTCountArrA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr             : PInteger;
  pt_pix_intr_cnt_arr_ptr   : PInteger;
  pt_pix_arr_row_mrg_btm_ptr: PInteger;
  pt_pix_cnt_row            : integer=0;
  x,y,i,j,p,m               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      pt_pix_cnt_prev:=pt_pix_cnt;
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        begin
          pt_pix_cnt:=0;
          Exit;
        end;
      SetLength(pt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
      pt_pix_cnt             :=0;
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000]);
      pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          for x:=0 to bmp_src_rct_clp.width-1 do
            if ((pix_alpha_ptr+x)^>>24<>0) and ((pix_alpha_ptr+x)^>>24<>alpha_max) then
              Inc(pt_pix_cnt_row);
          if (pt_pix_cnt_row<>0) then
            begin
              pt_pix_intr_cnt_arr_ptr^:=pt_pix_cnt_row;
              pt_pix_cnt              +=pt_pix_cnt_row;
              pt_pix_cnt_row          :=0;
            end;
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(pix_alpha_ptr,bmp_ftimg_width);
        end;
      if (pt_pix_cnt=0) then
        Exit;

      {Find Top Margin Value}
      m:=NotIndexDWord(@pt_pix_intr_cnt_arr[0],bmp_src_rct_clp.height-1);
      if (m=-1) then
        pt_pix_arr_row_mrg_top:=0
      else
        pt_pix_arr_row_mrg_top:=m;

      {Find Bottom Margin Value}
      if (pt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
        begin
          pt_pix_arr_row_mrg_btm_ptr:=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
          pt_pix_intr_cnt_arr_ptr   :=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
          for i:=0 to Abs(bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-2) do
            begin
              if      (pt_pix_intr_cnt_arr_ptr^<>0) then
                       pt_pix_arr_row_mrg_btm_ptr:=
                       pt_pix_intr_cnt_arr_ptr;
              Inc     (pt_pix_intr_cnt_arr_ptr);
            end;
          if          (pt_pix_intr_cnt_arr_ptr^<>0) then
                       pt_pix_arr_row_mrg_btm_ptr:=
                       pt_pix_intr_cnt_arr_ptr;
          p:=PInteger(@pt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-
             PInteger( pt_pix_arr_row_mrg_btm_ptr);
          if (p>0) then
                       pt_pix_arr_row_mrg_btm:=p;
        end;
    end;
end; {$endregion}
procedure TFastImageProc.CrtPTCountArrB; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr             : PByte;
  pt_pix_intr_cnt_arr_ptr   : PInteger;
  pt_pix_arr_row_mrg_btm_ptr: PInteger;
  pt_pix_cnt_row            : integer=0;
  x,y,i,j,p,m               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      pt_pix_cnt_prev:=pt_pix_cnt;
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        begin
          pt_pix_cnt:=0;
          Exit;
        end;
      SetLength(pt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
      pt_pix_cnt             :=0;
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000]);
      pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr2     [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          for x:=0 to bmp_src_rct_clp.width-1 do
            if ((pix_alpha_ptr+x)^<>0) and ((pix_alpha_ptr+x)^<>alpha_max) then
              Inc(pt_pix_cnt_row);
          if (pt_pix_cnt_row<>0) then
            begin
              pt_pix_intr_cnt_arr_ptr^:=pt_pix_cnt_row;
              pt_pix_cnt         +=pt_pix_cnt_row;
              pt_pix_cnt_row     :=0;
            end;
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(pix_alpha_ptr,bmp_ftimg_width);
        end;
      if (pt_pix_cnt=0) then
        Exit;

      {Find Top Margin Value}
      m:=NotIndexDWord(@pt_pix_intr_cnt_arr[0],bmp_src_rct_clp.height-1);
      if (m=-1) then
        pt_pix_arr_row_mrg_top:=0
      else
        pt_pix_arr_row_mrg_top:=m;

      {Find Bottom Margin Value}
      if (pt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
        begin
          pt_pix_arr_row_mrg_btm_ptr:=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
          pt_pix_intr_cnt_arr_ptr   :=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
          for i:=0 to Abs(bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-2) do
            begin
              if      (pt_pix_intr_cnt_arr_ptr^<>0) then
                       pt_pix_arr_row_mrg_btm_ptr:=
                       pt_pix_intr_cnt_arr_ptr;
              Inc     (pt_pix_intr_cnt_arr_ptr);
            end;
          if          (pt_pix_intr_cnt_arr_ptr^<>0) then
                       pt_pix_arr_row_mrg_btm_ptr:=
                       pt_pix_intr_cnt_arr_ptr;
          p:=PInteger(@pt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-
             PInteger( pt_pix_arr_row_mrg_btm_ptr);
          if (p>0) then
                       pt_pix_arr_row_mrg_btm:=p;
        end;
    end;
end; {$endregion}
procedure TFastImageProc.CrtPTCountArrC; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr             : PInteger;
  pt_pix_intr_cnt_arr_ptr   : PInteger;
  pt_pix_arr_row_mrg_btm_ptr: PInteger;
  pt_pix_cnt_row            : integer=0;
  x,y,i,j,p,m               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      pt_pix_cnt_prev:=pt_pix_cnt;
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        begin
          pt_pix_cnt:=0;
          Exit;
        end;
      SetLength(pt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
      pt_pix_cnt             :=0;
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000]);
      pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          for x:=0 to bmp_src_rct_clp.width-1 do
            if ((pix_alpha_ptr+x)^>>24<>0) and ((pix_alpha_ptr+x)^>>24<>alpha_max) then
              Inc(pt_pix_cnt_row);
          if (pt_pix_cnt_row<>0) then
            begin
              pt_pix_intr_cnt_arr_ptr^:=pt_pix_cnt_row;
              pt_pix_cnt              +=pt_pix_cnt_row;
              pt_pix_cnt_row          :=0;
            end;
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(pix_alpha_ptr,bmp_ftimg_width);
        end;
      if (pt_pix_cnt=0) then
        Exit;

      {Find Top Margin Value}
      m:=NotIndexDWord(@pt_pix_intr_cnt_arr[0],bmp_src_rct_clp.height-1);
      if (m=-1) then
        pt_pix_arr_row_mrg_top:=0
      else
        pt_pix_arr_row_mrg_top:=m;

      {Find Bottom Margin Value}
      if (pt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
        begin
          pt_pix_arr_row_mrg_btm_ptr:=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
          pt_pix_intr_cnt_arr_ptr   :=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
          for i:=0 to Abs(bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-2) do
            begin
              if      (pt_pix_intr_cnt_arr_ptr^<>0) then
                       pt_pix_arr_row_mrg_btm_ptr:=
                       pt_pix_intr_cnt_arr_ptr;
              Inc     (pt_pix_intr_cnt_arr_ptr);
            end;
          if          (pt_pix_intr_cnt_arr_ptr^<>0) then
                       pt_pix_arr_row_mrg_btm_ptr:=
                       pt_pix_intr_cnt_arr_ptr;
          p:=PInteger(@pt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-
             PInteger( pt_pix_arr_row_mrg_btm_ptr);
          if (p>0) then
                       pt_pix_arr_row_mrg_btm:=p;
        end;
    end;
end; {$endregion}
procedure TFastImageProc.CrtPTCountArrD; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr             : PByte;
  pt_pix_intr_cnt_arr_ptr   : PInteger;
  pt_pix_arr_row_mrg_btm_ptr: PInteger;
  pt_pix_cnt_row            : integer=0;
  x,y,i,j,p,m               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      pt_pix_cnt_prev:=pt_pix_cnt;
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        begin
          pt_pix_cnt:=0;
          Exit;
        end;
      SetLength(pt_pix_intr_cnt_arr,bmp_src_rct_clp.height);
      pt_pix_cnt             :=0;
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000000000000000000000000000000000000000000000]);
      pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr2     [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          for x:=0 to bmp_src_rct_clp.width-1 do
            if ((pix_alpha_ptr+x)^<>0) and ((pix_alpha_ptr+x)^<>alpha_max) then
              Inc(pt_pix_cnt_row);
          if (pt_pix_cnt_row<>0) then
            begin
              pt_pix_intr_cnt_arr_ptr^:=pt_pix_cnt_row;
              pt_pix_cnt              +=pt_pix_cnt_row;
              pt_pix_cnt_row          :=0;
            end;
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(pix_alpha_ptr,bmp_ftimg_width);
        end;
      if (pt_pix_cnt=0) then
        Exit;

      {Find Top Margin Value}
      m:=NotIndexDWord(@pt_pix_intr_cnt_arr[0],bmp_src_rct_clp.height-1);
      if (m=-1) then
        pt_pix_arr_row_mrg_top:=0
      else
        pt_pix_arr_row_mrg_top:=m;

      {Find Bottom Margin Value}
      if (pt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
        begin
          pt_pix_arr_row_mrg_btm_ptr:=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
          pt_pix_intr_cnt_arr_ptr   :=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
          for i:=0 to Abs(bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-2) do
            begin
              if (pt_pix_intr_cnt_arr_ptr^<>0) then
                pt_pix_arr_row_mrg_btm_ptr:=pt_pix_intr_cnt_arr_ptr;
              Inc(pt_pix_intr_cnt_arr_ptr);
            end;
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            pt_pix_arr_row_mrg_btm_ptr:=pt_pix_intr_cnt_arr_ptr;
          p:=PInteger(@pt_pix_intr_cnt_arr[bmp_src_rct_clp.height-1])-PInteger(pt_pix_arr_row_mrg_btm_ptr);
          if (p>0) then
            pt_pix_arr_row_mrg_btm:=p;
        end;
    end;
end; {$endregion} {$endregion}

{Create Array    of Items Shifts  in Rows from Bitmap--} {$region -fold}
// color and alpha are in separate bitmaps
// NT - not transparent pixels;
procedure TFastImageProc.CrtNTShiftBmpS; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_sht_arr_ptr: PInteger;
  pix_alpha_ptr          : PInteger;
  x,y                    : integer;
  d_width                : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        Exit;
      if (nt_pix_cnt=0) then
        Exit;
      SetLength(nt_pix_intr_sht_arr,nt_pix_cnt);
      d_width                :=bmp_ftimg_width-bmp_src_rct_clp.width;
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000]);
      pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          for x:=0 to bmp_src_rct_clp.width-1 do
            begin
              if (pix_alpha_ptr^=$FFFFFF) then
                begin
                      nt_pix_intr_sht_arr_ptr^:=x;
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc(pix_alpha_ptr);
            end;
          Inc(pix_alpha_ptr,d_width);
        end;
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImageProc.CrtPTShiftBmpS; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_intr_sht_arr_ptr: PInteger;
  pix_alpha_ptr          : PByte;
  x,y                    : integer;
  d_width                : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        Exit;
      if (pt_pix_cnt=0) then
        Exit;
      SetLength(pt_pix_intr_sht_arr,pt_pix_cnt);
      d_width                :=bmp_ftimg_width-bmp_src_rct_clp.width;
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000]);
      pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          for x:=0 to bmp_src_rct_clp.width-1 do
            begin
              if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<alpha_max) then
                begin
                      pt_pix_intr_sht_arr_ptr^:=x;
                  Inc(pt_pix_intr_sht_arr_ptr);
                end;
              Inc(pix_alpha_ptr,4);
            end;
          Inc(pix_alpha_ptr,d_width<<2);
        end;
    end;
end; {$endregion}
// color and alpha are in one bitmap
// NT - not transparent pixels;
procedure TFastImageProc.CrtNTShiftBmpO; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_sht_arr_ptr: PInteger;
  pix_color_ptr          : PInteger;
  x,y                    : integer;
  d_width                : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        Exit;
      if (nt_pix_cnt=0) then
        Exit;
      SetLength(nt_pix_intr_sht_arr,nt_pix_cnt);
      d_width                :=bmp_ftimg_width-bmp_src_rct_clp.width;
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000]);
      pix_color_ptr          :=Unaligned(@bmp_color_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          for x:=0 to bmp_src_rct_clp.width-1 do
            begin
              if (pix_color_ptr^>>24=alpha_max) then
                begin
                      nt_pix_intr_sht_arr_ptr^:=x{+bmp_src_rct_clp.left};
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc(pix_color_ptr);
            end;
          Inc(pix_color_ptr,d_width);
        end;
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImageProc.CrtPTShiftBmpO; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_intr_sht_arr_ptr: PInteger;
  pix_color_ptr          : PInteger;
  x,y                    : integer;
  d_width                : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        Exit;
      if (pt_pix_cnt=0) then
        Exit;
      SetLength(pt_pix_intr_sht_arr,pt_pix_cnt);
      d_width                :=bmp_ftimg_width-bmp_src_rct_clp.width;
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000]);
      pix_color_ptr          :=Unaligned(@bmp_color_ptr      [bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          for x:=0 to bmp_src_rct_clp.width-1 do
            begin
              if (pix_color_ptr^>>24>0) and (pix_color_ptr^>>24<alpha_max) then
                begin
                      pt_pix_intr_sht_arr_ptr^:=x{+bmp_src_rct_clp.left};
                  Inc(pt_pix_intr_sht_arr_ptr);
                end;
              Inc(pix_color_ptr);
            end;
          Inc(pix_color_ptr,d_width);
        end;
    end;
end; {$endregion} {$endregion}

{Create Array    of Items Shifts  in Rows from Array---} {$region -fold}
// NT - not transparent pixels;
procedure TFastImageProc.CrtNTShiftArrA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr          : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y,pix_cnt_in_a_row   : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (nt_pix_cnt=0) then
        begin
          //nt_pix_intr_sht_arr:=Nil;
          Exit;
        end;
      //SetLength(nt_pix_intr_sht_arr,0);
      if (nt_pix_cnt>Length(nt_pix_intr_sht_arr)) or (nt_pix_intr_sht_arr=Nil) or ((nt_pix_cnt_prev<nt_pix_cnt) and realloc_mem) then
        SetLength(nt_pix_intr_sht_arr,nt_pix_cnt);
      pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr      [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_cnt_in_a_row:=0;
              for x:=NotIndexDWord(pix_alpha_ptr,bmp_src_rct_clp.width-1) to bmp_src_rct_clp.width-1 do
                if ((pix_alpha_ptr+x)^{>}<>0) then
                  begin
                        nt_pix_intr_sht_arr_ptr^:=x;
                    Inc(nt_pix_intr_sht_arr_ptr);
                    Inc(pix_cnt_in_a_row);
                    if (pix_cnt_in_a_row=nt_pix_intr_cnt_arr_ptr^) then
                      Break;
                  end;
            end;
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(pix_alpha_ptr,bmp_ftimg_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.CrtNTShiftArrB; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr          : PByte;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y,pix_cnt_in_a_row   : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (nt_pix_cnt=0) then
        begin
          //nt_pix_intr_sht_arr:=Nil;
          Exit;
        end;
      //SetLength(nt_pix_intr_sht_arr,0);
      if (nt_pix_cnt>Length(nt_pix_intr_sht_arr)) or (nt_pix_intr_sht_arr=Nil) or ((nt_pix_cnt_prev<nt_pix_cnt) and realloc_mem) then
        SetLength(nt_pix_intr_sht_arr,nt_pix_cnt);
      pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr2     [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_cnt_in_a_row:=0;
              for x:={0}NotIndexByte(pix_alpha_ptr,bmp_src_rct_clp.width-1) to bmp_src_rct_clp.width-1 do
                if ((pix_alpha_ptr+x)^{>}<>0) then
                  begin
                        nt_pix_intr_sht_arr_ptr^:=x;
                    Inc(nt_pix_intr_sht_arr_ptr);
                    Inc(pix_cnt_in_a_row);
                    if (pix_cnt_in_a_row=nt_pix_intr_cnt_arr_ptr^) then
                      Break;
                  end;
            end;
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(pix_alpha_ptr,bmp_ftimg_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.CrtNTShiftArrC; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr          : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y,pix_cnt_in_a_row   : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (nt_pix_cnt=0) then
        begin
          //nt_pix_intr_sht_arr:=Nil;
          Exit;
        end;
      //SetLength(nt_pix_intr_sht_arr,0);
      if (nt_pix_cnt>Length(nt_pix_intr_sht_arr)) or (nt_pix_intr_sht_arr=Nil) or ((nt_pix_cnt_prev<nt_pix_cnt) and realloc_mem) then
        SetLength(nt_pix_intr_sht_arr,nt_pix_cnt);
      pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr      [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_cnt_in_a_row:=0;
              for x:=IndexDWord{IndexByte}(pix_alpha_ptr^,bmp_src_rct_clp.width-1,1) to bmp_src_rct_clp.width-1 do
                if ((pix_alpha_ptr+x)^=1) then
                  begin
                        nt_pix_intr_sht_arr_ptr^:=x;
                    Inc(nt_pix_intr_sht_arr_ptr);
                    Inc(pix_cnt_in_a_row);
                    if (pix_cnt_in_a_row=nt_pix_intr_cnt_arr_ptr^) then
                      Break;
                  end;
            end;
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(pix_alpha_ptr,bmp_ftimg_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.CrtNTShiftArrD; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr          : PByte;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y,pix_cnt_in_a_row   : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (nt_pix_cnt=0) then
        begin
          //nt_pix_intr_sht_arr:=Nil;
          Exit;
        end;
      //SetLength(nt_pix_intr_sht_arr,0);
      if (nt_pix_cnt>Length(nt_pix_intr_sht_arr)) or (nt_pix_intr_sht_arr=Nil) or ((nt_pix_cnt_prev<nt_pix_cnt) and realloc_mem) then
        SetLength(nt_pix_intr_sht_arr,nt_pix_cnt);
      pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr2     [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_cnt_in_a_row:=0;
              for x:=IndexByte(pix_alpha_ptr^,bmp_src_rct_clp.width-1,1) to bmp_src_rct_clp.width-1 do
                if ((pix_alpha_ptr+x)^=1) then
                  begin
                        nt_pix_intr_sht_arr_ptr^:=x;
                    Inc(nt_pix_intr_sht_arr_ptr);
                    Inc(pix_cnt_in_a_row);
                    if (pix_cnt_in_a_row=nt_pix_intr_cnt_arr_ptr^) then
                      Break;
                  end;
            end;
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(pix_alpha_ptr,bmp_ftimg_width);
        end;
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImageProc.CrtPTShiftArrA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr          : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y,pix_cnt_in_a_row   : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (pt_pix_cnt=0) then
        begin
          //pt_pix_intr_sht_arr:=Nil;
          Exit;
        end;
      //SetLength(pt_pix_intr_sht_arr,0);
      if (pt_pix_cnt>Length(pt_pix_intr_sht_arr)) or (pt_pix_intr_sht_arr=Nil) or ((pt_pix_cnt_prev<pt_pix_cnt) and realloc_mem) then
        SetLength(pt_pix_intr_sht_arr,pt_pix_cnt);
      pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr      [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_cnt_in_a_row:=0;
              for x:=NotIndexDWord(pix_alpha_ptr,bmp_src_rct_clp.width-1) to bmp_src_rct_clp.width-1 do
                if ((pix_alpha_ptr+x)^{>}<>0) then
                  begin
                        pt_pix_intr_sht_arr_ptr^:=x;
                    Inc(pt_pix_intr_sht_arr_ptr);
                    Inc(pix_cnt_in_a_row);
                    if (pix_cnt_in_a_row=pt_pix_intr_cnt_arr_ptr^) then
                      Break;
                  end;
            end;
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(pix_alpha_ptr,bmp_ftimg_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.CrtPTShiftArrB; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr          : PByte;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y,pix_cnt_in_a_row   : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (pt_pix_cnt=0) then
        begin
          //pt_pix_intr_sht_arr:=Nil;
          Exit;
        end;
      //SetLength(pt_pix_intr_sht_arr,0);
      if (pt_pix_cnt>Length(pt_pix_intr_sht_arr)) or (pt_pix_intr_sht_arr=Nil) or ((pt_pix_cnt_prev<pt_pix_cnt) and realloc_mem) then
        SetLength(pt_pix_intr_sht_arr,pt_pix_cnt);
      pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr2     [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_cnt_in_a_row:=0;
              for x:={0}NotIndexByte(pix_alpha_ptr,bmp_src_rct_clp.width-1) to bmp_src_rct_clp.width-1 do
                if ((pix_alpha_ptr+x)^{>}<>0) then
                  begin
                        pt_pix_intr_sht_arr_ptr^:=x;
                    Inc(pt_pix_intr_sht_arr_ptr);
                    Inc(pix_cnt_in_a_row);
                    if (pix_cnt_in_a_row=pt_pix_intr_cnt_arr_ptr^) then
                      Break;
                  end;
            end;
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(pix_alpha_ptr,bmp_ftimg_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.CrtPTShiftArrC; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr          : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y,pix_cnt_in_a_row   : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (pt_pix_cnt=0) then
        begin
          //pt_pix_intr_sht_arr:=Nil;
          Exit;
        end;
      //SetLength(pt_pix_intr_sht_arr,0);
      if (pt_pix_cnt>Length(pt_pix_intr_sht_arr)) or (pt_pix_intr_sht_arr=Nil) or ((pt_pix_cnt_prev<pt_pix_cnt) and realloc_mem) then
        SetLength(pt_pix_intr_sht_arr,pt_pix_cnt);
      pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr      [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_cnt_in_a_row:=0;
              for x:=IndexDWord{IndexByte}(pix_alpha_ptr^,bmp_src_rct_clp.width-1,1) to bmp_src_rct_clp.width-1 do
                if ((pix_alpha_ptr+x)^=1) then
                  begin
                        pt_pix_intr_sht_arr_ptr^:=x;
                    Inc(pt_pix_intr_sht_arr_ptr);
                    Inc(pix_cnt_in_a_row);
                    if (pix_cnt_in_a_row=pt_pix_intr_cnt_arr_ptr^) then
                      Break;
                  end;
            end;
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(pix_alpha_ptr,bmp_ftimg_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.CrtPTShiftArrD; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr          : PByte;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y,pix_cnt_in_a_row   : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (pt_pix_cnt=0) then
        begin
          //pt_pix_intr_sht_arr:=Nil;
          Exit;
        end;
      //SetLength(pt_pix_intr_sht_arr,0);
      if (pt_pix_cnt>Length(pt_pix_intr_sht_arr)) or (pt_pix_intr_sht_arr=Nil) or ((pt_pix_cnt_prev<pt_pix_cnt) and realloc_mem) then
        SetLength(pt_pix_intr_sht_arr,pt_pix_cnt);
      pix_alpha_ptr          :=Unaligned(@bmp_alpha_ptr2     [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_cnt_in_a_row:=0;
              for x:=IndexByte(pix_alpha_ptr^,bmp_src_rct_clp.width-1,1) to bmp_src_rct_clp.width-1 do
                if ((pix_alpha_ptr+x)^=1) then
                  begin
                        pt_pix_intr_sht_arr_ptr^:=x;
                    Inc(pt_pix_intr_sht_arr_ptr);
                    Inc(pix_cnt_in_a_row);
                    if (pix_cnt_in_a_row=pt_pix_intr_cnt_arr_ptr^) then
                      Break;
                  end;
            end;
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(pix_alpha_ptr,bmp_ftimg_width);
        end;
    end;
end; {$endregion} {$endregion}

{Create Array    of Items Indices in Rows from Array---} {$region -fold}
procedure TFastImageProc.CrtNTCntIndArr; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_cnt_ind_arr_ptr     : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  i                      : integer;
  s                      : longword;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        Exit;
      if (nt_pix_cnt=0) then
        Exit;
      SetLength(nt_cnt_ind_arr,0);
      SetLength(nt_cnt_ind_arr,bmp_src_rct_clp.height);
      nt_cnt_ind_arr_ptr     :=Unaligned(@nt_cnt_ind_arr     [0]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[0]);
      s:=0;
      for i:=0 to bmp_src_rct_clp.height-1 do
        begin
              nt_cnt_ind_arr_ptr^:=s;
          Inc(nt_cnt_ind_arr_ptr);
          s+= nt_pix_intr_cnt_arr_ptr^;
          Inc(nt_pix_intr_cnt_arr_ptr);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.CrtPTCntIndArr; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_cnt_ind_arr_ptr     : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  i                      : integer;
  s                      : longword;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        Exit;
      if (pt_pix_cnt=0) then
        Exit;
      SetLength(pt_cnt_ind_arr,0);
      SetLength(pt_cnt_ind_arr,bmp_src_rct_clp.height);
      pt_cnt_ind_arr_ptr     :=Unaligned(@pt_cnt_ind_arr     [0]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[0]);
      s:=0;
      for i:=0 to bmp_src_rct_clp.height-1 do
        begin
              pt_cnt_ind_arr_ptr^:=s;
          Inc(pt_cnt_ind_arr_ptr);
          s+= pt_pix_intr_cnt_arr_ptr^;
          Inc(pt_pix_intr_cnt_arr_ptr);
        end;
    end;
end; {$endregion} {$endregion}

{Store Color     of Current Layer         from Bmp/Arr-} {$region -fold}
// NT - not transparent pixels;
{store color channel}
procedure TFastImageProc.StrNTColorBmpA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (nt_pix_cnt=0) then
        Exit;
      SetLength(nt_pix_intr_ccl_arr,nt_pix_cnt);
      first_row_pix_ptr      :=Unaligned(@bmp_color_ptr      [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      nt_pix_intr_ccl_arr_ptr:=Unaligned(@nt_pix_intr_ccl_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
                  nt_pix_intr_ccl_arr_ptr^:=(pix_color_ptr+nt_pix_intr_sht_arr_ptr^)^;
              Inc(nt_pix_intr_sht_arr_ptr);
              Inc(nt_pix_intr_ccl_arr_ptr);
            end;
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_ftimg_width);
        end;
    end;
end; {$endregion}
// PT - partly transparent pixels;
{store color channel}
procedure TFastImageProc.StrPTColorBmpA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (pt_pix_cnt=0) then
        Exit;
      SetLength(pt_pix_intr_ccl_arr,pt_pix_cnt);
      first_row_pix_ptr      :=Unaligned(@bmp_color_ptr      [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      pt_pix_intr_ccl_arr_ptr:=Unaligned(@pt_pix_intr_ccl_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                  pt_pix_intr_ccl_arr_ptr^:=(pix_color_ptr+pt_pix_intr_sht_arr_ptr^)^;
              Inc(pt_pix_intr_sht_arr_ptr);
              Inc(pt_pix_intr_ccl_arr_ptr);
            end;
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_ftimg_width);
        end;
    end;
end; {$endregion}
//** color and alpha are in separate bitmaps
{store alpha channel into byte array---}
procedure TFastImageProc.StrPTAlphaArrS; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr          : PByte;
  first_row_pix_ptr      : PByte;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (pt_pix_cnt=0) then
        Exit;
      SetLength(pt_pix_byte_acl_arr,pt_pix_cnt);
      first_row_pix_ptr      :=Unaligned(@bmp_alpha_ptr      [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          pix_alpha_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                  pt_pix_byte_acl_arr_ptr^:=(pix_alpha_ptr+pt_pix_intr_sht_arr_ptr^<<2)^;
              Inc(pt_pix_intr_sht_arr_ptr);
              Inc(pt_pix_byte_acl_arr_ptr);
            end;
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_ftimg_width<<2);
        end;
    end;
end; {$endregion}
{store alpha channel into color channel}
procedure TFastImageProc.StrPTAlphaBmpS; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr          : PByte;
  first_row_pix_ptr      : PByte;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (pt_pix_cnt=0) then
        Exit;
      first_row_pix_ptr      :=Unaligned(@bmp_alpha_ptr      [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      pt_pix_intr_ccl_arr_ptr:=Unaligned(@pt_pix_intr_ccl_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          pix_alpha_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                  pt_pix_intr_ccl_arr_ptr^+=(pix_alpha_ptr+pt_pix_intr_sht_arr_ptr^<<2)^<<24;
              Inc(pt_pix_intr_sht_arr_ptr);
              Inc(pt_pix_intr_ccl_arr_ptr);
            end;
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_ftimg_width<<2);
        end;
    end;
end; {$endregion}
//** color and alpha are in one bitmap
{store alpha channel into byte array---}
procedure TFastImageProc.StrPTAlphaArrO; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (pt_pix_cnt=0) then
        Exit;
      SetLength(pt_pix_byte_acl_arr,pt_pix_cnt);
      first_row_pix_ptr      :=Unaligned(@bmp_color_ptr      [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                  pt_pix_byte_acl_arr_ptr^:=(pix_color_ptr+pt_pix_intr_sht_arr_ptr^)^>>24;
              Inc(pt_pix_intr_sht_arr_ptr);
              Inc(pt_pix_byte_acl_arr_ptr);
            end;
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_ftimg_width);
        end;
    end;
end; {$endregion}
{store alpha channel into color channel}
procedure TFastImageProc.StrPTAlphaBmpO; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (pt_pix_cnt=0) then
        Exit;
      first_row_pix_ptr      :=Unaligned(@bmp_color_ptr      [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      pt_pix_intr_ccl_arr_ptr:=Unaligned(@pt_pix_intr_ccl_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                  pt_pix_intr_ccl_arr_ptr^:=(pix_color_ptr+pt_pix_intr_sht_arr_ptr^)^;
              Inc(pt_pix_intr_sht_arr_ptr);
              Inc(pt_pix_intr_ccl_arr_ptr);
            end;
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_ftimg_width);
        end;
    end;
end; {$endregion} {$endregion}

{Store Color     of Lower   Layer         from Bitmap--} {$region -fold}
// NT - not transparent pixels;
procedure TFastImageProc.StrNTLowerBmpA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_cll_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (nt_pix_cnt=0) then
        begin
          //nt_pix_intr_cll_arr:=Nil;
          Exit;
        end;
      //SetLength(nt_pix_intr_cll_arr,0);
      if (nt_pix_cnt>Length(nt_pix_intr_cll_arr)) or (nt_pix_intr_cll_arr=Nil) then
        SetLength(nt_pix_intr_cll_arr,nt_pix_cnt);
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top+{bmp_src_rct_clp.top}bmp_ftimg_top)*bmp_bkgnd_width+{bmp_src_rct_clp.left}bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      nt_pix_intr_cll_arr_ptr:=Unaligned(@nt_pix_intr_cll_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
                  nt_pix_intr_cll_arr_ptr^:=(pix_color_ptr+nt_pix_intr_sht_arr_ptr^)^;
              Inc(nt_pix_intr_sht_arr_ptr);
              Inc(nt_pix_intr_cll_arr_ptr);
            end;
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImageProc.StrPTLowerBmpA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_cll_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (pt_pix_cnt=0) then
        begin
          //pt_pix_intr_cll_arr:=Nil;
          Exit;
        end;
      //SetLength(nt_pix_intr_cll_arr,0);
      if (pt_pix_cnt>Length(pt_pix_intr_cll_arr)) or (pt_pix_intr_cll_arr=Nil) then
        SetLength(pt_pix_intr_cll_arr,pt_pix_cnt);
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
      pt_pix_intr_cll_arr_ptr:=Unaligned(@pt_pix_intr_cll_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                  pt_pix_intr_cll_arr_ptr^:=(pix_color_ptr+pt_pix_intr_sht_arr_ptr^)^;
              Inc(pt_pix_intr_sht_arr_ptr);
              Inc(pt_pix_intr_cll_arr_ptr);
            end;
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// store alpha from byte array;
procedure TFastImageProc.StrPTLowerArrA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_intr_cll_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  i                      : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      pt_pix_intr_cll_arr_ptr:=Unaligned(@pt_pix_intr_cll_arr[0]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[0]);
      for i:=0 to pt_pix_cnt-1 do
        begin
              pt_pix_intr_cll_arr_ptr^+=pt_pix_byte_acl_arr_ptr^<<24;
          Inc(pt_pix_intr_cll_arr_ptr);
          Inc(pt_pix_byte_acl_arr_ptr);
        end;
    end;
end; {$endregion} {$endregion}

{Store Value     of Current Layer         from Array---} {$region -fold}
procedure TFastImageProc.StrNTValueArrA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_value_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_val_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (nt_pix_cnt=0) then
        begin
          //nt_pix_intr_val_arr:=Nil;
          Exit;
        end;
      //SetLength(nt_pix_intr_val_arr,0);
      if (nt_pix_cnt>Length(nt_pix_intr_val_arr)) or (nt_pix_intr_val_arr=Nil) then
        SetLength(nt_pix_intr_val_arr,nt_pix_cnt);
      first_row_pix_ptr      :=Unaligned(@bmp_value_ptr      [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width+bmp_src_rct_clp.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      nt_pix_intr_val_arr_ptr:=Unaligned(@nt_pix_intr_val_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          pix_value_ptr:=first_row_pix_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
                  nt_pix_intr_val_arr_ptr^:=(pix_value_ptr+nt_pix_intr_sht_arr_ptr^)^;
              Inc(nt_pix_intr_sht_arr_ptr);
              Inc(nt_pix_intr_val_arr_ptr);
            end;
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_ftimg_width);
        end;
    end;
end; {$endregion} {$endregion}

{Set Chess Order of Alpha Channel in Rows from Bitmap--} {$region -fold}
// calculation of image sides Parity}
procedure TFastImageProc.CalcSidesParity; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      width_parity :=not Odd(bmp_src_rct_clp.width );
      height_parity:=not Odd(bmp_src_rct_clp.height);
    end;
end; {$endregion}
// color and alpha are in separate bitmaps
// NT - not transparent pixels;
procedure TFastImageProc.SetNTChessBmpS0; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr: PInteger;
  x,y,w,h      : integer;
  d_width      : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (bmp_src_rct_clp.width*bmp_src_rct_clp.height<6) then
        Exit;
      w            :=Trunc(bmp_src_rct_clp.width /2)-1;
      h            :=Trunc(bmp_src_rct_clp.height/2)-1;
      d_width      :=bmp_ftimg_width-bmp_src_rct_clp.width;
      pix_alpha_ptr:=Unaligned(@bmp_alpha_ptr[bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
      if width_parity then
        begin
          if height_parity then
            for y:=0 to h do
              begin
                for x:=0 to w do
                  begin
                    if (pix_alpha_ptr^=$FFFFFF) then
                      pix_alpha_ptr^:=$000000;
                    Inc(pix_alpha_ptr,2);
                  end;
                Inc(pix_alpha_ptr,d_width);
                Dec(pix_alpha_ptr);
                for x:=0 to w do
                  begin
                    if (pix_alpha_ptr^=$FFFFFF) then
                      pix_alpha_ptr^:=$000000;
                    Inc(pix_alpha_ptr,2);
                  end;
                Inc(pix_alpha_ptr,d_width);
                Inc(pix_alpha_ptr);
              end
          else
            begin
              for x:=0 to w do
                begin
                  if (pix_alpha_ptr^=$FFFFFF) then
                    pix_alpha_ptr^:=$000000;
                  Inc(pix_alpha_ptr,2);
                end;
              Inc(pix_alpha_ptr,d_width);
            end;
        end
      else
        for y:=0 to bmp_src_rct_clp.height-1 do
          begin
            for x:=0 to w do
              begin
                if (pix_alpha_ptr^=$FFFFFF) then
                  pix_alpha_ptr^:=$000000;
                Inc(pix_alpha_ptr,2);
              end;
            Inc(pix_alpha_ptr,d_width);
          end;
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImageProc.SetPTChessBmpS0; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr: PByte;
  x,y,w,h      : integer;
  d_width      : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (bmp_src_rct_clp.width*bmp_src_rct_clp.height<6) then
        Exit;
      w            :=Trunc(bmp_src_rct_clp.width /2)-1;
      h            :=Trunc(bmp_src_rct_clp.height/2)-1;
      d_width      :=bmp_ftimg_width-bmp_src_rct_clp.width;
      pix_alpha_ptr:=Unaligned(@bmp_alpha_ptr[bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
      if width_parity then
        begin
          if height_parity then
            for y:=0 to h do
              begin
                for x:=0 to w do
                  begin
                    if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<alpha_max) then
                      pix_alpha_ptr^:=$000000;
                    Inc(pix_alpha_ptr,8);
                  end;
                Inc(pix_alpha_ptr,d_width<<2);
                Dec(pix_alpha_ptr,4);
                for x:=0 to w do
                  begin
                    if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<alpha_max) then
                      pix_alpha_ptr^:=$000000;
                    Inc(pix_alpha_ptr,8);
                  end;
                Inc(pix_alpha_ptr,d_width<<2);
                Inc(pix_alpha_ptr,4);
              end
          else
            begin
              for x:=0 to w do
                begin
                  if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<alpha_max) then
                    pix_alpha_ptr^:=$000000;
                  Inc(pix_alpha_ptr,8);
                end;
              Inc(pix_alpha_ptr,d_width<<2);
            end;
        end
      else
        for y:=0 to bmp_src_rct_clp.height-1 do
          begin
            for x:=0 to w do
              begin
                if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<alpha_max) then
                  pix_alpha_ptr^:=$000000;
                Inc(pix_alpha_ptr,8);
              end;
            Inc(pix_alpha_ptr,d_width<<2);
          end;
    end;
end; {$endregion}
// color and alpha are in one bitmap
// NT - not transparent pixels;
procedure TFastImageProc.SetNTChessBmpO0; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr: PInteger;
  x,y,w,h      : integer;
  d_width      : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (bmp_src_rct_clp.width*bmp_src_rct_clp.height<6) then
        Exit;
      w            :=Trunc(bmp_src_rct_clp.width /2)-1;
      h            :=Trunc(bmp_src_rct_clp.height/2)-1;
      d_width      :=bmp_ftimg_width-bmp_src_rct_clp.width;
      pix_alpha_ptr:=Unaligned(@bmp_color_ptr[bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
      if width_parity then
        begin
          if height_parity then
            for y:=0 to h do
              begin
                for x:=0 to w do
                  begin
                    if (pix_alpha_ptr^>>24=alpha_max) then
                      pix_alpha_ptr^:=0;
                    Inc(pix_alpha_ptr,2);
                  end;
                Inc(pix_alpha_ptr,d_width);
                Dec(pix_alpha_ptr);
                for x:=0 to w do
                  begin
                    if (pix_alpha_ptr^>>24=alpha_max) then
                      pix_alpha_ptr^:=0;
                    Inc(pix_alpha_ptr,2);
                  end;
                Inc(pix_alpha_ptr,d_width);
                Inc(pix_alpha_ptr);
              end
          else
            begin
              for x:=0 to w do
                begin
                  if (pix_alpha_ptr^>>24=alpha_max) then
                    pix_alpha_ptr^:=0;
                  Inc(pix_alpha_ptr,2);
                end;
              Inc(pix_alpha_ptr,d_width);
            end;
        end
      else
        for y:=0 to bmp_src_rct_clp.height-1 do
          begin
            for x:=0 to w do
              begin
                if (pix_alpha_ptr^>>24=alpha_max) then
                  pix_alpha_ptr^:=0;
                Inc(pix_alpha_ptr,2);
              end;
            Inc(pix_alpha_ptr,d_width);
          end;
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImageProc.SetPTChessBmpO0; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr: PInteger;
  x,y,w,h      : integer;
  d_width      : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (bmp_src_rct_clp.width*bmp_src_rct_clp.height<6) then
        Exit;
      w            :=Trunc(bmp_src_rct_clp.width /2)-1;
      h            :=Trunc(bmp_src_rct_clp.height/2)-1;
      d_width      :=bmp_ftimg_width-bmp_src_rct_clp.width;
      pix_alpha_ptr:=Unaligned(@bmp_color_ptr[bmp_src_rct_clp.left+bmp_ftimg_width*bmp_src_rct_clp.top]);
      if width_parity then
        begin
          if height_parity then
            for y:=0 to h do
              begin
                for x:=0 to w do
                  begin
                    if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<alpha_max) then
                      pix_alpha_ptr^:=0;
                    Inc(pix_alpha_ptr,2);
                  end;
                Inc(pix_alpha_ptr,d_width);
                Dec(pix_alpha_ptr);
                for x:=0 to w do
                  begin
                    if (pix_alpha_ptr^>>24>0) and (pix_alpha_ptr^>>24<alpha_max) then
                      pix_alpha_ptr^:=0;
                    Inc(pix_alpha_ptr,2);
                  end;
                Inc(pix_alpha_ptr,d_width);
                Inc(pix_alpha_ptr);
              end
          else
            begin
              for x:=0 to w do
                begin
                  if (pix_alpha_ptr^>>24>0) and (pix_alpha_ptr^>>24<alpha_max) then
                    pix_alpha_ptr^:=0;
                  Inc(pix_alpha_ptr,2);
                end;
              Inc(pix_alpha_ptr,d_width);
            end;
        end
      else
        for y:=0 to bmp_src_rct_clp.height-1 do
          begin
            for x:=0 to w do
              begin
                if (pix_alpha_ptr^>>24>0) and (pix_alpha_ptr^>>24<alpha_max) then
                  pix_alpha_ptr^:=0;
                Inc(pix_alpha_ptr,2);
              end;
            Inc(pix_alpha_ptr,d_width);
          end;
    end;
end; {$endregion} {$endregion}

{Create Array of Tiles Bounding Rectangles-------------} {$region -fold}
procedure TFastImageProc.CrtRectArr; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    SetLength(rect_src_arr,tiles_cnt);
end; {$endregion} {$endregion}

{CSR-Image Compression---------------------------------} {$region -fold}
// img. kind: 000:
procedure TFastImageProc.CmpProc000 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // NT - not transparent pixels;
  CrtNTCountBmpO;
  CrtNTShiftBmpO;
  CrtNTCntIndArr;
  StrNTColorBmpA;
  // PT - partly transparent pixels;
  CrtPTCountBmpO;
  CrtPTShiftBmpO;
  CrtPTCntIndArr;
  StrPTColorBmpA;
  // store alpha channel;
  StrPTAlphaArrO;
end; {$endregion}
// img. kind: 001:
procedure TFastImageProc.CmpProc001 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // NT - not transparent pixels;
  CrtNTCountBmpO;
  CrtNTShiftBmpO;
  CrtNTCntIndArr;
  StrNTColorBmpA;
end; {$endregion}
// img. kind: 002:
procedure TFastImageProc.CmpProc002 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // PT - partly transparent pixels;
  CrtPTCountBmpO;
  CrtPTCntIndArr;
  CrtPTShiftBmpO;
  StrPTColorBmpA;
  // store alpha channel;
  StrPTAlphaArrO;
end; {$endregion}
// img. kind: 003: empty:
procedure TFastImageProc.CmpProc003 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {do nothing}
end; {$endregion}
// img. kind: 004: empty:
procedure TFastImageProc.CmpProc004 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {do nothing}
end; {$endregion}
// img. kind: 005:
procedure TFastImageProc.CmpProc005 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // NT - not transparent pixels;
  CrtNTCountBmpO;
  CrtNTCntIndArr;
  CrtNTShiftBmpO;
  // PT - partly transparent pixels;
  CrtPTCountBmpO;
  CrtPTCntIndArr;
  CrtPTShiftBmpO;
  // store alpha channel;
  StrPTAlphaArrO;
end; {$endregion}
// img. kind: 006:
procedure TFastImageProc.CmpProc006 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // NT - not transparent pixels;
  CrtNTCountBmpO;
  CrtNTCntIndArr;
  CrtNTShiftBmpO;
end; {$endregion}
// img. kind: 007:
procedure TFastImageProc.CmpProc007 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // PT - partly transparent pixels;
  CrtPTCountBmpO;
  CrtPTCntIndArr;
  CrtPTShiftBmpO;
  // store alpha channel;
  StrPTAlphaArrO;
end; {$endregion}
// img. kind: 008: empty:
procedure TFastImageProc.CmpProc008 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {do nothing}
end; {$endregion}
// img. kind: 009:
procedure TFastImageProc.CmpProc009 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {do nothing}
end; {$endregion}
// img. kind: 010:
procedure TFastImageProc.CmpProc010 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {do nothing}
end; {$endregion}
// img. kind: 011:
procedure TFastImageProc.CmpProc011 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      // NT - not transparent pixels;
      if (bmp_alpha_ptr2=Nil) then // byte mode - off:
        begin
          if (not remove_brunching) then
            CrtNTCountArrA
          else
            CrtNTCountArrC;
          if (not better_quality) then
            CrtNTShiftArrA
          else
            CrtNTShiftArrC;
          CrtNTCntIndArr;
          if need_store_value then
            StrNTValueArrA;
          //StrNTLowerBmpA;
        end
      else // byte mode - on:
        begin
          if (not remove_brunching) then
            CrtNTCountArrB
          else
            CrtNTCountArrD;
          if (not better_quality) then
            CrtNTShiftArrB
          else
            CrtNTShiftArrD;
          CrtNTCntIndArr;
          //StrNTLowerBmpA;
        end;
      {// PT - partly transparent pixels;
      CrtPTCountArrA;
      CrtPTCntIndArr;
      CrtPTShiftArrA;
      // store alpha channel;
      StrPTAlphaArrO;}
    end;
end; {$endregion}
// img. kind: 012:
procedure TFastImageProc.CmpProc012 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // NT - not transparent(not black!) pixels;
  CrtNTCountArrA;
  CrtNTCntIndArr;
  CrtNTShiftArrA;
end; {$endregion}
// Procedures Table Init.:
procedure TFastImageProc.CmpProcInit; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  {Image Description} {$region -fold}
  {
    ----------------Image Has Alpha Channel And Color Channel---------------
    0:
    image has:     not monochrome alpha channel,
                   not monochrome color channel,
    count of fully not transparent pixels>0;
    count of partly    transparent pixels>0;

    1:
    image has:     not monochrome alpha channel,
                   not monochrome color channel,
    count of fully not transparent pixels>0;
    count of partly    transparent pixels=0;

    2:
    image has:     not monochrome alpha channel,
                   not monochrome color channel,
    count of fully not transparent pixels=0;
    count of partly    transparent pixels>0;

    3:
    image has:         monochrome alpha channel(white, not transparent),
                   not monochrome color channel,
    count of fully not transparent pixels>0;
    count of partly    transparent pixels=0;

    4:
    image has:         monochrome alpha channel(transparent),
                   not monochrome color channel,
    count of fully not transparent pixels=0;
    count of partly    transparent pixels>0;


    ----------------------Image Has Only Alpha Channel----------------------
    5:
    image has:     not monochrome alpha channel,
                               no color channel,
    count of fully not transparent pixels>0;
    count of partly    transparent pixels>0;

    6:
    image has:     not monochrome alpha channel,
                               no color channel,
    count of fully not transparent pixels>0;
    count of partly    transparent pixels=0;

    7:
    image has:     not monochrome alpha channel,
                               no color channel,
    count of fully not transparent pixels=0;
    count of partly    transparent pixels>0;

    8:
    image has:         monochrome alpha channel(white, not transparent),
                               no color channel,
    count of fully not transparent pixels>0;
    count of partly    transparent pixels=0;

    9:
    image has:         monochrome alpha channel(transparent),
                               no color channel,
    count of fully not transparent pixels=0;
    count of partly    transparent pixels>0;


    --------------Image Has No Alpha Channel And Color Channel--------------
    10:
    image has:      no alpha channel(black, invisible),
                    no color channel,
    count of fully not transparent pixels=0;
    count of partly    transparent pixels=0;


    --------------------------Image is Value Array--------------------------
    11:
    count of fully not transparent pixels>0;
    count of partly    transparent pixels>0;

    --------------------------Image is Mask--------------------------
    12:
    count of fully not transparent pixels>0;
    count of partly    transparent pixels=0;
  } {$endregion}

  // img. kind: 000:
  CmpProc[000]:=@CmpProc000;
  // img. kind: 001:
  CmpProc[001]:=@CmpProc001;
  // img. kind: 002:
  CmpProc[002]:=@CmpProc002;
  // img. kind: 003:
  CmpProc[003]:=@CmpProc003;
  // img. kind: 004:
  CmpProc[004]:=@CmpProc004;
  // img. kind: 005:
  CmpProc[005]:=@CmpProc005;
  // img. kind: 006:
  CmpProc[006]:=@CmpProc006;
  // img. kind: 007:
  CmpProc[007]:=@CmpProc007;
  // img. kind: 008:
  CmpProc[008]:=@CmpProc008;
  // img. kind: 009:
  CmpProc[009]:=@CmpProc009;
  // img. kind: 010:
  CmpProc[010]:=@CmpProc010;
  // img. kind: 011:
  CmpProc[011]:=@CmpProc011;
  // img. kind: 012:
  CmpProc[012]:=@CmpProc012;

end; {$endregion}

// Final image Compression:
procedure TFastImageProc.ImgToCImg  ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      DetImageKind;
      CmpProc[img_kind];
      SetSdrType;
    end;
end; {$endregion}

{$endregion}

{CSR-Image Drawing-------------------------------------} {$region -fold}

{Color    FloodFill------------------------------------} {$region -fold}

// NT - not transparent pixels:

// auxiliary procedures:
procedure TFastImageProc.RegNTColorA_0; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      res_var0:=0000000000000000+nt_pix_arr_row_mrg_top;
      res_var1:=0;
      res_var2:=bmp_ftimg_height-nt_pix_arr_row_mrg_top-
                                 nt_pix_arr_row_mrg_btm-1;
    end;
end; {$endregion}
procedure TFastImageProc.RegNTColorA_1; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      res_var0:=00000000000000+rct_src.top;
      res_var1:=nt_cnt_ind_arr[rct_src.top];
      res_var2:=00000000000000+rct_src.height-1;
    end;
end; {$endregion}

{Empty}
procedure TFastImageProc.RegNTColor009; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Color of Curent Layer}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegNTColorA00; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      nt_pix_intr_ccl_arr_ptr:=Unaligned( nt_pix_intr_arr_ptr+ res_var1);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          if      not ((nt_pix_intr_cnt_arr_ptr^>=4) and
                      ((nt_pix_intr_sht_arr_ptr+
                        nt_pix_intr_cnt_arr_ptr^-1)^-
                        nt_pix_intr_sht_arr_ptr^=
                        nt_pix_intr_cnt_arr_ptr^-1)) then
            for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
              begin
                       (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=
                        nt_pix_intr_ccl_arr_ptr^;
                Inc    (nt_pix_intr_sht_arr_ptr);
                Inc    (nt_pix_intr_ccl_arr_ptr);
              end
          else
            begin
              Move     (nt_pix_intr_ccl_arr_ptr^,
                       (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                        nt_pix_intr_cnt_arr_ptr^<<2);
              Inc      (nt_pix_intr_sht_arr_ptr,
                        nt_pix_intr_cnt_arr_ptr^);
              Inc      (nt_pix_intr_ccl_arr_ptr,
                        nt_pix_intr_cnt_arr_ptr^);
            end;
          Inc          (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegNTColor000; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegNTColorA_0;
      RegNTColorA00;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTColor002; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTColorA_1;
      RegNTColorA00;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTColor004; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      nt_pix_intr_ccl_arr_ptr:=Unaligned(@nt_pix_intr_arr_ptr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (nt_pix_intr_ccl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=
                                     nt_pix_intr_ccl_arr_ptr^;
                      Inc           (nt_pix_intr_sht_arr_ptr);
                      Inc           (nt_pix_intr_ccl_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (nt_pix_intr_ccl_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  Inc               (nt_pix_intr_ccl_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (nt_pix_intr_ccl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=
                                     nt_pix_intr_ccl_arr_ptr^;
                      Inc           (nt_pix_intr_sht_arr_ptr);
                      Inc           (nt_pix_intr_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  Inc               (nt_pix_intr_ccl_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=
                                     nt_pix_intr_ccl_arr_ptr^;
                      Inc           (nt_pix_intr_sht_arr_ptr);
                      Inc           (nt_pix_intr_ccl_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (nt_pix_intr_ccl_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=
                                     nt_pix_intr_ccl_arr_ptr^;
                      Inc           (nt_pix_intr_sht_arr_ptr);
                      Inc           (nt_pix_intr_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTColor006; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    BitBlt1(bmp_color_ptr,
            bmp_bkgnd_ptr,
            rct_src,
            rct_dst.left,
            rct_dst.top,
            bmp_ftimg_width_origin{bmp_ftimg_width},
            bmp_bkgnd_width);
end; {$endregion}
// (fading):
// same;

{Color of Curent Layer(Additive)}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegNTColorA10; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      nt_pix_intr_ccl_arr_ptr:=Unaligned( nt_pix_intr_arr_ptr+ res_var1);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveA(
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                     (nt_pix_intr_ccl_arr_ptr^));
              Inc    (nt_pix_intr_sht_arr_ptr);
              Inc    (nt_pix_intr_ccl_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegNTColor010; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegNTColorA_0;
      RegNTColorA10;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTColor012; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTColorA_1;
      RegNTColorA10;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTColor014; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      nt_pix_intr_ccl_arr_ptr:=Unaligned(@nt_pix_intr_arr_ptr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc             (nt_pix_intr_sht_arr_ptr,c1+1);
                  Inc             (nt_pix_intr_ccl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                           (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveA(
                           (nt_pix_intr_sht_arr_ptr^+v)^,
                           (nt_pix_intr_ccl_arr_ptr^));
                      Inc  (nt_pix_intr_sht_arr_ptr);
                      Inc  (nt_pix_intr_ccl_arr_ptr);
                    end;
                  Inc      (nt_pix_intr_sht_arr_ptr,
                            nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc      (nt_pix_intr_ccl_arr_ptr,
                            nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
                  Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc            (nt_pix_intr_sht_arr_ptr,c+1);
                  Inc            (nt_pix_intr_ccl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                             (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveA(
                             (nt_pix_intr_sht_arr_ptr^+v)^,
                             (nt_pix_intr_ccl_arr_ptr^));
                      Inc    (nt_pix_intr_sht_arr_ptr);
                      Inc    (nt_pix_intr_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
                  Inc(nt_pix_intr_ccl_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                           (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveA(
                           (nt_pix_intr_sht_arr_ptr^+v)^,
                           (nt_pix_intr_ccl_arr_ptr^));
                      Inc  (nt_pix_intr_sht_arr_ptr);
                      Inc  (nt_pix_intr_ccl_arr_ptr);
                    end;
                  Inc      (nt_pix_intr_sht_arr_ptr,
                            nt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc      (nt_pix_intr_ccl_arr_ptr,
                            nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                             (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveA(
                             (nt_pix_intr_sht_arr_ptr^+v)^,
                             (nt_pix_intr_ccl_arr_ptr^));
                      Inc    (nt_pix_intr_sht_arr_ptr);
                      Inc    (nt_pix_intr_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTColor016; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPAdditive(bmp_color_ptr,
               bmp_bkgnd_ptr,
               rct_src,
               rct_dst,
               bmp_ftimg_width_origin{bmp_ftimg_width},
               bmp_bkgnd_width);
end; {$endregion}
// (fading) auxiliary procedure:
procedure TFastImageProc.RegNTColorA11; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTColorA10;
          Exit;
        end;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      nt_pix_intr_ccl_arr_ptr:=Unaligned( nt_pix_intr_arr_ptr+ res_var1);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDecB(
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                     (nt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
              Inc    (nt_pix_intr_sht_arr_ptr);
              Inc    (nt_pix_intr_ccl_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegNTColor011; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegNTColorA_0;
      RegNTColorA11;
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegNTColor013; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTColorA_1;
      RegNTColorA11;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTColor015; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTColor014;
          Exit;
        end;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +00000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
      nt_pix_intr_ccl_arr_ptr:=Unaligned(@nt_pix_intr_arr_ptr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (nt_pix_intr_ccl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,
                                    (nt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                      Inc           (nt_pix_intr_ccl_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (nt_pix_intr_ccl_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  Inc               (nt_pix_intr_ccl_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (nt_pix_intr_ccl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,
                                    (nt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                      Inc           (nt_pix_intr_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  Inc               (nt_pix_intr_ccl_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,
                                    (nt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                      Inc           (nt_pix_intr_ccl_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (nt_pix_intr_ccl_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,
                                    (nt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                      Inc           (nt_pix_intr_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTColor017; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTColor016;
          Exit;
        end;
      PPAdditiveDec(bmp_color_ptr,
                    bmp_bkgnd_ptr,
                    rct_src,
                    rct_dst,
                    bmp_ftimg_width_origin{bmp_ftimg_width},
                    bmp_bkgnd_width,
                    alpha_max-cfx_pow0);
    end;
end; {$endregion}

{Color of Curent Layer(Alphablend)}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegNTColorA20; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTColorA00;
          Exit;
        end;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      nt_pix_intr_ccl_arr_ptr:=Unaligned( nt_pix_intr_arr_ptr+ res_var1);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendB(
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                     (nt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
              Inc    (nt_pix_intr_sht_arr_ptr);
              Inc    (nt_pix_intr_ccl_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegNTColor020; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegNTColorA_0;
      RegNTColorA20;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTColor022; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTColorA_1;
      RegNTColorA20;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTColor024; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTColor004;
          Exit;
        end;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      nt_pix_intr_ccl_arr_ptr:=Unaligned(@nt_pix_intr_arr_ptr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (nt_pix_intr_ccl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,
                                    (nt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                      Inc           (nt_pix_intr_ccl_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (nt_pix_intr_ccl_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  Inc               (nt_pix_intr_ccl_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (nt_pix_intr_ccl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,
                                    (nt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                      Inc           (nt_pix_intr_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  Inc               (nt_pix_intr_ccl_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,
                                    (nt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                      Inc           (nt_pix_intr_ccl_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (nt_pix_intr_ccl_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,
                                    (nt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                      Inc           (nt_pix_intr_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTColor026; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTColor006;
          Exit;
        end;
      PPAlphaBlend(bmp_color_ptr,
                   bmp_bkgnd_ptr,
                   rct_src,
                   rct_dst,
                   bmp_ftimg_width_origin{bmp_ftimg_width},
                   bmp_bkgnd_width,
                   cfx_pow0);
    end;
end; {$endregion}
// (fading):
// same;

// PT - partly transparent pixels:

// auxiliary procedures:
procedure TFastImageProc.RegPTColorA_0; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      res_var0:=0000000000000000+pt_pix_arr_row_mrg_top;
      res_var1:=0;
      res_var2:=bmp_ftimg_height-pt_pix_arr_row_mrg_top-
                                 pt_pix_arr_row_mrg_btm-1;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTColorA_1; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      res_var0:=00000000000000+rct_src.top;
      res_var1:=pt_cnt_ind_arr[rct_src.top];
      res_var2:=00000000000000+rct_src.height-1;
    end;
end; {$endregion}

{Empty}
procedure TFastImageProc.RegPTColor009; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Color of Curent Layer}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTColorA00; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_intr_ccl_arr_ptr:=Unaligned( pt_pix_intr_arr_ptr+ res_var1);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendB(
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                     (pt_pix_intr_ccl_arr_ptr^),alpha_max-
              TRGBA  (pt_pix_intr_ccl_arr_ptr^).a);
              Inc    (pt_pix_intr_sht_arr_ptr);
              Inc    (pt_pix_intr_ccl_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTColorB00; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_intr_ccl_arr_ptr:=Unaligned( pt_pix_intr_arr_ptr+ res_var1);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=
                      pt_pix_intr_ccl_arr_ptr^;
              Inc    (pt_pix_intr_sht_arr_ptr);
              Inc    (pt_pix_intr_ccl_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegPTColor000; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTColorA_0;
      if (not pt_as_nt) then
        RegPTColorA00
      else
        RegPTColorB00;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTColor002; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTColorA_1;
      if (not pt_as_nt) then
        RegPTColorA00
      else
        RegPTColorB00;
    end;
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTColorA04; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_intr_ccl_arr_ptr:=Unaligned(@pt_pix_intr_arr_ptr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_intr_ccl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^),alpha_max-
                      TRGBA         (pt_pix_intr_ccl_arr_ptr^).a);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_intr_ccl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^),alpha_max-
                      TRGBA         (pt_pix_intr_ccl_arr_ptr^).a);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^),alpha_max-
                      TRGBA         (pt_pix_intr_ccl_arr_ptr^).a);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^),alpha_max-
                      TRGBA         (pt_pix_intr_ccl_arr_ptr^).a);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTColorB04; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_intr_ccl_arr_ptr:=Unaligned(@pt_pix_intr_arr_ptr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_intr_ccl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=
                                     pt_pix_intr_ccl_arr_ptr^;
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_intr_ccl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=
                                     pt_pix_intr_ccl_arr_ptr^;
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=
                                     pt_pix_intr_ccl_arr_ptr^;
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=
                                     pt_pix_intr_ccl_arr_ptr^;
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTColor004; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.left>bmp_ftimg_width -1) then
        Exit;
      if (rct_src.top >bmp_ftimg_height-1) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTColorA04
      else
        RegPTColorB04;
    end;
end; {$endregion}
// (constant) image has transparent alpha channel:
procedure TFastImageProc.RegPTColor006; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (not pt_as_nt) then
        PPAlphaBlend(bmp_color_ptr,
                     bmp_bkgnd_ptr,
                     rct_src,
                     rct_dst,
                     bmp_ftimg_width_origin{bmp_ftimg_width},
                     bmp_bkgnd_width,
                     cfx_pow0)
      else
        BitBlt1     (bmp_color_ptr,
                     bmp_bkgnd_ptr,
                     rct_src,
                     rct_dst.left,
                     rct_dst.top,
                     bmp_ftimg_width_origin{bmp_ftimg_width},
                     bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading):
// same;

{Color of Curent Layer(Additive)}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTColorA10; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_intr_ccl_arr_ptr:=Unaligned( pt_pix_intr_arr_ptr+ res_var1);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDecB(
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                     (pt_pix_intr_ccl_arr_ptr^),alpha_max-
              TRGBA  (pt_pix_intr_ccl_arr_ptr^).a);
              Inc    (pt_pix_intr_sht_arr_ptr);
              Inc    (pt_pix_intr_ccl_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTColorB10; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_intr_ccl_arr_ptr:=Unaligned( pt_pix_intr_arr_ptr+ res_var1);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveA(
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                     (pt_pix_intr_ccl_arr_ptr^));
              Inc    (pt_pix_intr_sht_arr_ptr);
              Inc    (pt_pix_intr_ccl_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegPTColor010; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTColorA_0;
      if (not pt_as_nt) then
        RegPTColorA10
      else
        RegPTColorB10;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTColor012; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTColorA_1;
      if (not pt_as_nt) then
        RegPTColorA10
      else
        RegPTColorB10;
    end;
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTColorA14; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_intr_ccl_arr_ptr:=Unaligned(@pt_pix_intr_arr_ptr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_intr_ccl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^),alpha_max-
                      TRGBA         (pt_pix_intr_ccl_arr_ptr^).a);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_intr_ccl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^),alpha_max-
                      TRGBA         (pt_pix_intr_ccl_arr_ptr^).a);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^),alpha_max-
                      TRGBA         (pt_pix_intr_ccl_arr_ptr^).a);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^),alpha_max-
                      TRGBA         (pt_pix_intr_ccl_arr_ptr^).a);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTColorB14; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_intr_ccl_arr_ptr:=Unaligned(@pt_pix_intr_arr_ptr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_intr_ccl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_intr_ccl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTColor014; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTColorA14
      else
        RegPTColorB14;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegPTColor016; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (not pt_as_nt) then
        PPAdditiveDec(bmp_color_ptr,
                      bmp_bkgnd_ptr,
                      rct_src,
                      rct_dst,
                      bmp_ftimg_width_origin{bmp_ftimg_width},
                      bmp_bkgnd_width,
                      alpha_max-cfx_pow0)
      else
        PPAdditive   (bmp_color_ptr,
                      bmp_bkgnd_ptr,
                      rct_src,
                      rct_dst,
                      bmp_ftimg_width_origin{bmp_ftimg_width},
                      bmp_bkgnd_width);
    end;
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTColorA11; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_intr_ccl_arr_ptr:=Unaligned( pt_pix_intr_arr_ptr+ res_var1);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDecB(
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                     (pt_pix_intr_ccl_arr_ptr^),alpha_max-Max(
              TRGBA  (pt_pix_intr_ccl_arr_ptr^).a-cfx_pow0_,0));
              Inc    (pt_pix_intr_sht_arr_ptr);
              Inc    (pt_pix_intr_ccl_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTColorB11; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_intr_ccl_arr_ptr:=Unaligned( pt_pix_intr_arr_ptr+ res_var1);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDecB(
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                     (pt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
              Inc    (pt_pix_intr_sht_arr_ptr);
              Inc    (pt_pix_intr_ccl_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegPTColor011; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTColorA_0;
      if (not pt_as_nt) then
        RegPTColorA11
      else
        RegPTColorB11;
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegPTColor013; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTColorA_1;
      if (not pt_as_nt) then
        RegPTColorA11
      else
        RegPTColorB11;
    end;
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTColorA15; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_intr_ccl_arr_ptr:=Unaligned(@pt_pix_intr_arr_ptr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_intr_ccl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^),alpha_max-Max(
                      TRGBA         (pt_pix_intr_ccl_arr_ptr^).a-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_intr_ccl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^),alpha_max-Max(
                      TRGBA         (pt_pix_intr_ccl_arr_ptr^).a-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^),alpha_max-Max(
                      TRGBA         (pt_pix_intr_ccl_arr_ptr^).a-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^),alpha_max-Max(
                      TRGBA         (pt_pix_intr_ccl_arr_ptr^).a-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTColorB15; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_intr_ccl_arr_ptr:=Unaligned(@pt_pix_intr_arr_ptr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_intr_ccl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_intr_ccl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTColor015; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTColorA15
      else
        RegPTColorB15;
    end;
end; {$endregion}
// (fading) image has monochrome color channel
// same as (constant)

{Color of Curent Layer(Alphablend)}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTColorA20; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_intr_ccl_arr_ptr:=Unaligned( pt_pix_intr_arr_ptr+ res_var1);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to   pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendDecC(
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                       (pt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
              Inc      (pt_pix_intr_sht_arr_ptr);
              Inc      (pt_pix_intr_ccl_arr_ptr);
            end;
          Inc          (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTColorB20; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_intr_ccl_arr_ptr:=Unaligned( pt_pix_intr_arr_ptr+ res_var1);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendB(
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                     (pt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
              Inc    (pt_pix_intr_sht_arr_ptr);
              Inc    (pt_pix_intr_ccl_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegPTColor020; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTColorA_0;
      if (not pt_as_nt) then
        RegPTColorA20
      else
        RegPTColorB20;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTColor022; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTColorA_1;
      if (not pt_as_nt) then
        RegPTColorA20
      else
        RegPTColorB20;
    end;
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTColorA24; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_intr_ccl_arr_ptr:=Unaligned(@pt_pix_intr_arr_ptr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_intr_ccl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDecC(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_intr_ccl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDecC(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDecC(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDecC(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTColorB24; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_intr_ccl_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_intr_ccl_arr_ptr:=Unaligned(@pt_pix_intr_arr_ptr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_intr_ccl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_intr_ccl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_intr_ccl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                    (pt_pix_intr_ccl_arr_ptr^),cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_intr_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTColor024; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTColorA24
      else
        RegPTColorB24;
    end;
end; {$endregion}
// (fading):
// same;

{$endregion}

{Regular  FloodFill------------------------------------} {$region -fold}

// NT - not transparent pixels:

{Value} {$region -fold}

// auxiliary procedures:
procedure TFastImageProc.RegNTValueA_0; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      res_var0:=0000000000000000+nt_pix_arr_row_mrg_top;
      res_var1:=0;
      res_var2:=bmp_ftimg_height-nt_pix_arr_row_mrg_top-
                                 nt_pix_arr_row_mrg_btm-1;
    end;
end; {$endregion}
procedure TFastImageProc.RegNTValueA_1; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      res_var0:=00000000000000+rct_src.top;
      res_var1:=nt_cnt_ind_arr[rct_src.top];
      res_var2:=00000000000000+rct_src.height-1;
    end;
end; {$endregion}

// not clippped:
procedure TFastImageProc.RegNTProc0_0(constref args:TFunc0Args; Func0:TFunc0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ 00000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              with args do
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=Func0(
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,r,g,b,alpha,d_alpha,pow,d);
              Inc    (nt_pix_intr_sht_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// top-bottom clippped:
procedure TFastImageProc.RegNTProc0_2(constref args:TFunc0Args; Func0:TFunc0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top+rct_src.top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              with args do
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=Func0(
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,r,g,b,alpha,d_alpha,pow,d);
              Inc    (nt_pix_intr_sht_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// left-right-top-bottom clippped:
procedure TFastImageProc.RegNTProc0_4(constref args:TFunc0Args; Func0:TFunc0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,
                                   nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,
                                   nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc             (nt_pix_intr_sht_arr_ptr,c1+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                      with args do
                         (nt_pix_intr_sht_arr_ptr^+v)^:=Func0(
                         (nt_pix_intr_sht_arr_ptr^+v)^,r,g,b,alpha,d_alpha,pow,d);
                      Inc(nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc    (nt_pix_intr_sht_arr_ptr,
                          nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc(nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,
                                  nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc            (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to nt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                      with args do
                             (nt_pix_intr_sht_arr_ptr^+v)^:=Func0(
                             (nt_pix_intr_sht_arr_ptr^+v)^,r,g,b,alpha,d_alpha,pow,d);
                      Inc    (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc(nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,
                                  nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      with args do
                         (nt_pix_intr_sht_arr_ptr^+v)^:=Func0(
                         (nt_pix_intr_sht_arr_ptr^+v)^,r,g,b,alpha,d_alpha,pow,d);
                      Inc(nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc    (nt_pix_intr_sht_arr_ptr,
                          nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      with args do
                             (nt_pix_intr_sht_arr_ptr^+v)^:=Func0(
                             (nt_pix_intr_sht_arr_ptr^+v)^,r,g,b,alpha,d_alpha,pow,d);
                      Inc    (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// not clippped:
procedure TFastImageProc.RegNTProc1_0(                          Proc8:TProc8); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin

      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ 00000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              Proc8  (nt_pix_intr_sht_arr_ptr^+pix_color_ptr,bmp_bkgnd_width);
              Inc    (nt_pix_intr_sht_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// top-bottom clippped:
procedure TFastImageProc.RegNTProc1_2(                          Proc8:TProc8); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top+rct_src.top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000000000000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              Proc8  (nt_pix_intr_sht_arr_ptr^+pix_color_ptr,bmp_bkgnd_width);
              Inc    (nt_pix_intr_sht_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// left-right-top-bottom clippped:
procedure TFastImageProc.RegNTProc1_4(                          Proc8:TProc8); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,
                                   nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,
                                   nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc             (nt_pix_intr_sht_arr_ptr,c1+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                      Proc8(nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width);
                      Inc  (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc      (nt_pix_intr_sht_arr_ptr,
                            nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc(nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,
                                  nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc            (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to nt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                      Proc8  (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width);
                      Inc    (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,
                                  nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      Proc8(nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width);
                      Inc  (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc      (nt_pix_intr_sht_arr_ptr,
                            nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      Proc8  (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width);
                      Inc    (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}

{Empty}
procedure TFastImageProc.RegNTValue009; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Monochrome}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegNTValueA00; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          if       not ((nt_pix_intr_cnt_arr_ptr^>=4) and
                       ((nt_pix_intr_sht_arr_ptr+
                         nt_pix_intr_cnt_arr_ptr^-1)^-
                         nt_pix_intr_sht_arr_ptr^=
                         nt_pix_intr_cnt_arr_ptr^-1)) then
            for x:=0 to  nt_pix_intr_cnt_arr_ptr^-1 do
              begin
                        (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=monochrome_val;
                Inc     (nt_pix_intr_sht_arr_ptr);
              end
          else
            begin
              FillDWord((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                         nt_pix_intr_cnt_arr_ptr^,monochrome_val);
              Inc       (nt_pix_intr_sht_arr_ptr,
                         nt_pix_intr_cnt_arr_ptr^);
            end;
          Inc           (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width );
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegNTValue000; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegNTValueA_0;
      RegNTValueA00;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTValue002; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTValueA_1;
      RegNTValueA00;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue004; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,
                                   nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,
                                   nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc             (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                         (nt_pix_intr_sht_arr_ptr^+v)^:=monochrome_val;
                      Inc(nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc    (nt_pix_intr_sht_arr_ptr,
                          nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc(nt_pix_intr_sht_arr_ptr,
                      nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,
                                  nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc            (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to nt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                             (nt_pix_intr_sht_arr_ptr^+v)^:=monochrome_val;
                      Inc    (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,
                                  nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                         (nt_pix_intr_sht_arr_ptr^+v)^:=monochrome_val;
                      Inc(nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc    (nt_pix_intr_sht_arr_ptr,
                          nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                             (nt_pix_intr_sht_arr_ptr^+v)^:=monochrome_val;
                      Inc    (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue006; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPFloodFill(bmp_bkgnd_ptr,
                rct_dst,
                bmp_bkgnd_width,
                monochrome_val);
end; {$endregion}
// (fading):
// same;

{Additive}
// (constant) not clippped:
procedure TFastImageProc.RegNTValue010; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  with fast_image_data_ptr0^ do
    begin
      args.r:=TRGBA(monochrome_val).b;
      args.g:=TRGBA(monochrome_val).g;
      args.b:=TRGBA(monochrome_val).r;
      RegNTProc0_0(args,@Additive0);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTValue012; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  with fast_image_data_ptr0^ do
    begin
      args.r:=TRGBA(monochrome_val).b;
      args.g:=TRGBA(monochrome_val).g;
      args.b:=TRGBA(monochrome_val).r;
      RegNTProc0_2(args,@Additive0);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue014; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  with fast_image_data_ptr0^ do
    begin
      args.r:=TRGBA(monochrome_val).b;
      args.g:=TRGBA(monochrome_val).g;
      args.b:=TRGBA(monochrome_val).r;
      RegNTProc0_4(args,@Additive0);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue016; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPAdditive(bmp_bkgnd_ptr,
               rct_dst,
               bmp_bkgnd_width,
               monochrome_val);
end; {$endregion}
// (fading) auxiliary procedure:
procedure TFastImageProc.RegNTValueA11; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDecB(
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,monochrome_val,cfx_pow0_);
              Inc    (nt_pix_intr_sht_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegNTValue011; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegNTValueA_0;
      RegNTValueA11;
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegNTValue013; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTValueA_1;
      RegNTValueA11;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue015; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,
                                   nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,
                                   nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc             (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                  (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                  (nt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,cfx_pow0_);
                      Inc         (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc             (nt_pix_intr_sht_arr_ptr,
                                   nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue017; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPAdditiveDec(bmp_bkgnd_ptr,
                  rct_dst,
                  bmp_bkgnd_width,
                  monochrome_val,
                  alpha_max-cfx_pow0);
end; {$endregion}

{Alphablend}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegNTValueA20; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValueA00;
          Exit;
        end;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
                  (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendB(
                  (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,monochrome_val,cfx_pow0_);
              Inc (nt_pix_intr_sht_arr_ptr);
            end;
          Inc     (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegNTValue020; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegNTValueA_0;
      RegNTValueA20;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTValue022; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTValueA_1;
      RegNTValueA20;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue024; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue004;
          Exit;
        end;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +00000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue026; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue006;
          Exit;
        end;
      PPAlphaBlend(bmp_bkgnd_ptr,
                   rct_dst,
                   bmp_bkgnd_width,
                   monochrome_val,
                   cfx_pow0);
    end;
end; {$endregion}
// (fading):
// same;

{Inverse}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegNTValueA30; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=InverseA(
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^);
              Inc    (nt_pix_intr_sht_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegNTValue030; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegNTValueA_0;
      RegNTValueA30;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTValue032; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTValueA_1;
      RegNTValueA30;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue034; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=InverseA(
                                    (nt_pix_intr_sht_arr_ptr^+v)^);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=InverseA(
                                    (nt_pix_intr_sht_arr_ptr^+v)^);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=InverseA(
                                    (nt_pix_intr_sht_arr_ptr^+v)^);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=InverseA(
                                    (nt_pix_intr_sht_arr_ptr^+v)^);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue036; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPInverse(bmp_bkgnd_ptr,
              rct_dst,
              bmp_bkgnd_width);
end; {$endregion}
// (fading) auxiliary procedure:
procedure TFastImageProc.RegNTValueA31; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValueA30;
          Exit;
        end;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to     nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              InverseDec((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,cfx_pow0_);
              Inc        (nt_pix_intr_sht_arr_ptr);
            end;
          Inc            (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegNTValue031; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegNTValueA_0;
      RegNTValueA31;
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegNTValue033; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTValueA_1;
      RegNTValueA31;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue035; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue034;
          Exit;
        end;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      InverseDec   ((nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      InverseDec   ((nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      InverseDec   ((nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      InverseDec   ((nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue037; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue036;
          Exit;
        end;
      PPInverseDec(bmp_bkgnd_ptr,
                   rct_dst,
                   bmp_bkgnd_width,
                   alpha_max-cfx_pow0);
    end;
end; {$endregion}

{Highlight}
// (constant) not clippped:
procedure TFastImageProc.RegNTValue040; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  with fast_image_data_ptr0^ do
    begin
      args.pow:=cfx_pow0;
      RegNTProc0_0(args,@Highlight0);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTValue042; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  with fast_image_data_ptr0^ do
    begin
      args.pow:=cfx_pow0;
      RegNTProc0_2(args,@Highlight0);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue044; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  with fast_image_data_ptr0^ do
    begin
      args.pow:=cfx_pow0;
      RegNTProc0_4(args,@Highlight0);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue046; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPHighlight(bmp_bkgnd_ptr,
                rct_dst,
                bmp_bkgnd_width,
                cfx_pow0);
end; {$endregion}
// (fading):
// same;

{Darken}
// (constant) not clippped:
procedure TFastImageProc.RegNTValue050; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  with fast_image_data_ptr0^ do
    begin
      args.pow:=cfx_pow0;
      RegNTProc0_0(args,@Darken0);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTValue052; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  with fast_image_data_ptr0^ do
    begin
      args.pow:=cfx_pow0;
      RegNTProc0_2(args,@Darken0);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue054; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  args: TFunc0Args;
begin
  with fast_image_data_ptr0^ do
    begin
      args.pow:=cfx_pow0;
      RegNTProc0_4(args,@Darken0);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue056; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPDarken(bmp_bkgnd_ptr,
             rct_dst,
             bmp_bkgnd_width,
             cfx_pow0);
end; {$endregion}
// (fading):
// same;

{GrayscaleR}
// (constant) not clippped:
procedure TFastImageProc.RegNTValue060; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc0_0(Default(TFunc0Args),@GrayscaleR0);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTValue062; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc0_2(Default(TFunc0Args),@GrayscaleR0);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue064; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc0_4(Default(TFunc0Args),@GrayscaleR0);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue066; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPGrayscaleR(bmp_bkgnd_ptr,
                 rct_dst,
                 bmp_bkgnd_width);
end; {$endregion}
// (fading) auxiliary procedure:
procedure TFastImageProc.RegNTValueA61; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              GrayscaleRDec((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,cfx_pow0);
              Inc           (nt_pix_intr_sht_arr_ptr);
            end;
          Inc               (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegNTValue061; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegNTValueA_0;
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue060;
          Exit;
        end;
      RegNTValueA61;
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegNTValue063; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTValueA_1;
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue062;
          Exit;
        end;
      RegNTValueA61;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue065; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue064;
          Exit;
        end;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      GrayscaleRDec((nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      GrayscaleRDec((nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      GrayscaleRDec((nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      GrayscaleRDec((nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue067; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue066;
          Exit;
        end;
      PPGrayscaleRDec(bmp_bkgnd_ptr,
                      rct_dst,
                      bmp_bkgnd_width,
                      cfx_pow0);
    end;
end; {$endregion}

{GrayscaleG}
// (constant) not clippped:
procedure TFastImageProc.RegNTValue070; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc0_0(Default(TFunc0Args),@GrayscaleG0);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTValue072; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc0_2(Default(TFunc0Args),@GrayscaleG0);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue074; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc0_4(Default(TFunc0Args),@GrayscaleG0);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue076; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPGrayscaleG(bmp_bkgnd_ptr,
                 rct_dst,
                 bmp_bkgnd_width);
end; {$endregion}
// (fading) auxiliary procedure:
procedure TFastImageProc.RegNTValueA71; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              GrayscaleGDec((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,cfx_pow0);
              Inc           (nt_pix_intr_sht_arr_ptr);
            end;
          Inc               (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegNTValue071; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue070;
          Exit;
        end;
      RegNTValueA_0;
      RegNTValueA71;
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegNTValue073; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue072;
          Exit;
        end;
      RegNTValueA_1;
      RegNTValueA71;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue075; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue074;
          Exit;
        end;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      GrayscaleGDec((nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      GrayscaleGDec((nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      GrayscaleGDec((nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      GrayscaleGDec((nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue077; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue076;
          Exit;
        end;
      PPGrayscaleGDec(bmp_bkgnd_ptr,
                      rct_dst,
                      bmp_bkgnd_width,
                      cfx_pow0);
    end;
end; {$endregion}

{GrayscaleB}
// (constant) not clippped:
procedure TFastImageProc.RegNTValue080; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc0_0(Default(TFunc0Args),@GrayscaleB0);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTValue082; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc0_2(Default(TFunc0Args),@GrayscaleB0);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue084; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc0_4(Default(TFunc0Args),@GrayscaleB0);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue086; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPGrayscaleB(bmp_bkgnd_ptr,
                 rct_dst,
                 bmp_bkgnd_width);
end; {$endregion}
// (fading) auxiliary procedure:
procedure TFastImageProc.RegNTValueA81; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              GrayscaleBDec((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,cfx_pow0);
              Inc           (nt_pix_intr_sht_arr_ptr);
            end;
          Inc               (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegNTValue081; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue080;
          Exit;
        end;
      RegNTValueA_0;
      RegNTValueA81;
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegNTValue083; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue082;
          Exit;
        end;
      RegNTValueA_1;
      RegNTValueA81;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue085; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue084;
          Exit;
        end;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      GrayscaleBDec((nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      GrayscaleBDec((nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      GrayscaleBDec((nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      GrayscaleBDec((nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue087; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue086;
          Exit;
        end;
      PPGrayscaleBDec(bmp_bkgnd_ptr,
                      rct_dst,
                      bmp_bkgnd_width,
                      cfx_pow0);
    end;
end; {$endregion}

{Monochrome Noise}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegNTValueA90; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              if Odd((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=monochrome_val;
              Inc    (nt_pix_intr_sht_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegNTValue090; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegNTValueA_0;
      RegNTValueA90;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTValue092; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTValueA_1;
      RegNTValueA90;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue094; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      if Odd       ((nt_pix_intr_sht_arr_ptr^+v)^) then
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=monochrome_val;
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      if Odd       ((nt_pix_intr_sht_arr_ptr^+v)^) then
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=monochrome_val;
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      if Odd       ((nt_pix_intr_sht_arr_ptr^+v)^) then
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=monochrome_val;
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      if Odd       ((nt_pix_intr_sht_arr_ptr^+v)^) then
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=monochrome_val;
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue096; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPMonoNoise(bmp_bkgnd_ptr,
                rct_dst,
                bmp_bkgnd_width,
                monochrome_val);
end; {$endregion}
// (fading) auxiliary procedure:
procedure TFastImageProc.RegNTValueA91; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValueA90;
          Exit;
        end;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              if Odd((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendB(
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,monochrome_val,cfx_pow0_);
              Inc    (nt_pix_intr_sht_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegNTValue091; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegNTValueA_0;
      RegNTValueA91;
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegNTValue093; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTValueA_1;
      RegNTValueA91;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue095; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue094;
          Exit;
        end;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      if Odd       ((nt_pix_intr_sht_arr_ptr^+v)^) then
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      if Odd       ((nt_pix_intr_sht_arr_ptr^+v)^) then
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      if Odd       ((nt_pix_intr_sht_arr_ptr^+v)^) then
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      if Odd       ((nt_pix_intr_sht_arr_ptr^+v)^) then
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue097; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue096;
          Exit;
        end;
      PPMonoNoiseDec(bmp_bkgnd_ptr,
                     rct_dst,
                     bmp_bkgnd_width,
                     monochrome_val,
                     cfx_pow0);
    end;
end; {$endregion}

{ColorizeR}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegNTValue10A; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=ColorizeR(
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,cfx_pow0_);
              Inc    (nt_pix_intr_sht_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegNTValue100; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegNTValueA_0;
      RegNTValue10A;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTValue102; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTValueA_1;
      RegNTValue10A;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue104; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=ColorizeR(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=ColorizeR(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=ColorizeR(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=ColorizeR(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue106; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPColorCorrectionM0(@ColorizeR,
                        bmp_bkgnd_ptr,
                        rct_dst,
                        bmp_bkgnd_width,
                        alpha_max-cfx_pow0);
end; {$endregion}
// (fading):
// same;

{ColorizeG}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegNTValue11A; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=ColorizeG(
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,cfx_pow0_);
              Inc    (nt_pix_intr_sht_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegNTValue110; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegNTValueA_0;
      RegNTValue11A;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTValue112; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTValueA_1;
      RegNTValue11A;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue114; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=ColorizeG(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=ColorizeG(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=ColorizeG(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=ColorizeG(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue116; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPColorCorrectionM0(@ColorizeG,
                        bmp_bkgnd_ptr,
                        rct_dst,
                        bmp_bkgnd_width,
                        alpha_max-cfx_pow0);
end; {$endregion}
// (fading):
// same;

{ColorizeB}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegNTValue12A; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=ColorizeB(
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,cfx_pow0_);
              Inc    (nt_pix_intr_sht_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegNTValue120; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegNTValueA_0;
      RegNTValue12A;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTValue122; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTValueA_1;
      RegNTValue12A;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue124; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=ColorizeB(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=ColorizeB(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=ColorizeB(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=ColorizeB(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue126; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPColorCorrectionM0(@ColorizeB,
                        bmp_bkgnd_ptr,
                        rct_dst,
                        bmp_bkgnd_width,
                        alpha_max-cfx_pow0);
end; {$endregion}
// (fading):
// same;

{BlurRGB}
// (constant) not clippped:
procedure TFastImageProc.RegNTValue130; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_0(@BlurRGB);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTValue132; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_2(@BlurRGB);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue134; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_4(@BlurRGB);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue136; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPBlur(bmp_bkgnd_ptr,
           rct_dst,
           bmp_bkgnd_width,
           0);
end; {$endregion}
// (fading) auxiliary procedure:
procedure TFastImageProc.RegNTValueC31; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to    nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              BlurRGBDec(nt_pix_intr_sht_arr_ptr^+pix_color_ptr,bmp_bkgnd_width,cfx_pow0_);
              Inc       (nt_pix_intr_sht_arr_ptr);
            end;
          Inc           (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegNTValue131; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_0(@BlurRGB);
          Exit;
        end;
      RegNTValueA_0;
      RegNTValueC31;
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegNTValue133; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_2(@BlurRGB);
          Exit;
        end;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTValueA_1;
      RegNTValueC31;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue135; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_4(@BlurRGB);
          Exit;
        end;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      BlurRGBDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      BlurRGBDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      BlurRGBDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      BlurRGBDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue137; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue136;
          Exit;
        end;
      PPBDec(bmp_bkgnd_ptr,
             rct_dst,
             bmp_bkgnd_width,
             alpha_max-cfx_pow0,
             @BlurRGBDec);
    end;
end; {$endregion}

{BlurRRB}
// (constant) not clippped:
procedure TFastImageProc.RegNTValue140; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_0(@BlurRRB);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTValue142; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_2(@BlurRRB);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue144; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_4(@BlurRRB);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue146; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPBlur(bmp_bkgnd_ptr,
           rct_dst,
           bmp_bkgnd_width,
           1);
end; {$endregion}
// (fading) auxiliary procedure:
procedure TFastImageProc.RegNTValueC41; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to    nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              BlurRRBDec(nt_pix_intr_sht_arr_ptr^+pix_color_ptr,bmp_bkgnd_width,cfx_pow0_);
              Inc       (nt_pix_intr_sht_arr_ptr);
            end;
          Inc           (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegNTValue141; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_0(@BlurRRB);
          Exit;
        end;
      RegNTValueA_0;
      RegNTValueC41;
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegNTValue143; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_2(@BlurRRB);
          Exit;
        end;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTValueA_1;
      RegNTValueC41;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue145; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_4(@BlurRRB);
          Exit;
        end;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      BlurRRBDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      BlurRRBDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      BlurRRBDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      BlurRRBDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue147; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue146;
          Exit;
        end;
      PPBDec(bmp_bkgnd_ptr,
             rct_dst,
             bmp_bkgnd_width,
             alpha_max-cfx_pow0,
             @BlurRRBDec);
    end;
end; {$endregion}

{BlurRGR}
// (constant) not clippped:
procedure TFastImageProc.RegNTValue150; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_0(@BlurRGR);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTValue152; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_2(@BlurRGR);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue154; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_4(@BlurRGR);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue156; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPBlur(bmp_bkgnd_ptr,
           rct_dst,
           bmp_bkgnd_width,
           2);
end; {$endregion}
// (fading) auxiliary procedure:
procedure TFastImageProc.RegNTValueC51; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to    nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              BlurRGRDec(nt_pix_intr_sht_arr_ptr^+pix_color_ptr,bmp_bkgnd_width,cfx_pow0_);
              Inc       (nt_pix_intr_sht_arr_ptr);
            end;
          Inc           (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegNTValue151; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_0(@BlurRGR);
          Exit;
        end;
      RegNTValueA_0;
      RegNTValueC51;
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegNTValue153; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_2(@BlurRGR);
          Exit;
        end;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTValueA_1;
      RegNTValueC51;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue155; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_4(@BlurRGR);
          Exit;
        end;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      BlurRGRDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      BlurRGRDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      BlurRGRDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      BlurRGRDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue157; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue156;
          Exit;
        end;
      PPBDec(bmp_bkgnd_ptr,
             rct_dst,
             bmp_bkgnd_width,
             alpha_max-cfx_pow0,
             @BlurRGRDec);
    end;
end; {$endregion}

{BlurGGB}
// (constant) not clippped:
procedure TFastImageProc.RegNTValue160; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_0(@BlurGGB);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTValue162; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_2(@BlurGGB);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue164; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_4(@BlurGGB);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue166; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPBlur(bmp_bkgnd_ptr,
           rct_dst,
           bmp_bkgnd_width,
           3);
end; {$endregion}
// (fading) auxiliary procedure:
procedure TFastImageProc.RegNTValueC61; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to    nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              BlurGGBDec(nt_pix_intr_sht_arr_ptr^+pix_color_ptr,bmp_bkgnd_width,cfx_pow0_);
              Inc       (nt_pix_intr_sht_arr_ptr);
            end;
          Inc           (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegNTValue161; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_0(@BlurGGB);
          Exit;
        end;
      RegNTValueA_0;
      RegNTValueC61;
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegNTValue163; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_2(@BlurGGB);
          Exit;
        end;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTValueA_1;
      RegNTValueC61;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue165; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_4(@BlurGGB);
          Exit;
        end;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      BlurGGBDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      BlurGGBDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      BlurGGBDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      BlurGGBDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue167; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue166;
          Exit;
        end;
      PPBDec(bmp_bkgnd_ptr,
             rct_dst,
             bmp_bkgnd_width,
             alpha_max-cfx_pow0,
             @BlurGGBDec);
    end;
end; {$endregion}

{BlurRGG}
// (constant) not clippped:
procedure TFastImageProc.RegNTValue170; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_0(@BlurRGG);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTValue172; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_2(@BlurRGG);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue174; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_4(@BlurRGG);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue176; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPBlur(bmp_bkgnd_ptr,
           rct_dst,
           bmp_bkgnd_width,
           4);
end; {$endregion}
// (fading) auxiliary procedure:
procedure TFastImageProc.RegNTValueC71; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to    nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              BlurRGGDec(nt_pix_intr_sht_arr_ptr^+pix_color_ptr,bmp_bkgnd_width,cfx_pow0_);
              Inc       (nt_pix_intr_sht_arr_ptr);
            end;
          Inc           (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegNTValue171; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_0(@BlurRGG);
          Exit;
        end;
      RegNTValueA_0;
      RegNTValueC71;
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegNTValue173; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_2(@BlurRGG);
          Exit;
        end;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTValueA_1;
      RegNTValueC71;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue175; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_4(@BlurRGG);
          Exit;
        end;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      BlurRGGDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      BlurRGGDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      BlurRGGDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      BlurRGGDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue177; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue176;
          Exit;
        end;
      PPBDec(bmp_bkgnd_ptr,
             rct_dst,
             bmp_bkgnd_width,
             alpha_max-cfx_pow0,
             @BlurRGGDec);
    end;
end; {$endregion}

{BlurBGB}
// (constant) not clippped:
procedure TFastImageProc.RegNTValue180; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_0(@BlurBGB);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTValue182; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_2(@BlurBGB);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue184; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_4(@BlurBGB);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue186; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPBlur(bmp_bkgnd_ptr,
           rct_dst,
           bmp_bkgnd_width,
           5);
end; {$endregion}
// (fading) auxiliary procedure:
procedure TFastImageProc.RegNTValueC81; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to    nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              BlurBGBDec(nt_pix_intr_sht_arr_ptr^+pix_color_ptr,bmp_bkgnd_width,cfx_pow0_);
              Inc       (nt_pix_intr_sht_arr_ptr);
            end;
          Inc           (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegNTValue181; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_0(@BlurBGB);
          Exit;
        end;
      RegNTValueA_0;
      RegNTValueC81;
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegNTValue183; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_2(@BlurBGB);
          Exit;
        end;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTValueA_1;
      RegNTValueC81;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue185; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_4(@BlurBGB);
          Exit;
        end;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      BlurBGBDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      BlurBGBDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      BlurBGBDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      BlurBGBDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue187; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue186;
          Exit;
        end;
      PPBDec(bmp_bkgnd_ptr,
             rct_dst,
             bmp_bkgnd_width,
             alpha_max-cfx_pow0,
             @BlurBGBDec);
    end;
end; {$endregion}

{BlurRBB}
// (constant) not clippped:
procedure TFastImageProc.RegNTValue190; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_0(@BlurRBB);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTValue192; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_2(@BlurRBB);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue194; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_4(@BlurRBB);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue196; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPBlur(bmp_bkgnd_ptr,
           rct_dst,
           bmp_bkgnd_width,
           6);
end; {$endregion}
// (fading) auxiliary procedure:
procedure TFastImageProc.RegNTValueC91; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to    nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              BlurRBBDec(nt_pix_intr_sht_arr_ptr^+pix_color_ptr,bmp_bkgnd_width,cfx_pow0_);
              Inc       (nt_pix_intr_sht_arr_ptr);
            end;
          Inc           (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegNTValue191; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_0(@BlurRBB);
          Exit;
        end;
      RegNTValueA_0;
      RegNTValueC91;
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegNTValue193; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_2(@BlurRBB);
          Exit;
        end;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTValueA_1;
      RegNTValueC91;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue195; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_4(@BlurRBB);
          Exit;
        end;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      BlurRBBDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      BlurRBBDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      BlurRBBDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      BlurRBBDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue197; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue196;
          Exit;
        end;
      PPBDec(bmp_bkgnd_ptr,
             rct_dst,
             bmp_bkgnd_width,
             alpha_max-cfx_pow0,
             @BlurRBBDec);
    end;
end; {$endregion}

{BlurRRR}
// (constant) not clippped:
procedure TFastImageProc.RegNTValue200; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_0(@BlurRRR);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTValue202; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_2(@BlurRRR);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue204; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_4(@BlurRRR);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue206; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPBlur(bmp_bkgnd_ptr,
           rct_dst,
           bmp_bkgnd_width,
           7);
end; {$endregion}
// (fading) auxiliary procedure:
procedure TFastImageProc.RegNTValueD01; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to    nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              BlurRRRDec(nt_pix_intr_sht_arr_ptr^+pix_color_ptr,bmp_bkgnd_width,cfx_pow0_);
              Inc       (nt_pix_intr_sht_arr_ptr);
            end;
          Inc           (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegNTValue201; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_0(@BlurRRR);
          Exit;
        end;
      RegNTValueA_0;
      RegNTValueD01;
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegNTValue203; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_2(@BlurRRR);
          Exit;
        end;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTValueA_1;
      RegNTValueD01;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue205; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_4(@BlurRRR);
          Exit;
        end;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      BlurRRRDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      BlurRRRDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      BlurRRRDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      BlurRRRDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue207; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue206;
          Exit;
        end;
      PPBDec(bmp_bkgnd_ptr,
             rct_dst,
             bmp_bkgnd_width,
             alpha_max-cfx_pow0,
             @BlurRRRDec);
    end;
end; {$endregion}

{BlurGGG}
// (constant) not clippped:
procedure TFastImageProc.RegNTValue210; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_0(@BlurGGG);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTValue212; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_2(@BlurGGG);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue214; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_4(@BlurGGG);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue216; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPBlur(bmp_bkgnd_ptr,
           rct_dst,
           bmp_bkgnd_width,
           8);
end; {$endregion}
// (fading) auxiliary procedure:
procedure TFastImageProc.RegNTValueD11; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to    nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              BlurGGGDec(nt_pix_intr_sht_arr_ptr^+pix_color_ptr,bmp_bkgnd_width,cfx_pow0_);
              Inc       (nt_pix_intr_sht_arr_ptr);
            end;
          Inc           (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegNTValue211; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_0(@BlurGGG);
          Exit;
        end;
      RegNTValueA_0;
      RegNTValueD11;
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegNTValue213; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_2(@BlurGGG);
          Exit;
        end;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTValueA_1;
      RegNTValueD11;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue215; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_4(@BlurGGG);
          Exit;
        end;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      BlurGGGDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      BlurGGGDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      BlurGGGDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      BlurGGGDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue217; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue216;
          Exit;
        end;
      PPBDec(bmp_bkgnd_ptr,
             rct_dst,
             bmp_bkgnd_width,
             alpha_max-cfx_pow0,
             @BlurGGGDec);
    end;
end; {$endregion}

{BlurBBB}
// (constant) not clippped:
procedure TFastImageProc.RegNTValue220; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_0(@BlurBBB);
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTValue222; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_2(@BlurBBB);
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue224; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTProc1_4(@BlurBBB);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue226; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPBlur(bmp_bkgnd_ptr,
           rct_dst,
           bmp_bkgnd_width,
           9);
end; {$endregion}
// (fading) auxiliary procedure:
procedure TFastImageProc.RegNTValueD21; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to    nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              BlurBBBDec(nt_pix_intr_sht_arr_ptr^+pix_color_ptr,bmp_bkgnd_width,cfx_pow0_);
              Inc       (nt_pix_intr_sht_arr_ptr);
            end;
          Inc           (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegNTValue221; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_0(@BlurBBB);
          Exit;
        end;
      RegNTValueA_0;
      RegNTValueD21;
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegNTValue223; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_2(@BlurBBB);
          Exit;
        end;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTValueA_1;
      RegNTValueD21;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue225; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTProc1_4(@BlurBBB);
          Exit;
        end;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      BlurBBBDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      BlurBBBDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      BlurBBBDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      BlurBBBDec    (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue227; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue226;
          Exit;
        end;
      PPBDec(bmp_bkgnd_ptr,
             rct_dst,
             bmp_bkgnd_width,
             alpha_max-cfx_pow0,
             @BlurBBBDec);
    end;
end; {$endregion}

{Contrast}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegNTValue23A; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  contrast_pow           : integer;
  r                      : byte=128;
  g                      : byte=128;
  b                      : byte=128;
begin
  with fast_image_data_ptr0^ do
    begin
      contrast_pow           :=ContrastPrecalc(1+cfx_pow0/10);
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to   nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              Contrast2(nt_pix_intr_sht_arr_ptr^+pix_color_ptr,r,g,b,contrast_pow);
              Inc      (nt_pix_intr_sht_arr_ptr);
            end;
          Inc          (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegNTValue230; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegNTValueA_0;
      RegNTValue23A;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegNTValue232; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      RegNTValueA_1;
      RegNTValue23A;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegNTValue234; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  contrast_pow           : integer;
  r                      : byte=128;
  g                      : byte=128;
  b                      : byte=128;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      contrast_pow           :=ContrastPrecalc(1+cfx_pow0/10);
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      Contrast2     (nt_pix_intr_sht_arr_ptr^+v,r,g,b,contrast_pow);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      Contrast2     (nt_pix_intr_sht_arr_ptr^+v,r,g,b,contrast_pow);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      Contrast2     (nt_pix_intr_sht_arr_ptr^+v,r,g,b,contrast_pow);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      Contrast2     (nt_pix_intr_sht_arr_ptr^+v,r,g,b,contrast_pow);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue236; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    PPContrast1(bmp_bkgnd_ptr,
                rct_dst,
                bmp_bkgnd_width,
                cfx_pow0);
end; {$endregion}
// (fading):
// same;

{$endregion}

{Noise} {$region -fold}



{$endregion}

// PT - partly transparent pixels:

{Value} {$region -fold}

// auxiliary procedures:
procedure TFastImageProc.RegPTValueA_0; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      res_var0:=0000000000000000+pt_pix_arr_row_mrg_top;
      res_var1:=0;
      res_var2:=bmp_ftimg_height-pt_pix_arr_row_mrg_top-
                                 pt_pix_arr_row_mrg_btm-1;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueA_1; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      res_var0:=00000000000000+rct_src.top;
      res_var1:=pt_cnt_ind_arr[rct_src.top];
      res_var2:=00000000000000+rct_src.height-1;
    end;
end; {$endregion}

// auxiliary procedures:
// (constant) not clippped and top-bottom clippped:
procedure TFastImageProc.RegPTProcC_0(Proc19:TProc19); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to   pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              Proc19   (pt_pix_intr_sht_arr_ptr^+pix_color_ptr,bmp_bkgnd_width,
              alpha_max-pt_pix_byte_acl_arr_ptr^);
              Inc      (pt_pix_intr_sht_arr_ptr);
              Inc      (pt_pix_byte_acl_arr_ptr);
            end;
          Inc          (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTProcD_0(Proc8 :TProc8 ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              Proc8  (pt_pix_intr_sht_arr_ptr^+pix_color_ptr,bmp_bkgnd_width);
              Inc    (pt_pix_intr_sht_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTProcC_4(Proc19:TProc19); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc19        (pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      Proc19        (pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      Proc19        (pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      Proc19        (pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTProcD_4(Proc8 :TProc8 ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc8         (pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      Proc8         (pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      Proc8         (pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      Proc8         (pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped and top-bottom clippped:
procedure TFastImageProc.RegPTProcC_1(Proc19:TProc19); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to       pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              Proc19       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr,bmp_bkgnd_width,
              alpha_max-Max(pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
              Inc          (pt_pix_intr_sht_arr_ptr);
              Inc          (pt_pix_byte_acl_arr_ptr);
            end;
          Inc              (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTProcD_1(Proc19:TProc19); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              Proc19 (pt_pix_intr_sht_arr_ptr^+pix_color_ptr,bmp_bkgnd_width,cfx_pow0_);
              Inc    (pt_pix_intr_sht_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTProcC_5(Proc19:TProc19); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc19        (pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,
                      alpha_max-Max (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      Proc19        (pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,
                      alpha_max-Max (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      Proc19        (pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,
                      alpha_max-Max (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      Proc19        (pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,
                      alpha_max-Max (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTProcD_5(Proc19:TProc19); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc19        (pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      Proc19        (pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      Proc19        (pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      Proc19        (pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}

{Empty}
procedure TFastImageProc.RegPTValue009; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Monochrome}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA00; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to   pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendB(
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,monochrome_val,
              alpha_max-pt_pix_byte_acl_arr_ptr^);
              Inc      (pt_pix_intr_sht_arr_ptr);
              Inc      (pt_pix_byte_acl_arr_ptr);
            end;
          Inc          (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB00; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=monochrome_val;
              Inc    (pt_pix_intr_sht_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegPTValue000; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTValueA00
      else
        RegPTValueB00;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTValue002; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTValueA00
      else
        RegPTValueB00;
    end;
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA04; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB04; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=monochrome_val;
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=monochrome_val;
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=monochrome_val;
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=monochrome_val;
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue004; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTValueA04
      else
        RegPTValueB04;
    end;
end; {$endregion}
// (fading):
// same;

{Additive}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA10; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to   pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDecB(
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,monochrome_val,
              alpha_max-pt_pix_byte_acl_arr_ptr^);
              Inc      (pt_pix_intr_sht_arr_ptr);
              Inc      (pt_pix_byte_acl_arr_ptr);
            end;
          Inc          (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB10; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveA(
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,monochrome_val);
              Inc    (pt_pix_intr_sht_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegPTValue010; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTValueA10
      else
        RegPTValueB10;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTValue012; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTValueA10
      else
        RegPTValueB10;
    end;
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA14; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB14; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue014; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTValueA14
      else
        RegPTValueB14;
    end;
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTValueA11; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to       pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                           (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDecB(
                           (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,monochrome_val,
              alpha_max-Max(pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
              Inc          (pt_pix_intr_sht_arr_ptr);
              Inc          (pt_pix_byte_acl_arr_ptr);
            end;
          Inc              (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB11; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDecB(
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,monochrome_val,cfx_pow0_);
              Inc    (pt_pix_intr_sht_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegPTValue011; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTValueA11
      else
        RegPTValueB11;
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegPTValue013; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTValueA11
      else
        RegPTValueB11;
    end;
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTValueA15; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,
                      alpha_max-Max (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,
                      alpha_max-Max (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,
                      alpha_max-Max (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,
                      alpha_max-Max (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB15; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue015; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTValueA15
      else
        RegPTValueB15;
    end;
end; {$endregion}

{Alphablend}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA20; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueA00;
          Exit;
        end;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to   pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendDecB(
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,monochrome_val,
                        pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
              Inc      (pt_pix_intr_sht_arr_ptr);
              Inc      (pt_pix_byte_acl_arr_ptr);
            end;
          Inc          (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB20; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueB00;
          Exit;
        end;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendB(
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,monochrome_val,cfx_pow0_);
              Inc    (pt_pix_intr_sht_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegPTValue020; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTValueA20
      else
        RegPTValueB20;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTValue022; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTValueA20
      else
        RegPTValueB20;
    end;
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA24; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueA04;
          Exit;
        end;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,
                                     pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,
                                     pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,
                                     pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,
                                     pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB24; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueB04;
          Exit;
        end;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue024; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTValueA24
      else
        RegPTValueB24;
    end;
end; {$endregion}
// (fading):
// same;

{Inverse}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA30; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to     pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              InverseDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
              alpha_max-  pt_pix_byte_acl_arr_ptr^);
              Inc        (pt_pix_intr_sht_arr_ptr);
              Inc        (pt_pix_byte_acl_arr_ptr);
            end;
          Inc            (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB30; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=InverseA(
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^);
              Inc    (pt_pix_intr_sht_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegPTValue030; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTValueA30
      else
        RegPTValueB30;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTValue032; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTValueA30
      else
        RegPTValueB30;
    end;
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA34; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      InverseDec   ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      InverseDec   ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      InverseDec   ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      InverseDec   ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB34; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=InverseA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=InverseA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=InverseA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=InverseA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue034; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTValueA34
      else
        RegPTValueB34;
    end;
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTValueA31; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueA30;
          Exit;
        end;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to       pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              InverseDec  ((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
              alpha_max-Max(pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
              Inc          (pt_pix_intr_sht_arr_ptr);
              Inc          (pt_pix_byte_acl_arr_ptr);
            end;
          Inc              (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB31; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueB30;
          Exit;
        end;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to     pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              InverseDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,cfx_pow0_);
              Inc        (pt_pix_intr_sht_arr_ptr);
            end;
          Inc            (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegPTValue031; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTValueA31
      else
        RegPTValueB31;
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegPTValue033; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTValueA31
      else
        RegPTValueB31;
    end;
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTValueA35; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueA34;
          Exit;
        end;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      InverseDec   ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-Max (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      InverseDec   ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-Max (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      InverseDec   ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-Max (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      InverseDec   ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-Max (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB35; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueB34;
          Exit;
        end;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      InverseDec   ((pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      InverseDec   ((pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      InverseDec   ((pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      InverseDec   ((pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue035; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTValueA35
      else
        RegPTValueB35;
    end;
end; {$endregion}

{Highlight}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA40; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to       pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              HighlightDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
              alpha_max-    pt_pix_byte_acl_arr_ptr^,cfx_pow0);
              Inc          (pt_pix_intr_sht_arr_ptr);
              Inc          (pt_pix_byte_acl_arr_ptr);
            end;
          Inc              (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB40; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=HighlightA(
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,cfx_pow0);
              Inc    (pt_pix_intr_sht_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegPTValue040; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTValueA40
      else
        RegPTValueB40;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTValue042; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTValueA40
      else
        RegPTValueB40;
    end;
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA44; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      HighlightDec ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      HighlightDec ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      HighlightDec ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      HighlightDec ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB44; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=HighlightA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=HighlightA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=HighlightA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=HighlightA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue044; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTValueA44
      else
        RegPTValueB44;
    end;
end; {$endregion}
// (fading):
// same;

{Darken}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA50; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to    pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              DarkenDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
              alpha_max- pt_pix_byte_acl_arr_ptr^,cfx_pow0);
              Inc       (pt_pix_intr_sht_arr_ptr);
              Inc       (pt_pix_byte_acl_arr_ptr);
            end;
          Inc           (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB50; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  d                      : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=DarkenA(
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,cfx_pow0);
              Inc    (pt_pix_intr_sht_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegPTValue050; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTValueA50
      else
        RegPTValueB50;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTValue052; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTValueA50
      else
        RegPTValueB50;
    end;
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA54; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      DarkenDec    ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      DarkenDec    ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      DarkenDec    ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      DarkenDec    ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB54; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=DarkenA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=DarkenA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=DarkenA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=DarkenA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue054; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTValueA54
      else
        RegPTValueB54;
    end;
end; {$endregion}
// (fading):
// same;

{GrayscaleR}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA60; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              GrayscaleRDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                             pt_pix_byte_acl_arr_ptr^);
              Inc           (pt_pix_intr_sht_arr_ptr);
              Inc           (pt_pix_byte_acl_arr_ptr);
            end;
          Inc               (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB60; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleR0(
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^);
              Inc    (pt_pix_intr_sht_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegPTValue060; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTValueA60
      else
        RegPTValueB60;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTValue062; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTValueA60
      else
        RegPTValueB60;
    end;
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA64; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      GrayscaleRDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      GrayscaleRDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      GrayscaleRDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      GrayscaleRDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB64; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleR0(
                                    (pt_pix_intr_sht_arr_ptr^+v)^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleR0(
                                    (pt_pix_intr_sht_arr_ptr^+v)^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleR0(
                                    (pt_pix_intr_sht_arr_ptr^+v)^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleR0(
                                    (pt_pix_intr_sht_arr_ptr^+v)^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue064; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTValueA64
      else
        RegPTValueB64;
    end;
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTValueA61; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueA60;
          Exit;
        end;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              GrayscaleRDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
              Max           (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
              Inc           (pt_pix_intr_sht_arr_ptr);
              Inc           (pt_pix_byte_acl_arr_ptr);
            end;
          Inc               (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB61; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueB60;
          Exit;
        end;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              GrayscaleRDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,cfx_pow0);
              Inc           (pt_pix_intr_sht_arr_ptr);
            end;
          Inc               (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegPTValue061; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTValueA61
      else
        RegPTValueB61;
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegPTValue063; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTValueA61
      else
        RegPTValueB61;
    end;
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTValueA65; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueA64;
          Exit;
        end;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      GrayscaleRDec((pt_pix_intr_sht_arr_ptr^+v)^,
                      Max           (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      GrayscaleRDec((pt_pix_intr_sht_arr_ptr^+v)^,
                      Max           (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      GrayscaleRDec((pt_pix_intr_sht_arr_ptr^+v)^,
                      Max           (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      GrayscaleRDec((pt_pix_intr_sht_arr_ptr^+v)^,
                      Max           (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB65; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueB64;
          Exit;
        end;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      GrayscaleRDec((pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      GrayscaleRDec((pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      GrayscaleRDec((pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      GrayscaleRDec((pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue065; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTValueA65
      else
        RegPTValueB65;
    end;
end; {$endregion}

{GrayscaleG}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA70; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              GrayscaleGDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                             pt_pix_byte_acl_arr_ptr^);
              Inc           (pt_pix_intr_sht_arr_ptr);
              Inc           (pt_pix_byte_acl_arr_ptr);
            end;
          Inc               (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB70; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleG0(
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^);
              Inc    (pt_pix_intr_sht_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegPTValue070; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTValueA70
      else
        RegPTValueB70;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTValue072; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTValueA70
      else
        RegPTValueB70;
    end;
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA74; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      GrayscaleGDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      GrayscaleGDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      GrayscaleGDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      GrayscaleGDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB74; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleG0(
                                    (pt_pix_intr_sht_arr_ptr^+v)^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleG0(
                                    (pt_pix_intr_sht_arr_ptr^+v)^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleG0(
                                    (pt_pix_intr_sht_arr_ptr^+v)^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleG0(
                                    (pt_pix_intr_sht_arr_ptr^+v)^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue074; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTValueA74
      else
        RegPTValueB74;
    end;
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTValueA71; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueA70;
          Exit;
        end;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              GrayscaleGDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
              Max           (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
              Inc           (pt_pix_intr_sht_arr_ptr);
              Inc           (pt_pix_byte_acl_arr_ptr);
            end;
          Inc               (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB71; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueB70;
          Exit;
        end;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              GrayscaleGDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,cfx_pow0);
              Inc           (pt_pix_intr_sht_arr_ptr);
            end;
          Inc               (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegPTValue071; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTValueA71
      else
        RegPTValueB71;
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegPTValue073; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTValueA71
      else
        RegPTValueB71;
    end;
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTValueA75; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueA74;
          Exit;
        end;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      GrayscaleGDec((pt_pix_intr_sht_arr_ptr^+v)^,
                      Max           (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      GrayscaleGDec((pt_pix_intr_sht_arr_ptr^+v)^,
                      Max           (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      GrayscaleGDec((pt_pix_intr_sht_arr_ptr^+v)^,
                      Max           (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      GrayscaleGDec((pt_pix_intr_sht_arr_ptr^+v)^,
                      Max           (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB75; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueB74;
          Exit;
        end;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      GrayscaleGDec((pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      GrayscaleGDec((pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      GrayscaleGDec((pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      GrayscaleGDec((pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue075; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTValueA75
      else
        RegPTValueB75;
    end;
end; {$endregion}

{GrayscaleB}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA80; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              GrayscaleBDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                             pt_pix_byte_acl_arr_ptr^);
              Inc           (pt_pix_intr_sht_arr_ptr);
              Inc           (pt_pix_byte_acl_arr_ptr);
            end;
          Inc               (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB80; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=GrayscaleB0(
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^);
              Inc    (pt_pix_intr_sht_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegPTValue080; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTValueA80
      else
        RegPTValueB80;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTValue082; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTValueA80
      else
        RegPTValueB80;
    end;
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA84; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      GrayscaleBDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      GrayscaleBDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      GrayscaleBDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      GrayscaleBDec((pt_pix_intr_sht_arr_ptr^+v)^,
                                     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB84; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleB0(
                                    (pt_pix_intr_sht_arr_ptr^+v)^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleB0(
                                    (pt_pix_intr_sht_arr_ptr^+v)^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleB0(
                                    (pt_pix_intr_sht_arr_ptr^+v)^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=GrayscaleB0(
                                    (pt_pix_intr_sht_arr_ptr^+v)^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue084; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTValueA84
      else
        RegPTValueB84;
    end;
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTValueA81; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueA80;
          Exit;
        end;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              GrayscaleBDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
              Max           (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
              Inc           (pt_pix_intr_sht_arr_ptr);
              Inc           (pt_pix_byte_acl_arr_ptr);
            end;
          Inc               (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB81; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueB80;
          Exit;
        end;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              GrayscaleBDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,cfx_pow0);
              Inc           (pt_pix_intr_sht_arr_ptr);
            end;
          Inc               (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegPTValue081; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTValueA81
      else
        RegPTValueB81;
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegPTValue083; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTValueA81
      else
        RegPTValueB81;
    end;
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTValueA85; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueA84;
          Exit;
        end;
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      GrayscaleBDec((pt_pix_intr_sht_arr_ptr^+v)^,
                      Max           (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      GrayscaleBDec((pt_pix_intr_sht_arr_ptr^+v)^,
                      Max           (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      GrayscaleBDec((pt_pix_intr_sht_arr_ptr^+v)^,
                      Max           (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      GrayscaleBDec((pt_pix_intr_sht_arr_ptr^+v)^,
                      Max           (pt_pix_byte_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB85; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueB84;
          Exit;
        end;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      GrayscaleBDec((pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      GrayscaleBDec((pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      GrayscaleBDec((pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      GrayscaleBDec((pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue085; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTValueA85
      else
        RegPTValueB85;
    end;
end; {$endregion}

{Monochrome Noise}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA90; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to   pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              if Odd  ((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendB(
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,monochrome_val,
              alpha_max-pt_pix_byte_acl_arr_ptr^);
              Inc      (pt_pix_intr_sht_arr_ptr);
              Inc      (pt_pix_byte_acl_arr_ptr);
            end;
          Inc          (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB90; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              if Odd((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=monochrome_val;
              Inc    (pt_pix_intr_sht_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegPTValue090; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTValueA90
      else
        RegPTValueB90;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTValue092; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTValueA90
      else
        RegPTValueB90;
    end;
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA94; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      if Odd       ((pt_pix_intr_sht_arr_ptr^+v)^) then
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      if Odd       ((pt_pix_intr_sht_arr_ptr^+v)^) then
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      if Odd       ((pt_pix_intr_sht_arr_ptr^+v)^) then
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      if Odd       ((pt_pix_intr_sht_arr_ptr^+v)^) then
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB94; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      if Odd(       (pt_pix_intr_sht_arr_ptr^+v)^) then
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=monochrome_val;
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      if Odd(       (pt_pix_intr_sht_arr_ptr^+v)^) then
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=monochrome_val;
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      if Odd(       (pt_pix_intr_sht_arr_ptr^+v)^) then
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=monochrome_val;
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      if Odd(       (pt_pix_intr_sht_arr_ptr^+v)^) then
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=monochrome_val;
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue094; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTValueA94
      else
        RegPTValueB94;
    end;
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTValueA91; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to   pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              if Odd  ((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendDecB(
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,monochrome_val,
                        pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
              Inc      (pt_pix_intr_sht_arr_ptr);
              Inc      (pt_pix_byte_acl_arr_ptr);
            end;
          Inc          (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB91; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to   pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              if Odd  ((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendB(
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,monochrome_val,cfx_pow0_);
              Inc      (pt_pix_intr_sht_arr_ptr);
            end;
          Inc          (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegPTValue091; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTValueA91
      else
        RegPTValueB91;
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegPTValue093; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTValueA91
      else
        RegPTValueB91;
    end;
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTValueA95; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      if Odd       ((pt_pix_intr_sht_arr_ptr^+v)^) then
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,
                                     pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      if Odd       ((pt_pix_intr_sht_arr_ptr^+v)^) then
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,
                                     pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      if Odd       ((pt_pix_intr_sht_arr_ptr^+v)^) then
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,
                                     pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      if Odd       ((pt_pix_intr_sht_arr_ptr^+v)^) then
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDecB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,
                                     pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB95; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      if Odd       ((pt_pix_intr_sht_arr_ptr^+v)^) then
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      if Odd       ((pt_pix_intr_sht_arr_ptr^+v)^) then
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      if Odd       ((pt_pix_intr_sht_arr_ptr^+v)^) then
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      if Odd       ((pt_pix_intr_sht_arr_ptr^+v)^) then
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,monochrome_val,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue095; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTValueA95
      else
        RegPTValueB95;
    end;
end; {$endregion}

{ColorizeR}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueC00; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to       pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              ColorizeRDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
              alpha_max-    pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
              Inc          (pt_pix_intr_sht_arr_ptr);
              Inc          (pt_pix_byte_acl_arr_ptr);
            end;
          Inc              (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueD00; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to   pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=ColorizeR(
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,cfx_pow0_);
              Inc      (pt_pix_intr_sht_arr_ptr);
            end;
          Inc          (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegPTValue100; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTValueC00
      else
        RegPTValueD00;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTValue102; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTValueC00
      else
        RegPTValueD00;
    end;
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueC04; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      ColorizeRDec ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      ColorizeRDec ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      ColorizeRDec ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      ColorizeRDec ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueD04; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeR(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeR(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeR(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeR(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue104; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTValueC04
      else
        RegPTValueD04;
    end;
end; {$endregion}
// (fading):
// same;

{ColorizeG}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueC10; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to       pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              ColorizeGDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
              alpha_max-    pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
              Inc          (pt_pix_intr_sht_arr_ptr);
              Inc          (pt_pix_byte_acl_arr_ptr);
            end;
          Inc              (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueD10; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to   pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=ColorizeG(
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,cfx_pow0_);
              Inc      (pt_pix_intr_sht_arr_ptr);
            end;
          Inc          (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegPTValue110; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTValueC10
      else
        RegPTValueD10;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTValue112; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTValueC10
      else
        RegPTValueD10;
    end;
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueC14; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      ColorizeGDec ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      ColorizeGDec ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      ColorizeGDec ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      ColorizeGDec ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueD14; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeG(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeG(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeG(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeG(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue114; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTValueC14
      else
        RegPTValueD14;
    end;
end; {$endregion}
// (fading):
// same;

{ColorizeB}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueC20; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to       pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              ColorizeBDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
              alpha_max-    pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
              Inc          (pt_pix_intr_sht_arr_ptr);
              Inc          (pt_pix_byte_acl_arr_ptr);
            end;
          Inc              (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueD20; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  cfx_pow0_              : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to   pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=ColorizeB(
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,cfx_pow0_);
              Inc      (pt_pix_intr_sht_arr_ptr);
            end;
          Inc          (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegPTValue120; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTValueC20
      else
        RegPTValueD20;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTValue122; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTValueC20
      else
        RegPTValueD20;
    end;
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueC24; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      ColorizeBDec ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      ColorizeBDec ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      ColorizeBDec ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      ColorizeBDec ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueD24; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  cfx_pow0_              : byte;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      cfx_pow0_              :=alpha_max-cfx_pow0;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=ColorizeB(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,cfx_pow0_);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue124; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTValueC24
      else
        RegPTValueD24;
    end;
end; {$endregion}
// (fading):
// same;

{BlurRGB}
// (constant) not clippped:
procedure TFastImageProc.RegPTValue130; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTProcC_0(@BlurRGBDec)
      else
        RegPTProcD_0(@BlurRGB   );
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTValue132; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTProcC_0(@BlurRGBDec)
      else
        RegPTProcD_0(@BlurRGB   );
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue134; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTProcC_4(@BlurRGBDec)
      else
        RegPTProcD_4(@BlurRGB   );
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegPTValue131; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_0(@BlurRGBDec)
          else
            RegPTProcD_0(@BlurRGB   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_1(@BlurRGBDec)
      else
        RegPTProcD_1(@BlurRGBDec);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegPTValue133; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_0(@BlurRGBDec)
          else
            RegPTProcD_0(@BlurRGB   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_1(@BlurRGBDec)
      else
        RegPTProcD_1(@BlurRGBDec);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue135; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_4(@BlurRGBDec)
          else
            RegPTProcD_4(@BlurRGB   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_5(@BlurRGBDec)
      else
        RegPTProcD_5(@BlurRGBDec);
    end;
end; {$endregion}

{BlurRRB}
// (constant) not clippped:
procedure TFastImageProc.RegPTValue140; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTProcC_0(@BlurRRBDec)
      else
        RegPTProcD_0(@BlurRRB   );
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTValue142; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTProcC_0(@BlurRRBDec)
      else
        RegPTProcD_0(@BlurRRB   );
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue144; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTProcC_4(@BlurRRBDec)
      else
        RegPTProcD_4(@BlurRRB   );
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegPTValue141; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_0(@BlurRRBDec)
          else
            RegPTProcD_0(@BlurRRB   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_1(@BlurRRBDec)
      else
        RegPTProcD_1(@BlurRRBDec);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegPTValue143; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_0(@BlurRRBDec)
          else
            RegPTProcD_0(@BlurRRB   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_1(@BlurRRBDec)
      else
        RegPTProcD_1(@BlurRRBDec);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue145; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_4(@BlurRRBDec)
          else
            RegPTProcD_4(@BlurRRB   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_5(@BlurRRBDec)
      else
        RegPTProcD_5(@BlurRRBDec);
    end;
end; {$endregion}

{BlurRGR}
// (constant) not clippped:
procedure TFastImageProc.RegPTValue150; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTProcC_0(@BlurRGRDec)
      else
        RegPTProcD_0(@BlurRGR   );
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTValue152; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTProcC_0(@BlurRGRDec)
      else
        RegPTProcD_0(@BlurRGR   );
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue154; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTProcC_4(@BlurRGRDec)
      else
        RegPTProcD_4(@BlurRGR   );
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegPTValue151; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_0(@BlurRGRDec)
          else
            RegPTProcD_0(@BlurRGR   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_1(@BlurRGRDec)
      else
        RegPTProcD_1(@BlurRGRDec);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegPTValue153; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_0(@BlurRGRDec)
          else
            RegPTProcD_0(@BlurRGR   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_1(@BlurRGRDec)
      else
        RegPTProcD_1(@BlurRGRDec);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue155; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_4(@BlurRGRDec)
          else
            RegPTProcD_4(@BlurRGR   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_5(@BlurRGRDec)
      else
        RegPTProcD_5(@BlurRGRDec);
    end;
end; {$endregion}

{BlurGGB}
// (constant) not clippped:
procedure TFastImageProc.RegPTValue160; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTProcC_0(@BlurGGBDec)
      else
        RegPTProcD_0(@BlurGGB   );
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTValue162; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTProcC_0(@BlurGGBDec)
      else
        RegPTProcD_0(@BlurGGB   );
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue164; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTProcC_4(@BlurGGBDec)
      else
        RegPTProcD_4(@BlurGGB   );
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegPTValue161; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_0(@BlurGGBDec)
          else
            RegPTProcD_0(@BlurGGB   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_1(@BlurGGBDec)
      else
        RegPTProcD_1(@BlurGGBDec);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegPTValue163; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_0(@BlurGGBDec)
          else
            RegPTProcD_0(@BlurGGB   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_1(@BlurGGBDec)
      else
        RegPTProcD_1(@BlurGGBDec);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue165; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_4(@BlurGGBDec)
          else
            RegPTProcD_4(@BlurGGB   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_5(@BlurGGBDec)
      else
        RegPTProcD_5(@BlurGGBDec);
    end;
end; {$endregion}

{BlurRGG}
// (constant) not clippped:
procedure TFastImageProc.RegPTValue170; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTProcC_0(@BlurRGGDec)
      else
        RegPTProcD_0(@BlurRGG   );
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTValue172; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTProcC_0(@BlurRGGDec)
      else
        RegPTProcD_0(@BlurRGG   );
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue174; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTProcC_4(@BlurRGGDec)
      else
        RegPTProcD_4(@BlurRGG   );
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegPTValue171; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_0(@BlurRGGDec)
          else
            RegPTProcD_0(@BlurRGG   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_1(@BlurRGGDec)
      else
        RegPTProcD_1(@BlurRGGDec);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegPTValue173; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_0(@BlurRGGDec)
          else
            RegPTProcD_0(@BlurRGG   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_1(@BlurRGGDec)
      else
        RegPTProcD_1(@BlurRGGDec);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue175; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_4(@BlurRGGDec)
          else
            RegPTProcD_4(@BlurRGG   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_5(@BlurRGGDec)
      else
        RegPTProcD_5(@BlurRGGDec);
    end;
end; {$endregion}

{BlurBGB}
// (constant) not clippped:
procedure TFastImageProc.RegPTValue180; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTProcC_0(@BlurBGBDec)
      else
        RegPTProcD_0(@BlurBGB   );
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTValue182; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTProcC_0(@BlurBGBDec)
      else
        RegPTProcD_0(@BlurBGB   );
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue184; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTProcC_4(@BlurBGBDec)
      else
        RegPTProcD_4(@BlurBGB   );
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegPTValue181; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_0(@BlurBGBDec)
          else
            RegPTProcD_0(@BlurBGB   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_1(@BlurBGBDec)
      else
        RegPTProcD_1(@BlurBGBDec);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegPTValue183; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_0(@BlurBGBDec)
          else
            RegPTProcD_0(@BlurBGB   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_1(@BlurBGBDec)
      else
        RegPTProcD_1(@BlurBGBDec);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue185; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_4(@BlurBGBDec)
          else
            RegPTProcD_4(@BlurBGB   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_5(@BlurBGBDec)
      else
        RegPTProcD_5(@BlurBGBDec);
    end;
end; {$endregion}

{BlurRBB}
// (constant) not clippped:
procedure TFastImageProc.RegPTValue190; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTProcC_0(@BlurRBBDec)
      else
        RegPTProcD_0(@BlurRBB   );
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTValue192; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTProcC_0(@BlurRBBDec)
      else
        RegPTProcD_0(@BlurRBB   );
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue194; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTProcC_4(@BlurRBBDec)
      else
        RegPTProcD_4(@BlurRBB   );
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegPTValue191; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_0(@BlurRBBDec)
          else
            RegPTProcD_0(@BlurRBB   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_1(@BlurRBBDec)
      else
        RegPTProcD_1(@BlurRBBDec);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegPTValue193; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_0(@BlurRBBDec)
          else
            RegPTProcD_0(@BlurRBB   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_1(@BlurRBBDec)
      else
        RegPTProcD_1(@BlurRBBDec);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue195; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_4(@BlurRBBDec)
          else
            RegPTProcD_4(@BlurRBB   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_5(@BlurRBBDec)
      else
        RegPTProcD_5(@BlurRBBDec);
    end;
end; {$endregion}

{BlurRRR}
// (constant) not clippped:
procedure TFastImageProc.RegPTValue200; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTProcC_0(@BlurRRRDec)
      else
        RegPTProcD_0(@BlurRRR   );
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTValue202; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTProcC_0(@BlurRRRDec)
      else
        RegPTProcD_0(@BlurRRR   );
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue204; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTProcC_4(@BlurRRRDec)
      else
        RegPTProcD_4(@BlurRRR   );
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegPTValue201; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_0(@BlurRRRDec)
          else
            RegPTProcD_0(@BlurRRR   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_1(@BlurRRRDec)
      else
        RegPTProcD_1(@BlurRRRDec);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegPTValue203; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_0(@BlurRRRDec)
          else
            RegPTProcD_0(@BlurRRR   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_1(@BlurRRRDec)
      else
        RegPTProcD_1(@BlurRRRDec);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue205; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_4(@BlurRRRDec)
          else
            RegPTProcD_4(@BlurRRR   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_5(@BlurRRRDec)
      else
        RegPTProcD_5(@BlurRRRDec);
    end;
end; {$endregion}

{BlurGGG}
// (constant) not clippped:
procedure TFastImageProc.RegPTValue210; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTProcC_0(@BlurGGGDec)
      else
        RegPTProcD_0(@BlurGGG   );
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTValue212; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTProcC_0(@BlurGGGDec)
      else
        RegPTProcD_0(@BlurGGG   );
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue214; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTProcC_4(@BlurGGGDec)
      else
        RegPTProcD_4(@BlurGGG   );
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegPTValue211; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_0(@BlurGGGDec)
          else
            RegPTProcD_0(@BlurGGG   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_1(@BlurGGGDec)
      else
        RegPTProcD_1(@BlurGGGDec);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegPTValue213; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_0(@BlurGGGDec)
          else
            RegPTProcD_0(@BlurGGG   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_1(@BlurGGGDec)
      else
        RegPTProcD_1(@BlurGGGDec);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue215; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_4(@BlurGGGDec)
          else
            RegPTProcD_4(@BlurGGG   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_5(@BlurGGGDec)
      else
        RegPTProcD_5(@BlurGGGDec);
    end;
end; {$endregion}

{BlurBBB}
// (constant) not clippped:
procedure TFastImageProc.RegPTValue220; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTProcC_0(@BlurBBBDec)
      else
        RegPTProcD_0(@BlurBBB   );
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTValue222; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTProcC_0(@BlurBBBDec)
      else
        RegPTProcD_0(@BlurBBB   );
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue224; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTProcC_4(@BlurBBBDec)
      else
        RegPTProcD_4(@BlurBBB   );
    end;
end; {$endregion}
// (fading) not clippped:
procedure TFastImageProc.RegPTValue221; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_0(@BlurBBBDec)
          else
            RegPTProcD_0(@BlurBBB   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_1(@BlurBBBDec)
      else
        RegPTProcD_1(@BlurBBBDec);
    end;
end; {$endregion}
// (fading) top-bottom clippped:
procedure TFastImageProc.RegPTValue223; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_0(@BlurBBBDec)
          else
            RegPTProcD_0(@BlurBBB   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_1(@BlurBBBDec)
      else
        RegPTProcD_1(@BlurBBBDec);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue225; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcC_4(@BlurBBBDec)
          else
            RegPTProcD_4(@BlurBBB   );
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC_5(@BlurBBBDec)
      else
        RegPTProcD_5(@BlurBBBDec);
    end;
end; {$endregion}

{Contrast}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueE30; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  contrast_pow           : integer;
  r                      : byte=128;
  g                      : byte=128;
  b                      : byte=128;
begin
  with fast_image_data_ptr0^ do
    begin
      contrast_pow           :=ContrastPrecalc(1+cfx_pow0/10);
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to   pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=ContrastDec(
                        pt_pix_intr_sht_arr_ptr^+pix_color_ptr,r,g,b,
              alpha_max-pt_pix_byte_acl_arr_ptr^,contrast_pow);
              Inc      (pt_pix_intr_sht_arr_ptr);
              Inc      (pt_pix_byte_acl_arr_ptr);
            end;
          Inc          (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueF30; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  contrast_pow           : integer;
  r                      : byte=128;
  g                      : byte=128;
  b                      : byte=128;
begin
  with fast_image_data_ptr0^ do
    begin
      contrast_pow           :=ContrastPrecalc(1+cfx_pow0/10);
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(res_var0+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ res_var0+000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ res_var1+000000000000000000000000000000000000000000000]);
      for y:=0 to res_var2 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          for x:=0 to   pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              Contrast2(pt_pix_intr_sht_arr_ptr^+pix_color_ptr,r,g,b,contrast_pow);
              Inc      (pt_pix_intr_sht_arr_ptr);
            end;
          Inc          (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.RegPTValue230; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      RegPTValueA_0;
      if (not pt_as_nt) then
        RegPTValueE30
      else
        RegPTValueF30;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.RegPTValue232; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      RegPTValueA_1;
      if (not pt_as_nt) then
        RegPTValueE30
      else
        RegPTValueF30;
    end;
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueE34; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  contrast_pow           : integer;
  r                      : byte=128;
  g                      : byte=128;
  b                      : byte=128;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      contrast_pow           :=ContrastPrecalc(1+cfx_pow0/10);
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=ContrastDec(
                                     pt_pix_intr_sht_arr_ptr^+v,r,g,b,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^,contrast_pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=ContrastDec(
                                     pt_pix_intr_sht_arr_ptr^+v,r,g,b,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^,contrast_pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=ContrastDec(
                                     pt_pix_intr_sht_arr_ptr^+v,r,g,b,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^,contrast_pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=ContrastDec(
                                     pt_pix_intr_sht_arr_ptr^+v,r,g,b,
                      alpha_max-     pt_pix_byte_acl_arr_ptr^,contrast_pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueF34; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  contrast_pow           : integer;
  r                      : byte=128;
  g                      : byte=128;
  b                      : byte=128;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      contrast_pow           :=ContrastPrecalc(1+cfx_pow0/10);
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [rct_dst.top*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[00000000000000+rct_src.top +000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
      for y:=0 to rct_src.height-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      Contrast2     (pt_pix_intr_sht_arr_ptr^+v,r,g,b,contrast_pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      Contrast2     (pt_pix_intr_sht_arr_ptr^+v,r,g,b,contrast_pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      Contrast2     (pt_pix_intr_sht_arr_ptr^+v,r,g,b,contrast_pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      Contrast2     (pt_pix_intr_sht_arr_ptr^+v,r,g,b,contrast_pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.RegPTValue234; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      if (not pt_as_nt) then
        RegPTValueE34
      else
        RegPTValueF34;
    end;
end; {$endregion}
// (fading):
// same;

{$endregion}

{Noise} {$region -fold}



{$endregion}

{$endregion}

{Gradient FloodFill------------------------------------} {$region -fold}

// NT - not transparent pixels:

{Value} {$region -fold}

// auxiliary procedures:
procedure TFastImageProc.GrVNTValueA_0; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  dx: integer;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
          y_grad_rng_div_vec.r:=grad_col0.r<<16;
          y_grad_rng_div_vec.g:=grad_col0.g<<16;
          y_grad_rng_div_vec.b:=grad_col0.b<<16;
          y_grad_rng_div_vec.a:=grad_col0.a<<16;
            grad_vec2.y       :=Min2(bmp_ftimg_height-nt_pix_arr_row_mrg_btm,grad_vec.y);
            grad_vec2.x       :=Max2(                 nt_pix_arr_row_mrg_top,grad_vec.x);
          dx                  :=grad_vec2.x-                                 grad_vec.x{-3};
      if (dx<>0) then
        begin
          y_grad_rng_div_vec.r+=dx*grad_rng_div_vec.r;
          y_grad_rng_div_vec.g+=dx*grad_rng_div_vec.g;
          y_grad_rng_div_vec.b+=dx*grad_rng_div_vec.b;
          y_grad_rng_div_vec.a+=dx*grad_rng_div_vec.a;
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVNTValueA_1; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  dx: integer;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
          y_grad_rng_div_vec.r:=grad_col0.r<<16;
          y_grad_rng_div_vec.g:=grad_col0.g<<16;
          y_grad_rng_div_vec.b:=grad_col0.b<<16;
          y_grad_rng_div_vec.a:=grad_col0.a<<16;
            grad_vec2.y       :=Min2(Min2(bmp_ftimg_height-nt_pix_arr_row_mrg_btm,grad_vec.y),rct_src.bottom+000);
            grad_vec2.x       :=Max2(Max2(                 nt_pix_arr_row_mrg_top,grad_vec.x),rct_src.top       );
          dx                  :=grad_vec2.x-                                      grad_vec.x{-3};
      if (dx<>0) then
        begin
          y_grad_rng_div_vec.r+=dx*grad_rng_div_vec.r;
          y_grad_rng_div_vec.g+=dx*grad_rng_div_vec.g;
          y_grad_rng_div_vec.b+=dx*grad_rng_div_vec.b;
          y_grad_rng_div_vec.a+=dx*grad_rng_div_vec.a;
        end;
    end;
end; {$endregion}

// (constant) auxiliary procedure:
procedure TFastImageProc.GrVNTValueA0(Proc16:TProc16); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  pix_row_val            : TColor;
  pow                    : byte;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ nt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          pow          :=alpha_max-TRGBA(pix_row_val).a;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              Proc16((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,0,pow);
              Inc    (nt_pix_intr_sht_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVNTValueA4(Proc16:TProc16); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
  pow                    : byte;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ nt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);
              pow              :=alpha_max-TRGBA(pix_row_val).a;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc16       ((nt_pix_intr_sht_arr_ptr^+v)^,0,pow);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr, c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      Proc16       ((nt_pix_intr_sht_arr_ptr^+v)^,0,pow);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      Proc16       ((nt_pix_intr_sht_arr_ptr^+v)^,0,pow);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      Proc16       ((nt_pix_intr_sht_arr_ptr^+v)^,0,pow);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVNTValueB0(Proc17:TProc17); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  pix_row_val            : TColor;
  pow                    : byte;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ nt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          pow          :=alpha_max-TRGBA(pix_row_val).a;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              Proc17((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,pow);
              Inc    (nt_pix_intr_sht_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVNTValueB4(Proc17:TProc17); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
  pow                    : byte;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ nt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);
              pow              :=alpha_max-TRGBA(pix_row_val).a;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc17       ((nt_pix_intr_sht_arr_ptr^+v)^,pow);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr, c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      Proc17       ((nt_pix_intr_sht_arr_ptr^+v)^,pow);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      Proc17       ((nt_pix_intr_sht_arr_ptr^+v)^,pow);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      Proc17       ((nt_pix_intr_sht_arr_ptr^+v)^,pow);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVNTValueC0(Proc18:TProc18); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  pix_row_val            : TColor;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ nt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              Proc18((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,TRGBA(pix_row_val).a,0);
              Inc    (nt_pix_intr_sht_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVNTValueC4(Proc18:TProc18); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ nt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc18       ((nt_pix_intr_sht_arr_ptr^+v)^,TRGBA(pix_row_val).a,0);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr, c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      Proc18       ((nt_pix_intr_sht_arr_ptr^+v)^,TRGBA(pix_row_val).a,0);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      Proc18       ((nt_pix_intr_sht_arr_ptr^+v)^,TRGBA(pix_row_val).a,0);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      Proc18       ((nt_pix_intr_sht_arr_ptr^+v)^,TRGBA(pix_row_val).a,0);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVNTValueD0(Proc19:TProc19); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  pix_row_val            : TColor;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ nt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              Proc19 (nt_pix_intr_sht_arr_ptr^+pix_color_ptr,bmp_bkgnd_width,TRGBA(pix_row_val).a);
              Inc    (nt_pix_intr_sht_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVNTValueD4(Proc19:TProc19); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ nt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc19        (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,TRGBA(pix_row_val).a);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr, c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      Proc19        (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,TRGBA(pix_row_val).a);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      Proc19        (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,TRGBA(pix_row_val).a);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      Proc19        (nt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,TRGBA(pix_row_val).a);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}

{Empty}
procedure TFastImageProc.GrVNTValue009; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Monochrome}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVNTValueA00; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  pix_row_val            : TColor;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ nt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGB(y_grad_rng_div_vec.b>>16,
                             y_grad_rng_div_vec.g>>16,
                             y_grad_rng_div_vec.r>>16);
          if       not ((nt_pix_intr_cnt_arr_ptr^-4>=0) and
                       ((nt_pix_intr_sht_arr_ptr+
                         nt_pix_intr_cnt_arr_ptr^-1)^-
                         nt_pix_intr_sht_arr_ptr^=
                         nt_pix_intr_cnt_arr_ptr^-1)) then
            for x:=0 to  nt_pix_intr_cnt_arr_ptr^-1 do
              begin
                        (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=pix_row_val;
                Inc     (nt_pix_intr_sht_arr_ptr);
              end
          else
            begin
              FillDWord((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                         nt_pix_intr_cnt_arr_ptr^,pix_row_val);
              Inc       (nt_pix_intr_sht_arr_ptr,
                         nt_pix_intr_cnt_arr_ptr^);
            end;
          Inc           (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width );
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.GrVNTValue000; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVNTValueA_0;
      GrVNTValueA00;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVNTValue002; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueA00;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVNTValue004; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ nt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGB(y_grad_rng_div_vec.b>>16,
                                     y_grad_rng_div_vec.g>>16,
                                     y_grad_rng_div_vec.r>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  if           not ((c2-c1-4>=0) and
                                   ((nt_pix_intr_sht_arr_ptr+
                                     c2-c1-1)^-
                                     nt_pix_intr_sht_arr_ptr^=
                                     c2-c1-1)) then
                    for x:=0 to      c2-c1-1 do
                      begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=pix_row_val;
                        Inc         (nt_pix_intr_sht_arr_ptr);
                      end
                  else
                    begin
                      FillDWord    ((nt_pix_intr_sht_arr_ptr^+v)^,c2-c1,pix_row_val);
                      Inc           (nt_pix_intr_sht_arr_ptr     ,c2-c1);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^   -(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr, c+1);
                  v:=pix_color_ptr-rct_src.left;
                  if           not ((nt_pix_intr_cnt_arr_ptr^-c-5>=0) and
                                   ((nt_pix_intr_sht_arr_ptr+
                                     nt_pix_intr_cnt_arr_ptr^-c-2)^-
                                     nt_pix_intr_sht_arr_ptr^=
                                     nt_pix_intr_cnt_arr_ptr^-c-2)) then
                    for x:=0 to      nt_pix_intr_cnt_arr_ptr^-c-2 do
                      begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=pix_row_val;
                        Inc         (nt_pix_intr_sht_arr_ptr);
                      end
                  else
                    begin
                      FillDWord    ((nt_pix_intr_sht_arr_ptr^+v)^,
                                     nt_pix_intr_cnt_arr_ptr^-c-1,pix_row_val);
                      Inc           (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-c-1);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  if           not ((c-3>=0) and
                                   ((nt_pix_intr_sht_arr_ptr +c)^-
                                     nt_pix_intr_sht_arr_ptr^=c)) then
                    for x:=0 to c do
                      begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=pix_row_val;
                        Inc         (nt_pix_intr_sht_arr_ptr);
                      end
                  else
                    begin
                      FillDWord    ((nt_pix_intr_sht_arr_ptr^+v)^,c+1,pix_row_val);
                      Inc           (nt_pix_intr_sht_arr_ptr,     c+1);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  if           not ((nt_pix_intr_cnt_arr_ptr^-4>=0) and
                                   ((nt_pix_intr_sht_arr_ptr+
                                     nt_pix_intr_cnt_arr_ptr^-1)^-
                                     nt_pix_intr_sht_arr_ptr^=
                                     nt_pix_intr_cnt_arr_ptr^-1)) then
                    for x:=0 to      nt_pix_intr_cnt_arr_ptr^-1 do
                      begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=pix_row_val;
                        Inc         (nt_pix_intr_sht_arr_ptr);
                      end
                  else
                    begin
                      FillDWord    ((nt_pix_intr_sht_arr_ptr^+v)^,
                                     nt_pix_intr_cnt_arr_ptr^,pix_row_val);
                      Inc           (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue006; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec .y<=grad_vec .x) then
        Exit;
      GrVNTValueA_1;
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrVMonochrome(bmp_bkgnd_ptr,
                      PtBounds(rct_dst.left ,grad_vec2.x+bmp_ftimg_top,
                               rct_dst.width,grad_vec2.y-
                                             grad_vec2.x),
                      bmp_bkgnd_width,
                      grad_prop);
    end;
end; {$endregion}
// (fading):
// same;

{Additive}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVNTValueA10; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  pix_row_val            : TColor;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ nt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDecC(
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,pix_row_val);
              Inc    (nt_pix_intr_sht_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.GrVNTValue010; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVNTValueA_0;
      GrVNTValueA10;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVNTValue012; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueA10;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVNTValue014; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ nt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecC(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,pix_row_val);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr, c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecC(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,pix_row_val);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecC(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,pix_row_val);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecC(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,pix_row_val);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue016; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec .y<=grad_vec .x) then
        Exit;
      GrVNTValueA_1;
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrVAdditive(bmp_bkgnd_ptr,
                    PtBounds(rct_dst.left ,grad_vec2.x+bmp_ftimg_top,
                             rct_dst.width,grad_vec2.y-
                                           grad_vec2.x),
                    bmp_bkgnd_width,
                    grad_prop);
    end;
end; {$endregion}
// (fading):
// same;

{AlphaBlend}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVNTValueA20; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  pix_row_val            : TColor;
  pow                    : byte;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ nt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          pow          :=alpha_max-TRGBA(pix_row_val).a;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendDecA(
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,pix_row_val,pow,0);
              Inc    (nt_pix_intr_sht_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.GrVNTValue020; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVNTValueA_0;
      GrVNTValueA20;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVNTValue022; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueA20;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVNTValue024; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
  pow                    : byte;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ nt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);
              pow              :=alpha_max-TRGBA(pix_row_val).a;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDecA(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,pix_row_val,pow,0);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr, c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDecA(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,pix_row_val,pow,0);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDecA(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,pix_row_val,pow,0);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDecA(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,pix_row_val,pow,0);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue026; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec .y<=grad_vec .x) then
        Exit;
      GrVNTValueA_1;
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrVAlphaBlend(bmp_bkgnd_ptr,
                      PtBounds(rct_dst.left ,grad_vec2.x+bmp_ftimg_top,
                               rct_dst.width,grad_vec2.y-
                                             grad_vec2.x),
                      bmp_bkgnd_width,
                      grad_prop);
    end;
end; {$endregion}
// (fading):
// same;

{Inverse}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVNTValueA30; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  pix_row_val            : TColor;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ nt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          for x:=0 to     nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              InverseDec((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,TRGBA(pix_row_val).a);
              Inc        (nt_pix_intr_sht_arr_ptr);
            end;
          Inc            (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.GrVNTValue030; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVNTValueA_0;
      GrVNTValueA30;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVNTValue032; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueA30;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVNTValue034; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ nt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      InverseDec   ((nt_pix_intr_sht_arr_ptr^+v)^,TRGBA(pix_row_val).a);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr, c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      InverseDec   ((nt_pix_intr_sht_arr_ptr^+v)^,TRGBA(pix_row_val).a);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      InverseDec   ((nt_pix_intr_sht_arr_ptr^+v)^,TRGBA(pix_row_val).a);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      InverseDec   ((nt_pix_intr_sht_arr_ptr^+v)^,TRGBA(pix_row_val).a);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue036; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec .y<=grad_vec .x) then
        Exit;
      GrVNTValueA_1;
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrVInverse(bmp_bkgnd_ptr,
                   PtBounds(rct_dst.left ,grad_vec2.x+bmp_ftimg_top,
                            rct_dst.width,grad_vec2.y-
                                          grad_vec2.x),
                   bmp_bkgnd_width,
                   grad_prop);
    end;
end; {$endregion}
// (fading):
// same;

{Highlight}
// (constant) not clippped:
procedure TFastImageProc.GrVNTValue040; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVNTValueA_0;
      GrVNTValueA0(@HighlightDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVNTValue042; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueA0(@HighlightDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVNTValue044; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueA4(@HighlightDec);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue046; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec .y<=grad_vec .x) then
        Exit;
      GrVNTValueA_1;
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV16(bmp_bkgnd_ptr,
              PtBounds(rct_dst.left ,grad_vec2.x+bmp_ftimg_top,
                       rct_dst.width,grad_vec2.y-
                                     grad_vec2.x),
              bmp_bkgnd_width,
              grad_prop,
              @HighlightDec);
    end;
end; {$endregion}
// (fading):
// same;

{Darken}
// (constant) not clippped:
procedure TFastImageProc.GrVNTValue050; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVNTValueA_0;
      GrVNTValueA0(@DarkenDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVNTValue052; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueA0(@DarkenDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVNTValue054; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueA4(@DarkenDec);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue056; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec .y<=grad_vec .x) then
        Exit;
      GrVNTValueA_1;
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV16(bmp_bkgnd_ptr,
              PtBounds(rct_dst.left ,grad_vec2.x+bmp_ftimg_top,
                       rct_dst.width,grad_vec2.y-
                                     grad_vec2.x),
              bmp_bkgnd_width,
              grad_prop,
              @DarkenDec);
    end;
end; {$endregion}
// (fading):
// same;

{GrayscaleR}
// (constant) not clippped:
procedure TFastImageProc.GrVNTValue060; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVNTValueA_0;
      GrVNTValueB0(@GrayscaleRDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVNTValue062; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueB0(@GrayscaleRDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVNTValue064; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueB4(@GrayscaleRDec);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue066; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec .y<=grad_vec .x) then
        Exit;
      GrVNTValueA_1;
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV17(bmp_bkgnd_ptr,
              PtBounds(rct_dst.left ,grad_vec2.x+bmp_ftimg_top,
                       rct_dst.width,grad_vec2.y-
                                     grad_vec2.x),
              bmp_bkgnd_width,
              grad_prop,
              @GrayscaleRDec);
    end;
end; {$endregion}
// (fading):
// same;

{GrayscaleG}
// (constant) not clippped:
procedure TFastImageProc.GrVNTValue070; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVNTValueA_0;
      GrVNTValueB0(@GrayscaleGDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVNTValue072; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueB0(@GrayscaleGDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVNTValue074; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueB4(@GrayscaleGDec);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue076; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec .y<=grad_vec .x) then
        Exit;
      GrVNTValueA_1;
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV17(bmp_bkgnd_ptr,
              PtBounds(rct_dst.left ,grad_vec2.x+bmp_ftimg_top,
                       rct_dst.width,grad_vec2.y-
                                     grad_vec2.x),
              bmp_bkgnd_width,
              grad_prop,
              @GrayscaleGDec);
    end;
end; {$endregion}
// (fading):
// same;

{GrayscaleB}
// (constant) not clippped:
procedure TFastImageProc.GrVNTValue080; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVNTValueA_0;
      GrVNTValueB0(@GrayscaleBDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVNTValue082; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueB0(@GrayscaleBDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVNTValue084; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueB4(@GrayscaleBDec);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue086; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec .y<=grad_vec .x) then
        Exit;
      GrVNTValueA_1;
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV17(bmp_bkgnd_ptr,
              PtBounds(rct_dst.left ,grad_vec2.x+bmp_ftimg_top,
                       rct_dst.width,grad_vec2.y-
                                     grad_vec2.x),
              bmp_bkgnd_width,
              grad_prop,
              @GrayscaleBDec);
    end;
end; {$endregion}
// (fading):
// same;

{Monochrome Noise}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVNTValueA90; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  pix_row_val            : TColor;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ nt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGB(y_grad_rng_div_vec.b>>16,
                             y_grad_rng_div_vec.g>>16,
                             y_grad_rng_div_vec.r>>16);
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              if Odd((nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=pix_row_val;
              Inc    (nt_pix_intr_sht_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.GrVNTValue090; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVNTValueA_0;
      GrVNTValueA90;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVNTValue092; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueA90;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVNTValue094; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ nt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGB(y_grad_rng_div_vec.b>>16,
                                     y_grad_rng_div_vec.g>>16,
                                     y_grad_rng_div_vec.r>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to      c2-c1-1 do
                    begin
                      if Odd       ((nt_pix_intr_sht_arr_ptr^+v)^) then
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=pix_row_val;
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^   -(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr, c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                      if Odd       ((nt_pix_intr_sht_arr_ptr^+v)^) then
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=pix_row_val;
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      if Odd       ((nt_pix_intr_sht_arr_ptr^+v)^) then
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=pix_row_val;
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      if Odd       ((nt_pix_intr_sht_arr_ptr^+v)^) then
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=pix_row_val;
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue096; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec .y<=grad_vec .x) then
        Exit;
      GrVNTValueA_1;
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrVMonoNoise(bmp_bkgnd_ptr,
                     PtBounds(rct_dst.left ,grad_vec2.x+bmp_ftimg_top,
                              rct_dst.width,grad_vec2.y-
                                            grad_vec2.x),
                     bmp_bkgnd_width,
                     grad_prop);
    end;
end; {$endregion}
// (fading):
// same;

{ColorizeR}
// (constant) not clippped:
procedure TFastImageProc.GrVNTValue100; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVNTValueA_0;
      GrVNTValueC0(@ColorizeRDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVNTValue102; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueC0(@ColorizeRDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVNTValue104; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueC4(@ColorizeRDec);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue106; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec .y<=grad_vec .x) then
        Exit;
      GrVNTValueA_1;
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV18(bmp_bkgnd_ptr,
              PtBounds(rct_dst.left ,grad_vec2.x+bmp_ftimg_top,
                       rct_dst.width,grad_vec2.y-
                                     grad_vec2.x),
              bmp_bkgnd_width,
              grad_prop,
              @ColorizeRDec);
    end;
end; {$endregion}
// (fading):
// same;

{ColorizeG}
// (constant) not clippped:
procedure TFastImageProc.GrVNTValue110; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVNTValueA_0;
      GrVNTValueC0(@ColorizeGDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVNTValue112; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueC0(@ColorizeGDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVNTValue114; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueC4(@ColorizeGDec);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue116; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec .y<=grad_vec .x) then
        Exit;
      GrVNTValueA_1;
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV18(bmp_bkgnd_ptr,
              PtBounds(rct_dst.left ,grad_vec2.x+bmp_ftimg_top,
                       rct_dst.width,grad_vec2.y-
                                     grad_vec2.x),
              bmp_bkgnd_width,
              grad_prop,
              @ColorizeGDec);
    end;
end; {$endregion}
// (fading):
// same;

{ColorizeB}
// (constant) not clippped:
procedure TFastImageProc.GrVNTValue120; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVNTValueA_0;
      GrVNTValueC0(@ColorizeBDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVNTValue122; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueC0(@ColorizeBDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVNTValue124; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueC4(@ColorizeBDec);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue126; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec .y<=grad_vec .x) then
        Exit;
      GrVNTValueA_1;
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV18(bmp_bkgnd_ptr,
              PtBounds(rct_dst.left ,grad_vec2.x+bmp_ftimg_top,
                       rct_dst.width,grad_vec2.y-
                                     grad_vec2.x),
              bmp_bkgnd_width,
              grad_prop,
              @ColorizeBDec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRGB}
// (constant) not clippped:
procedure TFastImageProc.GrVNTValue130; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVNTValueA_0;
      GrVNTValueD0(@BlurRGBDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVNTValue132; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueD0(@BlurRGBDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVNTValue134; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueD4(@BlurRGBDec);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue136; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec .y<=grad_vec .x) then
        Exit;
      GrVNTValueA_1;
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV19(bmp_bkgnd_ptr,
              PtBounds(rct_dst.left ,grad_vec2.x+bmp_ftimg_top,
                       rct_dst.width,grad_vec2.y-
                                     grad_vec2.x),
              bmp_bkgnd_width,
              grad_prop,
              @BlurRGBDec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRRB}
// (constant) not clippped:
procedure TFastImageProc.GrVNTValue140; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVNTValueA_0;
      GrVNTValueD0(@BlurRRBDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVNTValue142; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueD0(@BlurRRBDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVNTValue144; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueD4(@BlurRRBDec);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue146; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec .y<=grad_vec .x) then
        Exit;
      GrVNTValueA_1;
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV19(bmp_bkgnd_ptr,
              PtBounds(rct_dst.left ,grad_vec2.x+bmp_ftimg_top,
                       rct_dst.width,grad_vec2.y-
                                     grad_vec2.x),
              bmp_bkgnd_width,
              grad_prop,
              @BlurRRBDec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRGR}
// (constant) not clippped:
procedure TFastImageProc.GrVNTValue150; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVNTValueA_0;
      GrVNTValueD0(@BlurRGRDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVNTValue152; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueD0(@BlurRGRDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVNTValue154; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueD4(@BlurRGRDec);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue156; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec .y<=grad_vec .x) then
        Exit;
      GrVNTValueA_1;
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV19(bmp_bkgnd_ptr,
              PtBounds(rct_dst.left ,grad_vec2.x+bmp_ftimg_top,
                       rct_dst.width,grad_vec2.y-
                                     grad_vec2.x),
              bmp_bkgnd_width,
              grad_prop,
              @BlurRGRDec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurGGB}
// (constant) not clippped:
procedure TFastImageProc.GrVNTValue160; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVNTValueA_0;
      GrVNTValueD0(@BlurGGBDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVNTValue162; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueD0(@BlurGGBDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVNTValue164; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueD4(@BlurGGBDec);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue166; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec .y<=grad_vec .x) then
        Exit;
      GrVNTValueA_1;
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV19(bmp_bkgnd_ptr,
              PtBounds(rct_dst.left ,grad_vec2.x+bmp_ftimg_top,
                       rct_dst.width,grad_vec2.y-
                                     grad_vec2.x),
              bmp_bkgnd_width,
              grad_prop,
              @BlurGGBDec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRGG}
// (constant) not clippped:
procedure TFastImageProc.GrVNTValue170; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVNTValueA_0;
      GrVNTValueD0(@BlurRGGDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVNTValue172; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueD0(@BlurRGGDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVNTValue174; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueD4(@BlurRGGDec);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue176; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec .y<=grad_vec .x) then
        Exit;
      GrVNTValueA_1;
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV19(bmp_bkgnd_ptr,
              PtBounds(rct_dst.left ,grad_vec2.x+bmp_ftimg_top,
                       rct_dst.width,grad_vec2.y-
                                     grad_vec2.x),
              bmp_bkgnd_width,
              grad_prop,
              @BlurRGGDec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurBGB}
// (constant) not clippped:
procedure TFastImageProc.GrVNTValue180; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVNTValueA_0;
      GrVNTValueD0(@BlurBGBDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVNTValue182; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueD0(@BlurBGBDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVNTValue184; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueD4(@BlurBGBDec);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue186; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec .y<=grad_vec .x) then
        Exit;
      GrVNTValueA_1;
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV19(bmp_bkgnd_ptr,
              PtBounds(rct_dst.left ,grad_vec2.x+bmp_ftimg_top,
                       rct_dst.width,grad_vec2.y-
                                     grad_vec2.x),
              bmp_bkgnd_width,
              grad_prop,
              @BlurBGBDec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRBB}
// (constant) not clippped:
procedure TFastImageProc.GrVNTValue190; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVNTValueA_0;
      GrVNTValueD0(@BlurRBBDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVNTValue192; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueD0(@BlurRBBDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVNTValue194; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueD4(@BlurRBBDec);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue196; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec .y<=grad_vec .x) then
        Exit;
      GrVNTValueA_1;
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV19(bmp_bkgnd_ptr,
              PtBounds(rct_dst.left ,grad_vec2.x+bmp_ftimg_top,
                       rct_dst.width,grad_vec2.y-
                                     grad_vec2.x),
              bmp_bkgnd_width,
              grad_prop,
              @BlurRBBDec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRRR}
// (constant) not clippped:
procedure TFastImageProc.GrVNTValue200; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVNTValueA_0;
      GrVNTValueD0(@BlurRRRDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVNTValue202; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueD0(@BlurRRRDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVNTValue204; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueD4(@BlurRRRDec);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue206; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec .y<=grad_vec .x) then
        Exit;
      GrVNTValueA_1;
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV19(bmp_bkgnd_ptr,
              PtBounds(rct_dst.left ,grad_vec2.x+bmp_ftimg_top,
                       rct_dst.width,grad_vec2.y-
                                     grad_vec2.x),
              bmp_bkgnd_width,
              grad_prop,
              @BlurRRRDec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurGGG}
// (constant) not clippped:
procedure TFastImageProc.GrVNTValue210; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVNTValueA_0;
      GrVNTValueD0(@BlurGGGDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVNTValue212; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueD0(@BlurGGGDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVNTValue214; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueD4(@BlurGGGDec);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue216; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec .y<=grad_vec .x) then
        Exit;
      GrVNTValueA_1;
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV19(bmp_bkgnd_ptr,
              PtBounds(rct_dst.left ,grad_vec2.x+bmp_ftimg_top,
                       rct_dst.width,grad_vec2.y-
                                     grad_vec2.x),
              bmp_bkgnd_width,
              grad_prop,
              @BlurGGGDec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurBBB}
// (constant) not clippped:
procedure TFastImageProc.GrVNTValue220; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVNTValueA_0;
      GrVNTValueD0(@BlurBBBDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVNTValue222; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueD0(@BlurBBBDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVNTValue224; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValueD4(@BlurBBBDec);
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue226; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec .y<=grad_vec .x) then
        Exit;
      GrVNTValueA_1;
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV19(bmp_bkgnd_ptr,
              PtBounds(rct_dst.left ,grad_vec2.x+bmp_ftimg_top,
                       rct_dst.width,grad_vec2.y-
                                     grad_vec2.x),
              bmp_bkgnd_width,
              grad_prop,
              @BlurBBBDec);
    end;
end; {$endregion}
// (fading):
// same;

{Contrast}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVNTValue23A; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  pix_row_val            : TColor;
  pix_const_val          : TColor;
  contrast_pow           : integer;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      pix_const_val          :=RGB(128,128,128);
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ nt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          contrast_pow :=ContrastPrecalc(1+(alpha_max-TRGBA(pix_row_val).a)/10);
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=ContrastDecA(
                     (nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,pix_const_val,TRGBA(pix_row_val).a,contrast_pow);
              Inc    (nt_pix_intr_sht_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.GrVNTValue230; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVNTValueA_0;
      GrVNTValue23A;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVNTValue232; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      GrVNTValue23A;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVNTValue234; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
  pix_const_val          : TColor;
  contrast_pow           : integer;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        Exit;
      GrVNTValueA_1;
      pix_const_val          :=RGB(128,128,128);
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ nt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (nt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);
              contrast_pow     :=ContrastPrecalc(1+(alpha_max-TRGBA(pix_row_val).a)/10);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_intr_sht_arr_ptr,c1+1);
                  v :=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=ContrastDecA(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,pix_const_val,TRGBA(pix_row_val).a,contrast_pow);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_intr_sht_arr_ptr, c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-c-2 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=ContrastDecA(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,pix_const_val,TRGBA(pix_row_val).a,contrast_pow);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (nt_pix_intr_cnt_arr_ptr^,
                                     nt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=ContrastDecA(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,pix_const_val,TRGBA(pix_row_val).a,contrast_pow);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_intr_sht_arr_ptr,
                                     nt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        nt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (nt_pix_intr_sht_arr_ptr^+v)^:=ContrastDecA(
                                    (nt_pix_intr_sht_arr_ptr^+v)^,pix_const_val,TRGBA(pix_row_val).a,contrast_pow);
                      Inc           (nt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue236; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec .y<=grad_vec .x) then
        Exit;
      GrVNTValueA_1;
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrVContrast(bmp_bkgnd_ptr,
                    PtBounds(rct_dst.left ,grad_vec2.x+bmp_ftimg_top,
                             rct_dst.width,grad_vec2.y-
                                           grad_vec2.x),
                    bmp_bkgnd_width,
                    grad_prop);
    end;
end; {$endregion}
// (fading):
// same;

{$endregion}

{Noise} {$region -fold}



{$endregion}

// PT - partly transparent pixels:

{Value} {$region -fold}

// auxiliary procedures:
procedure TFastImageProc.GrVPTValueA_0; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  dx: integer;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
          y_grad_rng_div_vec.r:=grad_col0.r<<16;
          y_grad_rng_div_vec.g:=grad_col0.g<<16;
          y_grad_rng_div_vec.b:=grad_col0.b<<16;
          y_grad_rng_div_vec.a:=grad_col0.a<<16;
            grad_vec2.y       :=Min2(bmp_ftimg_height-pt_pix_arr_row_mrg_btm,grad_vec.y);
            grad_vec2.x       :=Max2(                 pt_pix_arr_row_mrg_top,grad_vec.x);
          dx                  :=grad_vec2.x-                                 grad_vec.x{-3};
      if (dx<>0) then
        begin
          y_grad_rng_div_vec.r+=dx*grad_rng_div_vec.r;
          y_grad_rng_div_vec.g+=dx*grad_rng_div_vec.g;
          y_grad_rng_div_vec.b+=dx*grad_rng_div_vec.b;
          y_grad_rng_div_vec.a+=dx*grad_rng_div_vec.a;
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueA_1; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  dx: integer;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
          y_grad_rng_div_vec.r:=grad_col0.r<<16;
          y_grad_rng_div_vec.g:=grad_col0.g<<16;
          y_grad_rng_div_vec.b:=grad_col0.b<<16;
          y_grad_rng_div_vec.a:=grad_col0.a<<16;
            grad_vec2.y       :=Min2(Min2(bmp_ftimg_height-pt_pix_arr_row_mrg_btm,grad_vec.y),rct_src.bottom+000);
            grad_vec2.x       :=Max2(Max2(                 pt_pix_arr_row_mrg_top,grad_vec.x),rct_src.top       );
          dx                  :=grad_vec2.x-                                      grad_vec.x{-3};
      if (dx<>0) then
        begin
          y_grad_rng_div_vec.r+=dx*grad_rng_div_vec.r;
          y_grad_rng_div_vec.g+=dx*grad_rng_div_vec.g;
          y_grad_rng_div_vec.b+=dx*grad_rng_div_vec.b;
          y_grad_rng_div_vec.a+=dx*grad_rng_div_vec.a;
        end;
    end;
end; {$endregion}

// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueA0(Proc16:TProc16); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  pix_row_val            : TColor;
  pow                    : byte;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          pow          :=alpha_max-TRGBA(pix_row_val).a;
          for x:=0 to    pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              Proc16   ((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
              alpha_max-(pt_pix_byte_acl_arr_ptr^),pow);
              Inc       (pt_pix_intr_sht_arr_ptr);
              Inc       (pt_pix_byte_acl_arr_ptr);
            end;
          Inc           (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueB0(Proc16:TProc16); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  pix_row_val            : TColor;
  pow                    : byte;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          pow          :=alpha_max-TRGBA(pix_row_val).a;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              Proc16((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,0,pow);
              Inc    (pt_pix_intr_sht_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueA4(Proc16:TProc16); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
  pow                    : byte;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);

              pow              :=alpha_max-TRGBA(pix_row_val).a;
              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                      Proc16       ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-    (pt_pix_byte_acl_arr_ptr^),pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                      Proc16       ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-    (pt_pix_byte_acl_arr_ptr^),pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      Proc16       ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-    (pt_pix_byte_acl_arr_ptr^),pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      Proc16       ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-    (pt_pix_byte_acl_arr_ptr^),pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueB4(Proc16:TProc16); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
  pow                    : byte;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);
              pow              :=alpha_max-TRGBA(pix_row_val).a;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                      Proc16       ((pt_pix_intr_sht_arr_ptr^+v)^,0,pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                      Proc16       ((pt_pix_intr_sht_arr_ptr^+v)^,0,pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      Proc16       ((pt_pix_intr_sht_arr_ptr^+v)^,0,pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      Proc16       ((pt_pix_intr_sht_arr_ptr^+v)^,0,pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueC0(Proc17:TProc17); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  pix_row_val            : TColor;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              Proc17((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
              Max2   (pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0));
              Inc    (pt_pix_intr_sht_arr_ptr);
              Inc    (pt_pix_byte_acl_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueD0(Proc17:TProc17); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  pix_row_val            : TColor;
  pow                    : byte;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          pow          :=alpha_max-TRGBA(pix_row_val).a;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              Proc17((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,pow);
              Inc    (pt_pix_intr_sht_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueC4(Proc17:TProc17); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                      Proc17       ((pt_pix_intr_sht_arr_ptr^+v)^,
                      Max2          (pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                      Proc17       ((pt_pix_intr_sht_arr_ptr^+v)^,
                      Max2          (pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      Proc17       ((pt_pix_intr_sht_arr_ptr^+v)^,
                      Max2          (pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      Proc17       ((pt_pix_intr_sht_arr_ptr^+v)^,
                      Max2          (pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueD4(Proc17:TProc17); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
  pow                    : byte;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);
              pow              :=alpha_max-TRGBA(pix_row_val).a;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                      Proc17       ((pt_pix_intr_sht_arr_ptr^+v)^,pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                      Proc17       ((pt_pix_intr_sht_arr_ptr^+v)^,pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      Proc17       ((pt_pix_intr_sht_arr_ptr^+v)^,pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      Proc17       ((pt_pix_intr_sht_arr_ptr^+v)^,pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueE0(Proc18:TProc18); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  pix_row_val            : TColor;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              Proc18       ((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
              alpha_max-Max2(pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0),0);
              Inc           (pt_pix_intr_sht_arr_ptr);
              Inc           (pt_pix_byte_acl_arr_ptr);
            end;
          Inc               (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueF0(Proc18:TProc18); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  pix_row_val            : TColor;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              Proc18((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,TRGBA(pix_row_val).a,0);
              Inc    (pt_pix_intr_sht_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueE4(Proc18:TProc18); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                      Proc18       ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-Max2(pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0),0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                      Proc18       ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-Max2(pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0),0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      Proc18       ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-Max2(pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0),0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      Proc18       ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-Max2(pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0),0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueF4(Proc18:TProc18); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                      Proc18       ((pt_pix_intr_sht_arr_ptr^+v)^,TRGBA(pix_row_val).a,0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                      Proc18       ((pt_pix_intr_sht_arr_ptr^+v)^,TRGBA(pix_row_val).a,0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      Proc18       ((pt_pix_intr_sht_arr_ptr^+v)^,TRGBA(pix_row_val).a,0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      Proc18       ((pt_pix_intr_sht_arr_ptr^+v)^,TRGBA(pix_row_val).a,0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueG0(Proc19:TProc19); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  pix_row_val            : TColor;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              Proc19        (pt_pix_intr_sht_arr_ptr^+pix_color_ptr,bmp_bkgnd_width,
              alpha_max-Max2(pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0));
              Inc           (pt_pix_intr_sht_arr_ptr);
              Inc           (pt_pix_byte_acl_arr_ptr);
            end;
          Inc               (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueH0(Proc19:TProc19); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  pix_row_val            : TColor;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              Proc19 (pt_pix_intr_sht_arr_ptr^+pix_color_ptr,bmp_bkgnd_width,TRGBA(pix_row_val).a);
              Inc    (pt_pix_intr_sht_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueG4(Proc19:TProc19); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                      Proc19        (pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,
                      alpha_max-Max2(pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                      Proc19        (pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,
                      alpha_max-Max2(pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      Proc19        (pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,
                      alpha_max-Max2(pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      Proc19        (pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,
                      alpha_max-Max2(pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueH4(Proc19:TProc19); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                      Proc19        (pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,TRGBA(pix_row_val).a);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                      Proc19        (pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,TRGBA(pix_row_val).a);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      Proc19        (pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,TRGBA(pix_row_val).a);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      Proc19        (pt_pix_intr_sht_arr_ptr^+v,bmp_bkgnd_width,TRGBA(pix_row_val).a);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}

{Empty}
procedure TFastImageProc.GrVPTValue009; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Monochrome}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueA00; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  pix_row_val            : TColor;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGB(y_grad_rng_div_vec.b>>16,
                             y_grad_rng_div_vec.g>>16,
                             y_grad_rng_div_vec.r>>16);
          for x:=0 to   pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendB(pix_row_val,
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                        pt_pix_byte_acl_arr_ptr^);
              Inc      (pt_pix_intr_sht_arr_ptr);
              Inc      (pt_pix_byte_acl_arr_ptr);
            end;
          Inc          (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueB00; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  pix_row_val            : TColor;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGB(y_grad_rng_div_vec.b>>16,
                             y_grad_rng_div_vec.g>>16,
                             y_grad_rng_div_vec.r>>16);
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=pix_row_val;
              Inc    (pt_pix_intr_sht_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.GrVPTValue000; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVPTValueA_0;
      if (not pt_as_nt) then
        GrVPTValueA00
      else
        GrVPTValueB00;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVPTValue002; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueA00
      else
        GrVPTValueB00;
    end;
end; {$endregion}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueA04; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGB(y_grad_rng_div_vec.b>>16,
                                     y_grad_rng_div_vec.g>>16,
                                     y_grad_rng_div_vec.r>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(pix_row_val,
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(pix_row_val,
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(pix_row_val,
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(pix_row_val,
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueB04; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGB(y_grad_rng_div_vec.b>>16,
                                     y_grad_rng_div_vec.g>>16,
                                     y_grad_rng_div_vec.r>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=pix_row_val;
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=pix_row_val;
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=pix_row_val;
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=pix_row_val;
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVPTValue004; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueA04
      else
        GrVPTValueB04;
    end;
end; {$endregion}
// (fading):
// same;

{Additive}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueA10; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  pix_row_val            : TColor;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                            (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDecA(
                            (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,(pix_row_val),
              alpha_max-Max2(pt_pix_byte_acl_arr_ptr^-           TRGBA(pix_row_val).a,0));
              Inc           (pt_pix_intr_sht_arr_ptr);
              Inc           (pt_pix_byte_acl_arr_ptr);
            end;
          Inc               (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueB10; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  pix_row_val            : TColor;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AdditiveDecC(
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,pix_row_val);
              Inc    (pt_pix_intr_sht_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.GrVPTValue010; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVPTValueA_0;
      if (not pt_as_nt) then
        GrVPTValueA10
      else
        GrVPTValueB10;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVPTValue012; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueA10
      else
        GrVPTValueB10;
    end;
end; {$endregion}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueA14; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^, (pix_row_val),
                      alpha_max-Max2(pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^, (pix_row_val),
                      alpha_max-Max2(pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^, (pix_row_val),
                      alpha_max-Max2(pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^, (pix_row_val),
                      alpha_max-Max2(pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueB14; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecC(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,pix_row_val);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecC(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,pix_row_val);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecC(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,pix_row_val);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AdditiveDecC(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,pix_row_val);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVPTValue014; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueA14
      else
        GrVPTValueB14;
    end;
end; {$endregion}
// (fading):
// same;

{AlphaBlend}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueA20; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  pix_row_val            : TColor;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendDecA(
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,(pix_row_val),
                      pt_pix_byte_acl_arr_ptr^,           TRGBA(pix_row_val).a);
              Inc    (pt_pix_intr_sht_arr_ptr);
              Inc    (pt_pix_byte_acl_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueB20; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  pix_row_val            : TColor;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendDecA(
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,pix_row_val,alpha_max-TRGBA(pix_row_val).a,0);
              Inc    (pt_pix_intr_sht_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.GrVPTValue020; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVPTValueA_0;
      if (not pt_as_nt) then
        GrVPTValueA20
      else
        GrVPTValueB20;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVPTValue022; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueA20
      else
        GrVPTValueB20;
    end;
end; {$endregion}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueA24; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDecA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^, (pix_row_val),
                                     pt_pix_byte_acl_arr_ptr^,TRGBA(pix_row_val).a);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDecA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^, (pix_row_val),
                                     pt_pix_byte_acl_arr_ptr^,TRGBA(pix_row_val).a);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDecA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^, (pix_row_val),
                                     pt_pix_byte_acl_arr_ptr^,TRGBA(pix_row_val).a);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDecA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^, (pix_row_val),
                                     pt_pix_byte_acl_arr_ptr^,TRGBA(pix_row_val).a);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueB24; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDecA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,pix_row_val,alpha_max-TRGBA(pix_row_val).a,0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDecA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,pix_row_val,alpha_max-TRGBA(pix_row_val).a,0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDecA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,pix_row_val,alpha_max-TRGBA(pix_row_val).a,0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendDecA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,pix_row_val,alpha_max-TRGBA(pix_row_val).a,0);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVPTValue024; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueA24
      else
        GrVPTValueB24;
    end;
end; {$endregion}
// (fading):
// same;

{Inverse}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueA30; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  pix_row_val            : TColor;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          for x:=0 to       pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              InverseDec  ((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
              alpha_max-Max(pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0));
              Inc          (pt_pix_intr_sht_arr_ptr);
              Inc          (pt_pix_byte_acl_arr_ptr);
            end;
          Inc              (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueB30; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  pix_row_val            : TColor;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          for x:=0 to     pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              InverseDec((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,TRGBA(pix_row_val).a);
              Inc        (pt_pix_intr_sht_arr_ptr);
            end;
          Inc            (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.GrVPTValue030; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVPTValueA_0;
      if (not pt_as_nt) then
        GrVPTValueA30
      else
        GrVPTValueB30;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVPTValue032; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueA30
      else
        GrVPTValueB30;
    end;
end; {$endregion}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueA34; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                      InverseDec   ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-Max (pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                      InverseDec   ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-Max (pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      InverseDec   ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-Max (pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      InverseDec   ((pt_pix_intr_sht_arr_ptr^+v)^,
                      alpha_max-Max (pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0));
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueB34; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                      InverseDec   ((pt_pix_intr_sht_arr_ptr^+v)^,TRGBA(pix_row_val).a);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                      InverseDec   ((pt_pix_intr_sht_arr_ptr^+v)^,TRGBA(pix_row_val).a);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      InverseDec   ((pt_pix_intr_sht_arr_ptr^+v)^,TRGBA(pix_row_val).a);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      InverseDec   ((pt_pix_intr_sht_arr_ptr^+v)^,TRGBA(pix_row_val).a);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVPTValue034; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueA34
      else
        GrVPTValueB34;
    end;
end; {$endregion}
// (fading):
// same;

{Highlight}
// (constant) not clippped:
procedure TFastImageProc.GrVPTValue040; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVPTValueA_0;
      if (not pt_as_nt) then
        GrVPTValueA0(@HighlightDec)
      else
        GrVPTValueB0(@HighlightDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVPTValue042; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueA0(@HighlightDec)
      else
        GrVPTValueB0(@HighlightDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVPTValue044; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueA4(@HighlightDec)
      else
        GrVPTValueB4(@HighlightDec);
    end;
end; {$endregion}
// (fading):
// same;

{Darken}
// (constant) not clippped:
procedure TFastImageProc.GrVPTValue050; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVPTValueA_0;
      if (not pt_as_nt) then
        GrVPTValueA0(@DarkenDec)
      else
        GrVPTValueA0(@DarkenDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVPTValue052; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueA0(@DarkenDec)
      else
        GrVPTValueA0(@DarkenDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVPTValue054; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueA4(@DarkenDec)
      else
        GrVPTValueA4(@DarkenDec);
    end;
end; {$endregion}
// (fading):
// same;

{GrayscaleR}
// (constant) not clippped:
procedure TFastImageProc.GrVPTValue060; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVPTValueA_0;
      if (not pt_as_nt) then
        GrVPTValueC0(@GrayscaleRDec)
      else
        GrVPTValueD0(@GrayscaleRDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVPTValue062; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueC0(@GrayscaleRDec)
      else
        GrVPTValueD0(@GrayscaleRDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVPTValue064; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueC4(@GrayscaleRDec)
      else
        GrVPTValueD4(@GrayscaleRDec);
    end;
end; {$endregion}
// (fading):
// same;

{GrayscaleG}
// (constant) not clippped:
procedure TFastImageProc.GrVPTValue070; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVPTValueA_0;
      if (not pt_as_nt) then
        GrVPTValueC0(@GrayscaleGDec)
      else
        GrVPTValueD0(@GrayscaleGDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVPTValue072; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueC0(@GrayscaleGDec)
      else
        GrVPTValueD0(@GrayscaleGDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVPTValue074; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueC4(@GrayscaleGDec)
      else
        GrVPTValueD4(@GrayscaleGDec);
    end;
end; {$endregion}
// (fading):
// same;

{GrayscaleB}
// (constant) not clippped:
procedure TFastImageProc.GrVPTValue080; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVPTValueA_0;
      if (not pt_as_nt) then
        GrVPTValueC0(@GrayscaleBDec)
      else
        GrVPTValueD0(@GrayscaleBDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVPTValue082; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueC0(@GrayscaleBDec)
      else
        GrVPTValueD0(@GrayscaleBDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVPTValue084; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueC4(@GrayscaleBDec)
      else
        GrVPTValueD4(@GrayscaleBDec);
    end;
end; {$endregion}
// (fading):
// same;

{Monochrome Noise}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueA90; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  pix_row_val            : TColor;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGB(y_grad_rng_div_vec.b>>16,
                             y_grad_rng_div_vec.g>>16,
                             y_grad_rng_div_vec.r>>16);
          for x:=0 to   pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              if Odd  ((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=AlphaBlendB(pix_row_val,
                       (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,
                        pt_pix_byte_acl_arr_ptr^);
              Inc      (pt_pix_intr_sht_arr_ptr);
              Inc      (pt_pix_byte_acl_arr_ptr);
            end;
          Inc          (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueB90; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  pix_row_val            : TColor;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGB(y_grad_rng_div_vec.b>>16,
                             y_grad_rng_div_vec.g>>16,
                             y_grad_rng_div_vec.r>>16);
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              if Odd((pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^) then
                     (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=pix_row_val;
              Inc    (pt_pix_intr_sht_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.GrVPTValue090; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVPTValueA_0;
      if (not pt_as_nt) then
        GrVPTValueA90
      else
        GrVPTValueB90;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVPTValue092; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueA90
      else
        GrVPTValueB90;
    end;
end; {$endregion}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueA94; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGB(y_grad_rng_div_vec.b>>16,
                                     y_grad_rng_div_vec.g>>16,
                                     y_grad_rng_div_vec.r>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                      if Odd       ((pt_pix_intr_sht_arr_ptr^+v)^) then
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(pix_row_val,
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                      if Odd       ((pt_pix_intr_sht_arr_ptr^+v)^) then
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(pix_row_val,
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      if Odd       ((pt_pix_intr_sht_arr_ptr^+v)^) then
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(pix_row_val,
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      if Odd       ((pt_pix_intr_sht_arr_ptr^+v)^) then
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=AlphaBlendB(pix_row_val,
                                    (pt_pix_intr_sht_arr_ptr^+v)^,
                                     pt_pix_byte_acl_arr_ptr^);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueB94; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGB(y_grad_rng_div_vec.b>>16,
                                     y_grad_rng_div_vec.g>>16,
                                     y_grad_rng_div_vec.r>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                      if Odd       ((pt_pix_intr_sht_arr_ptr^+v)^) then
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=pix_row_val;
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                      if Odd       ((pt_pix_intr_sht_arr_ptr^+v)^) then
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=pix_row_val;
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                      if Odd       ((pt_pix_intr_sht_arr_ptr^+v)^) then
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=pix_row_val;
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                      if Odd       ((pt_pix_intr_sht_arr_ptr^+v)^) then
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=pix_row_val;
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVPTValue094; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueA94
      else
        GrVPTValueB94;
    end;
end; {$endregion}
// (fading):
// same;

{ColorizeR}
// (constant) not clippped:
procedure TFastImageProc.GrVPTValue100; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVPTValueA_0;
      if (not pt_as_nt) then
        GrVPTValueE0(@ColorizeRDec)
      else
        GrVPTValueF0(@ColorizeRDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVPTValue102; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueE0(@ColorizeRDec)
      else
        GrVPTValueF0(@ColorizeRDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVPTValue104; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueE4(@ColorizeRDec)
      else
        GrVPTValueF4(@ColorizeRDec);
    end;
end; {$endregion}
// (fading):
// same;

{ColorizeG}
// (constant) not clippped:
procedure TFastImageProc.GrVPTValue110; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVPTValueA_0;
      if (not pt_as_nt) then
        GrVPTValueE0(@ColorizeGDec)
      else
        GrVPTValueF0(@ColorizeGDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVPTValue112; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueE0(@ColorizeGDec)
      else
        GrVPTValueF0(@ColorizeGDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVPTValue114; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueE4(@ColorizeGDec)
      else
        GrVPTValueF4(@ColorizeGDec);
    end;
end; {$endregion}
// (fading):
// same;

{ColorizeB}
// (constant) not clippped:
procedure TFastImageProc.GrVPTValue120; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVPTValueA_0;
      if (not pt_as_nt) then
        GrVPTValueE0(@ColorizeBDec)
      else
        GrVPTValueF0(@ColorizeBDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVPTValue122; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueE0(@ColorizeBDec)
      else
        GrVPTValueF0(@ColorizeBDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVPTValue124; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueE4(@ColorizeBDec)
      else
        GrVPTValueF4(@ColorizeBDec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRGB}
// (constant) not clippped:
procedure TFastImageProc.GrVPTValue130; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVPTValueA_0;
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurRGBDec)
      else
        GrVPTValueH0(@BlurRGBDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVPTValue132; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurRGBDec)
      else
        GrVPTValueH0(@BlurRGBDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVPTValue134; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueG4(@BlurRGBDec)
      else
        GrVPTValueH4(@BlurRGBDec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRRB}
// (constant) not clippped:
procedure TFastImageProc.GrVPTValue140; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVPTValueA_0;
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurRRBDec)
      else
        GrVPTValueH0(@BlurRRBDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVPTValue142; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurRRBDec)
      else
        GrVPTValueH0(@BlurRRBDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVPTValue144; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueG4(@BlurRRBDec)
      else
        GrVPTValueH4(@BlurRRBDec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRGR}
// (constant) not clippped:
procedure TFastImageProc.GrVPTValue150; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVPTValueA_0;
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurRGRDec)
      else
        GrVPTValueH0(@BlurRGRDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVPTValue152; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurRGRDec)
      else
        GrVPTValueH0(@BlurRGRDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVPTValue154; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueG4(@BlurRGRDec)
      else
        GrVPTValueH4(@BlurRGRDec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurGGB}
// (constant) not clippped:
procedure TFastImageProc.GrVPTValue160; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVPTValueA_0;
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurGGBDec)
      else
        GrVPTValueH0(@BlurGGBDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVPTValue162; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurGGBDec)
      else
        GrVPTValueH0(@BlurGGBDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVPTValue164; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueG4(@BlurGGBDec)
      else
        GrVPTValueH4(@BlurGGBDec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRGG}
// (constant) not clippped:
procedure TFastImageProc.GrVPTValue170; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVPTValueA_0;
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurRGGDec)
      else
        GrVPTValueH0(@BlurRGGDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVPTValue172; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurRGGDec)
      else
        GrVPTValueH0(@BlurRGGDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVPTValue174; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueG4(@BlurRGGDec)
      else
        GrVPTValueH4(@BlurRGGDec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurBGB}
// (constant) not clippped:
procedure TFastImageProc.GrVPTValue180; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVPTValueA_0;
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurBGBDec)
      else
        GrVPTValueH0(@BlurBGBDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVPTValue182; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurBGBDec)
      else
        GrVPTValueH0(@BlurBGBDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVPTValue184; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueG4(@BlurBGBDec)
      else
        GrVPTValueH4(@BlurBGBDec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRBB}
// (constant) not clippped:
procedure TFastImageProc.GrVPTValue190; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVPTValueA_0;
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurRBBDec)
      else
        GrVPTValueH0(@BlurRBBDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVPTValue192; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurRBBDec)
      else
        GrVPTValueH0(@BlurRBBDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVPTValue194; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueG4(@BlurRBBDec)
      else
        GrVPTValueH4(@BlurRBBDec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRRR}
// (constant) not clippped:
procedure TFastImageProc.GrVPTValue200; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVPTValueA_0;
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurRRRDec)
      else
        GrVPTValueH0(@BlurRRRDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVPTValue202; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurRRRDec)
      else
        GrVPTValueH0(@BlurRRRDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVPTValue204; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueG4(@BlurRRRDec)
      else
        GrVPTValueH4(@BlurRRRDec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurGGG}
// (constant) not clippped:
procedure TFastImageProc.GrVPTValue210; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVPTValueA_0;
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurGGGDec)
      else
        GrVPTValueH0(@BlurGGGDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVPTValue212; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurGGGDec)
      else
        GrVPTValueH0(@BlurGGGDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVPTValue214; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueG4(@BlurGGGDec)
      else
        GrVPTValueH4(@BlurGGGDec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurBBB}
// (constant) not clippped:
procedure TFastImageProc.GrVPTValue220; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVPTValueA_0;
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurBBBDec)
      else
        GrVPTValueH0(@BlurBBBDec);
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVPTValue222; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurBBBDec)
      else
        GrVPTValueH0(@BlurBBBDec);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVPTValue224; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueG4(@BlurBBBDec)
      else
        GrVPTValueH4(@BlurBBBDec);
    end;
end; {$endregion}
// (fading):
// same;

{Contrast}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueI30; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  x,y                    : integer;
  pix_row_val            : TColor;
  pix_const_val          : TColor;
  contrast_pow           : integer;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      pix_const_val          :=RGB(128,128,128);
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          contrast_pow :=ContrastPrecalc(1+(alpha_max-TRGBA(pix_row_val).a)/10);
          for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                            (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=ContrastDecA(
                            (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,pix_const_val,
              alpha_max-Max2(pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0),contrast_pow);
              Inc           (pt_pix_intr_sht_arr_ptr);
              Inc           (pt_pix_byte_acl_arr_ptr);
            end;
          Inc               (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueJ30; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
  pix_row_val            : TColor;
  pix_const_val          : TColor;
  contrast_pow           : integer;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      pix_const_val          :=RGB(128,128,128);
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+bmp_ftimg_left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+000000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          contrast_pow :=ContrastPrecalc(1+(alpha_max-TRGBA(pix_row_val).a)/10);
          for x:=0 to    pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                        (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^:=ContrastDecA(
                        (pt_pix_intr_sht_arr_ptr^+pix_color_ptr)^,pix_const_val,TRGBA(pix_row_val).a,contrast_pow);
              Inc       (pt_pix_intr_sht_arr_ptr);
            end;
          Inc           (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) not clippped:
procedure TFastImageProc.GrVPTValue230; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      GrVPTValueA_0;
      if (not pt_as_nt) then
        GrVPTValueI30
      else
        GrVPTValueJ30;
    end;
end; {$endregion}
// (constant) top-bottom clippped:
procedure TFastImageProc.GrVPTValue232; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueI30
      else
        GrVPTValueJ30;
    end;
end; {$endregion}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueI34; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  pt_pix_byte_acl_arr_ptr: PByte;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
  pix_const_val          : TColor;
  contrast_pow           : integer;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      pix_const_val          :=RGB(128,128,128);
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      pt_pix_byte_acl_arr_ptr:=Unaligned(@pt_pix_byte_acl_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);
              contrast_pow     :=ContrastPrecalc(1+(alpha_max-TRGBA(pix_row_val).a)/10);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c1+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=ContrastDecA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,pix_const_val,
                      alpha_max-Max2(pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0),contrast_pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  Inc               (pt_pix_byte_acl_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=ContrastDecA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,pix_const_val,
                      alpha_max-Max2(pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0),contrast_pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=ContrastDecA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,pix_const_val,
                      alpha_max-Max2(pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0),contrast_pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_byte_acl_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=ContrastDecA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,pix_const_val,
                      alpha_max-Max2(pt_pix_byte_acl_arr_ptr^-TRGBA(pix_row_val).a,0),contrast_pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                      Inc           (pt_pix_byte_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueJ34; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  first_sht_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  v                      : PInteger;
  x,y                    : integer;
  c,c1,c2                : integer;
  pix_row_val            : TColor;
  pix_const_val          : TColor;
  contrast_pow           : integer;
label
  label1;
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      pix_const_val          :=RGB(128,128,128);
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(bmp_ftimg_top +grad_vec2.x)*bmp_bkgnd_width+rct_dst.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ 00000000000000+grad_vec2.x +0000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ pt_cnt_ind_arr[grad_vec2.x]+0000000000000000000000000000]);
      for y:=0 to grad_vec2.y-grad_vec2.x-1 do
        begin
          if (pt_pix_intr_cnt_arr_ptr^<>0) then
            begin
              pix_color_ptr    :=first_row_pix_ptr;
              first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);
              contrast_pow     :=ContrastPrecalc(1+(alpha_max-TRGBA(pix_row_val).a)/10);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch  (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_intr_sht_arr_ptr,c1+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=ContrastDecA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,pix_const_val,TRGBA(pix_row_val).a,contrast_pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_intr_sht_arr_ptr,c+1);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=ContrastDecA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,pix_const_val,TRGBA(pix_row_val).a,contrast_pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch   (pt_pix_intr_cnt_arr_ptr^,
                                     pt_pix_intr_sht_arr_ptr,rct_src.right);
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to c do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=ContrastDecA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,pix_const_val,TRGBA(pix_row_val).a,contrast_pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_intr_sht_arr_ptr,
                                     pt_pix_intr_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=pix_color_ptr-rct_src.left;
                  for x:=0 to        pt_pix_intr_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_intr_sht_arr_ptr^+v)^:=ContrastDecA(
                                    (pt_pix_intr_sht_arr_ptr^+v)^,pix_const_val,TRGBA(pix_row_val).a,contrast_pow);
                      Inc           (pt_pix_intr_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clippped:
procedure TFastImageProc.GrVPTValue234; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,grad_prop do
    begin
      if (grad_vec.y<=grad_vec.x) then
        Exit;
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        Exit;
      GrVPTValueA_1;
      if (not pt_as_nt) then
        GrVPTValueI34
      else
        GrVPTValueJ34;
    end;
end; {$endregion}
// (fading):
// same;

{$endregion}

{Noise} {$region -fold}



{$endregion}

{$endregion}

{Scale Image-------------------------------------------} {$region -fold}

// NT - not transparent pixels:
// scale down:
// color:
procedure TFastImageProc.FilNTColorScaleDownMip0; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_cnt_arr_ptr                 : PInteger;
  nt_pix_intr_sht_arr_ptr                 : PInteger;
  nt_pix_intr_ccl_arr_ptr                 : PInteger;
  first_row_pix_ptr                       : PInteger;
  scl_mul_x,scl_mul_y,d1_,d2_,x,y,r1,r2,r3: integer;
  d1,d2                                   : double;
  row_parity                              : boolean;
  _scl_mul_x,_scl_mul_y,_d1,_d2           : TPtPos;
const
  mul                                     : integer=1<<15;
begin
  with fast_image_data_ptr0^ do
    begin
     _scl_mul_x.x            :=Trunc(mul* scl_mul.x);
     _scl_mul_y.x            :=Trunc(mul* scl_mul.y);
      scl_mul.x              := _scl_mul_x.x/ mul;
      scl_mul.y              := _scl_mul_y.x/ mul;
     _d1.x                   :=     (mul-_scl_mul_x.x)*bmp_ftimg_left;
     _d2.x                   :=     (mul-_scl_mul_y.x)*bmp_ftimg_top ;
      d1                     :=_d1.x/mul;
      d2                     :=_d2.x/mul;
      d1_                    :=Trunc(65536*d1                );
      d2_                    :=Trunc(65536*d2                );
      scl_mul_x              :=Trunc(65536*(_scl_mul_x.x/mul));
      scl_mul_y              :=Trunc(65536*(_scl_mul_y.x/mul));
      r1                     :=              scl_mul_x*       (                       bmp_ftimg_left)+d1_;
      r2                     :=              scl_mul_y*       (nt_pix_arr_row_mrg_top+bmp_ftimg_top )+d2_;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      bmp_bkgnd_ptr          :=Unaligned(@bmp_bkgnd_ptr      [000000000000000000000000000000000000000000000000000000000000000000000]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
      nt_pix_intr_ccl_arr_ptr:=Unaligned( nt_pix_intr_arr_ptr);
      for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          row_parity:=not row_parity;
          r3        :=((scl_mul_y*y+r2)>>16)*bmp_bkgnd_width;
          for x:=0 to                      nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              if Odd                      (nt_pix_intr_sht_arr_ptr-first_row_pix_ptr) and row_parity then
                (bmp_bkgnd_ptr+((scl_mul_x*nt_pix_intr_sht_arr_ptr^+r1)>>16)+r3)^:=
                                           nt_pix_intr_ccl_arr_ptr^;
              Inc                         (nt_pix_intr_sht_arr_ptr);
              Inc                         (nt_pix_intr_ccl_arr_ptr);
            end;
          Inc                             (nt_pix_intr_cnt_arr_ptr);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.FilNTColorScaleDownMip1; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_cnt_arr_ptr                 : PInteger;
  nt_pix_intr_sht_arr_ptr                 : PInteger;
  nt_pix_intr_ccl_arr_ptr                 : PInteger;
  scl_mul_x,scl_mul_y,d1_,d2_,x,y,r1,r2,r3: integer;
  d1,d2                                   : double;
  _scl_mul_x,_scl_mul_y,_d1,_d2           : TPtPos;
const
  mul                                     : integer=1<<15;
begin
  with fast_image_data_ptr0^ do
    begin
     _scl_mul_x.x            :=Trunc(mul* scl_mul.x);
     _scl_mul_y.x            :=Trunc(mul* scl_mul.y);
      scl_mul.x              := _scl_mul_x.x/ mul;
      scl_mul.y              := _scl_mul_y.x/ mul;
     _d1.x                   :=     (mul-_scl_mul_x.x)*bmp_ftimg_left;
     _d2.x                   :=     (mul-_scl_mul_y.x)*bmp_ftimg_top ;
      d1                     :=_d1.x/mul;
      d2                     :=_d2.x/mul;
      d1_                    :=Trunc(65536*d1                );
      d2_                    :=Trunc(65536*d2                );
      scl_mul_x              :=Trunc(65536*(_scl_mul_x.x/mul));
      scl_mul_y              :=Trunc(65536*(_scl_mul_y.x/mul));
      r1                     :=              scl_mul_x*      (                       bmp_ftimg_left)+d1_;
      r2                     :=              scl_mul_y*      (nt_pix_arr_row_mrg_top+bmp_ftimg_top )+d2_;
      bmp_bkgnd_ptr          :=Unaligned(@bmp_bkgnd_ptr      [0000000000000000000000]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[0000000000000000000000]);
      nt_pix_intr_ccl_arr_ptr:=Unaligned( nt_pix_intr_arr_ptr);
      for y:=0 to bmp_ftimg_height-       nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          r3:=((scl_mul_y*y+r2)>>16)*bmp_bkgnd_width;
          for x:=0 to                     nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              (bmp_bkgnd_ptr+((scl_mul_x* nt_pix_intr_sht_arr_ptr^+r1)>>16)+r3)^:=
                                          nt_pix_intr_ccl_arr_ptr^;
              Inc                        (nt_pix_intr_sht_arr_ptr);
              Inc                        (nt_pix_intr_ccl_arr_ptr);
            end;
          Inc                            (nt_pix_intr_cnt_arr_ptr);
        end;
    end;
end; {$endregion}
{dont remove!!!--important details!!!}                                           {$region -fold}
{procedure TFastImageProc.FilNTColorScaleDownMip2; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_cnt_arr_ptr                                                                                  : PInteger;
  nt_pix_intr_sht_arr_ptr                                                                                  : PInteger;
  nt_pix_intr_ccl_arr_ptr                                                                                  : PInteger;
  first_row_pix_ptr                                                                                        : PInteger;
  bmp_bkgnd_ptr2                                                                                           : PInteger;
  scl_mul_x,scl_mul_y,d1_,d2_,s1_,s2_,x,y,v1,v2,v2_,v3,r1,r3,bmp_ftimg_left_,bmp_ftimg_top_                : integer;
  px,py,s0,s1,s2,g1,g2,alpha,alpha_inv,alpha_inv_mul_65536,_alpha_inv_mul_65536,d1,d2,alpha_sqr,k1,k2,r4,r5: double;
  row_parity                                                                                               : boolean;
  sqr_mul_0_1,sqr_mul_0_5                                                                                  : double;
  _scl_mul_x,_scl_mul_y,_d1,_d2,_r4,_r5,_alpha,_g1,_g2,_px,_py,_s0,_s1,_k1,_k2,_alpha_sqr                  : TPtPos;
  sqr_mul                                                                                                  : integer;
const
  mul                                                                                                      : integer={10000}1<<15{100};
begin
  with fast_image_data_ptr0^ do
    begin
      bmp_ftimg_left_        :=mul*bmp_ftimg_left;
      bmp_ftimg_top_         :=mul*bmp_ftimg_top;
      sqr_mul                :=mul*mul;
      sqr_mul_0_1            :=0000000.1* sqr_mul;
      sqr_mul_0_5            :=0000000.5* sqr_mul;
     _scl_mul_x.x            :=Trunc(mul* scl_mul.x);
     _scl_mul_y.x            :=Trunc(mul* scl_mul.y);
      scl_mul.x              := _scl_mul_x.x/ mul;
      scl_mul.y              := _scl_mul_y.x/ mul;
     _d1.x                   :=     (mul-_scl_mul_x.x)*bmp_ftimg_left;
     _d2.x                   :=     (mul-_scl_mul_y.x)*bmp_ftimg_top ;
      d1                     :=_d1.x/mul;                      //bmp_ftimg_left*(1-scl_mul.x);
      d2                     :=_d2.x/mul;                      //bmp_ftimg_top *(1-scl_mul.y);
      d1_                    :=Trunc(65536*d1                );
      d2_                    :=Trunc(65536*d2                );
      scl_mul_x              :=Trunc(65536*(_scl_mul_x.x/mul));//Trunc($0010000*   scl_mul.x);
      scl_mul_y              :=Trunc(65536*(_scl_mul_y.x/mul));//Trunc($0010000*   scl_mul.y);
      r1                     :=              scl_mul_x*       (                       bmp_ftimg_left)+d1_;
      v3                     :=              scl_mul_y*       (nt_pix_arr_row_mrg_top+bmp_ftimg_top )+d2_;
      r4                     :=              scl_mul.x*       (                       bmp_ftimg_left)+d1 ;
      r5                     :=              scl_mul.y*       (nt_pix_arr_row_mrg_top+bmp_ftimg_top )+d2 ;
     _r4.x                   :=                                                       bmp_ftimg_left_;
     _r5.x                   :=             _scl_mul_y.x*      nt_pix_arr_row_mrg_top+bmp_ftimg_top_;
     {g2                     :=scl_mul.y*y+r5;}
     _g2.x                   :=             _scl_mul_y.x*      nt_pix_arr_row_mrg_top+bmp_ftimg_top_;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      bmp_bkgnd_ptr          :=Unaligned(@bmp_bkgnd_ptr      [000000000000000000000000000000000000000000000000000000000000000000000]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
      nt_pix_intr_ccl_arr_ptr:=Unaligned( nt_pix_intr_arr_ptr);
      alpha                  :=Exp(((_scl_mul_x.x+_scl_mul_y.x)/(mul<<1))*LN_0_95);//Exp(((scl_mul.x+scl_mul.y)/2)*LN_0_95);
     _alpha.x                :=Trunc(mul* alpha);
   // alpha                  :=          _alpha.x/mul;
      alpha_inv              :=mul/      _alpha.x;//1/alpha;
      alpha_inv_mul_65536    :=65536*mul/_alpha.x;//alpha_inv*65536;
   //_alpha_inv_mul_65536    :=alpha_inv_mul_65536/sqr_mul;
     _alpha_sqr.x            :=_alpha.x* _alpha.x;
   //_alpha_sqr.y            :=sqr_mul;
      alpha_sqr              :=_alpha_sqr.x/sqr_mul{-0.25};
      for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          row_parity:=not row_parity;
          v2        :=v3>>16;
          v2_       :=v2*bmp_bkgnd_width;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              if Odd (nt_pix_intr_sht_arr_ptr-first_row_pix_ptr) and row_parity then
                begin
                  v1                                    :=((scl_mul_x*nt_pix_intr_sht_arr_ptr^+r1)>>16);
                 {g1                                    :=  scl_mul.x*nt_pix_intr_sht_arr_ptr^+r4;
                  px                                    :=(Min(v1+1,g1+scl_mul.x)-Max(v1,g1));
                  py                                    :=(Min(v2+1,g2+scl_mul.y)-Max(v2,g2));
                  s0                                    :=px   *py;
                  k1                                    :=alpha*px;
                  k2                                    :=alpha*py;}
                 _g1.x                                  := _scl_mul_x.x*nt_pix_intr_sht_arr_ptr^+bmp_ftimg_left_;
                 _px.x                                  :=(Min2(v1{*mul}<<15+mul,_g1.x+_scl_mul_x.x)-Max2(v1{*mul}<<15,_g1.x));
                 //_px.y                                  :=mul;
                 _py.x                                  :=(Min2(v2{*mul}<<15+mul,_g2.x+_scl_mul_y.x)-Max2(v2{*mul}<<15,_g2.x));
                 //_py.y                                  :=mul;
                 _s0.x                                  :=(         _px.x*_py.x);
                 //_s0.y                                  :=sqr_mul;
                 _k1.x                                  :=(_alpha.x*_px.x      );
                 //_k1.y                                  :=sqr_mul;
                 _k2.x                                  :=(_alpha.x*      _py.x);
                 //_k2.y                                  :=sqr_mul;
                  bmp_bkgnd_ptr2                        :=bmp_bkgnd_ptr+v1+v2_;
                  if (_s0.x>sqr_mul_0_1) then//if (s0>0.1) then
                    begin
                      s1_                               :=(_s0.x<<1) div _alpha.x;//(_s0.x<<16) div (_alpha.x*mul);{s1_:=Trunc(_alpha_inv_mul_65536*_s0);}
                    //s1_                               :=Trunc(alpha_inv_mul_65536*s0);
                     {s2                                :=alpha-s0;
                      s2_                               :=65536-s1_-1;{Trunc(alpha_inv_mul_65536*s2);}
                     (bmp_bkgnd_ptr2+00000000000000000)^:=((s2_*PRGBA(bmp_bkgnd_ptr2+0)^.r+s1_*PRGBA(nt_pix_intr_ccl_arr_ptr)^.r)>>16)<<00+
                                                          ((s2_*PRGBA(bmp_bkgnd_ptr2+0)^.g+s1_*PRGBA(nt_pix_intr_ccl_arr_ptr)^.g)>>16)<<08+
                                                          ((s2_*PRGBA(bmp_bkgnd_ptr2+0)^.b+s1_*PRGBA(nt_pix_intr_ccl_arr_ptr)^.b)>>16)<<16;}
                     (bmp_bkgnd_ptr2+00000000000000000)^:=(PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.r+(s1_*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.r-PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.r))>>16)<<00+
                                                          (PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.g+(s1_*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.g-PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.g))>>16)<<08+
                                                          (PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.b+(s1_*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.b-PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.b))>>16)<<16;
                    end;
                      _s1.x                             :=_k2.x-_s0.x;//s1:=k2-s0;//(alpha-px)*py;
                    //_s1.y                             :=sqr_mul;
                  if (_s1.x>sqr_mul_0_1) then//if (s1>0.1) then
                    begin
                      s1_                               :=(_s1.x<<1) div _alpha.x;//(_s1.x<<16) div (_alpha.x*mul);{s1_:=Trunc(_alpha_inv_mul_65536*_s1);}
                    //s1_                               :=Trunc(alpha_inv_mul_65536*s1);
                     {s2                                :=alpha-s1;
                      s2_                               :=65536-s1_-1;{Trunc(alpha_inv_mul_65536*s2);}
                     (bmp_bkgnd_ptr2+000000000000000+1)^:=((s2_*PRGBA(bmp_bkgnd_ptr2+1)^.r+s1_*PRGBA(nt_pix_intr_ccl_arr_ptr)^.r)>>16)<<00+
                                                          ((s2_*PRGBA(bmp_bkgnd_ptr2+1)^.g+s1_*PRGBA(nt_pix_intr_ccl_arr_ptr)^.g)>>16)<<08+
                                                          ((s2_*PRGBA(bmp_bkgnd_ptr2+1)^.b+s1_*PRGBA(nt_pix_intr_ccl_arr_ptr)^.b)>>16)<<16;}
                     (bmp_bkgnd_ptr2+000000000000000+1)^:=(PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.r+(s1_*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.r-PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.r))>>16)<<00+
                                                          (PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.g+(s1_*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.g-PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.g))>>16)<<08+
                                                          (PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.b+(s1_*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.b-PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.b))>>16)<<16;
                    end;
                      _s1.x                             :=_k1.x-_s0.x;//s1:=k1-s0;//(alpha-py)*px;
                    //_s1.y                             :=sqr_mul;
                  if (_s1.x>sqr_mul_0_5) then//if (s1>0.5) then
                    begin
                      s1_                               :=(_s1.x<<1) div _alpha.x;//(_s1.x<<16) div (_alpha.x*mul);{s1_:=Trunc(_alpha_inv_mul_65536*_s1);}
                    //s1_                               :=Trunc(alpha_inv_mul_65536*s1);
                     {s2                                :=alpha-s1;
                      s2_                               :=65536-s1_-1;{Trunc(alpha_inv_mul_65536*s2);}
                     (bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^:=((s2_*PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.r+s1_*PRGBA(nt_pix_intr_ccl_arr_ptr)^.r)>>16)<<00+
                                                          ((s2_*PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.g+s1_*PRGBA(nt_pix_intr_ccl_arr_ptr)^.g)>>16)<<08+
                                                          ((s2_*PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.b+s1_*PRGBA(nt_pix_intr_ccl_arr_ptr)^.b)>>16)<<16;}
                     (bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^:=(PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.r+(s1_*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.r-PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.r))>>16)<<00+
                                                          (PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.g+(s1_*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.g-PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.g))>>16)<<08+
                                                          (PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.b+(s1_*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.b-PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.b))>>16)<<16;
                    end
                  else
                     (bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^:=nt_pix_intr_ccl_arr_ptr^;
                      _s1.x                             :=_alpha_sqr.x-_k1.x-_k2.x+_s0.x;//s1:=alpha_sqr-k1-k2+s0;//(alpha-py)*(alpha-px);
                    //_s1.y                             :=sqr_mul;
                  if (_s1.x>sqr_mul_0_5) then//if (s1>0.5) then
                    begin
                      s1_                               :=(_s1.x<<1) div _alpha.x;//(_s1.x<<16) div (_alpha.x*mul);{s1_:=Trunc(_alpha_inv_mul_65536*_s1);}
                    //s1_                               :=Trunc(alpha_inv_mul_65536*s1);
                     {s2                                :=alpha-s1;
                      s2_                               :=65536-s1_-1;{Trunc(alpha_inv_mul_65536*s2);}
                     (bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^:=((s2_*PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.r+s1_*PRGBA(nt_pix_intr_ccl_arr_ptr)^.r)>>16)<<00+
                                                           ((s2_*PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.g+s1_*PRGBA(nt_pix_intr_ccl_arr_ptr)^.g)>>16)<<08+
                                                           ((s2_*PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.b+s1_*PRGBA(nt_pix_intr_ccl_arr_ptr)^.b)>>16)<<16;}
                     (bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^:=(PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.r+(s1_*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.r-PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.r))>>16)<<00+
                                                          (PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.g+(s1_*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.g-PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.g))>>16)<<08+
                                                          (PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.b+(s1_*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.b-PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.b))>>16)<<16;
                    end
                  else
                     (bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^:=nt_pix_intr_ccl_arr_ptr^;
                end;
              Inc                                        (nt_pix_intr_sht_arr_ptr);
              Inc                                        (nt_pix_intr_ccl_arr_ptr);
            end;
          Inc                                            (nt_pix_intr_cnt_arr_ptr);
          Inc( v3  , scl_mul_y  );
          Inc(_g2.x,_scl_mul_y.x);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.FilNTColorScaleDownMip2; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_cnt_arr_ptr                                                                         : PInteger;
  nt_pix_intr_sht_arr_ptr                                                                         : PInteger;
  nt_pix_intr_ccl_arr_ptr                                                                         : PInteger;
  first_row_pix_ptr                                                                               : PInteger;
  bmp_bkgnd_ptr2                                                                                  : PInteger;
  scl_mul_x  , scl_mul_y,d1_,d2_,x,y,v1,v2,v2_,v3,r1,s1_,s0_mul_2_div_alpha,bmp_ftimg_left_       : integer;
 _scl_mul_x  ,_scl_mul_y,d1 ,d2 ,alpha,g1,g2,px,py,t,s1 ,s0,k1,k2,alpha_sqr,bmp_ftimg_top_,sqr_mul: integer;
  sqr_mul_0_1, sqr_mul_0_5                                                                        : integer{double};
  row_parity                                                                                      : boolean;
const
  mul1                                                                                            : integer=1<<15;
  mul2                                                                                            : integer=1<<16;
begin
  with fast_image_data_ptr0^ do
    begin
      sqr_mul                :=      mul1*      mul1;
      sqr_mul_0_1            :=Trunc(0.1*   sqr_mul  );//0000000.1*    sqr_mul;
      sqr_mul_0_5            :=Trunc(0.5*   sqr_mul  );//0000000.5*    sqr_mul;
     _scl_mul_x              :=Trunc(mul1*  scl_mul.x);
     _scl_mul_y              :=Trunc(mul1*  scl_mul.y);
      bmp_ftimg_left_        :=      mul1*             bmp_ftimg_left;
      bmp_ftimg_top_         :=      mul1*             bmp_ftimg_top ;
      d1                     :=     (mul1- _scl_mul_x)*bmp_ftimg_left;
      d2                     :=     (mul1- _scl_mul_y)*bmp_ftimg_top ;
      d1_                    :=Trunc(mul2*(        d1/mul1));
      d2_                    :=Trunc(mul2*(        d2/mul1));
      scl_mul_x              :=Trunc(mul2*(_scl_mul_x/mul1));
      scl_mul_y              :=Trunc(mul2*(_scl_mul_y/mul1));
      r1                     :=             scl_mul_x*        (                       bmp_ftimg_left)+d1_;
      v3                     :=             scl_mul_y*        (nt_pix_arr_row_mrg_top+bmp_ftimg_top )+d2_;
      g2                     :=            _scl_mul_y*         nt_pix_arr_row_mrg_top+bmp_ftimg_top_;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      bmp_bkgnd_ptr          :=Unaligned(@bmp_bkgnd_ptr      [0000000000000000000000]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[0000000000000000000000]);
      nt_pix_intr_ccl_arr_ptr:=Unaligned( nt_pix_intr_arr_ptr);
      alpha                  :=mul1;//Trunc(mul1*Exp(((_scl_mul_x+_scl_mul_y)/(mul1<<1))*LN_0_95));
      alpha_sqr              :=alpha*alpha;
      for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          row_parity:=not row_parity;
          v2        :=v3>>16;
          v2_       :=v2*bmp_bkgnd_width;
          py        :=MinSubMax(v2<<15,g2,mul1,_scl_mul_y);//(Min2(v2<<15+mul1,g2+_scl_mul_y)-Max2(v2<<15,g2));
          k2        :=py<<15;//alpha*py;
          t         :=alpha-py;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              if Odd (nt_pix_intr_sht_arr_ptr-first_row_pix_ptr) and row_parity then
                begin
                  v1                                    :=(scl_mul_x*nt_pix_intr_sht_arr_ptr^+r1)>>16;
                  g1                                    :=_scl_mul_x*nt_pix_intr_sht_arr_ptr^+bmp_ftimg_left_;
                  px                                    :=MinSubMax(v1<<15,g1,mul1,_scl_mul_x);//(Min2(v1<<15+mul1,g1+_scl_mul_x)-Max2(v1<<15,g1));
                  s0                                    :=px*py;
                  k1                                    :=px<<15;//px*alpha;
                  bmp_bkgnd_ptr2                        :=bmp_bkgnd_ptr+v1+v2_;
                  s0_mul_2_div_alpha                    :=s0>>14;//(s0<<1) div alpha;
                  if (s0>sqr_mul_0_1) then
                    begin
                    //s1_                               :=(s0<<1) div alpha;
                     (bmp_bkgnd_ptr2+00000000000000000)^:=(PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.r+(s0_mul_2_div_alpha{s1_}*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.r-PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.r))>>16)<<00+
                                                          (PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.g+(s0_mul_2_div_alpha{s1_}*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.g-PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.g))>>16)<<08+
                                                          (PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.b+(s0_mul_2_div_alpha{s1_}*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.b-PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.b))>>16)<<16;
                    end;
                    //s1                                :=k2-s0;
                  if (k2-s0>sqr_mul_0_1) then//if (s1>sqr_mul_0_1) then
                    begin
                      s1_                               :=py<<1-s0_mul_2_div_alpha;//(s1<<1) div alpha;
                     (bmp_bkgnd_ptr2+000000000000000+1)^:=(PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.r+(s1_*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.r-PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.r))>>16)<<00+
                                                          (PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.g+(s1_*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.g-PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.g))>>16)<<08+
                                                          (PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.b+(s1_*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.b-PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.b))>>16)<<16;
                    end;
                    //s1                                :=k1-s0;
                  {if (k1-s0>sqr_mul_0_5) then//if (s1>sqr_mul_0_5) then
                    begin
                      s1_                               :=px<<1-s0_mul_2_div_alpha;//(s1<<1) div alpha;
                     (bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^:=(PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.r+(s1_*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.r-PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.r))>>16)<<00+
                                                          (PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.g+(s1_*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.g-PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.g))>>16)<<08+
                                                          (PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.b+(s1_*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.b-PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.b))>>16)<<16;
                    end
                  else}
                  if (k1-s0<=sqr_mul_0_5) then
                     (bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^:=nt_pix_intr_ccl_arr_ptr^;
                    //s1                                :=alpha_sqr-k1-k2+s0;
                  {if (alpha_sqr-k1-k2+s0>sqr_mul_0_5) then//if (s1>sqr_mul_0_5) then
                    begin
                      s1_                               :=(t-px)<<1+s0_mul_2_div_alpha;//(s1<<1) div alpha;
                     (bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^:=(PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.r+(s1_*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.r-PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.r))>>16)<<00+
                                                          (PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.g+(s1_*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.g-PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.g))>>16)<<08+
                                                          (PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.b+(s1_*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.b-PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.b))>>16)<<16;
                    end
                  else}
                  if (alpha_sqr-k1-k2+s0<=sqr_mul_0_5) then
                     (bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^:=nt_pix_intr_ccl_arr_ptr^;
                end;
              Inc                                        (nt_pix_intr_sht_arr_ptr);
              Inc                                        (nt_pix_intr_ccl_arr_ptr);
            end;
          Inc                                            (nt_pix_intr_cnt_arr_ptr);
          Inc(v3, scl_mul_y);
          Inc(g2,_scl_mul_y);
        end;
    end;
end; {$endregion}} {$endregion}
procedure TFastImageProc.FilNTColorScaleDownMip2; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_cnt_arr_ptr                                                                  : PInteger;
  nt_pix_intr_sht_arr_ptr                                                                  : PInteger;
  nt_pix_intr_ccl_arr_ptr                                                                  : PInteger;
  first_row_pix_ptr                                                                        : PInteger;
  bmp_bkgnd_ptr2                                                                           : PInteger;
  scl_mul_x  , scl_mul_y,d1_,d2_,x,y,v1,v2,v2_,v3,r1,s1_,s0_mul_2_div_alpha,bmp_ftimg_left_: integer;
 _scl_mul_x  ,_scl_mul_y,d1 ,d2 ,g1,g2,px,py,s0,k1,k2,bmp_ftimg_top_,sqr_mul               : integer;
  sqr_mul_0_1, sqr_mul_0_5                                                                 : integer;
  row_parity                                                                               : boolean;
const
  mul1                                                                                     : integer=1<<15;
  mul2                                                                                     : integer=1<<16;
  mul3                                                                                     : integer=1<<30;
begin
  with fast_image_data_ptr0^ do
    begin
      sqr_mul                :=      mul1*      mul1;
      sqr_mul_0_1            :=Trunc(00.1*  sqr_mul  );
      sqr_mul_0_5            :=Trunc(00.5*  sqr_mul  );
     _scl_mul_x              :=Trunc(mul1*  scl_mul.x);
     _scl_mul_y              :=Trunc(mul1*  scl_mul.y);
      bmp_ftimg_left_        :=      mul1*             bmp_ftimg_left;
      bmp_ftimg_top_         :=      mul1*             bmp_ftimg_top ;
      d1                     :=     (mul1- _scl_mul_x)*bmp_ftimg_left;
      d2                     :=     (mul1- _scl_mul_y)*bmp_ftimg_top ;
      d1_                    :=Trunc(mul2*(        d1/mul1));
      d2_                    :=Trunc(mul2*(        d2/mul1));
      scl_mul_x              :=Trunc(mul2*(_scl_mul_x/mul1));
      scl_mul_y              :=Trunc(mul2*(_scl_mul_y/mul1));
      r1                     :=             scl_mul_x*       (                       bmp_ftimg_left)+d1_;
      v3                     :=             scl_mul_y*       (nt_pix_arr_row_mrg_top+bmp_ftimg_top )+d2_;
      g2                     :=            _scl_mul_y*        nt_pix_arr_row_mrg_top+bmp_ftimg_top_;
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      bmp_bkgnd_ptr          :=Unaligned(@bmp_bkgnd_ptr      [000000000000000000000000000000000000000000000000000000000000000000000]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
      nt_pix_intr_ccl_arr_ptr:=Unaligned( nt_pix_intr_arr_ptr);
      for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          row_parity:=not row_parity;
          v2        :=v3>>16;
          v2_       :=v2*bmp_bkgnd_width;
          py        :=MinSubMax(v2<<15,g2,mul1,_scl_mul_y);
          k2        :=py<<15;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              if Odd (nt_pix_intr_sht_arr_ptr-first_row_pix_ptr) and row_parity then
                begin
                  v1                                    :=(scl_mul_x*nt_pix_intr_sht_arr_ptr^+r1)>>16;
                  g1                                    :=_scl_mul_x*nt_pix_intr_sht_arr_ptr^+bmp_ftimg_left_;
                  px                                    :=MinSubMax(v1<<15,g1,mul1,_scl_mul_x);
                  s0                                    :=px*py;
                  k1                                    :=px<<15;
                  bmp_bkgnd_ptr2                        :=bmp_bkgnd_ptr+v1+v2_;
                  s0_mul_2_div_alpha                    :=s0>>14;
                  if (s0>sqr_mul_0_1) then
                    begin
                     (bmp_bkgnd_ptr2+00000000000000000)^:=(PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.r+(s0_mul_2_div_alpha*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.r-PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.r))>>16)<<00+
                                                          (PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.g+(s0_mul_2_div_alpha*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.g-PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.g))>>16)<<08+
                                                          (PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.b+(s0_mul_2_div_alpha*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.b-PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.b))>>16)<<16;
                    end;
                  if (k2-s0>sqr_mul_0_1) then
                    begin
                      s1_                               :=py<<1-s0_mul_2_div_alpha;
                     (bmp_bkgnd_ptr2+000000000000000+1)^:=(PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.r+(s1_*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.r-PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.r))>>16)<<00+
                                                          (PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.g+(s1_*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.g-PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.g))>>16)<<08+
                                                          (PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.b+(s1_*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.b-PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.b))>>16)<<16;
                    end;
                  if (k1-s0<=sqr_mul_0_5) then
                     (bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^:=nt_pix_intr_ccl_arr_ptr^;
                  if (mul3-k1-k2+s0<=sqr_mul_0_5) then
                     (bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^:=nt_pix_intr_ccl_arr_ptr^;
                end;
              Inc                                        (nt_pix_intr_sht_arr_ptr);
              Inc                                        (nt_pix_intr_ccl_arr_ptr);
            end;
          Inc                                            (nt_pix_intr_cnt_arr_ptr);
          Inc(v3, scl_mul_y);
          Inc(g2,_scl_mul_y);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.FilNTColorScaleDownMip3; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_cnt_arr_ptr                                                                  : PInteger;
  nt_pix_intr_sht_arr_ptr                                                                  : PInteger;
  nt_pix_intr_ccl_arr_ptr                                                                  : PInteger;
  bmp_bkgnd_ptr2                                                                           : PInteger;
  scl_mul_x  , scl_mul_y,d1_,d2_,x,y,v1,v2,v2_,v3,r1,s1_,s0_mul_2_div_alpha,bmp_ftimg_left_: integer;
 _scl_mul_x  ,_scl_mul_y,d1 ,d2 ,g1,g2,px,py,s0,k1,k2,bmp_ftimg_top_,sqr_mul               : integer;
  sqr_mul_0_1, sqr_mul_0_5                                                                 : integer;
const
  mul1                                                                                     : integer=1<<15;
  mul2                                                                                     : integer=1<<16;
  mul3                                                                                     : integer=1<<30;
begin
  with fast_image_data_ptr0^ do
    begin
      sqr_mul                :=      mul1*      mul1;
      sqr_mul_0_1            :=Trunc(00.1*  sqr_mul  );
      sqr_mul_0_5            :=Trunc(00.5*  sqr_mul  );
     _scl_mul_x              :=Trunc(mul1*  scl_mul.x);
     _scl_mul_y              :=Trunc(mul1*  scl_mul.y);
      bmp_ftimg_left_        :=      mul1*             bmp_ftimg_left;
      bmp_ftimg_top_         :=      mul1*             bmp_ftimg_top ;
      d1                     :=     (mul1- _scl_mul_x)*bmp_ftimg_left;
      d2                     :=     (mul1- _scl_mul_y)*bmp_ftimg_top ;
      d1_                    :=Trunc(mul2*(        d1/mul1));
      d2_                    :=Trunc(mul2*(        d2/mul1));
      scl_mul_x              :=Trunc(mul2*(_scl_mul_x/mul1));
      scl_mul_y              :=Trunc(mul2*(_scl_mul_y/mul1));
      r1                     :=             scl_mul_x*       (                       bmp_ftimg_left)+d1_;
      v3                     :=             scl_mul_y*       (nt_pix_arr_row_mrg_top+bmp_ftimg_top )+d2_;
      g2                     :=            _scl_mul_y*        nt_pix_arr_row_mrg_top+bmp_ftimg_top_;
      bmp_bkgnd_ptr          :=Unaligned(@bmp_bkgnd_ptr      [0000000000000000000000]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[0000000000000000000000]);
      nt_pix_intr_ccl_arr_ptr:=Unaligned( nt_pix_intr_arr_ptr);
      for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          v2   :=v3>>16;
          v2_  :=v2*bmp_bkgnd_width;
          py   :=MinSubMax(v2<<15,g2,mul1,_scl_mul_y);
          k2   :=py<<15;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              v1                                    :=(scl_mul_x*nt_pix_intr_sht_arr_ptr^+r1)>>16;
              g1                                    :=_scl_mul_x*nt_pix_intr_sht_arr_ptr^+bmp_ftimg_left_;
              px                                    :=MinSubMax(v1<<15,g1,mul1,_scl_mul_x);
              s0                                    :=px*py;
              k1                                    :=px<<15;
              bmp_bkgnd_ptr2                        :=bmp_bkgnd_ptr+v1+v2_;
              s0_mul_2_div_alpha                    :=s0>>14;
              if (s0>sqr_mul_0_1) then
                begin
                 (bmp_bkgnd_ptr2+00000000000000000)^:=(PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.r+(s0_mul_2_div_alpha*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.r-PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.r))>>16)<<00+
                                                      (PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.g+(s0_mul_2_div_alpha*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.g-PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.g))>>16)<<08+
                                                      (PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.b+(s0_mul_2_div_alpha*(PRGBA(nt_pix_intr_ccl_arr_ptr)^.b-PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.b))>>16)<<16;
                end;
              if (k2-s0>sqr_mul_0_1) then
                begin
                  s1_                               :=py<<1-s0_mul_2_div_alpha;
                 (bmp_bkgnd_ptr2+000000000000000+1)^:=(PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.r+(s1_               *(PRGBA(nt_pix_intr_ccl_arr_ptr)^.r-PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.r))>>16)<<00+
                                                      (PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.g+(s1_               *(PRGBA(nt_pix_intr_ccl_arr_ptr)^.g-PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.g))>>16)<<08+
                                                      (PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.b+(s1_               *(PRGBA(nt_pix_intr_ccl_arr_ptr)^.b-PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.b))>>16)<<16;
                end;
              if (k1-s0<=sqr_mul_0_5) then
                 (bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^:=nt_pix_intr_ccl_arr_ptr^;
              if (mul3-k1-k2+s0<=sqr_mul_0_5) then
                 (bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^:=nt_pix_intr_ccl_arr_ptr^;
              Inc                                    (nt_pix_intr_sht_arr_ptr);
              Inc                                    (nt_pix_intr_ccl_arr_ptr);
            end;
          Inc                                        (nt_pix_intr_cnt_arr_ptr);
          Inc(v3, scl_mul_y);
          Inc(g2,_scl_mul_y);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.FilNTColorScaleDownMAll; {$ifdef Linux}[local];{$endif} {$region -fold}
label
  l1;
begin
  //type
  //  PInteger =PLongWord;
  //  TColor   =LongWord;
  //  TColorArr=array of TColor;
  //  TPtPosF  =packed record
  //    x,y: double;
  //  end;
  //var
  //  nt_pix_intr_cnt_arr   : TColorArr; // array of items counts in each of rows;
  //  nt_pix_intr_sht_arr   : TColorArr; // array of items shifts: from first item in a row to current;
  //  nt_pix_intr_ccl_arr   : TColorArr; // array of items color data;
  //  scl_mul               : TPtPosF;   // scale multiplier;
  //  bmp_ftimg_left        : integer;   // x-coordinate of left top corner of image;
  //  bmp_ftimg_top         : integer;   // y-coordinate of left top corner of image;
  //  bmp_bkgnd_width       : integer;   // width of drawing surface(background bitmap);
  //  nt_pix_arr_row_mrg_top: TColor;    // distance from the top    down to the first row containing at least one fully opaque(not transparent) pixel;
  //  nt_pix_arr_row_mrg_btm: TColor;    // distance from the bottom up   to the first row containing at least one fully opaque(not transparent) pixel;
  //  bmp_bkgnd_ptr         : PInteger;  // pointer to first pixel of drawing surface(background bitmap pointer);
  // inf:=65536*0.25*Exp((0.75*LN_0_95));
  // sup:=65536*0.75*Exp((0.25*LN_0_95));
  with fast_image_data_ptr0^ do
    begin
      if (scl_mul.x<0.15) and (scl_mul.y<0.15) then
        FilNTColorScaleDownMip0
      else
      if ((scl_mul.x<0.2)        and
          (scl_mul.y<0.2))        or
         ((scl_mul.x>0.5-0.01)   and
          (scl_mul.x<0.5+0.01)   and
          (scl_mul.y>0.5-0.01)   and
          (scl_mul.y<0.5+0.01))   or
         ((scl_mul.x>0.5-0.01)   and
          (scl_mul.x<0.5+0.01)   and
          (scl_mul.y>1.0-0.01)   and
          (scl_mul.y<1.0+0.01)) then
        begin
          l1:
          FilNTColorScaleDownMip1;
          Exit;
        end
      else
      if (scl_mul.x<0.25) and
         (scl_mul.y<0.25) then
        FilNTColorScaleDownMip2
      else
      if (scl_mul.x<0.75) and
         (scl_mul.y<0.75) then
        FilNTColorScaleDownMip3
      else
      if (scl_mul.x<1.00) or
         (scl_mul.y<1.00) then
        goto l1;
    end;
end; {$endregion}
procedure TFastImageProc.BlrNTColorScaleDown;     {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_cnt_arr_ptr    : PInteger;
  nt_pix_intr_sht_arr_ptr    : PInteger;
  nt_pix_intr_ccl_arr_ptr    : PInteger;
  d1,d2                      : double;
  x,y                        : integer;
  scl_mul_x,scl_mul_y,d1_,d2_: integer;
begin
  with fast_image_data_ptr0^ do
    begin
      d1                         :=bmp_ftimg_left *(1-scl_mul.x);
      d2                         :=bmp_ftimg_top  *(1-scl_mul.y);
      scl_mul_x                  :=Trunc(scl_mul.x*C_INT);
      scl_mul_y                  :=Trunc(scl_mul.y*C_INT);
      d1_                        :=Trunc(d1       *C_INT);
      d2_                        :=Trunc(d2       *C_INT);
      bmp_bkgnd_ptr              :=Unaligned(@bmp_bkgnd_ptr      [0000000000000000000000]);
      nt_pix_intr_cnt_arr_ptr    :=Unaligned(@nt_pix_intr_cnt_arr[nt_pix_arr_row_mrg_top]);
      nt_pix_intr_sht_arr_ptr    :=Unaligned(@nt_pix_intr_sht_arr[0000000000000000000000]);
      nt_pix_intr_ccl_arr_ptr    :=Unaligned( nt_pix_intr_arr_ptr);
      for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              (bmp_bkgnd_ptr+((scl_mul_x*(nt_pix_intr_sht_arr_ptr^+bmp_ftimg_left)+d1_)>>16)+
                             ((scl_mul_y*(nt_pix_arr_row_mrg_top+y+bmp_ftimg_top )+d2_)>>16)*bmp_bkgnd_width)^:=
              nt_pix_intr_ccl_arr_ptr^;
                                      Inc(nt_pix_intr_sht_arr_ptr);
                                      Inc(nt_pix_intr_ccl_arr_ptr);
            end;
                                      Inc(nt_pix_intr_cnt_arr_ptr);
        end;
    end;
end; {$endregion}
// value:
procedure TFastImageProc.FilNTValueScaleDown;     {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_ccl_arr_ptr: PInteger;
  x,y                    : integer;
  d1,d2                  : double;
begin
  // TODO
end; {$endregion}
// scale up:
// color:
procedure TFastImageProc.FilNTColorScaleUp;       {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // TODO
end; {$endregion}
// value:
procedure TFastImageProc.FilNTValueScaleUp;       {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // TODO
end; {$endregion}
// PT - partly transparent pixels:
// scale down:
// color:
procedure TFastImageProc.FilPTColorScaleDownMip0; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_intr_cnt_arr_ptr             : PInteger;
  pt_pix_intr_sht_arr_ptr             : PInteger;
  pt_pix_intr_ccl_arr_ptr             : PInteger;
  bmp_bkgnd_ptr2                      : PInteger;
  d1,d2                               : double;
  x,y                                 : integer;
  scl_mul_x,scl_mul_y,d1_,d2_,r1,r2,r3: integer;
begin
  with fast_image_data_ptr0^ do
    begin
      d1                     :=bmp_ftimg_left *(1-scl_mul.x);
      d2                     :=bmp_ftimg_top  *(1-scl_mul.y);
      d1_                    :=Trunc($00010000*   d1       );
      d2_                    :=Trunc($00010000*   d2       );
      scl_mul_x              :=Trunc($00010000*   scl_mul.x);
      scl_mul_y              :=Trunc($00010000*   scl_mul.y);
      r1                     :=scl_mul_x*(                       bmp_ftimg_left)+d1_;
      r2                     :=scl_mul_y*(pt_pix_arr_row_mrg_top+bmp_ftimg_top )+d2_;
      bmp_bkgnd_ptr          :=Unaligned(@bmp_bkgnd_ptr      [0000000000000000000000]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[0000000000000000000000]);
      pt_pix_intr_ccl_arr_ptr:=Unaligned( pt_pix_intr_arr_ptr);
      for y:=0 to bmp_ftimg_height-       pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          r3:=((scl_mul_y*y+r2)>>16)*bmp_bkgnd_width;
          for x:=0 to                     pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              bmp_bkgnd_ptr2:=
              bmp_bkgnd_ptr+  ((scl_mul_x*pt_pix_intr_sht_arr_ptr^+r1)>>16)+r3;
              bmp_bkgnd_ptr2^:=AlphaBlendB(
              bmp_bkgnd_ptr2^,
                                         (pt_pix_intr_ccl_arr_ptr^),alpha_max-
              PRGBA                      (pt_pix_intr_ccl_arr_ptr)^.a);
              Inc                        (pt_pix_intr_sht_arr_ptr);
              Inc                        (pt_pix_intr_ccl_arr_ptr);
            end;
          Inc                            (pt_pix_intr_cnt_arr_ptr);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.FilPTColorScaleDownMip1; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_intr_cnt_arr_ptr             : PInteger;
  pt_pix_intr_sht_arr_ptr             : PInteger;
  pt_pix_intr_ccl_arr_ptr             : PInteger;
  bmp_bkgnd_ptr2                      : PInteger;
  d1,d2                               : double;
  x,y                                 : integer;
  scl_mul_x,scl_mul_y,d1_,d2_,r1,r2,r3: integer;
  alpha                               : byte;
begin
  with fast_image_data_ptr0^ do
    begin
      d1                     :=bmp_ftimg_left *(1-scl_mul.x);
      d2                     :=bmp_ftimg_top  *(1-scl_mul.y);
      d1_                    :=Trunc($00010000*   d1       );
      d2_                    :=Trunc($00010000*   d2       );
      scl_mul_x              :=Trunc($00010000*   scl_mul.x);
      scl_mul_y              :=Trunc($00010000*   scl_mul.y);
      r1                     :=scl_mul_x*(                       bmp_ftimg_left)+d1_;
      r2                     :=scl_mul_y*(pt_pix_arr_row_mrg_top+bmp_ftimg_top )+d2_;
      bmp_bkgnd_ptr          :=Unaligned(@bmp_bkgnd_ptr      [0000000000000000000000]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[0000000000000000000000]);
      pt_pix_intr_ccl_arr_ptr:=Unaligned( pt_pix_intr_arr_ptr);
      for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          r3:=((scl_mul_y*y+r2)>>16)*bmp_bkgnd_width;
          for x:=0 to                                     pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              bmp_bkgnd_ptr2:=bmp_bkgnd_ptr+  ((scl_mul_x*pt_pix_intr_sht_arr_ptr^+r1)>>16)+r3;
              //if       (PRGBA(bmp_bkgnd_ptr2)^.a<>0) then
                begin
                        alpha:=
                       (PRGBA(bmp_bkgnd_ptr2)^.a+   PRGBA(pt_pix_intr_ccl_arr_ptr)^.a)>>1;
                              bmp_bkgnd_ptr2^:=AlphaBlend0(
                              bmp_bkgnd_ptr2^,
                       (PRGBA(bmp_bkgnd_ptr2)^.b+3* PRGBA(pt_pix_intr_ccl_arr_ptr)^.b)>>2,
                       (PRGBA(bmp_bkgnd_ptr2)^.g+3* PRGBA(pt_pix_intr_ccl_arr_ptr)^.g)>>2,
                       (PRGBA(bmp_bkgnd_ptr2)^.r+3* PRGBA(pt_pix_intr_ccl_arr_ptr)^.r)>>2,
                       alpha,
                      -alpha+alpha_max);
                end
              {else
                              bmp_bkgnd_ptr2^:=
                              bmp_bkgnd_ptr2^<<8>>8+     (pt_pix_intr_ccl_arr_ptr)^>>24<<24; //({alpha_max-}Min((bmp_bkgnd_ptr2^>>24+(pt_pix_intr_ccl_arr_ptr)^>>24)>>1+64,MAXBYTE))<<24};
              Inc                                        (pt_pix_intr_sht_arr_ptr);
              Inc                                        (pt_pix_intr_ccl_arr_ptr);
            end;
          Inc                                            (pt_pix_intr_cnt_arr_ptr);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.FilPTColorScaleDownMAll; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_intr_cnt_arr_ptr             : PInteger;
  pt_pix_intr_sht_arr_ptr             : PInteger;
  pt_pix_intr_ccl_arr_ptr             : PInteger;
  bmp_bkgnd_ptr2                      : PInteger;
  d1,d2                               : double;
  x,y                                 : integer;
  scl_mul_x,scl_mul_y,d1_,d2_,r1,r2,r3: integer;
  alpha                               : byte;
label
  l1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (scl_mul.x<0.2)  and
         (scl_mul.y<0.2) then
        begin
          l1:
          FilPTColorScaleDownMip0;
          Exit;
        end
      else
      if (scl_mul.x<0.5-0.01) and
         (scl_mul.y<0.5-0.01) then
        FilPTColorScaleDownMip1
      else
      if (scl_mul.x<1.0) or
         (scl_mul.y<1.0) then
        goto l1;
    end;
end; {$endregion}
procedure TFastImageProc.BlrPTColorScaleDown;     {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_intr_cnt_arr_ptr    : PInteger;
  pt_pix_intr_sht_arr_ptr    : PInteger;
  pt_pix_intr_ccl_arr_ptr    : PInteger;
  d1,d2                      : double;
  x,y                        : integer;
  scl_mul_x,scl_mul_y,d1_,d2_: integer;
begin
  with fast_image_data_ptr0^ do
    begin
      d1                         :=bmp_ftimg_left *(1-scl_mul.x);
      d2                         :=bmp_ftimg_top  *(1-scl_mul.y);
      scl_mul_x                  :=Trunc(scl_mul.x*C_INT);
      scl_mul_y                  :=Trunc(scl_mul.y*C_INT);
      d1_                        :=Trunc(d1       *C_INT);
      d2_                        :=Trunc(d2       *C_INT);
      bmp_bkgnd_ptr              :=Unaligned(@bmp_bkgnd_ptr      [0000000000000000000000]);
      pt_pix_intr_cnt_arr_ptr    :=Unaligned(@pt_pix_intr_cnt_arr[pt_pix_arr_row_mrg_top]);
      pt_pix_intr_sht_arr_ptr    :=Unaligned(@pt_pix_intr_sht_arr[0000000000000000000000]);
      pt_pix_intr_ccl_arr_ptr    :=Unaligned( pt_pix_intr_arr_ptr);
      for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              (bmp_bkgnd_ptr+((scl_mul_x*(pt_pix_intr_sht_arr_ptr^+bmp_ftimg_left)+d1_)>>16)+
                             ((scl_mul_y*(pt_pix_arr_row_mrg_top+y+bmp_ftimg_top )+d2_)>>16)   *bmp_bkgnd_width)^:=BlurRGB9(
              (bmp_bkgnd_ptr+((scl_mul_x*(pt_pix_intr_sht_arr_ptr^+bmp_ftimg_left)+d1_)>>16)-1+
                            (((scl_mul_y*(pt_pix_arr_row_mrg_top+y+bmp_ftimg_top )+d2_)>>16)-1)*bmp_bkgnd_width),bmp_bkgnd_width);
                                      Inc(pt_pix_intr_sht_arr_ptr);
                                      Inc(pt_pix_intr_ccl_arr_ptr);
            end;
                                      Inc(pt_pix_intr_cnt_arr_ptr);
        end;
    end;
end; {$endregion}
// value:
procedure TFastImageProc.FilPTValueScaleDown;     {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // TODO
end; {$endregion}
// scale up:
// color:
procedure TFastImageProc.FilPTColorScaleUp;       {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // TODO
end; {$endregion}
// value:
procedure TFastImageProc.FilPTValueScaleUp;       {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // TODO
end; {$endregion}

{$endregion}

{Fill Array at Specified Rectangle with Specified Value} {$region -fold}
// NT - not transparent pixels:
procedure TFastImageProc.FilNTValueArrA(var arr_src:TColorArr ; constref bmp_ftimg_width_:TColor; constref val:TColor=0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_value_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (nt_pix_cnt=0) then
        Exit;
      first_row_pix_ptr      :=Unaligned(@arr_src            [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width_+bmp_src_rct_clp.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ 000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          pix_value_ptr:=first_row_pix_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (nt_pix_intr_sht_arr_ptr^+pix_value_ptr)^:=val;
              Inc    (nt_pix_intr_sht_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_ftimg_width_);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.FilNTValueArrB(var arr_src:T1Byte1Arr; constref bmp_ftimg_width_:TColor; constref val:byte  =0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_value_ptr          : PByte;
  first_row_pix_ptr      : PByte;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (nt_pix_cnt=0) then
        Exit;
      first_row_pix_ptr      :=Unaligned(@arr_src            [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width_+bmp_src_rct_clp.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ 000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          pix_value_ptr:=first_row_pix_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (nt_pix_intr_sht_arr_ptr^+pix_value_ptr)^:=val;
              Inc    (nt_pix_intr_sht_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_ftimg_width_);
        end;
    end;
end; {$endregion}
// PT - partly transparent pixels:
procedure TFastImageProc.FilPTValueArrA(var arr_src:TColorArr ; constref bmp_ftimg_width_:TColor; constref val:TColor=0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_value_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (pt_pix_cnt=0) then
        Exit;
      first_row_pix_ptr      :=Unaligned(@arr_src            [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width_+bmp_src_rct_clp.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ 000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          pix_value_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_intr_sht_arr_ptr^+pix_value_ptr)^:=val;
              Inc    (pt_pix_intr_sht_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_ftimg_width_);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.FilPTValueArrB(var arr_src:T1Byte1Arr; constref bmp_ftimg_width_:TColor; constref val:byte  =0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_value_ptr          : PByte;
  first_row_pix_ptr      : PByte;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (pt_pix_cnt=0) then
        Exit;
      first_row_pix_ptr      :=Unaligned(@arr_src            [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width_+bmp_src_rct_clp.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[ 000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          pix_value_ptr:=first_row_pix_ptr;
          for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_intr_sht_arr_ptr^+pix_value_ptr)^:=val;
              Inc    (pt_pix_intr_sht_arr_ptr);
            end;
          Inc        (pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_ftimg_width_);
        end;
    end;
end; {$endregion}
{$endregion}

{Restore Source Image from Compressed Image------------} {$region -fold}
procedure TFastImageProc.ResNTValueArr(var arr_src:TColorArr; constref bmp_ftimg_width_:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_value_ptr          : PInteger;
  first_row_pix_ptr      : PInteger;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  nt_pix_intr_val_arr_ptr: PInteger;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (nt_pix_cnt=0) then
        Exit;
      first_row_pix_ptr      :=Unaligned(@arr_src            [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width_+bmp_src_rct_clp.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[ 000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      nt_pix_intr_val_arr_ptr:=Unaligned(@nt_pix_intr_val_arr[ 000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          pix_value_ptr:=first_row_pix_ptr;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
                     (nt_pix_intr_sht_arr_ptr^+pix_value_ptr)^:=nt_pix_intr_val_arr_ptr^;
              Inc    (nt_pix_intr_sht_arr_ptr);
              Inc    (nt_pix_intr_val_arr_ptr);
            end;
          Inc        (nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_ftimg_width_);
        end;
    end;
end; {$endregion}
{$endregion}

{Misc. Init Proc.--------------------------------------} {$region -fold}

// Check NTValueArr:
function  TFastImageProc.ChkNTValueArr: boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    Result:=({@}nt_pix_intr_val_arr{[0]}=Nil);
end; {$endregion}

// NT - not transparent pixels:
procedure TFastImageProc.SetNTNilToPtr; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TFastImageProc.SetNTCCLToPtr; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    nt_pix_intr_arr_ptr:=Unaligned(@nt_pix_intr_ccl_arr[0]);
end; {$endregion}
procedure TFastImageProc.SetNTCLLToPtr; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    nt_pix_intr_arr_ptr:=Unaligned(@nt_pix_intr_cll_arr[0]);
end; {$endregion}

// PT - partly transparent pixels:
procedure TFastImageProc.SetPTNilToPtr; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TFastImageProc.SetPTCCLToPtr; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    pt_pix_intr_arr_ptr:=Unaligned(@pt_pix_intr_ccl_arr[0]);
end; {$endregion}
procedure TFastImageProc.SetPTCLLToPtr; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    pt_pix_intr_arr_ptr:=Unaligned(@pt_pix_intr_cll_arr[0]);
end; {$endregion}

// Procedures Table Init.:
procedure TFastimageProc.FilProcInit  ; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  // NT - not transparent pixels:
  NTBeginProc[000]:=Unaligned(@SetNTNilToPtr);
  NTBeginProc[001]:=Unaligned(@SetNTCCLToPtr);
  NTBeginProc[002]:=Unaligned(@SetNTCLLToPtr);

  // PT - partly transparent pixels:
  PTBeginProc[000]:=Unaligned(@SetPTNilToPtr);
  PTBeginProc[001]:=Unaligned(@SetPTCCLToPtr);
  PTBeginProc[002]:=Unaligned(@SetPTCLLToPtr);

  // NT - not transparent pixels:

  {Empty}
  NTValueProc[009]:=Unaligned(@RegNTValue009);

  {Monochrome}
  // (constant) not clippped
  NTValueProc[000]:=Unaligned(@RegNTValue000);
  // (constant) top-bottom clippped
  NTValueProc[002]:=Unaligned(@RegNTValue002);
  // (constant) left-right-top-bottom clippped
  NTValueProc[004]:=Unaligned(@RegNTValue004);
  // (constant) image has monochrome color channel
  NTValueProc[006]:=Unaligned(@RegNTValue006);
  // (fading) not clippped
  NTValueProc[001]:=Unaligned(@RegNTValue020);
  // (fading) top-bottom clippped
  NTValueProc[003]:=Unaligned(@RegNTValue022);
  // (fading) left-right-top-bottom clippped
  NTValueProc[005]:=Unaligned(@RegNTValue024);
  // (fading) image has monochrome color channel
  NTValueProc[007]:=Unaligned(@RegNTValue026);

  {Additive}
  // (constant) not clippped
  NTValueProc[010]:=Unaligned(@RegNTValue010);
  // (constant) top-bottom clippped
  NTValueProc[012]:=Unaligned(@RegNTValue012);
  // (constant) left-right-top-bottom clippped
  NTValueProc[014]:=Unaligned(@RegNTValue014);
  // (constant) image has monochrome color channel
  NTValueProc[016]:=Unaligned(@RegNTValue016);
  // (fading) not clippped
  NTValueProc[011]:=Unaligned(@RegNTValue011);
  // (fading) top-bottom clippped
  NTValueProc[013]:=Unaligned(@RegNTValue013);
  // (fading) left-right-top-bottom clippped
  NTValueProc[015]:=Unaligned(@RegNTValue015);
  // (fading) image has monochrome color channel
  NTValueProc[017]:=Unaligned(@RegNTValue017);

  {Alphablend}
  // (constant) not clippped
  NTValueProc[020]:=Unaligned(@RegNTValue020);
  // (constant) top-bottom clippped
  NTValueProc[022]:=Unaligned(@RegNTValue022);
  // (constant) left-right-top-bottom clippped
  NTValueProc[024]:=Unaligned(@RegNTValue024);
  // (constant) image has monochrome color channel
  NTValueProc[026]:=Unaligned(@RegNTValue026);
  // (fading) not clippped
  NTValueProc[021]:=Unaligned(@RegNTValue020);
  // (fading) top-bottom clippped
  NTValueProc[023]:=Unaligned(@RegNTValue022);
  // (fading) left-right-top-bottom clippped
  NTValueProc[025]:=Unaligned(@RegNTValue024);
  // (fading) image has monochrome color channel
  NTValueProc[027]:=Unaligned(@RegNTValue026);

  {Inverse}
  // (constant) not clippped
  NTValueProc[030]:=Unaligned(@RegNTValue030);
  // (constant) top-bottom clippped
  NTValueProc[032]:=Unaligned(@RegNTValue032);
  // (constant) left-right-top-bottom clippped
  NTValueProc[034]:=Unaligned(@RegNTValue034);
  // (constant) image has monochrome color channel
  NTValueProc[036]:=Unaligned(@RegNTValue036);
  // (fading) not clippped
  NTValueProc[031]:=Unaligned(@RegNTValue031);
  // (fading) top-bottom clippped
  NTValueProc[033]:=Unaligned(@RegNTValue033);
  // (fading) left-right-top-bottom clippped
  NTValueProc[035]:=Unaligned(@RegNTValue035);
  // (fading) image has monochrome color channel
  NTValueProc[037]:=Unaligned(@RegNTValue037);

  {Highlight}
  // (constant) not clippped
  NTValueProc[040]:=Unaligned(@RegNTValue040);
  // (constant) top-bottom clippped
  NTValueProc[042]:=Unaligned(@RegNTValue042);
  // (constant) left-right-top-bottom clippped
  NTValueProc[044]:=Unaligned(@RegNTValue044);
  // (constant) image has monochrome color channel
  NTValueProc[046]:=Unaligned(@RegNTValue046);
  // (fading) not clippped
  NTValueProc[041]:=Unaligned(@RegNTValue040);
  // (fading) top-bottom clippped
  NTValueProc[043]:=Unaligned(@RegNTValue042);
  // (fading) left-right-top-bottom clippped
  NTValueProc[045]:=Unaligned(@RegNTValue044);
  // (fading) image has monochrome color channel
  NTValueProc[047]:=Unaligned(@RegNTValue046);

  {Darken}
  // (constant) not clippped
  NTValueProc[050]:=Unaligned(@RegNTValue050);
  // (constant) top-bottom clippped
  NTValueProc[052]:=Unaligned(@RegNTValue052);
  // (constant) left-right-top-bottom clippped
  NTValueProc[054]:=Unaligned(@RegNTValue054);
  // (constant) image has monochrome color channel
  NTValueProc[056]:=Unaligned(@RegNTValue056);
  // (fading) not clippped
  NTValueProc[051]:=Unaligned(@RegNTValue050);
  // (fading) top-bottom clippped
  NTValueProc[053]:=Unaligned(@RegNTValue052);
  // (fading) left-right-top-bottom clippped
  NTValueProc[055]:=Unaligned(@RegNTValue054);
  // (fading) image has monochrome color channel
  NTValueProc[057]:=Unaligned(@RegNTValue056);

  {GrayscaleR}
  // (constant) not clippped
  NTValueProc[060]:=Unaligned(@RegNTValue060);
  // (constant) top-bottom clippped
  NTValueProc[062]:=Unaligned(@RegNTValue062);
  // (constant) left-right-top-bottom clippped
  NTValueProc[064]:=Unaligned(@RegNTValue064);
  // (constant) image has monochrome color channel
  NTValueProc[066]:=Unaligned(@RegNTValue066);
  // (fading) not clippped
  NTValueProc[061]:=Unaligned(@RegNTValue061);
  // (fading) top-bottom clippped
  NTValueProc[063]:=Unaligned(@RegNTValue063);
  // (fading) left-right-top-bottom clippped
  NTValueProc[065]:=Unaligned(@RegNTValue065);
  // (fading) image has monochrome color channel
  NTValueProc[067]:=Unaligned(@RegNTValue067);

  {GrayscaleG}
  // (constant) not clippped
  NTValueProc[070]:=Unaligned(@RegNTValue070);
  // (constant) top-bottom clippped
  NTValueProc[072]:=Unaligned(@RegNTValue072);
  // (constant) left-right-top-bottom clippped
  NTValueProc[074]:=Unaligned(@RegNTValue074);
  // (constant) image has monochrome color channel
  NTValueProc[076]:=Unaligned(@RegNTValue076);
  // (fading) not clippped
  NTValueProc[071]:=Unaligned(@RegNTValue071);
  // (fading) top-bottom clippped
  NTValueProc[073]:=Unaligned(@RegNTValue073);
  // (fading) left-right-top-bottom clippped
  NTValueProc[075]:=Unaligned(@RegNTValue075);
  // (fading) image has monochrome color channel
  NTValueProc[077]:=Unaligned(@RegNTValue077);

  {GrayscaleB}
  // (constant) not clippped
  NTValueProc[080]:=Unaligned(@RegNTValue080);
  // (constant) top-bottom clippped
  NTValueProc[082]:=Unaligned(@RegNTValue082);
  // (constant) left-right-top-bottom clippped
  NTValueProc[084]:=Unaligned(@RegNTValue084);
  // (constant) image has monochrome color channel
  NTValueProc[086]:=Unaligned(@RegNTValue086);
  // (fading) not clippped
  NTValueProc[081]:=Unaligned(@RegNTValue081);
  // (fading) top-bottom clippped
  NTValueProc[083]:=Unaligned(@RegNTValue083);
  // (fading) left-right-top-bottom clippped
  NTValueProc[085]:=Unaligned(@RegNTValue085);
  // (fading) image has monochrome color channel
  NTValueProc[087]:=Unaligned(@RegNTValue087);

  {Monochrome Noise}
  // (constant) not clippped
  NTValueProc[090]:=Unaligned(@RegNTValue090);
  // (constant) top-bottom clippped
  NTValueProc[092]:=Unaligned(@RegNTValue092);
  // (constant) left-right-top-bottom clippped
  NTValueProc[094]:=Unaligned(@RegNTValue094);
  // (constant) image has monochrome color channel
  NTValueProc[096]:=Unaligned(@RegNTValue096);
  // (fading) not clippped
  NTValueProc[091]:=Unaligned(@RegNTValue091);
  // (fading) top-bottom clippped
  NTValueProc[093]:=Unaligned(@RegNTValue093);
  // (fading) left-right-top-bottom clippped
  NTValueProc[095]:=Unaligned(@RegNTValue095);
  // (fading) image has monochrome color channel
  NTValueProc[097]:=Unaligned(@RegNTValue097);

  {ColorizeR}
  // (constant) not clippped
  NTValueProc[100]:=Unaligned(@RegNTValue100);
  // (constant) top-bottom clippped
  NTValueProc[102]:=Unaligned(@RegNTValue102);
  // (constant) left-right-top-bottom clippped
  NTValueProc[104]:=Unaligned(@RegNTValue104);
  // (constant) image has monochrome color channel
  NTValueProc[106]:=Unaligned(@RegNTValue106);
  // (fading) not clippped
  NTValueProc[101]:=Unaligned(@RegNTValue100);
  // (fading) top-bottom clippped
  NTValueProc[103]:=Unaligned(@RegNTValue102);
  // (fading) left-right-top-bottom clippped
  NTValueProc[105]:=Unaligned(@RegNTValue104);
  // (fading) image has monochrome color channel
  NTValueProc[107]:=Unaligned(@RegNTValue106);

  {ColorizeG}
  // (constant) not clippped
  NTValueProc[110]:=Unaligned(@RegNTValue110);
  // (constant) top-bottom clippped
  NTValueProc[112]:=Unaligned(@RegNTValue112);
  // (constant) left-right-top-bottom clippped
  NTValueProc[114]:=Unaligned(@RegNTValue114);
  // (constant) image has monochrome color channel
  NTValueProc[116]:=Unaligned(@RegNTValue116);
  // (fading) not clippped
  NTValueProc[111]:=Unaligned(@RegNTValue110);
  // (fading) top-bottom clippped
  NTValueProc[113]:=Unaligned(@RegNTValue112);
  // (fading) left-right-top-bottom clippped
  NTValueProc[115]:=Unaligned(@RegNTValue114);
  // (fading) image has monochrome color channel
  NTValueProc[117]:=Unaligned(@RegNTValue116);

  {ColorizeB}
  // (constant) not clippped
  NTValueProc[120]:=Unaligned(@RegNTValue120);
  // (constant) top-bottom clippped
  NTValueProc[122]:=Unaligned(@RegNTValue122);
  // (constant) left-right-top-bottom clippped
  NTValueProc[124]:=Unaligned(@RegNTValue124);
  // (constant) image has monochrome color channel
  NTValueProc[126]:=Unaligned(@RegNTValue126);
  // (fading) not clippped
  NTValueProc[121]:=Unaligned(@RegNTValue120);
  // (fading) top-bottom clippped
  NTValueProc[123]:=Unaligned(@RegNTValue122);
  // (fading) left-right-top-bottom clippped
  NTValueProc[125]:=Unaligned(@RegNTValue124);
  // (fading) image has monochrome color channel
  NTValueProc[127]:=Unaligned(@RegNTValue126);

  {BlurRGB}
  // (constant) not clippped
  NTValueProc[130]:=Unaligned(@RegNTValue130);
  // (constant) top-bottom clippped
  NTValueProc[132]:=Unaligned(@RegNTValue132);
  // (constant) left-right-top-bottom clippped
  NTValueProc[134]:=Unaligned(@RegNTValue134);
  // (constant) image has monochrome color channel
  NTValueProc[136]:=Unaligned(@RegNTValue136);
  // (fading) not clippped
  NTValueProc[131]:=Unaligned(@RegNTValue131);
  // (fading) top-bottom clippped
  NTValueProc[133]:=Unaligned(@RegNTValue133);
  // (fading) left-right-top-bottom clippped
  NTValueProc[135]:=Unaligned(@RegNTValue135);
  // (fading) image has monochrome color channel
  NTValueProc[137]:=Unaligned(@RegNTValue137);

  {BlurRRB}
  // (constant) not clippped
  NTValueProc[140]:=Unaligned(@RegNTValue140);
  // (constant) top-bottom clippped
  NTValueProc[142]:=Unaligned(@RegNTValue142);
  // (constant) left-right-top-bottom clippped
  NTValueProc[144]:=Unaligned(@RegNTValue144);
  // (constant) image has monochrome color channel
  NTValueProc[146]:=Unaligned(@RegNTValue146);
  // (fading) not clippped
  NTValueProc[141]:=Unaligned(@RegNTValue141);
  // (fading) top-bottom clippped
  NTValueProc[143]:=Unaligned(@RegNTValue143);
  // (fading) left-right-top-bottom clippped
  NTValueProc[145]:=Unaligned(@RegNTValue145);
  // (fading) image has monochrome color channel
  NTValueProc[147]:=Unaligned(@RegNTValue147);

  {BlurRGR}
  // (constant) not clippped
  NTValueProc[150]:=Unaligned(@RegNTValue150);
  // (constant) top-bottom clippped
  NTValueProc[152]:=Unaligned(@RegNTValue152);
  // (constant) left-right-top-bottom clippped
  NTValueProc[154]:=Unaligned(@RegNTValue154);
  // (constant) image has monochrome color channel
  NTValueProc[156]:=Unaligned(@RegNTValue156);
  // (fading) not clippped
  NTValueProc[151]:=Unaligned(@RegNTValue151);
  // (fading) top-bottom clippped
  NTValueProc[153]:=Unaligned(@RegNTValue153);
  // (fading) left-right-top-bottom clippped
  NTValueProc[155]:=Unaligned(@RegNTValue155);
  // (fading) image has monochrome color channel
  NTValueProc[157]:=Unaligned(@RegNTValue157);

  {BlurGGB}
  // (constant) not clippped
  NTValueProc[160]:=Unaligned(@RegNTValue160);
  // (constant) top-bottom clippped
  NTValueProc[162]:=Unaligned(@RegNTValue162);
  // (constant) left-right-top-bottom clippped
  NTValueProc[164]:=Unaligned(@RegNTValue164);
  // (constant) image has monochrome color channel
  NTValueProc[166]:=Unaligned(@RegNTValue166);
  // (fading) not clippped
  NTValueProc[161]:=Unaligned(@RegNTValue161);
  // (fading) top-bottom clippped
  NTValueProc[163]:=Unaligned(@RegNTValue163);
  // (fading) left-right-top-bottom clippped
  NTValueProc[165]:=Unaligned(@RegNTValue165);
  // (fading) image has monochrome color channel
  NTValueProc[167]:=Unaligned(@RegNTValue167);

  {BlurRGG}
  // (constant) not clippped
  NTValueProc[170]:=Unaligned(@RegNTValue170);
  // (constant) top-bottom clippped
  NTValueProc[172]:=Unaligned(@RegNTValue172);
  // (constant) left-right-top-bottom clippped
  NTValueProc[174]:=Unaligned(@RegNTValue174);
  // (constant) image has monochrome color channel
  NTValueProc[176]:=Unaligned(@RegNTValue176);
  // (fading) not clippped
  NTValueProc[171]:=Unaligned(@RegNTValue171);
  // (fading) top-bottom clippped
  NTValueProc[173]:=Unaligned(@RegNTValue173);
  // (fading) left-right-top-bottom clippped
  NTValueProc[175]:=Unaligned(@RegNTValue175);
  // (fading) image has monochrome color channel
  NTValueProc[177]:=Unaligned(@RegNTValue177);

  {BlurBGB}
  // (constant) not clippped
  NTValueProc[180]:=Unaligned(@RegNTValue180);
  // (constant) top-bottom clippped
  NTValueProc[182]:=Unaligned(@RegNTValue182);
  // (constant) left-right-top-bottom clippped
  NTValueProc[184]:=Unaligned(@RegNTValue184);
  // (constant) image has monochrome color channel
  NTValueProc[186]:=Unaligned(@RegNTValue186);
  // (fading) not clippped
  NTValueProc[181]:=Unaligned(@RegNTValue181);
  // (fading) top-bottom clippped
  NTValueProc[183]:=Unaligned(@RegNTValue183);
  // (fading) left-right-top-bottom clippped
  NTValueProc[185]:=Unaligned(@RegNTValue185);
  // (fading) image has monochrome color channel
  NTValueProc[187]:=Unaligned(@RegNTValue187);

  {BlurRBB}
  // (constant) not clippped
  NTValueProc[190]:=Unaligned(@RegNTValue190);
  // (constant) top-bottom clippped
  NTValueProc[192]:=Unaligned(@RegNTValue192);
  // (constant) left-right-top-bottom clippped
  NTValueProc[194]:=Unaligned(@RegNTValue194);
  // (constant) image has monochrome color channel
  NTValueProc[196]:=Unaligned(@RegNTValue196);
  // (fading) not clippped
  NTValueProc[191]:=Unaligned(@RegNTValue191);
  // (fading) top-bottom clippped
  NTValueProc[193]:=Unaligned(@RegNTValue193);
  // (fading) left-right-top-bottom clippped
  NTValueProc[195]:=Unaligned(@RegNTValue195);
  // (fading) image has monochrome color channel
  NTValueProc[197]:=Unaligned(@RegNTValue197);

  {BlurRRR}
  // (constant) not clippped
  NTValueProc[200]:=Unaligned(@RegNTValue200);
  // (constant) top-bottom clippped
  NTValueProc[202]:=Unaligned(@RegNTValue202);
  // (constant) left-right-top-bottom clippped
  NTValueProc[204]:=Unaligned(@RegNTValue204);
  // (constant) image has monochrome color channel
  NTValueProc[206]:=Unaligned(@RegNTValue206);
  // (fading) not clippped
  NTValueProc[201]:=Unaligned(@RegNTValue201);
  // (fading) top-bottom clippped
  NTValueProc[203]:=Unaligned(@RegNTValue203);
  // (fading) left-right-top-bottom clippped
  NTValueProc[205]:=Unaligned(@RegNTValue205);
  // (fading) image has monochrome color channel
  NTValueProc[207]:=Unaligned(@RegNTValue207);

  {BlurGGG}
  // (constant) not clippped
  NTValueProc[210]:=Unaligned(@RegNTValue210);
  // (constant) top-bottom clippped
  NTValueProc[212]:=Unaligned(@RegNTValue212);
  // (constant) left-right-top-bottom clippped
  NTValueProc[214]:=Unaligned(@RegNTValue214);
  // (constant) image has monochrome color channel
  NTValueProc[216]:=Unaligned(@RegNTValue216);
  // (fading) not clippped
  NTValueProc[211]:=Unaligned(@RegNTValue211);
  // (fading) top-bottom clippped
  NTValueProc[213]:=Unaligned(@RegNTValue213);
  // (fading) left-right-top-bottom clippped
  NTValueProc[215]:=Unaligned(@RegNTValue215);
  // (fading) image has monochrome color channel
  NTValueProc[217]:=Unaligned(@RegNTValue217);

  {BlurBBB}
  // (constant) not clippped
  NTValueProc[220]:=Unaligned(@RegNTValue220);
  // (constant) top-bottom clippped
  NTValueProc[222]:=Unaligned(@RegNTValue222);
  // (constant) left-right-top-bottom clippped
  NTValueProc[224]:=Unaligned(@RegNTValue224);
  // (constant) image has monochrome color channel
  NTValueProc[226]:=Unaligned(@RegNTValue226);
  // (fading) not clippped
  NTValueProc[221]:=Unaligned(@RegNTValue221);
  // (fading) top-bottom clippped
  NTValueProc[223]:=Unaligned(@RegNTValue223);
  // (fading) left-right-top-bottom clippped
  NTValueProc[225]:=Unaligned(@RegNTValue225);
  // (fading) image has monochrome color channel
  NTValueProc[227]:=Unaligned(@RegNTValue227);

  {Contrast}
  // (constant) not clippped
  NTValueProc[230]:=Unaligned(@RegNTValue230);
  // (constant) top-bottom clippped
  NTValueProc[232]:=Unaligned(@RegNTValue232);
  // (constant) left-right-top-bottom clippped
  NTValueProc[234]:=Unaligned(@RegNTValue234);
  // (constant) image has monochrome color channel
  NTValueProc[236]:=Unaligned(@RegNTValue236);
  // (fading) not clippped
  NTValueProc[231]:=Unaligned(@RegNTValue230);
  // (fading) top-bottom clippped
  NTValueProc[233]:=Unaligned(@RegNTValue232);
  // (fading) left-right-top-bottom clippped
  NTValueProc[235]:=Unaligned(@RegNTValue234);
  // (fading) image has monochrome color channel
  NTValueProc[237]:=Unaligned(@RegNTValue236);

  {Empty}
  NTColorProc[009]:=Unaligned(@RegNTColor009);

  {Color of Curent Layer}
  // (constant) not clippped
  NTColorProc[000]:=Unaligned(@RegNTColor000);
  // (constant) top-bottom clippped
  NTColorProc[002]:=Unaligned(@RegNTColor002);
  // (constant) left-right-top-bottom clippped
  NTColorProc[004]:=Unaligned(@RegNTColor004);
  // (constant) image has monochrome color channel
  NTColorProc[006]:=Unaligned(@RegNTColor006);
  // (fading) not clippped
  NTColorProc[001]:=Unaligned(@RegNTColor020);
  // (fading) top-bottom clippped
  NTColorProc[003]:=Unaligned(@RegNTColor022);
  // (fading) left-right-top-bottom clippped
  NTColorProc[005]:=Unaligned(@RegNTColor024);
  // (fading) image has monochrome color channel
  NTColorProc[007]:=Unaligned(@RegNTColor026);

  {Color of Curent Layer(Additive)}
  // (constant) not clippped
  NTColorProc[010]:=Unaligned(@RegNTColor010);
  // (constant) top-bottom clippped
  NTColorProc[012]:=Unaligned(@RegNTColor012);
  // (constant) left-right-top-bottom clippped
  NTColorProc[014]:=Unaligned(@RegNTColor014);
  // (constant) image has monochrome color channel
  NTColorProc[016]:=Unaligned(@RegNTColor016);
  // (fading) not clippped
  NTColorProc[011]:=Unaligned(@RegNTColor011);
  // (fading) top-bottom clippped
  NTColorProc[013]:=Unaligned(@RegNTColor013);
  // (fading) left-right-top-bottom clippped
  NTColorProc[015]:=Unaligned(@RegNTColor015);
  // (fading) image has monochrome color channel
  NTColorProc[017]:=Unaligned(@RegNTColor017);

  {Color of Curent Layer(Alphablend)}
  // (constant) not clippped
  NTColorProc[020]:=Unaligned(@RegNTColor020);
  // (constant) top-bottom clippped
  NTColorProc[022]:=Unaligned(@RegNTColor022);
  // (constant) left-right-top-bottom clippped
  NTColorProc[024]:=Unaligned(@RegNTColor024);
  // (constant) image has monochrome color channel
  NTColorProc[026]:=Unaligned(@RegNTColor026);
  // (fading) not clippped
  NTColorProc[021]:=Unaligned(@RegNTColor020);
  // (fading) top-bottom clippped
  NTColorProc[023]:=Unaligned(@RegNTColor022);
  // (fading) left-right-top-bottom clippped
  NTColorProc[025]:=Unaligned(@RegNTColor024);
  // (fading) image has monochrome color channel
  NTColorProc[027]:=Unaligned(@RegNTColor026);



  // PT - partly transparent pixels:

  {Empty}
  PTValueProc[009]:=Unaligned(@RegPTValue009);

  {Monochrome}
  // (constant) not clippped
  PTValueProc[000]:=Unaligned(@RegPTValue000);
  // (constant) top-bottom clippped
  PTValueProc[002]:=Unaligned(@RegPTValue002);
  // (constant) left-right-top-bottom clippped
  PTValueProc[004]:=Unaligned(@RegPTValue004);
  // (fading) not clippped
  PTValueProc[001]:=Unaligned(@RegPTValue020);
  // (fading) top-bottom clippped
  PTValueProc[003]:=Unaligned(@RegPTValue022);
  // (fading) left-right-top-bottom clippped
  PTValueProc[005]:=Unaligned(@RegPTValue024);

  {Additive}
  // (constant) not clippped
  PTValueProc[010]:=Unaligned(@RegPTValue010);
  // (constant) top-bottom clippped
  PTValueProc[012]:=Unaligned(@RegPTValue012);
  // (constant) left-right-top-bottom clippped
  PTValueProc[014]:=Unaligned(@RegPTValue014);
  // (fading) not clippped
  PTValueProc[011]:=Unaligned(@RegPTValue011);
  // (fading) top-bottom clippped
  PTValueProc[013]:=Unaligned(@RegPTValue013);
  // (fading) left-right-top-bottom clippped
  PTValueProc[015]:=Unaligned(@RegPTValue015);

  {Alphablend}
  // (constant) not clippped
  PTValueProc[020]:=Unaligned(@RegPTValue020);
  // (constant) top-bottom clippped
  PTValueProc[022]:=Unaligned(@RegPTValue022);
  // (constant) left-right-top-bottom clippped
  PTValueProc[024]:=Unaligned(@RegPTValue024);
  // (fading) not clippped
  PTValueProc[021]:=Unaligned(@RegPTValue020);
  // (fading) top-bottom clippped
  PTValueProc[023]:=Unaligned(@RegPTValue022);
  // (fading) left-right-top-bottom clippped
  PTValueProc[025]:=Unaligned(@RegPTValue024);

  {Inverse}
  // (constant) not clippped
  PTValueProc[030]:=Unaligned(@RegPTValue030);
  // (constant) top-bottom clippped
  PTValueProc[032]:=Unaligned(@RegPTValue032);
  // (constant) left-right-top-bottom clippped
  PTValueProc[034]:=Unaligned(@RegPTValue034);
  // (fading) not clippped
  PTValueProc[031]:=Unaligned(@RegPTValue031);
  // (fading) top-bottom clippped
  PTValueProc[033]:=Unaligned(@RegPTValue033);
  // (fading) left-right-top-bottom clippped
  PTValueProc[035]:=Unaligned(@RegPTValue035);

  {Highlighted}
  // (constant) not clippped
  PTValueProc[040]:=Unaligned(@RegPTValue040);
  // (constant) top-bottom clippped
  PTValueProc[042]:=Unaligned(@RegPTValue042);
  // (constant) left-right-top-bottom clippped
  PTValueProc[044]:=Unaligned(@RegPTValue044);
  // (fading) not clippped
  PTValueProc[041]:=Unaligned(@RegPTValue040);
  // (fading) top-bottom clippped
  PTValueProc[043]:=Unaligned(@RegPTValue042);
  // (fading) left-right-top-bottom clippped
  PTValueProc[045]:=Unaligned(@RegPTValue044);

  {Darkened}
  // (constant) not clippped
  PTValueProc[050]:=Unaligned(@RegPTValue050);
  // (constant) top-bottom clippped
  PTValueProc[052]:=Unaligned(@RegPTValue052);
  // (constant) left-right-top-bottom clippped
  PTValueProc[054]:=Unaligned(@RegPTValue054);
  // (fading) not clippped
  PTValueProc[051]:=Unaligned(@RegPTValue050);
  // (fading) top-bottom clippped
  PTValueProc[053]:=Unaligned(@RegPTValue052);
  // (fading) left-right-top-bottom clippped
  PTValueProc[055]:=Unaligned(@RegPTValue054);

  {GrayscaleR}
  // (constant) not clippped
  PTValueProc[060]:=Unaligned(@RegPTValue060);
  // (constant) top-bottom clippped
  PTValueProc[062]:=Unaligned(@RegPTValue062);
  // (constant) left-right-top-bottom clippped
  PTValueProc[064]:=Unaligned(@RegPTValue064);
  // (fading) not clippped
  PTValueProc[061]:=Unaligned(@RegPTValue061);
  // (fading) top-bottom clippped
  PTValueProc[063]:=Unaligned(@RegPTValue063);
  // (fading) left-right-top-bottom clippped
  PTValueProc[065]:=Unaligned(@RegPTValue065);

  {GrayscaleG}
  // (constant) not clippped
  PTValueProc[070]:=Unaligned(@RegPTValue070);
  // (constant) top-bottom clippped
  PTValueProc[072]:=Unaligned(@RegPTValue072);
  // (constant) left-right-top-bottom clippped
  PTValueProc[074]:=Unaligned(@RegPTValue074);
  // (fading) not clippped
  PTValueProc[071]:=Unaligned(@RegPTValue071);
  // (fading) top-bottom clippped
  PTValueProc[073]:=Unaligned(@RegPTValue073);
  // (fading) left-right-top-bottom clippped
  PTValueProc[075]:=Unaligned(@RegPTValue075);

  {GrayscaleB}
  // (constant) not clippped
  PTValueProc[080]:=Unaligned(@RegPTValue080);
  // (constant) top-bottom clippped
  PTValueProc[082]:=Unaligned(@RegPTValue082);
  // (constant) left-right-top-bottom clippped
  PTValueProc[084]:=Unaligned(@RegPTValue084);
  // (fading) not clippped
  PTValueProc[081]:=Unaligned(@RegPTValue081);
  // (fading) top-bottom clippped
  PTValueProc[083]:=Unaligned(@RegPTValue083);
  // (fading) left-right-top-bottom clippped
  PTValueProc[085]:=Unaligned(@RegPTValue085);

  {Monochrome Noise}
  // (constant) not clippped
  PTValueProc[090]:=Unaligned(@RegPTValue090);
  // (constant) top-bottom clippped
  PTValueProc[092]:=Unaligned(@RegPTValue092);
  // (constant) left-right-top-bottom clippped
  PTValueProc[094]:=Unaligned(@RegPTValue094);
  // (fading) not clippped
  PTValueProc[091]:=Unaligned(@RegPTValue091);
  // (fading) top-bottom clippped
  PTValueProc[093]:=Unaligned(@RegPTValue093);
  // (fading) left-right-top-bottom clippped
  PTValueProc[095]:=Unaligned(@RegPTValue095);

  {ColorizeR}
  // (constant) not clippped
  PTValueProc[100]:=Unaligned(@RegPTValue100);
  // (constant) top-bottom clippped
  PTValueProc[102]:=Unaligned(@RegPTValue102);
  // (constant) left-right-top-bottom clippped
  PTValueProc[104]:=Unaligned(@RegPTValue104);
  // (fading) not clippped
  PTValueProc[101]:=Unaligned(@RegPTValue100);
  // (fading) top-bottom clippped
  PTValueProc[103]:=Unaligned(@RegPTValue102);
  // (fading) left-right-top-bottom clippped
  PTValueProc[105]:=Unaligned(@RegPTValue104);

  {ColorizeG}
  // (constant) not clippped
  PTValueProc[110]:=Unaligned(@RegPTValue110);
  // (constant) top-bottom clippped
  PTValueProc[112]:=Unaligned(@RegPTValue112);
  // (constant) left-right-top-bottom clippped
  PTValueProc[114]:=Unaligned(@RegPTValue114);
  // (fading) not clippped
  PTValueProc[111]:=Unaligned(@RegPTValue110);
  // (fading) top-bottom clippped
  PTValueProc[113]:=Unaligned(@RegPTValue112);
  // (fading) left-right-top-bottom clippped
  PTValueProc[115]:=Unaligned(@RegPTValue114);

  {ColorizeB}
  // (constant) not clippped
  PTValueProc[120]:=Unaligned(@RegPTValue120);
  // (constant) top-bottom clippped
  PTValueProc[122]:=Unaligned(@RegPTValue122);
  // (constant) left-right-top-bottom clippped
  PTValueProc[124]:=Unaligned(@RegPTValue124);
  // (fading) not clippped
  PTValueProc[121]:=Unaligned(@RegPTValue120);
  // (fading) top-bottom clippped
  PTValueProc[123]:=Unaligned(@RegPTValue122);
  // (fading) left-right-top-bottom clippped
  PTValueProc[125]:=Unaligned(@RegPTValue124);

  {BlurRGB}
  // (constant) not clippped
  PTValueProc[130]:=Unaligned(@RegPTValue130);
  // (constant) top-bottom clippped
  PTValueProc[132]:=Unaligned(@RegPTValue132);
  // (constant) left-right-top-bottom clippped
  PTValueProc[134]:=Unaligned(@RegPTValue134);
  // (fading) not clippped
  PTValueProc[131]:=Unaligned(@RegPTValue131);
  // (fading) top-bottom clippped
  PTValueProc[133]:=Unaligned(@RegPTValue133);
  // (fading) left-right-top-bottom clippped
  PTValueProc[135]:=Unaligned(@RegPTValue135);

  {BlurRRB}
  // (constant) not clippped
  PTValueProc[140]:=Unaligned(@RegPTValue140);
  // (constant) top-bottom clippped
  PTValueProc[142]:=Unaligned(@RegPTValue142);
  // (constant) left-right-top-bottom clippped
  PTValueProc[144]:=Unaligned(@RegPTValue144);
  // (fading) not clippped
  PTValueProc[141]:=Unaligned(@RegPTValue141);
  // (fading) top-bottom clippped
  PTValueProc[143]:=Unaligned(@RegPTValue143);
  // (fading) left-right-top-bottom clippped
  PTValueProc[145]:=Unaligned(@RegPTValue145);

  {BlurRGR}
  // (constant) not clippped
  PTValueProc[150]:=Unaligned(@RegPTValue150);
  // (constant) top-bottom clippped
  PTValueProc[152]:=Unaligned(@RegPTValue152);
  // (constant) left-right-top-bottom clippped
  PTValueProc[154]:=Unaligned(@RegPTValue154);
  // (fading) not clippped
  PTValueProc[151]:=Unaligned(@RegPTValue151);
  // (fading) top-bottom clippped
  PTValueProc[153]:=Unaligned(@RegPTValue153);
  // (fading) left-right-top-bottom clippped
  PTValueProc[155]:=Unaligned(@RegPTValue155);

  {BlurGGB}
  // (constant) not clippped
  PTValueProc[160]:=Unaligned(@RegPTValue160);
  // (constant) top-bottom clippped
  PTValueProc[162]:=Unaligned(@RegPTValue162);
  // (constant) left-right-top-bottom clippped
  PTValueProc[164]:=Unaligned(@RegPTValue164);
  // (fading) not clippped
  PTValueProc[161]:=Unaligned(@RegPTValue161);
  // (fading) top-bottom clippped
  PTValueProc[163]:=Unaligned(@RegPTValue163);
  // (fading) left-right-top-bottom clippped
  PTValueProc[165]:=Unaligned(@RegPTValue165);

  {BlurRGG}
  // (constant) not clippped
  PTValueProc[170]:=Unaligned(@RegPTValue170);
  // (constant) top-bottom clippped
  PTValueProc[172]:=Unaligned(@RegPTValue172);
  // (constant) left-right-top-bottom clippped
  PTValueProc[174]:=Unaligned(@RegPTValue174);
  // (fading) not clippped
  PTValueProc[171]:=Unaligned(@RegPTValue171);
  // (fading) top-bottom clippped
  PTValueProc[173]:=Unaligned(@RegPTValue173);
  // (fading) left-right-top-bottom clippped
  PTValueProc[175]:=Unaligned(@RegPTValue175);

  {BlurBGB}
  // (constant) not clippped
  PTValueProc[180]:=Unaligned(@RegPTValue180);
  // (constant) top-bottom clippped
  PTValueProc[182]:=Unaligned(@RegPTValue182);
  // (constant) left-right-top-bottom clippped
  PTValueProc[184]:=Unaligned(@RegPTValue184);
  // (fading) not clippped
  PTValueProc[181]:=Unaligned(@RegPTValue181);
  // (fading) top-bottom clippped
  PTValueProc[183]:=Unaligned(@RegPTValue183);
  // (fading) left-right-top-bottom clippped
  PTValueProc[185]:=Unaligned(@RegPTValue185);

  {BlurRBB}
  // (constant) not clippped
  PTValueProc[190]:=Unaligned(@RegPTValue190);
  // (constant) top-bottom clippped
  PTValueProc[192]:=Unaligned(@RegPTValue192);
  // (constant) left-right-top-bottom clippped
  PTValueProc[194]:=Unaligned(@RegPTValue194);
  // (fading) not clippped
  PTValueProc[191]:=Unaligned(@RegPTValue191);
  // (fading) top-bottom clippped
  PTValueProc[193]:=Unaligned(@RegPTValue193);
  // (fading) left-right-top-bottom clippped
  PTValueProc[195]:=Unaligned(@RegPTValue195);

  {BlurRRR}
  // (constant) not clippped
  PTValueProc[200]:=Unaligned(@RegPTValue200);
  // (constant) top-bottom clippped
  PTValueProc[202]:=Unaligned(@RegPTValue202);
  // (constant) left-right-top-bottom clippped
  PTValueProc[204]:=Unaligned(@RegPTValue204);
  // (fading) not clippped
  PTValueProc[201]:=Unaligned(@RegPTValue201);
  // (fading) top-bottom clippped
  PTValueProc[203]:=Unaligned(@RegPTValue203);
  // (fading) left-right-top-bottom clippped
  PTValueProc[205]:=Unaligned(@RegPTValue205);

  {BlurGGG}
  // (constant) not clippped
  PTValueProc[210]:=Unaligned(@RegPTValue210);
  // (constant) top-bottom clippped
  PTValueProc[212]:=Unaligned(@RegPTValue212);
  // (constant) left-right-top-bottom clippped
  PTValueProc[214]:=Unaligned(@RegPTValue214);
  // (fading) not clippped
  PTValueProc[211]:=Unaligned(@RegPTValue211);
  // (fading) top-bottom clippped
  PTValueProc[213]:=Unaligned(@RegPTValue213);
  // (fading) left-right-top-bottom clippped
  PTValueProc[215]:=Unaligned(@RegPTValue215);

  {BlurBBB}
  // (constant) not clippped
  PTValueProc[220]:=Unaligned(@RegPTValue220);
  // (constant) top-bottom clippped
  PTValueProc[222]:=Unaligned(@RegPTValue222);
  // (constant) left-right-top-bottom clippped
  PTValueProc[224]:=Unaligned(@RegPTValue224);
  // (fading) not clippped
  PTValueProc[221]:=Unaligned(@RegPTValue221);
  // (fading) top-bottom clippped
  PTValueProc[223]:=Unaligned(@RegPTValue223);
  // (fading) left-right-top-bottom clippped
  PTValueProc[225]:=Unaligned(@RegPTValue225);

  {Contrast}
  // (constant) not clippped
  PTValueProc[230]:=Unaligned(@RegPTValue230);
  // (constant) top-bottom clippped
  PTValueProc[232]:=Unaligned(@RegPTValue232);
  // (constant) left-right-top-bottom clippped
  PTValueProc[234]:=Unaligned(@RegPTValue234);
  // (fading) not clippped
  PTValueProc[231]:=Unaligned(@RegPTValue230);
  // (fading) top-bottom clippped
  PTValueProc[233]:=Unaligned(@RegPTValue232);
  // (fading) left-right-top-bottom clippped
  PTValueProc[235]:=Unaligned(@RegPTValue234);

  {Empty}
  PTColorProc[009]:=Unaligned(@RegPTColor009);

  {Color of Curent Layer}
  // (constant) not clippped
  PTColorProc[000]:=Unaligned(@RegPTColor000);
  // (constant) top-bottom clippped
  PTColorProc[002]:=Unaligned(@RegPTColor002);
  // (constant) left-right-top-bottom clippped
  PTColorProc[004]:=Unaligned(@RegPTColor004);
  // (constant) image has transparent alpha channel
  PTColorProc[006]:=Unaligned(@RegPTColor006);
  // (fading) not clippped
  PTColorProc[001]:=Unaligned(@RegPTColor020);
  // (fading) top-bottom clippped
  PTColorProc[003]:=Unaligned(@RegPTColor022);
  // (fading) left-right-top-bottom clippped
  PTColorProc[005]:=Unaligned(@RegPTColor024);
  // (fading) image has transparent alpha channel
  PTColorProc[007]:=Unaligned(@RegPTColor006);

  {Color of Curent Layer(Additive)}
  // (constant) not clippped
  PTColorProc[010]:=Unaligned(@RegPTColor010);
  // (constant) top-bottom clippped
  PTColorProc[012]:=Unaligned(@RegPTColor012);
  // (constant) left-right-top-bottom clippped
  PTColorProc[014]:=Unaligned(@RegPTColor014);
  // (constant) image has monochrome color channel
  PTColorProc[016]:=Unaligned(@RegPTColor016);
  // (fading) not clippped
  PTColorProc[011]:=Unaligned(@RegPTColor011);
  // (fading) top-bottom clippped
  PTColorProc[013]:=Unaligned(@RegPTColor013);
  // (fading) left-right-top-bottom clippped
  PTColorProc[015]:=Unaligned(@RegPTColor015);
  // (fading) image has monochrome color channel
  PTColorProc[017]:=Unaligned(@RegPTColor016);

  {Color of Curent Layer(Alphablend)}
  // (constant) not clippped
  PTColorProc[020]:=Unaligned(@RegPTColor020);
  // (constant) top-bottom clippped
  PTColorProc[022]:=Unaligned(@RegPTColor022);
  // (constant) left-right-top-bottom clippped
  PTColorProc[024]:=Unaligned(@RegPTColor024);
  // (constant) image has transparent alpha channel
  PTColorProc[026]:=Unaligned(@RegPTColor006);
  // (fading) not clippped
  PTColorProc[021]:=Unaligned(@RegPTColor020);
  // (fading) top-bottom clippped
  PTColorProc[023]:=Unaligned(@RegPTColor022);
  // (fading) left-right-top-bottom clippped
  PTColorProc[025]:=Unaligned(@RegPTColor024);
  // (fading) image has transparent alpha channel
  PTColorProc[027]:=Unaligned(@RegPTColor006);

end; {$endregion}

{$endregion}

{Tile Map Drawing--------------------------------------} {$region -fold}

// Fill Tile Map With Random Color:
procedure TFastImageProc.FilTileMap0; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst_0,rct_dst_1,rct_dst_2: TPtRect;
  bmp_bckgd_ptr2               : PInteger;
  pix_color_ptr                : PInteger;
  first_row_pix_ptr            : PInteger;
  nt_pix_intr_cnt_arr_ptr      : PInteger;
  nt_pix_intr_sht_arr_ptr      : PInteger;
  nt_pix_intr_sht_arr_ptr_mul  : integer;
  x,y,bmp_bckgd_width_mul_y    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      rct_dst_0                    :=PtBounds(bmp_ftimg_left,bmp_ftimg_top+nt_pix_arr_row_mrg_top*tilemap_sprite_w_h.y,tilemap_sprite_w_h.x,tilemap_sprite_w_h.y);
      rct_dst_1                    :=rct_dst_0;
      bmp_bckgd_width_mul_y        :=bmp_bkgnd_width*tilemap_sprite_w_h.y;
      bmp_bckgd_ptr2               :=Unaligned(@bmp_bkgnd_ptr      [000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      first_row_pix_ptr            :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top*tilemap_sprite_w_h.y+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr      :=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr      :=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          rct_dst_1    :=rct_dst_0;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              nt_pix_intr_sht_arr_ptr_mul:=nt_pix_intr_sht_arr_ptr^*tilemap_sprite_w_h.x;
              rct_dst_1.left             :=rct_dst_0.left +nt_pix_intr_sht_arr_ptr_mul;
              rct_dst_1.right            :=rct_dst_0.right+nt_pix_intr_sht_arr_ptr_mul;
              rct_dst_2                  :=ClippedRct(rct_clp_ptr^,rct_dst_1);
              PPFloodFill(bmp_bckgd_ptr2,rct_dst_2,bmp_bkgnd_width,Random($FFFFFF));
              Inc(nt_pix_intr_sht_arr_ptr);
            end;
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bckgd_width_mul_y);
          Inc(rct_dst_0.top    ,tilemap_sprite_w_h .y);
          Inc(rct_dst_0.bottom ,tilemap_sprite_w_h .y);
        end;
    end;
end; {$endregion}
// Fill Tile Map With Specified Sprite:
procedure TFastImageProc.FilTileMap1; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst_0,rct_dst_1,rct_dst_2: TPtRect;
  bmp_bckgd_ptr2               : PInteger;
  pix_color_ptr                : PInteger;
  first_row_pix_ptr            : PInteger;
  nt_pix_intr_cnt_arr_ptr      : PInteger;
  nt_pix_intr_sht_arr_ptr      : PInteger;
  nt_pix_intr_sht_arr_ptr_mul  : integer;
  i,j,bmp_bckgd_width_mul_y    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      with tilemap_sprite_w_h do
        begin
          fast_image_data_ptr0   :=fast_image_data_ptr1;
          rct_dst_0              :=PtBounds(bmp_ftimg_left,bmp_ftimg_top+nt_pix_arr_row_mrg_top*y,x,y);
          rct_dst_1              :=rct_dst_0;
          bmp_bckgd_width_mul_y  :=bmp_bkgnd_width*y;
          bmp_bckgd_ptr2         :=Unaligned(@bmp_bkgnd_ptr      [00000000000000000000000000000000000000000000000000000000000000000000000]);
          first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top*y+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
          nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+00000000000000000000000000000000000000000000000]);
          nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000000000000000000]);
          for j:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
            begin
              pix_color_ptr:=first_row_pix_ptr;
              rct_dst_1    :=rct_dst_0;
              for i:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  nt_pix_intr_sht_arr_ptr_mul:=nt_pix_intr_sht_arr_ptr^*x;
                  rct_dst_1.left             :=rct_dst_0.left +nt_pix_intr_sht_arr_ptr_mul;
                  rct_dst_1.right            :=rct_dst_0.right+nt_pix_intr_sht_arr_ptr_mul;
                  fast_image_data_ptr0       :=fast_image_data_ptr2;
                  SetRctPos(rct_dst_1.left,rct_dst_1.top);
                  SdrProc[3];
                  fast_image_data_ptr0       :=fast_image_data_ptr1;
                  Inc(nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_cnt_arr_ptr);
              Inc(first_row_pix_ptr,bmp_bckgd_width_mul_y);
              Inc(rct_dst_0.top    ,                    y);
              Inc(rct_dst_0.bottom ,                    y);
            end;
        end;
    end;
end; {$endregion}
// Fill Tile Map With Rectangles(Empty):
procedure TFastImageProc.FilTileMap2; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst_0,rct_dst_1,rct_dst_2: TPtRect;
  bmp_bckgd_ptr2               : PInteger;
  pix_color_ptr                : PInteger;
  first_row_pix_ptr            : PInteger;
  nt_pix_intr_cnt_arr_ptr      : PInteger;
  nt_pix_intr_sht_arr_ptr      : PInteger;
  nt_pix_intr_sht_arr_ptr_mul  : integer;
  x,y,bmp_bckgd_width_mul_y    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      rct_dst_0                    :=PtBounds(bmp_ftimg_left,bmp_ftimg_top+nt_pix_arr_row_mrg_top*tilemap_sprite_w_h.y,tilemap_sprite_w_h.x,tilemap_sprite_w_h.y);
      rct_dst_1                    :=rct_dst_0;
      bmp_bckgd_width_mul_y        :=bmp_bkgnd_width*tilemap_sprite_w_h.y;
      bmp_bckgd_ptr2               :=Unaligned(@bmp_bkgnd_ptr      [000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      first_row_pix_ptr            :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top*tilemap_sprite_w_h.y+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr      :=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr      :=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          rct_dst_1    :=rct_dst_0;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              nt_pix_intr_sht_arr_ptr_mul:=nt_pix_intr_sht_arr_ptr^*tilemap_sprite_w_h.x;
              rct_dst_1.left             :=rct_dst_0.left +nt_pix_intr_sht_arr_ptr_mul;
              rct_dst_1.right            :=rct_dst_0.right+nt_pix_intr_sht_arr_ptr_mul;
              rct_dst_2                  :=ClippedRct(rct_clp_ptr^,rct_dst_1);
              Rectangle
              (
                rct_dst_2.left+sln_prop_var.pts_rct_width__half-sln_prop_var.pts_rct_width__odd,
                rct_dst_2.top +sln_prop_var.pts_rct_height_half-sln_prop_var.pts_rct_height_odd,
                bmp_bckgd_ptr2,
                bmp_bkgnd_width,
                bmp_bkgnd_height,
                rct_dst_2,
                sln_prop_var);
              Inc(nt_pix_intr_sht_arr_ptr);
            end;
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bckgd_width_mul_y);
          Inc(rct_dst_0.top    ,tilemap_sprite_w_h .y);
          Inc(rct_dst_0.bottom ,tilemap_sprite_w_h .y);
        end;
    end;
end; {$endregion}
// Fill Tile Map With Rectangles(FloodFill):
procedure TFastImageProc.FilTileMap3; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst_0,rct_dst_1,rct_dst_2: TPtRect;
  bmp_bckgd_ptr2               : PInteger;
  pix_color_ptr                : PInteger;
  first_row_pix_ptr            : PInteger;
  nt_pix_intr_cnt_arr_ptr      : PInteger;
  nt_pix_intr_sht_arr_ptr      : PInteger;
  nt_pix_intr_ccl_arr_ptr      : PInteger;
  nt_pix_intr_sht_arr_ptr_mul  : integer;
  x,y,bmp_bckgd_width_mul_y    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      rct_dst_0              :=PtBounds(bmp_ftimg_left,bmp_ftimg_top+nt_pix_arr_row_mrg_top*tilemap_sprite_w_h.y,tilemap_sprite_w_h.x,tilemap_sprite_w_h.y);
      rct_dst_1              :=rct_dst_0;
      bmp_bckgd_width_mul_y  :=bmp_bkgnd_width*tilemap_sprite_w_h.y;
      bmp_bckgd_ptr2         :=Unaligned(@bmp_bkgnd_ptr      [000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      first_row_pix_ptr      :=Unaligned(@bmp_bkgnd_ptr      [(nt_pix_arr_row_mrg_top*tilemap_sprite_w_h.y+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      nt_pix_intr_ccl_arr_ptr:=Unaligned( nt_pix_intr_arr_ptr);
      for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          pix_color_ptr:=first_row_pix_ptr;
          rct_dst_1    :=rct_dst_0;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              nt_pix_intr_sht_arr_ptr_mul:=nt_pix_intr_sht_arr_ptr^*tilemap_sprite_w_h.x;
              rct_dst_1.left             :=rct_dst_0.left +nt_pix_intr_sht_arr_ptr_mul;
              rct_dst_1.right            :=rct_dst_0.right+nt_pix_intr_sht_arr_ptr_mul;
              rct_dst_2                  :=ClippedRct(rct_clp_ptr^,rct_dst_1);
              PPFloodFill(bmp_bckgd_ptr2,rct_dst_2,bmp_bkgnd_width,(nt_pix_intr_sht_arr_ptr^+pix_color_ptr)^);
              Inc(nt_pix_intr_sht_arr_ptr);
            end;
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bckgd_width_mul_y);
          Inc(rct_dst_0.top    ,tilemap_sprite_w_h .y);
          Inc(rct_dst_0.bottom ,tilemap_sprite_w_h .y);
        end;
    end;
end; {$endregion}

{$endregion}

{Full CSR-Image Drawing--------------------------------} {$region -fold}
procedure TFastimageProc.SdrAnimCng(b:boolean); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  with fast_image_data_ptr0^ do
    for i:=0 to fx_cnt-1 do
      fx_arr[i].is_fx_animate:=b;
end; {$endregion}
procedure TFastimageProc.SdrTypeCng ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      SdrAnimCng(True);
      SetSdrType;
         SdrType[sdr_type_ind];
      SdrAnimCng(False);
    end;
end; {$endregion}
procedure TFastimageProc.ShaderInfo ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin

      fx_cnt                   :=1; //must be in range of [0..255]
      pix_drw_type             :=0; //must be in range of [0..002]

      fx_arr[0].nt_pix_srf_type:=1; //must be in range of [0..002]
      fx_arr[0].nt_pix_cfx_type:=0; //must be in range of [0..002]
      fx_arr[0].nt_pix_cng_type:=0; //must be in range of [0..001]

      fx_arr[0].pt_pix_srf_type:=1; //must be in range of [0..002]
      fx_arr[0].pt_pix_cfx_type:=0; //must be in range of [0..002]
      fx_arr[0].pt_pix_cng_type:=0; //must be in range of [0..001]

      fx_arr[1].rep_cnt        :=1; //must be in range of [0..255]

      fx_arr[1].nt_pix_srf_type:=1; //must be in range of [0..001]
      fx_arr[1].nt_pix_cfx_type:=0; //must be in range of [0..255]
      fx_arr[1].nt_pix_cng_type:=0; //must be in range of [0..001]

      fx_arr[1].pt_pix_srf_type:=1; //must be in range of [0..001]
      fx_arr[1].pt_pix_cfx_type:=0; //must be in range of [0..255]
      fx_arr[1].pt_pix_cng_type:=0; //must be in range of [0..001]

      fx_arr[2].rep_cnt        :=1; //must be in range of [0..255]

      fx_arr[2].nt_pix_srf_type:=1; //must be in range of [0..001]
      fx_arr[2].nt_pix_cfx_type:=0; //must be in range of [0..255]
      fx_arr[2].nt_pix_cng_type:=0; //must be in range of [0..001]

      fx_arr[2].pt_pix_srf_type:=1; //must be in range of [0..001]
      fx_arr[2].pt_pix_cfx_type:=0; //must be in range of [0..255]
      fx_arr[2].pt_pix_cng_type:=0; //must be in range of [0..001]

      SdrTypeCng;

    end;
end; {$endregion}
procedure TFastimageProc.SetSdrType ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    sdr_type_ind:=3*img_kind+pix_drw_type;
end; {$endregion}
procedure TFastimageProc.SdrTypeInit; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType[000]:=Unaligned(@SdrType000);
  SdrType[001]:=Unaligned(@SdrType001);
  SdrType[002]:=Unaligned(@SdrType002);
  SdrType[003]:=Unaligned(@SdrType003);
  SdrType[004]:=Unaligned(@SdrType004);
  SdrType[005]:=Unaligned(@SdrType005);
  SdrType[006]:=Unaligned(@SdrType006);
  SdrType[007]:=Unaligned(@SdrType007);
  SdrType[008]:=Unaligned(@SdrType008);
  SdrType[009]:=Unaligned(@SdrType009);
  SdrType[010]:=Unaligned(@SdrType010);
  SdrType[011]:=Unaligned(@SdrType011);
  SdrType[012]:=Unaligned(@SdrType012);
  SdrType[013]:=Unaligned(@SdrType013);
  SdrType[014]:=Unaligned(@SdrType014);
  SdrType[015]:=Unaligned(@SdrType015);
  SdrType[016]:=Unaligned(@SdrType016);
  SdrType[017]:=Unaligned(@SdrType016);
  SdrType[018]:=Unaligned(@SdrType015);
  SdrType[019]:=Unaligned(@SdrType004);
  SdrType[020]:=Unaligned(@SdrType004);
  SdrType[021]:=Unaligned(@SdrType015);
  SdrType[022]:=Unaligned(@SdrType007);
  SdrType[023]:=Unaligned(@SdrType007);
  SdrType[024]:=Unaligned(@SdrType024);
  SdrType[025]:=Unaligned(@SdrType010);
  SdrType[026]:=Unaligned(@SdrType010);
  SdrType[027]:=Unaligned(@SdrType027);
  SdrType[028]:=Unaligned(@SdrType010);
  SdrType[029]:=Unaligned(@SdrType010);
  SdrType[030]:=Unaligned(@SdrType015);
  SdrType[031]:=Unaligned(@SdrType015);
  SdrType[032]:=Unaligned(@SdrType015);
  SdrType[033]:=Unaligned(@SdrType015);
  SdrType[034]:=Unaligned(@SdrType015);
  SdrType[035]:=Unaligned(@SdrType015);
  SdrType[036]:=Unaligned(@SdrType009);
  SdrType[037]:=Unaligned(@SdrType010);
  SdrType[038]:=Unaligned(@SdrType011);
end; {$endregion}
procedure TFastimageProc.SdrType000 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    with fx_arr[0] do
      begin
        if (nt_pix_srf_type<>0) then
          begin
            nt_begin_proc_ind.clip_part:=0;
            nt_color_proc_ind.clip_part:=((nt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
            if is_fx_animate then
              begin
                nt_begin_proc_ind.main_part:=((nt_pix_srf_type+0)>>0);
                nt_color_proc_ind.main_part:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
              end;
          end
        else
          begin
            nt_begin_proc_ind.clip_part:=0;
            nt_color_proc_ind.clip_part:=0;
            nt_begin_proc_ind.main_part:=0;
            nt_color_proc_ind.main_part:=9;
          end;
        if (pt_pix_srf_type<>0) then
          begin
            pt_begin_proc_ind.clip_part:=0;
            pt_color_proc_ind.clip_part:=((pt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
            if is_fx_animate then
              begin
                pt_begin_proc_ind.main_part:=((pt_pix_srf_type+0)>>0);
                pt_color_proc_ind.main_part:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
              end;
          end
        else
          begin
            pt_begin_proc_ind.clip_part:=0;
            pt_color_proc_ind.clip_part:=0;
            pt_begin_proc_ind.main_part:=0;
            pt_color_proc_ind.main_part:=9;
          end;
        fx_cnt:=1;
      end;
end; {$endregion}
procedure TFastimageProc.SdrType001 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  with fast_image_data_ptr0^ do
    begin
      with fx_arr[0] do
        begin
          nt_begin_proc_ind.clip_part:=0;
          nt_color_proc_ind.clip_part:=0;
          pt_begin_proc_ind.clip_part:=0;
          pt_color_proc_ind.clip_part:=0;
          nt_begin_proc_ind.main_part:=0;
          nt_color_proc_ind.main_part:=9;
          pt_begin_proc_ind.main_part:=0;
          pt_color_proc_ind.main_part:=9;
        end;
      for i:=1 to fx_cnt-1 do
        with fx_arr[i] do
          begin
            nt_value_proc_ind.clip_part:=((nt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
            pt_value_proc_ind.clip_part:=((pt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
            if is_fx_animate then
              begin
                nt_value_proc_ind.main_part:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
                pt_value_proc_ind.main_part:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
              end;
          end;
    end;
end; {$endregion}
procedure TFastimageProc.SdrType002 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  with fast_image_data_ptr0^ do
    begin
      with fx_arr[0] do
        begin
          if (nt_pix_srf_type<>0) then
            begin
              nt_begin_proc_ind.clip_part:=0;
              nt_color_proc_ind.clip_part:=((nt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
              if is_fx_animate then
                begin
                  nt_begin_proc_ind.main_part:=((nt_pix_srf_type+0)>>0);
                  nt_color_proc_ind.main_part:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
                end;
            end
          else
            begin
              nt_begin_proc_ind.clip_part:=0;
              nt_color_proc_ind.clip_part:=0;
              nt_begin_proc_ind.main_part:=0;
              nt_color_proc_ind.main_part:=9;
            end;
          if (pt_pix_srf_type<>0) then
            begin
              pt_begin_proc_ind.clip_part:=0;
              pt_color_proc_ind.clip_part:=((pt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
              if is_fx_animate then
                begin
                  pt_begin_proc_ind.main_part:=((pt_pix_srf_type+0)>>0);
                  pt_color_proc_ind.main_part:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
                end;
            end
          else
            begin
              pt_begin_proc_ind.clip_part:=0;
              pt_color_proc_ind.clip_part:=0;
              pt_begin_proc_ind.main_part:=0;
              pt_color_proc_ind.main_part:=9;
            end;
        end;
      for i:=1 to fx_cnt-1 do
        with fx_arr[i] do
          begin
            nt_value_proc_ind.clip_part:=((nt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
            pt_value_proc_ind.clip_part:=((pt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
            if is_fx_animate then
              begin
                nt_value_proc_ind.main_part:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
                pt_value_proc_ind.main_part:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
              end;
          end;
    end;
end; {$endregion}
procedure TFastimageProc.SdrType003 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    with fx_arr[0] do
      begin
        pt_begin_proc_ind.clip_part:=0;
        pt_color_proc_ind.clip_part:=0;
        pt_begin_proc_ind.main_part:=0;
        pt_color_proc_ind.main_part:=9;
        if (nt_pix_srf_type<>0) then
          begin
            nt_begin_proc_ind.clip_part:=0;
            nt_color_proc_ind.clip_part:=((nt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
            if is_fx_animate then
              begin
                nt_begin_proc_ind.main_part:=((nt_pix_srf_type+0)>>0);
                nt_color_proc_ind.main_part:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
              end;
          end
        else
          begin
            nt_begin_proc_ind.clip_part:=0;
            nt_color_proc_ind.clip_part:=0;
            nt_begin_proc_ind.main_part:=0;
            nt_color_proc_ind.main_part:=9;
          end;
        fx_cnt:=1;
      end;
end; {$endregion}
procedure TFastimageProc.SdrType004 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  with fast_image_data_ptr0^ do
    begin
      with fx_arr[0] do
        begin
          nt_begin_proc_ind.clip_part:=0;
          nt_color_proc_ind.clip_part:=0;
          pt_begin_proc_ind.clip_part:=0;
          pt_color_proc_ind.clip_part:=0;
          nt_begin_proc_ind.main_part:=0;
          nt_color_proc_ind.main_part:=9;
          pt_begin_proc_ind.main_part:=0;
          pt_color_proc_ind.main_part:=9;
        end;
      for i:=1 to fx_cnt-1 do
        with fx_arr[i] do
          begin
            nt_value_proc_ind.clip_part:=((nt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
            pt_value_proc_ind.clip_part:=0;
            if is_fx_animate then
              nt_value_proc_ind.main_part:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
            pt_value_proc_ind  .main_part:=9;
          end;
    end;
end; {$endregion}
procedure TFastimageProc.SdrType005 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  with fast_image_data_ptr0^ do
    begin
      with fx_arr[0] do
        begin
          pt_begin_proc_ind.clip_part:=0;
          pt_color_proc_ind.clip_part:=0;
          pt_begin_proc_ind.main_part:=0;
          pt_color_proc_ind.main_part:=9;
          if (nt_pix_srf_type<>0) then
            begin
              nt_begin_proc_ind.clip_part:=0;
              nt_color_proc_ind.clip_part:=((nt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
              if is_fx_animate then
                begin
                  nt_begin_proc_ind.main_part:=((nt_pix_srf_type+0)>>0);
                  nt_color_proc_ind.main_part:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
                end;
            end
          else
            begin
              nt_begin_proc_ind.clip_part:=0;
              nt_color_proc_ind.clip_part:=0;
              nt_begin_proc_ind.main_part:=0;
              nt_color_proc_ind.main_part:=9;
            end;
        end;
      for i:=1 to fx_cnt-1 do
        with fx_arr[i] do
          begin
            nt_value_proc_ind.clip_part:=((nt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
            pt_value_proc_ind.clip_part:=0;
            if is_fx_animate then
              nt_value_proc_ind.main_part:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
            pt_value_proc_ind  .main_part:=9;
          end;
    end;
end; {$endregion}
procedure TFastimageProc.SdrType006 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    with fx_arr[0] do
      begin
        nt_begin_proc_ind.clip_part:=0;
        nt_color_proc_ind.clip_part:=0;
        nt_begin_proc_ind.main_part:=0;
        nt_color_proc_ind.main_part:=9;
        if (pt_pix_srf_type<>0) then
          begin
            pt_begin_proc_ind.clip_part:=0;
            pt_color_proc_ind.clip_part:=((pt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
            if is_fx_animate then
              begin
                pt_begin_proc_ind.main_part:=((pt_pix_srf_type+0)>>0);
                pt_color_proc_ind.main_part:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
              end;
          end
        else
          begin
            pt_begin_proc_ind.clip_part:=0;
            pt_color_proc_ind.clip_part:=0;
            pt_begin_proc_ind.main_part:=0;
            pt_color_proc_ind.main_part:=9;
          end;
        fx_cnt:=1;
      end;
end; {$endregion}
procedure TFastimageProc.SdrType007 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  with fast_image_data_ptr0^ do
    begin
      with fx_arr[0] do
        begin
          nt_begin_proc_ind.clip_part:=0;
          nt_color_proc_ind.clip_part:=0;
          pt_begin_proc_ind.clip_part:=0;
          pt_color_proc_ind.clip_part:=0;
          nt_begin_proc_ind.main_part:=0;
          nt_color_proc_ind.main_part:=9;
          pt_begin_proc_ind.main_part:=0;
          pt_color_proc_ind.main_part:=9;
        end;
      for i:=1 to fx_cnt-1 do
        with fx_arr[i] do
          begin
            nt_value_proc_ind.clip_part:=0;
            pt_value_proc_ind.clip_part:=((pt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
            nt_value_proc_ind.main_part:=9;
            if is_fx_animate then
              pt_value_proc_ind.main_part:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
          end;
    end;
end; {$endregion}
procedure TFastimageProc.SdrType008 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  with fast_image_data_ptr0^ do
    begin
      with fx_arr[0] do
        begin
          nt_begin_proc_ind.clip_part:=0;
          nt_color_proc_ind.clip_part:=0;
          nt_begin_proc_ind.main_part:=0;
          nt_color_proc_ind.main_part:=9;
          if (pt_pix_srf_type<>0) then
            begin
              pt_begin_proc_ind.clip_part:=0;
              pt_color_proc_ind.clip_part:=((pt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
              if is_fx_animate then
                begin
                  pt_begin_proc_ind.main_part:=((pt_pix_srf_type+0)>>0);
                  pt_color_proc_ind.main_part:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
                end;
            end
          else
            begin
              pt_begin_proc_ind.clip_part:=0;
              pt_color_proc_ind.clip_part:=0;
              pt_begin_proc_ind.main_part:=0;
              pt_color_proc_ind.main_part:=9;
            end;
        end;
      for i:=1 to fx_cnt-1 do
        with fx_arr[i] do
          begin
            nt_value_proc_ind.clip_part:=0;
            pt_value_proc_ind.clip_part:=((pt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
            nt_value_proc_ind.main_part:=9;
            if is_fx_animate then
              pt_value_proc_ind.main_part:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
          end;
    end;
end; {$endregion}
procedure TFastimageProc.SdrType009 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    with fx_arr[0] do
      begin
        pix_clp_type               :=3;
        nt_begin_proc_ind.clip_part:=0;
        pt_begin_proc_ind.clip_part:=0;
        pt_color_proc_ind.clip_part:=0;
        nt_begin_proc_ind.main_part:=0;
        pt_begin_proc_ind.main_part:=0;
        pt_color_proc_ind.main_part:=9;
        if (nt_pix_srf_type<>0) then
          begin
            nt_color_proc_ind.clip_part:=((nt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
            if is_fx_animate then
              nt_color_proc_ind.main_part:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
          end
        else
          begin
            nt_color_proc_ind.clip_part:=0;
            nt_color_proc_ind.main_part:=9;
          end;
        fx_cnt:=1;
      end;
end; {$endregion}
procedure TFastimageProc.SdrType010 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  with fast_image_data_ptr0^ do
    begin
      with fx_arr[0] do
        begin
          pix_clp_type               :=3;
          nt_begin_proc_ind.clip_part:=0;
          nt_color_proc_ind.clip_part:=0;
          pt_begin_proc_ind.clip_part:=0;
          pt_color_proc_ind.clip_part:=0;
          nt_begin_proc_ind.main_part:=0;
          nt_color_proc_ind.main_part:=9;
          pt_begin_proc_ind.main_part:=0;
          pt_color_proc_ind.main_part:=9;
        end;
      for i:=1 to fx_cnt-1 do
        with fx_arr[i] do
          begin
            nt_value_proc_ind.clip_part:=((nt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
            pt_value_proc_ind.clip_part:=0;
            if is_fx_animate then
              nt_value_proc_ind.main_part:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
            pt_value_proc_ind  .main_part:=9;
          end;
    end;
end; {$endregion}
procedure TFastimageProc.SdrType011 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  with fast_image_data_ptr0^ do
    begin
      with fx_arr[0] do
        begin
          pix_clp_type               :=3;
          nt_begin_proc_ind.clip_part:=0;
          pt_begin_proc_ind.clip_part:=0;
          pt_color_proc_ind.clip_part:=0;
          nt_begin_proc_ind.main_part:=0;
          pt_begin_proc_ind.main_part:=0;
          pt_color_proc_ind.main_part:=9;
          if (nt_pix_srf_type<>0) then
            begin
              nt_color_proc_ind.clip_part:=((nt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
              if is_fx_animate then
                nt_color_proc_ind.main_part:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
            end
          else
            begin
              nt_color_proc_ind.clip_part:=0;
              nt_color_proc_ind.main_part:=9;
            end;
        end;
      for i:=1 to fx_cnt-1 do
        with fx_arr[i] do
          begin
            nt_value_proc_ind.clip_part:=((nt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
            pt_value_proc_ind.clip_part:=0;
            if is_fx_animate then
              nt_value_proc_ind.main_part:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
            pt_value_proc_ind  .main_part:=9;
          end;
    end;
end; {$endregion}
procedure TFastimageProc.SdrType012 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    with fx_arr[0] do
      begin
        pix_clp_type               :=3;
        nt_begin_proc_ind.clip_part:=0;
        nt_color_proc_ind.clip_part:=0;
        pt_begin_proc_ind.clip_part:=0;
        nt_begin_proc_ind.main_part:=0;
        nt_color_proc_ind.main_part:=9;
        pt_begin_proc_ind.main_part:=0;
        if (pt_pix_srf_type<>0) then
          begin
            pt_color_proc_ind.clip_part:=((pt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
            if is_fx_animate then
              pt_color_proc_ind.main_part:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
          end
        else
          begin
            pt_color_proc_ind.clip_part:=0;
            pt_color_proc_ind.main_part:=9;
          end;
        fx_cnt:=1;
      end;
end; {$endregion}
procedure TFastimageProc.SdrType013 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  with fast_image_data_ptr0^ do
    begin
      with fx_arr[0] do
        begin
          pix_clp_type               :=3;
          nt_begin_proc_ind.clip_part:=0;
          nt_color_proc_ind.clip_part:=0;
          pt_begin_proc_ind.clip_part:=0;
          pt_color_proc_ind.clip_part:=0;
          nt_begin_proc_ind.main_part:=0;
          nt_color_proc_ind.main_part:=9;
          pt_begin_proc_ind.main_part:=0;
          pt_color_proc_ind.main_part:=9;
        end;
      for i:=1 to fx_cnt-1 do
        with fx_arr[i] do
          begin
            nt_value_proc_ind.clip_part:=((nt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
            pt_value_proc_ind.clip_part:=0;
            if is_fx_animate then
              nt_value_proc_ind.main_part:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
            pt_value_proc_ind  .main_part:=9;
          end;
    end;
end; {$endregion}
procedure TFastimageProc.SdrType014 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  with fast_image_data_ptr0^ do
    begin
      with fx_arr[0] do
        begin
          pix_clp_type               :=3;
          nt_begin_proc_ind.clip_part:=0;
          nt_color_proc_ind.clip_part:=0;
          pt_begin_proc_ind.clip_part:=0;
          nt_begin_proc_ind.main_part:=0;
          nt_color_proc_ind.main_part:=9;
          pt_begin_proc_ind.main_part:=0;
          if (pt_pix_srf_type<>0) then
            begin
              pt_color_proc_ind.clip_part:=((pt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
              if is_fx_animate then
                pt_color_proc_ind.main_part:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
            end
          else
            begin
              pt_color_proc_ind.clip_part:=0;
              pt_color_proc_ind.main_part:=9;
            end;
        end;
      for i:=1 to fx_cnt-1 do
        with fx_arr[i] do
          begin
            nt_value_proc_ind.clip_part:=((nt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
            pt_value_proc_ind.clip_part:=0;
            if is_fx_animate then
              nt_value_proc_ind.main_part:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
            pt_value_proc_ind  .main_part:=9;
          end;
    end;
end; {$endregion}
procedure TFastimageProc.SdrType015 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    with fx_arr[0] do
      begin
        nt_begin_proc_ind.clip_part:=0;
        nt_color_proc_ind.clip_part:=0;
        pt_begin_proc_ind.clip_part:=0;
        pt_color_proc_ind.clip_part:=0;
        nt_begin_proc_ind.main_part:=0;
        nt_color_proc_ind.main_part:=9;
        pt_begin_proc_ind.main_part:=0;
        pt_color_proc_ind.main_part:=9;
        fx_cnt                     :=1;
      end;
end; {$endregion}
procedure TFastimageProc.SdrType016 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  with fast_image_data_ptr0^ do
    begin
      with fx_arr[0] do
        begin
          nt_begin_proc_ind.clip_part:=0;
          nt_color_proc_ind.clip_part:=0;
          pt_begin_proc_ind.clip_part:=0;
          pt_color_proc_ind.clip_part:=0;
          nt_begin_proc_ind.main_part:=0;
          nt_color_proc_ind.main_part:=9;
          pt_begin_proc_ind.main_part:=0;
          pt_color_proc_ind.main_part:=9;
        end;
      for i:=1 to fx_cnt-1 do
        with fx_arr[i] do
          begin
            nt_value_proc_ind.clip_part:=((nt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
            pt_value_proc_ind.clip_part:=((pt_pix_srf_type+1)>>1)*(pix_clp_type<<1);
            if is_fx_animate then
              begin
                nt_value_proc_ind.main_part:=((nt_pix_srf_type+1)>>1)*(10*nt_pix_cfx_type+nt_pix_cng_type)+(1-(nt_pix_srf_type+1)>>1)*9;
                pt_value_proc_ind.main_part:=((pt_pix_srf_type+1)>>1)*(10*pt_pix_cfx_type+pt_pix_cng_type)+(1-(pt_pix_srf_type+1)>>1)*9;
              end;
          end;
    end;
end; {$endregion}
procedure TFastimageProc.SdrType017 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType016;
end; {$endregion}
procedure TFastimageProc.SdrType018 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType015;
end; {$endregion}
procedure TFastimageProc.SdrType019 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType004;
end; {$endregion}
procedure TFastimageProc.SdrType020 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType004;
end; {$endregion}
procedure TFastimageProc.SdrType021 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType015;
end; {$endregion}
procedure TFastimageProc.SdrType022 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType007;
end; {$endregion}
procedure TFastimageProc.SdrType023 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType007;
end; {$endregion}
procedure TFastimageProc.SdrType024 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  fast_image_data_ptr0^.pix_clp_type:=3;
  SdrType015;
end; {$endregion}
procedure TFastimageProc.SdrType025 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType010;
end; {$endregion}
procedure TFastimageProc.SdrType026 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType010;
end; {$endregion}
procedure TFastimageProc.SdrType027 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  fast_image_data_ptr0^.pix_clp_type:=3;
  SdrType015;
end; {$endregion}
procedure TFastimageProc.SdrType028 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType010;
end; {$endregion}
procedure TFastimageProc.SdrType029 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType010;
end; {$endregion}
procedure TFastimageProc.SdrType030 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType015;
end; {$endregion}
procedure TFastimageProc.SdrType031 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {empty}
end; {$endregion}
procedure TFastimageProc.ShaderType ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin

  {Image Description} {$region -fold}
  {
    ----------------Image Has Alpha Channel And Color Channel---------------
    0:
    image has:  not monochrome alpha channel,
                not monochrome color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels>0;

    1:
    image has:  not monochrome alpha channel,
                not monochrome color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;

    2:
    image has:  not monochrome alpha channel,
                not monochrome color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels>0;

    3:
    image has:      monochrome alpha channel(white, not transparent),
                not monochrome color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;

    4:
    image has:      monochrome alpha channel(transparent),
                not monochrome color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels>0;


    ----------------------Image Has Only Alpha Channel----------------------
    5:
    image has:  not monochrome alpha channel,
                            no color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels>0;

    6:
    image has:  not monochrome alpha channel,
                            no color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;

    7:
    image has:  not monochrome alpha channel,
                            no color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels>0;

    8:
    image has:      monochrome alpha channel(white, not transparent),
                            no color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;

    9:
    image has:      monochrome alpha channel(transparent),
                            no color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels>0;


    --------------Image Has No Alpha Channel And Color Channel--------------
    10:
    image has:      no alpha channel(black, invisible),
                    no color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels=0;

    --------------------------Image is Value Array--------------------------
    11:
    count of    not transparent pixels>0;
    count of partly transparent pixels>0;

    --------------------------Image is Mask--------------------------
    12:
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;
  } {$endregion}

  with fast_image_data_ptr0^ do
    case sdr_type_ind of
      000: SdrType000;
      001: SdrType001;
      002: SdrType002;
      003: SdrType003;
      004: SdrType004;
      005: SdrType005;
      006: SdrType006;
      007: SdrType007;
      008: SdrType008;
      009: SdrType009;
      010: SdrType010;
      011: SdrType011;
      012: SdrType012;
      013: SdrType013;
      014: SdrType014;
      015: SdrType015;
      016: SdrType016;
      017: SdrType017;
      018: SdrType018;
      019: SdrType019;
      020: SdrType020;
      021: SdrType021;
      022: SdrType022;
      023: SdrType023;
      024: SdrType024;
      025: SdrType025;
      026: SdrType026;
      027: SdrType027;
      028: SdrType028;
      029: SdrType029;
      030: SdrType030;
      031: SdrType030;
      032: SdrType030;
      033: SdrType030;
      034: SdrType030;
      035: SdrType030;
      036: SdrType009;
      037: SdrType010;
      038: SdrType011;
    end;

end; {$endregion}
procedure TFastimageProc.SdrProcInit; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrProc[0]:=@UberShader0;
  SdrProc[1]:=@UberShader1;
  SdrProc[2]:=@UberShader2;
  SdrProc[3]:=@UberShader3;
end; {$endregion}
procedure TFastimageProc.UberShader0; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TFastimageProc.UberShader1; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  fx_arr_ptr: PFX;
  i,j       : shortint;
begin

  with fast_image_data_ptr0^ do
    begin

      {Sprite Bounding Rectangles}
      SetRctDst;
      if (pix_clp_type=3) then
        Exit;
      SetRctSrc;

      {Sprite Shader Type}
      SetSdrType;
         SdrType[sdr_type_ind]; {ShaderType;}

      {Sprite Drawing}
      cfx_pow0:=(fx_arr[0].cfx_pow0);
      cfx_pow1:=(fx_arr[0].cfx_pow1);
      if (cfx_pow0<>0) then
        begin
          pt_as_nt:= (fx_arr[0].pt_as_nt);
          NTBeginProc[fx_arr[0].nt_begin_proc_ind.main_part+fx_arr[0].nt_begin_proc_ind.clip_part];
          NTColorProc[fx_arr[0].nt_color_proc_ind.main_part+fx_arr[0].nt_color_proc_ind.clip_part];
        end;

      {Sprite Post-Processing}
      fx_arr_ptr:=Unaligned(@fx_arr[1]);
      for i:=1 to fx_cnt-1 do
        begin
          for j:=0 to     fx_arr_ptr^.rep_cnt-1 do
            begin
              cfx_pow0:= (fx_arr_ptr^.cfx_pow0);
              cfx_pow1:= (fx_arr_ptr^.cfx_pow1);
              pt_as_nt:= (fx_arr_ptr^.pt_as_nt);
              if (cfx_pow0=0) then
                Continue;
              NTValueProc[fx_arr_ptr^.nt_value_proc_ind.main_part+fx_arr_ptr^.nt_value_proc_ind.clip_part];
            end;
          Inc            (fx_arr_ptr);
        end;

    end;

end; {$endregion}
procedure TFastimageProc.UberShader2; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  fx_arr_ptr: PFX;
  i,j       : shortint;
begin

  with fast_image_data_ptr0^ do
    begin

      {Sprite Bounding Rectangles}
      SetRctDst;
      if (pix_clp_type=3) then
        Exit;
      SetRctSrc;

      {Sprite Shader Type}
      SetSdrType;
         SdrType[sdr_type_ind]; {ShaderType;}

      {Sprite Drawing}
      cfx_pow0:=(fx_arr[0].cfx_pow0);
      cfx_pow1:=(fx_arr[0].cfx_pow1);
      if (cfx_pow0<>0) then
        begin
          pt_as_nt:= (fx_arr[0].pt_as_nt);
          PTBeginProc[fx_arr[0].pt_begin_proc_ind.main_part+fx_arr[0].pt_begin_proc_ind.clip_part];
          PTColorProc[fx_arr[0].pt_color_proc_ind.main_part+fx_arr[0].pt_color_proc_ind.clip_part];
        end;

      {Sprite Post-Processing}
      fx_arr_ptr:=Unaligned(@fx_arr[1]);
      for i:=1 to fx_cnt-1 do
        begin
          for j:=0 to     fx_arr_ptr^.rep_cnt-1 do
            begin
              cfx_pow0:= (fx_arr_ptr^.cfx_pow0);
              cfx_pow1:= (fx_arr_ptr^.cfx_pow1);
              pt_as_nt:= (fx_arr_ptr^.pt_as_nt);
              if (cfx_pow0=0) then
                Continue;
              PTValueProc[fx_arr_ptr^.pt_value_proc_ind.main_part+fx_arr_ptr^.pt_value_proc_ind.clip_part];
            end;
          Inc            (fx_arr_ptr);
        end;

    end;

end; {$endregion}
procedure TFastimageProc.UberShader3; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  fx_arr_ptr: PFX;
  i,j       : shortint;
begin

  with fast_image_data_ptr0^ do
    begin

      {Sprite Bounding Rectangles}
      SetRctDst;
      if (pix_clp_type=3) then
        Exit;
      SetRctSrc;

      {Sprite Shader Type}
      SetSdrType;
         SdrType[sdr_type_ind]; {ShaderType;}

      {Sprite Drawing}
      cfx_pow0:=(fx_arr[0].cfx_pow0);
      cfx_pow1:=(fx_arr[0].cfx_pow1);
      if (cfx_pow0<>0) then
        begin
          pt_as_nt:= (fx_arr[0].pt_as_nt);
          NTBeginProc[fx_arr[0].nt_begin_proc_ind.main_part+fx_arr[0].nt_begin_proc_ind.clip_part];
          NTColorProc[fx_arr[0].nt_color_proc_ind.main_part+fx_arr[0].nt_color_proc_ind.clip_part];
          PTBeginProc[fx_arr[0].pt_begin_proc_ind.main_part+fx_arr[0].pt_begin_proc_ind.clip_part];
          PTColorProc[fx_arr[0].pt_color_proc_ind.main_part+fx_arr[0].pt_color_proc_ind.clip_part];
        end;

      {Sprite Post-Processing}
      fx_arr_ptr:=Unaligned(@fx_arr[1]);
      for i:=1 to fx_cnt-1 do
        begin
          for j:=0 to     fx_arr_ptr^.rep_cnt-1 do
            begin
              cfx_pow0:= (fx_arr_ptr^.cfx_pow0);
              cfx_pow1:= (fx_arr_ptr^.cfx_pow1);
              pt_as_nt:= (fx_arr_ptr^.pt_as_nt);
              if (cfx_pow0=0) then
                Continue;
              NTValueProc[fx_arr_ptr^.nt_value_proc_ind.main_part+fx_arr_ptr^.nt_value_proc_ind.clip_part];
              PTValueProc[fx_arr_ptr^.pt_value_proc_ind.main_part+fx_arr_ptr^.pt_value_proc_ind.clip_part];
            end;
          Inc            (fx_arr_ptr);
        end;

    end;

end; {$endregion}

// Clear Background from Image:
procedure TFastimageProc.ClrBkgnd;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  NTBeginProc[2];
  NTColorProc[0];
end; {$endregion}

{$endregion}

{$endregion}

{CSR-Image Anti-Aliasing-------------------------------} {$region -fold}
procedure TFastImageProc.CrtBorderBmp(constref arr_src:TColorArr; var arr_dst:TObjSelArr;                         constref arr_src_width,arr_dst_width:TColor; constref rect_left,rect_top,rect_width,rect_height:TColor; var brdr_pix_cnt:TColor; constref obj_kind,obj_id:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr      : PInteger;
  arr_dst_ptr      : PObjSel;
  d_width1,d_width2: integer;
  x_,y_            : integer;
begin
  brdr_pix_cnt     :=0;
  d_width1         :=                   arr_src_width- rect_width;
  d_width2         :=                   arr_dst_width- rect_width;
  arr_src_ptr      :=@arr_src[rect_left+arr_src_width*(rect_top+1)];
  arr_dst_ptr      :=@arr_dst[rect_left+arr_dst_width*(rect_top+1)];
  for y_:=0 to rect_height-3 do
    begin
      for x_:=0 to rect_width-1 do
        begin
          if (arr_src_ptr^<>0) then
            begin
              if ((arr_src_ptr-arr_src_width)^=0) then
                if ((arr_dst_ptr-arr_dst_width)^.obj_kind<>obj_kind) then
                  begin
                    (arr_dst_ptr-arr_dst_width)^.obj_kind:=obj_kind;
                    (arr_dst_ptr-arr_dst_width)^.obj_id  :=obj_id  ;
                    Inc(brdr_pix_cnt);
                  end;
              if ((arr_src_ptr+arr_src_width)^=0) then
                if ((arr_dst_ptr+arr_dst_width)^.obj_kind<>obj_kind) then
                  begin
                    (arr_dst_ptr+arr_dst_width)^.obj_kind:=obj_kind;
                    (arr_dst_ptr+arr_dst_width)^.obj_id  :=obj_id  ;
                    Inc(brdr_pix_cnt);
                  end;
            end;
          Inc(arr_src_ptr);
          Inc(arr_dst_ptr);
        end;
      Inc(arr_src_ptr,d_width1);
      Inc(arr_dst_ptr,d_width2);
    end;
end; {$endregion}
procedure TFastImageProc.BorderCalc1 (constref arr_src:TColorArr; var arr_dst:T1Byte1Arr;                         constref arr_src_width,arr_dst_width:TColor; constref rct_dst_:TPtRect                                                                                          ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  first_row_pix_ptr1     : PInteger;
  first_row_pix_ptr2     : PByte;
  nt_pix_intr_cnt_arr_ptr: PInteger;
  nt_pix_intr_sht_arr_ptr: PInteger;
  arr_src_ptr1           : PInteger;
  arr_dst_ptr1           : PByte;
  arr_src_ptr2           : PInteger;
  arr_dst_ptr2           : PByte;
  x,y                    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (nt_pix_cnt=0) or (rct_dst_.height<3) then
        Exit;
      first_row_pix_ptr1     :=Unaligned(@arr_src            [(nt_pix_arr_row_mrg_top+rct_dst_.top)*arr_src_width+rct_dst_.left]);
      first_row_pix_ptr2     :=Unaligned(@arr_dst            [(nt_pix_arr_row_mrg_top+rct_dst_.top)*arr_dst_width+rct_dst_.left]);
      nt_pix_intr_cnt_arr_ptr:=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+00000000000000000000000000000000000000000]);
      nt_pix_intr_sht_arr_ptr:=Unaligned(@nt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to rct_dst_.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          arr_src_ptr1:=first_row_pix_ptr1;
          arr_dst_ptr1:=first_row_pix_ptr2;
          for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
            begin
              arr_src_ptr2:=nt_pix_intr_sht_arr_ptr^+arr_src_ptr1;
              arr_dst_ptr2:=nt_pix_intr_sht_arr_ptr^+arr_dst_ptr1;
              if (arr_src_ptr2^<>0) then
                begin
                  if ((arr_src_ptr2-arr_src_width)^ =0) then
                      (arr_dst_ptr2-arr_dst_width)^:=1;
                  if ((arr_src_ptr2+arr_src_width)^ =0) then
                      (arr_dst_ptr2+arr_dst_width)^:=1;
                  if ((arr_src_ptr2-0000000000001)^ =0) then
                      (arr_dst_ptr2-0000000000001)^:=1;
                  if ((arr_src_ptr2+0000000000001)^ =0) then
                      (arr_dst_ptr2+0000000000001)^:=1;
                end;
              Inc(nt_pix_intr_sht_arr_ptr);
            end;
          Inc(nt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr1,arr_src_width);
          Inc(first_row_pix_ptr2,arr_dst_width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.BorderCalc2 (constref arr_src:TColorArr; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; constref arr_src_width,arr_dst_width:TColor; constref rct_dst_:TPtRect; out line_cnt:TColor                                                                     ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  first_row_pix_ptr1     : PInteger;
  first_row_pix_ptr2     : PByte;
  pt_pix_intr_cnt_dec    : integer;
  pt_pix_intr_cnt_arr_ptr: PInteger;
  pt_pix_intr_sht_arr_ptr: PInteger;
  arr_src_ptr2           : PInteger;
  arr_dst_ptr2           : PByte;
  line_kind_arr          : array[0..7] of boolean;
  line_kind              : qword absolute line_kind_arr;
  arr_alpha_ptr          : PFastAALine;
  arr_dst_left_ptr       : PByte;
  arr_dst_right_ptr      : PByte;
  line_first_pt_ptr      : PByte;
  y_,x_,i,d0,d1,d2       : integer;
  a,b,c,d                : boolean;
label
  label1,label2;
begin
  with fast_image_data_ptr0^ do
    begin
      if (pt_pix_cnt=0) or (rct_dst_.height<3) then
        Exit;
      d0                     :=                               (pt_pix_arr_row_mrg_top+rct_dst_.top)*arr_src_width;
      first_row_pix_ptr1     :=Unaligned(@arr_src            [(pt_pix_arr_row_mrg_top+rct_dst_.top)*arr_src_width+rct_dst_.left]);
      first_row_pix_ptr2     :=Unaligned(@arr_dst            [(pt_pix_arr_row_mrg_top+rct_dst_.top)*arr_dst_width+rct_dst_.left]);
      arr_dst_left_ptr       :=Unaligned(@arr_dst            [(pt_pix_arr_row_mrg_top+rct_dst_.top)*arr_dst_width+rct_dst_.left]);
      pt_pix_intr_cnt_arr_ptr:=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+00000000000000000000000000000000000000000]);
      pt_pix_intr_sht_arr_ptr:=Unaligned(@pt_pix_intr_sht_arr[00000000000000000000000000000000000000000000000000000000000000000]);
      arr_alpha_ptr          :=Unaligned(@arr_alpha          [00000000000000000000000000000000000000000000000000000000000000000]);
      for y_:=0 to 6{rct_dst_.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1} do
        begin
          arr_dst_right_ptr  :=arr_dst_left_ptr+rct_dst_.left+rct_dst_.width-1;
          pt_pix_intr_cnt_dec:=pt_pix_intr_cnt_arr_ptr^-1;
          for x_:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
            begin
              if (pt_pix_intr_cnt_dec=0) then
                begin
                  Inc(pt_pix_intr_sht_arr_ptr);
                  goto label1;
                end;
              arr_src_ptr2:=pt_pix_intr_sht_arr_ptr^+first_row_pix_ptr1;
              arr_dst_ptr2:=pt_pix_intr_sht_arr_ptr^+first_row_pix_ptr2;
              if (arr_dst_ptr2^=1) then                                                          //  -01234----5678
                begin                                                                            //  01234500006789
                  {Fill Horizontal Line} {$region -fold}                                         //   87654    3210
                  if ((arr_dst_ptr2+1)^=1) then
                    begin
                      line_first_pt_ptr:=arr_dst_ptr2;
                      while (arr_dst_ptr2^=1) and (pt_pix_intr_cnt_dec<>0) do
                        begin
                          arr_dst_ptr2^:=2;
                          Inc(arr_dst_ptr2);

                          Dec(pt_pix_intr_cnt_dec);
                        end;
                      if (pt_pix_intr_cnt_dec=0) then
                        begin
                          arr_dst_ptr2^:=2;
                        end;
                      //Dec(pt_pix_intr_sht_arr_ptr);
                      {arr_alpha_ptr^.line_shift:=arr_dst_ptr2-line_first_pt_ptr;
                      d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                      d2                       :=arr_dst_ptr2     -arr_dst_left_ptr+d0;
                      line_kind_arr[3]         :=((arr_src_ptr2+d1-1)^<>0);
                      line_kind_arr[4]         :=((arr_src_ptr2+d2  )^<>0);
                      {line_kind=2----} {$region -fold}
                      if (line_kind_arr[3] and line_kind_arr[4]) then
                        begin
                          arr_alpha_ptr^.line_kind :=2;
                          arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                          arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                          Inc(arr_alpha_ptr);
                        end {$endregion}
                      else
                      {line_kind=0,1,3} {$region -fold}
                        begin
                          line_kind_arr[0]:=((arr_src_ptr2+d1-1-arr_src_width)^<>0);
                          line_kind_arr[1]:=((arr_src_ptr2+d1  -arr_src_width)^<>0);
                          line_kind_arr[2]:=((arr_src_ptr2+d2  -arr_src_width)^<>0);
                          line_kind_arr[5]:=((arr_src_ptr2+d1-1+arr_src_width)^<>0);
                          line_kind_arr[6]:=((arr_src_ptr2+d1  +arr_src_width)^<>0);
                          line_kind_arr[7]:=((arr_src_ptr2+d2  +arr_src_width)^<>0);
                          case line_kind of
                            {line_kind=0} {$region -fold}
                            {can be rolled to line_kind=1}
                            {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                            {00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001,
                            {00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000,
                            {00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000,
                            {00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001,
                            {00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000,
                            {00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001,
                            {01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000,
                            {01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001,
                            {01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001,
                            {01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000,
                            {01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000,
                            {01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001,
                            {01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000,
                            {01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001,
                            {01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000,
                            {11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000,
                            {10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000,
                            {11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000,
                            {10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001:
                              begin
                                arr_alpha_ptr^.line_kind :=0;
                                arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                                arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                                Inc(arr_alpha_ptr);
                              end; {$endregion}
                            {line_kind=1} {$region -fold}
                            {can be rolled to line_kind=0}
                            {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                            {11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000,
                            {01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000,
                            {01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000,
                            {11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000,
                            {01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000,
                            {11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000,
                            {01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000,
                            {11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000,
                            {10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000,
                            {00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000,
                            {00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000,
                            {10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000,
                            {00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000,
                            {10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000,
                            {01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000,
                            {00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001,
                            {01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001,
                            {00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001,
                            {11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001:
                              begin
                                arr_alpha_ptr^.line_kind :=1;
                                arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                                arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                                Inc(arr_alpha_ptr);
                              end; {$endregion}
                            {line_kind=3} {$region -fold}
                            {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                            {00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000:
                            if ((arr_src_ptr2+d2-arr_src_width-1)^<>0) then
                              begin
                                arr_alpha_ptr^.line_kind :=3;
                                arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                                arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                                Inc(arr_alpha_ptr);
                              end;
                            {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                            {01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000:
                            if ((arr_src_ptr2+d2+arr_src_width-1)^<>0) then
                              begin
                                arr_alpha_ptr^.line_kind :=3;
                                arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                                arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                                Inc(arr_alpha_ptr);
                              end; {$endregion}
                          end;
                        end; {$endregion}
                    }end; {$endregion}
                  {
                  {Fill Vertical Line--} {$region -fold}
                  else
                  if ((arr_dst_ptr2+arr_dst_width)^=1) then
                    begin
                      line_first_pt_ptr:=arr_dst_ptr2;
                      while (arr_dst_ptr2^=1) do
                        begin
                          arr_dst_ptr2^:=2;
                          Inc(arr_dst_ptr2,arr_dst_width);
                        end;
                      arr_alpha_ptr^.line_shift:=Trunc((arr_dst_ptr2-line_first_pt_ptr)/arr_dst_width);
                      Dec(arr_dst_ptr2,arr_dst_ptr2-line_first_pt_ptr);
                      d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                      d2                       :=d1+arr_src_width *arr_alpha_ptr^.line_shift;
                      line_kind_arr[3]         :=((arr_src_ptr2+d1-arr_src_width)^<>0);
                      line_kind_arr[4]         :=((arr_src_ptr2+d2              )^<>0);
                      {line_kind=7----} {$region -fold}
                      if (line_kind_arr[3] and line_kind_arr[4]) then
                        begin
                          arr_alpha_ptr^.line_kind :=7;
                          arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                          arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                          Inc(arr_alpha_ptr);
                        end {$endregion}
                      else
                      {line_kind=5,6,8} {$region -fold}
                        begin
                          line_kind_arr[0]:=((arr_src_ptr2+d1+1-arr_src_width)^<>0);
                          line_kind_arr[1]:=((arr_src_ptr2+d1+1              )^<>0);
                          line_kind_arr[2]:=((arr_src_ptr2+d2+1              )^<>0);
                          line_kind_arr[5]:=((arr_src_ptr2+d1-1-arr_src_width)^<>0);
                          line_kind_arr[6]:=((arr_src_ptr2+d1-1              )^<>0);
                          line_kind_arr[7]:=((arr_src_ptr2+d2-1              )^<>0);
                          case line_kind of
                            {line_kind=5} {$region -fold}
                            {can be rolled to line_kind=6}
                            {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                            {00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001,
                            {00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000,
                            {00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000,
                            {00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001,
                            {00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000,
                            {00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001,
                            {01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000,
                            {01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001,
                            {01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001,
                            {01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000,
                            {01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000,
                            {01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001,
                            {01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000,
                            {01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001,
                            {01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000,
                            {11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000,
                            {10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000,
                            {11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000,
                            {10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001:
                              begin
                                arr_alpha_ptr^.line_kind :=5;
                                arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                                arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                                Inc(arr_alpha_ptr);
                              end; {$endregion}
                            {line_kind=6} {$region -fold}
                            {can be rolled to line_kind=5}
                            {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                            {11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000,
                            {01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000,
                            {01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000,
                            {11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000,
                            {01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000,
                            {11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000,
                            {01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000,
                            {11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000,
                            {10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000,
                            {00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000,
                            {00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000,
                            {10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000,
                            {00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000,
                            {10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000,
                            {01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000,
                            {00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001,
                            {01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001,
                            {00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001,
                            {11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001:
                              begin
                                arr_alpha_ptr^.line_kind :=6;
                                arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                                arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                                Inc(arr_alpha_ptr);
                              end; {$endregion}
                            {line_kind=8} {$region -fold}
                            {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                            {00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000:
                            if ((arr_src_ptr2+d2+1)^<>0) then
                              begin
                                arr_alpha_ptr^.line_kind :=8;
                                arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                                arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                                Inc(arr_alpha_ptr);
                              end;
                            {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                            {01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000:
                            if ((arr_src_ptr2+d2-1-arr_src_width)^<>0) then
                              begin
                                arr_alpha_ptr^.line_kind :=8;
                                arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                                arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                                Inc(arr_alpha_ptr);
                              end; {$endregion}
                          end;
                        end; {$endregion}
                    end {$endregion}
                  }
                  {
                  {Fill One Pixel------} {$region -fold}
                  else
                    begin
                      if (PInteger(pt_pix_intr_cnt_arr_ptr)-PInteger(@pt_pix_intr_cnt_arr[0])=0) then
                        a:=True
                      else
                        a:=((arr_dst_ptr2-arr_dst_width)^<>1);

                      if (arr_dst_ptr2=arr_dst_left_ptr) then
                        b:=True
                      else
                        b:=((arr_dst_ptr2-1)^<>1);

                      if (PInteger(pt_pix_intr_cnt_arr_ptr)-PInteger(@pt_pix_intr_cnt_arr[0])=rct_dst_.height) then
                        c:=True
                      else
                        c:=((arr_dst_ptr2+arr_dst_width)^<>1);

                      if (arr_dst_ptr2=arr_dst_right_ptr) then
                        d:=True
                      else
                        d:=((arr_dst_ptr2+1)^<>1);

                      if (a and b) or (c and d) then
                        begin
                          arr_dst_ptr2^             :=2;
                          arr_alpha_ptr^.line_kind :=10;
                          arr_alpha_ptr^.first_pt_x:=arr_dst_ptr2-arr_dst_left_ptr;
                          arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                          Inc(arr_alpha_ptr);
                        end;
                    end; {$endregion}
                  }
                  //goto label2;
                end;
              //Inc(pt_pix_intr_sht_arr_ptr);
              //label2:
            end;
          label1:
          //Inc(pt_pix_intr_sht_arr_ptr);
          Inc(pt_pix_intr_cnt_arr_ptr);
          Inc(first_row_pix_ptr1,arr_src_width);
          Inc(first_row_pix_ptr2,arr_dst_width);
          Inc(arr_dst_left_ptr  ,arr_dst_width);
        end;
      line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
    end;
end; {$endregion}
{$endregion}

{CSR-Image Clipping------------------------------------} {$region -fold}
procedure TFastImageProc.UlsProcInit;                                                                           {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  NTUselessProc[0]:=Unaligned(@NTUseless0);
  NTUselessProc[1]:=Unaligned(@NTUseless1);
  NTUselessProc[2]:=Unaligned(@NTUseless2);
  PTUselessProc[0]:=Unaligned(@PTUseless0);
  PTUselessProc[1]:=Unaligned(@PTUseless1);
  PTUselessProc[2]:=Unaligned(@PTUseless2);
end; {$endregion}
procedure TFastImageProc.NTUseless0(var arr_dst:TColorArr; constref arr_dst_width:TColor; constref val:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_cnt_arr_ptr   : PInteger;
  nt_pix_intr_sht_arr_ptr   : PInteger;
  first_row_item_arr_dst_ptr: PInteger;
  arr_dst_ptr               : PInteger;
  nt_z_item_cnt             : TColor;
  x,y                       : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (nt_pix_cnt<>0) then
        begin
          nt_z_item_cnt             :=0;
          first_row_item_arr_dst_ptr:=Unaligned(@arr_dst            [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*arr_dst_width+bmp_ftimg_left]);
          nt_pix_intr_cnt_arr_ptr   :=Unaligned(@nt_pix_intr_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000]);
          nt_pix_intr_sht_arr_ptr   :=Unaligned(@nt_pix_intr_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000]);
          for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
            begin
              arr_dst_ptr:=first_row_item_arr_dst_ptr;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  if ((nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                    begin
                      (nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                      Inc(nt_z_item_cnt);
                    end;
                  Inc (nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_cnt_arr_ptr);
              Inc(first_row_item_arr_dst_ptr,arr_dst_width);
            end;
        end;
      if (nt_z_item_cnt=0) then
        nt_useless:=0
      else
        nt_useless:=1;
    end;
end; {$endregion}
procedure TFastImageProc.NTUseless1(var arr_dst:TColorArr; constref arr_dst_width:TColor; constref val:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_intr_cnt_arr_ptr   : PInteger;
  nt_pix_intr_sht_arr_ptr   : PInteger;
  first_row_item_arr_dst_ptr: PInteger;
  arr_dst_ptr               : PInteger;
  nt_z_item_cnt             : TColor;
  x,y                       : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr=Nil) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        begin
          nt_useless:=0;
          Exit;
        end;
      if (nt_pix_cnt<>0) then
        begin
          nt_z_item_cnt             :=0;
          first_row_item_arr_dst_ptr:=Unaligned(@arr_dst            [(rct_src.top+bmp_ftimg_top)*arr_dst_width+bmp_ftimg_left]);
          nt_pix_intr_cnt_arr_ptr   :=Unaligned(@nt_pix_intr_cnt_arr[ rct_src.top+0000000000000000000000000000000000000000000]);
          nt_pix_intr_sht_arr_ptr   :=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+0000000000000000000000000000]);
          for y:=0 to rct_src.height-1 do
            begin
              arr_dst_ptr:=first_row_item_arr_dst_ptr;
              for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  if ((nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                    begin
                      (nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                      Inc(nt_z_item_cnt);
                    end;
                  Inc (nt_pix_intr_sht_arr_ptr);
                end;
              Inc(nt_pix_intr_cnt_arr_ptr);
              Inc(first_row_item_arr_dst_ptr,arr_dst_width);
            end;
        end;
      if (nt_z_item_cnt=0) then
        nt_useless:=0
      else
        nt_useless:=1;
    end;
end; {$endregion}
procedure TFastImageProc.NTUseless2(var arr_dst:TColorArr; constref arr_dst_width:TColor; constref val:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_dst_ptr               : PInteger;
  first_row_item_arr_dst_ptr: PInteger;
  first_sht_pix_ptr         : PInteger;
  nt_pix_intr_cnt_arr_ptr   : PInteger;
  nt_pix_intr_sht_arr_ptr   : PInteger;
  nt_z_item_cnt             : TColor;
  x,y                       : integer;
  c,c1,c2                   : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr=Nil) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        begin
          nt_useless:=0;
          Exit;
        end;
      if (nt_pix_cnt<>0) then
        begin
          nt_z_item_cnt             :=0;
          first_row_item_arr_dst_ptr:=Unaligned(@arr_dst            [rct_dst.top*arr_dst_width+rct_dst.left]);
          nt_pix_intr_cnt_arr_ptr   :=Unaligned(@nt_pix_intr_cnt_arr[rct_src.top+00000000000000000000000000]);
          nt_pix_intr_sht_arr_ptr   :=Unaligned(@nt_pix_intr_sht_arr[nt_cnt_ind_arr[rct_src.top]+0000000000]);
          for y:=0 to rct_src.height-1 do
            begin
              if (nt_pix_intr_cnt_arr_ptr^<>0) then
                begin
                  arr_dst_ptr:=first_row_item_arr_dst_ptr;
                  first_sht_pix_ptr:=nt_pix_intr_sht_arr_ptr;

                  {left-right-clipped} {$region -fold}
                  if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                     ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                    begin
                      c1:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
                      c2:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
                      Inc(nt_pix_intr_sht_arr_ptr,c1+1);
                      for x:=0 to (c2+1)-(c1+1)-1 do
                        begin
                          if ((nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                            begin
                              (nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                              Inc(nt_z_item_cnt);
                            end;
                          Inc(nt_pix_intr_sht_arr_ptr);
                        end;
                      Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c2+1));
                      goto label1;
                    end; {$endregion}

                  {left-clipped------} {$region -fold}
                  if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                    begin
                      Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
                      goto label1;
                    end
                  else
                  if (first_sht_pix_ptr^<rct_src.left) then
                    begin
                      c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.left);
                      Inc(nt_pix_intr_sht_arr_ptr,c+1);
                      for x:=0 to nt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                        begin
                          if ((nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                            begin
                              (nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                              Inc(nt_z_item_cnt);
                            end;
                          Inc(nt_pix_intr_sht_arr_ptr);
                        end;
                      goto label1;
                    end; {$endregion}

                  {right-clipped-----} {$region -fold}
                  if (first_sht_pix_ptr^>=rct_src.right) then
                    begin
                      Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^);
                      goto label1;
                    end
                  else
                  if ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                    begin
                      c:=BinarySearch(nt_pix_intr_cnt_arr_ptr^,nt_pix_intr_sht_arr_ptr,rct_src.right);
                      for x:=0 to c do
                        begin
                          if ((nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                            begin
                              (nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                              Inc(nt_z_item_cnt);
                            end;
                          Inc(nt_pix_intr_sht_arr_ptr);
                        end;
                      Inc(nt_pix_intr_sht_arr_ptr,nt_pix_intr_cnt_arr_ptr^-(c+1));
                      goto label1;
                    end; {$endregion}

                  {not clipped-------} {$region -fold}
                  if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                     ((first_sht_pix_ptr+nt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                    for x:=0 to nt_pix_intr_cnt_arr_ptr^-1 do
                      begin
                        if ((nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                          begin
                            (nt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                            Inc(nt_z_item_cnt);
                          end;
                        Inc(nt_pix_intr_sht_arr_ptr);
                      end; {$endregion}

                end;
              label1:
              Inc(nt_pix_intr_cnt_arr_ptr);
              Inc(first_row_item_arr_dst_ptr,arr_dst_width);
            end;
        end;
      if (nt_z_item_cnt=0) then
        nt_useless:=0
      else
        nt_useless:=1;
    end;
end; {$endregion}
procedure TFastImageProc.PTUseless0(var arr_dst:TColorArr; constref arr_dst_width:TColor; constref val:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_dst_ptr               : PInteger;
  first_row_item_arr_dst_ptr: PInteger;
  pt_pix_intr_cnt_arr_ptr   : PInteger;
  pt_pix_intr_sht_arr_ptr   : PInteger;
  pt_z_item_cnt             : integer;
  x,y                       : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (pt_pix_cnt<>0) then
        begin
          pt_z_item_cnt             :=0;
          first_row_item_arr_dst_ptr:=Unaligned(@arr_dst            [(pt_pix_arr_row_mrg_top+bmp_ftimg_top)*arr_dst_width+bmp_ftimg_left]);
          pt_pix_intr_cnt_arr_ptr   :=Unaligned(@pt_pix_intr_cnt_arr[ pt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000]);
          pt_pix_intr_sht_arr_ptr   :=Unaligned(@pt_pix_intr_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000]);
          for y:=0 to bmp_ftimg_height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
            begin
              arr_dst_ptr:=first_row_item_arr_dst_ptr;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  if ((pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                    begin
                      (pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                      Inc(pt_z_item_cnt);
                    end;
                  Inc (pt_pix_intr_sht_arr_ptr);
                end;
              Inc(pt_pix_intr_cnt_arr_ptr);
              Inc(first_row_item_arr_dst_ptr,arr_dst_width);
            end;
        end;
      if (pt_z_item_cnt=0) then
        pt_useless:=0
      else
        pt_useless:=1;
    end;
end; {$endregion}
procedure TFastImageProc.PTUseless1(var arr_dst:TColorArr; constref arr_dst_width:TColor; constref val:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_dst_ptr               : PInteger;
  first_row_item_arr_dst_ptr: PInteger;
  pt_pix_intr_cnt_arr_ptr   : PInteger;
  pt_pix_intr_sht_arr_ptr   : PInteger;
  pt_z_item_cnt             : integer;
  x,y                       : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr=Nil) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        begin
          pt_useless:=0;
          Exit;
        end;
      if (pt_pix_cnt<>0) then
        begin
          pt_z_item_cnt             :=0;
          first_row_item_arr_dst_ptr:=Unaligned(@arr_dst            [(rct_src.top+bmp_ftimg_top)*arr_dst_width+bmp_ftimg_left]);
          pt_pix_intr_cnt_arr_ptr   :=Unaligned(@pt_pix_intr_cnt_arr[ rct_src.top+0000000000000000000000000000000000000000000]);
          pt_pix_intr_sht_arr_ptr   :=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+0000000000000000000000000000]);
          for y:=0 to rct_src.height-1 do
            begin
              arr_dst_ptr:=first_row_item_arr_dst_ptr;
              for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                begin
                  if ((pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                    begin
                      (pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                      Inc(pt_z_item_cnt);
                    end;
                  Inc (pt_pix_intr_sht_arr_ptr);
                end;
              Inc(pt_pix_intr_cnt_arr_ptr);
              Inc(first_row_item_arr_dst_ptr,arr_dst_width);
            end;
        end;
      if (pt_z_item_cnt=0) then
        pt_useless:=0
      else
        pt_useless:=1;
    end;
end; {$endregion}
procedure TFastImageProc.PTUseless2(var arr_dst:TColorArr; constref arr_dst_width:TColor; constref val:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_dst_ptr               : PInteger;
  first_row_item_arr_dst_ptr: PInteger;
  first_sht_pix_ptr         : PInteger;
  pt_pix_intr_cnt_arr_ptr   : PInteger;
  pt_pix_intr_sht_arr_ptr   : PInteger;
  pt_z_item_cnt             : integer;
  x,y                       : integer;
  c,c1,c2                   : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr=Nil) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        begin
          pt_useless:=0;
          Exit;
        end;
      if (pt_pix_cnt<>0) then
        begin
          pt_z_item_cnt             :=0;
          first_row_item_arr_dst_ptr:=Unaligned(@arr_dst            [rct_dst.top*arr_dst_width+rct_dst.left]);
          pt_pix_intr_cnt_arr_ptr   :=Unaligned(@pt_pix_intr_cnt_arr[rct_src.top+00000000000000000000000000]);
          pt_pix_intr_sht_arr_ptr   :=Unaligned(@pt_pix_intr_sht_arr[pt_cnt_ind_arr[rct_src.top]+0000000000]);
          for y:=0 to rct_src.height-1 do
            begin
              if (pt_pix_intr_cnt_arr_ptr^<>0) then
                begin
                  arr_dst_ptr:=first_row_item_arr_dst_ptr;
                  first_sht_pix_ptr:=pt_pix_intr_sht_arr_ptr;

                  {left-right-clipped} {$region -fold}
                  if ((first_sht_pix_ptr+00000000000000000000000000)^< rct_src.left ) and
                     ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                    begin
                      c1:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
                      c2:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
                      Inc(pt_pix_intr_sht_arr_ptr,c1+1);
                      for x:=0 to (c2+1)-(c1+1)-1 do
                        begin
                          if ((pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                            begin
                              (pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                              Inc(pt_z_item_cnt);
                            end;
                          Inc(pt_pix_intr_sht_arr_ptr);
                        end;
                      Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c2+1));
                      goto label1;
                    end; {$endregion}

                  {left-clipped------} {$region -fold}
                  if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^<rct_src.left) then
                    begin
                      Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
                      goto label1;
                    end
                  else
                  if (first_sht_pix_ptr^<rct_src.left) then
                    begin
                      c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.left);
                      Inc(pt_pix_intr_sht_arr_ptr,c+1);
                      for x:=0 to pt_pix_intr_cnt_arr_ptr^-(c+1)-1 do
                        begin
                          if ((pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                            begin
                              (pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                              Inc(pt_z_item_cnt);
                            end;
                          Inc(pt_pix_intr_sht_arr_ptr);
                        end;
                      goto label1;
                    end; {$endregion}

                  {right-clipped-----} {$region -fold}
                  if (first_sht_pix_ptr^>=rct_src.right) then
                    begin
                      Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^);
                      goto label1;
                    end
                  else
                  if ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^>=rct_src.right) then
                    begin
                      c:=BinarySearch(pt_pix_intr_cnt_arr_ptr^,pt_pix_intr_sht_arr_ptr,rct_src.right);
                      for x:=0 to c do
                        begin
                          if ((pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                            begin
                              (pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                              Inc(pt_z_item_cnt);
                            end;
                          Inc(pt_pix_intr_sht_arr_ptr);
                        end;
                      Inc(pt_pix_intr_sht_arr_ptr,pt_pix_intr_cnt_arr_ptr^-(c+1));
                      goto label1;
                    end; {$endregion}

                  {not clipped-------} {$region -fold}
                  if ((first_sht_pix_ptr+00000000000000000000000000)^>=rct_src.left ) and
                     ((first_sht_pix_ptr+pt_pix_intr_cnt_arr_ptr^-1)^< rct_src.right) then
                    for x:=0 to pt_pix_intr_cnt_arr_ptr^-1 do
                      begin
                        if ((pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^=0) then
                          begin
                            (pt_pix_intr_sht_arr_ptr^+arr_dst_ptr)^:=val;
                            Inc(pt_z_item_cnt);
                          end;
                        Inc(pt_pix_intr_sht_arr_ptr);
                      end; {$endregion}

                end;
              label1:
              Inc(pt_pix_intr_cnt_arr_ptr);
              Inc(first_row_item_arr_dst_ptr,arr_dst_width);
            end;
        end;
      if (pt_z_item_cnt=0) then
        pt_useless:=0
      else
        pt_useless:=1;
    end;
end; {$endregion}
function  TFastImageProc.Useless: byte;                                                                 inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (nt_useless=0) and (pt_useless=0) then
        Result:=0;
      if (nt_useless=1) and (pt_useless=0) then
        Result:=1;
      if (nt_useless=0) and (pt_useless=1) then
        Result:=2;
      if (nt_useless=1) and (pt_useless=1) then
        Result:=3;
    end;
end; {$endregion}
procedure TFastImageProc.SetRctPos (rct:TPtRect);                                                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      with rct do
        begin
          bmp_ftimg_left  :=left  ;
          bmp_ftimg_top   :=top   ;
          bmp_ftimg_width :=width ;
          bmp_ftimg_height:=height;
          bmp_ftimg_right :=right ;
          bmp_ftimg_bottom:=bottom;
        end;
    end;
end; {$endregion}
procedure TFastImageProc.SetRctPos (x,y,w,h:integer);                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      bmp_ftimg_left  :=x;
      bmp_ftimg_top   :=y;
      bmp_ftimg_width :=w;
      bmp_ftimg_height:=h;
      bmp_ftimg_right :=bmp_ftimg_left+bmp_ftimg_width ;
      bmp_ftimg_bottom:=bmp_ftimg_top +bmp_ftimg_height;
    end;
end; {$endregion}
procedure TFastImageProc.SetRctPos (x,y    :integer);                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      bmp_ftimg_left  :=x;
      bmp_ftimg_top   :=y;
      bmp_ftimg_right :=bmp_ftimg_left+bmp_ftimg_width ;
      bmp_ftimg_bottom:=bmp_ftimg_top +bmp_ftimg_height;
    end;
end; {$endregion}
procedure TFastImageProc.SetRctPos (pvt    :TPtPosF);                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      bmp_ftimg_left  :=Trunc(pvt.x);
      bmp_ftimg_top   :=Trunc(pvt.y);
      bmp_ftimg_right :=bmp_ftimg_left+bmp_ftimg_width ;
      bmp_ftimg_bottom:=bmp_ftimg_top +bmp_ftimg_height;
    end;
end; {$endregion}
procedure TFastImageProc.SetRctDst;                                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      rct_dst:=           PtRct(bmp_ftimg_left     +rct_dst_mrg.left,
                                bmp_ftimg_top      +rct_dst_mrg.top,
                                bmp_ftimg_right    -rct_dst_mrg.right,
                                bmp_ftimg_bottom   -rct_dst_mrg.bottom);
      rct_dst:=ClippedRct(PtRct(rct_clp_ptr^.left  +rct_clp_mrg.left,
                                rct_clp_ptr^.top   +rct_clp_mrg.top,
                                rct_clp_ptr^.right -rct_clp_mrg.right,
                                rct_clp_ptr^.bottom-rct_clp_mrg.bottom),
                                rct_dst_mrg,
                                rct_dst,
                                pix_clp_type);
    end;
end; {$endregion}
procedure TFastImageProc.SetRctSrc;                                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    rct_src:=PtBounds(rct_dst.left  -bmp_ftimg_left,
                      rct_dst.top   -bmp_ftimg_top,
                      rct_dst.right -rct_dst.left,
                      rct_dst.bottom-rct_dst.top);
end; {$endregion} {$endregion}

{Init. Part--------------------------------------------} {$region -fold}
constructor TFastImageProc.Create;                                                                                                                       {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  CmpProcInit;
  FilProcInit;
  SdrProcInit;
  UlsProcInit;
  SdrTypeInit;
end; {$endregion}
destructor  TFastImageProc.Destroy;                                                                                                                      {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  self.Free;
  inherited Destroy;
end; {$endregion}
procedure   TFastImageProc.SetBkgnd  (constref bkgnd_ptr:PInteger; constref bkgnd_width,bkgnd_height:TColor; constref rct_clp:TPtRect);          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      bmp_bkgnd_ptr   :=bkgnd_ptr   ;
      bmp_bkgnd_width :=bkgnd_width ;
      bmp_bkgnd_height:=bkgnd_height;
      rct_clp_ptr     :=@rct_clp;
    end;
end; {$endregion}
procedure   TFastImageProc.SetClpRct (constref rct_clp:TPtRect);                                                                                 inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    rct_clp_ptr:=Unaligned(@rct_clp);
end; {$endregion}
procedure   TFastImageProc.SetValInfo(constref bmp_color_ptr_,bmp_alpha_ptr_,bmp_value_ptr_:PInteger; constref ftimg_width,ftimg_height:TColor); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      bmp_color_ptr          :=bmp_color_ptr_;
      bmp_alpha_ptr          :=bmp_alpha_ptr_;
      bmp_value_ptr          :=bmp_value_ptr_;
      bmp_ftimg_width        :=ftimg_width ;
      bmp_ftimg_height       :=ftimg_height;
      bmp_ftimg_width_origin :=ftimg_width ;
      bmp_ftimg_height_origin:=ftimg_height;
    end;
end; {$endregion}
procedure   TFastImageProc.SetPPInfo (const val:TColor=$00434D3E);                                                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    monochrome_val:=RGB(TRGBA(val).b,
                        TRGBA(val).g,
                        TRGBA(val).r);
end; {$endregion}
procedure   TFastImageProc.FXInit;                                                                                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure   TFastImageProc.SetGradVec(x,y:integer);                                                                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      grad_vec:=PtPos(x,y);
      with grad_prop do
        begin
          if set_grad_to_vis_area then
            grad_vec_dif:=grad_vec.y-grad_vec.x
          else
            grad_vec_dif:=bmp_ftimg_height;
        end;
    end;
end; {$endregion}
procedure   TFastImageProc.SetGradCol(x,y:TColor );                                                                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      grad_col:=PtPos2(x,y);
      with grad_prop do
        begin
          grad_col0         := TRGBA(grad_col.x);
          grad_col0.a       :=-TRGBA(grad_col.x).a+alpha_max;
          grad_col1         := TRGBA(grad_col.y);
          grad_col1.a       :=-TRGBA(grad_col.y).a+alpha_max;
         {grad_col0       .r:= TRGBA(grad_col.x).r;
          grad_col0       .g:= TRGBA(grad_col.x).g;
          grad_col0       .b:= TRGBA(grad_col.x).b;
          grad_col1       .r:= TRGBA(grad_col.y).r;
          grad_col1       .g:= TRGBA(grad_col.y).g;
          grad_col1       .b:= TRGBA(grad_col.y).b;}
          grad_col_dif    .r:=grad_col1.r-grad_col0.r;
          grad_col_dif    .g:=grad_col1.g-grad_col0.g;
          grad_col_dif    .b:=grad_col1.b-grad_col0.b;
          grad_col_dif    .a:=grad_col1.a-grad_col0.a;
          grad_rng_div_vec.r:=Trunc((grad_col_dif.r*C_INT)/grad_vec_dif);
          grad_rng_div_vec.g:=Trunc((grad_col_dif.g*C_INT)/grad_vec_dif);
          grad_rng_div_vec.b:=Trunc((grad_col_dif.b*C_INT)/grad_vec_dif);
          grad_rng_div_vec.a:=Trunc((grad_col_dif.a*C_INT)/grad_vec_dif);
          if (not set_grad_to_vis_area) then
            begin
              grad_col0   .r+=(grad_rng_div_vec.r*grad_vec.x)>>16;
              grad_col0   .g+=(grad_rng_div_vec.g*grad_vec.x)>>16;
              grad_col0   .b+=(grad_rng_div_vec.b*grad_vec.x)>>16;
              grad_col0   .a+=(grad_rng_div_vec.a*grad_vec.x)>>16;
              grad_col1   .r+=(grad_rng_div_vec.r*grad_vec.y)>>16;
              grad_col1   .g+=(grad_rng_div_vec.g*grad_vec.y)>>16;
              grad_col1   .b+=(grad_rng_div_vec.b*grad_vec.y)>>16;
              grad_col1   .a+=(grad_rng_div_vec.a*grad_vec.y)>>16;
            end;
        end;
    end;
end; {$endregion}
procedure   TFastImageProc.SrcDestroy(bmp_src:TPicture  );                                                                                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  bmp_src.Free;
end; {$endregion}
procedure   TFastImageProc.SrcDestroy(bmp_src:TBitmap   );                                                                                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  bmp_src.Free;
end; {$endregion}
procedure   TFastImageProc.SrcDestroy(arr_src:TColorArr );                                                                                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(arr_src,0);
  Finalize (arr_src);
end; {$endregion}
procedure   TFastImageProc.SrcDestroy(arr_src:TWordArr  );                                                                                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(arr_src,0);
  Finalize (arr_src);
end; {$endregion}
procedure   TFastImageProc.SrcDestroy(arr_src:T1Byte1Arr);                                                                                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(arr_src,0);
  Finalize (arr_src);
end; {$endregion}
constructor TFastImageItem.Create    (constref bkgnd_ptr:PInteger; constref bkgnd_width,bkgnd_height:TColor; var rct_clp:TPtRect; constref bmp_src_rct:TPtRect; constref empty:TColor=0);                                                                                                                                        {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data,fast_image_proc_var do
    begin

      fast_image_data_ptr0:=@fast_image_data;

      {Set Max. Alpha Value-----------} {$region -fold}
      alpha_max:=MAXBYTE; {$endregion}

      {Set Drawing Surface(Background)} {$region -fold}
      SetBkgnd(bkgnd_ptr,bkgnd_width,bkgnd_height,rct_clp); {$endregion}

      {Misc. Precalc. Settings--------} {$region -fold}
      ShaderInfo;
      SetPPInfo ; {$endregion}

    end;
end; {$endregion}
constructor TFastImageItem.Create    (constref bkgnd_ptr:PInteger; constref bkgnd_width,bkgnd_height:TColor; var rct_clp:TPtRect; constref bmp_src_rct:TPtRect; constref location:string=''; constref ImgLstGetBmp:TProc1=Nil; constref img_ind:TColor=0; constref tile_map_calc_:boolean=False; constref pic_src:TPicture=Nil); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  icn_src_pic       : TPicture=Nil;
  icn_src0          : TBitmap =Nil;
  icn_src           : TBitmap =Nil;
  icn_src_ptr       : PInteger=Nil;
  icn_src_pic_is_nil: boolean =True;
  icn_src0_is_nil   : boolean =True;
  w_mul_h           : integer;
begin

  with fast_image_data,fast_image_proc_var do
    begin

      fast_image_data_ptr0:=@fast_image_data;

      {Set Max. Alpha Value-----------} {$region -fold}
      alpha_max:=MAXBYTE; {$endregion}

      {Is Spite a Tile Map------------} {$region -fold}
      tile_map_calc:=tile_map_calc_;
      if tile_map_calc then
        sln_prop_var:=curve_default_prop; {$endregion}

      {Set Drawing Surface(Background)} {$region -fold}
      SetBkgnd(bkgnd_ptr,bkgnd_width,bkgnd_height,rct_clp); {$endregion}

      {Misc. Precalc. Settings--------} {$region -fold}
      ShaderInfo;
      SetPPInfo; {$endregion}

      {Load Sprite--------------------} {$region -fold}
      if (pic_src<>Nil) then
        begin
          icn_src        :=CrtTBmpInst(pic_src.Bitmap,icn_src_ptr);
          icn_src0_is_nil:=False;
        end
      else
      if FileExists(location) then
        begin
          icn_src_pic       :=CrtTPicInstFromHDDSrc(location);
          icn_src           :=CrtTBmpInst(icn_src_pic.Bitmap,icn_src_ptr);
          icn_src_pic_is_nil:=False;
        end
      else
      if (ImgLstGetBmp<>Nil) then
        begin
          icn_src0       :=CrtTBmpInstFromImgLst(ImgLstGetBmp,img_ind);
          icn_src        :=CrtTBmpInst(icn_src0,icn_src_ptr);
          icn_src0_is_nil:=False;
        end;
      if (icn_src_ptr=Nil) then
        Exit; {$endregion}

      {Compress Sprite----------------} {$region -fold}
      SetValInfo(icn_src_ptr,icn_src_ptr,icn_src_ptr,icn_src.width,icn_src.height);
      bmp_src_rct_clp :=ClippedRct(PtBounds(0,0,icn_src.width,icn_src.height),bmp_src_rct);
      ImgToCImg;
      bmp_ftimg_width :=bmp_src_rct_clp.width;
      bmp_ftimg_height:=bmp_src_rct_clp.height; {$endregion}

      {Clear Resources----------------} {$region -fold}
      DeleteObject(icn_src.Canvas.Handle);
      w_mul_h:=bmp_ftimg_width_origin*bmp_ftimg_height_origin;
      if ((img_kind=0) and (nt_pix_cnt>0) and (nt_pix_cnt<w_mul_h)
                       and (pt_pix_cnt>0) and (pt_pix_cnt<w_mul_h)) or
         ((img_kind=1) and (nt_pix_cnt>0) and (nt_pix_cnt<w_mul_h)) or
         ((img_kind=2) and (pt_pix_cnt>0) and (pt_pix_cnt<w_mul_h)) or
         ((img_kind=3) and (nt_pix_cnt>0) and (nt_pix_cnt<w_mul_h)) or
         ((img_kind=4) and (pt_pix_cnt>0) and (pt_pix_cnt<w_mul_h)) then
        begin
          DeleteObject(icn_src.Handle);
          SrcDestroy  (icn_src);
        end;
      if (not icn_src_pic_is_nil) then
        SrcDestroy(icn_src_pic);
      if (not icn_src0_is_nil) then
        SrcDestroy(icn_src0);
      icn_src_ptr:=Nil; {$endregion}

    end;

end; {$endregion}
destructor  TFastImageItem.Destroy;                                                                                                                      {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  self.Free;
  inherited Destroy;
end; {$endregion}
{$endregion}

{$endregion}



(**************************** Fast Actor Container ****************************) {$region -fold}

constructor TFastActorSet.Create(constref bkgnd_ptr:PInteger; constref bkgnd_width,bkgnd_height:TColor; var rct_clp:TPtRect; constref bmp_src_rct:TPtRect; constref location:string=''; constref ImgLstGetBmp:TProc1=Nil; constref d_icon_img_lst_ind:TColor=0); {$region -fold}
begin

  {Default Icon---} {$region -fold}
  d_icon:=TFastImageItem.Create(bkgnd_ptr,
                                bkgnd_width,
                                bkgnd_height,
                                rct_clp,
                                bmp_src_rct,
                                location,
                                ImgLstGetBmp,
                                d_icon_img_lst_ind); {$endregion}

  {Selection Field} {$region -fold}
  SetLength(sel_fld,bkgnd_width*bkgnd_height);
  PtrInit  (sel_fld_ptr,sel_fld); {$endregion}

end; {$endregion}
destructor TFastActorSet.Destroy; {$region -fold}
begin
  self.Free;
  inherited Destroy;
end; {$endregion}
procedure TFastActorSet.AddActor(x,y:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with d_icon,fast_image_proc_var,fast_image_data_ptr0^ do
    begin
      fast_image_data_ptr0:=@d_icon.fast_image_data;
      Inc        (act_cnt);
      SetLength  (act_arr,
                  act_cnt);
      SetLength  (act_pos_arr,
                  act_cnt);
      act_arr    [act_cnt-1]  :=TFastActor.Create;
      act_pos_arr[act_cnt-1].x:=x-bmp_ftimg_width >>1;
      act_pos_arr[act_cnt-1].y:=y-bmp_ftimg_height>>1;
      with d_icon do
       begin
         SetRctPos(x,y);
         SdrProc[3];
       end;
    end;
end; {$endregion}

{$endregion}



(********************************* Fast Actor *********************************) {$region -fold}

constructor TFastActor.Create; {$region -fold}
begin
  SetLength(frm_arr,frm_cnt);
end; {$endregion}
destructor TFastActor.Destroy; {$region -fold}
begin
  self.Free;
  inherited Destroy;
end; {$endregion}

{$endregion}



(***************************** Fast Line Routines *****************************) {$region -fold}

{Init. Part--} {$region -fold}
constructor TFastLine.Create;                                                                                                                        {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  LineSInit;
end; {$endregion}
destructor TFastLine.Destroy;                                                                                                                        {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  self.Free;
  inherited Destroy;
end; {$endregion}
procedure TFastLine.GCCArrInit;                                                                                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  gcd_arr:=Nil;
  SetLength  (gcd_arr,ln_arr_width*ln_arr_height);
  LinePrecalc(        ln_arr_width,ln_arr_height);
end; {$endregion}
// Replace Lookup Table(Precalculated Array):
procedure TFastLine.GCCArrRepl(dst_fl_var:TFastLine);                                                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {gcd_arr:=Nil;
  SetLength(gcd_arr,ln_arr_width*ln_arr_height);
  gcd_arr:=dst_fl_var.gcd_arr;}
end; {$endregion}
procedure TFastLine.BuffersInit(w,h:TColor; ln_arr0_init:boolean; ln_arr1_init:boolean; ln_arr2_init:boolean; aa_buff_init:boolean);         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  if ((w=0) or (h=0)) then
    Exit;
  ln_arr_width :=w;
  ln_arr_height:=h;
  if ln_arr0_init then
    begin
      SetLength(ln_arr0,w*h);
      ln_arr0_ptr:=Unaligned(@ln_arr0[0]);
    end;
  if ln_arr1_init then
    begin
      SetLength(ln_arr1,w*h);
      ln_arr1_ptr:=Unaligned(@ln_arr1[0]);
    end;
  if ln_arr2_init then
    begin
      SetLength(ln_arr2,w);
      for i:=0 to w-1 do
        SetLength(ln_arr2[i],h);
    end;
  if aa_buff_init then
    begin
      SetLength(aa_arr1,w*h);
      SetLength(aa_arr2,w*h);
    end;
end; {$endregion}
procedure TFastLine.SetBkgnd(constref bmp_dst_ptr_:PInteger; constref bmp_dst_width_,bmp_dst_height_:TColor; constref rct_clp_ptr_:PPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  bmp_dst_ptr   :=bmp_dst_ptr_;
  bmp_dst_width :=bmp_dst_width_;
  bmp_dst_height:=bmp_dst_height_;
  rct_clp_ptr   :=rct_clp_ptr_;
end; {$endregion}
procedure TFastLine.MinimizeArrs(aa_buff_clear:boolean);                                                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Setlength(ln_arr0,0);
  Setlength(ln_arr1,0);
  Setlength(ln_arr2,0);
  if (not aa_buff_clear) then
    Exit;
  Setlength(aa_arr1,0);
  Setlength(aa_arr2,0);
end; {$endregion} {$endregion}

{Line Drawing} {$region -fold}
// (Fast Line Grid Precalculation) Предпросчет сетки для быстрой линии:
{class} procedure TFastLine.LinePrecalc(w,h:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  gcd_arr_ptr            : PGCDGrid; //^TFastLine.TGCDGrid;
  i,j,k,t1,t2,s1,s2,v1,v2: integer;

  {(Binary Stein Algorithm, which finds Greatest Common Divisor of two integer numbers) Бинарный алгоритм Стейна нахождения НСД двух целых чисел}
  function SteinGCD(a_,b_:integer): integer; {$region -fold}
  var
    k_: integer;
  begin
    k_:=1;
    while (a_<>0) and (a_<>0) do
      begin
        while (a_ and 1=0) and (b_ and 1=0) do
          begin
            a_:=a_>>1;
            b_:=b_>>1;
            k_:=k_<<1;
          end;
        while (a_ and 1=0) do
          a_:=a_>>1;
        while (b_ and 1=0) do
          b_:=b_>>1;
        if (a_>=b_) then
          a_:=a_-b_
        else
          b_:=b_-a_;
      end;
    Result:=b_*k_;
  end; {$endregion}

begin
  grid_pt_rad:=2;
  k:=2*grid_pt_rad;

  {Loop 1} {$region -fold}
  for j:=0 to h-1 do
    for i:=0 to w-1 do
      if (i>=j) then
        begin
          gcd_arr[i+j*w].a:=SteinGCD(i+1,j+1);
          if (gcd_arr[i+j*w].a<>1) then
            begin

              // Line1 Precalc.:
             {dx+1:=a*c;
              dy+1:=a;}
              if (gcd_arr[i+j*w].a=j+1) then {$region -fold}
                begin
                  gcd_arr[i+j*w].f_ln_kind:=1;
                  gcd_arr[i+j*w].b        :=0;
                  gcd_arr[i+j*w].c        :=Trunc((i+1)/(j+1));
                  Continue;
                end; {$endregion}

              // Line2 Precalc.:
             {dx+1:=c*(dy+1)+a:=a*b*c+a*(c+1):=a((b+1)*c+1);
              dy+1:=a*(b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-1) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) then {$region -fold}
                begin
                  gcd_arr[i+j*w].f_ln_kind:=2;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1));
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-1)/(gcd_arr[i+j*w].b+1));
                  Continue;
                end; {$endregion}

              // Line3 Precalc.:
             {dx+1:=c*(dy+1)+a*b:=a*c+a*b*(c+1):=a((b+1)*c+b);
              dy+1:=a*(b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-((j+1)/gcd_arr[i+j*w].a-1)) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) then {$region -fold}
                begin
                  gcd_arr[i+j*w].f_ln_kind:=3;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1));
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-gcd_arr[i+j*w].b)/(gcd_arr[i+j*w].b+1));
                  Continue;
                end; {$endregion}

              // Line4 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*b*c+a*(b+1)*(c+1):=a((2*b+1)*c+b+1);
              dy+1:=a*(2*b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-(((j+1)/gcd_arr[i+j*w].a-1)/2)-1) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) and {$region -fold}
                 (Trunc((j+1)/gcd_arr[i+j*w].a) mod 2=1) then
                begin
                  gcd_arr[i+j*w].f_ln_kind:=4;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1)/2);
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-gcd_arr[i+j*w].b-1)/((2*gcd_arr[i+j*w].b)+1));
                  Continue;
                end; {$endregion}

              // Line5 Precalc.:
             {dx+1:=c*(dy+1)+a*b:=a*(b+1)*c+a*b*(c+1):=a((2*b+1)*c+b);
              dy+1:=a*(2*b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-(((j+1)/gcd_arr[i+j*w].a-1)/2)) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) and {$region -fold}
                 (Trunc((j+1)/gcd_arr[i+j*w].a) mod 2=1) then
                begin
                  gcd_arr[i+j*w].f_ln_kind:=5;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1)/2);
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-gcd_arr[i+j*w].b)/((2*gcd_arr[i+j*w].b)+1));
                  Continue;
                end; {$endregion}

              // Line6 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*2*b*c+a*(b+1)*(c+1):=a((3*b+1)*c+b+1);
              dy+1:=a*(3*b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-(((j+1)/gcd_arr[i+j*w].a-1)/3)-1) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) and {$region -fold}
                 (Trunc((j+1)/gcd_arr[i+j*w].a) mod 3=1) then
                begin
                  gcd_arr[i+j*w].f_ln_kind:=6;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1)/3);
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-gcd_arr[i+j*w].b-1)/((3*gcd_arr[i+j*w].b)+1));
                  Continue;
                end; {$endregion}

              // Line7 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*(2*b+1)*c+a*b*(c+1):=a((3*b+1)*c+b);
              dy+1:=a*(3*b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-(((j+1)/gcd_arr[i+j*w].a-1)/3)) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) and {$region -fold}
                 (Trunc((j+1)/gcd_arr[i+j*w].a) mod 3=1) then
                begin
                  gcd_arr[i+j*w].f_ln_kind:=7;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1)/3);
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-gcd_arr[i+j*w].b)/((3*gcd_arr[i+j*w].b)+1));
                  Continue;
                end; {$endregion}

              // Line8 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*b*c+a*(2*b+1)*(c+1):=a((3*b+1)*c+2*b+1);
              dy+1:=a*(3*b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-2*(((j+1)/gcd_arr[i+j*w].a-1)/3)-1) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) and {$region -fold}
                 (Trunc((j+1)/gcd_arr[i+j*w].a) mod 3=1) then
                begin
                  gcd_arr[i+j*w].f_ln_kind:=8;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1)/3);
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-2*gcd_arr[i+j*w].b-1)/((3*gcd_arr[i+j*w].b)+1));
                  Continue;
                end; {$endregion}

              // Line9 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*(b+1)*c+a*2*b*(c+1):=a((3*b+1)*c+2*b);
              dy+1:=a*(3*b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-2*(((j+1)/gcd_arr[i+j*w].a-1)/3)) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) and {$region -fold}
                 (Trunc((j+1)/gcd_arr[i+j*w].a) mod 3=1) then
                begin
                  gcd_arr[i+j*w].f_ln_kind:=9;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1)/3);
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-2*gcd_arr[i+j*w].b)/((3*gcd_arr[i+j*w].b)+1));
                  Continue;
                end; {$endregion}

            end;
        end; {$endregion}

  {Loop 2} {$region -fold}
  for j:=0 to h-1 do
    for i:=0 to w-1 do
      if (i>j)                        then
        if (gcd_arr[i+j*w].f_ln_kind=0) then
          begin
            v1:=grid_pt_rad;
            v2:=grid_pt_rad;
            for t1:=0 to k do
              for t2:=0 to k do
                begin
                  s1:=t1-grid_pt_rad;
                  s2:=t2-grid_pt_rad;
                  if (i+s1>=0) and (i+s1<=w-1) and
                     (j+s2>=0) and (j+s2<=h-1) and
                     (gcd_arr[(i+s1)+(j+s2)*w].d<>-1) and
                     (gcd_arr[(i+s1)+(j+s2)*w].f_ln_kind<>0) and
                     (Max2(Abs(s1),Abs(s2))<Max2(Abs(v1),Abs(v2))) then
                    begin
                      v1:=s1;
                      v2:=s2;
                    end;
                end;
            if (i+v1>=0) and (i+v1<=w-1) and
               (j+v2>=0) and (j+v2<=h-1) then
              begin
                gcd_arr[i+j*w]  :=gcd_arr[(i+v1)+(j+v2)*w];
                gcd_arr[i+j*w].d:=-1;
              end;
          end; {$endregion}

  {Loop 3} {$region -fold}
  {2 alternative records of the same code block}
  {1.} {$region -fold}
  {for j:=0 to h-1 do
    for i:=0 to w-1 do
      if (i<j) then
        begin
          gcd_arr[i+j*w]          :=gcd_arr[j+i*w];
          gcd_arr[i+j*w].f_ln_kind:=gcd_arr[j+i*w].f_ln_kind+10;
        end;} {$endregion}
  {2.} {$region -fold}
  gcd_arr_ptr:=Unaligned(@gcd_arr[0]);
  for j:=0 to h-1 do
    for i:=0 to w-1 do
      begin
        if (i<j) then
          begin
            gcd_arr_ptr^          :=gcd_arr[j+i*w];
            gcd_arr_ptr^.f_ln_kind:=gcd_arr[j+i*w].f_ln_kind+10;
          end;
        Inc(gcd_arr_ptr);
      end; {$endregion} {$endregion}

end;
{var
  gcd_arr_ptr            : PGCDGrid; //^TFastLine.TGCDGrid;
  i,j,k,n,m,t1,t2,s1,s2,v1,v2: integer;

  {(Binary Stein Algorithm, which finds Greatest Common Divisor of two integer numbers) Бинарный алгоритм Стейна нахождения НСД двух целых чисел}
  function SteinGCD(a_,b_:integer): integer; {$region -fold}
  var
    k_: integer;
  begin
    k_:=1;
    while (a_<>0) and (a_<>0) do
      begin
        while (a_ and 1=0) and (b_ and 1=0) do
          begin
            a_:=a_>>1;
            b_:=b_>>1;
            k_:=k_<<1;
          end;
        while (a_ and 1=0) do
          a_:=a_>>1;
        while (b_ and 1=0) do
          b_:=b_>>1;
        if (a_>=b_) then
          a_:=a_-b_
        else
          b_:=b_-a_;
      end;
    Result:=b_*k_;
  end; {$endregion}

begin
  grid_pt_rad:=2;
  k:=2*grid_pt_rad;

  {Loop 1} {$region -fold}
  for j:=0 to h-1 do
    for i:=0 to w-1 do
      if (i>=j) then
        begin
          n:=i+j*w;
          gcd_arr[n].a:=SteinGCD(i+1,j+1);
          if (gcd_arr[n].a<>1) then
            begin

              // Line1 Precalc.:
             {dx+1:=a*c;
              dy+1:=a;}
              if (gcd_arr[n].a=j+1) then {$region -fold}
                begin
                  gcd_arr[n].f_ln_kind:=1;
                  gcd_arr[n].b        :=0;
                  gcd_arr[n].c        :=Trunc((i+1)/(j+1));
                  Continue;
                end; {$endregion}

              // Line2 Precalc.:
             {dx+1:=c*(dy+1)+a:=a*b*c+a*(c+1):=a((b+1)*c+1);
              dy+1:=a*(b+1);}
              if (Trunc((i+1)/gcd_arr[n].a-1) mod Trunc((j+1)/gcd_arr[n].a)=0) then {$region -fold}
                begin
                  gcd_arr[n].f_ln_kind:=2;
                  gcd_arr[n].b        :=Trunc(((j+1)/gcd_arr[n].a-1));
                  gcd_arr[n].c        :=Trunc(((i+1)/gcd_arr[n].a-1)/(gcd_arr[n].b+1));
                  Continue;
                end; {$endregion}

              // Line3 Precalc.:
             {dx+1:=c*(dy+1)+a*b:=a*c+a*b*(c+1):=a((b+1)*c+b);
              dy+1:=a*(b+1);}
              if (Trunc((i+1)/gcd_arr[n].a-((j+1)/gcd_arr[n].a-1)) mod Trunc((j+1)/gcd_arr[n].a)=0) then {$region -fold}
                begin
                  gcd_arr[n].f_ln_kind:=3;
                  gcd_arr[n].b        :=Trunc(((j+1)/gcd_arr[n].a-1));
                  gcd_arr[n].c        :=Trunc(((i+1)/gcd_arr[n].a-gcd_arr[n].b)/(gcd_arr[n].b+1));
                  Continue;
                end; {$endregion}

              // Line4 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*b*c+a*(b+1)*(c+1):=a((2*b+1)*c+b+1);
              dy+1:=a*(2*b+1);}
              if (Trunc((i+1)/gcd_arr[n].a-(((j+1)/gcd_arr[n].a-1)/2)-1) mod Trunc((j+1)/gcd_arr[n].a)=0) and {$region -fold}
                 (Trunc((j+1)/gcd_arr[n].a) mod 2=1) then
                begin
                  gcd_arr[n].f_ln_kind:=4;
                  gcd_arr[n].b        :=Trunc(((j+1)/gcd_arr[n].a-1)/2);
                  gcd_arr[n].c        :=Trunc(((i+1)/gcd_arr[n].a-gcd_arr[n].b-1)/((2*gcd_arr[n].b)+1));
                  Continue;
                end; {$endregion}

              // Line5 Precalc.:
             {dx+1:=c*(dy+1)+a*b:=a*(b+1)*c+a*b*(c+1):=a((2*b+1)*c+b);
              dy+1:=a*(2*b+1);}
              if (Trunc((i+1)/gcd_arr[n].a-(((j+1)/gcd_arr[n].a-1)/2)) mod Trunc((j+1)/gcd_arr[n].a)=0) and {$region -fold}
                 (Trunc((j+1)/gcd_arr[n].a) mod 2=1) then
                begin
                  gcd_arr[n].f_ln_kind:=5;
                  gcd_arr[n].b        :=Trunc(((j+1)/gcd_arr[n].a-1)/2);
                  gcd_arr[n].c        :=Trunc(((i+1)/gcd_arr[n].a-gcd_arr[n].b)/((2*gcd_arr[n].b)+1));
                  Continue;
                end; {$endregion}

              // Line6 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*2*b*c+a*(b+1)*(c+1):=a((3*b+1)*c+b+1);
              dy+1:=a*(3*b+1);}
              if (Trunc((i+1)/gcd_arr[n].a-(((j+1)/gcd_arr[n].a-1)/3)-1) mod Trunc((j+1)/gcd_arr[n].a)=0) and {$region -fold}
                 (Trunc((j+1)/gcd_arr[n].a) mod 3=1) then
                begin
                  gcd_arr[n].f_ln_kind:=6;
                  gcd_arr[n].b        :=Trunc(((j+1)/gcd_arr[n].a-1)/3);
                  gcd_arr[n].c        :=Trunc(((i+1)/gcd_arr[n].a-gcd_arr[n].b-1)/((3*gcd_arr[n].b)+1));
                  Continue;
                end; {$endregion}

              // Line7 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*(2*b+1)*c+a*b*(c+1):=a((3*b+1)*c+b);
              dy+1:=a*(3*b+1);}
              if (Trunc((i+1)/gcd_arr[n].a-(((j+1)/gcd_arr[n].a-1)/3)) mod Trunc((j+1)/gcd_arr[n].a)=0) and {$region -fold}
                 (Trunc((j+1)/gcd_arr[n].a) mod 3=1) then
                begin
                  gcd_arr[n].f_ln_kind:=7;
                  gcd_arr[n].b        :=Trunc(((j+1)/gcd_arr[n].a-1)/3);
                  gcd_arr[n].c        :=Trunc(((i+1)/gcd_arr[n].a-gcd_arr[n].b)/((3*gcd_arr[n].b)+1));
                  Continue;
                end; {$endregion}

              // Line8 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*b*c+a*(2*b+1)*(c+1):=a((3*b+1)*c+2*b+1);
              dy+1:=a*(3*b+1);}
              if (Trunc((i+1)/gcd_arr[n].a-2*(((j+1)/gcd_arr[n].a-1)/3)-1) mod Trunc((j+1)/gcd_arr[n].a)=0) and {$region -fold}
                 (Trunc((j+1)/gcd_arr[n].a) mod 3=1) then
                begin
                  gcd_arr[n].f_ln_kind:=8;
                  gcd_arr[n].b        :=Trunc(((j+1)/gcd_arr[n].a-1)/3);
                  gcd_arr[n].c        :=Trunc(((i+1)/gcd_arr[n].a-2*gcd_arr[n].b-1)/((3*gcd_arr[n].b)+1));
                  Continue;
                end; {$endregion}

              // Line9 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*(b+1)*c+a*2*b*(c+1):=a((3*b+1)*c+2*b);
              dy+1:=a*(3*b+1);}
              if (Trunc((i+1)/gcd_arr[n].a-2*(((j+1)/gcd_arr[n].a-1)/3)) mod Trunc((j+1)/gcd_arr[n].a)=0) and {$region -fold}
                 (Trunc((j+1)/gcd_arr[n].a) mod 3=1) then
                begin
                  gcd_arr[n].f_ln_kind:=9;
                  gcd_arr[n].b        :=Trunc(((j+1)/gcd_arr[n].a-1)/3);
                  gcd_arr[n].c        :=Trunc(((i+1)/gcd_arr[n].a-2*gcd_arr[n].b)/((3*gcd_arr[n].b)+1));
                  Continue;
                end; {$endregion}

            end;
        end; {$endregion}

  {Loop 2} {$region -fold}
  for j:=0 to h-1 do
    for i:=0 to w-1 do
      if (i>j) then
        begin
          n:=i+j*w;
          if (gcd_arr[n].f_ln_kind=0) then
            begin
              v1:=grid_pt_rad;
              v2:=grid_pt_rad;
              for t1:=0 to k do
                for t2:=0 to k do
                  begin
                    s1:=t1-grid_pt_rad;
                    s2:=t2-grid_pt_rad;
                    m :=n+s1+s2*w;
                    if (i+s1>=0) and (i+s1<=w-1) and
                       (j+s2>=0) and (j+s2<=h-1) and
                       (gcd_arr[m].d<>-1) and
                       (gcd_arr[m].f_ln_kind<>0) and
                       (Max2(Abs(s1),Abs(s2))<Max2(Abs(v1),Abs(v2))) then
                      begin
                        v1:=s1;
                        v2:=s2;
                      end;
                  end;
              if (i+v1>=0) and (i+v1<=w-1) and
                 (j+v2>=0) and (j+v2<=h-1) then
                begin
                  gcd_arr[n]  :=gcd_arr[(i+v1)+(j+v2)*w];
                  gcd_arr[n].d:=-1;
                end;
            end;
        end; {$endregion}

  {Loop 3} {$region -fold}
  {2 alternative records of the same code block}
  {1.} {$region -fold}
  {for j:=0 to h-1 do
    for i:=0 to w-1 do
      if (i<j) then
        begin
          gcd_arr[i+j*w]          :=gcd_arr[j+i*w];
          gcd_arr[i+j*w].f_ln_kind:=gcd_arr[j+i*w].f_ln_kind+10;
        end;} {$endregion}
  {2.} {$region -fold}
  gcd_arr_ptr:=Unaligned(@gcd_arr[0]);
  for j:=0 to h-1 do
    for i:=0 to w-1 do
      begin
        if (i<j) then
          begin
            n                     :=j+i*w;
            gcd_arr_ptr^          :=gcd_arr[n];
            gcd_arr_ptr^.f_ln_kind:=gcd_arr[n].f_ln_kind+10;
          end;
        Inc(gcd_arr_ptr);
      end; {$endregion} {$endregion}

end;} {$endregion}

{Fast Line Solid (Width - 1 pixel)}

// (Solid Line Initialization) Инициализация сплошной линии:
procedure TFastLine.LineSInit;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  {Right Bottom Corner}
  {0°..-45°}
  LineProc[00]:=Unaligned(@LineS00   );
  LineProc[01]:=Unaligned(@LineS01RBC);
  LineProc[02]:=Unaligned(@LineS02RBC);
  LineProc[03]:=Unaligned(@LineS03RBC);
  LineProc[04]:=Unaligned(@LineS04RBC);
  LineProc[05]:=Unaligned(@LineS05RBC);
  LineProc[06]:=Unaligned(@LineS06RBC);
  LineProc[07]:=Unaligned(@LineS07RBC);
  LineProc[08]:=Unaligned(@LineS08RBC);
  LineProc[09]:=Unaligned(@LineS09RBC);
  {-45°..-90°}
  LineProc[10]:=Unaligned(@LineS10   );
  LineProc[11]:=Unaligned(@LineS11RBC);
  LineProc[12]:=Unaligned(@LineS12RBC);
  LineProc[13]:=Unaligned(@LineS13RBC);
  LineProc[14]:=Unaligned(@LineS14RBC);
  LineProc[15]:=Unaligned(@LineS15RBC);
  LineProc[16]:=Unaligned(@LineS16RBC);
  LineProc[17]:=Unaligned(@LineS17RBC);
  LineProc[18]:=Unaligned(@LineS18RBC);
  LineProc[19]:=Unaligned(@LineS19RBC);

  {Left Bottom Corner}
  {-135°..-180°}
  LineProc[20]:=Unaligned(@LineS20   );
  LineProc[21]:=Unaligned(@LineS21LBC);
  LineProc[22]:=Unaligned(@LineS22LBC);
  LineProc[23]:=Unaligned(@LineS23LBC);
  LineProc[24]:=Unaligned(@LineS24LBC);
  LineProc[25]:=Unaligned(@LineS25LBC);
  LineProc[26]:=Unaligned(@LineS26LBC);
  LineProc[27]:=Unaligned(@LineS27LBC);
  LineProc[28]:=Unaligned(@LineS28LBC);
  LineProc[29]:=Unaligned(@LineS29LBC);
  {-90°..-135°}
  LineProc[30]:=Unaligned(@LineS30   );
  LineProc[31]:=Unaligned(@LineS31LBC);
  LineProc[32]:=Unaligned(@LineS32LBC);
  LineProc[33]:=Unaligned(@LineS33LBC);
  LineProc[34]:=Unaligned(@LineS34LBC);
  LineProc[35]:=Unaligned(@LineS35LBC);
  LineProc[36]:=Unaligned(@LineS36LBC);
  LineProc[37]:=Unaligned(@LineS37LBC);
  LineProc[38]:=Unaligned(@LineS38LBC);
  LineProc[39]:=Unaligned(@LineS39LBC);

end; {$endregion}

//
procedure TFastLine.SwapArgs (x0,y0,x1,y1:double); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Swap1(r0,r1);
  Swap1(p0,p1);
  Swap3(x0,x1);
  Swap3(y0,y1);
end; {$endregion}

//
procedure TFastLine.GetLCoef0(x0,y0,x1,y1:double); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  dx_:=x1-x0;
  dy_:=y1-y0;
  k_ :=dy_/dx_;
  b_ :=y0-x0*k_;
end; {$endregion}
procedure TFastLine.GetLCoef1;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
 {t0  :=Trunc(x0_);
  t1  :=Trunc(x1_);
  n_  :=k_*t0+b_;}
  t_k_:=Trunc($10000*k_);
  t_b_:=Trunc($10000*b_)+$111;
  j0  :=t_k_*{t0}r0+t_b_;
end; {$endregion}
procedure TFastLine.GetLCoef2;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
 {t0   :=Trunc(y0_);
  t1   :=Trunc(y1_);
  k_inv:=1/k_;
  n_   :=(t0-b_)*k_inv;
  m_   :=bmp_dst_width*t0;}
  t_k_ :=Trunc($10000   /k_);
  t_b_ :=Trunc($10000*b_/k_)-$111;
  j0   :=t_k_*{t0}p0-t_b_;
  //j1   :=ln_arr_width*{t0}p0;
end; {$endregion}

// (Move Points) Перемещение точек:
procedure TFastLine.LinePHL00(x0,y0,x1,y1:double); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  GetLCoef0(x0,y0,x1,y1);

  {Nearly Horizontal Line} {$region -fold}
  if (Abs(dx_)>=Abs(dy_)) then
    begin
      r0:=Trunc(x0);
      r1:=Trunc(x1);
      if (x1<x0) then
        SwapArgs(x0,y0,x1,y1);
      p0:=Trunc (y0);
      if (y1>=p0) and (y1<p0+1) then
        begin
          LineSHL00;
          Exit;
        end;
      GetLCoef1;
      LinePHL01;
    end {$endregion}

  {Nearly Vertical   Line} {$region -fold}
  else
    begin
      p0:=Trunc(y0);
      p1:=Trunc(y1);
      if (y1<y0) then
        SwapArgs(x0,y0,x1,y1);
      r0:=Trunc (x0);
      if (x1>=r0) and (x1<r0+1) then
        begin
          LineSVL00;
          Exit;
        end;
      GetLCoef2;
      LinePHL02;
    end; {$endregion}

end; {$endregion}
procedure TFastLine.LinePHL01;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_arr0_ptr2: PByte;
  i           : integer;
begin
  i           :=r0;
  ln_arr0_ptr2:=ln_arr0_ptr+r0;
  while (i<=r1) do
    begin
     (ln_arr0_ptr2+bmp_dst_width*(j0>>16))^:=1;
      j0                                   +=t_k_;
      i                                    +=1;
      ln_arr0_ptr2                         +=1;
    end;
end; {$endregion}
procedure TFastLine.LinePHL02;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_arr0_ptr2: PByte;
  i           : integer;
begin
  i           :=p0;
  ln_arr0_ptr2:=ln_arr0_ptr+bmp_dst_width*p0;
  while (i<=p1) do
    begin
     (ln_arr0_ptr2+(j0>>16))^:=1;
      j0                     +=t_k_;
      i                      +=1;
      ln_arr0_ptr2           +=bmp_dst_width;
    end;
end; {$endregion}

// (Select Points) Выделение точек:
procedure TFastLine.LinePHL10(x0,y0,x1,y1:double); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  // Some explanations:
  // case val-=1 will be some faster then assignment val:=-1,
  // thus i was forced to create separate procedures/functions for such cases,
  // instead of creating a single procedure with an assignment val:=...:

  GetLCoef0(x0,y0,x1,y1);

  {Nearly Horizontal Line} {$region -fold}
  if (Abs(dx_)>=Abs(dy_)) then
    begin
      r0:=Trunc(x0);
      r1:=Trunc(x1);
      if (x1<x0) then
        SwapArgs(x0,y0,x1,y1);
      p0:=Trunc (y0);
      if (y1>=p0) and (y1<p0+1) then
        begin
          LineSHL10;
          Exit;
        end;
      GetLCoef1;
      LinePHL11;
    end {$endregion}

  {Nearly Vertical   Line} {$region -fold}
  else
    begin
      p0:=Trunc(y0);
      p1:=Trunc(y1);
      if (y1<y0) then
        SwapArgs(x0,y0,x1,y1);
      r0:=Trunc (x0);
      if (x1>=r0) and (x1<r0+1) then
        begin
          LineSVL10;
          Exit;
        end;
      GetLCoef2;
      LinePHL12;
    end; {$endregion}

end; {$endregion}
procedure TFastLine.LinePHL11;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_arr1_ptr2: PInteger;
  i           :  integer;
begin
  i           :=r0;
  ln_arr1_ptr2:=ln_arr1_ptr+r0;
  while (i<=r1) do
    begin
     (ln_arr1_ptr2+bmp_dst_width*(j0>>16))^-=1;
      j0                                   +=t_k_;
      i                                    +=1;
      ln_arr1_ptr2                         +=1;
    end;
end; {$endregion}
procedure TFastLine.LinePHL12;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_arr1_ptr2: PInteger;
  i           :  integer;
begin
  i           :=p0;
  ln_arr1_ptr2:=ln_arr1_ptr+bmp_dst_width*p0;
  while (i<=p1) do
    begin
     (ln_arr1_ptr2+(j0>>16))^-=1;
      j0                     +=t_k_;
      i                      +=1;
      ln_arr1_ptr2           +=bmp_dst_width;
    end;
end; {$endregion}

// (Unselect Points) Снятие выделения точек:
procedure TFastLine.LinePHL20(x0,y0,x1,y1:double); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  GetLCoef0(x0,y0,x1,y1);

  {Nearly Horizontal Line} {$region -fold}
  if (Abs(dx_)>=Abs(dy_)) then
    begin
      r0:=Trunc(x0);
      r1:=Trunc(x1);
      if (x1<x0) then
        SwapArgs(x0,y0,x1,y1);
      p0:=Trunc (y0);
      if (y1>=p0) and (y1<p0+1) then
        begin
          LineSHL20;
          Exit;
        end;
      GetLCoef1;
      LinePHL21;
    end {$endregion}

  {Nearly Vertical   Line} {$region -fold}
  else
    begin
      p0:=Trunc(y0);
      p1:=Trunc(y1);
      if (y1<y0) then
        SwapArgs(x0,y0,x1,y1);
      r0:=Trunc (x0);
      if (x1>=r0) and (x1<r0+1) then
        begin
          LineSVL20;
          Exit;
        end;
      GetLCoef2;
      LinePHL22;
    end; {$endregion}

end; {$endregion}
procedure TFastLine.LinePHL21;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_arr1_ptr2: PInteger;
  i           :  integer;
begin
  i           :=r0;
  ln_arr1_ptr2:=ln_arr1_ptr+r0;
  while (i<=r1) do
    begin
     (ln_arr1_ptr2+bmp_dst_width*(j0>>16))^+=1;
      j0                                   +=t_k_;
      i                                    +=1;
      ln_arr1_ptr2                         +=1;
    end;
end; {$endregion}
procedure TFastLine.LinePHL22;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_arr1_ptr2: PInteger;
  i           :  integer;
begin
  i           :=p0;
  ln_arr1_ptr2:=ln_arr1_ptr+bmp_dst_width*p0;
  while (i<=p1) do
    begin
     (ln_arr1_ptr2+(j0>>16))^+=1;
      j0                     +=t_k_;
      i                      +=1;
      ln_arr1_ptr2           +=bmp_dst_width;
    end;
end; {$endregion}

// (Direct Pixel Write) Непосредственная запись в битовую карту:
procedure TFastLine.LinePHL30(x0,y0,x1,y1:double); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  GetLCoef0(x0,y0,x1,y1);

  {Nearly Horizontal Line} {$region -fold}
  if (Abs(dx_)>=Abs(dy_)) then
    begin
      r0:=Trunc(x0);
      r1:=Trunc(x1);
      if (x1<x0) then
        SwapArgs(x0,y0,x1,y1);
      p0:=Trunc (y0);
      if (y1>=p0) and (y1<p0+1) then
        begin
          LineSHL30;
          Exit;
        end;
      GetLCoef1;
      LinePHL31;
    end {$endregion}

  {Nearly Vertical   Line} {$region -fold}
  else
    begin
      p0:=Trunc(y0);
      p1:=Trunc(y1);
      if (y1<y0) then
        SwapArgs(x0,y0,x1,y1);
      r0:=Trunc (x0);
      if (x1>=r0) and (x1<r0+1) then
        begin
          LineSVL30;
          Exit;
        end;
      GetLCoef2;
      LinePHL32;
    end; {$endregion}

end; {$endregion}
procedure TFastLine.LinePHL31;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  bmp_dst_ptr2: PInteger;
  i           :  integer;
begin
  i           :=r0;
  bmp_dst_ptr2:=bmp_dst_ptr+{t0}r0;
  while (i<={t1}r1) do
    begin
     (bmp_dst_ptr2+bmp_dst_width*(j0>>16))^:=local_prop.eds_col_inv;
      j0                                   +=t_k_;
      i                                    +=1;
      bmp_dst_ptr2                         +=1;
    end;
 {n_:=k_*t0+b_;
  for i:=t0 to t1 do
    begin
      (bmp_dst_ptr+i+bmp_dst_width*Trunc(n_))^:=local_prop.eds_col_inv;
      n_+=k_;
    end;}
end; {$endregion}
procedure TFastLine.LinePHL32;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  bmp_dst_ptr2: PInteger;
  i           :  integer;
begin
  i           :=p0;
  bmp_dst_ptr2:=bmp_dst_ptr+bmp_dst_width*{t0}p0;
  while (i<={t1}p1) do
    begin
     (bmp_dst_ptr2+(j0>>16))^:=local_prop.eds_col_inv;
      j0                     +=t_k_;
      i                      +=1;
      bmp_dst_ptr2           +=bmp_dst_width;
    end;
 {for i:=t0 to t1 do
    begin
      (bmp_dst_ptr+Trunc(n_)+m_)^:=local_prop.eds_col_inv;
      n_+=k_inv;
      m_+=bmp_dst_width;
    end;}
end; {$endregion}

// (Advanced Byte Mode) Продвинутый байт-режим:
procedure TFastLine.LinePHL40(x0,y0,x1,y1:double); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  GetLCoef0(x0,y0,x1,y1);

  {Nearly Horizontal Line} {$region -fold}
  if (Abs(dx_)>=Abs(dy_)) then
    begin
      r0:=Trunc(x0);
      r1:=Trunc(x1);
      if (x1<x0) then
        SwapArgs(x0,y0,x1,y1);
      p0:=Trunc (y0);
      if (y1>=p0) and (y1<p0+1) then
        begin
          LineSHL40;
          Exit;
        end;
      GetLCoef1;
      LinePHL41;
    end {$endregion}

  {Nearly Vertical   Line} {$region -fold}
  else
    begin
      p0:=Trunc(y0);
      p1:=Trunc(y1);
      if (y1<y0) then
        SwapArgs(x0,y0,x1,y1);
      r0:=Trunc (x0);
      if (x1>=r0) and (x1<r0+1) then
        begin
          LineSVL40;
          Exit;
        end;
      GetLCoef2;
      LinePHL42;
    end; {$endregion}

end; {$endregion}
procedure TFastLine.LinePHL41;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_arr0_ptr2: PByte;
  i           : integer;
begin
  i           :=r0;
  ln_arr0_ptr2:=ln_arr0_ptr+r0;
  while (i<=r1) do
    begin
     (ln_arr0_ptr2+bmp_dst_width*(j0>>16))^+=1;
      j0                                   +=t_k_;
      i                                    +=1;
      ln_arr0_ptr2                         +=1;
    end;
end; {$endregion}
procedure TFastLine.LinePHL42;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_arr0_ptr2: PByte;
  i           : integer;
begin
  i           :=p0;
  ln_arr0_ptr2:=ln_arr0_ptr+bmp_dst_width*p0;
  while (i<=p1) do
    begin
     (ln_arr0_ptr2+(j0>>16))^+=1;
      j0                     +=t_k_;
      i                      +=1;
      ln_arr0_ptr2           +=bmp_dst_width;
    end;
end; {$endregion}

{Right Bottom Corner}

{0°..-45°}
// 0: out of grid
procedure TFastLine.LineS00;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// 1: (c_n)
procedure TFastLine.LineS01RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
 {dx+1:=a*c;
  dy+1:=a;}
  for i:=0 to a-2 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 2: (c_n,c+1)
procedure TFastLine.LineS02RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a:=a*b*c+a*(c+1):=a((b+1)*c+1);
  dy+1:=a*(b+1);
  Если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1), что легко доказать.
  "Пусть a<>НСД(dx+1,dy+1), тогда dy+1:=a*r*v1, dx+1:=a*r*v2=a*(r*v1*c+1), что невозможно."
  Последующие доказательства в остальных процедурах проводятся аналогичным образом.}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 3: ((c+1)_n,c)
procedure TFastLine.LineS03RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*b:=a*c+a*b*(c+1):=a((b+1)*c+b);
  dy+1:=a*(b+1);
  Очевидно, что если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1)}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 4: ((c,c+1)_n,c+1)
procedure TFastLine.LineS04RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*(b+1):=a*b*c+a*(b+1)*(c+1):=a((2*b+1)*c+b+1);
  dy+1:=a*(2*b+1);
  Очевидно, что если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1)}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 5: ((c,c+1)_n,c)
procedure TFastLine.LineS05RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*b:=a*(b+1)*c+a*b*(c+1):=a((2*b+1)*c+b);
  dy+1:=a*(2*b+1);
  Очевидно, что если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1)}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 6: ((c,c+1,c)_n,c+1)
procedure TFastLine.LineS06RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*(b+1):=a*2*b*c+a*(b+1)*(c+1):=a((3*b+1)*c+b+1);
  dy+1:=a*(3*b+1);
  Очевидно, что если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1)}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 7: ((c,c+1,c)_n,c)
procedure TFastLine.LineS07RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*(b+1):=a*(2*b+1)*c+a*b*(c+1):=a((3*b+1)*c+b);
  dy+1:=a*(3*b+1);
  Очевидно, что если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1)}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 8: ((c,c+1,c+1)_n,c+1)
procedure TFastLine.LineS08RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*(b+1):=a*b*c+a*(2*b+1)*(c+1):=a((3*b+1)*c+2*b+1);
  dy+1:=a*(3*b+1);
  Очевидно, что если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1)}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 9: ((c+1,c,c+1)_n,c)
procedure TFastLine.LineS09RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*(b+1):=a*(b+1)*c+a*2*b*(c+1):=a((3*b+1)*c+2*b);
  dy+1:=a*(3*b+1);
  Очевидно, что если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1)}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
{-45°..-90°}
// 10: out of grid
procedure TFastLine.LineS10;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// 11: (c_n)
procedure TFastLine.LineS11RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    FillByte(ln_arr2[p0+i+g,r0+i*c-g],c,1);
end; {$endregion}
// 12: (c_n,c+1)
procedure TFastLine.LineS12RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        FillByte(ln_arr2[p0+i*(b+1)+j+g,r0+i*((b+1)*c+1)+c*j-g],c+0,1);
        FillByte(ln_arr2[p0+i*(b+1)+b+g,r0+i*((b+1)*c+1)+c*b-g],c+1,1);
    end;
end; {$endregion}
// 13: ((c+1)_n,c)
procedure TFastLine.LineS13RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        FillByte(ln_arr2[p0+i*(b+1)+j+g,r0+i*((b+1)*(c+1)-1)+(c+1)*j-g],c+1,1);
        FillByte(ln_arr2[p0+i*(b+1)+b+g,r0+i*((b+1)*(c+1)-1)+(c+1)*b-g],c+0,1);
    end;
end; {$endregion}
// 14: ((c,c+1)_n,c+1)
procedure TFastLine.LineS14RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+(2*b+1)*i+2*j+0+g,r0+(b*(2*c+1)+c+1)*i+(2*c+1)*j+0-g],c+0,1);
          FillByte(ln_arr2[p0+(2*b+1)*i+2*j+1+g,r0+(b*(2*c+1)+c+1)*i+(2*c+1)*j+c-g],c+1,1);
        end;
      FillByte(ln_arr2[p0+(2*b+1)*i+2*b+g,r0+(b*(2*c+1)+c+1)*i+(2*c+1)*b-g],c+1,1);
    end;
end; {$endregion}
// 15: ((c,c+1)_n,c)
procedure TFastLine.LineS15RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+(2*b+1)*i+2*j+0+g,r0+(b*(2*c+1)+c)*i+(2*c+1)*j+0-g],c+0,1);
          FillByte(ln_arr2[p0+(2*b+1)*i+2*j+1+g,r0+(b*(2*c+1)+c)*i+(2*c+1)*j+c-g],c+1,1);
        end;
      FillByte(ln_arr2[p0+(2*b+1)*i+2*b+g,r0+(b*(2*c+1)+c)*i+(2*c+1)*b-g],c,1);
    end;
end; {$endregion}
// 16: ((c,c+1,c)_n,c+1)
procedure TFastLine.LineS16RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+0+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*j+0  +0-g],c+0,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+1+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*j+c  +0-g],c+1,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+2+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*j+c*2+1-g],c+0,1);
        end;
      FillByte(ln_arr2[p0+(3*b+1)*i+3*b+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*b-g],c+1,1);
    end;
end; {$endregion}
// 17: ((c,c+1,c)_n,c)
procedure TFastLine.LineS17RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+0+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*j+00000-g],c+0,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+1+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*j+c+000-g],c+1,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+2+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*j+c*2+1-g],c+0,1);
        end;
      FillByte(ln_arr2[p0+(3*b+1)*i+3*b+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*b-g],c,1);
    end;
end; {$endregion}
// 18: ((c,c+1,c+1)_n,c+1)
procedure TFastLine.LineS18RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+0+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*j+00000-g],c+0,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+1+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*j+c+000-g],c+1,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+2+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*j+c*2+1-g],c+1,1);
        end;
      FillByte(ln_arr2[p0+(3*b+1)*i+3*b+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*b-g],c+1,1);
    end;
end; {$endregion}
// 19: ((c+1,c,c+1)_n,c)
procedure TFastLine.LineS19RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+0+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*j+00000-g],c+1,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+1+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*j+c+001-g],c+0,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+2+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*j+c*2+1-g],c+1,1);
        end;
      FillByte(ln_arr2[p0+(3*b+1)*i+3*b+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*b-g],c,1);
    end;
end; {$endregion}

{Left Bottom Corner}

{-135°..-180°}
// 20: out of grid
procedure TFastLine.LineS20;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// 21: (c_n)
procedure TFastLine.LineS21LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 22: (c_n,c+1)
procedure TFastLine.LineS22LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-2 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-2 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c+0,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 23: ((c+1)_n,c)
procedure TFastLine.LineS23LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-2 do
        begin
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  for j:=0 to b-2 do
    begin
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m1);
  FillByte(ln_arr0_ptr^,c+0,1);
end; {$endregion}
// 24: ((c,c+1)_n,c+1)
procedure TFastLine.LineS24LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-2 do
        begin
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-2 do
    begin
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c+0,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 25: ((c,c+1)_n,c)
procedure TFastLine.LineS25LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 26: ((c,c+1,c)_n,c+1)
procedure TFastLine.LineS26LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-2 do
        begin
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-2 do
    begin
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c+0,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m1);
  FillByte(ln_arr0_ptr^,c+0,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 27: ((c,c+1,c)_n,c)
procedure TFastLine.LineS27LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 28: ((c,c+1,c+1)_n,c+1)
procedure TFastLine.LineS28LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-2 do
        begin
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-2 do
    begin
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c+0,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 29: ((c+1,c,c+1)_n,c)
procedure TFastLine.LineS29LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-2 do
        begin
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  for j:=0 to b-2 do
    begin
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m1);
  FillByte(ln_arr0_ptr^,c+0,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m1);
  FillByte(ln_arr0_ptr^,c+0,1);
end; {$endregion}
{-90°..-135°}
// 30: out of grid
procedure TFastLine.LineS30;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// 31: (c_n)
procedure TFastLine.LineS31LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    FillByte(ln_arr2[p0-i+g,r0+i*c-g],c,1);
end; {$endregion}
// 32: (c_n,c+1)
procedure TFastLine.LineS32LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        FillByte(ln_arr2[p0-i*(b+1)-j+g,r0+i*((b+1)*c+1)+c*j-g],c+0,1);
        FillByte(ln_arr2[p0-i*(b+1)-b+g,r0+i*((b+1)*c+1)+c*b-g],c+1,1);
    end;
end; {$endregion}
// 33: ((c+1)_n,c)
procedure TFastLine.LineS33LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        FillByte(ln_arr2[p0-i*(b+1)-j+g,r0+i*((b+1)*(c+1)-1)+(c+1)*j-g],c+1,1);
        FillByte(ln_arr2[p0-i*(b+1)-b+g,r0+i*((b+1)*(c+1)-1)+(c+1)*b-g],c+0,1);
    end;
end; {$endregion}
// 34: ((c,c+1)_n,c+1)
procedure TFastLine.LineS34LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0-(2*b+1)*i-2*j+0+g,r0+(b*(2*c+1)+c+1)*i+(2*c+1)*j+0-g],c+0,1);
          FillByte(ln_arr2[p0-(2*b+1)*i-2*j-1+g,r0+(b*(2*c+1)+c+1)*i+(2*c+1)*j+c-g],c+1,1);
        end;
      FillByte(ln_arr2[p0-(2*b+1)*i-2*b+g,r0+(b*(2*c+1)+c+1)*i+(2*c+1)*b-g],c+1,1);
    end;
end; {$endregion}
// 35: ((c,c+1)_n,c)
procedure TFastLine.LineS35LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0-(2*b+1)*i-2*j+0+g,r0+(b*(2*c+1)+c)*i+(2*c+1)*j+0-g],c+0,1);
          FillByte(ln_arr2[p0-(2*b+1)*i-2*j-1+g,r0+(b*(2*c+1)+c)*i+(2*c+1)*j+c-g],c+1,1);
        end;
      FillByte(ln_arr2[p0-(2*b+1)*i-2*b+g,r0+(b*(2*c+1)+c)*i+(2*c+1)*b-g],c,1);
    end;
end; {$endregion}
// 36: ((c,c+1,c)_n,c+1)
procedure TFastLine.LineS36LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j+0+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*j+00000-g],c+0,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-1+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*j+c+000-g],c+1,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-2+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*j+c*2+1-g],c+0,1);
        end;
      FillByte(ln_arr2[p0-(3*b+1)*i-3*b+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*b-g],c+1,1);
    end;
end; {$endregion}
// 37: ((c,c+1,c)_n,c)
procedure TFastLine.LineS37LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j+0+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*j+00000-g],c+0,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-1+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*j+c+000-g],c+1,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-2+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*j+c*2+1-g],c+0,1);
        end;
      FillByte(ln_arr2[p0-(3*b+1)*i-3*b+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*b-g],c,1);
    end;
end; {$endregion}
// 38: ((c,c+1,c+1)_n,c+1)
procedure TFastLine.LineS38LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j+0+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*j+00000-g],c+0,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-1+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*j+c+000-g],c+1,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-2+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*j+c*2+1-g],c+1,1);
        end;
      FillByte(ln_arr2[p0-(3*b+1)*i-3*b+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*b-g],c+1,1);
    end;
end; {$endregion}
// 39: ((c+1,c,c+1)_n,c)
procedure TFastLine.LineS39LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j+0+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*j+00000-g],c+1,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-1+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*j+c+001-g],c+0,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-2+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*j+c*2+1-g],c+1,1);
        end;
      FillByte(ln_arr2[p0-(3*b+1)*i-3*b+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*b-g],c,1);
    end;
end; {$endregion}

// (Solid Line Drawing) Рисование сплошной линии:
procedure TFastLine.LineSMN(constref x0,y0,x1,y1:integer);                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  dx_abs,dy_abs: longword;

label
  l1;

  procedure SetArgs; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    r0:=x0;
    p0:=y0;
    r1:=x1;
    p1:=y1;
  end; {$endregion}

begin
  dx    :=x1-x0;
  dy    :=y1-y0;
  dx_abs:=Abs(dx);
  dy_abs:=Abs(dy);
  if (dy_abs<<9<dx_abs*229) then
    begin
      if (dy>0) then {$region -fold}
        begin
          ln_kind_ptr:=Unaligned(@gcd_arr[dx_abs+dy*ln_arr_width].f_ln_kind);
          if (ln_kind_ptr^=0) or (ln_kind_ptr^=10) then
            goto l1
          else
            begin
              ln_arr0_ptr:=Unaligned(@ln_arr0[x0+y0*ln_arr_width]);
              a:=(ln_kind_ptr+1)^;
              b:=(ln_kind_ptr+2)^;
              c:=(ln_kind_ptr+3)^;
              {0°..-45°}
              if (dx>0) then
                begin
                  m1:=ln_arr_width+c+0;
                  m2:=ln_arr_width+c+1;
                  LineProc[ln_kind_ptr^];
                  Exit;
                end;
              {-135°..-180°}
              if (dx<0) then
                begin
                  m1:=ln_arr_width-c-0;
                  m2:=ln_arr_width-c-1;
                  LineProc[ln_kind_ptr^+20];
                  Exit;
                end;
            end;
        end; {$endregion}
      if (dy<0) then {$region -fold}
        begin
          ln_kind_ptr:=Unaligned(@gcd_arr[dx_abs-dy*ln_arr_width].f_ln_kind);
          if (ln_kind_ptr^=0) or (ln_kind_ptr^=10) then
            goto l1
          else
            begin
              ln_arr0_ptr:=Unaligned(@ln_arr0[x1+y1*ln_arr_width]);
              a:=(ln_kind_ptr+1)^;
              b:=(ln_kind_ptr+2)^;
              c:=(ln_kind_ptr+3)^;
              {-180°..-225°}
              if (dx<0) then
                begin
                  m1:=ln_arr_width+c+0;
                  m2:=ln_arr_width+c+1;
                  LineProc[ln_kind_ptr^];
                  Exit;
                end;
              {-315°..-360°}
              if (dx>0) then
                begin
                  m1:=ln_arr_width-c-0;
                  m2:=ln_arr_width-c-1;
                  LineProc[ln_kind_ptr^+20];
                  Exit;
                end;
            end;
        end; {$endregion}
      {Horizontal Line}
      if (dy=0) then {$region -fold}
        begin
          if (dx>0) then
            FillByte(ln_arr0[x0+y0*ln_arr_width],1+dx,1)
          else
            FillByte(ln_arr0[x1+y1*ln_arr_width],1-dx,1);
          Exit;
        end; {$endregion}
    end
  else
  if (dx_abs<<9<dy_abs*229) then
    begin
      if (dy>0) then {$region -fold}
        begin
          ln_kind_ptr:=Unaligned(@gcd_arr[dx_abs+dy*ln_arr_width].f_ln_kind);
          if (ln_kind_ptr^=0) or (ln_kind_ptr^=10) then
            goto l1
          else
            begin
              a:=(ln_kind_ptr+1)^;
              b:=(ln_kind_ptr+2)^;
              c:=(ln_kind_ptr+3)^;
              {-45°..-90°}
              if (dx>0) then
                begin
                  r0:=x0;
                  p0:=y0;
                  g :=r0-p0;
                  LineProc[ln_kind_ptr^+00];
                  Exit;
                end;
              {-90°..-135°}
              if (dx<0) then
                begin
                  r0:=x0;
                  p0:=y0;
                  g :=r0-p0;
                  LineProc[ln_kind_ptr^+20];
                  Exit;
                end;
              {Vertical Line Down}
              if (dx=0) then
                begin
                  FillByte(ln_arr2[x0,y0],dy,1);
                  Exit;
                end;
            end;
        end; {$endregion}
      if (dy<0) then {$region -fold}
        begin
          ln_kind_ptr:=Unaligned(@gcd_arr[dx_abs-dy*ln_arr_width].f_ln_kind);
          if (ln_kind_ptr^=0) or (ln_kind_ptr^=10) then
            goto l1
          else
            begin
              a:=(ln_kind_ptr+1)^;
              b:=(ln_kind_ptr+2)^;
              c:=(ln_kind_ptr+3)^;
              {-225°..-270°}
              if (dx<0) then
                begin
                  r0:=y1;
                  p0:=x1;
                  g :=00;
                  LineProc[ln_kind_ptr^+00];
                  Exit;
                end;
              {-270°..-315°}
              if (dx>0) then
                begin
                  r0:=y1;
                  p0:=x1;
                  g :=00;
                  LineProc[ln_kind_ptr^+20];
                  Exit;
                end;
              {Vertical Line Up}
              if (dx=0) then
                begin
                  FillByte(ln_arr2[x1,y1],-dy,1);
                  Exit;
                end;
            end;
        end; {$endregion}
    end
  else {$region -fold}
    begin
      l1:
      SetArgs;
      ln_arr0_ptr:=Unaligned(@ln_arr0[0]);
      LinePHL40(x0,y0,x1,y1);
      Exit;
    end; {$endregion}
end; {$endregion}
procedure TFastLine.LineSME(constref x0,y0,x1,y1:integer; constref proc_ptr_a,proc_ptr_b,proc_ptr_c:TProc0); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  LineSMN(x0,y0,x1,y1);
end; {$endregion}

// Fast Line Solid Horizontal(Width - 1 pixel):
procedure TFastLine.LineSHL00; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FillByte(ln_arr0[r0+p0*ln_arr_width],r1-r0+1,1);
end; {$endregion}
procedure TFastLine.LineSHL10; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PInteger;
  i       : integer;
begin
  f_ln_ptr:=Unaligned(@ln_arr1_ptr[r0+p0*ln_arr_width]);
  for i:=0 to r1-r0 do
    (f_ln_ptr+i)^-=1;
end; {$endregion}
procedure TFastLine.LineSHL20; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PInteger;
  i       : integer;
begin
  f_ln_ptr:=Unaligned(@ln_arr1_ptr[r0+p0*ln_arr_width]);
  for i:=0 to r1-r0 do
    (f_ln_ptr+i)^+=1;
end; {$endregion}
procedure TFastLine.LineSHL30; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FillDWord((bmp_dst_ptr+r0+p0*bmp_dst_width)^,r1-r0+1,local_prop.eds_col_inv);
end; {$endregion}
procedure TFastLine.LineSHL40; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PByte;
  i       : integer;
begin
  f_ln_ptr:=Unaligned(@ln_arr0[r0+p0*ln_arr_width]);
  for i:=0 to r1-r0 do
    (f_ln_ptr+i)^+=1;
end; {$endregion}

// Fast Line Solid Vertical(Width - 1 pixel):
procedure TFastLine.LineSVL00; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PByte;
  i       : integer;
begin
  f_ln_ptr:=Unaligned(@ln_arr0[r0+p0*ln_arr_width]);
  for i:=0 to p1-p0 do
    begin
      f_ln_ptr^:=1;
      Inc(f_ln_ptr,ln_arr_width);
    end;
end; {$endregion}
procedure TFastLine.LineSVL10; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PInteger;
  i       : integer;
begin
  f_ln_ptr:=Unaligned(@ln_arr1_ptr[r0+p0*ln_arr_width]);
  for i:=0 to p1-p0 do
    begin
      f_ln_ptr^-=1;
      Inc(f_ln_ptr,ln_arr_width);
    end;
end; {$endregion}
procedure TFastLine.LineSVL20; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PInteger;
  i       : integer;
begin
  f_ln_ptr:=Unaligned(@ln_arr1_ptr[r0+p0*ln_arr_width]);
  for i:=0 to p1-p0 do
    begin
      f_ln_ptr^+=1;
      Inc(f_ln_ptr,ln_arr_width);
    end;
end; {$endregion}
procedure TFastLine.LineSVL30; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PInteger;
  i       : integer;
begin
  f_ln_ptr:=bmp_dst_ptr+r0+p0*bmp_dst_width;
  for i:=0 to p1-p0 do
    begin
      f_ln_ptr^:=local_prop.eds_col_inv;
      Inc(f_ln_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure TFastLine.LineSVL40; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PByte;
  i       : integer;
begin
  f_ln_ptr:=Unaligned(@ln_arr0[r0+p0*ln_arr_width]);
  for i:=0 to p1-p0 do
    begin
      f_ln_ptr^+=1;
      Inc(f_ln_ptr,ln_arr_width);
    end;
end; {$endregion}

{Fast Line Clipping}

// Sobkow-Pospisil-Yang Algorithm:
procedure TFastLine.ClippedLine1(x0,y0,x1,y1:integer; const rct_clp:TPtRect; constref proc1:TProc3; constref proc2,proc3,proc4:TProc0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_code: integer{byte}=0;

  procedure ClipLine    (                            var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    proc1(v0,w0,v1,w1,proc2,proc3,proc4);
  end; {$endregion}
  procedure Clip0_Left  (const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    w0+=Trunc(((w1-w0)*(custom_rect2.left-v0))/(v1-v0));
    v0:=custom_rect2.left;
  end; {$endregion}
  procedure Clip0_Top   (const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // inline induces SIGFPE ERROR in outer procedure
  begin
    v0+=Trunc(((v1-v0)*(custom_rect2.bottom-w0))/(w1-w0));
    w0:=custom_rect2.bottom;
  end; {$endregion}
  procedure Clip0_Right (const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    w0+=Trunc(((w1-w0)*(custom_rect2.right-v0))/(v1-v0));
    v0:=custom_rect2.right;
  end; {$endregion}
  procedure Clip0_Bottom(const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    v0+=Trunc(((v1-v0)*(custom_rect2.top-w0))/(w1-w0));
    w0:=custom_rect2.top;
  end; {$endregion}
  procedure Clip1_Left  (const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    w1+=Trunc(((w0-w1)*(custom_rect2.left-v1))/(v0-v1));
    v1:=custom_rect2.left;
  end; {$endregion}
  procedure Clip1_Top   (const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    v1+=Trunc(((v0-v1)*(custom_rect2.bottom-w1))/(w0-w1));
    w1:=custom_rect2.bottom;
  end; {$endregion}
  procedure Clip1_Right (const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    w1+=Trunc(((w0-w1)*(custom_rect2.right-v1))/(v0-v1));
    v1:=custom_rect2.right;
  end; {$endregion}
  procedure Clip1_Bottom(const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    v1+=Trunc(((v0-v1)*(custom_rect2.top-w1))/(w0-w1));
    w1:=custom_rect2.top;
  end; {$endregion}

begin
  {$region -fold}
  {Fast Clipping Algorithm}

   (*
    Алгоритм быстрого отсечения FC(Fast Clipping) Собкова-Поспишила-Янга
  (Sobkow-Pospisil-Yang), с кодированием линий. Отсекает отрезок, заданный
  координатами его точек (x0,y0), (x1,y1), по окну custom_rect.
    * Clip0_A - перемещение начальной точки (x0,y0) в точку пересечения отрезка
  со стороной A;
    * Clip1_A - перемещение конечной точки (x1,y1) в точку пересечения отрезка
  со стороной A;
    Схема кодирования концов отрезков:

                          1001    |  1000   |  1010
                                  |         |
                           0x9    |   0x8   |   0xA
                          _ _ _ _1| _ _ _ _2| _ _ _ _3
                                  |         |
                          0001    |  0000   |  0010
                                  |         |
                           0x1    |   0x0   |   0x2
                          _ _ _ _4| _ _ _ _5| _ _ _ _6
                                  |         |
                          0101    |  0100   |  0110
                                  |         |
                           0x5    |   0x4   |   0x6
                                 7|        8|        9

    Отрезок видим только в области 5, т.е. отрезок, координаты которого
  удовлетворяют условиям:

        Rect.Left < X < Rect.Right    и    Rect.Bottom < Y < Rect.Top,

  но поскольку в Lazarus-е координата Y отсчитывается от верхнего левого
  угла, то последнее неравенство перепишем как

                         Rect.Bottom > Y > Rect.Top,

  (Это обстоятельство также учтено в коде подпрограммы!!!)
    Каждая конечная точка отрезка V0V1 окажется с одной из этих областей.
  Комбинация кодов концов отрезка, называемая кодом линии, используется для
  определения возможных вариантов расположения отрезка и, следовательно,
  отсечения. Код линии формируется из кодов концов отрезка следующим образом:

                 LineCode(V0,V1) = (Code(V0) × 16) + Code(V1),

  здесь Code(V1) обозначает код конечной точки V1, Code(V0) × 16 означает сдвиг
  кода начальной точки V0 влево на 4 разряда.
    Так как каждый код может принимать одно из 9 значений, то всего имеется
  81 возможный вариант расположения отрезка.
   *)

  {Вычисление значения Code - кода отрезка.
  Биты 0-3 - для конечной точки(x1,y1), 4-7 - для начальной точки(x0,y0);}

  if (y1>rct_clp.Bottom) then
    line_code+=8
  else
    if (y1<rct_clp.Top) then
      line_code+=4;

  if (x1>rct_clp.Right) then
    line_code+=2
  else
    if (x1<rct_clp.Left) then
      line_code+=1;

  if (y0>rct_clp.Bottom) then
    line_code+=128
  else
    if (y0<rct_clp.Top) then
      line_code+=64;

  if (x0>rct_clp.Right) then
    line_code+=32
  else
    if (x0<rct_clp.Left) then
      line_code+=16;

  {Отсечение для каждого из 81-го случаев}
  case line_code of

    {Из центра}

    $00:
      begin
        ClipLine(x0,y0,x1,y1);
        Exit;
      end;
    $01:
      begin
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        ClipLine  (        x0,y0,x1,y1);
        Exit;
      end;
    $02:
      begin
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $04:
      begin
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $05:
      begin
        Clip1_Left    (rct_clp,x0,y0,x1,y1);
        if (y1<        rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $06:
      begin
        Clip1_Right   (rct_clp,x0,y0,x1,y1);
        if (y1<        rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $08:
      begin
        Clip1_Top(rct_clp,x0,y0,x1,y1);
        ClipLine (        x0,y0,x1,y1);
        Exit;
      end;
    $09:
      begin
        Clip1_Left (rct_clp,x0,y0,x1,y1);
        if (y1>     rct_clp.Bottom) then
          Clip1_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $0A:
      begin
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        if (y1>     rct_clp.Bottom) then
          Clip1_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;

    {Слева}

    $10:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        ClipLine  (        x0,y0,x1,y1);
        Exit;
      end;
    $11: Exit;                                                 // Отброшен
    $12:
      begin
        Clip0_Left (rct_clp,x0,y0,x1,y1);
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $14:
      begin
        Clip0_Left  (rct_clp,x0,y0,x1,y1);
        if (y0<      rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $15: Exit;                                                 // Отброшен
    $16:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        if (y0<    rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip1_Bottom (rct_clp,x0,y0,x1,y1);
        if (x1>       rct_clp.Right) then
          Clip1_Right(rct_clp,x0,y0,x1,y1);
        ClipLine     (        x0,y0,x1,y1);
        Exit;
      end;
    $18:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        if (y0>    rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip1_Top(rct_clp,x0,y0,x1,y1);
        ClipLine (        x0,y0,x1,y1);
        Exit;
      end;
    $19: Exit;                                                 // Отброшен
    $1A:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        if (y0>    rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip1_Top    (rct_clp,x0,y0,x1,y1);
        if (x1>       rct_clp.Right) then
          Clip1_Right(rct_clp,x0,y0,x1,y1);
        ClipLine     (        x0,y0,x1,y1);
        Exit;
      end;

    {Справа}

    $20:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $21:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        Clip1_Left (rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $22: Exit;                                                 // Отброшен
    $24:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0<     rct_clp.Top) then
          Exit;                                                 // Отброшен
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $25:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0<     rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        if (x1<      rct_clp.Left) then
          Clip1_Left(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $26: Exit;                                                 // Отброшен
    $28:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip1_Top  (rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $29:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip1_Top(rct_clp,x0,y0,x1,y1);
        if (x1<   rct_clp.Left) then
          Clip1_Left(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $2A: Exit;                                                 // Отброшен

    {Снизу}

    $40:
      begin
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $41:
      begin
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (x0<      rct_clp.Left) then
          Exit;                                                // Отброшен
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        if (y1<    rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $42:
      begin
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (x0>      rct_clp.Right) then
          Exit;                                                // Отброшен
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $44: Exit;                                                 // Отброшен
    $45: Exit;                                                 // Отброшен
    $46: Exit;                                                 // Отброшен
    $48:
      begin
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        Clip1_Top   (rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $49:
      begin
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (x0<      rct_clp.Left) then
          Exit;                                                // Отброшен
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        if (y1>    rct_clp.Bottom) then
          Clip1_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $4A:
      begin
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (x0>      rct_clp.Right) then
          Exit;                                                // Отброшен
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        if (y1>     rct_clp.Bottom) then
          Clip1_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;

    {Снизу слева}

    $50:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        if (y0<    rct_clp.Top) then
          Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $51: Exit;                                                 // Отброшен
    $52:
      begin
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        if (y1<     rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (x0<      rct_clp.Left) then
          Clip0_Left(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $54: Exit;                                                 // Отброшен
    $55: Exit;                                                 // Отброшен
    $56: Exit;                                                 // Отброшен
    $58:
      begin
        Clip1_Top(rct_clp,x0,y0,x1,y1);
        if (x1<   rct_clp.Left) then
          Exit;                                                // Отброшен
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (x0<      rct_clp.Left) then
          Clip0_Left(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $59: Exit;                                                 // Отброшен
    $5A:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        if (y0>    rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        if (y1<     rct_clp.Top) then
          Exit;                                                // Отброшен
        if (y0<        rct_clp.Top) then
          Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (y1>        rct_clp.Bottom) then
          Clip1_Top   (rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;

    {Снизу-справа}

    $60:
      begin
        Clip0_Right   (rct_clp,x0,y0,x1,y1);
        if (y0<        rct_clp.Top) then
          Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $61:
      begin
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        if (y1<    rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip0_Bottom (rct_clp,x0,y0,x1,y1);
        if (x0>       rct_clp.Right) then
          Clip0_Right(rct_clp,x0,y0,x1,y1);
        ClipLine     (        x0,y0,x1,y1);
        Exit;
      end;
    $62: Exit;                                                 // Отброшен
    $64: Exit;                                                 // Отброшен
    $65: Exit;                                                 // Отброшен
    $66: Exit;                                                 // Отброшен
    $68:
      begin
        Clip1_Top(rct_clp,x0,y0,x1,y1);
        if (x1>   rct_clp.Right) then
          Exit;                                                // Отброшен
        Clip0_Right   (rct_clp,x0,y0,x1,y1);
        if (y0<        rct_clp.Top) then
          Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $69:
      begin
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        if (y1<    rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Exit;                                                // Отброшен
        if (y1>        rct_clp.Bottom) then
          Clip1_Top   (rct_clp,x0,y0,x1,y1);
        if (y0<        rct_clp.Top) then
          Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $6A: ;                                                     // Отброшен

    {Сверху}

    $80:
      begin
        Clip0_Top(rct_clp,x0,y0,x1,y1);
        ClipLine (        x0,y0,x1,y1);
        Exit;
      end;
    $81:
      begin
        Clip0_Top(rct_clp,x0,y0,x1,y1);
        if (x0<   rct_clp.Left) then
          Exit;                                                // Отброшен
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        ClipLine  (        x0,y0,x1,y1);
        Exit;
      end;
    $82:
      begin
        Clip0_Top(rct_clp,x0,y0,x1,y1);
        if (x0>   rct_clp.Right) then
          Exit;                                                // Отброшен
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $84:
      begin
        Clip0_Top   (rct_clp,x0,y0,x1,y1);
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $85:
      begin
        Clip0_Top(rct_clp,x0,y0,x1,y1);
        if (x0<   rct_clp.Left) then
          Exit;                                                // Отброшен
        Clip1_Left    (rct_clp,x0,y0,x1,y1);
        if (y1<        rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $86:
      begin
        Clip0_Top(rct_clp,x0,y0,x1,y1);
        if (x0>   rct_clp.Right) then
          Exit;                                                // Отброшен
        Clip1_Right   (rct_clp,x0,y0,x1,y1);
        if (y1<        rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $88: Exit;                                                 // Отброшен
    $89: Exit;                                                 // Отброшен
    $8A: Exit;                                                 // Отброшен

    {Сверху-слева}

    $90:
      begin
        Clip0_Left (rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Clip0_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $91: Exit;                                                 // Отброшен
    $92:
      begin
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        if (y1>     rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip0_Top   (rct_clp,x0,y0,x1,y1);
        if (x0<      rct_clp.Left) then
          Clip0_Left(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $94:
      begin
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        if (x1<      rct_clp.Left) then
          Exit;                                                // Отброшен
        Clip0_Left (rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Clip0_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $95: Exit;                                                 // Отброшен
    $96:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        if (y0<    rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        if (y1>     rct_clp.Bottom) then
          Exit;                                                // Отброшен
        if (y0>        rct_clp.Bottom) then
          Clip0_Top   (rct_clp,x0,y0,x1,y1);
        if (y1<        rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $98: Exit;                                                 // Отброшен
    $99: Exit;                                                 // Отброшен
    $9A: Exit;                                                 // Отброшен

    {Сверху-справа}

    $A0:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Clip0_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $A1:
      begin
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        if (y1>    rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip0_Top    (rct_clp,x0,y0,x1,y1);
        if (x0>       rct_clp.Right) then
          Clip0_Right(rct_clp,x0,y0,x1,y1);
        ClipLine     (        x0,y0,x1,y1);
        Exit;
      end;
    $A2: Exit;                                                 // Отброшен
    $A4:
      begin
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        if (x1>      rct_clp.Right) then
          Exit;                                                // Отброшен
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Clip0_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $A5:
      begin
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        if (y1>    rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0<     rct_clp.Top) then
          Exit;                                                // Отброшен
        if (y1<        rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        if (y0>        rct_clp.Bottom) then
          Clip0_Top   (rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $A6: Exit;                                                 // Отброшен
    $A8: Exit;                                                 // Отброшен
    $A9: Exit;                                                 // Отброшен
    $AA: Exit;                                                 // Отброшен

  end;
  {$endregion}
end; {$endregion}

// Matthes-Drakopoulos  Algorithm:
procedure TFastLine.ClippedLine2(x0,y0,x1,y1:integer; const rct_clp:TPtRect; constref proc1:TProc3; constref proc2,proc3,proc4      :TProc0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y: array[0..1] of integer;
  i  : byte;
begin
  if ((not ((x0<rct_clp.left) and (x1<rct_clp.left))) and (not ((x0>rct_clp.right ) and (x1>rct_clp.right )))) and
     ((not ((y0<rct_clp.top ) and (y1<rct_clp.top ))) and (not ((y0>rct_clp.bottom) and (y1>rct_clp.bottom)))) then
    begin
      x[0]:=x0;
      y[0]:=y0;
      x[1]:=x1;
      y[1]:=y1;
      i   :=0;
      repeat
        begin
          if (x[i]<rct_clp.left) then
            begin
              x[i]:=rct_clp.left;
              y[i]:=Trunc(((y1-y0)*(rct_clp.left  -x0))/(x1-x0)+y0);
            end
          else
          if (x[i]>rct_clp.right) then
            begin
              x[i]:=rct_clp.right;
              y[i]:=Trunc(((y1-y0)*(rct_clp.right -x0))/(x1-x0)+y0);
            end;
          if (y[i]<rct_clp.top) then
            begin
              y[i]:=rct_clp.top;
              x[i]:=Trunc(((x1-x0)*(rct_clp.top   -y0))/(y1-y0)+x0);
            end
          else
          if (y[i]>rct_clp.bottom) then
            begin
              y[i]:=rct_clp.bottom;
              x[i]:=Trunc(((x1-x0)*(rct_clp.bottom-y0))/(y1-y0)+x0);
            end;
          i:=i+1;
        end;
      until (i>1);
      if (not ((x[0]<rct_clp.left ) and (x[1]<rct_clp.left ))) and
         (not ((x[0]>rct_clp.right) and (x[1]>rct_clp.right))) then
        proc1(x[0],y[0],x[1],y[1],proc2,proc3,proc4);
    end;
end; {$endregion}
procedure TFastLine.ClippedLine2(x0,y0,x1,y1:double ; const rct_clp:TPtRect;                        constref proc2,proc3,proc4,proc5:TProc0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y      : array[0..1] of double;
  ff0,ff1  : integer;
  chk_bnds : boolean=False;

  procedure OrthoLine(var h0,h1,h2:integer; const h3,h4,h5,h6:integer; prochv:TProc0); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  {var
    rct_out    : TPtRect;
    t0,t1,t2,t3: integer;}
  begin
   {t0:=0;
    t1:=0;
    t2:=0;
    t3:=0;
    case mov_dir of
      mdRight: t2:=-1;
      mdUp   : t1:=-1;
    end;
    rct_out:=PtRct(rct_clp.left  +t0,
                   rct_clp.top   +t1,
                   rct_clp.right +t2,
                   rct_clp.bottom+t3);}
    if (h1<h0) then
      Swap1(h0,h1);
    if (h0<h3) then
      begin
        if (h1<h3) then
          begin
            Exit;
          end;
        if (h1<h4) then
          begin
            h0:=h3;
            prochv;
            Exit;
          end;
        h0:=h3;
        h1:=h4-1;
        prochv;
        Exit;
      end;
    if (h0<h4) then
      begin
        if (h1<h4) then
          begin
            prochv;
            Exit;
          end;
        h1:=h4-1;
        prochv;
        Exit;
      end;
  end; {$endregion}

  function  CheckBounds: boolean;                                                      inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    Result:=((not ((x[0]<rct_clp.left) and (x[1]<rct_clp.left))) and (not ((x[0]>=rct_clp.right ) and (x[1]>=rct_clp.right )))) and
            ((not ((y[0]<rct_clp.top ) and (y[1]<rct_clp.top ))) and (not ((y[0]>=rct_clp.bottom) and (y[1]>=rct_clp.bottom))))
  end; {$endregion}

  procedure SetArgs;                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x[0]:=x0;
    y[0]:=y0;
    x[1]:=x1;
    y[1]:=y1;
  end; {$endregion}

begin

  r0 :=Trunc(x0);
  p0 :=Trunc(y0);
  r1 :=Trunc(x1);
  p1 :=Trunc(y1);
  ff0:=r0;
  ff1:=p0;

  {horizontal line} {$region -fold}
  if (p0=p1) then
    begin
      if (r0=r1) then
        Exit;
      if (p0>=rct_clp.top) and (p0<rct_clp.bottom) then
        OrthoLine(r0,r1,p0,rct_clp.left,rct_clp.right,rct_clp.top,rct_clp.bottom,proc2);
      Exit;
    end; {$endregion}

  {vertical   line} {$region -fold}
  if (r0=r1) then
    begin
      if (p0=p1) then
        Exit;
      if (r0>=rct_clp.left) and (r0<rct_clp.right) then
        OrthoLine(p0,p1,r0,rct_clp.top,rct_clp.bottom,rct_clp.left,rct_clp.right,proc3);
      Exit;
    end; {$endregion}

  {regular    line} {$region -fold}
    begin
      SetArgs;
      if CheckBounds then
        begin
          GetLCoef0(x0,y0,x1,y1);
          if (Abs(dx_)>=Abs(dy_)) then
            begin
              if (x1<x0) then
                begin
                  ff0:=    r1 ;
                  Swap2(r0,r1);
                  Swap3(x0,x1);
                  Swap3(y0,y1);
                  SetArgs;
                end;
              GetLCoef1;
              if (y1>y0) then
                begin
                  if (x[0]<         rct_clp.left    ) then
                    begin
                      y[0]:=       (rct_clp.left-x0 )*k_+y0;
                       r0 :=        rct_clp.left;
                    end;
                  if (y[0]<         rct_clp.top     ) then
                       r0 :=Trunc(((rct_clp.top-1   )<<16-j0+ONE_SHL_16_M_1)/t_k_)+ff0+1;
                  if (x[1]>=        rct_clp.right   ) then
                    begin
                      y[1]:=       (rct_clp.right-x0)*k_+y0;
                       r1 :=        rct_clp.right-1;
                    end;
                  if (y[1]>=        rct_clp.bottom  ) then
                       r1 :=Trunc(((rct_clp.bottom-1)<<16-j0+ONE_SHL_16_M_1)/t_k_)+ff0;
                  if CheckBounds then
                    begin
                      chk_bnds:=True;
                      j0:=t_k_*r0+t_b_;
                      if ((j0>>16)=rct_clp.top-1) then
                        begin
                          r0+=1;
                          j0+=t_k_;
                        end;
                    end;
                end
              else
                begin
                  if (x[0]<         rct_clp.left    ) then
                    begin
                      y[0]:=       (rct_clp.left-x0 )*k_+y0;
                       r0 :=        rct_clp.left;
                    end;
                  if (y[0]>=        rct_clp.bottom  ) then
                       r0 :=Trunc(((rct_clp.bottom-1)<<16-j0+ONE_SHL_16_M_1)/t_k_)+ff0+1;
                  if (x[1]>=        rct_clp.right   ) then
                    begin
                      y[1]:=       (rct_clp.right-x0)*k_+y0;
                       r1 :=        rct_clp.right-1;
                    end;
                  if (y[1]<         rct_clp.top     ) then
                       r1 :=Trunc(((rct_clp.top-1   )<<16-j0+ONE_SHL_16_M_1)/t_k_)+ff0;
                  if CheckBounds then
                    begin
                      chk_bnds:=True;
                      j0  :=t_k_*r0+t_b_;
                      if (((t_k_*r1+t_b_)>>16)=rct_clp.top-1) then
                        r1:=Trunc((rct_clp.top<<16-j0+ONE_SHL_16_M_1)/t_k_)+ff0;
                      if ((j0>>16)=rct_clp.bottom) then
                        begin
                          r0+=1;
                          j0+=t_k_;
                        end;
                    end;
                end;
              if chk_bnds then
                begin
                  if (r1=rct_clp.right) then
                    r1-=1;
                  proc4;
                end;
            end
          else
            begin
              if (y1<y0) then
                begin
                  ff1:=    p1 ;
                  Swap2(p0,p1);
                  Swap3(x0,x1);
                  Swap3(y0,y1);
                  SetArgs;
                end;
              GetLCoef2;
              if (x1>x0) then
                begin
                  if (x[0]<         rct_clp.left    ) then
                    begin
                      y[0]:=       (rct_clp.left-x0 )*k_+y0;
                       p0 :=Trunc(((rct_clp.left-1  )<<16-j0+ONE_SHL_16_M_1)/t_k_)+ff1+1;
                    end;
                  if (y[0]<         rct_clp.top     ) then
                       p0 :=        rct_clp.top;
                  if (x[1]>=        rct_clp.right   ) then
                    begin
                      y[1]:=       (rct_clp.right-x0)*k_+y0;
                       p1 :=Trunc(((rct_clp.right-1 )<<16-j0+ONE_SHL_16_M_1)/t_k_)+ff1;
                    end;
                  if (y[1]>=        rct_clp.bottom  ) then
                       p1 :=        rct_clp.bottom-1;
                  if CheckBounds then
                    begin
                      chk_bnds:=True;
                      j0:=t_k_*p0-t_b_;
                      if ((j0>>16)=rct_clp.left-1) then
                        begin
                          p0+=1;
                          j0+=t_k_;
                        end;
                    end;
                end
              else
                begin
                  if (x[0]>=        rct_clp.right   ) then
                    begin
                      y[0]:=       (rct_clp.right-x0)*k_+y0;
                       p0 :=Trunc(((rct_clp.right-1 )<<16-j0+ONE_SHL_16_M_1)/t_k_)+ff1+1;
                    end;
                  if (y[0]<         rct_clp.top     ) then
                       p0 :=        rct_clp.top;
                  if (x[1]<         rct_clp.left    ) then
                    begin
                      y[1]:=       (rct_clp.left-x0 )*k_+y0;
                       p1 :=Trunc(((rct_clp.left-1  )<<16-j0+ONE_SHL_16_M_1)/t_k_)+ff1;
                    end;
                  if (y[1]>=        rct_clp.bottom  ) then
                       p1 :=        rct_clp.bottom-1;
                  if CheckBounds then
                    begin
                      chk_bnds:=True;
                      j0  :=t_k_*p0-t_b_;
                      if (((t_k_*p1-t_b_)>>16)=rct_clp.left-1) then
                        p1:=Trunc((rct_clp.left<<16-j0+ONE_SHL_16_M_1)/t_k_)+ff1;
                      if ((j0>>16)=rct_clp.right) then
                        begin
                          p0+=1;
                          j0+=t_k_;
                        end;
                    end;
                end;
              if chk_bnds then
                begin
                  if (p1=rct_clp.bottom) then
                    p1-=1;
                  proc5;
                end;
            end;
        end;
    end; {$endregion}

end; {$endregion}
procedure TFastLine.ClippedLine2(x0,y0,x1,y1:integer; const rct_clp:TPtRect                                                                ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y: array[0..1] of integer;
  i  : byte;
begin
  if ((not ((x0<rct_clp.left) and (x1<rct_clp.left))) and (not ((x0>rct_clp.right ) and (x1>rct_clp.right )))) and
     ((not ((y0<rct_clp.top ) and (y1<rct_clp.top ))) and (not ((y0>rct_clp.bottom) and (y1>rct_clp.bottom)))) then
    begin
      x[0]:=x0;
      y[0]:=y0;
      x[1]:=x1;
      y[1]:=y1;
      i   :=0;
      repeat
        begin
          if (x[i]<rct_clp.left) then
            begin
              x[i]:=rct_clp.left;
              y[i]:=Trunc(((y1-y0)*(rct_clp.left  -x0))/(x1-x0)+y0);
            end
          else
          if (x[i]>rct_clp.right) then
            begin
              x[i]:=rct_clp.right;
              y[i]:=Trunc(((y1-y0)*(rct_clp.right -x0))/(x1-x0)+y0);
            end;
          if (y[i]<rct_clp.top) then
            begin
              y[i]:=rct_clp.top;
              x[i]:=Trunc(((x1-x0)*(rct_clp.top   -y0))/(y1-y0)+x0);
            end
          else
          if (y[i]>rct_clp.bottom) then
            begin
              y[i]:=rct_clp.bottom;
              x[i]:=Trunc(((x1-x0)*(rct_clp.bottom-y0))/(y1-y0)+x0);
            end;
          i:=i+1;
        end;
      until (i>1);
      if (not ((x[0]<rct_clp.left ) and (x[1]<rct_clp.left ))) and
         (not ((x[0]>rct_clp.right) and (x[1]>rct_clp.right))) then
        with ln_pos do
          begin
            x0:=x[0];
            y0:=y[0];
            x1:=x[1];
            y1:=y[1];
          end;
    end;
end; {$endregion}

// Fill Buffer With Anti-Aliasing:
procedure TFastLine.FilBuffer(constref rct_clp:TPtRect); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct: TPtRect;
begin
  with local_prop do
    if (clp_stl<>csResilientEdges) then
      begin
        with rct_clp do
          rct:=PtRct(left+1,top+1,right-1,bottom-1);
        ArrAdd(ln_arr0,
               ln_arr2,
               rct_clp,
               ln_arr_width,
               ln_arr_height);

        {Fill Buffer---------} {$region -fold}
        ArrFilProc[Byte(eds_bld_stl)](ln_arr0,
                                      bmp_dst_ptr,
                                      ln_arr_width,
                                      ln_arr_height,
                                      rct_clp,
                                      eds_col); {$endregion}

        {Border Anti-Aliasing} {$region -fold}
        if eds_aa then
          begin
            BorderCalc1 (ln_arr0,
                         aa_arr1,
                         ln_arr_width,
                         ln_arr_width,
                         rct,
                         aa_nz_arr_items_cnt);
            BorderCalc22(ln_arr0,
                         aa_arr1,
                         aa_arr2,
                         ln_arr_width,
                         ln_arr_width,
                         rct,
                         aa_line_cnt);
            BorderFill  (aa_arr2,
                         0,
                         0,
                         bmp_dst_ptr,
                         ln_arr_width,
                         aa_line_cnt,
                         eds_col,
                         args,
                         PPDec2Proc[pp_dec_2_proc_ind]);
          end; {$endregion}

      end;
end; {$endregion} {$endregion}

{$endregion}



(***************************** Fast Text Routines *****************************) {$region -fold}

{Init. Part--} {$region -fold}
constructor TFastText.Create;                                                                                                               {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
destructor TFastText.Destroy;                                                                                                               {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  self.Free;
  inherited Destroy;
end; {$endregion} {$endregion}

{$endregion}



(****************************** Points Transform ******************************) {$region -fold}

// (Align Points to horizontal line, from left to right): Выровнять точки по горизонтали, слева направо:
procedure PtsRawH(var pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref pts_dist:TColor);                                                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr       : PPtPosF;
  i,pts_dist_acc: integer;
begin
  pts_ptr     :=Unaligned(@pts[start_ind]);
  pts_dist_acc:=Trunc(pts_ptr^.x);
  for i:=0 to end_ind-start_ind-1 do
    begin
      (pts_ptr+i)^.x:=pts_dist_acc;
      Inc(pts_dist_acc,pts_dist);
    end;
end; {$endregion}
// (Align Points to vertical line, from top to bottom): Выровнять точки по вертикали, сверху вниз:
procedure PtsRawV(var pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref pts_dist:TColor);                                                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr       : PPtPosF;
  i,pts_dist_acc: integer;
begin
  pts_ptr     :=Unaligned(@pts[start_ind]);
  pts_dist_acc:=Trunc(pts_ptr^.y);
  for i:=0 to end_ind-start_ind-1 do
    begin
      (pts_ptr+i)^.y:=pts_dist_acc;
      Inc(pts_dist_acc,pts_dist);
    end;
end; {$endregion}
// (Reset Points Position): Восстановить позицию точек:
procedure PtsRes (constref fst_pt_ptr1,fst_pt_ptr2:PPtPosF; constref pts_cnt:TColor; constref pt_pos_curr,pt_pos_prev:TPtPosF);                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  fst_pt_ptr3: PPtPosF;
  i,n1,n2    : integer;
  m          : byte;
begin
  n1:=Trunc(pt_pos_curr.x)-Trunc(pt_pos_prev.x);
  n2:=Trunc(pt_pos_curr.y)-Trunc(pt_pos_prev.y);
  for i:=0 to Trunc(pts_cnt/4)-1 do
    begin
       fst_pt_ptr3      :=fst_pt_ptr1+i<<2;
      (fst_pt_ptr3+0)^.x+=n1;
      (fst_pt_ptr3+0)^.y+=n2;
      (fst_pt_ptr3+1)^.x+=n1;
      (fst_pt_ptr3+1)^.y+=n2;
      (fst_pt_ptr3+2)^.x+=n1;
      (fst_pt_ptr3+2)^.y+=n2;
      (fst_pt_ptr3+3)^.x+=n1;
      (fst_pt_ptr3+3)^.y+=n2;
    end;
  m:=pts_cnt mod 4;
  if (m<>0) then
    for i:=0 to m-1 do
      begin
        (fst_pt_ptr2+i)^.x+=n1;
        (fst_pt_ptr2+i)^.y+=n2;
      end;
end; {$endregion}
// (Points Pivot) Ось точек:
procedure PtsPvt (var      pvt:TPtPosF; var pts:TPtPosFArr; constref pts_cnt:TColor);                                                                         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr: PPtPosF;
  p      : TPtPosF;
  i      : integer;
begin
  if (pts=Nil) then
    Exit;
  p      :=Default(TPtPosF);
  pvt    :=Default(TPtPosF);
  pts_ptr:=Unaligned(@pts[0]);
  for i  :=0 to pts_cnt-1 do
    begin
      p.x+=(pts_ptr+i)^.x;
      p.y+=(pts_ptr+i)^.y;
    end;
  pvt.x  :=p.x/pts_cnt;
  pvt.y  :=p.y/pts_cnt;
end; {$endregion}
// (Points Moving) Перемещение точек:
procedure PtsMov (constref pvt:TPtPos;  var pts:TPtPosFArr; constref fst_ind,lst_ind:TColor                                 );                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr: PPtPosF;
  i      : integer;
begin
  if (pts=Nil) then
    Exit;
  pts_ptr:=Unaligned(@pts[fst_ind]);
  for i:=0 to lst_ind-fst_ind do
    begin
      pts_ptr^.x-=pvt.x;
      pts_ptr^.y-=pvt.y;
      Inc(pts_ptr);
    end;
end; {$endregion}
procedure PtsMov (constref pvt:TPtPos;  var rct:TPtRect                                                                     );                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  rct.left  -=pvt.x;
  rct.top   -=pvt.y;
  rct.right -=pvt.x;
  rct.bottom-=pvt.y;
  rct.width :=rct.right -rct.left;
  rct.height:=rct.bottom-rct.top;
end; {$endregion}
procedure PtsMov (constref pvt:TPtPos;  var rct:TRect                                                                       );                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  rct.left  -=pvt.x;
  rct.top   -=pvt.y;
  rct.right -=pvt.x;
  rct.bottom-=pvt.y;
  rct.width :=rct.right -rct.left;
  rct.height:=rct.bottom-rct.top;
end; {$endregion}
procedure PtsMov (constref pvt:TPtPos;  var rct:TPtRectF                                                                    );                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  rct.left  -=pvt.x;
  rct.top   -=pvt.y;
  rct.right -=pvt.x;
  rct.bottom-=pvt.y;
  rct.width :=rct.right -rct.left;
  rct.height:=rct.bottom-rct.top;
end; {$endregion}
procedure WndSht (constref outer_rect:TPtRect; constref inner_rect:TPtPosFArr; var shift_power:integer; constref mul:integer);                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m: integer;
begin
  m:=Max2(Trunc(inner_rect[1].x-
                inner_rect[0].x),
          Trunc(inner_rect[1].y-
                inner_rect[0].y));
  if (m>512) then
      shift_power:=Trunc(m/50);
  if (shift_power >Min3(outer_rect.width,
                       outer_rect.height)) then
      shift_power:=Min3(outer_rect.width,
                       outer_rect.height);
      shift_power*=mul>>4;
end; {$endregion}
procedure MDCalc (var rct:TPtRectF; constref mov_dir:TMovingDirection; constref parallax_shift:TPtPosF                      );                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct do
    case mov_dir of
      mdNone:
        Exit;
      mdLeft:
        begin
          left +=parallax_shift.x;
          right+=parallax_shift.x;
          width:=right-left;
        end;
      mdRight:
        begin
          left -=parallax_shift.x;
          right-=parallax_shift.x;
          width:=right-left;
        end;
      mdUp:
        begin
          top   +=parallax_shift.y;
          bottom+=parallax_shift.y;
          height:=bottom-top;
        end;
      mdDown:
        begin
          top   -=parallax_shift.y;
          bottom-=parallax_shift.y;
          height:=bottom-top;
        end;
      mdLeftUp:
        begin
          left  +=parallax_shift.x;
          right +=parallax_shift.x;
          width :=right-left;
          top   +=parallax_shift.y;
          bottom+=parallax_shift.y;
          height:=bottom-top;
        end;
      mdRightUp:
        begin
          left  -=parallax_shift.x;
          right -=parallax_shift.x;
          width :=right-left;
          top   +=parallax_shift.y;
          bottom+=parallax_shift.y;
          height:=bottom-top;
        end;
      mdLeftDown:
        begin
          left  +=parallax_shift.x;
          right +=parallax_shift.x;
          width :=right-left;
          top   -=parallax_shift.y;
          bottom-=parallax_shift.y;
          height:=bottom-top;
        end;
      mdRightDown:
        begin
          left  -=parallax_shift.x;
          right -=parallax_shift.x;
          width :=right-left;
          top   -=parallax_shift.y;
          bottom-=parallax_shift.y;
          height:=bottom-top;
        end;
    end;
end; {$endregion}
// (Points Scaling) Масштабирование точек:
procedure PtsScl (constref pvt:TPtPosF; var pts:TPtPosFArr; scl_mul:TPtPosF; constref scl_dir:TSclDir; fst_ind:TColor=0; lst_ind:TColor=0);                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr: PPtPosF;
  d1,d2  : double;
  i      : integer;
begin
  if (pts=Nil) then
    Exit;
  if (scl_dir=sdNone) then
    Exit;
  if (scl_dir=sdDown) then
    scl_mul:=PtPosF(1/scl_mul.x,
                    1/scl_mul.y);
  d1       :=pvt.x*(1-scl_mul.x){pvt.x-pvt.x*scl_mul.x};
  d2       :=pvt.y*(1-scl_mul.y){pvt.y-pvt.y*scl_mul.y};
  pts_ptr  :=Unaligned(@pts[fst_ind]);
  for i:=0 to lst_ind-fst_ind do
    begin
    //pts_ptr^.x:=scl_mul.x*pts_ptr^.x+d1;
      pts_ptr^.x*=scl_mul.x;
      pts_ptr^.x+=d1;
    //pts_ptr^.y:=scl_mul.y*pts_ptr^.y+d2;
      pts_ptr^.y*=scl_mul.y;
      pts_ptr^.y+=d2;
      Inc(pts_ptr);
    end;
end; {$endregion}
procedure PtsScl (constref pvt:TPtPosF; var rct:TPtRectF  ; scl_mul:TPtPosF; constref scl_dir:TSclDir                                    );                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  d1,d2: double;
begin
  if (scl_dir=sdNone) then
    Exit;
  if (scl_dir=sdDown) then
    scl_mul:=PtPosF(1/scl_mul.x,
                    1/scl_mul.y);
  d1       :=pvt.x*(1-scl_mul.x){pvt.x-pvt.x*scl_mul.x};
  d2       :=pvt.y*(1-scl_mul.y){pvt.y-pvt.y*scl_mul.y};
  with rct do
    begin
    //left  :=scl_mul.x*left   +d1;
      left  *=scl_mul.x;
      left  +=d1;
    //top   :=scl_mul.y*top    +d2;
      top   *=scl_mul.y;
      top   +=d2;
    //right :=scl_mul.x*=right +d1;
      right *=scl_mul.x;
      right +=d1;
    //bottom:=scl_mul.y*=bottom+d2;
      bottom*=scl_mul.y;
      bottom+=d2;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
procedure PtsScl (constref pvt:TPtPosF; var rct:TRect     ; scl_mul:TPtPosF; constref scl_dir:TSclDir                                    );                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  d1,d2: double;
begin
  if (scl_dir=sdNone) then
    Exit;
  if (scl_dir=sdDown) then
    scl_mul:=PtPosF(1/scl_mul.x,
                    1/scl_mul.y);
  d1       :=pvt.x*(1-scl_mul.x){pvt.x-pvt.x*scl_mul.x};
  d2       :=pvt.y*(1-scl_mul.y){pvt.y-pvt.y*scl_mul.y};
  with rct do
    begin
      left  :=Trunc (scl_mul.x*left  +d1);
      top   :=Trunc (scl_mul.y*top   +d2);
      right :=Trunc (scl_mul.x*right +d1);
      bottom:=Trunc (scl_mul.y*bottom+d2);
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function  GetDir1(prev_pos,curr_pos,pvt:TPtPosF): TSclDir;                                                                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  dist  : double;
begin
  Result:=sdNone;
  dist  :=PtDistSqr(pvt.x,pvt.y,curr_pos.x,curr_pos.y)-
          PtDistSqr(pvt.x,pvt.y,prev_pos.x,prev_pos.y);
  if (dist>0) then
    Result:=sdUp
  else
  if (dist<0) then
    Result:=sdDown
  else
  if (dist=0) then
    Result:=sdNone;
end; {$endregion}
function  GetDir2(prev_pos,curr_pos,pvt:TPtPosF): TSclDir;                                                                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=sdNone;
  if (curr_pos.x>prev_pos.x) then
    Result:=sdUp
  else
  if (curr_pos.x<prev_pos.x) then
    Result:=sdDown
  else
  if (curr_pos.x=prev_pos.x) then
    Result:=sdNone;
end; {$endregion}
procedure SetMul (prev_pos,curr_pos,pvt:TPtPosF;        var scl_mul:TPtPosF; constref scl_dir:TSclDir);                                                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  scl_mul:=PtPosF(DEFAULT_SCL_MUL,
                  DEFAULT_SCL_MUL);
  if (scl_dir=sdDown) then
    scl_mul:=PtPosF(1/scl_mul.x,
                    1/scl_mul.y);
end; {$endregion}
// (Points Rotation) Вращение точек:
procedure GetRot         (constref pvt:TPtPos    ;                          constref angle:double; var c,s,v,w:double                            );           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SinCos(pi*(1+angle/180),s,c);
  v:=pvt.x*c-pvt.y*s+pvt.x;
  w:=pvt.y*c+pvt.x*s+pvt.y;
end; {$endregion}
procedure GetRot         (constref pvt:TPtPos    ;                          constref angle:double; var c,s,v,w:integer; constref x,y    :integer );           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  c:=Trunc(cos(pi*(1+angle/180))*C_INT);
  s:=Trunc(sin(pi*(1+angle/180))*C_INT);
  v:=(pvt.x-x)*c-(pvt.y-y)*s+pvt.x<<16;
  w:=(pvt.y-y)*c+(pvt.x-x)*s+pvt.y<<16;
end; {$endregion}
procedure GetRot         (constref pvt:TPtPosF   ;                          constref angle:double; var c,s,v,w:double                            );           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SinCos(pi*(1+angle/180),s,c);
  v:=pvt.x*c-pvt.y*s+pvt.x;
  w:=pvt.y*c+pvt.x*s+pvt.y;
end; {$endregion}
procedure GetRotRound    (constref pvt:TPtPos    ;                          constref angle:double; var c,s,v,w:double;  constref x,y    :integer );           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  v:=x;
  w:=y;
  c:=Tan(pi*(angle-45)/360);
  s:=Sin(pi*(angle-45)/180);
  v-=Round(w*c);
  w+=Round(v*s);
  v-=Round(w*c);
 {c   :=Round(Tan((pi*(1+angle/360))*C_INT));
  s   :=Round(Sin((pi*(1+angle/180))*C_INT));
  pt.y:= pt.y  +pt.x-pt.y*c*s  ;
  pt.x:=-pt.y*c-pt.y+pt.y*c*s*c;}
 {c:=Trunc(cos(pi*(1+angle/180))*C_INT);
  s:=Trunc(sin(pi*(1+angle/180))*C_INT);
  v:=(pvt.x-x)*c-(pvt.y-y)*s+pvt.x<<16;
  w:=(pvt.y-y)*c+(pvt.x-x)*s+pvt.y<<16;}
end; {$endregion}
procedure GetRotNotRound (constref pvt:TPtPos    ;                          constref angle:double; var c,s,v,w:double;  constref x,y    :integer );           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  v:=x;
  w:=y;
  c:=Tan(pi*(angle-45)/360);
  s:=Sin(pi*(angle-45)/180);
  {v-={Round}(w*c);
  w+={Round}(v*s);
  v-={Round}(w*c);}


  //v:=x-y*c;
  w:=y+(x-y*c)*s;
  v:={x-y*c-(y+(x-y*c)*s)*c}{x-2*y*c-x*s*c+y*c*s*c}{x-2*y*c-x*s*c+y*c*s*c}x-(y<<1+(x-y*c)*s)*c;


 {c   :=Round(Tan((pi*(1+angle/360))*C_INT));
  s   :=Round(Sin((pi*(1+angle/180))*C_INT));
  pt.y:= pt.y  +pt.x-pt.y*c*s  ;
  pt.x:=-pt.y*c-pt.y+pt.y*c*s*c;}
 {c:=Trunc(cos(pi*(1+angle/180))*C_INT);
  s:=Trunc(sin(pi*(1+angle/180))*C_INT);
  v:=(pvt.x-x)*c-(pvt.y-y)*s+pvt.x<<16;
  w:=(pvt.y-y)*c+(pvt.x-x)*s+pvt.y<<16;}
end; {$endregion}
procedure GetRotNotRound2(constref pvt:TPtPos    ;                          constref angle:double; var c,s,v,w:integer; constref x,y    :integer );           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  c:=Trunc(Tan(pi*(angle-45)/360)*65536);
  s:=Trunc(Sin(pi*(angle-45)/180)*65536);
  w:=(y<<48+(x-y*c)*s)>>48;
  v:={x-((x-y*c)*s+y<<1)*c}(x<<48-2*y*c-x*s*c+y*c*s*c)>>48;


 {c   :=Round(Tan((pi*(1+angle/360))*C_INT));
  s   :=Round(Sin((pi*(1+angle/180))*C_INT));
  pt.y:= pt.y  +pt.x-pt.y*c*s  ;
  pt.x:=-pt.y*c-pt.y+pt.y*c*s*c;}
 {c:=Trunc(cos(pi*(1+angle/180))*C_INT);
  s:=Trunc(sin(pi*(1+angle/180))*C_INT);
  v:=(pvt.x-x)*c-(pvt.y-y)*s+pvt.x<<16;
  w:=(pvt.y-y)*c+(pvt.x-x)*s+pvt.y<<16;}
end; {$endregion}
procedure PtsRot         (var      pts:TPtPosFArr; constref pts_cnt:TColor; constref angle:double; var c,s,v,w:double;  constref fst_ind:TColor=0);           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr: PPtPosF;
  dx,dy  : double ;
  i      : integer;
begin
  if (pts=Nil) then
    Exit;
  if (Trunc(angle) mod 360=0) then
    Exit;
  pts_ptr:=Unaligned(@pts[fst_ind]);
  for i:=0 to pts_cnt-fst_ind-1 do
    begin
      dx        :=pts_ptr^.x;
      dy        :=pts_ptr^.y;
      pts_ptr^.x:=-dx*c+dy*s+v;
      pts_ptr^.y:=-dy*c-dx*s+w;
      Inc(pts_ptr);
    end;
end; {$endregion}
function  PtsRot         (         rct:TPtRectF  ;                          constref angle:double; var c,s,v,w:double;  constref margin :TColor=1): TPtRectF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x0,x1,x2,x3: double ;
  y0,y1,y2,y3: double ;
  i          : integer;
begin
  if (Trunc(angle) mod 360=0) then
    Exit;
  with rct do
    begin
      x0:=-left  *c+top   *s+v;
      x1:=-right *c+top   *s+v;
      x2:=-right *c+bottom*s+v;
      x3:=-left  *c+bottom*s+v;
      y0:=-top   *c-left  *s+w;
      y1:=-top   *c-right *s+w;
      y2:=-bottom*c-right *s+w;
      y3:=-bottom*c-left  *s+w;
    end;
  with Result do
    begin
      left  :=Min1(Min1(x0,x1),Min1(x2,x3))-margin;
      top   :=Min1(Min1(y0,y1),Min1(y2,y3))-margin;
      right :=Max1(Max1(x0,x1),Max1(x2,x3))+margin;
      bottom:=Max1(Max1(y0,y1),Max1(y2,y3))+margin;
      width :=right -left;
      height:=bottom-top;
    end;
end; {$endregion}
function  PtsRot         (         rct:TRect     ;                          constref angle:double; var c,s,v,w:double;  constref margin :TColor=1): TRect;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x0,x1,x2,x3: double ;
  y0,y1,y2,y3: double ;
  i          : integer;
begin
  if (Trunc(angle) mod 360=0) then
    Exit;
  with rct do
    begin
      x0:=-left  *c+top   *s+v;
      x1:=-right *c+top   *s+v;
      x2:=-right *c+bottom*s+v;
      x3:=-left  *c+bottom*s+v;
      y0:=-top   *c-left  *s+w;
      y1:=-top   *c-right *s+w;
      y2:=-bottom*c-right *s+w;
      y3:=-bottom*c-left  *s+w;
    end;
  with Result do
    begin
      left  :=Trunc(Min1(Min1(x0,x1),Min1(x2,x3)))-margin;
      top   :=Trunc(Min1(Min1(y0,y1),Min1(y2,y3)))-margin;
      right :=Trunc(Max1(Max1(x0,x1),Max1(x2,x3)))+margin;
      bottom:=Trunc(Max1(Max1(y0,y1),Max1(y2,y3)))+margin;
      width :=right -left;
      height:=bottom-top;
    end;
end; {$endregion}
function  PtsRot         (         rct:TPtRect   ;                          constref angle:double; var c,s,v,w:double;  constref margin :TColor=1): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x0,x1,x2,x3: double ;
  y0,y1,y2,y3: double ;
  i          : integer;
begin
  if (Trunc(angle) mod 360=0) then
    Exit;
  with rct do
    begin
      x0:=-left  *c+top   *s+v;
      x1:=-right *c+top   *s+v;
      x2:=-right *c+bottom*s+v;
      x3:=-left  *c+bottom*s+v;
      y0:=-top   *c-left  *s+w;
      y1:=-top   *c-right *s+w;
      y2:=-bottom*c-right *s+w;
      y3:=-bottom*c-left  *s+w;
    end;
  with Result do
    begin
      left  :=Trunc(Min1(Min1(x0,x1),Min1(x2,x3)))-margin;
      top   :=Trunc(Min1(Min1(y0,y1),Min1(y2,y3)))-margin;
      right :=Trunc(Max1(Max1(x0,x1),Max1(x2,x3)))+margin;
      bottom:=Trunc(Max1(Max1(y0,y1),Max1(y2,y3)))+margin;
      width :=right -left;
      height:=bottom-top;
    end;
end; {$endregion}
// (Points Simplification) Точечное упрощение:
{TODO}

{$endregion}



(************************** Miscellaneous Primitives **************************) {$region -fold}

// Color Info:
procedure SetColorInfo(constref pix_col_:TColor; var color_info:TColorInfo; alpha_max:byte=MAXBYTE); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with color_info do
    begin
      r       :=TRGBA(pix_col_).r;
      g       :=TRGBA(pix_col_).g;
      b       :=TRGBA(pix_col_).b;
      pix_col :=RGB(b,g,r);
        alpha1:=180;
      d_alpha1:=alpha_max-alpha1;
        alpha2:=80;
      d_alpha2:=alpha_max-alpha2;
    end;
end; {$endregion}
procedure SetColorInfo(constref pix_col_:TColor; var color_info:TColorInfo; b_:boolean);             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with color_info do
    begin
      r      :=TRGBA(pix_col_).r;
      g      :=TRGBA(pix_col_).g;
      b      :=TRGBA(pix_col_).b;
      pix_col:=RGB(b,g,r);
    end;
end; {$endregion}
// Line Segment: Отрезок:
function  LineS   (constref v0,w0,v1,w1,r0,r1:double                               ): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k,d0,d1: double;
begin
  with Result do
    begin
      if (v1=v0) then
        begin
          x0:=v0;
          y0+=r0;
          x1:=v1;
          y1+=r1;
          Exit;
        end;
      if (w1=w0) then
        begin
          x0+=r0;
          y0:=w0;
          x1+=r1;
          y1:=w1;
          Exit;
        end;
      k :=(w1-w0)/(v1-v0);
      d0:=r0*InvSqrt(1+k*k){r0/sqrt(1+k*k)}; // only with garbage init. ON
      x0:=v0+d0;
      y0:=k*d0+w0;
      d1:=r1*InvSqrt(1+k*k){r1/sqrt(1+k*k)}; // only with garbage init. ON
      x1:=v1+d1;
      y1:=k*d1+w1;
    end;
end; {$endregion}
function  LineS   (constref v0,w0,v1,w1,r    :double                               ): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k,d: double;
begin
  with Result do
    begin
      if (v1=v0) then
        begin
          x:=v1;
          y+=r;
          Exit;
        end;
      if (w1=w0) then
        begin
          x+=r;
          y:=w1;
          Exit;
        end;
      k :=(w1-w0)/(v1-v0);
      d :=r*InvSqrt(1+k*k){r/sqrt(1+k*k)}; // only with garbage init. ON
      x :=v1+d;
      y :=k*d+w1;
    end;
end; {$endregion}
function  LineS   (constref v0,w0,v1,w1,r    :double; constref dir_x,dir_y:shortint): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k,dx: double;
begin
  with Result do
    begin
      if (v1=v0) then
        begin
          x:=v1;
          y:=w1+r*dir_y;
          Exit;
        end;
      if (w1=w0) then
        begin
          x:=v1+r*dir_x;
          y:=w1;
          Exit;
        end;
      k :=(w1-w0)/(v1-v0);
      dx:=r*InvSqrt(1+k*k){r/sqrt(1+k*k)}; // only with garbage init. ON
      x :=v1+dir_x*dx;
      y :=w1+dir_y*dx*k;
    end;
end; {$endregion}
// Line Direction: Направление линии:
procedure LineD   (constref v0,w0,v1,w1      :double; var      dir_x,dir_y:shortint);          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (v1>v0) then
    begin
      if (w1=w0) then
        begin
          dir_x:=1;
          dir_y:=0;
          Exit;
        end
      else
        begin
          dir_x:=1;
          dir_y:=1;
          Exit;
        end;
    end
  else
    begin
      if (v1=v0) then
        begin
          if (w1>w0) then
            begin
              dir_x:=0;
              dir_y:=1;
              Exit;
            end
          else
            begin
              dir_x:=0;
              dir_y:=-1;
              Exit;
            end
        end;
      if (w1=w0) then
        begin
          dir_x:=-1;
          dir_y:=0;
          Exit;
        end
      else
        begin
          dir_x:=-1;
          dir_y:=-1;
          Exit;
        end;
    end
end; {$endregion}
// Monochrome Regular Line(Width - 1 pixel):
procedure Line    (x0,y0,x1,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  y0_shift                        : integer;
  i,short_len,long_len,swp,dec_inc: integer;
  yLonger                         : boolean;
begin
  with color_info do
    begin
      yLonger  :=False;
      short_len:=y1-y0;
      long_len :=x1-x0;
      if (Abs(short_len)>Abs(long_len)) then
        begin
          swp      :=short_len;
          short_len:=long_len;
          long_len :=swp;
          yLonger  :=True;
        end;
      if (long_len=0) then
        dec_inc:=0
      else
        dec_inc:=Trunc((short_len<<16)/long_len);
      if (yLonger) then
        begin
          if (long_len>0) then
            begin
    	      long_len+=y0;
              i:=$8000+(x0<<16);
              y0_shift:=y0*bmp_dst_width;
              while (y0<=long_len) do
                begin
                  (bmp_dst_ptr+(i>>16)+y0_shift)^:=pix_col;
    	          i+=dec_inc;
                  Inc(y0);
                  Inc(y0_shift,bmp_dst_width);
                end;
              Exit;
            end;
          long_len+=y0;
          i:=$8000+(x0<<16);
          y0_shift:=y0*bmp_dst_width;
          while (y0>=long_len) do
            begin
              (bmp_dst_ptr+(i>>16)+y0_shift)^:=pix_col;
              i-=dec_inc;
              Dec(y0);
              Dec(y0_shift,bmp_dst_width);
            end;
          Exit;
        end;
      if (long_len>0) then
        begin
          long_len+=x0;
          i:=$8000+(y0<<16);
          while (x0<=long_len) do
            begin
              (bmp_dst_ptr+x0+(i>>16)*bmp_dst_width)^:=pix_col;
              i+=dec_inc;
              Inc(x0);
            end;
          Exit;
        end;
      long_len+=x0;
      i:=$8000+(y0<<16);
      while (x0>=long_len) do
        begin
          (bmp_dst_ptr+x0+(i>>16)*bmp_dst_width)^:=pix_col;
          i-=dec_inc;
          Dec(x0);
        end;
    end;
end; {$endregion}
procedure Line    (x0,y0,x1,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref val       :TColor    ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  y0_shift                        : integer;
  i,short_len,long_len,swp,dec_inc: integer;
  yLonger                         : boolean;
begin
  yLonger  :=False;
  short_len:=y1-y0;
  long_len :=x1-x0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
    end;
  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);
  if (yLonger) then
    begin
      if (long_len>0) then
        begin
          long_len+=y0;
          i:=$8000+(x0<<16);
          y0_shift:=y0*bmp_dst_width;
          while (y0<=long_len) do
            begin
              (bmp_dst_ptr+(i>>16)+y0_shift)^:=val;
              i+=dec_inc;
              Inc(y0);
              Inc(y0_shift,bmp_dst_width);
            end;
          Exit;
        end;
      long_len+=y0;
      i:=$8000+(x0<<16);
      y0_shift:=y0*bmp_dst_width;
      while (y0>=long_len) do
        begin
          (bmp_dst_ptr+(i>>16)+y0_shift)^:=val;
          i-=dec_inc;
          Dec(y0);
          Dec(y0_shift,bmp_dst_width);
        end;
      Exit;
    end;
  if (long_len>0) then
    begin
      long_len+=x0;
      i:=$8000+(y0<<16);
      while (x0<=long_len) do
        begin
          (bmp_dst_ptr+x0+(i>>16)*bmp_dst_width)^:=val;
          i+=dec_inc;
          Inc(x0);
        end;
      Exit;
    end;
  long_len+=x0;
  i:=$8000+(y0<<16);
  while (x0>=long_len) do
    begin
      (bmp_dst_ptr+x0+(i>>16)*bmp_dst_width)^:=val;
      i-=dec_inc;
      Dec(x0);
    end;
end; {$endregion}
procedure Line    (x0,y0,x1,y1:integer; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width:TColor; constref val       :byte      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  y0_shift                        : integer;
  i,short_len,long_len,swp,dec_inc: integer;
  yLonger                         : boolean;
begin
  yLonger  :=False;
  short_len:=y1-y0;
  long_len :=x1-x0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
    end;
  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);
  if (yLonger) then
    begin
      if (long_len>0) then
        begin
          long_len+=y0;
          i:=$8000+(x0<<16);
          y0_shift:=y0*bmp_dst_width;
          while (y0<=long_len) do
            begin
              (bmp_dst_ptr+(i>>16)+y0_shift)^:=val;
              i+=dec_inc;
              Inc(y0);
              Inc(y0_shift,bmp_dst_width);
            end;
          Exit;
        end;
      long_len+=y0;
      i:=$8000+(x0<<16);
      y0_shift:=y0*bmp_dst_width;
      while (y0>=long_len) do
        begin
          (bmp_dst_ptr+(i>>16)+y0_shift)^:=val;
          i-=dec_inc;
          Dec(y0);
          Dec(y0_shift,bmp_dst_width);
        end;
      Exit;
    end;
  if (long_len>0) then
    begin
      long_len+=x0;
      i:=$8000+(y0<<16);
      while (x0<=long_len) do
        begin
          (bmp_dst_ptr+x0+(i>>16)*bmp_dst_width)^:=val;
          i+=dec_inc;
          Inc(x0);
        end;
      Exit;
    end;
  long_len+=x0;
  i:=$8000+(y0<<16);
  while (x0>=long_len) do
    begin
      (bmp_dst_ptr+x0+(i>>16)*bmp_dst_width)^:=val;
      i-=dec_inc;
      Dec(x0);
    end;
end; {$endregion}
// Line Segments Intersection:
function LineSI   (x0,y0,x1,y1,v0,w0,v1,w1:double ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  a0,a1,b0,b1: boolean;}
begin
  {a0:=((x0-x1)*(w0-y1)<=(y0-y1)*(v0-x1));
  a1:=((x0-x1)*(w1-y1)<=(y0-y1)*(v1-x1));
  b0:=((v1-v0)*(y1-w0)<=(w1-w0)*(x1-v0));
  b1:=((v1-v0)*(y0-w0)<=(w1-w0)*(x0-v0));
  Result:=((a0 and (not a1)) or (a1 and (not a0))) and
          ((b0 and (not b1)) or (b1 and (not b0)));}
  Result:=(((x0-x1)*(w0-y1)-(y0-y1)*(v0-x1))*
           ((x0-x1)*(w1-y1)-(y0-y1)*(v1-x1))<=0) and
          (((v1-v0)*(y1-w0)-(w1-w0)*(x1-v0))*
           ((v1-v0)*(y0-w0)-(w1-w0)*(x0-v0))<=0);
end; {$endregion}
function LineSI   (x0,y0,x1,y1,v0,w0,v1,w1:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  a0,a1,b0,b1: boolean;}
begin
  {a0:=((x0-x1)*(w0-y1)<=(y0-y1)*(v0-x1));
  a1:=((x0-x1)*(w1-y1)<=(y0-y1)*(v1-x1));
  b0:=((v1-v0)*(y1-w0)<=(w1-w0)*(x1-v0));
  b1:=((v1-v0)*(y0-w0)<=(w1-w0)*(x0-v0));
  Result:=((a0 and (not a1)) or (a1 and (not a0))) and
          ((b0 and (not b1)) or (b1 and (not b0)));}
  Result:=(((x0-x1)*(w0-y1)-(y0-y1)*(v0-x1))*
           ((x0-x1)*(w1-y1)-(y0-y1)*(v1-x1))<=0) and
          (((v1-v0)*(y1-w0)-(w1-w0)*(x1-v0))*
           ((v1-v0)*(y0-w0)-(w1-w0)*(x0-v0))<=0);
end; {$endregion}
// Line Clipping:
function LineC    (var x0,y0,x1,y1:integer; constref rct_clp:TPtRect): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x: array[0..1] of integer;
  y: array[0..1] of integer;
  i: byte;
begin
  Result:=False;
  if ((not ((x0<rct_clp.left) and (x1<rct_clp.left))) and (not ((x0>rct_clp.right ) and (x1>rct_clp.right )))) and
     ((not ((y0<rct_clp.top ) and (y1<rct_clp.top ))) and (not ((y0>rct_clp.bottom) and (y1>rct_clp.bottom)))) then
    begin
      x[0]:=x0;
      y[0]:=y0;
      x[1]:=x1;
      y[1]:=y1;
      i   :=0;
      repeat
        begin
          if (x[i]<rct_clp.left) then
            begin
              x[i]:=rct_clp.left;
              y[i]:=Trunc(((y1-y0)*(rct_clp.left  -x0))/(x1-x0)+y0);
            end
          else
          if (x[i]>rct_clp.right) then
            begin
              x[i]:=rct_clp.right;
              y[i]:=Trunc(((y1-y0)*(rct_clp.right -x0))/(x1-x0)+y0);
            end;
          if (y[i]<rct_clp.top) then
            begin
              y[i]:=rct_clp.top;
              x[i]:=Trunc(((x1-x0)*(rct_clp.top   -y0))/(y1-y0)+x0);
            end
          else
          if (y[i]>rct_clp.bottom) then
            begin
              y[i]:=rct_clp.bottom;
              x[i]:=Trunc(((x1-x0)*(rct_clp.bottom-y0))/(y1-y0)+x0);
            end;
          i:=i+1;
        end;
      until (i>1);
      if (not ((x[0]<rct_clp.left ) and (x[1]<rct_clp.left ))) and
         (not ((x[0]>rct_clp.right) and (x[1]>rct_clp.right))) then
        begin
          Result:=True;
          x0    :=x[0];
          y0    :=y[0];
          x1    :=x[1];
          y1    :=y[1];
        end;
    end;
end; {$endregion}
// Monochrome Horizontal Line(Width - 1 pixel):
function  LineHC  (var x0,y0,x1:integer; constref rct_clp:TPtRect): boolean;                                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_clp: array[0..7] of boolean;
  clp    : qword absolute arr_clp;
  x2     : integer;
begin
  Result:=True;
  if (y0<rct_clp.top) or (y0>=rct_clp.bottom) then
    begin
      Result:=False;
      Exit;
    end;
  if (x0>x1) then
    begin
      x2:=x1;
      x1:=x0;
      x0:=x2;
    end;
  arr_clp[00]:=(x0< rct_clp.left  );
  arr_clp[01]:=(x0>=rct_clp.left  ) and (x0<rct_clp.right);
  arr_clp[02]:=(x0>=rct_clp.right );
  arr_clp[03]:=(x1< rct_clp.left  );
  arr_clp[04]:=(x1>=rct_clp.left  ) and (x1<rct_clp.right);
  arr_clp[05]:=(x1>=rct_clp.right );
  arr_clp[06]:=False;
  arr_clp[07]:=False;
  case clp of
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000000000000000000001000000000000000000000001:
      begin
        Result:=False;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000000000000100000000000000000000000000000001:
      begin
        x0    :=rct_clp.left;
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000010000000000000000000000000000000000000001:
      begin
        x0    :=rct_clp.left;
        x1    :=rct_clp.right-1;
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000000000000100000000000000000000000100000000:
      begin
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000010000000000000000000000000000000100000000:
      begin
        x1    :=rct_clp.right-1;
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000010000000000000000000000010000000000000000:
      begin
        Result:=False;
        Exit;
      end;
  end;
end; {$endregion}
procedure LineH   (    x0,y0,x1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FillDWord((bmp_dst_ptr+x0+y0*bmp_dst_width)^,x1-x0+1,color_info.pix_col);
end; {$endregion}
procedure LineH   (    x0,y0,x1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref val       :TColor    ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FillDWord((bmp_dst_ptr+x0+y0*bmp_dst_width)^,x1-x0+1,val);
end; {$endregion}
procedure LineH   (    x0,y0,x1:integer; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width:TColor; constref val       :byte      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FillByte((bmp_dst_ptr+x0+y0*bmp_dst_width)^,x1-x0+1,val);
end; {$endregion}
// Monochrome Vertical Line(Width - 1 pixel):
function  LineVC  (var x0,y0,y1:integer; constref rct_clp:TPtRect): boolean;                                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_clp: array[0..7] of boolean;
  clp    : qword absolute arr_clp;
  y2     : integer;
begin
  Result:=True;
  if (x0<rct_clp.left) or (x0>=rct_clp.right) then
    begin
      Result:=False;
      Exit;
    end;
  if (y0>y1) then
    begin
      y2:=y1;
      y1:=y0;
      y0:=y2;
    end;
  arr_clp[00]:=(y0< rct_clp.top   );
  arr_clp[01]:=(y0>=rct_clp.top   ) and (y0<rct_clp.bottom);
  arr_clp[02]:=(y0>=rct_clp.bottom);
  arr_clp[03]:=(y1< rct_clp.top   );
  arr_clp[04]:=(y1>=rct_clp.top   ) and (y1<rct_clp.bottom);
  arr_clp[05]:=(y1>=rct_clp.bottom);
  arr_clp[06]:=False;
  arr_clp[07]:=False;
  case clp of
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000000000000000000001000000000000000000000001:
      begin
        Result:=False;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000000000000100000000000000000000000000000001:
      begin
        y0    :=rct_clp.top;
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000010000000000000000000000000000000000000001:
      begin
        y0    :=rct_clp.top;
        y1    :=rct_clp.bottom-1;
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000000000000100000000000000000000000100000000:
      begin
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000010000000000000000000000000000000100000000:
      begin
        y1    :=rct_clp.bottom-1;
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000010000000000000000000000010000000000000000:
      begin
        Result:=False;
        Exit;
      end;
  end;
end; {$endregion}
procedure LineV   (    x0,y0,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_ptr: PInteger;
  i     : integer;
begin
  ln_ptr:=bmp_dst_ptr+x0+y0*bmp_dst_width;
  for i:=0 to y1-y0 do
    begin
      ln_ptr^:=color_info.pix_col;
      Inc(ln_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure LineV   (    x0,y0,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref val       :TColor    ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_ptr: PInteger;
  i     : integer;
begin
  ln_ptr:=bmp_dst_ptr+x0+y0*bmp_dst_width;
  for i:=0 to y1-y0 do
    begin
      ln_ptr^:=val;
      Inc(ln_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure LineV   (    x0,y0,y1:integer; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width:TColor; constref val       :byte      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_ptr: PByte;
  i     : integer;
begin
  ln_ptr:=bmp_dst_ptr+x0+y0*bmp_dst_width;
  for i:=0 to y1-y0 do
    begin
      ln_ptr^:=val;
      Inc(ln_ptr,bmp_dst_width);
    end;
end; {$endregion}
// Monochrome Antialiased Line(Width - 1 pixel):
procedure LineA   (    x0,y0,x1,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo; alpha_max:byte=MAXBYTE  ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  dx,dy,dydx                                      : double;
  df,deltax,deltay,i,start,finish,dx_,dy_,loop_cnt: integer;
begin
  with color_info do
    begin
      deltax:=Abs(x1-x0);
      deltay:=Abs(y1-y0);
      {if (deltax=0) or (deltay=0) then
        Exit;}
      if (deltax>deltay) then
        begin
          if (y1>y0) then
            dydx:=-deltay/deltax
          else
            dydx:= deltay/deltax;
          if (x1<x0) then
            begin
              start :=x1;
              finish:=x0;
              dy    :=y1;
            end
          else
            begin
              start :=x0;
              finish:=x1;
              dy    :=y0;
              dydx  :=-dydx;
            end;
          for i:=start to finish do
            begin
              dy_:=Trunc(dy);
              df :=Trunc(alpha_max*(dy-dy_));       //MAXBYTE*dy_0+MAXBYTE*loop*([deltay/deltax]+{deltay/deltax})=MAXBYTE*(dy_0+loop)+MAXBYTE*loop*{deltay/deltax}
              AlphaBlend1(bmp_dst_ptr+i+(dy_+0)*bmp_dst_width,r,g,b,          df);
              AlphaBlend1(bmp_dst_ptr+i+(dy_+1)*bmp_dst_width,r,g,b,alpha_max-df);
              dy+=dydx;
            end;
        end
      else
        begin
          if (x1>x0) then
            dydx:=-deltax/deltay
          else
            dydx:= deltax/deltay;
          if (y1<y0) then
            begin
              start :=y1;
              finish:=y0;
              dx    :=x1;
            end
          else
            begin
              start :=y0;
              finish:=y1;
              dx    :=x0;
              dydx  :=-dydx;
            end;
          loop_cnt:=start*bmp_dst_width;
          for i:=start to finish do
            begin
              dx_:=Trunc(dx);
              df :=Trunc(alpha_max*(dx-dx_));
              AlphaBlend1(bmp_dst_ptr+dx_+loop_cnt+0,r,g,b,          df);
              AlphaBlend1(bmp_dst_ptr+dx_+loop_cnt+1,r,g,b,alpha_max-df);
              Inc(loop_cnt,bmp_dst_width);
              dx+=dydx;
            end;
        end;
    end;
end; {$endregion}
procedure LineAC  (var x0,y0,x1,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo; constref rct_clp:TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (y0=y1) then
    begin
      // Line Clipping:
      if LineHC(x0,y0,x1,rct_clp) then
        // Line Drawing:
        LineH(x0,y0,x1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
    end
  else
    begin
      // Line Clipping:
      if LineC(x0,y0,x1,y1,rct_clp) then
        // Line Drawing:
        LineA(x0,y0,x1,y1,bmp_dst_ptr,bmp_dst_width,color_info);
    end;
end; {$endregion}
// Monochrome Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineABC (constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo; constref rct_clp:TPtRect; constref shift:TPtPos; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr            : PPtPosF;
  x0,y0,x1,y1,i,d_ind: integer;
begin
  d_ind:=end_ind-start_ind;
  if (d_ind=0) then
    Exit;
  pts_ptr:=Unaligned(@pts[start_ind]);
  for i:=0 to d_ind-1 do
    begin
      x0:=Trunc((pts_ptr+0)^.x)+shift.x;
      y0:=Trunc((pts_ptr+0)^.y)+shift.y;
      x1:=Trunc((pts_ptr+1)^.x)+shift.x;
      y1:=Trunc((pts_ptr+1)^.y)+shift.y;
      if (y0=y1) then
        begin
          // Line Clipping:
          if LineHC(x0,y0,x1,rct_clp) then
            // Line Drawing:
            LineH(x0,y0,x1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        end
      else
        begin
          // Line Clipping:
          if LineC(x0,y0,x1,y1,rct_clp) then
            // Line Drawing:
            LineA(x0,y0,x1,y1,bmp_dst_ptr,bmp_dst_width,color_info);
        end;
      Inc(pts_ptr);
    end;
  if exp_ then
    begin
      pts_ptr:=Unaligned(@pts[start_ind]);
      x0     :=Trunc((pts_ptr+00000)^.x)+shift.x;
      y0     :=Trunc((pts_ptr+00000)^.y)+shift.y;
      x1     :=Trunc((pts_ptr+d_ind)^.x)+shift.x;
      y1     :=Trunc((pts_ptr+d_ind)^.y)+shift.y;
      if (y0=y1) then
        begin
          // Line Clipping:
          if LineHC(x0,y0,x1,rct_clp) then
            // Line Drawing:
            LineH(x0,y0,x1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        end
      else
        begin
          // Line Clipping:
          if LineC(x0,y0,x1,y1,rct_clp) then
            // Line Drawing:
            LineA(x0,y0,x1,y1,bmp_dst_ptr,bmp_dst_width,color_info);
        end;
    end;
end; {$endregion}
// Gradient(Highlight) Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineABCG(constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; var      color_info:TColorInfo; constref rct_clp:TPtRect; constref shift:TPtPos; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr              : PPtPosF;
  x0,y0,x1,y1,i,d_ind,p: integer;
  pix_col              : TColor;
begin
  d_ind:=end_ind-start_ind;
  if (d_ind=0) then
    Exit;
  p      :=0;
  pix_col:=color_info.pix_col;
  pts_ptr:=Unaligned(@pts[start_ind]);
  for i:=0 to d_ind-1 do
    begin
      x0:=Trunc((pts_ptr+0)^.x)+shift.x;
      y0:=Trunc((pts_ptr+0)^.y)+shift.y;
      x1:=Trunc((pts_ptr+1)^.x)+shift.x;
      y1:=Trunc((pts_ptr+1)^.y)+shift.y;
      SetColorInfo(HighlightA(pix_col,p),color_info,False);
      if (y0=y1) then
        begin
          // Line Clipping:
          if LineHC(x0,y0,x1,rct_clp) then
            // Line Drawing:
            LineH(x0,y0,x1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        end
      else
        begin
          // Line Clipping:
          if LineC(x0,y0,x1,y1,rct_clp) then
            // Line Drawing:
            LineA(x0,y0,x1,y1,bmp_dst_ptr,bmp_dst_width,color_info);
        end;
      Inc(p);
      Inc(pts_ptr);
    end;
  if exp_ then
    begin
      pts_ptr:=Unaligned(@pts[start_ind]);
      x0     :=Trunc((pts_ptr+00000)^.x)+shift.x;
      y0     :=Trunc((pts_ptr+00000)^.y)+shift.y;
      x1     :=Trunc((pts_ptr+d_ind)^.x)+shift.x;
      y1     :=Trunc((pts_ptr+d_ind)^.y)+shift.y;
      SetColorInfo(HighlightA(pix_col,p),color_info,False);
      if (y0=y1) then
        begin
          // Line Clipping:
          if LineHC(x0,y0,x1,rct_clp) then
            // Line Drawing:
            LineH(x0,y0,x1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        end
      else
        begin
          // Line Clipping:
          if LineC(x0,y0,x1,y1,rct_clp) then
            // Line Drawing:
            LineA(x0,y0,x1,y1,bmp_dst_ptr,bmp_dst_width,color_info);
        end;
    end;
end; {$endregion}
// Equidistant Line(Width - 1 pixel):
function  LineE1  (constref v0,w0,v1,w1,rad:double): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k,d,l0,l1: double;
begin
  with Result do
    begin
      if (v1=v0) then
        begin
          x0:=v0-rad;
          y0:=w0;
          x1:=x0;
          y1:=w1;
          Exit;
        end
      else
        begin
          if (w1=w0) then
            begin
              x0:=v0;
              y0:=w0-rad;
              x1:=v1;
              y1:=y0;
              Exit;
            end;
          k :=(w1-w0)/(v1-v0);
          d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
          l0:=rad*d*k;
          l1:=rad*d  ;
          x0:=v0-l0;
          y0:=w0+l1;
          x1:=v1-l0;
          y1:=w1+l1;
        end;
    end;
end; {$endregion}
function  LineE2  (constref v0,w0,v1,w1,rad:double): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k,d,l0,l1: double;
begin
  with Result do
    begin
      if (v1=v0) then
        begin
          x0:=v0+rad;
          y0:=w0;
          x1:=x0;
          y1:=w1;
          Exit;
        end
      else
        begin
          if (w1=w0) then
            begin
              x0:=v0;
              y0:=w0+rad;
              x1:=v1;
              y1:=y0;
              Exit;
            end;
          k :=(w1-w0)/(v1-v0);
          d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
          l0:=rad*d*k;
          l1:=rad*d  ;
          x0:=v0+l0;
          y0:=w0-l1;
          x1:=v1+l0;
          y1:=w1-l1;
        end;
    end;
end; {$endregion}
// Equidistant Curve for Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineABCE(constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo; constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    {if (Abs(x1-x0){*(x1-x0)}+Abs(y1-y0){*(y1-y0)}<2) then
      begin
        Inc(pts_ptr);
        Continue;
      end;}
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=x1-rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          LineA(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        v0:=x0+rad;
        w0:=y0;
        v1:=x1+rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          LineA(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          LineA(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          LineA(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            color_info.pix_col);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (end_ind-start_ind>0) then
    CircProc(d_ind);
end; {$endregion}
// Equidistant Curve for Not Antialiased Broken Clipped Line(Width - 1 pixel):
procedure LineBCE (constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo; constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    {if (Abs(x1-x0){*(x1-x0)}+Abs(y1-y0){*(y1-y0)}<2) then
      begin
        Inc(pts_ptr);
        Continue;
      end;}
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=x1-rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        v0:=x0+rad;
        w0:=y0;
        v1:=x1+rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            color_info.pix_col);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (end_ind-start_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE (constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref val       :TColor    ; constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=x1-rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        v0:=x0+rad;
        w0:=y0;
        v1:=x1+rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            val);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (end_ind-start_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE (constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width:TColor; constref val       :byte      ; constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=x1-rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        v0:=x0+rad;
        w0:=y0;
        v1:=x1+rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            val);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (end_ind-start_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE (constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor;                                 constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  pt_ind     : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0    :=Trunc((pts_ptr+i)^.x)+shift.x;
    y0    :=Trunc((pts_ptr+i)^.y)+shift.y;
    x1    :=Trunc((pts_ptr+j)^.x)+shift.x;
    y1    :=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=x1-rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0:=x0+rad;
        w0:=y0;
        v1:=x1+rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            pt_ind);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    begin
      pt_ind:=start_ind+i+1;
      LineProc(0,1);
    end;
  pts_ptr :=pts_ptr1;
  if exp_ then
    begin
      pt_ind:=-(start_ind+1);
      LineProc(0,d_ind);
    end;
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    begin
      pt_ind:=start_ind+i+1;
      CircProc(i);
    end;
  pts_ptr :=pts_ptr1;
  if (end_ind-start_ind>0) then
    begin
      pt_ind:=end_ind+1;
      CircProc(d_ind);
    end;
end; {$endregion}
// Equidistant Curve for Not Antialiased Broken Clipped Line(Width - 2 pixel):
procedure LineBCE2(constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo; constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end;
        v0:=x0+rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end;
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info);
              end;
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info);
              end;
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end;
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end;
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            color_info.pix_col);
    if (rad>1) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-1,
              bmp_dst_ptr,
              rct_clp,
              bmp_dst_width,
              color_info.pix_col);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (d_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE2(constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref val       :TColor    ; constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
        v0:=x0+rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end;
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end;
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            val);
    if (rad>1) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-1,
              bmp_dst_ptr,
              rct_clp,
              bmp_dst_width,
              val);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (d_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE2(constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width:TColor; constref val       :byte      ; constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
        v0:=x0+rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end;
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end;
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            val);
    if (rad>1) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-1,
              bmp_dst_ptr,
              rct_clp,
              bmp_dst_width,
              val);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (d_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE2(constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor;                                 constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  pt_ind     : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end;
        v0:=x0+rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end;
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
              end;
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
              end;
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end;
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end;
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            pt_ind);
    if (rad>1) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-1,
              bmp_dst_ptr,
              rct_clp,
              bmp_dst_width,
              pt_ind);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (d_ind>0) then
    CircProc(d_ind);
end; {$endregion}
// Equidistant Curve for Not Antialiased Broken Clipped Line(Width - 3 pixel):
procedure LineBCE3(constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo; constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0+rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        v0+=1;
        v1+=1;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        v0-=2;
        v1-=2;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        v0:=x0-rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        v0+=1;
        v1+=1;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        v0-=2;
        v1-=2;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            w0+=1;
            w1+=1;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            w0-=2;
            w1-=2;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            w0+=1;
            w1+=1;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            w0-=2;
            w1-=2;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );

        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            w0-=2;
            w1-=2;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
          end;

        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            w0-=2;
            w1-=2;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            v0-=2;
            v1-=2;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
          end;

      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            color_info.pix_col);
    if (rad>1) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-1,
              bmp_dst_ptr,
              rct_clp,
              bmp_dst_width,
              color_info.pix_col);
    if (rad>2) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-2,
              bmp_dst_ptr,
              rct_clp,
              bmp_dst_width,
              color_info.pix_col);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (d_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE3(constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor;                                 constref rct_clp:TPtRect; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  pt_ind     : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0+rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0+=1;
        v1+=1;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0-=2;
        v1-=2;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0:=x0-rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0+=1;
        v1+=1;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0-=2;
        v1-=2;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            w0+=1;
            w1+=1;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            w0-=2;
            w1-=2;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            w0+=1;
            w1+=1;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            w0-=2;
            w1-=2;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            w0-=2;
            w1-=2;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end;
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            w0-=2;
            w1-=2;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            v0-=2;
            v1-=2;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end;
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  {var
    a,x,n: integer;}
  begin
    {if rad<(n>>1)+2 then
      Exit;
    if Odd(n) then
      a:=1
    else
      a:=0;
    for x:=-(n>>1) to (n>>1)-a do
      CircleC
      (
        Trunc((pts_ptr+i)^.x)+shift.x,
        Trunc((pts_ptr+i)^.y)+shift.y,
        rad+x,
        bmp_dst_ptr,
        rct_clp,
        bmp_dst_width,
        pt_ind
      );}
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            rct_clp,
            bmp_dst_width,
            pt_ind);
    if (rad>1) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-1,
              bmp_dst_ptr,
              rct_clp,
              bmp_dst_width,
              pt_ind);
    if (rad>2) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-2,
              bmp_dst_ptr,
              rct_clp,
              bmp_dst_width,
              pt_ind);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    begin
      pt_ind:=start_ind+i+1;
      LineProc(0,1);
    end;
  pts_ptr :=pts_ptr1;
  if exp_ then
    begin
      pt_ind:=-(start_ind+1);
      LineProc(0,d_ind);
    end;
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    begin
      pt_ind:=start_ind+i+1;
      CircProc(i);
    end;
  pts_ptr :=pts_ptr1;
  if (end_ind-start_ind>0) then
    begin
      pt_ind:=end_ind+1;
      CircProc(d_ind);
    end;
end; {$endregion}
// Monochrome Resilient Line(Width - 1 pixel):
procedure LineR   (constref x0,y0,x1,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo; constref seg_cnt:TColor); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,dx,dy: double;
  i        : integer;
begin
      x:=x0;
      y:=y0;
  if (x1>x0) then
    begin
      dx:=(x1-x0)/seg_cnt;
      if  (y1>y0) then
        begin
          dy:=(y1-y0)/seg_cnt;
          for i:=0 to seg_cnt-2 do
            begin
              x+=dx;
              y+=dy;
              Point(Trunc(x),
                    Trunc(y),
                    bmp_dst_ptr,
                    bmp_dst_width,
                    color_info);
            end;
        end
      else
        begin
          dy:=(y0-y1)/seg_cnt;
          for i:=0 to seg_cnt-2 do
            begin
              x+=dx;
              y-=dy;
              Point(Trunc(x),
                    Trunc(y),
                    bmp_dst_ptr,
                    bmp_dst_width,
                    color_info);
            end;
        end;
    end
  else
    begin
      dx:=(x0-x1)/seg_cnt;
      if  (y1>y0) then
        begin
          dy:=(y1-y0)/seg_cnt;
          for i:=0 to seg_cnt-2 do
            begin
              x-=dx;
              y+=dy;
              Point(Trunc(x),
                    Trunc(y),
                    bmp_dst_ptr,
                    bmp_dst_width,
                    color_info);
            end;
        end
      else
        begin
          dy:=(y0-y1)/seg_cnt;
          for i:=0 to seg_cnt-2 do
            begin
              x-=dx;
              y-=dy;
              Point(Trunc(x),
                    Trunc(y),
                    bmp_dst_ptr,
                    bmp_dst_width,
                    color_info);
            end;
        end;
    end;
end; {$endregion}
// Point:
procedure Point        (constref x,y:integer; constref bmp_dst_ptr  :PInteger; constref bmp_dst_width:TColor    ; constref color_info:TColorInfo);                                                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pixel_ptr: PInteger;
begin
  with color_info do
    begin
      pixel_ptr:=bmp_dst_ptr+(x-1)+bmp_dst_width*(y-1);
      AlphaBlend1(pixel_ptr,r,g,b,alpha1);
      Inc(pixel_ptr);
      AlphaBlend1(pixel_ptr,r,g,b,alpha2);
      Inc(pixel_ptr);
      AlphaBlend1(pixel_ptr,r,g,b,alpha1);
      Inc(pixel_ptr,bmp_dst_width-2);
      AlphaBlend1(pixel_ptr,r,g,b,alpha2);
      Inc(pixel_ptr);
      pixel_ptr^:=pix_col;
      Inc(pixel_ptr);
      AlphaBlend1(pixel_ptr,r,g,b,alpha2);
      Inc(pixel_ptr,bmp_dst_width-2);
      AlphaBlend1(pixel_ptr,r,g,b,alpha1);
      Inc(pixel_ptr);
      AlphaBlend1(pixel_ptr,r,g,b,alpha2);
      Inc(pixel_ptr);
      AlphaBlend1(pixel_ptr,r,g,b,alpha1);
    end;
end; {$endregion}
procedure Point        (constref x,y:integer; constref bmp_dst_ptr  :PInteger; constref bmp_dst_width:TColor    ; constref color_info:TColorInfo; constref clip_rect:TPtRect);                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pixel_ptr: PInteger;
begin
  with clip_rect,color_info do
    if (x-1>left  ) and
       (x+1<right ) and
       (y-1>top   ) and
       (y+1<bottom) then
      begin
        pixel_ptr:=bmp_dst_ptr+(x-1)+bmp_dst_width*(y-1);
        AlphaBlend1(pixel_ptr,r,g,b,alpha1);
        Inc(pixel_ptr);
        AlphaBlend1(pixel_ptr,r,g,b,alpha2);
        Inc(pixel_ptr);
        AlphaBlend1(pixel_ptr,r,g,b,alpha1);
        Inc(pixel_ptr,bmp_dst_width-2);
        AlphaBlend1(pixel_ptr,r,g,b,alpha2);
        Inc(pixel_ptr);
        pixel_ptr^:=pix_col;
        Inc(pixel_ptr);
        AlphaBlend1(pixel_ptr,r,g,b,alpha2);
        Inc(pixel_ptr,bmp_dst_width-2);
        AlphaBlend1(pixel_ptr,r,g,b,alpha1);
        Inc(pixel_ptr);
        AlphaBlend1(pixel_ptr,r,g,b,alpha2);
        Inc(pixel_ptr);
        AlphaBlend1(pixel_ptr,r,g,b,alpha1);
    end;
end; {$endregion}
procedure Point        (constref x,y:integer; constref bmp_dst_ptr  :PInteger; constref bmp_dst_width:TColor    ; constref color_info:TColorInfo; constref clip_rect:TPtRect; constref alpha_fade:byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pixel_ptr: PInteger;
begin
  with clip_rect,color_info do
    if (x-1>left  ) and
       (x+1<right ) and
       (y-1>top   ) and
       (y+1<bottom) then
      begin
        pixel_ptr:=bmp_dst_ptr+(x-1)+bmp_dst_width* (y-1);
        AlphaBlendDec(pixel_ptr,r,g,b,alpha2 ,alpha_fade);
        Inc(pixel_ptr);
        AlphaBlendDec(pixel_ptr,r,g,b,alpha1 ,alpha_fade);
        Inc(pixel_ptr);
        AlphaBlendDec(pixel_ptr,r,g,b,alpha2 ,alpha_fade);
        Inc(pixel_ptr,bmp_dst_width-2);
        AlphaBlendDec(pixel_ptr,r,g,b,alpha1 ,alpha_fade);
        Inc(pixel_ptr);
        AlphaBlendDec(pixel_ptr,r,g,b,MAXBYTE,alpha_fade);
        Inc(pixel_ptr);
        AlphaBlendDec(pixel_ptr,r,g,b,alpha1 ,alpha_fade);
        Inc(pixel_ptr,bmp_dst_width-2);
        AlphaBlendDec(pixel_ptr,r,g,b,alpha2 ,alpha_fade);
        Inc(pixel_ptr);
        AlphaBlendDec(pixel_ptr,r,g,b,alpha1 ,alpha_fade);
        Inc(pixel_ptr);
        AlphaBlendDec(pixel_ptr,r,g,b,alpha2 ,alpha_fade);
    end;
end; {$endregion}
function  PointCollDraw(constref x,y:integer; constref arr_src_width:TColor  ; var      arr_src      :T1Byte1Arr; constref clip_rect :TPtRect): boolean;                                                 inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with clip_rect do
    if (x>left  ) and
       (x<right ) and
       (y>top   ) and
       (y<bottom) then
      begin
        if (arr_src[x+arr_src_width*y]=0) then
          begin
            Result:=False;
            arr_src[x+arr_src_width*y]:=1;
          end
        else
          Result:=True;
      end;
end; {$endregion}
function  PointCollDraw(constref x,y:integer; constref arr_src_width:TColor  ; constref arr_src      :T1Byte1Arr; constref clip_rect :TPtRect; constref b:byte): boolean;                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with clip_rect do
    if (x>clip_rect.left  ) and
       (x<clip_rect.right ) and
       (y>clip_rect.top   ) and
       (y<clip_rect.bottom) then
      Result:=(arr_src[x+arr_src_width*y]<>0);
end; {$endregion}
// Rectangle:
procedure SetRctDupId (var sln_prop_var:TCurveProp); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      dup_pts_id.arr[0]:=pts_rct_tns_left  ;
      dup_pts_id.arr[1]:=pts_rct_tns_top   ;
      dup_pts_id.arr[2]:=pts_rct_tns_right ;
      dup_pts_id.arr[3]:=pts_rct_tns_bottom;
      dup_pts_id.arr[4]:=pts_rct_inn_width ;
      dup_pts_id.arr[5]:=pts_rct_inn_height;
    end;
end; {$endregion}
procedure SetEdsWidth (var sln_prop_var:TCurveProp); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      eds_width_half:=Trunc(eds_width/2);
      if Odd(eds_width) then
        eds_width_odd:=0
      else
        eds_width_odd:=1;
    end;
end; {$endregion}
procedure SetRctWidth (var sln_prop_var:TCurveProp); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      pts_rct_width      :=pts_rct_tns_left +
                           pts_rct_tns_right+
                           pts_rct_inn_width;
      pts_rct_width__half:=pts_rct_width>>1;
      if Odd(pts_rct_width) then
        pts_rct_width__odd:=0
      else
        pts_rct_width__odd:=1;
      pts_width:=pts_rct_width;
    end;
end; {$endregion}
procedure SetRctHeight(var sln_prop_var:TCurveProp); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      pts_rct_height     :=pts_rct_tns_top   +
                           pts_rct_tns_bottom+
                           pts_rct_inn_height;
      pts_rct_height_half:=pts_rct_height>>1;
      if Odd(pts_rct_height) then
        pts_rct_height_odd:=0
      else
        pts_rct_height_odd:=1;
      pts_height:=pts_rct_height;
    end;
end; {$endregion}
procedure SetRctValues(var sln_prop_var:TCurveProp); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      rct_val_arr[0]:=-(pts_rct_inn_width >>1)-pts_rct_tns_left+pts_rct_width__odd;
      rct_val_arr[1]:=-(pts_rct_inn_height>>1)-pts_rct_tns_top +pts_rct_height_odd;
      rct_val_arr[2]:=+(pts_rct_inn_height>>1)+1;
      rct_val_arr[3]:=-(pts_rct_inn_height>>1)                 +pts_rct_height_odd;
      rct_val_arr[4]:=+(pts_rct_inn_width >>1)+1;
    end;
end; {$endregion}
procedure Rectangle   (constref x,y:integer; constref arr_dst_ptr:PInteger; constref arr_dst_width,arr_dst_height:TColor; constref rct_dst:TPtRect; constref sln_prop_var:TCurveProp                                   ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      // rct_top:
      PPFloodFill(arr_dst_ptr,
                  ClippedRct(rct_dst,
                             PtBounds(x+rct_val_arr[0],
                                      y+rct_val_arr[1],
                                      pts_rct_width,
                                      pts_rct_tns_top)),
                  arr_dst_width,
                  pts_col_inv);
      // rct_bottom:
      PPFloodFill(arr_dst_ptr,
                  ClippedRct(rct_dst,
                             PtBounds(x+rct_val_arr[0],
                                      y+rct_val_arr[2],
                                      pts_rct_width,
                                      pts_rct_tns_bottom)),
                  arr_dst_width,
                  pts_col_inv);
      // rct_left:
      PPFloodFill(arr_dst_ptr,
                  ClippedRct(rct_dst,
                             PtBounds(x+rct_val_arr[0],
                                      y+rct_val_arr[3],
                                      pts_rct_tns_left,
                                      pts_rct_inn_height)),
                  arr_dst_width,
                  pts_col_inv);
      // rct_right:
      PPFloodFill(arr_dst_ptr,
                  ClippedRct(rct_dst,
                             PtBounds(x+rct_val_arr[4],
                                      y+rct_val_arr[3],
                                      pts_rct_tns_right,
                                      pts_rct_inn_height)),
                  arr_dst_width,
                  pts_col_inv);
    end;
end; {$endregion}
procedure Rectangle   (constref x,y:integer; constref arr_dst_ptr:PInteger; constref arr_dst_width,arr_dst_height:TColor; constref rct_dst:TPtRect; constref sln_prop_var:TCurveProp; constref PPFloodFillProc:TProc4  ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      // rct_top:
      PPFloodFillProc(arr_dst_ptr,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[0],
                                          y+rct_val_arr[1],
                                          pts_rct_width,
                                          pts_rct_tns_top)),
                      arr_dst_width);
      // rct_bottom:
      PPFloodFillProc(arr_dst_ptr,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[0],
                                          y+rct_val_arr[2],
                                          pts_rct_width,
                                          pts_rct_tns_bottom)),
                      arr_dst_width);
      // rct_left:
      PPFloodFillProc(arr_dst_ptr,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[0],
                                          y+rct_val_arr[3],
                                          pts_rct_tns_left,
                                          pts_rct_inn_height)),
                      arr_dst_width);
      // rct_right:
      PPFloodFillProc(arr_dst_ptr,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[4],
                                          y+rct_val_arr[3],
                                          pts_rct_tns_right,
                                          pts_rct_inn_height)),
                      arr_dst_width);
    end;
end; {$endregion}
procedure Rectangle   (constref x,y:integer; constref arr_dst_ptr:PByte   ; constref arr_dst_width,arr_dst_height:TColor; constref rct_dst:TPtRect; constref sln_prop_var:TCurveProp; constref PPFloodFillProc:TProc4_1); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      // rct_top:
      PPFloodFillProc(arr_dst_ptr,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[0],
                                          y+rct_val_arr[1],
                                          pts_rct_width,
                                          pts_rct_tns_top)),
                      arr_dst_width);
      // rct_bottom:
      PPFloodFillProc(arr_dst_ptr,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[0],
                                          y+rct_val_arr[2],
                                          pts_rct_width,
                                          pts_rct_tns_bottom)),
                      arr_dst_width);
      // rct_left:
      PPFloodFillProc(arr_dst_ptr,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[0],
                                          y+rct_val_arr[3],
                                          pts_rct_tns_left,
                                          pts_rct_inn_height)),
                      arr_dst_width);
      // rct_right:
      PPFloodFillProc(arr_dst_ptr,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[4],
                                          y+rct_val_arr[3],
                                          pts_rct_tns_right,
                                          pts_rct_inn_height)),
                      arr_dst_width);
    end;
end; {$endregion}
procedure Rectangle   (                      constref arr_dst_ptr:PInteger; constref arr_dst_width,arr_dst_height:TColor; constref rct_dst:TPtRect; constref col:TColor                                                ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_prop: TCurveProp;
begin
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  with rct_prop do
    begin
      pts_col           :=col;
      pts_col_inv       :=SetColorInv(col);
      pts_rct_tns_left  :=1;
      pts_rct_tns_top   :=1;
      pts_rct_tns_right :=1;
      pts_rct_tns_bottom:=1;
      pts_rct_inn_width :=rct_dst.width ;
      pts_rct_inn_height:=rct_dst.height;
      SetRctWidth (rct_prop);
      SetRctHeight(rct_prop);
      SetRctValues(rct_prop);
      Rectangle
      (
        rct_dst.left+rct_dst.width >>1-pts_rct_width__odd,
        rct_dst.top +rct_dst.height>>1-pts_rct_height_odd,
        arr_dst_ptr,
        arr_dst_width,
        arr_dst_height,
        PtBounds
        (
          rct_dst.left  -1,
          rct_dst.top   -1,
          rct_dst.right +1,
          rct_dst.bottom+1
        ),
        rct_prop
      );
    end;
end; {$endregion}
// Rhombus:
{TODO}
procedure Rombus(constref x,y:integer;        constref bmp_dst_ptr:PInteger;                           constref bmp_dst_width:TColor; constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pixel_ptr: PInteger;
begin
  with color_info do
    begin

    end;
end; {$endregion}
// Circle Drawing(Midpoint Algorithm):
procedure Circle (constref x0,y0,rad:integer; constref bmp_dst_ptr:PInteger;                           constref bmp_dst_width:TColor; constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p   : PInteger;
  x,x1: integer;
  y,y1: integer;
  err : integer;
begin
  p   :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x   :=rad;
  y   :=0;
  err :=0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      (p+y-x1)^:=color_info.pix_col;
      (p+x-y1)^:=color_info.pix_col;
      (p+x+y1)^:=color_info.pix_col;
      (p+y+x1)^:=color_info.pix_col;
      (p-y+x1)^:=color_info.pix_col;
      (p-x+y1)^:=color_info.pix_col;
      (p-x-y1)^:=color_info.pix_col;
      (p-y-x1)^:=color_info.pix_col;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure Circle (constref x0,y0,rad:integer; constref bmp_dst_ptr:PInteger;                           constref bmp_dst_width:TColor; constref val       :TColor    ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p   : PInteger;
  x,x1: integer;
  y,y1: integer;
  err : integer;
begin
  p   :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x   :=rad;
  y   :=0;
  err :=0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      (p+y-x1)^:=val;
      (p+x-y1)^:=val;
      (p+x+y1)^:=val;
      (p+y+x1)^:=val;
      (p-y+x1)^:=val;
      (p-x+y1)^:=val;
      (p-x-y1)^:=val;
      (p-y-x1)^:=val;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure Circle (constref x0,y0,rad:integer; constref bmp_dst_ptr:PInteger;                           constref bmp_dst_width:TColor                                ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p   : PByte;
  x,x1: integer;
  y,y1: integer;
  err : integer;
begin
  p   :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x   :=rad;
  y   :=0;
  err :=0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      (p+y-x1)^+=1;
      (p+x-y1)^+=1;
      (p+x+y1)^+=1;
      (p+y+x1)^+=1;
      (p-y+x1)^+=1;
      (p-x+y1)^+=1;
      (p-x-y1)^+=1;
      (p-y-x1)^+=1;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure Circle (constref x0,y0,rad:integer; constref bmp_dst_ptr:PByte   ;                           constref bmp_dst_width:TColor; constref val       :byte      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p   : PByte;
  x,x1: integer;
  y,y1: integer;
  err : integer;
begin
  p   :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x   :=rad;
  y   :=0;
  err :=0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      (p+y-x1)^:=val;
      (p+x-y1)^:=val;
      (p+x+y1)^:=val;
      (p+y+x1)^:=val;
      (p-y+x1)^:=val;
      (p-x+y1)^:=val;
      (p-x-y1)^:=val;
      (p-y-x1)^:=val;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure Circle (constref x0,y0,rad:integer; constref bmp_dst_ptr:PByte   ;                           constref bmp_dst_width:TColor                                ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p   : PByte;
  x,x1: integer;
  y,y1: integer;
  err : integer;
begin
  p   :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x   :=rad;
  y   :=0;
  err :=0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      (p+y-x1)^+=1;
      (p+x-y1)^+=1;
      (p+x+y1)^+=1;
      (p+y+x1)^+=1;
      (p-y+x1)^+=1;
      (p-x+y1)^+=1;
      (p-x-y1)^+=1;
      (p-y-x1)^+=1;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure CircleC(constref x0,y0,rad:integer; constref bmp_dst_ptr:PInteger; constref rct_clp:TPtRect; constref bmp_dst_width:TColor; constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p          : PInteger;
  x,x1       : integer;
  y,y1       : integer;
  err        : integer;
  c0,c1,c2,c3: integer;
begin
  p  :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x  :=rad;
  y  :=0;
  err:=0;
  c0 := rct_clp.left  -x0;
  c1 := rct_clp.right -x0;
  c2 :=-rct_clp.top   +y0;
  c3 :=-rct_clp.bottom+y0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      if (y>=+c0) and (y<+c1) then
        begin
          if (x<=+c2) and (x>+c3) then
             (p+y-x1)^:=color_info.pix_col; //(x0+y)+(y0-x)*arr_dst_width
          if (x>=-c2) and (x<-c3) then
             (p+y+x1)^:=color_info.pix_col; //(x0+y)+(y0+x)*arr_dst_width
        end;
      if (x>=+c0) and (x<+c1) then
        begin
          if (y<=+c2) and (y>+c3) then
             (p+x-y1)^:=color_info.pix_col; //(x0+x)+(y0-y)*arr_dst_width
          if (y>=-c2) and (y<-c3) then
             (p+x+y1)^:=color_info.pix_col; //(x0+x)+(y0+y)*arr_dst_width
        end;
      if (y<=-c0) and (y>-c1) then
        begin
          if (x>=-c2) and (x<-c3) then
             (p-y+x1)^:=color_info.pix_col; //(x0-y)+(y0+x)*arr_dst_width
          if (x<=+c2) and (x>+c3) then
             (p-y-x1)^:=color_info.pix_col; //(x0-y)+(y0-x)*arr_dst_width
        end;
      if (x<=-c0) and (x>-c1) then
        begin
          if (y>=-c2) and (y<-c3) then
             (p-x+y1)^:=color_info.pix_col; //(x0-x)+(y0+y)*arr_dst_width
          if (y<=+c2) and (y>+c3) then
             (p-x-y1)^:=color_info.pix_col; //(x0-x)+(y0-y)*arr_dst_width
        end;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure CircleC(constref x0,y0,rad:integer; constref bmp_dst_ptr:PInteger; constref rct_clp:TPtRect; constref bmp_dst_width:TColor; constref val       :TColor    ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  p          : PInteger;
  rad2       : integer;
  f          : integer;
  d_x        : integer;
  d_y        : integer;
  x,x1       : integer;
  y,y1       : integer;
  c0,c1,c2,c3: integer;
begin
  p   :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  rad2:=rad-1;
  f   := 1-rad2;
  d_x := 0;
  d_y :=-(rad2<<1);
  x   :=0;
  y   :=rad2;
  c0  := rct_clp.left  -x0;
  c1  := rct_clp.right -x0;
  c2  :=-rct_clp.top   +y0;
  c3  :=-rct_clp.bottom+y0;
  (p+rad2*bmp_dst_width)^:=val;
  (p-rad2*bmp_dst_width)^:=val;
  (p+rad2              )^:=val;
  (p-rad2              )^:=val;
  while (x<y) do
    begin
      if (f>=0) then
        begin
          Dec(y);
          d_y+=2;
          f  +=d_y;
        end;
      Inc(x);
      d_x+=2;
      f  +=d_x+1;
      x1 :=x*bmp_dst_width;
      y1 :=y*bmp_dst_width;
      (p+x+y1)^:=val;
      (p-x+y1)^:=val;
      (p+x-y1)^:=val;
      (p-x-y1)^:=val;
      (p+y+x1)^:=val;
      (p-y+x1)^:=val;
      (p+y-x1)^:=val;
      (p-y-x1)^:=val;
    end;}
var
  p          : PInteger;
  x,x1       : integer;
  y,y1       : integer;
  err        : integer;
  c0,c1,c2,c3: integer;
begin
  p  :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x  :=rad;
  y  :=0;
  err:=0;
  c0 := rct_clp.left  -x0;
  c1 := rct_clp.right -x0;
  c2 :=-rct_clp.top   +y0;
  c3 :=-rct_clp.bottom+y0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      if (y>=+c0) and (y<+c1) then
        begin
          if (x<=+c2) and (x>+c3) then
             (p+y-x1)^:=val; //(x0+y)+(y0-x)*arr_dst_width
          if (x>=-c2) and (x<-c3) then
             (p+y+x1)^:=val; //(x0+y)+(y0+x)*arr_dst_width
        end;
      if (x>=+c0) and (x<+c1) then
        begin
          if (y<=+c2) and (y>+c3) then
             (p+x-y1)^:=val; //(x0+x)+(y0-y)*arr_dst_width
          if (y>=-c2) and (y<-c3) then
             (p+x+y1)^:=val; //(x0+x)+(y0+y)*arr_dst_width
        end;
      if (y<=-c0) and (y>-c1) then
        begin
          if (x>=-c2) and (x<-c3) then
             (p-y+x1)^:=val; //(x0-y)+(y0+x)*arr_dst_width
          if (x<=+c2) and (x>+c3) then
             (p-y-x1)^:=val; //(x0-y)+(y0-x)*arr_dst_width
        end;
      if (x<=-c0) and (x>-c1) then
        begin
          if (y>=-c2) and (y<-c3) then
             (p-x+y1)^:=val; //(x0-x)+(y0+y)*arr_dst_width
          if (y<=+c2) and (y>+c3) then
             (p-x-y1)^:=val; //(x0-x)+(y0-y)*arr_dst_width
        end;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure CircleC(constref x0,y0,rad:integer; constref bmp_dst_ptr:PInteger; constref rct_clp:TPtRect; constref bmp_dst_width:TColor                                ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p          : PInteger;
  x,x1       : integer;
  y,y1       : integer;
  err        : integer;
  c0,c1,c2,c3: integer;
begin
  p  :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x  :=rad;
  y  :=0;
  err:=0;
  c0 := rct_clp.left  -x0;
  c1 := rct_clp.right -x0;
  c2 :=-rct_clp.top   +y0;
  c3 :=-rct_clp.bottom+y0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      if (y>=+c0) and (y<+c1) then
        begin
          if (x<=+c2) and (x>+c3) then
             (p+y-x1)^+=1; //(x0+y)+(y0-x)*arr_dst_width
          if (x>=-c2) and (x<-c3) then
             (p+y+x1)^+=1; //(x0+y)+(y0+x)*arr_dst_width
        end;
      if (x>=+c0) and (x<+c1) then
        begin
          if (y<=+c2) and (y>+c3) then
             (p+x-y1)^+=1; //(x0+x)+(y0-y)*arr_dst_width
          if (y>=-c2) and (y<-c3) then
             (p+x+y1)^+=1; //(x0+x)+(y0+y)*arr_dst_width
        end;
      if (y<=-c0) and (y>-c1) then
        begin
          if (x>=-c2) and (x<-c3) then
             (p-y+x1)^+=1; //(x0-y)+(y0+x)*arr_dst_width
          if (x<=+c2) and (x>+c3) then
             (p-y-x1)^+=1; //(x0-y)+(y0-x)*arr_dst_width
        end;
      if (x<=-c0) and (x>-c1) then
        begin
          if (y>=-c2) and (y<-c3) then
             (p-x+y1)^+=1; //(x0-x)+(y0+y)*arr_dst_width
          if (y<=+c2) and (y>+c3) then
             (p-x-y1)^+=1; //(x0-x)+(y0-y)*arr_dst_width
        end;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure CircleC(constref x0,y0,rad:integer; constref bmp_dst_ptr:PByte   ; constref rct_clp:TPtRect; constref bmp_dst_width:TColor; constref val       :byte      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p          : PByte;
  x,x1       : integer;
  y,y1       : integer;
  err        : integer;
  c0,c1,c2,c3: integer;
begin
  p  :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x  :=rad;
  y  :=0;
  err:=0;
  c0 := rct_clp.left  -x0;
  c1 := rct_clp.right -x0;
  c2 :=-rct_clp.top   +y0;
  c3 :=-rct_clp.bottom+y0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      if (y>=+c0) and (y<+c1) then
        begin
          if (x<=+c2) and (x>+c3) then
             (p+y-x1)^:=val; //(x0+y)+(y0-x)*arr_dst_width
          if (x>=-c2) and (x<-c3) then
             (p+y+x1)^:=val; //(x0+y)+(y0+x)*arr_dst_width
        end;
      if (x>=+c0) and (x<+c1) then
        begin
          if (y<=+c2) and (y>+c3) then
             (p+x-y1)^:=val; //(x0+x)+(y0-y)*arr_dst_width
          if (y>=-c2) and (y<-c3) then
             (p+x+y1)^:=val; //(x0+x)+(y0+y)*arr_dst_width
        end;
      if (y<=-c0) and (y>-c1) then
        begin
          if (x>=-c2) and (x<-c3) then
             (p-y+x1)^:=val; //(x0-y)+(y0+x)*arr_dst_width
          if (x<=+c2) and (x>+c3) then
             (p-y-x1)^:=val; //(x0-y)+(y0-x)*arr_dst_width
        end;
      if (x<=-c0) and (x>-c1) then
        begin
          if (y>=-c2) and (y<-c3) then
             (p-x+y1)^:=val; //(x0-x)+(y0+y)*arr_dst_width
          if (y<=+c2) and (y>+c3) then
             (p-x-y1)^:=val; //(x0-x)+(y0-y)*arr_dst_width
        end;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure CircleC(constref x0,y0,rad:integer; constref bmp_dst_ptr:PByte   ; constref rct_clp:TPtRect; constref bmp_dst_width:TColor                                ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p          : PByte;
  x,x1       : integer;
  y,y1       : integer;
  err        : integer;
  c0,c1,c2,c3: integer;
begin
  p  :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x  :=rad;
  y  :=0;
  err:=0;
  c0 := rct_clp.left  -x0;
  c1 := rct_clp.right -x0;
  c2 :=-rct_clp.top   +y0;
  c3 :=-rct_clp.bottom+y0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      if (y>=+c0) and (y<+c1) then
        begin
          if (x<=+c2) and (x>+c3) then
             (p+y-x1)^+=1; //(x0+y)+(y0-x)*arr_dst_width
          if (x>=-c2) and (x<-c3) then
             (p+y+x1)^+=1; //(x0+y)+(y0+x)*arr_dst_width
        end;
      if (x>=+c0) and (x<+c1) then
        begin
          if (y<=+c2) and (y>+c3) then
             (p+x-y1)^+=1; //(x0+x)+(y0-y)*arr_dst_width
          if (y>=-c2) and (y<-c3) then
             (p+x+y1)^+=1; //(x0+x)+(y0+y)*arr_dst_width
        end;
      if (y<=-c0) and (y>-c1) then
        begin
          if (x>=-c2) and (x<-c3) then
             (p-y+x1)^+=1; //(x0-y)+(y0+x)*arr_dst_width
          if (x<=+c2) and (x>+c3) then
             (p-y-x1)^+=1; //(x0-y)+(y0-x)*arr_dst_width
        end;
      if (x<=-c0) and (x>-c1) then
        begin
          if (y>=-c2) and (y<-c3) then
             (p-x+y1)^+=1; //(x0-x)+(y0+y)*arr_dst_width
          if (y<=+c2) and (y>+c3) then
             (p-x-y1)^+=1; //(x0-x)+(y0-y)*arr_dst_width
        end;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
// Wave Search:
function CircleW (constref x0,y0,rad:integer; constref arr_dst:TPtPos3Arr;                           constref arr_dst_width:TColor; var pt:TPtPosF): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p     : PPtPos3;
  x,x1  : integer;
  y,y1  : integer;
  err   : integer;
begin
  Result:=False;
  p     :=Unaligned(@arr_dst[x0+y0*arr_dst_width]);
  x     :=rad;
  y     :=0;
  err   :=0;
  while (x>=y) do
    begin
      x1:=x*arr_dst_width;
      y1:=y*arr_dst_width;
      if ((p+y-x1)^.obj_ind<>-1) then //(x0+y)+(y0-x)*arr_dst_width
        begin
          pt    :=PtPosF(x0+y,y0-x);
          Result:=True;
          Exit;
        end;
      if ((p+x-y1)^.obj_ind<>-1) then //(x0+x)+(y0-y)*arr_dst_width
        begin
          pt    :=PtPosF(x0+x,y0-y);
          Result:=True;
          Exit;
        end;
      if ((p+x+y1)^.obj_ind<>-1) then //(x0+x)+(y0+y)*arr_dst_width
        begin
          pt    :=PtPosF(x0+x,y0+y);
          Result:=True;
          Exit;
        end;
      if ((p+y+x1)^.obj_ind<>-1) then //(x0+y)+(y0+x)*arr_dst_width
        begin
          pt    :=PtPosF(x0+y,y0+x);
          Result:=True;
          Exit;
        end;
      if ((p-y+x1)^.obj_ind<>-1) then //(x0-y)+(y0+x)*arr_dst_width
        begin
          pt    :=PtPosF(x0-y,y0+x);
          Result:=True;
          Exit;
        end;
      if ((p-x+y1)^.obj_ind<>-1) then //(x0-x)+(y0+y)*arr_dst_width
        begin
          pt    :=PtPosF(x0-x,y0+y);
          Result:=True;
          Exit;
        end;
      if ((p-x-y1)^.obj_ind<>-1) then //(x0-x)+(y0-y)*arr_dst_width
        begin
          pt    :=PtPosF(x0-x,y0-y);
          Result:=True;
          Exit;
        end;
      if ((p-y-x1)^.obj_ind<>-1) then //(x0-y)+(y0-x)*arr_dst_width
        begin
          pt    :=PtPosF(x0-y,y0-x);
          Result:=True;
          Exit;
        end;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
function CircleWC(constref x0,y0,rad:integer; constref arr_dst:TPtPos3Arr; constref rct_clp:TPtRect; constref arr_dst_width:TColor; var pt:TPtPosF): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p          : PPtPos3;
  x,x1       : integer;
  y,y1       : integer;
  err        : integer;
  c0,c1,c2,c3: integer;
begin
  Result:=False;
  p     :=Unaligned(@arr_dst[x0+y0*arr_dst_width]);
  x     :=rad;
  y     :=0;
  err   :=0;
  c0    := rct_clp.left  -x0;
  c1    := rct_clp.right -x0;
  c2    :=-rct_clp.top   +y0;
  c3    :=-rct_clp.bottom+y0;
  while (x>=y) do
    begin
      x1:=x*arr_dst_width;
      y1:=y*arr_dst_width;
      if (y>=+c0) and (y<+c1) then
        begin
          if (x<=+c2) and (x>+c3) and ((p+y-x1)^.obj_ind<>-1) then //(x0+y)+(y0-x)*arr_dst_width
            begin
              pt    :=PtPosF(x0+y,y0-x);
              Result:=True;
              Exit;
            end;
          if (x>=-c2) and (x<-c3) and ((p+y+x1)^.obj_ind<>-1) then //(x0+y)+(y0+x)*arr_dst_width
            begin
              pt    :=PtPosF(x0+y,y0+x);
              Result:=True;
              Exit;
            end;
        end;
      if (x>=+c0) and (x<+c1) then
        begin
          if (y<=+c2) and (y>+c3) and ((p+x-y1)^.obj_ind<>-1) then //(x0+x)+(y0-y)*arr_dst_width
            begin
              pt    :=PtPosF(x0+x,y0-y);
              Result:=True;
              Exit;
            end;
          if (y>=-c2) and (y<-c3) and ((p+x+y1)^.obj_ind<>-1) then //(x0+x)+(y0+y)*arr_dst_width
            begin
              pt    :=PtPosF(x0+x,y0+y);
              Result:=True;
              Exit;
            end;
        end;
      if (y<=-c0) and (y>-c1) then
        begin
          if (x>=-c2) and (x<-c3) and ((p-y+x1)^.obj_ind<>-1) then //(x0-y)+(y0+x)*arr_dst_width
            begin
              pt    :=PtPosF(x0-y,y0+x);
              Result:=True;
              Exit;
            end;
          if (x<=+c2) and (x>+c3) and ((p-y-x1)^.obj_ind<>-1) then //(x0-y)+(y0-x)*arr_dst_width
          begin
            pt    :=PtPosF(x0-y,y0-x);
            Result:=True;
            Exit;
          end;
        end;
      if (x<=-c0) and (x>-c1) then
        begin
          if (y>=-c2) and (y<-c3) and ((p-x+y1)^.obj_ind<>-1) then //(x0-x)+(y0+y)*arr_dst_width
            begin
              pt    :=PtPosF(x0-x,y0+y);
              Result:=True;
              Exit;
            end;
          if (y<=+c2) and (y>+c3) and ((p-x-y1)^.obj_ind<>-1) then //(x0-x)+(y0-y)*arr_dst_width
            begin
              pt    :=PtPosF(x0-x,y0-y);
              Result:=True;
              Exit;
            end;
        end;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
// Circle FloodFill:
procedure CircleFloodFill(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref rct_out:TPtRect; constref bmp_dst_width:TColor; constref color_info:TColorInfo; constref diam:TColor; constref pow:byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  rad1_sqr :=rad1*rad1;
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x-rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y-rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) and (pixel_ptr^>>24=0) then
            begin
              pixel_ptr^:=AlphaBlendB(pixel_ptr^,color_info.pix_col,pow)
                         {HighlightA (pixel_ptr^,pow)};
              pixel_ptr^+=%00000001000000000000000000000000;
            end;
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
// Spotlight:
procedure CircleHighlight(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref rct_out:TPtRect; constref bmp_dst_width:TColor; constref color_info:TColorInfo; constref diam:TColor; constref pow:byte; alpha_max:byte=MAXBYTE); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
  m        : byte;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  rad1_sqr :=rad1*rad1;
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x-rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y-rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) then
            begin
              m:=Max2(pow-Trunc(alpha_max*sqrt(dist_sqr)/rad1),0){Abs(pow-Trunc(alpha_max*sqrt(dist_sqr)/rad1))};
              //if (m<>0) then
                pixel_ptr^:={ColorizeRDec(pixel_ptr^,0,m)}{DarkenA(pixel_ptr^,m)}HighlightA(pixel_ptr^,m);
            end;
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
// (Transparent Text) Прозрачный текст:
procedure SetTextInfo(                      constref dst_canvas:TCanvas; constref height_:integer=27; constref font_color:TColor=$006C754A; constref font_name:string='AR CENA'; constref font_charset:TFontCharSet=ANSI_CHARSET; constref font_quality:TFontQuality=fqAntialiased; constref pen_mode:TFPPenMode=pmXor; constref brush_style:TFPBrushStyle=bsClear); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with dst_canvas do
    begin
      Font .height :=height_;
    //Font .size   :=height_;
      Font .color  :=font_color;
      Font .charset:=font_charset;
      Font .name   :=font_name;
      Font .quality:=font_quality;
      Pen  .mode   :=pen_mode;
      Brush.style  :=brush_style;
    end;
end; {$endregion}
procedure Text       (constref x,y:integer; constref dst_canvas:TCanvas; constref text_:string);                                                                                                                                                                                                                                                                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  dst_canvas.TextOut(x,y,text_);
end; {$endregion}

{$endregion}



(********************************** Blitters **********************************) {$region -fold}

// Get Bitmap Handle:
function  GetBmpHandle(bmp:Graphics.TBitmap): PInteger{pointer}; inline; {$region -fold}
var
  bmp_info: TBitmapInfo;
begin
  bmp_info.bmiHeader.biSize       :=SizeOf(BitmapInfo.bmiHeader);
  bmp_info.bmiHeader.biWidth      :=bmp.Width;
  bmp_info.bmiHeader.biHeight     :=-bmp.Height; // BitMap.Height will invert image on axis X
  bmp_info.bmiHeader.biPlanes     :=1;
  bmp_info.bmiHeader.biBitCount   :=32;
  bmp_info.bmiHeader.biCompression:=BI_RGB;
  bmp.Handle:=CreateDIBSection(bmp.Canvas.Handle,bmp_info,DIB_RGB_COLORS,GetBmpHandle,0,0);
end; {$endregion}
procedure GLBitmapInit(tex_id:TColor; bmp:Graphics.TBitmap; b:boolean); inline; {$region -fold}
begin
  if (not b) then
    glDisable(GL_TEXTURE_2D)
  else
    begin
      glEnable     (GL_TEXTURE_2D);
      glGenTextures(1,@tex_id);
      glBindTexture(GL_TEXTURE_2D,tex_id);
    end;
end; {$endregion}
// Copy One Canvas To Another:
procedure CnvToCnv(rct_dst:TPtRect; cnv_dst,cnv_src:TCanvas; copy_mode:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {$ifdef Windows}
  BitBlt
  (
    cnv_dst.Handle,
    rct_dst.left,
    rct_dst.top,
    rct_dst.width,
    rct_dst.height,
    cnv_src.Handle,
    0,
    0,
    copy_mode
  );
  {StretchBlt
  (
    cnv_dst.Handle,
    rct_dst.left,
    rct_dst.top,
    rct_dst.width,
    rct_dst.height,
    cnv_src.Handle,
    0,
    0,
    rct_dst.width,
    rct_dst.height,
    copy_mode
  );}
  {$else}
  cnv_dst.CopyMode:=copy_mode;
  cnv_dst.CopyRect
  (
    Rect
    (
      rct_dst.left,
      rct_dst.top,
      rct_dst.right,
      rct_dst.bottom
    ),
    cnv_src,
    Rect(0,0,rct_dst.width,rct_dst.height)
  );
  {$endif}
end; {$endregion}
// Blitter1:
procedure BitBlt1  (constref bmp_src_ptr,bmp_dst_ptr:PInteger ; constref rct_src:TPtRect;                             constref rct_dst_left,rct_dst_top,bmp_src_width,bmp_dst_width:integer); inline;                                {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  bits_per_line: integer;
  y,x          : integer;
begin
  bits_per_line:=rct_src.width<<2;
  src_pixel_ptr:=Unaligned(@bmp_src_ptr[rct_src.left+rct_src.top*bmp_src_width]);
  dst_pixel_ptr:=Unaligned(@bmp_dst_ptr[rct_dst_left+rct_dst_top*bmp_dst_width]);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1 do
    begin
      {for x:=0 to rct_src.width-1 do
        if ((src_pixel_ptr+x)^>>24)=MAXBYTE then
        (dst_pixel_ptr+x)^:=(src_pixel_ptr+x)^;}
      Move(src_pixel_ptr^,dst_pixel_ptr^,bits_per_line);
      Inc (src_pixel_ptr,bmp_src_width);
      Inc (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure BitBlt1  (constref bmp_src_ptr,bmp_dst_ptr:PInteger ; constref rct_src_left,rct_src_top,rct_src_width,rct_src_height,rct_dst_left,rct_dst_top,bmp_src_width,bmp_dst_width:integer); inline;                                {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  bits_per_line: integer;
  y            : integer;
begin
  bits_per_line:=rct_src_width<<2;
  src_pixel_ptr:=Unaligned(@bmp_src_ptr[rct_src_left+rct_src_top*bmp_src_width]);
  dst_pixel_ptr:=Unaligned(@bmp_dst_ptr[rct_dst_left+rct_dst_top*bmp_dst_width]);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src_height-1 do
    begin
      Move(src_pixel_ptr^,dst_pixel_ptr^,bits_per_line);
      Inc (src_pixel_ptr,bmp_src_width);
      Inc (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure BitBlt1  (var      arr_src                :TColorArr; constref                          rct_src_width,rct_src_height,rct_dst_left,rct_dst_top                            :integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_med       : TColorArr;
  arr_med_ptr   : PInteger;
  arr_src_ptr   : PInteger;
  bits_per_line : integer;
  y             : integer;
  arr_src_width : integer;
  arr_src_height: integer;
begin
  arr_src_width := rct_dst_left+rct_src_width;
  arr_src_height:= rct_dst_top +rct_src_height;
  SetLength     (  arr_med,    (rct_src_width*rct_src_height));
  arr_med       := arr_src;
  SetLength     (  arr_src     ,arr_src_width*arr_src_height);
  FillDWord     ( Unaligned(@arr_src[0])^,arr_src_width*arr_src_height,0);
  arr_med_ptr   :=Unaligned(@arr_med[00000000000000000000000000000000000000]);
  arr_src_ptr   :=Unaligned(@arr_src[rct_dst_left+rct_dst_top*arr_src_width]);
  bits_per_line := rct_src_width<<2;
  Prefetch(arr_med_ptr);
  Prefetch(arr_src_ptr);
  for y:=0 to rct_src_height-1 do
    begin
      Move(arr_med_ptr^,arr_src_ptr^,bits_per_line);
      Inc (arr_med_ptr,rct_src_width);
      Inc (arr_src_ptr,arr_src_width);
    end;
  SetLength(arr_med,0);
end; {$endregion}
// Blitter2:
procedure BitBlt2  (constref bmp_src_ptr,bmp_dst_ptr:PInteger ; constref rct_src:TPtRect;                             constref rct_dst_left,rct_dst_top,bmp_src_width,bmp_dst_width:integer); inline;                                {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(@bmp_src_ptr[rct_src.left+rct_src.width-1+(rct_src.top+rct_src.height-1)*bmp_src_width]);
  dst_pixel_ptr:=Unaligned(@bmp_dst_ptr[rct_dst_left+rct_src.width-1+(rct_dst_top+rct_src.height-1)*bmp_dst_width]);
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
              dst_pixel_ptr^:=
              src_pixel_ptr^;
          Dec(src_pixel_ptr);
          Dec(dst_pixel_ptr);
        end;
      Dec    (src_pixel_ptr,d_width1);
      Dec    (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
procedure BitBlt2  (constref bmp_src_ptr,bmp_dst_ptr:PInteger ; constref rct_src_left,rct_src_top,rct_src_width,rct_src_height,rct_dst_left,rct_dst_top,bmp_src_width,bmp_dst_width:integer); inline;                                {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  d_width1         :=bmp_src_width-rct_src_width;
  d_width2         :=bmp_dst_width-rct_src_width;
  src_pixel_ptr    :=Unaligned(@bmp_src_ptr[rct_src_left+rct_src_width-1+(rct_src_top+rct_src_height-1)*bmp_src_width]);
  dst_pixel_ptr    :=Unaligned(@bmp_dst_ptr[rct_dst_left+rct_src_width-1+(rct_dst_top+rct_src_height-1)*bmp_dst_width]);
  for y:=0 to rct_src_height-1 do
    begin
      for x:=0 to rct_src_width-1 do
        begin
              dst_pixel_ptr^:=
              src_pixel_ptr^;
          Dec(src_pixel_ptr);
          Dec(dst_pixel_ptr);
        end;
      Dec    (src_pixel_ptr,d_width1);
      Dec    (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
procedure BmpToBmp2(constref bmp_src_ptr,bmp_dst_ptr:PInteger ; constref bmp_src_width,bmp_dst_width:integer; constref clp_rct:TPtRect; constref inn_wnd_mrg_:integer);                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  BitBlt2(bmp_src_ptr,
          bmp_dst_ptr,
          clp_rct.left  -inn_wnd_mrg_,
          clp_rct.top   -inn_wnd_mrg_,
          clp_rct.width +inn_wnd_mrg_<<1,
          clp_rct.height+inn_wnd_mrg_<<1,
          clp_rct.left  -inn_wnd_mrg_,
          clp_rct.top   -inn_wnd_mrg_,
          bmp_src_width,
          bmp_dst_width);
end; {$endregion}
// Blitter3:
procedure BitBlt3  (constref bmp_src_ptr,bmp_dst_ptr:PInteger ; constref rct_src:TPtRect;                             constref rct_dst_left,rct_dst_top,bmp_src_width,bmp_dst_width:integer; transparent_color:TColor); inline; {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(@bmp_src_ptr[rct_src.left+rct_src.width-1+(rct_src.top+rct_src.height-1)*bmp_src_width]);
  dst_pixel_ptr:=Unaligned(@bmp_dst_ptr[rct_dst_left+rct_src.width-1+(rct_dst_top+rct_src.height-1)*bmp_dst_width]);
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
          if (src_pixel_ptr^<>transparent_color) then
              dst_pixel_ptr^:=src_pixel_ptr^;
          Dec(src_pixel_ptr);
          Dec(dst_pixel_ptr);
        end;
      Dec    (src_pixel_ptr,d_width1);
      Dec    (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
procedure BitBlt3  (constref bmp_src_ptr,bmp_dst_ptr:PInteger ; constref rct_src_left,rct_src_top,rct_src_width,rct_src_height,rct_dst_left,rct_dst_top,bmp_src_width,bmp_dst_width:integer; transparent_color:TColor); inline; {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  d_width1         :=bmp_src_width-rct_src_width;
  d_width2         :=bmp_dst_width-rct_src_width;
  src_pixel_ptr    :=Unaligned(@bmp_src_ptr[rct_src_left+rct_src_width-1+(rct_src_top+rct_src_height-1)*bmp_src_width]);
  dst_pixel_ptr    :=Unaligned(@bmp_dst_ptr[rct_dst_left+rct_src_width-1+(rct_dst_top+rct_src_height-1)*bmp_dst_width]);
  for y:=0 to rct_src_height-1 do
    begin
      for x:=0 to rct_src_width-1 do
        begin
          if (src_pixel_ptr^<>transparent_color) then
              dst_pixel_ptr^:=
              src_pixel_ptr^;
          Dec(src_pixel_ptr);
          Dec(dst_pixel_ptr);
        end;
      Dec    (src_pixel_ptr,d_width1);
      Dec    (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}

{$endregion}



(****************************** Image Transform *******************************) {$region -fold}

// Scale:
procedure ImgScl(constref bmp_src_ptr:PInteger; constref bmp_dst_ptr:PInteger; constref bmp_dst_width,bmp_dst_height:TColor; constref ker_w,ker_h:integer); inline; {$ifdef Linux}[local];{$endif} deprecated; {$region -fold}
var
  bmp_src_ptr2: PInteger;
  bmp_src_ptr3: PInteger;
  bmp_dst_ptr2: PInteger;
  ker_prod_inv: double;
  ker_prod    : integer;
  ker_h_prod  : integer;
  ker_w_int   : integer;
  ker_h_int   : integer;
  d_width_ker : integer;
  width_j_prod: integer;
  w,h         : integer;
  x,y         : integer;
  i,j         : integer;
  r,g,b       : integer;
begin
  ker_w_int   :=ker_w-1;
  ker_h_int   :=ker_h-1;
  ker_prod    :=ker_w*ker_h;
  ker_prod_inv:=1/ker_prod;
  ker_h_prod  :=ker_h*bmp_dst_width;
  w           :=Trunc(bmp_dst_width /ker_w)-1;
  h           :=Trunc(bmp_dst_height/ker_h)-1;
  d_width_ker :=bmp_dst_width-w-1;
  bmp_src_ptr2:=bmp_src_ptr;
  bmp_dst_ptr2:=bmp_dst_ptr;
  for y:=0 to h do
    begin
      for x:=0 to w do
        begin
          bmp_src_ptr3:=Unaligned(bmp_src_ptr2+x*ker_w+y*ker_h_prod);
          width_j_prod:=0;
          r           :=0;
          for j:=0 to ker_h_int do
            begin
              for i:=0 to ker_w_int do
                r+=TRGBA((bmp_src_ptr3+i+width_j_prod)^).r;
              Inc(width_j_prod,bmp_dst_width);
            end;
          width_j_prod:=0;
          g           :=0;
          for j:=0 to ker_h_int do
            begin
              for i:=0 to ker_w_int do
                g+=TRGBA((bmp_src_ptr3+i+width_j_prod)^).g;
              Inc(width_j_prod,bmp_dst_width);
            end;
          width_j_prod:=0;
          b           :=0;
          for j:=0 to ker_h_int do
            begin
              for i:=0 to ker_w_int do
                b+=TRGBA((bmp_src_ptr3+i+width_j_prod)^).b;
              Inc(width_j_prod,bmp_dst_width);
            end;
          bmp_dst_ptr2^:=RGB(Trunc(r*ker_prod_inv),
                             Trunc(g*ker_prod_inv),
                             Trunc(b*ker_prod_inv));
          Inc(bmp_dst_ptr2);
        end;
      Inc(bmp_dst_ptr2,d_width_ker);
      //Application.ProcessMessages;
    end;
end; {$endregion}

{
procedure BlurLineX(src,dest:PInteger; w,rad,km:integer);
var
  c,x: integer;
begin
  c:=0;
  for x:=1 to rad-1 do
    c+=src[x];
  c+=c+src[0];
  for x:=0 to rad-1 do
    begin
      dest[x]:=c*km>>16;
      c+=src[rad+x+1];
      c-=src[rad-x];
    end;
  for x:=rad to w-rad-2 do
    begin
      dest[x]:=c*km>>16;
      c+=src[rad+x+1];
      c-=src[x-rad];
    end;
  for x:=w-rad-1 to w-1 do
    begin
      dest[x]:=c*km>>16;
      c+=src[w+w-x-rad-2];
      c-=src[x-rad];
    end;
end;

procedure BlurLineX(src,dest:PInteger; w,rad,km:integer);
var
  end_,dst_,beg_: PInteger;
  c        : integer;
begin
  end_:=src+1;
  dst_:=dest;
  c   :=0;
  while (end_<=src+rad) do
    begin
      c+=end_^;
      end_+=1;
    end;
  c+=c+src^;
  beg_:=end_-1;
  while (beg_>src) do
    begin
      dst_^++=c*km>>16;
      c-=beg_^;
      beg_^-=1;
      c+=end_^;
      end_+=1;
    end;
  while (end_<src+w-1) do
    begin
      dst_^++=c*km>>16;
      c-=beg_^;
      beg_^+=1;
      c+=end_^;
      end_^+=1;
    end;
  while (dst_<dest+w) do
    begin
      dst_^++=c*km>>16;
      c-=beg_^;
      beg_^+=1;
      c+=end_^;
      c_^-=1;
    end;
end;
}

// Rotate:
procedure ImgRotLoop0(                     constref rct_src        :TPtRect;          bmp_src_ptr,bmp_dst_ptr:PInteger; constref bmp_dst_width,d_width,c,s,v,w,lt,tp,rt,bt:integer; constref mask_alpha:TColor                                                                                       ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,i,j: integer;
begin
  for j:=0 to rct_src.height-1 do
    begin
      x:=v+j*s;
      y:=w-j*c;
      for i:=0 to rct_src.width-1 do
        begin
              bmp_dst_ptr[(x>>16)+(y>>16)*bmp_dst_width]:=
              bmp_src_ptr^;
          Inc(bmp_src_ptr);
          x-=c;
          y-=s;
        end;
      Inc(bmp_src_ptr,d_width);
    end;
end; {$endregion}
procedure ImgRotLoop1(                     constref rct_src        :TPtRect;          bmp_src_ptr,bmp_dst_ptr:PInteger; constref bmp_dst_width,d_width,c,s,v,w,lt,tp,rt,bt:integer; constref mask_alpha:TColor                                                                                       ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,i,j: integer;
begin
  for j:=0 to rct_src.height-1 do
    begin
      x:=v+j*s;
      y:=w-j*c;
      for i:=0 to rct_src.width-1 do
        begin
          if (x>lt) and (x<rt) and (y>tp) and (y<bt) then
              bmp_dst_ptr[(x>>16)+(y>>16)*bmp_dst_width]:=
              bmp_src_ptr^;
          Inc(bmp_src_ptr);
          x-=c;
          y-=s;
        end;
      Inc(bmp_src_ptr,d_width);
    end;
end; {$endregion}
procedure ImgRotLoop2(                     constref rct_src        :TPtRect;          bmp_src_ptr,bmp_dst_ptr:PInteger; constref bmp_dst_width,d_width,c,s,v,w,lt,tp,rt,bt:integer; constref mask_alpha:TColor                                                                                       ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,i,j: integer;
begin
  for j:=0 to rct_src.height-1 do
    begin
      x:=v+j*s;
      y:=w-j*c;
      for i:=0 to rct_src.width-1 do
        begin
              bmp_dst_ptr[(x>>16)+(y>>16)*bmp_dst_width]:=
              bmp_src_ptr^<<8>>8+mask_alpha;
          Inc(bmp_src_ptr);
          x-=c;
          y-=s;
        end;
      Inc(bmp_src_ptr,d_width);
    end;
end; {$endregion}
procedure ImgRotLoop3(                     constref rct_src        :TPtRect;          bmp_src_ptr,bmp_dst_ptr:PInteger; constref bmp_dst_width,d_width,c,s,v,w,lt,tp,rt,bt:integer; constref mask_alpha:TColor                                                                                       ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,i,j: integer;
begin
  for j:=0 to rct_src.height-1 do
    begin
      x:=v+j*s;
      y:=w-j*c;
      for i:=0 to rct_src.width-1 do
        begin
          if (x>lt) and (x<rt) and (y>tp) and (y<bt) then
              bmp_dst_ptr[(x>>16)+(y>>16)*bmp_dst_width]:=
              bmp_src_ptr^<<8>>8+mask_alpha;
          Inc(bmp_src_ptr);
          x-=c;
          y-=s;
        end;
      Inc(bmp_src_ptr,d_width);
    end;
end; {$endregion}
procedure ImgRotLoop4(                     constref rct_src        :TPtRect;          bmp_src_ptr,bmp_dst_ptr:PInteger; constref bmp_dst_width,d_width,c,s,v,w,lt,tp,rt,bt:integer; constref mask_alpha:TColor                                                                                       ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,i,j: integer;
begin
  for j:=0 to rct_src.height-1 do
    begin
      x:=v+j*s;
      y:=w-j*c;
      for i:=0 to rct_src.width-1 do
        begin
          bmp_dst_ptr[(x>>16)+(y>>16)*bmp_dst_width]:=mask_alpha;
          x-=c;
          y-=s;
        end;
    end;
end; {$endregion}
procedure ImgRotLoop5(                     constref rct_src        :TPtRect;          bmp_src_ptr,bmp_dst_ptr:PInteger; constref bmp_dst_width,d_width,c,s,v,w,lt,tp,rt,bt:integer; constref mask_alpha:TColor                                                                                       ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,i,j: integer;
begin
  for j:=0 to rct_src.height-1 do
    begin
      x:=v+j*s;
      y:=w-j*c;
      for i:=0 to rct_src.width-1 do
        begin
          if (x>lt) and (x<rt) and (y>tp) and (y<bt) then
            bmp_dst_ptr[(x>>16)+(y>>16)*bmp_dst_width]:=mask_alpha;
          x-=c;
          y-=s;
        end;
    end;
end; {$endregion}
procedure ImgRot1    (constref pvt:TPtPos; constref rct_src,rct_clp:TPtRect; constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref bmp_src_width,bmp_dst_width:TColor; constref angle:double; constref x,y :integer; constref add_alpha_mask:byte; var bounding_rct:TPtRect; constref mask_alpha:TColor); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst     : TPtRect;
  rct_src1    : TPtRect;
  rct_src2    : TPtRect;
  bmp_src_ptr2: PInteger;
  c           : double =0.0;
  s           : double =0.0;
  v           : double =0.0;
  w           : double =0.0;
  c2          : integer=000;
  s2          : integer=000;
  v2          : integer=000;
  w2          : integer=000;
  r,k,d_width : integer;
  lt,tp,rt,bt : integer;
  b           : byte   =001;
begin

  {} {$region -fold}
  if (Trunc(angle) mod 360=0) then
    begin
      rct_src1:=PtRct
      (
        x,
        y,
        x+rct_src.width,
        y+rct_src.height
      );
      rct_dst :=ClippedRct(rct_clp,rct_src1) ;
      if (rct_dst.width=0) or (rct_dst.height=0) then
        Exit;
      r       :=rct_src.width -(rct_dst.right -rct_dst.left);
      k       :=rct_src.height-(rct_dst.bottom-rct_dst.top );
      rct_src2:=PtRct
      (
        rct_src.left+r,
        rct_src.top +k,
        rct_src.right ,
        rct_src.bottom
      );
      BitBlt1
      (
        bmp_src_ptr,
        bmp_dst_ptr,
        rct_src2,
        rct_dst.left,
        rct_dst.top,
        bmp_src_width,
        bmp_dst_width
      );
      Exit;
    end; {$endregion}

  {} {$region -fold}
  GetRot
  (
    PtPos
    (
      x-rct_src.left+pvt.x,
      y-rct_src.top +pvt.y
    ),
    angle,
    c,
    s,
    v,
    w
  ); {$endregion}

  {} {$region -fold}
  b:=1;
  bounding_rct:=ClippedRctB
  (
    rct_clp,
    PtsRot
    (
      PtRct
      (
        x,
        y,
        x-rct_src.left+rct_src.right,
        y-rct_src.top +rct_src.bottom
      ),
      angle,
      c,
      s,
      v,
      w
    ),
    b
  ); {$endregion}

  {} {$region -fold}
  if (b=2) then
    Exit
  else
    begin
      GetRot
      (
        PtPos
        (
          x-rct_src.left+pvt.x,
          y-rct_src.top +pvt.y
        ),
        angle,
        c2,
        s2,
        v2,
        w2,
        x,
        y
      );
      lt          :=rct_clp.left  <<16;
      rt          :=rct_clp.right <<16;
      tp          :=rct_clp.top   <<16;
      bt          :=rct_clp.bottom<<16;
      d_width     :=bmp_src_width-rct_src.width;
      bmp_src_ptr2:=Unaligned(bmp_src_ptr+rct_src.left+rct_src.top*bmp_dst_width);
    end;
  {
  add_alpha_mask values:
  0: copy source to destination without mask;
  1: add mask to alpha channel of destination;
  2: fill destination with specifed value
  }
  case add_alpha_mask of
    0:
      begin
        if (b=0) then
          ImgRotLoop0(rct_src,bmp_src_ptr2,bmp_dst_ptr,bmp_dst_width,d_width,c2,s2,v2,w2,lt,tp,rt,bt,mask_alpha)
        else
          ImgRotLoop1(rct_src,bmp_src_ptr2,bmp_dst_ptr,bmp_dst_width,d_width,c2,s2,v2,w2,lt,tp,rt,bt,mask_alpha);
      end;
    1:
      begin
        if (b=0) then
          ImgRotLoop2(rct_src,bmp_src_ptr2,bmp_dst_ptr,bmp_dst_width,d_width,c2,s2,v2,w2,lt,tp,rt,bt,mask_alpha)
        else
          ImgRotLoop3(rct_src,bmp_src_ptr2,bmp_dst_ptr,bmp_dst_width,d_width,c2,s2,v2,w2,lt,tp,rt,bt,mask_alpha);
      end;
    2:
      begin
        if (b=0) then
          ImgRotLoop4(rct_src,bmp_src_ptr2,bmp_dst_ptr,bmp_dst_width,d_width,c2,s2,v2,w2,lt,tp,rt,bt,mask_alpha)
        else
          ImgRotLoop5(rct_src,bmp_src_ptr2,bmp_dst_ptr,bmp_dst_width,d_width,c2,s2,v2,w2,lt,tp,rt,bt,mask_alpha);
      end;
  end; {$endregion}

end; {$endregion}
procedure ImgRot2    (constref pvt:TPtPos; constref rct_src,rct_clp:TPtRect; constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref bmp_src_width,bmp_dst_width:TColor; constref angle:double; constref x,y,inn_wnd_mrg,bmp_src_height:integer                                                          ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst        : TPtRect;
  rct_src1       : TPtRect;
  rct_src2       : TPtRect;
  rct_src3       : TPtRect;
  bmp_src_ptr2   : PInteger;
  c              : double=0.0;
  s              : double=0.0;
  v              : double=0.0;
  w              : double=0.0;
  x_,y_          : double;
  i,j,r,k,d_width: integer;
  b              : byte;
  v2,w2,ssx,ssy,ssw,ssh,addy,xx,yy,L2,T2,R2,B2,sx,sy,dx,dy,sw,sh,dw,SinA,CosA: integer;
begin
  {if (Trunc(angle) mod 360=0) then
    begin
      rct_src1:=PtRct
      (
        x,
        y,
        x+rct_src.width,
        y+rct_src.height
      );
      rct_dst :=ClippedRct(rct_clp,rct_src1) ;
      if (rct_dst.width=0) or (rct_dst.height=0) then
        Exit;
      r       :=rct_src.width -(rct_dst.right -rct_dst.left);
      k       :=rct_src.height-(rct_dst.bottom-rct_dst.top );
      rct_src2:=PtRct
      (
        rct_src.left+r,
        rct_src.top +k,
        rct_src.right ,
        rct_src.bottom
      );
      BitBlt1
      (
        bmp_src_ptr,
        bmp_dst_ptr,
        rct_src2,
        rct_dst.left-pvt.x,
        rct_dst.top -pvt.y,
        bmp_src_width,
        bmp_dst_width
      );
      Exit;
    end;
  GetRot
  (
    PtPos
    (
      x-rct_src.left+pvt.x,
      y-rct_src.top +pvt.y
    ),
    angle,
    c,
    s,
    v,
    w
  );
  rct_src3:=ClippedRctB
  (
    rct_clp,
    PtsRot
    (
      PtRct
      (
        x,
        y,
        x-rct_src.left+rct_src.right,
        y-rct_src.top +rct_src.bottom
      ),
      angle,
      c,
      s,
      v,
      w
    ),
    b
  );
  if (b=2) then
    Exit
  else
    begin
      sx  :=pvt.x                                 ;
      sy  :=pvt.y                                 ;
      sw  :=bmp_src_width                         ;
      sh  :=bmp_src_height                        ;
      dx  :=x                                     ;
      dy  :=y                                     ;
      dw  :=bmp_dst_width                         ;
      L2  :=rct_src3.left                         ;
      T2  :=rct_src3.top                          ;
      R2  :=rct_src3.right                        ;
      B2  :=rct_src3.bottom                       ;
      CosA:=Round( cos(pi*(1+angle/180)+pi)*65536);
      SinA:=Round(-sin(pi*(1+angle/180)+pi)*65536);
      ssx :=(sx<<16)-(dx-L2)*CosA                 ;
      ssy :=(sy<<16)-(dx-L2)*SinA                 ;
      ssw := sw<<16                               ;
      ssh := sh<<16                               ;
      addy:= T2*dw                                ;
      T2  -= dy                                   ;
      B2  -= dy                                   ;
      xx  :=ssx-T2*SinA                           ;
      yy  :=ssy+T2*CosA                           ;
    end;
  if (b=0) then
    begin
      for j:=T2 to B2 do
        begin
          xx:=ssx-j*SinA;
          yy:=ssy+j*CosA;
          for i:=L2 to R2 do
            begin
              if ((xx>=0) and (xx<ssw) and (yy>=0) and (yy<ssh)) then
              {if (i>=rct_clp.left) and (i<(rct_clp.right -1)) and
                 (yy>>16>=rct_clp.top ) and (yy>>16<(rct_clp.bottom-1)) then}
                (bmp_dst_ptr+addy+i)^:={clGreen}(bmp_src_ptr+sw*(yy>>16)+(xx>>16))^;
              xx+=CosA;
              yy+=SinA;
            end;
          addy+=dw;
        end;
    end
  else
  if (b=1) then
    begin
      for j:=T2 to B2 do
        begin
          xx:=ssx-j*SinA;
          yy:=ssy+j*CosA;
          for i:=L2 to R2 do
            begin
              if ((xx>=0) and (xx<ssw) and (yy>=0) and (yy<ssh)) then
              {if (i>=rct_clp.left) and (i<(rct_clp.right -1)) and
                 (yy>>16>=rct_clp.top ) and (yy>>16<(rct_clp.bottom-1)) then}
                (bmp_dst_ptr+addy+i)^:={clGreen}(bmp_src_ptr+sw*(yy>>16)+(xx>>16))^;
              xx+=CosA;
              yy+=SinA;
            end;
          addy+=dw;
        end;
    end;}
end; {$endregion}

{$endregion}



(****************************** Post-Processing *******************************) {$region -fold}

//
procedure PPDec2ProcInit;    {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPDec2Proc[000]:=Unaligned(@AlphablendDec2);
  PPDec2Proc[001]:=Unaligned(@AdditiveDec2  );
  PPDec2Proc[002]:=Unaligned(@AlphablendDec2);
  PPDec2Proc[003]:=Unaligned(@InverseDec2   );
  PPDec2Proc[004]:=Unaligned(@HighlightDec2 );
  PPDec2Proc[005]:=Unaligned(@DarkenDec2    );
  PPDec2Proc[006]:=Unaligned(@GrayscaleRDec2);
  PPDec2Proc[007]:=Unaligned(@GrayscaleGDec2);
  PPDec2Proc[008]:=Unaligned(@GrayscaleBDec2);
  PPDec2Proc[009]:=Unaligned(@AlphablendDec2);
  PPDec2Proc[010]:=Unaligned(@ColorizeRDec2 );
  PPDec2Proc[011]:=Unaligned(@ColorizeGDec2 );
  PPDec2Proc[012]:=Unaligned(@ColorizeBDec2 );
 {PPDec2Proc[013]:=Unaligned(@BlurRGBDec2   );
  PPDec2Proc[014]:=Unaligned(@BlurRRBDec2   );
  PPDec2Proc[015]:=Unaligned(@BlurRGRDec2   );
  PPDec2Proc[016]:=Unaligned(@BlurGGBDec2   );
  PPDec2Proc[017]:=Unaligned(@BlurRGGDec2   );
  PPDec2Proc[018]:=Unaligned(@BlurBGBDec2   );
  PPDec2Proc[019]:=Unaligned(@BlurRBBDec2   );
  PPDec2Proc[020]:=Unaligned(@BlurRRRDec2   );
  PPDec2Proc[021]:=Unaligned(@BlurGGGDec2   );
  PPDec2Proc[022]:=Unaligned(@BlurBBBDec2   );}
end; {$endregion}
procedure ArrFilProcInit;    {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  ArrFilProc[000]:=Unaligned(@ArrFilProc00);
  ArrFilProc[001]:=Unaligned(@ArrFilProc01);
  ArrFilProc[002]:=Unaligned(@ArrFilProc02);
  ArrFilProc[003]:=Unaligned(@ArrFilProc03);
  ArrFilProc[004]:=Unaligned(@ArrFilProc04);
  ArrFilProc[005]:=Unaligned(@ArrFilProc05);
  ArrFilProc[006]:=Unaligned(@ArrFilProc06);
  ArrFilProc[007]:=Unaligned(@ArrFilProc07);
  ArrFilProc[008]:=Unaligned(@ArrFilProc08);
  ArrFilProc[009]:=Unaligned(@ArrFilProc09);
  ArrFilProc[010]:=Unaligned(@ArrFilProc10);
  ArrFilProc[011]:=Unaligned(@ArrFilProc11);
  ArrFilProc[012]:=Unaligned(@ArrFilProc12);
  ArrFilProc[013]:=Unaligned(@ArrFilProc13);
  ArrFilProc[014]:=Unaligned(@ArrFilProc14);
  ArrFilProc[015]:=Unaligned(@ArrFilProc15);
  ArrFilProc[016]:=Unaligned(@ArrFilProc16);
  ArrFilProc[017]:=Unaligned(@ArrFilProc17);
  ArrFilProc[018]:=Unaligned(@ArrFilProc18);
  ArrFilProc[019]:=Unaligned(@ArrFilProc19);
  ArrFilProc[020]:=Unaligned(@ArrFilProc20);
  ArrFilProc[021]:=Unaligned(@ArrFilProc21);
  ArrFilProc[022]:=Unaligned(@ArrFilProc22);
  ArrFilProc[023]:=Unaligned(@ArrFilProc23);
  ArrFilProc[024]:=Unaligned(@ArrFilProc24);
  ArrFilProc[025]:=Unaligned(@ArrFilProc25);
end; {$endregion}
procedure PPBlurProcInit;    {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PPBlurProc[00]:=Unaligned(@PPBlurProc00);
  PPBlurProc[01]:=Unaligned(@PPBlurProc01);
  PPBlurProc[02]:=Unaligned(@PPBlurProc02);
  PPBlurProc[03]:=Unaligned(@PPBlurProc03);
  PPBlurProc[04]:=Unaligned(@PPBlurProc04);
  PPBlurProc[05]:=Unaligned(@PPBlurProc05);
  PPBlurProc[06]:=Unaligned(@PPBlurProc06);
  PPBlurProc[07]:=Unaligned(@PPBlurProc07);
  PPBlurProc[08]:=Unaligned(@PPBlurProc08);
  PPBlurProc[09]:=Unaligned(@PPBlurProc09);
  PPBlurProc[10]:=Unaligned(@PPBlurProc10);
  PPBlurProc[11]:=Unaligned(@PPBlurProc11);
end; {$endregion}
// (Flood Fill) Заливка:
procedure PPFloodFillAdd     (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor);                                                     {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
             (dst_pixel_ptr)^-=-1;
          Inc(dst_pixel_ptr);
        end;
      Inc    (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPFloodFillSub     (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor);                                                     {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
             (dst_pixel_ptr)^-=1;
          Inc(dst_pixel_ptr);
        end;
      Inc    (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPFloodFill        (                  constref             bmp_dst_ptr:PByte;                              constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor);                                                     {$region -fold}
var
  dst_pixel_ptr: PByte;
  y            : integer;
begin
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  for y:=0 to rct_dst.height-1 do
    begin
      FillByte(dst_pixel_ptr^,rct_dst.width,1);
      Inc     (dst_pixel_ptr ,bmp_dst_width  );
    end;
end; {$endregion}
procedure PPFloodFill        (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor; constref col:TColor);                                {$region -fold}
var
  dst_pixel_ptr: PInteger;
  y            : integer;
begin
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  for y:=0 to rct_dst.height-1 do
    begin
      FillDWord(dst_pixel_ptr^,rct_dst.width,col);
      Inc      (dst_pixel_ptr ,bmp_dst_width    );
    end;
end; {$endregion}
procedure PPFloodFill        (                  constref             bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_dst_width,rct_dst_height,first_pix_pos:integer;       constref col:TColor);                                {$region -fold}
var
  dst_pixel_ptr: PInteger;
  pix          : integer;
  x,y          : integer;
begin
  if (rct_dst_width=0) or (rct_dst_height=0) then
    Exit;
  pix          :=RGB(TRGBA(col).b,
                     TRGBA(col).g,
                     TRGBA(col).r);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+first_pix_pos);
  for y:=0 to rct_dst_height-1 do
    begin
      FillDWord(dst_pixel_ptr^,rct_dst_width,pix);
      Inc      (dst_pixel_ptr ,bmp_dst_width    );
    end;
end; {$endregion}
procedure PPFloodFill        (                  constref             bmp_dst:Graphics.TBitmap;                                                                                               constref col:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  raw_image     : TRawImage;
  pixel_ptr     : PInteger;
  pixel_row_ptr : PInteger;
  byte_per_pixel: integer;
  x,y           : integer;
begin
  bmp_dst.BeginUpdate(False);
  bmp_dst.PixelFormat:=pf32bit;
  raw_image      :=bmp_dst.RawImage;
  pixel_row_ptr  :=PInteger(raw_image.Data);
  byte_per_pixel :=Trunc(raw_image.Description.BitsPerPixel>>3);
  for y:=0 to bmp_dst.height-1 do
    begin
      pixel_ptr:=pixel_row_ptr;
      for x:=0 to bmp_dst.width-1 do
        begin
                    pixel_ptr^:=col;
          Inc(PByte(pixel_ptr),byte_per_pixel);
        end;
      Inc(PByte(pixel_row_ptr),raw_image.Description.BytesPerLine);
    end;
  bmp_dst.EndUpdate(False);
end; {$endregion}
procedure PPFloodFill        (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor; constref col:TColor; flood_fill_inc:boolean);        {$region -fold}
var
  dst_pixel_ptr    : PInteger;
  y,bmp_dst_width_ : integer;
    rct_dst_height_: integer;
begin
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  bmp_dst_width_:=bmp_dst_width<<1;
  if flood_fill_inc then
    begin
      dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+(rct_dst.top+0)*bmp_dst_width);
      if Odd(rct_dst.height) then
        rct_dst_height_:=rct_dst.height>>1
      else
        rct_dst_height_:=rct_dst.height>>1-1;
    end
  else
    begin
      dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+(rct_dst.top+1)*bmp_dst_width);
      if not Odd(rct_dst.height) then
        rct_dst_height_:=rct_dst.height>>1
      else
        rct_dst_height_:=rct_dst.height>>1-1;
    end;
  for y:=0 to rct_dst_height_ do
    begin
      FillDWord(dst_pixel_ptr^,rct_dst.width,col);
      Inc      (dst_pixel_ptr ,bmp_dst_width_   );
    end;
end; {$endregion}
// (Additive) Аддитивное смешивание:
procedure PPAdditive         (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; constref col:TColor                      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(@bmp_dst_ptr[rct_dst.left+rct_dst.top*bmp_dst_width]);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
                    dst_pixel_ptr^:=AdditiveB(
                    dst_pixel_ptr^,col);
          Inc      (dst_pixel_ptr);
        end;
      Inc          (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPAdditive         (                  constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref rct_src:TPtRect; constref rct_dst:TPtRect; constref bmp_src_width,bmp_dst_width:TColor                                           ); {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
                dst_pixel_ptr^  :=AdditiveB(
                dst_pixel_ptr^  ,
               (src_pixel_ptr^));
          Inc  (src_pixel_ptr ) ;
          Inc  (dst_pixel_ptr ) ;
        end;
      Inc      (src_pixel_ptr,d_width1);
      Inc      (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
procedure PPAdditiveDec      (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; constref col:TColor; constref pow:byte=64); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  r,g,b        : byte;
begin
  r            :=TRGBA(col).r;
  g            :=TRGBA(col).g;
  b            :=TRGBA(col).b;
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          AdditiveDec(dst_pixel_ptr^,b,g,r,pow);
          Inc        (dst_pixel_ptr);
        end;
      Inc            (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPAdditiveDec      (                  constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref rct_src:TPtRect; constref rct_dst:TPtRect; constref bmp_src_width,bmp_dst_width:TColor;                      constref pow:byte=64); {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
          AdditiveDec(dst_pixel_ptr^,
          TRGBA      (src_pixel_ptr^).b,
          TRGBA      (src_pixel_ptr^).g,
          TRGBA      (src_pixel_ptr^).r,
          pow);
          Inc        (src_pixel_ptr );
          Inc        (dst_pixel_ptr );
        end;
      Inc            (src_pixel_ptr,d_width1);
      Inc            (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
// (AlphaBlend) Полупрозрачность:
procedure PPAlphaBlend       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; constref col:TColor; constref pow:byte=64; alpha_max:byte=MAXBYTE); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  d_alpha      : byte;
begin
  d_alpha      :=alpha_max-pow;
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
              dst_pixel_ptr^:=AlphaBlendB(
              dst_pixel_ptr^,col,d_alpha);
          Inc(dst_pixel_ptr);
        end;
      Inc    (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPAlphaBlend       (                  constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref rct_src:TPtRect; constref rct_dst:TPtRect; constref bmp_src_width,bmp_dst_width:TColor;                      constref pow:byte=64; alpha_max:byte=MAXBYTE); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  d_width1     : integer;
  d_width2     : integer;
  x,y          : integer;
  d_alpha      : byte;
begin
  d_alpha      :=alpha_max-pow;
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
              dst_pixel_ptr^ :=AlphaBlendB(
              dst_pixel_ptr^ ,
             (src_pixel_ptr^),d_alpha);
          Inc(src_pixel_ptr );
          Inc(dst_pixel_ptr );
        end;
      Inc    (src_pixel_ptr,d_width1);
      Inc    (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
// (Inverse) Инверсия:
procedure PPInverse          (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor                      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
              dst_pixel_ptr^:=InverseA(
              dst_pixel_ptr^);
          Inc(dst_pixel_ptr);
        end;
      Inc    (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPInverseDec       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; constref pow:byte=64); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          InverseDec(dst_pixel_ptr^,pow);
          Inc       (dst_pixel_ptr);
        end;
      Inc           (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
// (HighLight) Подсветка:
procedure PPHighlight        (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; constref pow:byte=64); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
              dst_pixel_ptr^:=HighlightA(
              dst_pixel_ptr^,pow);
          Inc(dst_pixel_ptr);
        end;
      Inc    (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
// (Darken) Затемнение:
procedure PPDarken           (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; constref pow:byte=64); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
              dst_pixel_ptr^:=DarkenA(
              dst_pixel_ptr^,pow);
          Inc(dst_pixel_ptr);
        end;
      Inc    (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
// (GrayscaleR) Серый оттенок: красный канал:
procedure PPGrayscaleR       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor                      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
              dst_pixel_ptr^:=GrayscaleR0(
              dst_pixel_ptr^);
          Inc(dst_pixel_ptr );
        end;
      Inc    (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPGrayscaleRDec    (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; constref pow:byte=64); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          GrayscaleRDec(dst_pixel_ptr^,pow);
          Inc          (dst_pixel_ptr);
        end;
      Inc              (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
// (GrayscaleG) Серый оттенок: зеленый канал:
procedure PPGrayscaleG       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor                      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
              dst_pixel_ptr^:=GrayscaleG0(
              dst_pixel_ptr^);
          Inc(dst_pixel_ptr );
        end;
      Inc    (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPGrayscaleGDec    (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; constref pow:byte=64); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          GrayscaleGDec(dst_pixel_ptr^,pow);
          Inc          (dst_pixel_ptr);
        end;
      Inc              (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
// (GrayscaleB) Серый оттенок: синий   канал:
procedure PPGrayscaleB       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor                      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
              dst_pixel_ptr^ :=GrayscaleB0(
              dst_pixel_ptr^);
          Inc(dst_pixel_ptr );
        end;
      Inc    (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPGrayscaleBDec    (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; constref pow:byte=64); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          GrayscaleBDec(dst_pixel_ptr^,pow);
          Inc          (dst_pixel_ptr);
        end;
      Inc              (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
// (Monochrome Noise) Монохромный шум:
procedure PPMonoNoise        (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor; constref col:TColor                                              ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if Odd(dst_pixel_ptr^) then
                 dst_pixel_ptr^:=col;
          Inc   (dst_pixel_ptr);
        end;
      Inc       (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPMonoNoiseDec     (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect;  constref               bmp_dst_width:TColor; constref col:TColor; constref pow:byte=64; alpha_max:byte=MAXBYTE); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  d_alpha      : byte;
begin
  d_alpha      :=alpha_max-pow;
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if Odd(dst_pixel_ptr^) then
                 dst_pixel_ptr^:=AlphaBlendB(
                 dst_pixel_ptr^,col,d_alpha);
          Inc   (dst_pixel_ptr);
        end;
      Inc       (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
// (Blur) Размытие:
procedure PPBlurProc00       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          BlurRGB(pixel_ptr4,bmp_dst_width);
          Inc    (pixel_ptr4);
        end;
      Inc        (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc01       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          BlurRRB(pixel_ptr4,bmp_dst_width);
          Inc    (pixel_ptr4);
        end;
      Inc        (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc02       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          BlurRGR(pixel_ptr4,bmp_dst_width);
          Inc    (pixel_ptr4);
        end;
      Inc        (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc03       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          BlurGGB(pixel_ptr4,bmp_dst_width);
          Inc    (pixel_ptr4);
        end;
      Inc        (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc04       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          BlurRGG(pixel_ptr4,bmp_dst_width);
          Inc    (pixel_ptr4);
        end;
      Inc        (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc05       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          BlurBGB(pixel_ptr4,bmp_dst_width);
          Inc    (pixel_ptr4);
        end;
      Inc        (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc06       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          BlurRBB(pixel_ptr4,bmp_dst_width);
          Inc    (pixel_ptr4);
        end;
      Inc        (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc07       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
  r          : byte;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          r:=(TRGBA((pixel_ptr4+0                 )^).r+
              TRGBA((pixel_ptr4+2                 )^).r+
              TRGBA((pixel_ptr4+0+bmp_dst_width<<1)^).r+
              TRGBA((pixel_ptr4+2+bmp_dst_width<<1)^).r)>>2;
                    (pixel_ptr4+  bmp_dst_width+ 1)^:=RGB(r,r,r);
          Inc       (pixel_ptr4);
        end;
      Inc           (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc08       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
  g          : byte;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          g:=(TRGBA((pixel_ptr4+0                 )^).g+
              TRGBA((pixel_ptr4+2                 )^).g+
              TRGBA((pixel_ptr4+0+bmp_dst_width<<1)^).g+
              TRGBA((pixel_ptr4+2+bmp_dst_width<<1)^).g)>>2;
                    (pixel_ptr4+  bmp_dst_width+ 1)^:=RGB(g,g,g);
          Inc       (pixel_ptr4);
        end;
      Inc           (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc09       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
  b          : byte;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          b:=(TRGBA((pixel_ptr4+0                 )^).b+
              TRGBA((pixel_ptr4+2                 )^).b+
              TRGBA((pixel_ptr4+0+bmp_dst_width<<1)^).b+
              TRGBA((pixel_ptr4+2+bmp_dst_width<<1)^).b)>>2;
                    (pixel_ptr4+  bmp_dst_width+ 1)^:=RGB(b,b,b);
          Inc       (pixel_ptr4);
        end;
      Inc           (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc10       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
                         (pixel_ptr4+bmp_dst_width+1)^:=
          RGB((Byte(    ((pixel_ptr4+0)^)>>00)+
               Byte(    ((pixel_ptr4+1)^)>>00)+
               Byte(    ((pixel_ptr4+2)^)>>00)+
               Byte(    ((pixel_ptr4+bmp_dst_width   +0)^)>>00)+
               Byte(    ((pixel_ptr4+bmp_dst_width   +2)^)>>00)+
               Byte(    ((pixel_ptr4+bmp_dst_width<<1+0)^)>>00)+
               Byte(    ((pixel_ptr4+bmp_dst_width<<1+1)^)>>00)+
               Byte(    ((pixel_ptr4+bmp_dst_width<<1+2)^)>>00))>>3,
              (Byte(Word((pixel_ptr4+0)^)>>08)+
               Byte(Word((pixel_ptr4+1)^)>>08)+
               Byte(Word((pixel_ptr4+2)^)>>08)+
               Byte(Word((pixel_ptr4+bmp_dst_width   +0)^)>>08)+
               Byte(Word((pixel_ptr4+bmp_dst_width   +2)^)>>08)+
               Byte(Word((pixel_ptr4+bmp_dst_width<<1+0)^)>>08)+
               Byte(Word((pixel_ptr4+bmp_dst_width<<1+1)^)>>08)+
               Byte(Word((pixel_ptr4+bmp_dst_width<<1+2)^)>>08))>>3,
              (Byte(    ((pixel_ptr4+0)^)>>16)+
               Byte(    ((pixel_ptr4+1)^)>>16)+
               Byte(    ((pixel_ptr4+2)^)>>16)+
               Byte(    ((pixel_ptr4+bmp_dst_width   +0)^)>>16)+
               Byte(    ((pixel_ptr4+bmp_dst_width   +2)^)>>16)+
               Byte(    ((pixel_ptr4+bmp_dst_width<<1+0)^)>>16)+
               Byte(    ((pixel_ptr4+bmp_dst_width<<1+1)^)>>16)+
               Byte(    ((pixel_ptr4+bmp_dst_width<<1+2)^)>>16))>>3);
          Inc            (pixel_ptr4);
        end;
      Inc                (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlurProc11       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor); {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
begin
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          if (Byte(    ((pixel_ptr4+bmp_dst_width+1)^)>>00)>200) and
             (Byte(Word((pixel_ptr4+bmp_dst_width+1)^)>>08)>200) and
             (Byte(    ((pixel_ptr4+bmp_dst_width+1)^)>>16)>200) then
                        (pixel_ptr4+bmp_dst_width+1)^:=
         RGB((Byte(    ((pixel_ptr4+0)^)>>00)+
              Byte(    ((pixel_ptr4+2)^)>>00)+
              Byte(    ((pixel_ptr4+bmp_dst_width<<1+0)^)>>00)+
              Byte(    ((pixel_ptr4+bmp_dst_width<<1+2)^)>>00))>>2,
             (Byte(Word((pixel_ptr4+0)^)>>08)+
              Byte(Word((pixel_ptr4+2)^)>>08)+
              Byte(Word((pixel_ptr4+bmp_dst_width<<1+0)^)>>08)+
              Byte(Word((pixel_ptr4+bmp_dst_width<<1+2)^)>>08))>>2,
             (Byte(    ((pixel_ptr4+0)^)>>16)+
              Byte(    ((pixel_ptr4+2)^)>>16)+
              Byte(    ((pixel_ptr4+bmp_dst_width<<1+0)^)>>16)+
              Byte(    ((pixel_ptr4+bmp_dst_width<<1+2)^)>>16))>>2);
          Inc           (pixel_ptr4);
        end;
      Inc               (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
procedure PPBlur             (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; constref blur_type:byte=0; constref border_filter:TBorderFilter=efNotTiled); {$region -fold}
var
  pixel_ptr0,pixel_ptr1,pixel_ptr2,pixel_ptr3,pixel_ptr4: PInteger;
  i,j,d_width                                           : integer;
  r0,r1,r2,r3,r4,r5,r6,r7,r8                            : byte;
  g0,g1,g2,g3,g4,g5,g6,g7,g8                            : byte;
  b0,b1,b2,b3,b4,b5,b6,b7,b8                            : byte;
  r,g,b                                                 : byte;
begin
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  {
  d_width:=bmp_dst_width-rct_dst.width;

  // left -top    pixel
  pixel_ptr0:=Unaligned(bmp_dst_ptr+rct_dst.left+                bmp_dst_width* rct_dst.top                  );
  // right-top    pixel
  pixel_ptr1:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.width-1+bmp_dst_width* rct_dst.top                  );
  // left -bottom pixel
  pixel_ptr2:=Unaligned(bmp_dst_ptr+rct_dst.left+                bmp_dst_width*(rct_dst.top+rct_dst.height-1));
  // right-bottom pixel
  pixel_ptr3:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.width-1+bmp_dst_width*(rct_dst.top+rct_dst.height-1));

  pixel_ptr4:=pixel_ptr0;

  {Borders-------------} {$region -fold}

  case border_filter of

    efNotTiled:
      begin

        {Left-Top Pixel----} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
        pixel_ptr4^:=RGB((Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+1)^)+Red  ((pixel_ptr4+bmp_dst_width+0)^)+Red  ((pixel_ptr4+bmp_dst_width+1)^))>>2,
                         (Green((pixel_ptr4+0)^)+Green((pixel_ptr4+1)^)+Green((pixel_ptr4+bmp_dst_width+0)^)+Green((pixel_ptr4+bmp_dst_width+1)^))>>2,
                         (Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+1)^)+Blue ((pixel_ptr4+bmp_dst_width+0)^)+Blue ((pixel_ptr4+bmp_dst_width+1)^))>>2); {$endregion}

        {Right-Top Pixel---} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.width-1+bmp_dst_width*rct_dst.top);
        pixel_ptr4^:=RGB((Red  ((pixel_ptr4-1)^)+Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+bmp_dst_width-1)^)+Red  ((pixel_ptr4+bmp_dst_width+0)^))>>2,
                         (Green((pixel_ptr4-1)^)+Green((pixel_ptr4+0)^)+Green((pixel_ptr4+bmp_dst_width-1)^)+Green((pixel_ptr4+bmp_dst_width+0)^))>>2,
                         (Blue ((pixel_ptr4-1)^)+Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+bmp_dst_width-1)^)+Blue ((pixel_ptr4+bmp_dst_width+0)^))>>2); {$endregion}

        {Left-Bottom Pixel-} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*(rct_dst.top+rct_dst.height-1));
        pixel_ptr4^:=RGB((Red  ((pixel_ptr4-bmp_dst_width+0)^)+Red  ((pixel_ptr4-bmp_dst_width+1)^)+Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+1)^))>>2,
                         (Green((pixel_ptr4-bmp_dst_width+0)^)+Green((pixel_ptr4-bmp_dst_width+1)^)+Green((pixel_ptr4+0)^)+Green((pixel_ptr4+1)^))>>2,
                         (Blue ((pixel_ptr4-bmp_dst_width+0)^)+Blue ((pixel_ptr4-bmp_dst_width+1)^)+Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+1)^))>>2); {$endregion}

        {Right-Bottom Pixel} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.width-1+bmp_dst_width*(rct_dst.top+rct_dst.height-1));
        pixel_ptr4^:=RGB((Red  ((pixel_ptr4-bmp_dst_width-1)^)+Red  ((pixel_ptr4-bmp_dst_width+0)^)+Red  ((pixel_ptr4-1)^)+Red  ((pixel_ptr4+0)^))>>2,
                         (Green((pixel_ptr4-bmp_dst_width-1)^)+Green((pixel_ptr4-bmp_dst_width+0)^)+Green((pixel_ptr4-1)^)+Green((pixel_ptr4+0)^))>>2,
                         (Blue ((pixel_ptr4-bmp_dst_width-1)^)+Blue ((pixel_ptr4-bmp_dst_width+0)^)+Blue ((pixel_ptr4-1)^)+Blue ((pixel_ptr4+0)^))>>2); {$endregion}

        {Top Line----------} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+1+bmp_dst_width*rct_dst.top);
        for i:=0 to rct_dst.width-3 do
          begin
            pixel_ptr4^:=RGB(Trunc((Red  ((pixel_ptr4-1)^)+Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+1)^)+Red  ((pixel_ptr4+bmp_dst_width-1)^)+Red  ((pixel_ptr4+bmp_dst_width+0)^)+Red  ((pixel_ptr4+bmp_dst_width+1)^))/6),
                             Trunc((Green((pixel_ptr4-1)^)+Green((pixel_ptr4+0)^)+Green((pixel_ptr4+1)^)+Green((pixel_ptr4+bmp_dst_width-1)^)+Green((pixel_ptr4+bmp_dst_width+0)^)+Green((pixel_ptr4+bmp_dst_width+1)^))/6),
                             Trunc((Blue ((pixel_ptr4-1)^)+Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+1)^)+Blue ((pixel_ptr4+bmp_dst_width-1)^)+Blue ((pixel_ptr4+bmp_dst_width+0)^)+Blue ((pixel_ptr4+bmp_dst_width+1)^))/6));
            Inc(pixel_ptr4);
          end; {$endregion}

        {Left Line---------} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*(rct_dst.top+1));
        for j:=0 to rct_dst.height-3 do
          begin
            pixel_ptr4^:=RGB(Trunc((Red  ((pixel_ptr4-bmp_dst_width)^)+Red  ((pixel_ptr4-bmp_dst_width+1)^)+Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+1)^)+Red  ((pixel_ptr4+bmp_dst_width+0)^)+Red  ((pixel_ptr4+bmp_dst_width+1)^))/6),
                             Trunc((Green((pixel_ptr4-bmp_dst_width)^)+Green((pixel_ptr4-bmp_dst_width+1)^)+Green((pixel_ptr4+0)^)+Green((pixel_ptr4+1)^)+Green((pixel_ptr4+bmp_dst_width+0)^)+Green((pixel_ptr4+bmp_dst_width+1)^))/6),
                             Trunc((Blue ((pixel_ptr4-bmp_dst_width)^)+Blue ((pixel_ptr4-bmp_dst_width+1)^)+Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+1)^)+Blue ((pixel_ptr4+bmp_dst_width+0)^)+Blue ((pixel_ptr4+bmp_dst_width+1)^))/6));
            Inc(pixel_ptr4,bmp_dst_width);
          end; {$endregion}

        {Right Line--------} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.width-1+bmp_dst_width*(rct_dst.top+1));
        for j:=0 to rct_dst.height-3 do
          begin
            pixel_ptr4^:=RGB(Trunc((Red  ((pixel_ptr4-bmp_dst_width-1)^)+Red  ((pixel_ptr4-bmp_dst_width+0)^)+Red  ((pixel_ptr4-1)^)+Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+bmp_dst_width-1)^)+Red  ((pixel_ptr4+bmp_dst_width+0)^))/6),
                             Trunc((Green((pixel_ptr4-bmp_dst_width-1)^)+Green((pixel_ptr4-bmp_dst_width+0)^)+Green((pixel_ptr4-1)^)+Green((pixel_ptr4+0)^)+Green((pixel_ptr4+bmp_dst_width-1)^)+Green((pixel_ptr4+bmp_dst_width+0)^))/6),
                             Trunc((Blue ((pixel_ptr4-bmp_dst_width-1)^)+Blue ((pixel_ptr4-bmp_dst_width+0)^)+Blue ((pixel_ptr4-1)^)+Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+bmp_dst_width-1)^)+Blue ((pixel_ptr4+bmp_dst_width+0)^))/6));
            Inc(pixel_ptr4,bmp_dst_width);
          end; {$endregion}

        {Bottom Line-------} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+1+bmp_dst_width*(rct_dst.top+rct_dst.height-1));
        for i:=0 to rct_dst.width-3 do
          begin
            pixel_ptr4^:=RGB(Trunc((Red  ((pixel_ptr4-bmp_dst_width-1)^)+Red  ((pixel_ptr4-bmp_dst_width+0)^)+Red  ((pixel_ptr4-bmp_dst_width+1)^)+Red  ((pixel_ptr4-1)^)+Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+1)^))/6),
                             Trunc((Green((pixel_ptr4-bmp_dst_width-1)^)+Green((pixel_ptr4-bmp_dst_width+0)^)+Green((pixel_ptr4-bmp_dst_width+1)^)+Green((pixel_ptr4-1)^)+Green((pixel_ptr4+0)^)+Green((pixel_ptr4+1)^))/6),
                             Trunc((Blue ((pixel_ptr4-bmp_dst_width-1)^)+Blue ((pixel_ptr4-bmp_dst_width+0)^)+Blue ((pixel_ptr4-bmp_dst_width+1)^)+Blue ((pixel_ptr4-1)^)+Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+1)^))/6));
            Inc(pixel_ptr4);
          end; {$endregion}

      end;

    efTiled:  {TODO}
      begin

        {Left-Top Pixel----} {$region -fold}
        pixel_ptr4 :=Unaligned(@bmp_dst_ptr[rct_dst.left+bmp_dst_width*rct_dst.top]);
        pixel_ptr4^:=RGB((Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+1)^)+Red  ((pixel_ptr4+bmp_dst_width+0)^)+Red  ((pixel_ptr4+bmp_dst_width+1)^))>>2,
                         (Green((pixel_ptr4+0)^)+Green((pixel_ptr4+1)^)+Green((pixel_ptr4+bmp_dst_width+0)^)+Green((pixel_ptr4+bmp_dst_width+1)^))>>2,
                         (Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+1)^)+Blue ((pixel_ptr4+bmp_dst_width+0)^)+Blue ((pixel_ptr4+bmp_dst_width+1)^))>>2); {$endregion}
        {r0:=pixel_ptr3^{shr 0};
        g0:=pixel_ptr3^ shr 8 ;
        b0:=pixel_ptr3^ shr 16;
        r1:=pixel_ptr2^{shr 0};
        g1:=pixel_ptr2^ shr 8 ;
        b1:=pixel_ptr2^ shr 16;
        Inc(pixel_ptr2);
        r2:=pixel_ptr2^{shr 0};
        g2:=pixel_ptr2^ shr 8 ;
        b2:=pixel_ptr2^ shr 16;
        r3:=pixel_ptr1^{shr 0};
        g3:=pixel_ptr1^ shr 8 ;
        b3:=pixel_ptr1^ shr 16;
        r4:=pixel_ptr0^{shr 0};
        g4:=pixel_ptr0^ shr 8 ;
        b4:=pixel_ptr0^ shr 16;
        Inc(pixel_ptr0);
        r5:=pixel_ptr0^{shr 0};
        g5:=pixel_ptr0^ shr 8 ;
        b5:=pixel_ptr0^ shr 16;
        Inc(pixel_ptr1,bmp_dst_width);
        r6:=pixel_ptr1^{shr 0};
        g6:=pixel_ptr1^ shr 8 ;
        b6:=pixel_ptr1^ shr 16;
        Inc(pixel_ptr0,bmp_dst_width-1);
        r7:=pixel_ptr0^{shr 0};
        g7:=pixel_ptr0^ shr 8 ;
        b7:=pixel_ptr0^ shr 16;
        Inc(pixel_ptr0);
        r8:=pixel_ptr0^{shr 0};
        g8:=pixel_ptr0^ shr 8 ;
        b8:=pixel_ptr0^ shr 16;
        Dec(pixel_ptr0,bmp_dst_width+1); // Reset left -top    pixel pointer
        Dec(pixel_ptr1,bmp_dst_width);   // Reset right-top    pixel pointer
        Dec(pixel_ptr2);                 // Reset left -bottom pixel pointer
        r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
        g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
        b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
        pixel_ptr0^:=RGB(r,g,b); {$endregion}}

        {Right-Top Pixel---} {$region -fold}
        Dec(pixel_ptr3);
        r0:=pixel_ptr3^>>00;
        g0:=pixel_ptr3^>>08;
        b0:=pixel_ptr3^>>16;
        Inc(pixel_ptr3);
        r1:=pixel_ptr3^>>00;
        g1:=pixel_ptr3^>>08;
        b1:=pixel_ptr3^>>16;
        r2:=pixel_ptr2^>>00;
        g2:=pixel_ptr2^>>08;
        b2:=pixel_ptr2^>>16;
        Dec(pixel_ptr1);
        r3:=pixel_ptr1^>>00;
        g3:=pixel_ptr1^>>08;
        b3:=pixel_ptr1^>>16;
        Inc(pixel_ptr1);
        r4:=pixel_ptr1^>>00;
        g4:=pixel_ptr1^>>08;
        b4:=pixel_ptr1^>>16;
        r5:=pixel_ptr0^>>00;
        g5:=pixel_ptr0^>>08;
        b5:=pixel_ptr0^>>16;
        Inc(pixel_ptr1,bmp_dst_width-1);
        r6:=pixel_ptr1^>>00;
        g6:=pixel_ptr1^>>08;
        b6:=pixel_ptr1^>>16;
        Inc(pixel_ptr1);
        r7:=pixel_ptr1^>>00;
        g7:=pixel_ptr1^>>08;
        b7:=pixel_ptr1^>>16;
        Inc(pixel_ptr0,bmp_dst_width);
        r8:=pixel_ptr0^>>00;
        g8:=pixel_ptr0^>>08;
        b8:=pixel_ptr0^>>16;
        Dec(pixel_ptr0,bmp_dst_width); // Reset left -top pixel pointer
        Dec(pixel_ptr1,bmp_dst_width); // Reset right-top pixel pointer
        r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
        g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
        b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
        pixel_ptr1^:=RGB(r,g,b); {$endregion}

        {Left-Bottom Pixel-} {$region -fold}
        Dec(pixel_ptr3,bmp_dst_width);
        r0:=pixel_ptr3^>>00;
        g0:=pixel_ptr3^>>08;
        b0:=pixel_ptr3^>>16;
        Dec(pixel_ptr2,bmp_dst_width);
        r1:=pixel_ptr2^>>00;
        g1:=pixel_ptr2^>>08;
        b1:=pixel_ptr2^>>16;
        Inc(pixel_ptr2);
        r2:=pixel_ptr2^>>00;
        g2:=pixel_ptr2^>>08;
        b2:=pixel_ptr2^>>16;
        Inc(pixel_ptr3,bmp_dst_width);
        r3:=pixel_ptr3^>>00;
        g3:=pixel_ptr3^>>08;
        b3:=pixel_ptr3^>>16;
        Inc(pixel_ptr2,bmp_dst_width-1);
        r4:=pixel_ptr2^>>00;
        g4:=pixel_ptr2^>>08;
        b4:=pixel_ptr2^>>16;
        Inc(pixel_ptr2);
        r5:=pixel_ptr2^>>00;
        g5:=pixel_ptr2^>>08;
        b5:=pixel_ptr2^>>16;
        r6:=pixel_ptr1^>>00;
        g6:=pixel_ptr1^>>08;
        b6:=pixel_ptr1^>>16;
        r7:=pixel_ptr0^>>00;
        g7:=pixel_ptr0^>>08;
        b7:=pixel_ptr0^>>16;
        Inc(pixel_ptr0);
        r8:=pixel_ptr0^>>00;
        g8:=pixel_ptr0^>>08;
        b8:=pixel_ptr0^>>16;
        Dec(pixel_ptr0); // Reset left-top    pixel pointer
        Dec(pixel_ptr2); // Reset left-bottom pixel pointer
        r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
        g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
        b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
        pixel_ptr2^:=RGB(r,g,b); {$endregion}

        {Right-Bottom Pixel} {$region -fold}
        Dec(pixel_ptr3,bmp_dst_width+1);
        r0:=pixel_ptr3^>>00;
        g0:=pixel_ptr3^>>08;
        b0:=pixel_ptr3^>>16;
        Inc(pixel_ptr3);
        r1:=pixel_ptr3^>>00;
        g1:=pixel_ptr3^>>08;
        b1:=pixel_ptr3^>>16;
        Dec(pixel_ptr2,bmp_dst_width);
        r2:=pixel_ptr2^>>00;
        g2:=pixel_ptr2^>>08;
        b2:=pixel_ptr2^>>16;
        Inc(pixel_ptr3,bmp_dst_width-1);
        r3:=pixel_ptr3^>>00;
        g3:=pixel_ptr3^>>08;
        b3:=pixel_ptr3^>>16;
        Inc(pixel_ptr3);
        r4:=pixel_ptr3^>>00;
        g4:=pixel_ptr3^>>08;
        b4:=pixel_ptr3^>>16;
        Inc(pixel_ptr2,bmp_dst_width);
        r5:=pixel_ptr2^>>00;
        g5:=pixel_ptr2^>>08;
        b5:=pixel_ptr2^>>16;
        Dec(pixel_ptr1);
        r6:=pixel_ptr1^>>00;
        g6:=pixel_ptr1^>>08;
        b6:=pixel_ptr1^>>16;
        Inc(pixel_ptr1);
        r7:=pixel_ptr1^>>00;
        g7:=pixel_ptr1^>>08;
        b7:=pixel_ptr1^>>16;
        r8:=pixel_ptr0^>>00;
        g8:=pixel_ptr0^>>08;
        b8:=pixel_ptr0^>>16;
        r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
        g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
        b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
        pixel_ptr3^:=RGB(r,g,b); {$endregion}

        {Top Line----------} {$region -fold}
        for i:=1 to rct_dst.width-2 do
          begin
            r0:=pixel_ptr2^>>00;
            g0:=pixel_ptr2^>>08;
            b0:=pixel_ptr2^>>16;
            Inc(pixel_ptr2);
            r1:=pixel_ptr2^>>00;
            g1:=pixel_ptr2^>>08;
            b1:=pixel_ptr2^>>16;
            Inc(pixel_ptr2);
            r2:=pixel_ptr2^>>00;
            g2:=pixel_ptr2^>>08;
            b2:=pixel_ptr2^>>16;
            r3:=pixel_ptr0^>>00;
            g3:=pixel_ptr0^>>08;
            b3:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r4:=pixel_ptr0^>>00;
            g4:=pixel_ptr0^>>08;
            b4:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r5:=pixel_ptr0^>>00;
            g5:=pixel_ptr0^>>08;
            b5:=pixel_ptr0^>>16;
            Inc(pixel_ptr0,bmp_dst_width-2);
            r6:=pixel_ptr0^>>00;
            g6:=pixel_ptr0^>>08;
            b6:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r7:=pixel_ptr0^>>00;
            g7:=pixel_ptr0^>>08;
            b7:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r8:=pixel_ptr0^>>00;
            g8:=pixel_ptr0^>>08;
            b8:=pixel_ptr0^>>16;
            Dec(pixel_ptr0,bmp_dst_width+1);
            Dec(pixel_ptr2);
            r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
            g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
            b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
            pixel_ptr0^:=RGB(r,g,b);
          end;
        Dec(pixel_ptr0,rct_dst.width-2); // Reset left-top    pixel pointer
        Dec(pixel_ptr2,rct_dst.width-2); // Reset left-bottom pixel pointer
        {$endregion}

        {Left Line---------} {$region -fold}
        for j:=1 to rct_dst.height-2 do
          begin
            r0:=pixel_ptr1^>>00;
            g0:=pixel_ptr1^>>08;
            b0:=pixel_ptr1^>>16;
            r1:=pixel_ptr0^>>00;
            g1:=pixel_ptr0^>>08;
            b1:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r2:=pixel_ptr0^>>00;
            g2:=pixel_ptr0^>>08;
            b2:=pixel_ptr0^>>16;
            Inc(pixel_ptr1,bmp_dst_width);
            r3:=pixel_ptr1^>>00;
            g3:=pixel_ptr1^>>08;
            b3:=pixel_ptr1^>>16;
            Inc(pixel_ptr0,bmp_dst_width-1);
            r4:=pixel_ptr0^>>00;
            g4:=pixel_ptr0^>>08;
            b4:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r5:=pixel_ptr0^>>00;
            g5:=pixel_ptr0^>>08;
            b5:=pixel_ptr0^>>16;
            Inc(pixel_ptr1,bmp_dst_width);
            r6:=pixel_ptr1^>>00;
            g6:=pixel_ptr1^>>08;
            b6:=pixel_ptr1^>>16;
            Inc(pixel_ptr0,bmp_dst_width-1);
            r7:=pixel_ptr0^>>00;
            g7:=pixel_ptr0^>>08;
            b7:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r8:=pixel_ptr0^>>00;
            g8:=pixel_ptr0^>>08;
            b8:=pixel_ptr0^>>16;
            Dec(pixel_ptr0,bmp_dst_width+1);
            Dec(pixel_ptr1,bmp_dst_width);
            r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
            g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
            b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
            pixel_ptr0^:=RGB(r,g,b);
          end;
        Dec(pixel_ptr0,bmp_dst_width*(rct_dst.height-2)); // Reset left -top pixel pointer
        Dec(pixel_ptr1,bmp_dst_width*(rct_dst.height-2)); // Reset right-top pixel pointer
        {$endregion}

        {Right Line--------} {$region -fold}
        Dec(pixel_ptr1);
        for j:=1 to rct_dst.height-2 do
          begin
            r0:=pixel_ptr1^>>00;
            g0:=pixel_ptr1^>>08;
            b0:=pixel_ptr1^>>16;
            Inc(pixel_ptr1);
            r1:=pixel_ptr1^>>00;
            g1:=pixel_ptr1^>>08;
            b1:=pixel_ptr1^>>16;
            r2:=pixel_ptr0^>>00;
            g2:=pixel_ptr0^>>08;
            b2:=pixel_ptr0^>>16;
            Inc(pixel_ptr1,bmp_dst_width-1);
            r3:=pixel_ptr1^>>00;
            g3:=pixel_ptr1^>>08;
            b3:=pixel_ptr1^>>16;
            Inc(pixel_ptr1);
            r4:=pixel_ptr1^>>00;
            g4:=pixel_ptr1^>>08;
            b4:=pixel_ptr1^>>16;
            Inc(pixel_ptr0,bmp_dst_width);
            r5:=pixel_ptr0^>>00;
            g5:=pixel_ptr0^>>08;
            b5:=pixel_ptr0^>>16;
            Inc(pixel_ptr1,bmp_dst_width-1);
            r6:=pixel_ptr1^>>00;
            g6:=pixel_ptr1^>>08;
            b6:=pixel_ptr1^>>16;
            Inc(pixel_ptr1);
            r7:=pixel_ptr1^>>00;
            g7:=pixel_ptr1^>>08;
            b7:=pixel_ptr1^>>16;
            Inc(pixel_ptr0,bmp_dst_width);
            r8:=pixel_ptr0^>>00;
            g8:=pixel_ptr0^>>08;
            b8:=pixel_ptr0^>>16;
            Dec(pixel_ptr0,bmp_dst_width);
            Dec(pixel_ptr1,bmp_dst_width);
            r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
            g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
            b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
            pixel_ptr1^:=RGB(r,g,b);
            Dec(pixel_ptr1);
          end;
        Dec(pixel_ptr0,bmp_dst_width*(rct_dst.height-2));   // Reset left -top pixel pointer
        Dec(pixel_ptr1,bmp_dst_width*(rct_dst.height-2)-1); // Reset right-top pixel pointer
        {$endregion}

        {Bottom Line-------} {$region -fold}
        Dec(pixel_ptr2,bmp_dst_width);
        for i:=1 to rct_dst.width-2 do
          begin
            r0:=pixel_ptr2^>>00;
            g0:=pixel_ptr2^>>08;
            b0:=pixel_ptr2^>>16;
            Inc(pixel_ptr2);
            r1:=pixel_ptr2^>>00;
            g1:=pixel_ptr2^>>08;
            b1:=pixel_ptr2^>>16;
            Inc(pixel_ptr2);
            r2:=pixel_ptr2^>>00;
            g2:=pixel_ptr2^>>08;
            b2:=pixel_ptr2^>>16;
            Inc(pixel_ptr2,bmp_dst_width-2);
            r3:=pixel_ptr2^>>00;
            g3:=pixel_ptr2^>>08;
            b3:=pixel_ptr2^>>16;
            Inc(pixel_ptr2);
            r4:=pixel_ptr2^>>00;
            g4:=pixel_ptr2^>>08;
            b4:=pixel_ptr2^>>16;
            Inc(pixel_ptr2);
            r5:=pixel_ptr2^>>00;
            g5:=pixel_ptr2^>>08;
            b5:=pixel_ptr2^>>16;
            r6:=pixel_ptr0^>>00;
            g6:=pixel_ptr0^>>08;
            b6:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r7:=pixel_ptr0^>>00;
            g7:=pixel_ptr0^>>08;
            b7:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r8:=pixel_ptr0^>>00;
            g8:=pixel_ptr0^>>08;
            b8:=pixel_ptr0^>>16;
            Dec(pixel_ptr2);
            r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
            g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
            b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
            pixel_ptr2^:=RGB(r,g,b);
            Dec(pixel_ptr0);               // Reset left-top    pixel pointer
            Dec(pixel_ptr2,bmp_dst_width); // Reset left-bottom pixel pointer
          end;
        Dec(pixel_ptr0,rct_dst.width-2); // Reset left-top    pixel pointer
        Inc(pixel_ptr2,d_width+2);       // Reset left-bottom pixel pointer
        {$endregion}

      end;

  end; {$endregion}
  }
  {Inner Rectangle Area} {$region -fold}
  {
  blur_type:
    00: {Fast----}
    01: {g to r--}
    02: {b to r--}
    03: {r to g--}
    04: {b to g--}
    05: {r to b--}
    06: {g to b--}
    07: {b,g to r}
    08: {r,b to g}
    09: {r,g to b}
    10: {Slow----}
  }
  PPBlurProc[blur_type](bmp_dst_ptr,rct_dst,bmp_dst_width); {$endregion}
end; {$endregion}
procedure PPBlur             (                  constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref rct_src:TPtRect; constref rct_dst:TPtRect; constref bmp_src_width,bmp_dst_width:TColor; constref blur_type:byte=0                                                 ); {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  if (rct_src.width<=0) or (rct_src.height<=0) then
    Exit;
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
          if (src_pixel_ptr^>>24<>0) then
            dst_pixel_ptr^:=RGB((Byte(    ((dst_pixel_ptr-bmp_dst_width-1)^)>>00)+Byte(    ((dst_pixel_ptr-bmp_dst_width+1)^)>>00)+Byte(    ((dst_pixel_ptr+bmp_dst_width-1)^)>>00)+Byte(    ((dst_pixel_ptr+bmp_dst_width+1)^)>>00))>>2,
                                (Byte(Word((dst_pixel_ptr-bmp_dst_width-1)^)>>08)+Byte(Word((dst_pixel_ptr-bmp_dst_width+1)^)>>08)+Byte(Word((dst_pixel_ptr+bmp_dst_width-1)^)>>08)+Byte(Word((dst_pixel_ptr+bmp_dst_width+1)^)>>08))>>2,
                                (Byte(    ((dst_pixel_ptr-bmp_dst_width-1)^)>>16)+Byte(    ((dst_pixel_ptr-bmp_dst_width+1)^)>>16)+Byte(    ((dst_pixel_ptr+bmp_dst_width-1)^)>>16)+Byte(    ((dst_pixel_ptr+bmp_dst_width+1)^)>>16))>>2);
          Inc(src_pixel_ptr);
          Inc(dst_pixel_ptr);
        end;
      Inc(src_pixel_ptr,d_width1);
      Inc(dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
procedure PPBDec             (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; constref alpha:byte; PPBDecProc:TProc19);  {$region -fold}
var
  pixel_ptr4 : PInteger;
  x,y,d_width: integer;
begin
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  d_width    :=bmp_dst_width-rct_dst.width;
  pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
  Prefetch(pixel_ptr4);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-3 do
        begin
          PPBDecProc(pixel_ptr4,bmp_dst_width,alpha);
          Inc       (pixel_ptr4);
        end;
      Inc           (pixel_ptr4,d_width+2);
    end;
end; {$endregion}
// (Color Correction) Цветокоррекция:
procedure PPColorCorrectionM0(ColorizeM:TFunc3; constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; constref pow:byte=32; alpha_max:byte=MAXBYTE); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  d            : smallint;
begin
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  d_width      := bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
              dst_pixel_ptr^:=ColorizeM(dst_pixel_ptr^,pow);
          Inc(dst_pixel_ptr);
        end;
      Inc(dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPColorCorrectionP0(ColorizeP:TFunc3; constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; constref pow:byte=32; alpha_max:byte=MAXBYTE); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
begin
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  d_width      := bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
              dst_pixel_ptr^:=ColorizeP(dst_pixel_ptr^,pow);
          Inc(dst_pixel_ptr);
        end;
      Inc(dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPColorCorrectionM0(ColorizeM:TFunc3; constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref rct_src:TPtRect; constref rct_dst:TPtRect; constref bmp_src_width,bmp_dst_width:TColor; constref pow:byte=32; alpha_max:byte=MAXBYTE); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  d_width1     : integer;
  d_width2     : integer;
  x,y          : integer;
begin
  if (rct_src.width<=0) or (rct_src.height<=0) then
    Exit;
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
          if (src_pixel_ptr^>>24<>0) then
            dst_pixel_ptr^:=ColorizeM(dst_pixel_ptr^,pow);
          Inc(src_pixel_ptr);
          Inc(dst_pixel_ptr);
        end;
      Inc(src_pixel_ptr,d_width1);
      Inc(dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
procedure PPColorCorrectionP0(ColorizeP:TFunc3; constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref rct_src:TPtRect; constref rct_dst:TPtRect; constref bmp_src_width,bmp_dst_width:TColor; constref pow:byte=32; alpha_max:byte=MAXBYTE); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  d_width1     : integer;
  d_width2     : integer;
  x,y          : integer;
begin
  if (rct_src.width<=0) or (rct_src.height<=0) then
    Exit;
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
          if (src_pixel_ptr^>>24<>0) then
            dst_pixel_ptr^:=ColorizeP(dst_pixel_ptr^,pow);
          Inc(src_pixel_ptr);
          Inc(dst_pixel_ptr);
        end;
      Inc(src_pixel_ptr,d_width1);
      Inc(dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
procedure PPColorCorrectionM1(ColorizeM:TFunc1; constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref rct_src:TPtRect; constref rct_dst:TPtRect; constref bmp_src_width,bmp_dst_width:TColor; constref pow:byte=32; alpha_max:byte=MAXBYTE); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  d_width1     : integer;
  d_width2     : integer;
  x,y          : integer;
begin
  if (rct_src.width<=0) or (rct_src.height<=0) then
    Exit;
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
          if (src_pixel_ptr^>>24=alpha_max) then
            dst_pixel_ptr^:=ColorizeM(dst_pixel_ptr^,0,pow)
          else
          if (src_pixel_ptr^>>24<alpha_max) and (src_pixel_ptr^>>24>0) then
            dst_pixel_ptr^:=ColorizeM(dst_pixel_ptr^,alpha_max-src_pixel_ptr^>>24,pow);
          Inc(src_pixel_ptr);
          Inc(dst_pixel_ptr);
        end;
      Inc(src_pixel_ptr,d_width1);
      Inc(dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
procedure PPColorCorrectionP1(ColorizeP:TFunc1; constref bmp_src_ptr,bmp_dst_ptr:PInteger; constref rct_src:TPtRect; constref rct_dst:TPtRect; constref bmp_src_width,bmp_dst_width:TColor; constref pow:byte=32; alpha_max:byte=MAXBYTE); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  d_width1     : integer;
  d_width2     : integer;
  x,y          : integer;
begin
  if (rct_src.width<=0) or (rct_src.height<=0) then
    Exit;
  d_width1     :=bmp_src_width-rct_src.width;
  d_width2     :=bmp_dst_width-rct_src.width;
  src_pixel_ptr:=Unaligned(bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  Prefetch(src_pixel_ptr);
  Prefetch(dst_pixel_ptr);
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
          if (src_pixel_ptr^>>24=alpha_max) then
            dst_pixel_ptr^:=ColorizeP(dst_pixel_ptr^,0,pow)
          else
          if (src_pixel_ptr^>>24<alpha_max) and (src_pixel_ptr^>>24>0) then
            dst_pixel_ptr^:=ColorizeP(dst_pixel_ptr^,alpha_max-src_pixel_ptr^>>24,pow);
          Inc(src_pixel_ptr);
          Inc(dst_pixel_ptr);
        end;
      Inc(src_pixel_ptr,d_width1);
      Inc(dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
// (Vertical Gradient) Вертикальный градиент:
procedure PPGrVMonochrome    (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; grad_prop:TGradProp                ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  y            : integer;
begin
  with grad_prop do
    begin
      if (rct_dst.width=0) or (rct_dst.height=0) then
        Exit;
      dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
      for y:=0 to rct_dst.height-1 do
        begin
          FillDWord(dst_pixel_ptr^,
                    rct_dst.width,
                    RGB(y_grad_rng_div_vec.b>>16,
                        y_grad_rng_div_vec.g>>16,
                        y_grad_rng_div_vec.r>>16));
          Inc      (dst_pixel_ptr ,bmp_dst_width);
          Inc          (y_grad_rng_div_vec.r,
                          grad_rng_div_vec.r);
          Inc          (y_grad_rng_div_vec.g,
                          grad_rng_div_vec.g);
          Inc          (y_grad_rng_div_vec.b,
                          grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
procedure PPGrVAdditive      (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; grad_prop:TGradProp                ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  pix_row_val  : TColor;
begin
  with grad_prop do
    begin
      if (rct_dst.width=0) or (rct_dst.height=0) then
        Exit;
      d_width      :=bmp_dst_width-rct_dst.width;
      dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
      for y:=0 to rct_dst.height-1 do
        begin
          pix_row_val:=RGBA(y_grad_rng_div_vec.r>>16,
                            y_grad_rng_div_vec.g>>16,
                            y_grad_rng_div_vec.b>>16,
                            y_grad_rng_div_vec.a>>16);
          for x:=0 to rct_dst.width-1 do
            begin
                  dst_pixel_ptr^:=AdditiveDecC(
                  dst_pixel_ptr^,pix_row_val);
              Inc(dst_pixel_ptr);
            end;
          Inc    (dst_pixel_ptr,d_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure PPGrVAlphablend    (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; grad_prop:TGradProp                ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  pix_row_val  : TColor;
  pow          : byte;
begin
  with grad_prop do
    begin
      if (rct_dst.width=0) or (rct_dst.height=0) then
        Exit;
      d_width      :=bmp_dst_width-rct_dst.width;
      dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
      for y:=0 to rct_dst.height-1 do
        begin
          pix_row_val:=RGBA(y_grad_rng_div_vec.r>>16,
                            y_grad_rng_div_vec.g>>16,
                            y_grad_rng_div_vec.b>>16,
                            y_grad_rng_div_vec.a>>16);
          pow        :=MAXBYTE-TRGBA(pix_row_val).a;
          for x:=0 to rct_dst.width-1 do
            begin
                  dst_pixel_ptr^:=AlphaBlendDecA(
                  dst_pixel_ptr^,pix_row_val,pow,0);
              Inc(dst_pixel_ptr);
            end;
          Inc    (dst_pixel_ptr,d_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure PPGrVInverse       (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; grad_prop:TGradProp                ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  pix_row_val  : TColor;
begin
  with grad_prop do
    begin
      if (rct_dst.width=0) or (rct_dst.height=0) then
        Exit;
      d_width      :=bmp_dst_width-rct_dst.width;
      dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
      for y:=0 to rct_dst.height-1 do
        begin
          pix_row_val:=RGBA(y_grad_rng_div_vec.r>>16,
                            y_grad_rng_div_vec.g>>16,
                            y_grad_rng_div_vec.b>>16,
                            y_grad_rng_div_vec.a>>16);
          for x:=0 to rct_dst.width-1 do
            begin
              InverseDec(dst_pixel_ptr^,TRGBA(pix_row_val).a);
              Inc       (dst_pixel_ptr);
            end;
          Inc           (dst_pixel_ptr,d_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure PPGrV16            (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; grad_prop:TGradProp; Proc16:TProc16); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  pix_row_val  : TColor;
  pow          : byte;
begin
  with grad_prop do
    begin
      if (rct_dst.width=0) or (rct_dst.height=0) then
        Exit;
      d_width      :=bmp_dst_width-rct_dst.width;
      dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
      for y:=0 to rct_dst.height-1 do
        begin
          pix_row_val:=RGBA(y_grad_rng_div_vec.r>>16,
                            y_grad_rng_div_vec.g>>16,
                            y_grad_rng_div_vec.b>>16,
                            y_grad_rng_div_vec.a>>16);
          pow        :=MAXBYTE-TRGBA(pix_row_val).a;
          for x:=0 to rct_dst.width-1 do
            begin
              Proc16(dst_pixel_ptr^,0,pow);
              Inc   (dst_pixel_ptr);
            end;
          Inc       (dst_pixel_ptr,d_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure PPGrV17            (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; grad_prop:TGradProp; Proc17:TProc17); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  pix_row_val  : TColor;
  pow          : byte;
begin
  with grad_prop do
    begin
      if (rct_dst.width=0) or (rct_dst.height=0) then
        Exit;
      d_width      :=bmp_dst_width-rct_dst.width;
      dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
      for y:=0 to rct_dst.height-1 do
        begin
          pix_row_val:=RGBA(y_grad_rng_div_vec.r>>16,
                            y_grad_rng_div_vec.g>>16,
                            y_grad_rng_div_vec.b>>16,
                            y_grad_rng_div_vec.a>>16);
          pow        :=MAXBYTE-TRGBA(pix_row_val).a;
          for x:=0 to rct_dst.width-1 do
            begin
              Proc17(dst_pixel_ptr^,pow);
              Inc   (dst_pixel_ptr);
            end;
          Inc       (dst_pixel_ptr,d_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure PPGrVMonoNoise     (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; grad_prop:TGradProp                ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  pix_row_val  : TColor;
  pow          : byte;
begin
  with grad_prop do
    begin
      if (rct_dst.width=0) or (rct_dst.height=0) then
        Exit;
      d_width      :=bmp_dst_width-rct_dst.width;
      dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
      for y:=0 to rct_dst.height-1 do
        begin
          pix_row_val:=RGBA(y_grad_rng_div_vec.r>>16,
                            y_grad_rng_div_vec.g>>16,
                            y_grad_rng_div_vec.b>>16,
                            y_grad_rng_div_vec.a>>16);
          pow        :=MAXBYTE-TRGBA(pix_row_val).a;
          for x:=0 to rct_dst.width-1 do
            begin
              if Odd(dst_pixel_ptr^) then
                     dst_pixel_ptr^:=pix_row_val;
              Inc   (dst_pixel_ptr);
            end;
          Inc       (dst_pixel_ptr,d_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure PPGrV18            (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; grad_prop:TGradProp; Proc18:TProc18); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  pix_row_val  : TColor;
begin
  with grad_prop do
    begin
      if (rct_dst.width=0) or (rct_dst.height=0) then
        Exit;
      d_width      :=bmp_dst_width-rct_dst.width;
      dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
      for y:=0 to rct_dst.height-1 do
        begin
          pix_row_val:=RGBA(y_grad_rng_div_vec.r>>16,
                            y_grad_rng_div_vec.g>>16,
                            y_grad_rng_div_vec.b>>16,
                            y_grad_rng_div_vec.a>>16);
          for x:=0 to rct_dst.width-1 do
            begin
              Proc18(dst_pixel_ptr^,TRGBA(pix_row_val).a,0);
              Inc   (dst_pixel_ptr);
            end;
          Inc       (dst_pixel_ptr,d_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure PPGrV19            (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; grad_prop:TGradProp; Proc19:TProc19); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  pix_row_val  : TColor;
begin
  with grad_prop do
    begin
      if (rct_dst.width=0) or (rct_dst.height=0) then
        Exit;
      d_width      :=bmp_dst_width-rct_dst.width;
      dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
      for y:=0 to rct_dst.height-1 do
        begin
          pix_row_val:=RGBA(y_grad_rng_div_vec.r>>16,
                            y_grad_rng_div_vec.g>>16,
                            y_grad_rng_div_vec.b>>16,
                            y_grad_rng_div_vec.a>>16);
          for x:=0 to rct_dst.width-1 do
            begin
              Proc19(dst_pixel_ptr,bmp_dst_width,TRGBA(pix_row_val).a);
              Inc   (dst_pixel_ptr);
            end;
          Inc       (dst_pixel_ptr,d_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure PPGrVContrast      (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; grad_prop:TGradProp                ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  pix_row_val  : TColor;
  pix_const_val: TColor;
  contrast_pow : integer;
begin
  with grad_prop do
    begin
      if (rct_dst.width=0) or (rct_dst.height=0) then
        Exit;
      pix_const_val:=RGB(128,128,128);
      d_width      :=bmp_dst_width-rct_dst.width;
      dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
      for y:=0 to rct_dst.height-1 do
        begin
          pix_row_val :=RGBA(y_grad_rng_div_vec.r>>16,
                             y_grad_rng_div_vec.g>>16,
                             y_grad_rng_div_vec.b>>16,
                             y_grad_rng_div_vec.a>>16);
          contrast_pow:=ContrastPrecalc(1+(MAXBYTE-TRGBA(pix_row_val).a)/10);
          for x:=0 to rct_dst.width-1 do
            begin
                  dst_pixel_ptr^:=ContrastDecA(
                  dst_pixel_ptr^,pix_const_val,TRGBA(pix_row_val).a,contrast_pow);
              Inc(dst_pixel_ptr);
            end;
          Inc    (dst_pixel_ptr,d_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (Contrast) Контрастность:
procedure PPContrast1        (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; constref pow:byte=64); {$region -fold}
var
  contrast_pow : double;
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  r,g,b        : byte;
  pow2         : shortint;
begin
  r   :=128;
  g   :=128;
  b   :=128;
  pow2:=pow;
  if (pow2>0) then
    contrast_pow:=1+(pow2/10)
  else
    contrast_pow:=1-(Sqrt(-pow2)/10);
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          Contrast(dst_pixel_ptr,r,g,b,contrast_pow);
          Inc     (dst_pixel_ptr);
        end;
      Inc         (dst_pixel_ptr,d_width);
    end;
end; {$endregion}
procedure PPContrast2        (                  constref             bmp_dst_ptr:PInteger;                           constref rct_dst:TPtRect; constref               bmp_dst_width:TColor; constref pow:byte=64); {$region -fold}
var
  contrast_pow : double;
  dst_pixel_ptr: PInteger;
  d_width      : integer;
  x,y          : integer;
  r,g,b        : byte;
  r_,g_,b_     : longword;
  pow2         : shortint;
begin
  d_width      :=bmp_dst_width-rct_dst.width;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  r_           :=0;
  g_           :=0;
  b_           :=0;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          Inc(r_,TRGBA((dst_pixel_ptr)^).r);
          Inc(g_,TRGBA((dst_pixel_ptr)^).g);
          Inc(b_,TRGBA((dst_pixel_ptr)^).b);
          Inc          (dst_pixel_ptr);
        end;
      Inc              (dst_pixel_ptr,d_width);
    end;
  r:=Trunc(r_/(rct_dst.width*rct_dst.height));
  g:=Trunc(g_/(rct_dst.width*rct_dst.height));
  b:=Trunc(b_/(rct_dst.width*rct_dst.height));
  pow2:=pow;
  if (pow2>0) then
    contrast_pow:=1+(pow2/10)
  else
    contrast_pow:=1-(Sqrt(-pow2)/10);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          Contrast(dst_pixel_ptr,r,g,b,contrast_pow);
          Inc     (dst_pixel_ptr);
        end;
      Inc         (dst_pixel_ptr,d_width);
    end;
end; {$endregion}

{$endregion}

end.

unit Fast_Graphics;

{This file contains some basic routines and routines for fast drawing of primitives like a line,
rectangle,circle,rhombus and their miscellaneous variations, filters, blitters,
CSR-sprites processing etc.}

{Some abbreviations:
   - aa   =anti-aliasing;
   - arr  =array;
   - bkgnd=background;
   - bmp  =bitmap;
   - col  =color;
   - clp  =clipped;
   - clr  =clear;
   - crc  =circle;
   - crt  =create;
   - dst  =destination;
   - fil  =fill;
   - ftimg=fast image;
   - grad =gradient;
   - grh  =gradient(horizontal);
   - grv  =gradient(vertical);
   - img  =image;
   - inn  =inner;
   - intr =integer;
   - it   =item;
   - ln   =line;
   - mov  =move;
   - mrg  =margin;
   - mt   =multi-threading;
   - op   =operation;
   - out  =outer;
   - pix  =pixel;
   - pp   =post-processing;
   - pt   =point(another meaning of the word: partly transparent; depending on the context);
   - ptr  =pointer;
   - pts  =points;
   - rct  =rect=rectangle;
   - reg  =regular;
   - scl  =scale;
   - sel  =select;
   - src  =source;
   - vec  =vector;}

{$mode objfpc}{$H+,R-,Q-}
{$modeswitch advancedrecords}
{$modeswitch arrayoperators}
{$modeswitch typehelpers}

interface

uses

  {$ifdef Windows}Windows,{$endif} Graphics, Classes, FPCanvas, GraphType, Math,
  Types, TypInfo, {MTProcs, PasMP,} SysUtils, GL, GLU, GLEXT, {GLUT, dglOpenGL,}
  OpenGLContext, Fast_SIMD;



const

  GAMMA_MIN          =0.0;
  GAMMA_MAX          =7.0;

  ONE_SHL_10         =1<<10;
  ONE_SHL_15         =1<<15;

  ONE_SHL_16         =1<<16;
  ONE_SHL_16_SUB_1   =ONE_SHL_16-1;

  ONE_SHL_24         =1<<24;
  ONE_SHL_24_SUB_1   =ONE_SHL_24-1;

  ONE_SHL_30         =1<<30;
  ONE_SHL_56         =1<<56;

  ONE_SHL_24_56      =ONE_SHL_24+ONE_SHL_56;

  ONE_SHL_24_56_SUB_1=ONE_SHL_24_SUB_1+ONE_SHL_24_SUB_1<<32;

  DEFAULT_SCL_MUL    =5/4{6/5};
  DEFAULT_SCL_MUL_INV=1/DEFAULT_SCL_MUL;

  FULL_ROT           =pi/180;
  ONE_DIV_BY_FULL_ROT=01/FULL_ROT;

  LN_0_95            =Ln(0.95);

  MAX_SPRITE_WIDTH   =MAXLONG;
  MAX_SPRITE_HEIGHT  =MAXLONG;

  MSK0               =%00000000000000000000000000000011;
  MSK0_NOT           =not MSK0;

  NT_BIT_MASK_ALPHA  =$FF000000;

  NT_BIT_MASK_ALPHA2 =$00FFFFFF;

  NZ_ITEM_COEFF10    =1+Trunc(Ln(MAXBYTE )/Ln(2));
  NZ_ITEM_COEFF20    =1<<NZ_ITEM_COEFF10-1;
  NZ_ITEM_COEFF11    =1+Trunc(Ln(MAXWORD )/Ln(2));
  NZ_ITEM_COEFF21    =1<<NZ_ITEM_COEFF11-1;
  NZ_ITEM_COEFF12    =1+Trunc(Ln(MAXDWORD)/Ln(2));
  NZ_ITEM_COEFF22    =1<<NZ_ITEM_COEFF12-1;
                      {l.b. - last bit:             l.b.    l.b.    l.b.    l.b.    l.b.    l.b.    l.b.    l.b.   }
  AA_LINE_KIND000    ={00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001;
  AA_LINE_KIND001    ={00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000;
  AA_LINE_KIND002    ={00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000;
  AA_LINE_KIND003    ={00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001;
  AA_LINE_KIND004    ={00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000;
  AA_LINE_KIND005    ={00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001;
  AA_LINE_KIND006    ={01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000;
  AA_LINE_KIND007    ={01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001;
  AA_LINE_KIND008    ={01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001;
  AA_LINE_KIND009    ={01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000;
  AA_LINE_KIND010    ={01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000;
  AA_LINE_KIND011    ={01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001;
  AA_LINE_KIND012    ={01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000;
  AA_LINE_KIND013    ={01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001;
  AA_LINE_KIND014    ={01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000;
  AA_LINE_KIND015    ={11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000;
  AA_LINE_KIND016    ={10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000;
  AA_LINE_KIND017    ={11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000;
  AA_LINE_KIND018    ={10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001;
                      {l.b. - last bit:             l.b.    l.b.    l.b.    l.b.    l.b.    l.b.    l.b.    l.b.   }
  AA_LINE_KIND100    ={11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000;
  AA_LINE_KIND101    ={01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000;
  AA_LINE_KIND102    ={01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000;
  AA_LINE_KIND103    ={11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000;
  AA_LINE_KIND104    ={01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000;
  AA_LINE_KIND105    ={11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000;
  AA_LINE_KIND106    ={01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000;
  AA_LINE_KIND107    ={11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000;
  AA_LINE_KIND108    ={10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000;
  AA_LINE_KIND109    ={00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000;
  AA_LINE_KIND110    ={00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000;
  AA_LINE_KIND111    ={10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000;
  AA_LINE_KIND112    ={00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000;
  AA_LINE_KIND113    ={10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000;
  AA_LINE_KIND114    ={01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000;
  AA_LINE_KIND115    ={00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001;
  AA_LINE_KIND116    ={01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001;
  AA_LINE_KIND117    ={00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001;
  AA_LINE_KIND118    ={11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001;
                      {l.b. - last bit:             l.b.    l.b.    l.b.    l.b.    l.b.    l.b.    l.b.    l.b.   }
  AA_LINE_KIND300    ={00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000;
  AA_LINE_KIND301    ={01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000;

  GLUT_DOUBLE        =02;
  GLUT_RGB           =00;
  GLUT_DEPTH         =16;



type

  {Forward declarations *******************************************************} {$region -fold}
  TFastActorSet      =class;
  TFastActor         =class;
  TFastImageItem     =class;
  TFastImageProc     =class;
  TFastLine          =class;
  TFastText          =class;
  {****************************************************************************} {$endregion}



  {Miscellaneous types ********************************************************} {$region -fold}
  // Exdended to be able to have ABGR color format: !!!!!!!!!!!!!!!!!!!!!!!!!!!!
  PInteger           =PLongWord;
  TColor             = LongWord;
  PColor             =                 ^TColor;
  TColorArr          =array of          TColor;
  PColorArr          =                 ^TColorArr;
  TColor2Arr         =array of array of TColor;
  PColor2Arr         =                 ^TColor2Arr;

  {Blur Effects}
  TBlurType          =(btRGB,
                       btRRB,
                       btRGR,
                       btGGB,
                       btRGG,
                       btBGB,
                       btRBB,
                       btRRR,
                       btGGG,
                       btBBB);
  PBlurType          =^TBlurType;

  {Camera shake type}
  TCameraShake       =(csRandom,
                       csSpline);
  PCameraShake       =^TCameraShake;

  {Direction type}
  TMovingDirection   =(mdLeft,
                       mdRight,
                       mdUp,
                       mdDown,
                       mdLeftUp,
                       mdRightUp,
                       mdLeftDown,
                       mdRightDown,
                       mdNone);
  PMovingDirection   =^TMovingDirection;

  {Drawing style}
  TDrawingStyle      =(dsMonochrome,
                       dsAdditive,
                       dsAlphablend,
                       dsInverse,
                       dsHighlight,
                       dsDarken,
                       dsGrayscaleR,
                       dsGrayscaleG,
                       dsGrayscaleB,
                       dsNoise,
                       dsColorizeR,
                       dsColorizeG,
                       dsColorizeB,
                       dsBlurRGB,
                       dsBlurRRB,
                       dsBlurRGR,
                       dsBlurGGB,
                       dsBlurRGG,
                       dsBlurBGB,
                       dsBlurRBB,
                       dsBlurRRR,
                       dsBlurGGG,
                       dsBlurBBB,
                       dsContrast);
  PDrawingStyle      =^TDrawingStyle;

  TDynamicsStyle     =(dsNone,
                       dsNative,
                       dsSoft,
                       dsSpring,
                       dsRigid);
  PDynamicsStyle     =^TDynamicsStyle;

  {Spline type}
  TSplineType        =(stFreeHand,
                       stFormula,
                       stRandom,
                       stLoad);
  PSplineType        =^TSplineType;

  {Spline mode}
  TSplineMode        =(smContinuous,
                       smDiscrete,
                       smSpray);
  PSplineMode        =^TSplineMode;

  {Selection mode}
  TSelectionMode     =(smCircle,
                       smBrush,
                       smRectangle,
                       smRegion,
                       smSelectAll);
  PSelectionMode     =^TSelectionMode;

  {Background post-processing}
  TBackgroundStyle   =(bsGrayscale,
                       bsBlur,
                       bsBoth,
                       bsNone);
  PBackgroundStyle   =^TBackgroundStyle;

  {Clipping}
  TClipStyle         =(csClippedEdges1,
                       csClippedEdges2,
                       csRemoveEdges,
                       csResilientEdges,
                       csAdvancedClip);
  PClipStyle         =^TClipStyle;

  {Blur}
  TBorderFilter      =(efNotTiled,
                       efTiled);
  PBorderFilter      =^TBorderFilter;

  {Spline formula}
  TSplineFormula     =(sfCycloid,
                       sfEpicycloid,
                       sfHypocycloid,
                       sfRose,
                       sfSpiral,
                       sfSuperellipse);
  PSplineFormula     =^TSplineFormula;

  TParamType         =(ptLeft,
                       ptTop);
  PParamType         =^TParamType;

  TSclDir            =(sdUp,
                       sdDown,
                       sdNone);
  PSclDir            =^TSclDir;

  TEnum0             =0..3;
  PEnum0             =^TEnum0;

  TEnum1             =0..4;
  PEnum1             =^TEnum1;

  PByteBool          =^boolean;

  TFunc0Args         =packed record {$region -fold}
    r      :byte;
    g      :byte;
    b      :byte;
    alpha  :byte;
    d_alpha:byte;
    pow    :byte;
    d      :smallint;
  end; {$endregion}
  PFunc0Args         =^TFunc0Args;

  TObjSel            =       record {$region -fold}
    // kind   of selected object(spline, sprite, etc.,...)
    obj_kind:integer;
    // number of selected object inside array of this kind
    obj_id  :integer;
  end; {$endregion}
  PObjSel            =^TObjSel;

  TPtRect            =       record {$region -fold}
    left  : integer;
    top   : integer;
    width : integer;
    height: integer;
    right : integer;
    bottom: integer;
  end; {$endregion}
  PPtRect            =^TPtRect;

  TPtRectF           =       record {$region -fold}
    left  : double;
    top   : double;
    width : double;
    height: double;
    right : double;
    bottom: double;
  end; {$endregion}
  PPtRectF           =^TPtRectF;

  TPtRectB           =packed record {$region -fold}
    pt_rct  : TPtRect;
    b_left  : boolean;
    b_top   : boolean;
    b_right : boolean;
    b_bottom: boolean;
  end; {$endregion}
  PPtRectB           =^TPtRectB;

  TPtPos             =packed record {$region -fold}
    x,y: integer;
  end; {$endregion}
  PPtPos             =^TPtPos;

  TPtPos2            =packed record {$region -fold}
    x,y: TColor;
    class operator =(r1,r2:TPtPos2): boolean; inline; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PPtPos2            =^TPtPos2;

  TPtPos3            =       record {$region -fold}
    arr        : array[0..5] of word;
    obj_ind    : integer;
    pts_ind    : integer;
    dup_pts_cnt: integer;
    class operator    =(      r1,r2:TPtPos3): boolean; inline; {$ifdef Linux}[local];{$endif}
    class operator    *(      r1,r2:TPtPos3): boolean; inline; {$ifdef Linux}[local];{$endif}
    procedure SetEqual1(var   r1   :TPtPos3;
                        const r2   :TPtPos3);          inline; {$ifdef Linux}[local];{$endif}
    procedure SetEqual2(var   r1   :TPtPos3;
                        const r2   :TPtPos3);          inline; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PPtPos3            =^TPtPos3;

  TPtPos4            =packed record {$region -fold}
    x: integer;
    y: boolean;
  end; {$endregion}
  PPtPos4            =^TPtPos4;

  TPtPos5            =       record {$region -fold}
    x0,x1,x2,x3,x4: integer;
  end; {$endregion}
  PPtPos5            =^TPtPos5;

  TPtPosF            =       record {$region -fold}
    x,y: double;
  end; {$endregion}
  PPtPosF            =^TPtPosF;

  TPtPosF2           =       record {$region -fold}
    x,y: double{single};
    class operator =(r1,r2:TPtPosF2): boolean; inline; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PPtPosF2           =^TPtPosF2;

  TPtPosW            =       record {$region -fold}
    x,y: word;
  end; {$endregion}
  PPtPosW            =^TPtPosW;

  TCrPos             =       record {$region -fold}
    x,y,r: integer;
  end; {$endregion}
  PCrPos             =^TCrPos;

  TCrPosF            =       record {$region -fold}
    x,y,r: double;
  end; {$endregion}
  PCrPosF            =^TCrPosF;

  TLnPos             =       record {$region -fold}
    x0,y0,x1,y1: integer;
  end; {$endregion}
  PLnPos             =^TLnPos;

  TLnPosF            =       record {$region -fold}
    x0,y0,x1,y1: double;
  end; {$endregion}
  PLnPosF            =^TLnPosF;

  TLnPosF2           =       record {$region -fold}
    x0,y0,x1,y1: double;
    b          : boolean;
  end; {$endregion}
  PLnPosF2           =^TLnPosF2;

  TLnPosF3           =       record {$region -fold}
    vec0,vec1:TLnPosF;
  end; {$endregion}
  PLnPosF3           =^TLnPosF3;

  TEdge              =       record {$region -fold}
    first_point: TColor;
    last_point : TColor;
    obj_ind    : TColor;
  end; {$endregion}
  PEdge              =^TEdge;

  TSlPt              =       record {$region -fold}
    point  : TColor;
    obj_ind: TColor;
  end; {$endregion}
  PSlPt              =^TSlPt;

  TRGBA              =       record {$region -fold}
    r,g,b,a: byte;
  end; {$endregion}
  PRGBA              =^TRGBA;

  TRGBA2             =       record {$region -fold}
    r,g,b,a: TColor;
  end; {$endregion}
  PRGBA2             =^TRGBA2;

  TRGB               =       record {$region -fold}
    r,g,b: byte;
  end; {$endregion}
  PRGB               =^TRGB;

  TGrid              =packed record {$region -fold}
    grid_rct                               : TPtRectF;
    shift                                  : TPtPosF;
    grid_density                           : TPtPos;
    grid_dx,grid_dy,grid_dx_inv,grid_dy_inv: double;
    val,i0,i1,j0,j1,di,dj                  : integer;
  end; {$endregion}
  PGrid              =^TGrid;

  TClip              =       record {$region -fold}
    main_part,clip_part: byte;
  end; {$endregion}
  PClip              =^TClip;

  TFXInfo            =packed record {$region -fold}
    // some reserved variables:
    cfx_pow0      : byte;
    // proc. indices:
    begin_proc_ind: TClip;
    color_proc_ind: TClip;
    value_proc_ind: TClip;
    // is effect visible on rendering:
    is_fx_visible : boolean;
    // does effect change its properties at runrime:
    is_fx_animate : boolean;
    // regular or gradient:
    is_fx_gradvec : boolean;
    // count of effect repetition:
    rep_cnt       : byte;
    {Type of Surface--------------------} {$region -fold}
    // [0..001]
    // 0 - nothing;
    // 1 - src. image;
    pix_srf_type  : byte; {$endregion}
    {Type of Color Effect---------------} {$region -fold}
    // [0..255]
    // 00 - monochrome       ;
    // 01 - additive         ;
    // 02 - alphablend       ;
    // 03 - inverse          ;
    // 04 - highlight        ;
    // 05 - darken           ;
    // 06 - grayscale r      ;
    // 07 - grayscale g      ;
    // 08 - grayscale b      ;
    // 09 - monochrome noise ;
    // 10 - colorize r       ;
    // 11 - colorize g       ;
    // 12 - colorize b       ;
    // 13 - blurRGB          ;
    // 14 - blurRRB          ;
    // 15 - blurRGR          ;
    // 16 - blurGGB          ;
    // 17 - blurRGG          ;
    // 18 - blurBGB          ;
    // 19 - blurRBB          ;
    // 20 - blurRRR          ;
    // 21 - blurGGG          ;
    // 22 - blurBBB          ;
    // 23 - contrast         ;
    pix_cfx_type  : byte; {$endregion}
    {Type of Image Changing-------------} {$region -fold}
    // [0..001]
    // 0 - constant;
    // 1 - fading;
    pix_cng_type  : byte; {$endregion}
  end; {$endregion}
  PFXInfo            =^TFXInfo;

  TFX                =packed record {$region -fold}
    // effect properties:
    nt_fx_prop  : TFXInfo;
    pt_fx_prop  : TFXInfo;
    // draw partly transparent pixels as not transparent:
    pt_as_nt    : boolean;
  end; {$endregion}
  PFX                =^TFX;

  TBckgdStngs        =packed record {$region -fold}
    // outer(clipping) rectangle:
    rct_clp       :TPtRect;
    // handle of drawing destination surface(background):
    bmp_dst_ptr   :PInteger;
    // width of drawing destination surface(background):
    bmp_dst_width :TColor;
    // height of drawing destination surface(background):
    bmp_dst_height:TColor;
  end; {$endregion}
  PBckgdStngs        =^TBckgdStngs;

  TListItem          =packed record {$region -fold}
    next_item_ptr: ^TListItem;
    ind          : longword;
  end; {$endregion}
  PListItem          =^TListItem;

  TIList             =packed record {$region -fold}
    next_item: ^TIList;
    x_ptr    : ^integer;
  end; {$endregion}
  PIList             =^TIList;

  TFList             =packed record {$region -fold}
    next_item: ^TFList;
    x,y      : double;
  end; {$endregion}
  PFList             =^TFList;

  TGCDGrid           =       record {$region -fold}
    f_ln_kind,a,b,c,d: integer;
  end; {$endregion}
  PGCDGrid           =^TGCDGrid;

  TIntrC4RGBA        =       record {$region -fold}
    r,g,b,a: integer;
  end; {$endregion}
  PIntrC4RGBA        =^TIntrC4RGBA;

  TColor4RGBA        =       record {$region -fold}
    r,g,b,a: TColor;
  end; {$endregion}
  PColor4RGBA        =^TColor4RGBA;

  TGradProp          =packed record {$region -fold}
    y_grad_rng_div_vec: TColor4RGBA;
      grad_rng_div_vec: TColor4RGBA;
    grad_col_dif      : TIntrC4RGBA;
    grad_vec_dif      : integer;
    grad_col0         : TRGBA;
    grad_col1         : TRGBA;
  end; {$endregion}
  PGradProp          =^TGradProp;

  TSprayProp         =packed record {$region -fold}
    rad,a: double;
    m1   : integer;
    m2   : integer;
  end; {$endregion}
  PSprayProp         =^TSprayProp;
  {****************************************************************************} {$endregion}



  {Anti-aliasing **************************************************************} {$region -fold}
  TFastAALine        = packed  record {$region -fold}
    first_pt_x: integer;
    first_pt_y: integer;
    line_shift: integer;
    line_kind : byte;
    // 00 - horizontal line: 2 points from left to right;
    // 01 - horizontal line: 2 points from right to left;
    // 02 - horizontal line: outer line from ends to middle;
    // 03 - horizontal line: inner line from middle to ends;
    // 04 - horizontal line: const fill;

    // 05 - vertical   line: 2 points from top to bottom;
    // 06 - vertical   line: 2 points from bottom to top;
    // 07 - vertical   line: inner line from ends to middle;
    // 08 - vertical   line: outer line from middle to ends;
    // 09 - vertical   line: const fill;

    // 10 - 1 point;
    // 11 - circle;
  end; {$endregion}
  PFastAALine        =^TFastAALine;
  {****************************************************************************} {$endregion}



  {Miscellaneous array types **************************************************} {$region -fold}
  TEnum0Arr          =packed array of TEnum0;
  PEnum0Arr          =^TEnum0Arr;

  TEnum1Arr          =packed array of TEnum1;
  PEnum1Arr          =^TEnum1Arr;

  TEnum2Arr          =array[0..3] of integer;
  PEnum2Arr          =^TEnum2Arr;

  TFastImageItemArr  =array of TFastImageItem;
  PFastImageItemArr  =^TFastImageItemArr;

  TPictArr           =array of TPicture;
  PPictArr           =^TPictArr;

  TFLnArr            =array of TFastLine;
  PFLnArr            =^TFLnArr;

  TFTxArr            =array of TFastText;
  PFTxArr            =^TFTxArr;

  TAALnArr           =array of TFastAALine;
  PAALnArr           =^TAALnArr;

  TObjSelArr         =array of TObjSel;
  PObjSelArr         =^TObjSelArr;

  TClipArr           =array of TClip;
  PClipArr           =^TClipArr;

  TRectArr           =array of TRect;
  PRectArr           =^TRectArr;

  TPtPos3Arr         =array of TPtPos3;
  PPtPos3Arr         =^TPtPos3Arr;

  T2PtPosFArr        =array of array of TPtPosF;
  P2PtPosFArr        =^T2PtPosFArr;

  TPtPosFArr         =array of TPtPosF;
  PPtPosFArr         =^TPtPosFArr;

  TPtPosWArr         =array of TPtPosW;
  PPtPosWArr         =^TPtPosWArr;

  TPtPosArr          =array of TPtPos;
  PPtPosArr          =^TPtPosArr;

  TEdgeArr           =array of TEdge;
  PEdgeArr           =^TEdgeArr;

  TSlPtArr           =array of TSlPt;
  PSlPtArr           =^TSlPtArr;

  TRGBAArr           =array[0..3] of byte;

  TRGBA2Arr          =array of TRGBA2;

  TRctValArr         =array[0..4] of integer;
  PRctValArr         =^TRctValArr;

  TFXArr             =array[0..15] of TFX;
  PFXArr             =^TFXArr;

  TFX2Arr            =array of TFX;
  PFX2Arr            =^TFX2Arr;

  TDublArr           =array of double;
  PDublArr           =^TDublArr;

  TIntrArr           =array of integer;
  PIntrArr           =^TIntrArr;

  TSmIntArr          =array of smallint;
  PSmIntArr          =^TSmIntArr;

  TShIntArr          =array of shortint;
  PShIntArr          =^TShIntArr;

  TLWordArr          =array of longword;
  PLWordArr          =^TLWordArr;

  TWordArr           =array of word;
  PWordArr           =^TWordArr;

  T1Byte1Arr         =array of byte;
  P1Byte1Arr         =^T1Byte1Arr;

  T1Byte2Arr         =array[0..15] of byte;
  P1Byte2Arr         =^T1Byte2Arr;

  T2Byte1Arr         =array of array of byte;
  P2Byte1Arr         =^T2Byte1Arr;

  T2Byte2Arr          =array of array[byte] of byte;
  P2Byte2Arr          =^T2Byte2Arr;

  TBool1Arr          =array of boolean;
  PBool1Arr          =^TBool1Arr;

  TBool2Arr          =array[0..100] of boolean;
  PBool2Arr          =^TBool2Arr;

  TListItemArr       =array of TListItem;
  PListItemArr       =^TListItemArr;

  TGCDArr            =array of TGCDGrid;
  PGCDArr            =TGCDArr;

  TStringArr         =array of string;
  PStringArr         =^TStringArr;

  TFontArr           =array of TFont;
  PFontArr           =^TFontArr;
  {****************************************************************************} {$endregion}



  {Procedure types ************************************************************} {$region -fold}
  TProc0             =procedure of object;
  PProc0             =^TProc0;

  TProc1             =procedure(         index               :integer;
                                         image               :TCustomBitmap)  of object;
  PProc1             =^TProc1;

  TProc2             =procedure(var      arr_dst             :TColorArr;
                                const    arr_dst_width       :TColor;
                                const    val                 :TColor)         of object;
  PProc2             =^TProc2;

  TProc3             =procedure(const    x0,y0,x1,y1         :integer;
                                const    proc_ptr_a,
                                         proc_ptr_b,
                                         proc_ptr_c          :TProc0)         of object;
  PProc3             =^TProc3;

  TProc4             =procedure(const    bmp_dst_ptr         :PInteger;
                                const    bmp_dst_width       :TColor;
                                const    rct_dst             :TPtRect);
  PProc4             =^TProc4;

  TProc4_1           =procedure(const    bmp_dst_ptr         :PByte;
                                const    bmp_dst_width       :TColor;
                                const    rct_dst             :TPtRect);
  PProc4_1           =^TProc4_1;

  TProc5             =procedure(const    arr0                :T1Byte1Arr;
                                const    bmp_ptr             :PInteger;
                                const    bmp_width,
                                         bmp_height          :TColor;
                                const    rct_dst             :TPtRect;
                                const    col                 :TColor;
                                const    alpha               :byte=120);
  PProc5             =^TProc5;

  TProc6             =procedure(const    bmp_dst_ptr         :PInteger;
                                const    bmp_dst_width       :TColor;
                                const    rct_dst             :TPtRect);
  PProc6             =^TProc6;

  TProc7             =procedure(const    x,y                 :integer)        of object;
  PProc7             =^TProc7;

  TProc8             =procedure(         pixel_ptr           :PInteger;
                                const    bmp_dst_width       :TColor);
  PProc8             =^TProc8;

  TProc9             =procedure(         bmp_src_ptr,
                                         bmp_dst_ptr         :PInteger;
                                const    bmp_dst_width       :TColor;
                                const    rct_src             :TPtRect;
                                const    d_width,
                                         c,s,v,w,
                                         lt,tp,rt,bt         :integer);
  PProc9             =^TProc9;

  TProc10            =procedure(         x,y                 :integer;
                                const    pvt                 :TPtPosF;
                                var      pts                 :TPtPosFArr;
                                const    bmp_dst_ptr         :PInteger;
                                const    rct_clp             :TPtRect)        of object;
  PProc10            =^TProc10;

  TProc11            =procedure(         x,y                 :integer;
                                const    pvt                 :TPtPosF;
                                var      pts                 :TPtPosFArr;
                                const    bmp_dst_ptr         :PInteger;
                                const    rct1,rct2           :TPtRect)        of object;
  PProc11            =^TProc11;

  TProc12            =procedure(         x,y                 :integer;
                                var      sel_pts_rect        :TPtRectF)       of object;
  PProc12            =^TProc12;

  TProc13            =procedure(         x,y                 :integer)        of object;
  PProc13            =^TProc13;

  TProc14            =procedure(         sender              :TObject)        of object;
  PProc14            =^TProc14;

  TProc15            =procedure(         pixel_ptr           :PInteger);
  PProc15            =^TProc15;

  TProc16            =procedure(         pixel_ptr           :PInteger;
                                const    alpha_fade          :byte;
                                const    pow                 :byte=64);
  PProc16            =^TProc16;

  TProc17            =procedure(         pixel_ptr           :PInteger;
                                const    alpha_fade          :byte);
  PProc17            =^TProc17;

  TProc18            =procedure(         pixel_ptr           :PInteger;
                                const    alpha_fade          :byte;
                                const    pow                 :byte);
  PProc18            =^TProc18;

  TProc19            =procedure(         pixel_ptr           :PInteger;
                                const    bmp_dst_width       :TColor;
                                const    alpha_fade          :byte);
  PProc19            =^TProc19;

  TProc20            =procedure(         x0,y0,x1,y1         :double)         of object;
  PProc20            =^TProc20;

  TProc21            =procedure(const    data_write;
                                         data_shift          :integer;
                                         data_ptr0           :pointer)        of object;
  PProc21            =^TProc21;

  TProc22            =procedure(const    data_write;
                                         data_shift          :integer;
                                         data_ptr0,
                                         data_ptr1           :pointer)        of object;
  PProc22            =^TProc22;

  TProc23            =procedure(         pixel_ptr           :PInteger;
                                const    arr_ind             :integer;
                                const    pow1,pow2           :byte);
  PProc23            =^TProc23;

  TFunc0             =function (         pixel               :TColor;
                                const    r,g,b               :byte;
                                         alpha,d_alpha       :byte;
                                const    alpha_fade          :byte;
                                const    pow                 :byte;
                                const    d                   :smallint): TColor;
  PFunc0             =^TFunc0;

  {****************************************************************************} {$endregion}



  {Text properties(attributes) ************************************************} {$region -fold}
  TFTextProp         =packed record {$region -fold}
    // background color:
    bkgnd_col    : TColor;
    // background drawing:
    bkgnd_draw   : boolean;
    // background random color:
    bkgnd_rnd_col: boolean;
  end; {$endregion}
  PFTextProp         =^TFTextProp;
  {****************************************************************************} {$endregion}



  {Spline properties(attributes) **********************************************} {$region -fold}
  TCurveProp         =packed record {$region -fold}

    {Miscellaneous}
    // duplicated points id:
    dup_pts_id               : TPtPos3;
    // global spline object index:
    curve_obj_ind            : TColor;
    // spline points count:
    pts_cnt                  : TColor;
    //
    pts_cnt_val              : TColor;
    // edges simplification angle:
    eds_smpl_angle           : single;

    {Edges bounds}
    // edges bounds color(pointer ):
    rct_eds_col_ptr          : PColor;
    // edges bounds color(value   ):
    rct_eds_col              : TColor;
    // edges bounds color(inverted):
    rct_eds_col_inv          : TColor;
    // edges bounds color(random  ):
    rct_eds_col_rnd          : boolean;
    // edges bounds color(fall-off):
    rct_eds_col_fall_off     : boolean;
    rct_eds_col_fall_off_inc : byte;

    {Points bounds}
    // points bounds color(pointer ):
    rct_pts_col_ptr          : PColor;
    // points bounds color(value   ):
    rct_pts_col              : TColor;
    // points bounds color(inverted):
    rct_pts_col_inv          : TColor;
    // points bounds color(random  ):
    rct_pts_col_rnd          : boolean;
    // points bounds color(fall-off):
    rct_pts_col_fall_off     : boolean;
    rct_pts_col_fall_off_inc : byte;

    {Edges}
    // edges color(pointer ):
    eds_col_ptr              : PColor;
    // edges color(value   ):
    eds_col                  : TColor;
    // edges color(inverted):
    eds_col_inv              : TColor;
    // edges color(random  ):
    eds_col_rnd              : boolean;
    // edges color(fall-off):
    eds_col_fall_off         : boolean;
    eds_col_fall_off_inc     : byte;
    // edges width:
    eds_width                : TColor;
    // edges width half:
    eds_width_half           : TColor;
    // edges width parity:
    eds_width_odd            : TColor;
    // edges anti-aliasing:
    eds_aa                   : boolean;
    // points color pointer:

    {Points}
    // points color(pointer ):
    pts_col_ptr              : PInteger;
    // points color(value   ):
    pts_col                  : TColor;
    // points color(inverted):
    pts_col_inv              : TColor;
    // points color(random  ):
    pts_col_rnd              : boolean;
    // points color(fall-off):
    pts_col_fall_off         : boolean;
    pts_col_fall_off_inc     : byte;
    // point width:
    pts_width                : TColor;
    // point width  half:
    pts_width__half          : TColor;
    // point width parity:
    pts_width__odd           : TColor;
    // point height:
    pts_height               : TColor;
    // point height half:
    pts_height_half          : TColor;
    // point height parity:
    pts_height_odd           : TColor;

    {Custom point-rectangle}
    rct_val_arr              : TRctValArr;
    // point rectangle width:
    pts_rct_width            : TColor;
    // point rectangle width half:
    pts_rct_width__half      : TColor;
    // point rectangle width parity:
    pts_rct_width__odd       : TColor;
    // point rectangle height:
    pts_rct_height           : TColor;
    // point rectangle height half:
    pts_rct_height_half      : TColor;
    // point rectangle height parity:
    pts_rct_height_odd       : TColor;
    // point rectangle thickness left:
    pts_rct_tns_left         : TColor;
    // point rectangle thickness top:
    pts_rct_tns_top          : TColor;
    // point rectangle thickness right:
    pts_rct_tns_right        : TColor;
    // point rectangle thickness bottom:
    pts_rct_tns_bottom       : TColor;
    // point rectangle inner width:
    pts_rct_inn_width        : TColor;
    // point rectangle inner width parity:
    pts_rct_inn_width__odd   : TColor;
    // point rectangle inner height:
    pts_rct_inn_height       : TColor;
    // point rectangle inner height parity:
    pts_rct_inn_height_odd   : TColor;

    {Custom point-circle}
    // point inner radius:
    pts_crc_diam_inn         : TColor;
    // point inner radius half:
    pts_crc_diam_inn_half    : TColor;
    // point outer radius:
    pts_crc_diam_out         : TColor;
    // point outer radius half:
    pts_crc_diam_out_half    : TColor;

    {Custom point-polygon}
    // point polygon width:
    pts_plg_diam             : TColor;
    // point polygon width half:
    pts_plg_diam_half        : TColor;
    // point polygon angles count:
    pts_plg_ang_cnt          : TColor;

    {Custom point-sprite}
    // point sprite width:
    pts_srt_width            : TColor;
    // point sprite height:
    pts_srt_height           : TColor;

    // points drawing frequance:
    sln_pts_frq              : word;
    // spline type:
    sln_type                 : TSplineType;
    // spline mode:
    sln_mode                 : TSplineMode;
    // spray radius:
    spray_rad                : TColor;
    // edges  blending:
    eds_bld_stl              : TDrawingStyle;
    // points blending:
    pts_bld_stl              : TDrawingStyle;
    // edges  bounds blending:
    rct_eds_bld_stl          : TDrawingStyle;
    // points bounds blending:
    rct_pts_bld_stl          : TDrawingStyle;
    // edges clipping:
    clp_stl                  : TClipStyle;
    // grid clipping points density:
    grd_pts_dns              : TColor;
    // edges level of details:
    eds_lod                  : boolean;
    // edges level of details on creating of spline:
    eds_lod_on_create        : boolean;
    // simplification angle
    eds_simpl_angle          : double;
    // hidden-line elimination:
    hid_ln_elim              : boolean;
    // best regular(not grid) clipping quality:
    best_ends_quality        : boolean;
    // best precision for hidden-line elimination:
    best_precision           : boolean;
    // lazy_repaint:
    lazy_repaint             : boolean;
    lazy_repaint_prev        : boolean;
    // byte mode:
    byte_mode                : boolean;
    better_quality           : boolean;
    // grid clipping:
    grid_clipping_eds        : boolean;
    grid_clipping_pts        : boolean;
    grid_clipping_adaptive   : boolean;
    // only fit to window:
    only_fit_to_wnd_calc     : boolean;
    // free memory on out of window:
    free_mem_on_out_of_wnd   : boolean;
    // free memory on scale down:
    free_mem_on_scale_down   : boolean;
    // reallocate memory if previous pixels count is less than current pixels count:
    realloc_mem              : boolean;
    // remove brunching:
    remove_brunching         : boolean;
    // edges bounding rectangle:
    rct_eds_show             : boolean;
    // points bounding rectangle:
    rct_pts_show             : boolean;
    // edges  visibility:
    eds_show                 : boolean;
    // points visibility:
    pts_show                 : boolean;
    // connect ends:
    cnc_ends                 : boolean;
    // invert points indices order:
    pts_ord_inv              : boolean;
    // is object out of window:
    is_out_of_wnd            : boolean;
    // dynamics style:
    dyn_stl                  : TDynamicsStyle;

    // formula type:
    fml_type                 : TSplineFormula;

    {Cycloid}
    // points count:
    cycloid_pts_cnt          : TColor;
    // loops count:
    cycloid_loop_cnt         : TColor;
    // loop radius:
    cycloid_loop_rad         : double;
    // curvature:
    cycloid_curvature        : double;
    // curve direction on axis x:
    cycloid_dir_x            : TMovingDirection;
    // curve direction on axis y:
    cycloid_dir_y            : TMovingDirection;

    {Epicycloid}
    // points count:
    epicycloid_pts_cnt       : TColor;
    // petals count:
    epicycloid_petals_cnt    : double;
    // curve radius:
    epicycloid_rad           : double;
    // rotation angle:
    epicycloid_rot           : double;
    // cut on angle:
    epicycloid_angle         : double;

    {Rose}
    // points count:
    rose_pts_cnt             : TColor;
    // petals count:
    rose_petals_cnt          : double;
    // curve radius:
    rose_rad                 : double;
    // rotation angle:
    rose_rot                 : double;
    // cut on angle:
    rose_angle               : double;
    // mobius_grid:
    rose_mobius_grid         : boolean;

    {Spiral}
    // points count:
    spiral_pts_cnt           : TColor;
    // coil step:
    spiral_coil_step         : double;
    // curve radius:
    spiral_rad               : double;
    // rotation angle:
    spiral_rot               : double;
    // cut on angle:
    spiral_angle             : double;

    {Superellipse}
    // points count:
    superellipse_pts_cnt     : TColor;
    // curvature:
    superellipse_curvature0  : double;
    superellipse_curvature1  : double;
    superellipse_curvature2  : double;
    superellipse_curvature3  : double;
    // curve radius:
    superellipse_rad         : double;
    // rotation angle:
    superellipse_rot         : double;
    // cut on angle:
    superellipse_angle       : double;

    // Reserved:
    res_fld                  : byte;

  end; {$endregion}
  PCurveProp         =^TCurveProp;
  {****************************************************************************} {$endregion}



  {Select items properties(attributes) ****************************************} {$region -fold}
  TSelItProp         =packed record {$region -fold}
    bkgnd_style   : TBackgroundStyle;
    selection_mode: TSelectionMode;
  end; {$endregion}
  PSelItProp         =^TSelItProp;
  {****************************************************************************} {$endregion}



  {Color information **********************************************************} {$region -fold}
  TColorInfo         =packed record {$region -fold}
    pix_col : TColor;
    r,g,b   : byte;
      alpha1: byte;
    d_alpha1: byte;
      alpha2: byte;
    d_alpha2: byte;
  end; {$endregion}
  PColorInfo         =^TColorInfo;
  {****************************************************************************} {$endregion}



  {Fast actors container ******************************************************} {$region -fold}
  TFastActorSet      =class {$region -fold}
    // list of actors:
    act_arr       : array of TFastActor;
    // dummy icon:
    d_icon        : TFastImageItem;
    // array of actors positions:
    act_pos_arr   : TPtPosFArr;
    // selection field:
    sel_fld       : TColorArr;
    sel_fld_ptr   : PInteger;
    // actors count:
    act_cnt       : TColor;
    // first frame rect:
    first_frm_rect: TPtRect;
    // init. part:
    constructor Create(const bkgnd_ptr         :PInteger;
                       const bkgnd_width,
                             bkgnd_height      :TColor;
                       var   rct_clp           :TPtRect;
                       const bmp_src_rct       :TPtRect;
                       const location          :string='';
                       const ImgLstGetBmp      :TProc1=Nil;
                       const d_icon_img_lst_ind:TColor=0);           {$ifdef Linux}[local];{$endif}
    destructor  Destroy;                                   override; {$ifdef Linux}[local];{$endif}
    // add actor;
    procedure AddActor(x,y                     :integer);            {$ifdef Linux}[local];{$endif}
    {TODO}
  end; {$endregion}
  PFastActorSet      =^TFastActorSet;
  {****************************************************************************} {$endregion}



  {Fast image container *******************************************************} {$region -fold}
  TFastActorInstInfo =packed record {$region -fold}
    frm_ind         : integer;
    bmp_ftimg_left  : integer;
    bmp_ftimg_top   : integer;
    bmp_ftimg_right : integer;
    bmp_ftimg_bottom: integer;
    monochrome_val  : TColor;
    fx_arr          : TFXArr;
    fx_cnt          : byte;
    {Type of image drawing-------} {$region -fold}
    // 0 - color;
    // 1 -           value;
    // 2 - color and value;
    pix_drw_type    : byte; {$endregion}
    {Type of surface-------------} {$region -fold}
    // 0 - nothing;
    // 1 - src. image;
    // 2 - dst. background;
    nt_pix_srf_type : byte;
    pt_pix_srf_type : byte; {$endregion}
    {Type of color effect--------} {$region -fold}
    // 0 - monochrome;
    // 1 - additive;
    // 2 - alphablend;
    nt_pix_cfx_type : byte;
    pt_pix_cfx_type : byte; {$endregion}
    {Type of image clipping------} {$region -fold}
    // 0 - not clipped;
    // 1 - top-bottom clipped;
    // 2 - left-right-top-bottom clipped;
    nt_pix_clp_type : byte;
    pt_pix_clp_type : byte; {$endregion}
    {Type of image changing------} {$region -fold}
    // 0 - constant;
    // 1 - fading;
    nt_pix_cng_type : byte;
    pt_pix_cng_type : byte; {$endregion}
  end; {$endregion}
  PFastActorInstInfo =^TFastActorInstInfo;

  TFastActor         =class {$region -fold}
    // list of frames
    frm_arr      : array of TFastImageItem;
    // list of instances:
    act_inst_arr : array of array of TFastActorInstInfo;
    // list of paths for actor:
    path_ind_arr : TColorArr;
    //
    src_img_color: TBitmap;
    // frames count;
    frm_cnt      : TColor;
    constructor Create;            {$ifdef Linux}[local];{$endif}
    destructor  Destroy; override; {$ifdef Linux}[local];{$endif}
    {TODO}
  end; {$endregion}
  PFastActor         =^TFastActor;
  {****************************************************************************} {$endregion}



  {Fast image *****************************************************************} {$region -fold}
  // allows to store array in CSR(Compressed Sparse Row) format:
  TRenderType        =(rtDynamic,rtStatic);
  PRenderType        =^TRenderType;

  TFIPScaleData0     =record {$region -fold}
    rct_ent_left,
    _scl_mul_x,
    _scl_mul_y,
     scl_mul_x,
     scl_mul_y,
    d1,
    d2,
    g1,
    g2,
    r1,
    v3,
    dh: integer;
  end; {$endregion}
  PFIPScaleData0     =^TFIPScaleData0;

  TFIPScaleData1     =record {$region -fold}
    m0,m1: double;
  end; {$endregion}
  PFIPScaleData1     =^TFIPScaleData1;

  TFastImageData     =packed record {$region -fold}

    {Misc. data------------------} {$region -fold}
    // Reserved:
    res_var0              : integer;
    res_var1              : integer;
    res_var2              : integer;
    res_var3              : integer;
    res_var4              : integer;
    res_var5              : integer;
    res_var6              : integer;
    res_var7              : integer;
    res_var8              : integer;
    res_var9              : double;
    res_var10             : double;

    // ...
    nt_pix_arr_ptr        : PInteger;
    pt_pix_arr_ptr        : PInteger;

    // shader type proc. table:
    sdr_type_ind          : byte;

    // shader uber proc. table:
    sdr_proc_ind          : byte; {$endregion}

    {Scale transform data--------} {$region -fold}
    fip_scale_data_var0   : TFIPScaleData0;
    fip_scale_data_var1   : TFIPScaleData1; {$endregion}

    {Gradient vector-------------} {$region -fold}
    set_grad_to_vis_area  : boolean;
    grad_vec              : TPtPos;
    grad_vec2             : TPtPos;
    grad_col              : TPtPos2;
    grad_prop             : TGradProp; {$endregion}

    {Color and value info--------} {$region -fold}
    // effects param.s array:
    fx_arr                : TFXArr;
    // count of effects:
    fx_cnt                : byte;
    // ...
    monochrome_val        : TColor;
    // ...
    cfx_pow0              : byte;
    // ...
    pt_as_nt              : boolean;
    {Type of sprite inversion along axes} {$region -fold}
    // [0..003]
    // 0 - not     inverted;
    // 1 - x -axis inverted;
    // 2 - y -axis inverted;
    // 3 - xy-axis inverted;
    img_inv_type          : byte; {$endregion} {$endregion}

    {Color/alpha of current layer} {$region -fold}
    // NT - not transparent pixels:
    nt_pix_ccl_arr        : TColorArr;

    // PT - partly transparent pixels:
    // color channel:
    pt_pix_ccl_arr        : TColorArr;
    // alpha channel:
    pt_pix_acl_arr        : T1Byte1Arr; {$endregion}

    {Color       of lower   layer} {$region -fold}
    // NT - not transparent pixels:
    nt_pix_cll_arr        : TColorArr;

    // PT - partly transparent pixels:
    pt_pix_cll_arr        : TColorArr; {$endregion}

    {Value       of current layer} {$region -fold}
    // NT - not transparent pixels:
    nt_pix_val_arr        : TColorArr;

    // PT - partly transparent pixels; reserved:
    pt_pix_val_arr        : TColorArr; {$endregion}

    {Items counts in rows--------} {$region -fold}
    // NT - not transparent pixels:
    // each item is a count of NT pixels in a row:
    nt_pix_cnt_arr        : TWordArr;
    // ...:
    nt_pix_clm_arr        : TPtPosWArr;
    // PT - partly transparent pixels:
    // each item is a count of PT pixels in a row:
    pt_pix_cnt_arr        : TWordArr;
    // ...:
    pt_pix_clm_arr        : TPtPosWArr; {$endregion}

    {CSR-items shifts------------} {$region -fold}
    // NT - not transparent pixels:
    // each item is a count of NT pixels from first pixel to current in a row:
    nt_pix_sht_arr        : TWordArr;
    // PT - partly transparent pixels:
    // each item is a count of PT pixels from first pixel to current in a row:
    pt_pix_sht_arr        : TWordArr; {$endregion}

    {CSR-image clipping----------} {$region -fold}
    {Precalculated table of counts vertically(image clipping)}
    // NT - not    transparent pixels:
    // each item is a partial sum of nt_pix_intr_cnt_arr-items from first to previous item:
    nt_cnt_ind_arr        : TColorArr;
    // PT - partly transparent pixels:
    // each item is a partial sum of pt_pix_intr_cnt_arr-items from first to previous item:
    pt_cnt_ind_arr        : TColorArr;
    //
    rct_clp_ptr           : PPtRect;
    //
    bmp_src_rct_clp       : TPtRect;
    //
    rct_clp_mrg           : TPtRect;
    //
    rct_src_mrg           : TPtRect;
    //
    rct_src               : TPtRect;
    rct_src_f             : TPtRectF;
    rct_src_res           : TPtRect;
    //
    rct_dst               : TPtRect;
    rct_dst_f             : TPtRectF;
    // frames count in the sprite vertically:
    frame_cnt_v           : word;
    // height of one frame:
    frame_height          : single;
    frame_height_int      : integer;
    is_frame_animate      : boolean; {$endregion}

    {CSR-image kind--------------} {$region -fold}
    public
      var
        img_kind              : byte;
        {
        ----------------Image has alpha channel and color channel---------------
        0:
        image has:  not monochrome alpha channel,
                    not monochrome color channel,
        count of    not transparent pixels>0;
        count of partly transparent pixels>0;

        1:
        image has:  not monochrome alpha channel,
                    not monochrome color channel,
        count of    not transparent pixels>0;
        count of partly transparent pixels=0;

        2:
        image has:  not monochrome alpha channel,
                    not monochrome color channel,
        count of    not transparent pixels=0;
        count of partly transparent pixels>0;

        3:
        image has:      monochrome alpha channel(white, not transparent),
                    not monochrome color channel,
        count of    not transparent pixels>0;
        count of partly transparent pixels=0;

        4:
        image has:      monochrome alpha channel(transparent),
                    not monochrome color channel,
        count of    not transparent pixels=0;
        count of partly transparent pixels>0;


        ----------------------Image has only alpha channel----------------------
        5:
        image has:  not monochrome alpha channel,
                                no color channel,
        count of    not transparent pixels>0;
        count of partly transparent pixels>0;

        6:
        image has:  not monochrome alpha channel,
                                no color channel,
        count of    not transparent pixels>0;
        count of partly transparent pixels=0;

        7:
        image has:  not monochrome alpha channel,
                                no color channel,
        count of    not transparent pixels=0;
        count of partly transparent pixels>0;

        8:
        image has:      monochrome alpha channel(white, not transparent),
                                no color channel,
        count of    not transparent pixels>0;
        count of partly transparent pixels=0;

        9:
        image has:      monochrome alpha channel(transparent),
                                no color channel,
        count of    not transparent pixels=0;
        count of partly transparent pixels>0;


        --------------Image has no alpha channel and color channel--------------
        10:
        image has:      no alpha channel(black, invisible),
                        no color channel,
        count of    not transparent pixels=0;
        count of partly transparent pixels=0;

        --------------------------Image is value array--------------------------
        11:
        count of    not transparent pixels>0;
        count of partly transparent pixels>0;

        ------------------------------Image is mask-----------------------------
        12:
        count of    not transparent pixels>0;
        count of partly transparent pixels=0;
        } {$endregion}

    {CSR-image metrics-----------} {$region -fold}
    // pointer to background image(where sprite will be drawn):
    bmp_bkgnd_ptr          : PInteger;
    // background image width:
    bmp_bkgnd_width        : TColor;
    // background image height:
    bmp_bkgnd_height       : TColor;
    //
    bmp_color_ptr          : PInteger;
    //
    bmp_alpha_ptr          : PInteger;
    bmp_alpha_ptr2         : PByte;
    //
    bmp_value_ptr          : PInteger;
    //
    bmp_ftimg_width_origin : TColor;
    //
    bmp_ftimg_height_origin: TColor;
    //
    pvt0                   : TPtPosF;
    //
    pvt1                   : TPtPos;
    //
    rct_ent                : TPtRect;
    rct_ent_f              : TPtRectF;
    //
    rct_scl                : TPtRectF;
    //
    scl_mul                : TPtPosF;
    //
    // 0 -  (scl_mul.x =1.0) and (scl_mul.y =1.0);
    // 1 - ((scl_mul.x<=1.0) and (scl_mul.y< 1.0)) or
    //     ((scl_mul.x< 1.0) and (scl_mul.y<=1.0))
    // 2 - ((scl_mul.x>=1.0) and (scl_mul.y> 1.0)) or
    //     ((scl_mul.x> 1.0) and (scl_mul.y>=1.0))
    // 3 - ((scl_mul.x< 1.0) and (scl_mul.y> 1.0)) or
    //     ((scl_mul.x> 1.0) and (scl_mul.y< 1.0));
    scl_mul_check          : byte;
    //
    nt_pix_arr_row_mrg_top : TColor;
    //
    nt_pix_arr_row_mrg_btm : TColor;
    //
    pt_pix_arr_row_mrg_top : TColor;
    //
    pt_pix_arr_row_mrg_btm : TColor;
    //
    width_parity           : boolean;
    //
    height_parity          : boolean;
    //
    tile_map_calc          : boolean;
    //
    render_type            : TRenderType;
    //
    remove_brunching       : boolean;
    //
    better_quality         : boolean;
    //
    need_store_value       : boolean;
    //
    realloc_mem            : boolean;
    //
    are_all_fx_animated    : boolean; {$endregion}

    {Tiles copying---------------} {$region -fold}
    // array of tiles bounding rectangles inside one bitmap:
    rect_src_arr          : array of TPtRect;
    // tiles count:
    tiles_cnt             : TColor; {$endregion}

    {Total count of pixels-------} {$region -fold}
    // all pixels:
    al_pix_cnt            : TColor;
    // fully  transparent pixels count:
    ft_pix_cnt            : TColor;
    // not    transparent pixels count:
    nt_pix_cnt            : TColor;
    nt_pix_cnt_prev       : TColor;
    // partly transparent pixels count:
    pt_pix_cnt            : TColor;
    pt_pix_cnt_prev       : TColor;
    // count of zero(black) color pixels:
    zr_pix_cnt            : TColor;
    // count of pixels which are equal to first pixel:
    pt_pix_cng_cnt        : TColor;
    // ...:
    nt_pix_clm            : word;
    // ...:
    pt_pix_clm            : word; {$endregion}

    {Type of image drawing-------} {$region -fold}
    // 0 - color:
    // 1 -           value:
    // 2 - color and value:
    pix_drw_type          : byte; {$endregion}

    {Type of CSR-image clipping--} {$region -fold}

    // 0 - not clipped;
    // 1 - top-bottom clipped;
    // 2 - left-right-top-bottom clipped;
    // 3 - out of clipping rectangle;
    pix_clp_type          : byte;
    pix_clp_type_res      : byte; {$endregion}

    {Type of CSR-image processing} {$region -fold}
    // 0 - not to draw image(exclude shader);
    // 1 -        draw image(include shader);
    nt_useless            : byte;
    pt_useless            : byte; {$endregion}

    {Tilemap---------------------} {$region -fold}
    // map spline properties:
    sln_prop_var          : TCurveProp;
    // tile map handle:
    tilemap_sprite_ind    : integer;
    // width and height of sprite at mask:
    tilemap_sprite_w_h    : TPtPos;
    grid_color_info       : TColorInfo;
    grid_visible          : boolean;
    grid_draw_after       : boolean;
    //class var
     {// original tilemap image:
      tilemap_icn_src     : TColorArr;}
      // tile map collisions grids:
      tilemap_coll_grid0  : T1Byte1Arr;
      tilemap_coll_grid1  : T1Byte1Arr; {$endregion}

  end; {$endregion}
  PFastImageData     =^TFastImageData;

  TFID0              =procedure(var   fast_image_data_    :TFastImageData) of object;
  PFID0              =^TFID0;

  TFID1              =procedure(const x,y                 :integer;
                                const fast_image_data_ptr_:PFastImageData;
                                const index               :PtrInt =0;
                                const block_count         :integer=1) of object;
  PFID1              =^TFID1;

  TFID2              =procedure(const fast_image_data_ptr_:PFastImageData;
                                var   fast_image_data_    :TFastImageData) of object;
  PFID2              =^TFID2;

  TFastImageItem     =class  {$region -fold}
    fast_image_data: TFastImageData;
    constructor Create  (const bkgnd_ptr     :PInteger;
                         const bkgnd_width,
                               bkgnd_height  :TColor;
                         var   rct_clp       :TPtRect;
                         const bmp_src_rct   :TPtRect;
                         const empty         :TColor=0);                {$ifdef Linux}[local];{$endif}
    constructor Create  (const bkgnd_ptr     :PInteger;
                         const bkgnd_width,
                               bkgnd_height  :TColor;
                         var   rct_clp       :TPtRect;
                         const bmp_src_rct   :TPtRect;
                         const location      :string  ='';
                         const ImgLstGetBmp  :TProc1  =Nil;
                         const img_ind       :TColor  =0;
                         const tile_map_calc_:boolean =False;
                         const pic_src       :TPicture=Nil;
                         const is_gpu_tex    :boolean=False);           {$ifdef Linux}[local];{$endif}
    destructor  Destroy;                                      override; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PFastImageItem     =^TFastImageItem;

  TFastImageProc     =class  {$region -fold}

    // MT Data Array:
    fast_image_data_arr : array of TFastImageData;

    fast_image_data_ptr0: PFastImageData;
    fast_image_data_ptr1: PFastImageData;
    fast_image_data_ptr2: PFastImageData;

    {Proc. Table-----------------} {$region -fold}
    // Image Compression:
    CmpProc             : array[0..012] of TProc0;

    // Image Drawing:
    // NT - not transparent pixels:
    GenNTBeginProc      : array[0..002] of TFID2;
    // ||scl_mul||=1:
    RegNTColorProc      : array[0..029] of TFID2;
    RegNTValueProc      : array[0..255] of TFID2;
    GrVNTColorProc      : array[0..029] of TFID2;
    GrVNTValueProc      : array[0..255] of TFID2;
    // ||scl_mul||<1: (SD - Scale Down)
    RSDNTColorProc      : array[0..029] of TFID2;
    RSDNTValueProc      : array[0..255] of TFID2;
    GSDNTColorProc      : array[0..029] of TFID2;
    GSDNTValueProc      : array[0..255] of TFID2;
    // ||scl_mul||>1: (SU - Scale Up  )
    RSUNTColorProc      : array[0..029] of TFID2;
    RSUNTValueProc      : array[0..255] of TFID2;
    GSUNTColorProc      : array[0..029] of TFID2;
    GSUNTValueProc      : array[0..255] of TFID2;

    // PT - partly transparent pixels:
    GenPTBeginProc      : array[0..002] of TFID2;
    // ||scl_mul||=1:
    RegPTColorProc      : array[0..029] of TFID2;
    RegPTValueProc      : array[0..255] of TFID2;
    GrVPTColorProc      : array[0..029] of TFID2;
    GrVPTValueProc      : array[0..255] of TFID2;
    // ||scl_mul||<1: (SD - Scale Down)
    RSDPTColorProc      : array[0..029] of TFID2;
    RSDPTValueProc      : array[0..255] of TFID2;
    GSDPTColorProc      : array[0..029] of TFID2;
    GSDPTValueProc      : array[0..255] of TFID2;
    // ||scl_mul||>1: (SU - Scale Up  )
    RSUPTColorProc      : array[0..029] of TFID2;
    RSUPTValueProc      : array[0..255] of TFID2;
    GSUPTColorProc      : array[0..029] of TFID2;
    GSUPTValueProc      : array[0..255] of TFID2;

    // Shader Type Proc. Table:
    SdrType             : array[0..038] of TFID2;

    // Shader Uber Proc. Table:
    SdrProc             : array[0..007] of TFID1;

    // Clipping Proc. Table:
    NTUselessProc       : array[0..002] of TProc2;
    PTUselessProc       : array[0..002] of TProc2;

    SRIProc             : array[0..003] of TFID0;
    RRIProc             : array[0..003] of TFID0; {$endregion}

    {CSR-Image Routines----------} {$region -fold}

    {Clear Arrays------------------------------------------} {$region -fold}
    procedure ClrArr(arr_clear_val:word); inline; {$ifdef Linux}[local];{$endif}
    procedure ClrArr;                     inline; {$ifdef Linux}[local];{$endif} {$endregion}

    {Define Image Kind-------------------------------------} {$region -fold}
    procedure DetImageKind; {$ifdef Linux}[local];{$endif} {$endregion}

    {Create Array    of Items Counts  in Rows from Bitmap--} {$region -fold}
    //** color and alpha are in separate bitmaps
    // NT - not transparent pixels:
    procedure CrtNTCountBmpS; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure CrtPTCountBmpS; {$ifdef Linux}[local];{$endif}
    //** color and alpha are in one bitmap
    // NT - not transparent pixels:
    procedure CrtNTCountBmpO; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure CrtPTCountBmpO; {$ifdef Linux}[local];{$endif} {$endregion}

    {Create Array    of Items Counts  in Rows from Array---} {$region -fold}
    // NT - not transparent pixels:
    procedure CrtNTCountArrA; {$ifdef Linux}[local];{$endif}
    procedure CrtNTCountArrB; {$ifdef Linux}[local];{$endif}
    procedure CrtNTCountArrC; {$ifdef Linux}[local];{$endif}
    procedure CrtNTCountArrD; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure CrtPTCountArrA; {$ifdef Linux}[local];{$endif}
    procedure CrtPTCountArrB; {$ifdef Linux}[local];{$endif}
    procedure CrtPTCountArrC; {$ifdef Linux}[local];{$endif}
    procedure CrtPTCountArrD; {$ifdef Linux}[local];{$endif} {$endregion}

    {Create Array    of Items Shifts  in Rows from Bitmap--} {$region -fold}
    //** color and alpha are in separate bitmaps
    // NT - not transparent pixels:
    procedure CrtNTShiftBmpS; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure CrtPTShiftBmpS; {$ifdef Linux}[local];{$endif}
    //** color and alpha are in one bitmap
    // NT - not transparent pixels:
    procedure CrtNTShiftBmpO; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure CrtPTShiftBmpO; {$ifdef Linux}[local];{$endif} {$endregion}

    {Create Array    of Items Shifts  in Rows from Array---} {$region -fold}
    // NT - not transparent pixels:
    procedure CrtNTShiftArrA; {$ifdef Linux}[local];{$endif}
    procedure CrtNTShiftArrB; {$ifdef Linux}[local];{$endif}
    procedure CrtNTShiftArrC; {$ifdef Linux}[local];{$endif}
    procedure CrtNTShiftArrD; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure CrtPTShiftArrA; {$ifdef Linux}[local];{$endif}
    procedure CrtPTShiftArrB; {$ifdef Linux}[local];{$endif}
    procedure CrtPTShiftArrC; {$ifdef Linux}[local];{$endif}
    procedure CrtPTShiftArrD; {$ifdef Linux}[local];{$endif} {$endregion}

    {Store Color     of Current Layer         from Bmp/Arr-} {$region -fold}
    // NT - not transparent pixels:
    {store color channel}
    procedure StrNTColorBmpA; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    {store color channel}
    procedure StrPTColorBmpA; {$ifdef Linux}[local];{$endif}
    //** color and alpha are in separate bitmaps
    {store alpha channel into byte array---}
    procedure StrPTAlphaArrS; {$ifdef Linux}[local];{$endif}
    {store alpha channel into color channel}
    procedure StrPTAlphaBmpS; {$ifdef Linux}[local];{$endif}
    //** color and alpha are in one bitmap
    {store alpha channel into byte array---}
    procedure StrPTAlphaArrO; {$ifdef Linux}[local];{$endif}
    {store alpha channel into color channel}
    procedure StrPTAlphaBmpO; {$ifdef Linux}[local];{$endif} {$endregion}

    {Store Color     of Lower   Layer         from Bitmap--} {$region -fold}
    // NT - not transparent pixels:
    procedure StrNTLowerBmpA(const fast_image_data_ptr_:PFastImageData); {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure StrPTLowerBmpA(const fast_image_data_ptr_:PFastImageData); {$ifdef Linux}[local];{$endif}
    // store alpha from byte array:
    procedure StrPTLowerArrA;                                            {$ifdef Linux}[local];{$endif} {$endregion}

    {Store Value     of Current Layer         from Array---} {$region -fold}
    procedure StrNTValueArrA; {$ifdef Linux}[local];{$endif} {$endregion}

    {Set Chess Order of Alpha Channel in Rows from Bitmap--} {$region -fold}
    // calculation of image sides parity
    procedure CalcSidesParity; {$ifdef Linux}[local];{$endif}
    // color and alpha are in separate bitmaps
    // NT - not transparent pixels:
    procedure SetNTChessBmpS0; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure SetPTChessBmpS0; {$ifdef Linux}[local];{$endif}
    // color and alpha are in one bitmap
    // NT - not transparent pixels:
    procedure SetNTChessBmpO0; {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure SetPTChessBmpO0; {$ifdef Linux}[local];{$endif} {$endregion}

    {Create Array of Tiles Bounding Rectangles-------------} {$region -fold}
    procedure CrtRectArr; inline; {$ifdef Linux}[local];{$endif} {$endregion}

    {CSR-Image Compression---------------------------------} {$region -fold}
    // img. kind: 000:
    procedure CmpProc000 ; inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 001:
    procedure CmpProc001 ; inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 002:
    procedure CmpProc002 ; inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 003:
    procedure CmpProc003 ; inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 004:
    procedure CmpProc004 ; inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 005:
    procedure CmpProc005 ; inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 006:
    procedure CmpProc006 ; inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 007:
    procedure CmpProc007 ; inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 008:
    procedure CmpProc008 ; inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 009:
    procedure CmpProc009 ; inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 010:
    procedure CmpProc010 ; inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 011:
    procedure CmpProc011 ; inline; {$ifdef Linux}[local];{$endif}
    // img. kind: 012:
    procedure CmpProc012 ; inline; {$ifdef Linux}[local];{$endif}

    procedure CmpProcInit; inline; {$ifdef Linux}[local];{$endif}
    procedure ImgToCImg  ; inline; {$ifdef Linux}[local];{$endif} {$endregion}

    {CSR-Image Drawing-------------------------------------} {$region -fold}

    {Regular  FloodFill------------------------------------} {$region -fold}

    // NT - not transparent pixels:

    {Auxiliary procedure}
    procedure RegNTResVar0 (const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData); inline; {$ifdef Linux}[local];{$endif}
    procedure RegNTResVar1 (const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData); inline; {$ifdef Linux}[local];{$endif}
    procedure RegNTResVar2 (const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData); inline; {$ifdef Linux}[local];{$endif}
    procedure RegNTResVar3 (const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData); inline; {$ifdef Linux}[local];{$endif}
    procedure SclNTResVar0 (const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData); inline; {$ifdef Linux}[local];{$endif}
    procedure SclNTResVar1 (const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData); inline; {$ifdef Linux}[local];{$endif}

    {Color} {$region -fold}

    {||scl_mul||=1:                  } {$region -fold}

    {Empty}
    procedure RegNTColor009(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Color of Curent Layer}
    // (constant) auxiliary procedure:
    procedure RegNTColorA00(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegNTColor000(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTColorA04(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegNTColor004(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTColor006(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Color of Curent Layer(Additive)}
    // (constant) auxiliary procedure:
    procedure RegNTColor010(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTColor014(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTColor016(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedure:
    procedure RegNTColor011(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegNTColor015(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTColor017(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Color of Curent Layer(AlphaBlend)}
    // (constant) auxiliary procedure:
    procedure RegNTColor020(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTColor024(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTColor026(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {||scl_mul||<1: (SD - Scale Down)} {$region -fold}

    {Empty}
    procedure RSDNTColor009(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Color of Curent Layer}
    // (constant) not clipped:
    procedure RSDNTColorA00(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTColorA02(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTColorA04(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTColorA06(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    // (constant) not clipped:
    procedure RSDNTColorA10(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTColorA12(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTColorA14(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTColorA16(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    // (constant) not clipped:
    procedure RSDNTColor000(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTColor002(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTColor004(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTColor006(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Color of Curent Layer(Additive)}
    // (constant) not clipped:
    procedure RSDNTColor010(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTColor012(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTColor014(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTColor016(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTColor011(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTColor013(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTColor015(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTColor017(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Color of Curent Layer(Alphablend)}
    // (constant) not clipped:
    procedure RSDNTColor020(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTColor022(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTColor024(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTColor026(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {||scl_mul||>1: (SU - Scale Up  )} {$region -fold}

    {Empty}
    procedure RSUNTColor009(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Color of Curent Layer}
    // (constant) not clipped:
    procedure RSUNTColor000(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTColor002(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTColor004(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTColor006(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Color of Curent Layer(Additive)}
    // (constant) not clipped:
    procedure RSUNTColor010(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTColor012(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTColor014(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTColor016(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTColor011(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTColor013(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTColor015(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTColor017(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Color of Curent Layer(Alphablend)}
    // (constant) not clipped:
    procedure RSUNTColor020(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTColor022(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTColor024(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTColor026(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {$endregion}

    {Value} {$region -fold}

    {||scl_mul||=1:                  } {$region -fold}

    {Auxiliary procedures}
    // (constant) not cliped and top-bottom clipped:
    procedure RegNTValueA0 (      Proc17              :TProc17;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValueA4 (      Proc17              :TProc17;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped and top-bottom clipped:
    procedure RegNTValueB0 (      Proc15              :TProc15;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValueB4 (      Proc15              :TProc15;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped and top-bottom clipped:
    procedure RegNTValueC0 (      Proc8               :TProc8;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValueC4 (      Proc8               :TProc8;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped and top-bottom clipped:
    procedure RegNTValueD0 (      Proc19              :TProc19;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValueD4 (      Proc19              :TProc19;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Empty}
    procedure RegNTValue009(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Monochrome}
    // (constant) auxiliary procedure:
    procedure RegNTValueA00(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegNTValue000(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValueA04(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegNTValue004(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue006(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Additive}
    // (constant) auxiliary procedure:
    procedure RegNTValue010(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValue014(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue016(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedure:
    procedure RegNTValue011(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegNTValue015(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue017(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Alphablend}
    // (constant) auxiliary procedure:
    procedure RegNTValue020(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValue024(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue026(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading)
    //same;

    {Inverse}
    // (constant) auxiliary procedure:
    procedure RegNTValue030(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValue034(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue036(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegNTValue031(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegNTValue035(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue037(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Highlight}
    // (constant) not clipped:
    procedure RegNTValue040(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValue044(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue046(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Darken}
    // (constant) not clipped:
    procedure RegNTValue050(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValue054(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue056(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleR}
    // (constant) not clipped:
    procedure RegNTValue060(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValue064(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue066(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegNTValue061(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegNTValue065(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue067(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {GrayscaleG}
    // (constant) not clipped:
    procedure RegNTValue070(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValue074(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue076(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegNTValue071(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegNTValue075(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue077(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {GrayscaleB}
    // (constant) not clipped:
    procedure RegNTValue080(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValue084(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue086(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegNTValue081(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegNTValue085(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue087(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Monochrome Noise}
    // (constant) auxiliary procedure:
    procedure RegNTValue090(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValue094(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue096(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedure:
    procedure RegNTValue091(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegNTValue095(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue097(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {ColorizeR}
    // (constant) auxiliary procedure:
    procedure RegNTValue100(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValue104(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue106(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeG}
    // (constant) auxiliary procedure:
    procedure RegNTValue110(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValue114(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue116(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeB}
    // (constant) auxiliary procedure:
    procedure RegNTValue120(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValue124(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue126(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGB}
    // (constant) not clipped:
    procedure RegNTValue130(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValue134(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue136(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegNTValue131(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegNTValue135(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue137(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRRB}
    // (constant) not clipped:
    procedure RegNTValue140(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValue144(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue146(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegNTValue141(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegNTValue145(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue147(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRGR}
    // (constant) not clipped:
    procedure RegNTValue150(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValue154(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue156(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegNTValue151(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegNTValue155(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue157(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurGGB}
    // (constant) not clipped:
    procedure RegNTValue160(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValue164(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue166(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegNTValue161(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegNTValue165(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue167(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRGG}
    // (constant) not clipped:
    procedure RegNTValue170(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValue174(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue176(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegNTValue171(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegNTValue175(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue177(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurBGB}
    // (constant) not clipped:
    procedure RegNTValue180(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValue184(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue186(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegNTValue181(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegNTValue185(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue187(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRBB}
    // (constant) not clipped:
    procedure RegNTValue190(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValue194(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue196(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegNTValue191(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    /// (fading) left-right-top-bottom clipped:
    procedure RegNTValue195(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue197(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRRR}
    // (constant) not clipped:
    procedure RegNTValue200(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValue204(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue206(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegNTValue201(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegNTValue205(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue207(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurGGG}
    // (constant) not clipped:
    procedure RegNTValue210(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValue214(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue216(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegNTValue211(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegNTValue215(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue217(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurBBB}
    // (constant) not clipped:
    procedure RegNTValue220(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValue224(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue226(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegNTValue221(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegNTValue225(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RegNTValue227(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Contrast}
    // (constant) auxiliary procedure:
    procedure RegNTValue230(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegNTValue234(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegNTValue236(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {||scl_mul||<1: (SD - Scale Down)} {$region -fold}

    {Empty}
    procedure RSDNTValue009(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Monochrome}
    // (constant) not clipped:
    procedure RSDNTValue000(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTValue002(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTValue004(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTValue006(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTValue001(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTValue003(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTValue005(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTValue007(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Additive}
    // (constant) not clipped:
    procedure RSDNTValue010(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTValue012(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTValue014(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTValue016(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTValue011(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTValue013(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTValue015(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTValue017(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Alphablend}
    // (constant) not clipped:
    procedure RSDNTValue020(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTValue022(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTValue024(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTValue026(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTValue021(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTValue023(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTValue025(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTValue027(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Inverse}
    // (constant) not clipped:
    procedure RSDNTValue030(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTValue032(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTValue034(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTValue036(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTValue031(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTValue033(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTValue035(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTValue037(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Highlight}
    // (constant) not clipped:
    procedure RSDNTValue040(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTValue042(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTValue044(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTValue046(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTValue041(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTValue043(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTValue045(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTValue047(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Darken}
    // (constant) not clipped:
    procedure RSDNTValue050(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTValue052(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTValue054(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTValue056(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTValue051(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTValue053(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTValue055(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTValue057(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {GrayscaleR}
    // (constant) not clipped:
    procedure RSDNTValue060(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTValue062(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTValue064(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTValue066(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTValue061(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTValue063(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTValue065(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTValue067(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {GrayscaleG}
    // (constant) not clipped:
    procedure RSDNTValue070(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTValue072(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTValue074(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTValue076(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTValue071(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTValue073(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTValue075(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTValue077(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {GrayscaleB}
    // (constant) not clipped:
    procedure RSDNTValue080(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTValue082(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTValue084(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTValue086(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTValue081(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTValue083(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTValue085(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTValue087(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Monochrome Noise}
    // (constant) not clipped:
    procedure RSDNTValue090(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTValue092(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTValue094(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTValue096(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTValue091(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTValue093(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTValue095(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTValue097(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {ColorizeR}
    // (constant) not clipped:
    procedure RSDNTValue100(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTValue102(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTValue104(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTValue106(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTValue101(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTValue103(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTValue105(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTValue107(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {ColorizeG}
    // (constant) not clipped:
    procedure RSDNTValue110(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTValue112(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTValue114(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTValue116(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTValue111(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTValue113(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTValue115(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTValue117(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {ColorizeB}
    // (constant) not clipped:
    procedure RSDNTValue120(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTValue122(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTValue124(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTValue126(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTValue121(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTValue123(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTValue125(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTValue127(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRGB}
    // (constant) not clipped:
    procedure RSDNTValue130(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTValue132(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTValue134(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTValue136(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTValue131(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTValue133(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTValue135(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTValue137(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRRB}
    // (constant) not clipped:
    procedure RSDNTValue140(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTValue142(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTValue144(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTValue146(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTValue141(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTValue143(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTValue145(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTValue147(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRGR}
    // (constant) not clipped:
    procedure RSDNTValue150(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTValue152(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTValue154(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTValue156(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTValue151(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTValue153(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTValue155(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTValue157(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurGGB}
    // (constant) not clipped:
    procedure RSDNTValue160(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTValue162(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTValue164(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTValue166(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTValue161(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTValue163(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTValue165(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTValue167(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRGG}
    // (constant) not clipped:
    procedure RSDNTValue170(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTValue172(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTValue174(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTValue176(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTValue171(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTValue173(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTValue175(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTValue177(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurBGB}
    // (constant) not clipped:
    procedure RSDNTValue180(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTValue182(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTValue184(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTValue186(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTValue181(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTValue183(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTValue185(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTValue187(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRBB}
    // (constant) not clipped:
    procedure RSDNTValue190(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTValue192(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTValue194(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTValue196(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTValue191(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTValue193(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTValue195(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTValue197(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRRR}
    // (constant) not clipped:
    procedure RSDNTValue200(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTValue202(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTValue204(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTValue206(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTValue201(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTValue203(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTValue205(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTValue207(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurGGG}
    // (constant) not clipped:
    procedure RSDNTValue210(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTValue212(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTValue214(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTValue216(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTValue211(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTValue213(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTValue215(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTValue217(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurBBB}
    // (constant) not clipped:
    procedure RSDNTValue220(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTValue222(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTValue224(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTValue226(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTValue221(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTValue223(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTValue225(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTValue227(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Contrast}
    // (constant) not clipped:
    procedure RSDNTValue230(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDNTValue232(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDNTValue234(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDNTValue236(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDNTValue231(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDNTValue233(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDNTValue235(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSDNTValue237(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {$endregion}

    {||scl_mul||>1: (SU - Scale Up  )} {$region -fold}

    {Empty}
    procedure RSUNTValue009(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Monochrome}
    // (constant) not clipped:
    procedure RSUNTValue000(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTValue002(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTValue004(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTValue006(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTValue001(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTValue003(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTValue005(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTValue007(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Additive}
    // (constant) not clipped:
    procedure RSUNTValue010(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTValue012(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTValue014(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTValue016(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTValue011(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTValue013(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTValue015(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTValue017(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Alphablend}
    // (constant) not clipped:
    procedure RSUNTValue020(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTValue022(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTValue024(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTValue026(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTValue021(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTValue023(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTValue025(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTValue027(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Inverse}
    // (constant) not clipped:
    procedure RSUNTValue030(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTValue032(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTValue034(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTValue036(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTValue031(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTValue033(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTValue035(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTValue037(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Highlight}
    // (constant) not clipped:
    procedure RSUNTValue040(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTValue042(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTValue044(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTValue046(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTValue041(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTValue043(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTValue045(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTValue047(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Darken}
    // (constant) not clipped:
    procedure RSUNTValue050(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTValue052(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTValue054(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTValue056(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTValue051(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTValue053(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTValue055(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTValue057(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {GrayscaleR}
    // (constant) not clipped:
    procedure RSUNTValue060(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTValue062(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTValue064(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTValue066(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTValue061(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTValue063(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTValue065(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTValue067(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {GrayscaleG}
    // (constant) not clipped:
    procedure RSUNTValue070(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTValue072(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTValue074(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTValue076(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTValue071(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTValue073(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTValue075(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTValue077(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {GrayscaleB}
    // (constant) not clipped:
    procedure RSUNTValue080(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTValue082(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTValue084(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTValue086(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTValue081(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTValue083(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTValue085(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTValue087(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Monochrome Noise}
    // (constant) not clipped:
    procedure RSUNTValue090(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTValue092(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTValue094(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTValue096(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTValue091(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTValue093(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTValue095(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTValue097(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {ColorizeR}
    // (constant) not clipped:
    procedure RSUNTValue100(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTValue102(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTValue104(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTValue106(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTValue101(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTValue103(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTValue105(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTValue107(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {ColorizeG}
    // (constant) not clipped:
    procedure RSUNTValue110(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTValue112(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTValue114(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTValue116(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTValue111(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTValue113(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTValue115(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTValue117(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {ColorizeB}
    // (constant) not clipped:
    procedure RSUNTValue120(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTValue122(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTValue124(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTValue126(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTValue121(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTValue123(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTValue125(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTValue127(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRGB}
    // (constant) not clipped:
    procedure RSUNTValue130(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTValue132(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTValue134(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTValue136(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTValue131(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTValue133(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTValue135(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTValue137(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRRB}
    // (constant) not clipped:
    procedure RSUNTValue140(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTValue142(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTValue144(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTValue146(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTValue141(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTValue143(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTValue145(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTValue147(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRGR}
    // (constant) not clipped:
    procedure RSUNTValue150(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTValue152(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTValue154(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTValue156(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTValue151(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTValue153(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTValue155(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTValue157(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurGGB}
    // (constant) not clipped:
    procedure RSUNTValue160(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTValue162(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTValue164(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTValue166(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTValue161(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTValue163(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTValue165(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTValue167(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRGG}
    // (constant) not clipped:
    procedure RSUNTValue170(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTValue172(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTValue174(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTValue176(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTValue171(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTValue173(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTValue175(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTValue177(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurBGB}
    // (constant) not clipped:
    procedure RSUNTValue180(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTValue182(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTValue184(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTValue186(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTValue181(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTValue183(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTValue185(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTValue187(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRBB}
    // (constant) not clipped:
    procedure RSUNTValue190(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTValue192(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTValue194(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTValue196(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTValue191(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTValue193(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTValue195(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTValue197(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRRR}
    // (constant) not clipped:
    procedure RSUNTValue200(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTValue202(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTValue204(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTValue206(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTValue201(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTValue203(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTValue205(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTValue207(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurGGG}
    // (constant) not clipped:
    procedure RSUNTValue210(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTValue212(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTValue214(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTValue216(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTValue211(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTValue213(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTValue215(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTValue217(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurBBB}
    // (constant) not clipped:
    procedure RSUNTValue220(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTValue222(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTValue224(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTValue226(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTValue221(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTValue223(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTValue225(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTValue227(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Contrast}
    // (constant) not clipped:
    procedure RSUNTValue230(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUNTValue232(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUNTValue234(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUNTValue236(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUNTValue231(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUNTValue233(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUNTValue235(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    procedure RSUNTValue237(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {$endregion}

    {$endregion}

    {Noise} {$region -fold}

    {TODO}

    {$endregion}

    // PT - partly transparent pixels;

    {Auxiliary procedure}
    procedure RegPTResVar0 (const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData); inline; {$ifdef Linux}[local];{$endif}
    procedure RegPTResVar1 (const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData); inline; {$ifdef Linux}[local];{$endif}
    procedure RegPTResVar2 (const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData); inline; {$ifdef Linux}[local];{$endif}
    procedure RegPTResVar3 (const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData); inline; {$ifdef Linux}[local];{$endif}
    procedure SclPTResVar0 (const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData); inline; {$ifdef Linux}[local];{$endif}
    procedure SclPTResVar1 (const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData); inline; {$ifdef Linux}[local];{$endif}

    {Color} {$region -fold}

    {||scl_mul||=1:                  } {$region -fold}

    {Empty}
    procedure RegPTColor009(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Color of Curent Layer}
    // (constant) auxiliary procedures:
    procedure RegPTColorA00(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTColorB00(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTColor000(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTColorA04(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTColorB04(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTColor004(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has transparent alpha channel:
    procedure RegPTColor006(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Color of Curent Layer(Additive)}
    // (constant) auxiliary procedures:
    procedure RegPTColorA10(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTColorB10(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTColor010(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTColorA14(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTColorB14(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTColor014(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RegPTColor016(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTColorA11(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTColorB11(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTColor011(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTColorA15(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTColorB15(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegPTColor015(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    // same as (constant);

    {Color of Curent Layer(AlphaBlend)}
    // (constant) auxiliary procedures:
    procedure RegPTColorA20(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTColorB20(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTColor020(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTColorA24(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTColorB24(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTColor024(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {||scl_mul||<1: (SD - Scale Down)} {$region -fold}

    {Empty}
    procedure RSDPTColor009(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Color of Curent Layer}
    // (constant) not clipped:
    procedure RSDPTColorA00(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTColorA02(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTColorA04(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome alpha channel:
    procedure RSDPTColorA06(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    // (constant) not clipped:
    procedure RSDPTColorA10(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTColorA12(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTColorA14(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome alpha channel:
    procedure RSDPTColorA16(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    // (constant) not clipped:
    procedure RSDPTColor000(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTColor002(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTColor004(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome alpha channel:
    procedure RSDPTColor006(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Color of Curent Layer(Additive)}
    // (constant) not clipped:
    procedure RSDPTColor010(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTColor012(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTColor014(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSDPTColor016(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTColor011(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTColor013(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTColor015(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    // same as (constant)

    {Color of Curent Layer(Alphablend)}
    // (constant) not clipped:
    procedure RSDPTColor020(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTColor022(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTColor024(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {||scl_mul||>1: (SU - Scale Up  )} {$region -fold}

    {Empty}
    procedure RSUPTColor009(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Color of Curent Layer}
    // (constant) not clipped:
    procedure RSUPTColor000(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTColor002(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTColor004(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome alpha channel:
    procedure RSUPTColor006(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Color of Curent Layer(Additive)}
    // (constant) not clipped:
    procedure RSUPTColor010(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTColor012(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTColor014(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure RSUPTColor016(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTColor011(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTColor013(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTColor015(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) image has monochrome color channel:
    // same as (constant)

    {Color of Curent Layer(Alphablend)}
    // (constant) not clipped:
    procedure RSUPTColor020(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTColor022(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTColor024(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {$endregion}

    {Value} {$region -fold}

    {||scl_mul||=1:                  } {$region -fold}

    {Auxiliary procedures}
    // (constant) not clipped and top-bottom clipped:
    procedure RegPTProcA0  (      Proc19              :TProc19;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTProcB0  (      Proc8               :TProc8;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTProcA4  (      Proc19              :TProc19;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTProcB4  (      Proc8               :TProc8;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped and top-bottom clipped:
    procedure RegPTProcC0  (      Proc19              :TProc19;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTProcD0  (      Proc19              :TProc19;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegPTProcC4  (      Proc19              :TProc19;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTProcD4  (      Proc19              :TProc19;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped and top-bottom clipped:
    procedure RegPTProcE0  (      Proc18              :TProc18;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTProcE4  (      Proc18              :TProc18;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Empty}
    procedure RegPTValue009(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Monochrome}
    // (constant) auxiliary procedures:
    procedure RegPTValueA00(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB00(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue000(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueA04(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB04(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped :
    procedure RegPTValue004(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Additive}
    // (constant) auxiliary procedures:
    procedure RegPTValueA10(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB10(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue010(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueA14(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB14(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTValue014(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTValueA11(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB11(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue011(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTValueA15(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB15(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegPTValue015(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Alphablend}
    // (constant) auxiliary procedures:
    procedure RegPTValueA20(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB20(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue020(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueA24(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB24(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTValue024(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Inverse}
    // (constant) auxiliary procedures:
    procedure RegPTValueA30(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB30(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue030(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueA34(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB34(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTValue034(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTValueA31(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB31(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue031(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTValueA35(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB35(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegPTValue035(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Highlight}
    // (constant) auxiliary procedure:
    procedure RegPTValueB40(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue040(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedure:
    procedure RegPTValueB44(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTValue044(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Darken}
    // (constant) auxiliary procedures:
    procedure RegPTValueA50(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB50(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue050(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueA54(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB54(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTValue054(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleR}
    // (constant) auxiliary procedures:
    procedure RegPTValueA60(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB60(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue060(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueA64(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB64(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTValue064(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTValueA61(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB61(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue061(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTValueA65(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB65(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegPTValue065(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {GrayscaleG}
    // (constant) auxiliary procedures:
    procedure RegPTValueA70(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB70(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue070(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueA74(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB74(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTValue074(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTValueA71(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB71(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue071(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTValueA75(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB75(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegPTValue075(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {GrayscaleB}
    // (constant) auxiliary procedures:
    procedure RegPTValueA80(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB80(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue080(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueA84(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB84(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTValue084(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTValueA81(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB81(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue081(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTValueA85(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB85(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegPTValue085(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Monochrome Noise}
    // (constant) auxiliary procedures:
    procedure RegPTValueA90(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB90(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue090(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueA94(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB94(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTValue094(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTValueA91(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB91(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue091(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) auxiliary procedures:
    procedure RegPTValueA95(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueB95(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegPTValue095(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {ColorizeR}
    // (constant) auxiliary procedures:
    procedure RegPTValueC00(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueD00(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue100(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueC04(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueD04(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTValue104(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeG}
    // (constant) auxiliary procedures:
    procedure RegPTValueC10(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueD10(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue110(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueC14(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueD14(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTValue114(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeB}
    // (constant) auxiliary procedures:
    procedure RegPTValueC20(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueD20(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue120(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueC24(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueD24(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTValue124(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGB}
    // (constant) not clipped:
    procedure RegPTValue130(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTValue134(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue131(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegPTValue135(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRRB}
    // (constant) not clipped:
    procedure RegPTValue140(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTValue144(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue141(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegPTValue145(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRGR}
    // (constant) not clipped:
    procedure RegPTValue150(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTValue154(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue151(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegPTValue155(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurGGB}
    // (constant) not clipped:
    procedure RegPTValue160(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTValue164(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue161(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegPTValue165(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRGG}
    // (constant) not clipped:
    procedure RegPTValue170(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTValue174(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue171(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegPTValue175(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurBGB}
    // (constant) not clipped:
    procedure RegPTValue180(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTValue184(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue181(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegPTValue185(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRBB}
    // (constant) not clipped:
    procedure RegPTValue190(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTValue194(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue191(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegPTValue195(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRRR}
    // (constant) not clipped:
    procedure RegPTValue200(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTValue204(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue201(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegPTValue205(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurGGG}
    // (constant) not clipped:
    procedure RegPTValue210(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTValue214(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue211(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegPTValue215(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurBBB}
    // (constant) not clipped:
    procedure RegPTValue220(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTValue224(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RegPTValue221(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RegPTValue225(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Contrast}
    // (constant) auxiliary procedures:
    procedure RegPTValueE30(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueF30(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure RegPTValue230(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure RegPTValueE34(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure RegPTValueF34(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RegPTValue234(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {||scl_mul||<1: (SD - Scale Down)} {$region -fold}

    {Empty}
    procedure RSDPTValue009(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Monochrome}
    // (constant) not clipped:
    procedure RSDPTValue000(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTValue002(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTValue004(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTValue001(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTValue003(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTValue005(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Additive}
    // (constant) not clipped:
    procedure RSDPTValue010(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTValue012(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTValue014(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTValue011(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTValue013(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTValue015(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Alphablend}
    // (constant) not clipped:
    procedure RSDPTValue020(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTValue022(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTValue024(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTValue021(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTValue023(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTValue025(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Inverse}
    // (constant) not clipped:
    procedure RSDPTValue030(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTValue032(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTValue034(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTValue031(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTValue033(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTValue035(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Highlight}
    // (constant) not clipped:
    procedure RSDPTValue040(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTValue042(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTValue044(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTValue041(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTValue043(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTValue045(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Darken}
    // (constant) not clipped:
    procedure RSDPTValue050(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTValue052(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTValue054(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTValue051(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTValue053(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTValue055(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {GrayscaleR}
    // (constant) not clipped:
    procedure RSDPTValue060(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTValue062(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTValue064(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTValue061(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTValue063(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTValue065(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {GrayscaleG}
    // (constant) not clipped:
    procedure RSDPTValue070(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTValue072(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTValue074(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTValue071(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTValue073(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTValue075(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {GrayscaleB}
    // (constant) not clipped:
    procedure RSDPTValue080(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTValue082(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTValue084(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTValue081(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTValue083(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTValue085(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Monochrome Noise}
    // (constant) not clipped:
    procedure RSDPTValue090(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTValue092(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTValue094(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTValue091(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTValue093(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTValue095(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {ColorizeR}
    // (constant) not clipped:
    procedure RSDPTValue100(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTValue102(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTValue104(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTValue101(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTValue103(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTValue105(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {ColorizeG}
    // (constant) not clipped:
    procedure RSDPTValue110(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTValue112(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTValue114(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTValue111(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTValue113(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTValue115(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {ColorizeB}
    // (constant) not clipped:
    procedure RSDPTValue120(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTValue122(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTValue124(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTValue121(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTValue123(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTValue125(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRGB}
    // (constant) not clipped:
    procedure RSDPTValue130(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTValue132(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTValue134(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTValue131(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTValue133(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTValue135(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRRB}
    // (constant) not clipped:
    procedure RSDPTValue140(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTValue142(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTValue144(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTValue141(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTValue143(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTValue145(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRGR}
    // (constant) not clipped:
    procedure RSDPTValue150(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTValue152(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTValue154(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTValue151(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTValue153(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTValue155(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurGGB}
    // (constant) not clipped:
    procedure RSDPTValue160(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTValue162(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTValue164(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTValue161(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTValue163(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTValue165(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRGG}
    // (constant) not clipped:
    procedure RSDPTValue170(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTValue172(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTValue174(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTValue171(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTValue173(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTValue175(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurBGB}
    // (constant) not clipped:
    procedure RSDPTValue180(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTValue182(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTValue184(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTValue181(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTValue183(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTValue185(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRBB}
    // (constant) not clipped:
    procedure RSDPTValue190(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTValue192(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTValue194(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTValue191(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTValue193(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTValue195(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRRR}
    // (constant) not clipped:
    procedure RSDPTValue200(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTValue202(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTValue204(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTValue201(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTValue203(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTValue205(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurGGG}
    // (constant) not clipped:
    procedure RSDPTValue210(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTValue212(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTValue214(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTValue211(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTValue213(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTValue215(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurBBB}
    // (constant) not clipped:
    procedure RSDPTValue220(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTValue222(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTValue224(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTValue221(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTValue223(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTValue225(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Contrast}
    // (constant) not clipped:
    procedure RSDPTValue230(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSDPTValue232(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSDPTValue234(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSDPTValue231(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSDPTValue233(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSDPTValue235(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {$endregion}

    {||scl_mul||>1: (SU - Scale Up  )} {$region -fold}

    {Empty}
    procedure RSUPTValue009(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Monochrome}
    // (constant) not clipped:
    procedure RSUPTValue000(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTValue002(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTValue004(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTValue001(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTValue003(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTValue005(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Additive}
    // (constant) not clipped:
    procedure RSUPTValue010(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTValue012(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTValue014(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTValue011(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTValue013(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTValue015(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Alphablend}
    // (constant) not clipped:
    procedure RSUPTValue020(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTValue022(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTValue024(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTValue021(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTValue023(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTValue025(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Inverse}
    // (constant) not clipped:
    procedure RSUPTValue030(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTValue032(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTValue034(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTValue031(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTValue033(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTValue035(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Highlight}
    // (constant) not clipped:
    procedure RSUPTValue040(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTValue042(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTValue044(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTValue041(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTValue043(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTValue045(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Darken}
    // (constant) not clipped:
    procedure RSUPTValue050(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTValue052(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTValue054(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTValue051(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTValue053(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTValue055(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {GrayscaleR}
    // (constant) not clipped:
    procedure RSUPTValue060(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTValue062(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTValue064(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTValue061(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTValue063(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTValue065(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {GrayscaleG}
    // (constant) not clipped:
    procedure RSUPTValue070(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTValue072(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTValue074(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTValue071(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTValue073(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTValue075(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}


    {GrayscaleB}
    // (constant) not clipped:
    procedure RSUPTValue080(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTValue082(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTValue084(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTValue081(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTValue083(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTValue085(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Monochrome Noise}
    // (constant) not clipped:
    procedure RSUPTValue090(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTValue092(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTValue094(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTValue091(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTValue093(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTValue095(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {ColorizeR}
    // (constant) not clipped:
    procedure RSUPTValue100(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTValue102(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTValue104(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTValue101(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTValue103(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTValue105(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {ColorizeG}
    // (constant) not clipped:
    procedure RSUPTValue110(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTValue112(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTValue114(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTValue111(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTValue113(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTValue115(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {ColorizeB}
    // (constant) not clipped:
    procedure RSUPTValue120(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTValue122(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTValue124(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTValue121(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTValue123(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTValue125(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRGB}
    // (constant) not clipped:
    procedure RSUPTValue130(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTValue132(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTValue134(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTValue131(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTValue133(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTValue135(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRRB}
    // (constant) not clipped:
    procedure RSUPTValue140(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTValue142(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTValue144(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTValue141(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTValue143(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTValue145(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRGR}
    // (constant) not clipped:
    procedure RSUPTValue150(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTValue152(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTValue154(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTValue151(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTValue153(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTValue155(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurGGB}
    // (constant) not clipped:
    procedure RSUPTValue160(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTValue162(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTValue164(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTValue161(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTValue163(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTValue165(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRGG}
    // (constant) not clipped:
    procedure RSUPTValue170(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTValue172(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTValue174(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTValue171(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTValue173(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTValue175(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurBGB}
    // (constant) not clipped:
    procedure RSUPTValue180(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTValue182(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTValue184(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTValue181(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTValue183(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTValue185(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRBB}
    // (constant) not clipped:
    procedure RSUPTValue190(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTValue192(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTValue194(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTValue191(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTValue193(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTValue195(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurRRR}
    // (constant) not clipped:
    procedure RSUPTValue200(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTValue202(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTValue204(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTValue201(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTValue203(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTValue205(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurGGG}
    // (constant) not clipped:
    procedure RSUPTValue210(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTValue212(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTValue214(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTValue211(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTValue213(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTValue215(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {BlurBBB}
    // (constant) not clipped:
    procedure RSUPTValue220(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTValue222(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTValue224(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTValue221(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTValue223(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTValue225(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Contrast}
    // (constant) not clipped:
    procedure RSUPTValue230(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure RSUPTValue232(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure RSUPTValue234(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) not clipped:
    procedure RSUPTValue231(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) top-bottom clipped:
    procedure RSUPTValue233(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading) left-right-top-bottom clipped:
    procedure RSUPTValue235(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {$endregion}

    {$endregion}

    {Noise} {$region -fold}

    {TODO}

    {$endregion}

    {$endregion}

    {Gradient FloodFill(Vertical)--------------------------} {$region -fold}

    // NT - not transparent pixels:

    {Auxiliary procedures}
    procedure GrVNTResVar0 (const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData); inline; {$ifdef Linux}[local];{$endif}

    {Color} {$region -fold}

    {||scl_mul||=1:                  } {$region -fold}

    {Empty}
    procedure GrVNTColor009(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Color of Curent Layer(Additive)}
    // (constant) auxiliary procedure:
    procedure GrVNTColor010(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTColor014(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTColor016(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Color of Curent Layer(AlphaBlend)}
    // (constant) auxiliary procedure:
    procedure GrVNTColor020(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTColor024(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTColor026(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {||scl_mul||<1: (SD - Scale Down)} {$region -fold}

    {Empty}
    procedure GSDNTColor009(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Color of Curent Layer(Additive)}
    // (constant) not clipped:
    procedure GSDNTColor010(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTColor012(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTColor014(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTColor016(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Color of Curent Layer(Alphablend)}
    // (constant) not clipped:
    procedure GSDNTColor020(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTColor022(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTColor024(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTColor026(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {||scl_mul||>1: (SU - Scale Up  )} {$region -fold}

    {Empty}
    procedure GSUNTColor009(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Color of Curent Layer(Additive)}
    // (constant) not clipped:
    procedure GSUNTColor010(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTColor012(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTColor014(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTColor016(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Color of Curent Layer(Alphablend)}
    // (constant) not clipped:
    procedure GSUNTColor020(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTColor022(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTColor024(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTColor026(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {$endregion}

    {Value} {$region -fold}

    {||scl_mul||=1:                  } {$region -fold}

    {Auxiliary procedures}
    // (constant) not clipped and top-bottom clipped:
    procedure GrVNTValueA0 (      Proc16              :TProc16;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValueA4 (      Proc16              :TProc16;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped and top-bottom clipped:
    procedure GrVNTValueB0 (      Proc17              :TProc17;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValueB4 (      Proc17              :TProc17;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped and top-bottom clipped:
    procedure GrVNTValueC0 (      Proc18              :TProc18;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValueC4 (      Proc18              :TProc18;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped and top-bottom clipped:
    procedure GrVNTValueD0 (      Proc19              :TProc19;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValueD4 (      Proc19              :TProc19;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Empty}
    procedure GrVNTValue009(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Monochrome}
    // (constant) auxiliary procedure:
    procedure GrVNTValueA00(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVNTValue000(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValueA04(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVNTValue004(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue006(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Additive}
    // (constant) auxiliary procedure:
    procedure GrVNTValue010(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValue014(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue016(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {AlphaBlend}
    // (constant) auxiliary procedure:
    procedure GrVNTValue020(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValue024(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue026(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Inverse}
    // (constant) auxiliary procedure:
    procedure GrVNTValue030(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValue034(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue036(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Highlight}
    // (constant) not clipped:
    procedure GrVNTValue040(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValue044(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue046(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Darken}
    // (constant) not clipped:
    procedure GrVNTValue050(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValue054(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue056(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleR}
    // (constant) not clipped:
    procedure GrVNTValue060(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValue064(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue066(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleG}
    // (constant) not clipped:
    procedure GrVNTValue070(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValue074(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue076(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleB}
    // (constant) not clipped:
    procedure GrVNTValue080(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValue084(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue086(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Monochrome Noise}
    // (constant) auxiliary procedure:
    procedure GrVNTValue090(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValue094(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue096(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeR}
    // (constant) not clipped:
    procedure GrVNTValue100(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValue104(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue106(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeG}
    // (constant) not clipped:
    procedure GrVNTValue110(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValue114(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue116(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeB}
    // (constant) not clipped:
    procedure GrVNTValue120(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValue124(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue126(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGB}
    // (constant) not clipped:
    procedure GrVNTValue130(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValue134(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue136(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRRB}
    // (constant) not clipped:
    procedure GrVNTValue140(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValue144(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue146(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGR}
    // (constant) not clipped:
    procedure GrVNTValue150(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValue154(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue156(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurGGB}
    // (constant) not clipped:
    procedure GrVNTValue160(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValue164(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue166(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGG}
    // (constant) not clipped:
    procedure GrVNTValue170(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValue174(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue176(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurBGB}
    // (constant) not clipped:
    procedure GrVNTValue180(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValue184(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue186(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRBB}
    // (constant) not clipped:
    procedure GrVNTValue190(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValue194(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue196(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRRR}
    // (constant) not clipped:
    procedure GrVNTValue200(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValue204(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue206(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurGGG}
    // (constant) not clipped:
    procedure GrVNTValue210(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValue214(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue216(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurBBB}
    // (constant) not clipped:
    procedure GrVNTValue220(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValue224(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue226(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Contrast}
    // (constant) auxiliary procedure:
    procedure GrVNTValue230(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVNTValue234(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GrVNTValue236(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {||scl_mul||<1: (SD - Scale Down)} {$region -fold}

    {Empty}
    procedure GSDNTValue009(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Monochrome}
    // (constant) not clipped:
    procedure GSDNTValue000(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTValue002(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTValue004(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTValue006(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Additive}
    // (constant) not clipped:
    procedure GSDNTValue010(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTValue012(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTValue014(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTValue016(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Alphablend}
    // (constant) not clipped:
    procedure GSDNTValue020(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTValue022(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTValue024(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTValue026(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Inverse}
    // (constant) not clipped:
    procedure GSDNTValue030(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTValue032(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTValue034(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTValue036(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Highlight}
    // (constant) not clipped:
    procedure GSDNTValue040(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTValue042(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTValue044(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTValue046(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Darken}
    // (constant) not clipped:
    procedure GSDNTValue050(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTValue052(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTValue054(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTValue056(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleR}
    // (constant) not clipped:
    procedure GSDNTValue060(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTValue062(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTValue064(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTValue066(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleG}
    // (constant) not clipped:
    procedure GSDNTValue070(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTValue072(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTValue074(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTValue076(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleB}
    // (constant) not clipped:
    procedure GSDNTValue080(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTValue082(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTValue084(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTValue086(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Monochrome Noise}
    // (constant) not clipped:
    procedure GSDNTValue090(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTValue092(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTValue094(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTValue096(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeR}
    // (constant) not clipped:
    procedure GSDNTValue100(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTValue102(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTValue104(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTValue106(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeG}
    // (constant) not clipped:
    procedure GSDNTValue110(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTValue112(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTValue114(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTValue116(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeB}
    // (constant) not clipped:
    procedure GSDNTValue120(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTValue122(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTValue124(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTValue126(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGB}
    // (constant) not clipped:
    procedure GSDNTValue130(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTValue132(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTValue134(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTValue136(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRRB}
    // (constant) not clipped:
    procedure GSDNTValue140(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTValue142(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTValue144(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTValue146(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGR}
    // (constant) not clipped:
    procedure GSDNTValue150(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTValue152(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTValue154(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTValue156(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurGGB}
    // (constant) not clipped:
    procedure GSDNTValue160(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTValue162(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTValue164(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTValue166(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGG}
    // (constant) not clipped:
    procedure GSDNTValue170(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTValue172(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTValue174(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTValue176(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurBGB}
    // (constant) not clipped:
    procedure GSDNTValue180(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTValue182(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTValue184(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTValue186(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRBB}
    // (constant) not clipped:
    procedure GSDNTValue190(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTValue192(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTValue194(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTValue196(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRRR}
    // (constant) not clipped:
    procedure GSDNTValue200(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTValue202(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTValue204(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTValue206(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurGGG}
    // (constant) not clipped:
    procedure GSDNTValue210(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTValue212(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTValue214(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTValue216(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurBBB}
    // (constant) not clipped:
    procedure GSDNTValue220(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTValue222(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTValue224(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTValue226(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Contrast}
    // (constant) not clipped:
    procedure GSDNTValue230(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDNTValue232(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDNTValue234(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSDNTValue236(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {||scl_mul||>1: (SU - Scale Up  )} {$region -fold}

    {Empty}
    procedure GSUNTValue009(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Monochrome}
    // (constant) not clipped:
    procedure GSUNTValue000(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTValue002(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTValue004(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTValue006(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Additive}
    // (constant) not clipped:
    procedure GSUNTValue010(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTValue012(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTValue014(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTValue016(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Alphablend}
    // (constant) not clipped:
    procedure GSUNTValue020(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTValue022(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTValue024(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTValue026(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Inverse}
    // (constant) not clipped:
    procedure GSUNTValue030(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTValue032(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTValue034(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTValue036(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Highlight}
    // (constant) not clipped:
    procedure GSUNTValue040(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTValue042(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTValue044(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTValue046(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Darken}
    // (constant) not clipped:
    procedure GSUNTValue050(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTValue052(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTValue054(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTValue056(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleR}
    // (constant) not clipped:
    procedure GSUNTValue060(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTValue062(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTValue064(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTValue066(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleG}
    // (constant) not clipped:
    procedure GSUNTValue070(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTValue072(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTValue074(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTValue076(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleB}
    // (constant) not clipped:
    procedure GSUNTValue080(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTValue082(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTValue084(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTValue086(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Monochrome Noise}
    // (constant) not clipped:
    procedure GSUNTValue090(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTValue092(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTValue094(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTValue096(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeR}
    // (constant) not clipped:
    procedure GSUNTValue100(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTValue102(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTValue104(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTValue106(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeG}
    // (constant) not clipped:
    procedure GSUNTValue110(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTValue112(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTValue114(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTValue116(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeB}
    // (constant) not clipped:
    procedure GSUNTValue120(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTValue122(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTValue124(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTValue126(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGB}
    // (constant) not clipped:
    procedure GSUNTValue130(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTValue132(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTValue134(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTValue136(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRRB}
    // (constant) not clipped:
    procedure GSUNTValue140(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTValue142(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTValue144(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTValue146(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGR}
    // (constant) not clipped:
    procedure GSUNTValue150(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTValue152(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTValue154(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTValue156(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurGGB}
    // (constant) not clipped:
    procedure GSUNTValue160(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTValue162(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTValue164(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTValue166(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGG}
    // (constant) not clipped:
    procedure GSUNTValue170(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTValue172(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTValue174(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTValue176(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurBGB}
    // (constant) not clipped:
    procedure GSUNTValue180(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTValue182(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTValue184(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTValue186(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRBB}
    // (constant) not clipped:
    procedure GSUNTValue190(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTValue192(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTValue194(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTValue196(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRRR}
    // (constant) not clipped:
    procedure GSUNTValue200(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTValue202(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTValue204(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTValue206(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurGGG}
    // (constant) not clipped:
    procedure GSUNTValue210(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTValue212(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTValue214(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTValue216(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurBBB}
    // (constant) not clipped:
    procedure GSUNTValue220(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTValue222(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTValue224(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTValue226(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Contrast}
    // (constant) not clipped:
    procedure GSUNTValue230(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUNTValue232(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUNTValue234(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) image has monochrome color channel:
    procedure GSUNTValue236(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {$endregion}

    {Noise} {$region -fold}

    {TODO}

    {$endregion}

    // PT - partly transparent pixels:

    {Auxiliary procedures}
    procedure GrVPTResVar0 (const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData); inline; {$ifdef Linux}[local];{$endif}

    {Color} {$region -fold}

    {||scl_mul||=1:                  } {$region -fold}

    {Empty}
    procedure GrVPTColor009(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Color of Curent Layer(Additive)}
    // (constant) auxiliary procedures:
    procedure GrVPTColorA10(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVPTColorB10(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure GrVPTColor010(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure GrVPTColorA14(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVPTColorB14(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTColor014(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Color of Curent Layer(AlphaBlend)}
    // (constant) auxiliary procedures:
    procedure GrVPTColorA20(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVPTColorB20(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure GrVPTColor020(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedures:
    procedure GrVPTColorA24(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVPTColorB24(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTColor024(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {||scl_mul||<1: (SD - Scale Down)} {$region -fold}

    {Empty}
    procedure GSDPTColor009(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Color of Curent Layer(Additive)}
    // (constant) not clipped:
    procedure GSDPTColor010(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTColor012(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTColor014(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Color of Curent Layer(Alphablend)}
    // (constant) not clipped:
    procedure GSDPTColor020(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTColor022(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTColor024(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {||scl_mul||>1: (SU - Scale Up  )} {$region -fold}

    {Empty}
    procedure GSUPTColor009(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Color of Curent Layer(Additive)}
    // (constant) not clipped:
    procedure GSUPTColor010(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTColor012(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTColor014(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Color of Curent Layer(Alphablend)}
    // (constant) not clipped:
    procedure GSUPTColor020(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTColor022(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTColor024(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {$endregion}

    {Value} {$region -fold}

    {||scl_mul||=1:                  } {$region -fold}

    {Auxiliary procedures}
    // (constant) not clipped and top-bottom clipped:
    procedure GrVPTValueA0 (      Proc16              :TProc16;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueB0 (      Proc16              :TProc16;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValueA4 (      Proc16              :TProc16;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueB4 (      Proc16              :TProc16;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped and top-bottom clipped:
    procedure GrVPTValueC0 (      Proc17              :TProc17;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueD0 (      Proc17              :TProc17;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValueC4 (      Proc17              :TProc17;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueD4 (      Proc17              :TProc17;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped and top-bottom clipped:
    procedure GrVPTValueE0 (      Proc18              :TProc18;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueF0 (      Proc18              :TProc18;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValueE4 (      Proc18              :TProc18;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueF4 (      Proc18              :TProc18;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped and top-bottom clipped:
    procedure GrVPTValueG0 (      Proc19              :TProc19;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueH0 (      Proc19              :TProc19;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValueG4 (      Proc19              :TProc19;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueH4 (      Proc19              :TProc19;
                            const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Empty}
    procedure GrVPTValue009(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Monochrome}
    // (constant) auxiliary procedure:
    procedure GrVPTValueA00(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueB00(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure GrVPTValue000(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedure:
    procedure GrVPTValueA04(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueB04(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValue004(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Additive}
    // (constant) auxiliary procedure:
    procedure GrVPTValueA10(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueB10(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure GrVPTValue010(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedure:
    procedure GrVPTValueA14(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueB14(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValue014(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {AlphaBlend}
    // (constant) auxiliary procedure:
    procedure GrVPTValueA20(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueB20(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure GrVPTValue020(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedure:
    procedure GrVPTValueA24(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueB24(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValue024(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Inverse}
    // (constant) auxiliary procedure:
    procedure GrVPTValueA30(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueB30(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure GrVPTValue030(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedure:
    procedure GrVPTValueA34(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueB34(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValue034(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Highlight}
    // (constant) not clipped:
    procedure GrVPTValue040(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValue044(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Darken}
    // (constant) not clipped:
    procedure GrVPTValue050(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValue054(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleR}
    // (constant) not clipped:
    procedure GrVPTValue060(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValue064(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleG}
    // (constant) not clipped:
    procedure GrVPTValue070(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValue074(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleB}
    // (constant) not clipped:
    procedure GrVPTValue080(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValue084(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Monochrome Noise}
    // (constant) auxiliary procedure:
    procedure GrVPTValueA90(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueB90(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure GrVPTValue090(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedure:
    procedure GrVPTValueA94(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueB94(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValue094(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeR}
    // (constant) not clipped:
    procedure GrVPTValue100(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValue104(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeG}
    // (constant) not clipped:
    procedure GrVPTValue110(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValue114(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeB}
    // (constant) not clipped:
    procedure GrVPTValue120(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValue124(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGB}
    // (constant) not clipped:
    procedure GrVPTValue130(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValue134(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRRB}
    // (constant) not clipped:
    procedure GrVPTValue140(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValue144(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGR}
    // (constant) not clipped:
    procedure GrVPTValue150(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValue154(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurGGB}
    // (constant) not clipped:
    procedure GrVPTValue160(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValue164(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGG}
    // (constant) not clipped:
    procedure GrVPTValue170(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValue174(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurBGB}
    // (constant) not clipped:
    procedure GrVPTValue180(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValue184(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRBB}
    // (constant) not clipped:
    procedure GrVPTValue190(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValue194(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRRR}
    // (constant) not clipped:
    procedure GrVPTValue200(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValue204(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurGGG}
    // (constant) not clipped:
    procedure GrVPTValue210(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValue214(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurBBB}
    // (constant) not clipped:
    procedure GrVPTValue220(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValue224(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Contrast}
    // (constant) auxiliary procedure:
    procedure GrVPTValueI30(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueJ30(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) not clipped:
    procedure GrVPTValue230(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) auxiliary procedure:
    procedure GrVPTValueI34(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    procedure GrVPTValueJ34(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GrVPTValue234(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {||scl_mul||<1: (SD - Scale Down)} {$region -fold}

    {Empty}
    procedure GSDPTValue009(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Monochrome}
    // (constant) not clipped:
    procedure GSDPTValue000(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTValue002(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTValue004(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Additive}
    // (constant) not clipped:
    procedure GSDPTValue010(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTValue012(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTValue014(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Alphablend}
    // (constant) not clipped:
    procedure GSDPTValue020(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTValue022(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTValue024(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Inverse}
    // (constant) not clipped:
    procedure GSDPTValue030(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTValue032(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTValue034(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Highlight}
    // (constant) not clipped:
    procedure GSDPTValue040(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTValue042(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTValue044(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Darken}
    // (constant) not clipped:
    procedure GSDPTValue050(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTValue052(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTValue054(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleR}
    // (constant) not clipped:
    procedure GSDPTValue060(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTValue062(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTValue064(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleG}
    // (constant) not clipped:
    procedure GSDPTValue070(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTValue072(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTValue074(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleB}
    // (constant) not clipped:
    procedure GSDPTValue080(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTValue082(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTValue084(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Monochrome Noise}
    // (constant) not clipped:
    procedure GSDPTValue090(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTValue092(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTValue094(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeR}
    // (constant) not clipped:
    procedure GSDPTValue100(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTValue102(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTValue104(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeG}
    // (constant) not clipped:
    procedure GSDPTValue110(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTValue112(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTValue114(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeB}
    // (constant) not clipped:
    procedure GSDPTValue120(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTValue122(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTValue124(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGB}
    // (constant) not clipped:
    procedure GSDPTValue130(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTValue132(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTValue134(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRRB}
    // (constant) not clipped:
    procedure GSDPTValue140(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTValue142(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTValue144(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGR}
    // (constant) not clipped:
    procedure GSDPTValue150(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTValue152(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTValue154(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurGGB}
    // (constant) not clipped:
    procedure GSDPTValue160(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTValue162(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTValue164(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGG}
    // (constant) not clipped:
    procedure GSDPTValue170(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTValue172(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTValue174(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurBGB}
    // (constant) not clipped:
    procedure GSDPTValue180(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTValue182(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTValue184(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRBB}
    // (constant) not clipped:
    procedure GSDPTValue190(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTValue192(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTValue194(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRRR}
    // (constant) not clipped:
    procedure GSDPTValue200(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTValue202(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTValue204(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurGGG}
    // (constant) not clipped:
    procedure GSDPTValue210(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTValue212(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTValue214(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurBBB}
    // (constant) not clipped:
    procedure GSDPTValue220(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTValue222(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTValue224(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Contrast}
    // (constant) not clipped:
    procedure GSDPTValue230(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSDPTValue232(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSDPTValue234(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {||scl_mul||>1: (SU - Scale Up  )} {$region -fold}

    {Empty}
    procedure GSUPTValue009(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}

    {Monochrome}
    // (constant) not clipped:
    procedure GSUPTValue000(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTValue002(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTValue004(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Additive}
    // (constant) not clipped:
    procedure GSUPTValue010(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTValue012(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTValue014(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Alphablend}
    // (constant) not clipped:
    procedure GSUPTValue020(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTValue022(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTValue024(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Inverse}
    // (constant) not clipped:
    procedure GSUPTValue030(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTValue032(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTValue034(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Highlight}
    // (constant) not clipped:
    procedure GSUPTValue040(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTValue042(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTValue044(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Darken}
    // (constant) not clipped:
    procedure GSUPTValue050(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTValue052(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTValue054(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleR}
    // (constant) not clipped:
    procedure GSUPTValue060(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTValue062(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTValue064(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleG}
    // (constant) not clipped:
    procedure GSUPTValue070(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTValue072(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTValue074(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {GrayscaleB}
    // (constant) not clipped:
    procedure GSUPTValue080(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTValue082(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTValue084(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Monochrome Noise}
    // (constant) not clipped:
    procedure GSUPTValue090(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTValue092(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTValue094(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeR}
    // (constant) not clipped:
    procedure GSUPTValue100(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTValue102(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTValue104(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeG}
    // (constant) not clipped:
    procedure GSUPTValue110(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTValue112(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTValue114(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {ColorizeB}
    // (constant) not clipped:
    procedure GSUPTValue120(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTValue122(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTValue124(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGB}
    // (constant) not clipped:
    procedure GSUPTValue130(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTValue132(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTValue134(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRRB}
    // (constant) not clipped:
    procedure GSUPTValue140(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTValue142(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTValue144(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGR}
    // (constant) not clipped:
    procedure GSUPTValue150(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTValue152(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTValue154(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurGGB}
    // (constant) not clipped:
    procedure GSUPTValue160(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTValue162(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTValue164(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRGG}
    // (constant) not clipped:
    procedure GSUPTValue170(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTValue172(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTValue174(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurBGB}
    // (constant) not clipped:
    procedure GSUPTValue180(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTValue182(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTValue184(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRBB}
    // (constant) not clipped:
    procedure GSUPTValue190(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTValue192(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTValue194(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurRRR}
    // (constant) not clipped:
    procedure GSUPTValue200(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTValue202(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTValue204(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurGGG}
    // (constant) not clipped:
    procedure GSUPTValue210(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTValue212(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTValue214(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {BlurBBB}
    // (constant) not clipped:
    procedure GSUPTValue220(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTValue222(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTValue224(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {Contrast}
    // (constant) not clipped:
    procedure GSUPTValue230(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) top-bottom clipped:
    procedure GSUPTValue232(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (constant) left-right-top-bottom clipped:
    procedure GSUPTValue234(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData);         {$ifdef Linux}[local];{$endif}
    // (fading):
    // same;

    {$endregion}

    {$endregion}

    {Noise} {$region -fold}

    {TODO}

    {$endregion}

    {$endregion}

    {Fill Array at Specified Rectangle with Specified Value} {$region -fold}
    // NT - not transparent pixels:
    procedure FilNTValueArrA(var      arr_src         :TColorArr;
                             const    bmp_ftimg_width_:TColor;
                             const    val             :TColor=0); {$ifdef Linux}[local];{$endif}
    procedure FilNTValueArrB(var      arr_src         :T1Byte1Arr;
                             const    bmp_ftimg_width_:TColor;
                             const    val             :byte=0);   {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure FilPTValueArrA(var      arr_src         :TColorArr;
                             const    bmp_ftimg_width_:TColor;
                             const    val             :TColor=0); {$ifdef Linux}[local];{$endif}
    procedure FilPTValueArrB(var      arr_src         :T1Byte1Arr;
                             const    bmp_ftimg_width_:TColor;
                             const    val             :byte=0);   {$ifdef Linux}[local];{$endif}
    procedure FilPTValueArrC;                                     {$ifdef Linux}[local];{$endif}
    procedure FilPTValueArrD;                                     {$ifdef Linux}[local];{$endif}
    procedure FilPTValueArrE;                                     {$ifdef Linux}[local];{$endif}
    procedure FilPTValueArrF;                                     {$ifdef Linux}[local];{$endif}
    procedure FilPTValueArrG;                                     {$ifdef Linux}[local];{$endif}
    procedure FilPTValueArrH;                                     {$ifdef Linux}[local];{$endif}
    procedure FilPTValueArrI;                                     {$ifdef Linux}[local];{$endif}
    procedure FilPTValueArrJ;                                     {$ifdef Linux}[local];{$endif}
    procedure FilPTValueArrK;                                     {$ifdef Linux}[local];{$endif}
    procedure FilPTValueArrL;                                     {$ifdef Linux}[local];{$endif}
    procedure FilPTValueArrM;                                     {$ifdef Linux}[local];{$endif}
    procedure FilPTValueArrN;                                     {$ifdef Linux}[local];{$endif}
    {$endregion}

    {Restore Source Image from Compressed Image------------} {$region -fold}
    // NT - not transparent pixels:
    procedure ResNTValueArr(var   arr_src         :TColorArr;
                            const bmp_ftimg_width_:TColor); {$ifdef Linux}[local];{$endif}
    // PT - partly transparent pixels:
    procedure ResPTValueArr(var   arr_src         :TColorArr;
                            const bmp_ftimg_width_:TColor); {$ifdef Linux}[local];{$endif}
    {$endregion}

    {Misc. Init Proc.--------------------------------------} {$region -fold}

    // Check NTValueArr:
    function  ChkNTValueArr: boolean; inline; {$ifdef Linux}[local];{$endif}

    // NT - not transparent pixels:
    procedure SetNTNilToPtr(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData); inline; {$ifdef Linux}[local];{$endif}
    procedure SetNTCCLToPtr(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData); inline; {$ifdef Linux}[local];{$endif}
    procedure SetNTCLLToPtr(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData); inline; {$ifdef Linux}[local];{$endif}

    // PT - partly transparent pixels:
    procedure SetPTNilToPtr(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData); inline; {$ifdef Linux}[local];{$endif}
    procedure SetPTCCLToPtr(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData); inline; {$ifdef Linux}[local];{$endif}
    procedure SetPTCLLToPtr(const fast_image_data_ptr_:PFastImageData;
                            var   fast_image_data_    :TFastImageData); inline; {$ifdef Linux}[local];{$endif}

    // Procedures Table Init.:
    procedure FilProcInit;                    {$ifdef Linux}[local];{$endif}

    // Table of Counts Vertically Init.(Image Clipping):
    procedure CrtNTCntIndArr;                 {$ifdef Linux}[local];{$endif}
    procedure CrtPTCntIndArr;                 {$ifdef Linux}[local];{$endif}

    {$endregion}

    {Tile Map Drawing--------------------------------------} {$region -fold}

    // ...
    function GetArrCellInd(const x,y:double ): TPtPos; inline; {$ifdef Linux}[local];{$endif}
    function GetArrCellInd(const x,y:integer): TPtPos; inline; {$ifdef Linux}[local];{$endif}
    // Fill Tile Map With Random Color:
    procedure FilTileMap0; {$ifdef Linux}[local];{$endif}
    // Fill Tile Map With Specified Sprite:
    procedure FilTileMap1; {$ifdef Linux}[local];{$endif}
    // Fill Tile Map With Rectangles(Empty):
    procedure FilTileMap2; {$ifdef Linux}[local];{$endif}
    // Fill Tile Map With Rectangles(FloodFill):
    procedure FilTileMap3; {$ifdef Linux}[local];{$endif}

    {$endregion}

    {Full CSR-Image Drawing--------------------------------} {$region -fold}

    procedure SetPartVal (      fx                  :TFXInfo);        inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrAnimCng (      nt,pt               :boolean;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrTypeCng (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure ShaderInfo ;                                            inline;            {$ifdef Linux}[local];{$endif}
    procedure SetSdrType (var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrTypeInit;                                            inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType000 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType001 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType002 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType003 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType004 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType005 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType006 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType007 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType008 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType009 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType010 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType011 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType012 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType013 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType014 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType015 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType016 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType017 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType018 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType019 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType020 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType021 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType022 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType023 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType024 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType025 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType026 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType027 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType028 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType029 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType030 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrType031 (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure ShaderType (const fast_image_data_ptr_:PFastImageData;
                          var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    // Set Sprite Bounding Rectangle:
    procedure SRIProcInit;                                            inline;            {$ifdef Linux}[local];{$endif}
    procedure SetRctInv0 (var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SetRctInv1 (var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SetRctInv2 (var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure SetRctInv3 (var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    // Reset Sprite Bounding Rectangle:
    procedure RRIProcInit;                                            inline;            {$ifdef Linux}[local];{$endif}
    procedure ResRctInv0 (var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure ResRctInv1 (var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure ResRctInv2 (var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    procedure ResRctInv3 (var   fast_image_data_    :TFastImageData); inline;            {$ifdef Linux}[local];{$endif}
    // CPU Shader Proc.:
    procedure SdrProcInit;                                            inline;            {$ifdef Linux}[local];{$endif}
    procedure SdrProcInd (var   fast_image_data_    :TFastImageData);                    {$ifdef Linux}[local];{$endif}
    procedure UberShader0(const x,y                 :integer;
                          const fast_image_data_ptr_:PFastImageData;
                          const index               :PtrInt =0;
                          const block_count         :integer=1);                         {$ifdef Linux}[local];{$endif}
    procedure UberShader1(const x,y                 :integer;
                          const fast_image_data_ptr_:PFastImageData;
                          const index               :PtrInt =0;
                          const block_count         :integer=1);                         {$ifdef Linux}[local];{$endif}
    procedure UberShader2(const x,y                 :integer;
                          const fast_image_data_ptr_:PFastImageData;
                          const index               :PtrInt =0;
                          const block_count         :integer=1);                         {$ifdef Linux}[local];{$endif}
    procedure UberShader3(const x,y                 :integer;
                          const fast_image_data_ptr_:PFastImageData;
                          const index               :PtrInt =0;
                          const block_count         :integer=1);                         {$ifdef Linux}[local];{$endif}
    procedure UberShader4(const x,y                 :integer;
                          const fast_image_data_ptr_:PFastImageData;
                          const index               :PtrInt =0;
                          const block_count         :integer=1);                         {$ifdef Linux}[local];{$endif}
    procedure UberShader5(const x,y                 :integer;
                          const fast_image_data_ptr_:PFastImageData;
                          const index               :PtrInt =0;
                          const block_count         :integer=1);                         {$ifdef Linux}[local];{$endif}
    procedure UberShader6(const x,y                 :integer;
                          const fast_image_data_ptr_:PFastImageData;
                          const index               :PtrInt =0;
                          const block_count         :integer=1);                         {$ifdef Linux}[local];{$endif}
    procedure UberShader7(const x,y                 :integer;
                          const fast_image_data_ptr_:PFastImageData;
                          const index               :PtrInt =0;
                          const block_count         :integer=1);                         {$ifdef Linux}[local];{$endif}
    procedure UberShader8(const pt_arr_ptr          :PPtPosF;
                          const sprites_cnt,
                                w_a_s_x,
                                w_a_s_y             :integer;
                          const block_count         :integer=1);      virtual; abstract; {$ifdef Linux}[local];{$endif}
    procedure UberShader9(const pt_arr_ptr          :PPtPosF;
                          const sprites_cnt,
                                w_a_s_x,
                                w_a_s_y             :integer;
                          const block_count         :integer=1);      virtual; abstract; {$ifdef Linux}[local];{$endif}

    // Clear Background from Image:
    procedure ClrBkgnd; inline; {$ifdef Linux}[local];{$endif}

    {$endregion}

    {CSR-Image Anti-Aliasing-------------------------------} {$region -fold}
    procedure CrtBorderBmp(const arr_src      :TColorArr;
                           var   arr_dst      :TObjSelArr;
                           const arr_src_width,
                                 arr_dst_width:TColor;
                           const rect_left,
                                 rect_top,
                                 rect_width,
                                 rect_height  :TColor;
                           var   brdr_pix_cnt :TColor;
                           const obj_kind,
                                 obj_id       :TColor);  {$ifdef Linux}[local];{$endif}
    procedure BorderCalc1 (const arr_src      :TColorArr;
                           var   arr_dst      :T1Byte1Arr;
                           const arr_src_width,
                                 arr_dst_width:TColor;
                           const rct_dst_     :TPtRect); {$ifdef Linux}[local];{$endif}
    procedure BorderCalc2 (const arr_src      :TColorArr;
                           var   arr_dst      :T1Byte1Arr;
                           var   arr_alpha    :TAALnArr;
                           const arr_src_width,
                                 arr_dst_width:TColor;
                           const rct_dst_     :TPtRect;
                           out   line_cnt     :TColor);  {$ifdef Linux}[local];{$endif}
    {$endregion}

    {$endregion}

    {CSR-Image Clipping------------------------------------} {$region -fold}
    procedure UlsProcInit;                                                   {$ifdef Linux}[local];{$endif}
    procedure NTUseless0    (var   arr_dst         :TColorArr;
                             const arr_dst_width   :TColor;
                             const val             :TColor);                 {$ifdef Linux}[local];{$endif}
    procedure NTUseless1    (var   arr_dst         :TColorArr;
                             const arr_dst_width   :TColor;
                             const val             :TColor);                 {$ifdef Linux}[local];{$endif}
    procedure NTUseless2    (var   arr_dst         :TColorArr;
                             const arr_dst_width   :TColor;
                             const val             :TColor);                 {$ifdef Linux}[local];{$endif}
    procedure PTUseless0    (var   arr_dst         :TColorArr;
                             const arr_dst_width   :TColor;
                             const val             :TColor);                 {$ifdef Linux}[local];{$endif}
    procedure PTUseless1    (var   arr_dst         :TColorArr;
                             const arr_dst_width   :TColor;
                             const val             :TColor);                 {$ifdef Linux}[local];{$endif}
    procedure PTUseless2    (var   arr_dst         :TColorArr;
                             const arr_dst_width   :TColor;
                             const val             :TColor);                 {$ifdef Linux}[local];{$endif}
    function  Useless: byte;                                         inline; {$ifdef Linux}[local];{$endif}
    procedure SclMulCheck   (var   fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctPos     (      rct             :TPtRect);        inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctPos     (      x,y,w,h         :integer);        inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctPos     (      x,y             :integer);        inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctPos     (      x,y             :integer;
                             var   fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctPosF    (      x,y             :double);         inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctPosF    (      x,y             :double;
                             var   fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif}

    procedure SetRctDst0;                                            inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctDst0    (var   fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctDst1;                                            inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctDst1    (var   fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctDst2;                                            inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctDst2    (var   fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctDst3;                                            inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctDst3    (var   fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctSrc;                                             inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctSrc     (var   fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctSrcF;                                            inline; {$ifdef Linux}[local];{$endif}
    procedure SetRctSrcF    (var   fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif}
    procedure GetFrameHeight(      frame_cnt       :word);           inline; {$ifdef Linux}[local];{$endif} {$endregion}

    {Init. Part--------------------------------------------} {$region -fold}
    constructor Create;                                                                       {$ifdef Linux}[local];{$endif}
    destructor  Destroy;                                                   override;          {$ifdef Linux}[local];{$endif}
    // MT data array init.:
    procedure   FastImageDataMTInit;                                       virtual; abstract; {$ifdef Linux}[local];{$endif}
    // Set the basic properties of the drawing target surface(bkgnd):
    procedure SetBkgnd  (const bkgnd_ptr               :PInteger;
                         const bkgnd_width,
                               bkgnd_height            :TColor;
                         const rct_clp                 :TPtRect);          inline;            {$ifdef Linux}[local];{$endif}
    procedure SetClpRct (const rct_clp                 :TPtRect);          inline;            {$ifdef Linux}[local];{$endif}
    procedure SetValInfo(const bmp_color_ptr_,
                               bmp_alpha_ptr_,
                               bmp_value_ptr_          :PInteger;
                         const ftimg_width,
                               ftimg_height            :TColor);           inline;            {$ifdef Linux}[local];{$endif}
    procedure SetPPInfo (const val                     :TColor=$00434D3E); inline;            {$ifdef Linux}[local];{$endif}
    procedure SetPPInfo (const val                     :TColor;
                         var   fast_image_data_        :TFastImageData);   inline;            {$ifdef Linux}[local];{$endif}
    procedure FXInit;                                                      inline;            {$ifdef Linux}[local];{$endif}
    // Set the start and end             of the gradient on the axis y:
    procedure SetGradVec(      x,y                     :integer);          inline;            {$ifdef Linux}[local];{$endif}
    procedure SetGradVec(      x,y                     :integer;
                         const fast_image_data_ptr_    :PFastImageData;
                         var   fast_image_data_        :TFastImageData);   inline;            {$ifdef Linux}[local];{$endif}
    // Set     start and end color value of the gradient:
    procedure SetGradCol(      x,y                     :TColor);           inline;            {$ifdef Linux}[local];{$endif}
    procedure SetGradCol(      x,y                     :TColor;
                         var   fast_image_data_        :TFastImageData);   inline;            {$ifdef Linux}[local];{$endif}
    procedure SrcDestroy(      bmp_src                 :TPicture  );       inline;            {$ifdef Linux}[local];{$endif}
    procedure SrcDestroy(      bmp_src                 :TBitmap   );       inline;            {$ifdef Linux}[local];{$endif}
    procedure SrcDestroy(      arr_src                 :TColorArr );       inline;            {$ifdef Linux}[local];{$endif}
    procedure SrcDestroy(      arr_src                 :TWordArr  );       inline;            {$ifdef Linux}[local];{$endif}
    procedure SrcDestroy(      arr_src                 :T1Byte1Arr);       inline;            {$ifdef Linux}[local];{$endif} {$endregion}

    {$endregion}

  end; {$endregion}
  PFastImageProc     =^TFastImageProc;
  {****************************************************************************} {$endregion}



  {Fast line ******************************************************************} {$region -fold}
  // allows to draw lines but can be usefull for drawing another primitives:
  TFastLine          =class {$region -fold}

    {State machine for line drawing routines--------} {$region -fold}
    protected
      var
        LineProc: array[0..39] of TProc0; {$endregion}

    {Edges and points pixels basic datas------------} {$region -fold}
    public
      var
        {spline sprite}
        //fast_image         : TFastImageItem;

        {static edges buffer : for "vertical"   lines}
        ln_arr2              : T2Byte1Arr;

        {static edges buffer : for "regular"    lines}
        ln_arr1              : TColorArr;

        {static edges buffer : for "horizontal" lines}
        ln_arr0              : T1Byte1Arr;

        {destination bitmap(background)}
        bmp_dst_ptr          : PInteger;
        bmp_dst_width        : TColor;
        bmp_dst_height       : TColor;

        {source array}
        ln_arr1_ptr          : PInteger;
        ln_arr0_ptr          : PByte;
        ln_arr_width         : TColor;
        ln_arr_height        : TColor;

        {line kind pointer}
        ln_kind_ptr          : PInteger; {$endregion}

    {Misc. variables: line drawing------------------} {$region -fold}
    protected
      var
        k_ ,b_ ,dx_,dy_                : double ;
        r0 ,p0 ,r1 ,p1 ,g  ,tk ,tb ,th : integer;
        dx ,dy ,a  ,b  ,c  ,m1 ,m2     : integer;
       {n_                             : double;
        t0,t1,m_                       : integer;} {$endregion}

    {Hidden-line elimination------------------------} {$region -fold}
    public
     {is line visible array:
      0 - line is invisible;
      1 - line is   visible}
      useless_arr: T1Byte1Arr;
     {hidden  lines count}
      hid_ln_cnt : TColor;
     {visible lines count}
      vis_ln_cnt : TColor;
     {existing lines count}
      all_ln_cnt : TColor; {$endregion}

    {Misc. variables: clipping----------------------} {$region -fold}
    public
      {drawing window rectangle pointer}
      rct_clp_ptr: PPtRect;
      ln_pos     : TLnPos;
      color_info : TColorInfo;
      pix_cnt    : TColor;
      mov_dir    : TMovingDirection; {$endregion}

    {Resilient line---------------------------------} {$region -fold}
    res_ln_pts_cnt: TColorArr; {$endregion}

    {Spline local properties------------------------} {$region -fold}
    public
      var
        local_prop: TCurveProp; {$endregion}

    {Bounding rectangles of spline object-----------} {$region -fold}
    public
      var
        // spline entire rectangle:
        rct_ent  : TPtRectF;
        // spline entire rectangle with offset:
        rct_ent_2: TPtRect;
        // spline visible(clipped by inner window) rectangle:
        rct_vis  : TPtRect;
        // spline window(inner window) rectangle
        rct_wnd  : TRect; {$endregion}

    {Post-processing--------------------------------} {$region -fold}
    args             : TFunc0Args;
    pp_dec_2_proc_ind: byte; {$endregion}

    {Edge anti-aliasing-----------------------------} {$region -fold}
    public
      var
        {alpha border of anti-aliased spline}
        aa_arr2            : TAALnArr;
        {alpha border of anti-aliased spline}
        aa_arr1            : T1Byte1Arr;
        {antialiased lines count}
        aa_line_cnt        : TColor;
        aa_nz_arr_items_cnt: TColor; {$endregion}

    {Misc. routines---------------------------------} {$region -fold}
    public
      constructor Create;                                                    {$ifdef Linux}[local];{$endif}
      destructor  Destroy;                                         override; {$ifdef Linux}[local];{$endif}
      procedure GCCArrInit;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure GetLineBuffHndl;                                   inline;   {$ifdef Linux}[local];{$endif}
      procedure BuffersInit       (      w,h            :TColor;
                                         ln_arr0_init   :boolean;
                                         ln_arr1_init   :boolean;
                                         ln_arr2_init   :boolean;
                                         aa_buff_init   :boolean); inline;   {$ifdef Linux}[local];{$endif}
      procedure SetBkgnd          (const bmp_dst_ptr_   :PInteger;
                                   const bmp_dst_width_,
                                         bmp_dst_height_:TColor;
                                   const rct_clp_ptr_   :PPtRect); inline;   {$ifdef Linux}[local];{$endif}
      procedure MinimizeArrs      (      aa_buff_clear  :boolean); inline;   {$ifdef Linux}[local];{$endif}
      {Fast line grid precalculation}
    {class} procedure LinePrecalc (      w,h            :TColor);            {$ifdef Linux}[local];{$endif}
      {Solid line initialization}
      procedure LineSInit;                                         inline;   {$ifdef Linux}[local];{$endif}
      {Solid horizontal line drawing}
      procedure LineSHL00;                                         inline;   {$ifdef Linux}[local];{$endif}
      procedure LineSHL10;                                         inline;   {$ifdef Linux}[local];{$endif}
      procedure LineSHL20;                                         inline;   {$ifdef Linux}[local];{$endif}
      procedure LineSHL30;                                         inline;   {$ifdef Linux}[local];{$endif}
      procedure LineSHL40;                                         inline;   {$ifdef Linux}[local];{$endif}
      {Solid vertical line drawing}
      procedure LineSVL00;                                         inline;   {$ifdef Linux}[local];{$endif}
      procedure LineSVL10;                                         inline;   {$ifdef Linux}[local];{$endif}
      procedure LineSVL20;                                         inline;   {$ifdef Linux}[local];{$endif}
      procedure LineSVL30;                                         inline;   {$ifdef Linux}[local];{$endif}
      procedure LineSVL40;                                         inline;   {$ifdef Linux}[local];{$endif}
      //
      procedure SwapArgs          (      x0,y0,x1,y1    : double); inline;   {$ifdef Linux}[local];{$endif}
      //
      procedure GetLCoef0         (      x0,y0,x1,y1    : double); inline;   {$ifdef Linux}[local];{$endif}
      procedure GetLCoef1;                                         inline;   {$ifdef Linux}[local];{$endif}
      procedure GetLCoef2;                                         inline;   {$ifdef Linux}[local];{$endif}
      // (Move points) Перемещение точек:
      procedure LinePHL00         (      x0,y0,x1,y1    : double); inline;   {$ifdef Linux}[local];{$endif}
      procedure LinePHL01;                                         inline;   {$ifdef Linux}[local];{$endif}
      procedure LinePHL02;                                         inline;   {$ifdef Linux}[local];{$endif}
      // (Select points) Выделение точек:
      procedure LinePHL10         (      x0,y0,x1,y1    : double); inline;   {$ifdef Linux}[local];{$endif}
      procedure LinePHL11;                                         inline;   {$ifdef Linux}[local];{$endif}
      procedure LinePHL12;                                         inline;   {$ifdef Linux}[local];{$endif}
      // (Unselect points) Снятие выделения точек:
      procedure LinePHL20         (      x0,y0,x1,y1    : double); inline;   {$ifdef Linux}[local];{$endif}
      procedure LinePHL21;                                         inline;   {$ifdef Linux}[local];{$endif}
      procedure LinePHL22;                                         inline;   {$ifdef Linux}[local];{$endif}
      // (Direct pixel write) Непосредственная запись в битовую карту:
      procedure LinePHL30         (      x0,y0,x1,y1    : double); inline;   {$ifdef Linux}[local];{$endif}
      procedure LinePHL31;                                         inline;   {$ifdef Linux}[local];{$endif}
      procedure LinePHL32;                                         inline;   {$ifdef Linux}[local];{$endif}
      // (Advanced byte mode) Продвинутый байт-режим:
      procedure LinePHL40         (      x0,y0,x1,y1    : double); inline;   {$ifdef Linux}[local];{$endif}
      procedure LinePHL41;                                         inline;   {$ifdef Linux}[local];{$endif}
      procedure LinePHL42;                                         inline;   {$ifdef Linux}[local];{$endif}

    protected
      {Right bottom corner}
      {0°..-45°}
      procedure LineS00;                                           inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS01RBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS02RBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS03RBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS04RBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS05RBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS06RBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS07RBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS08RBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS09RBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      {-45°..-90°}
      procedure LineS10;                                           inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS11RBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS12RBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS13RBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS14RBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS15RBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS16RBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS17RBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS18RBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS19RBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      {Left bottom corner}
      {-135°..-180°}
      procedure LineS20;                                           inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS21LBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS22LBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS23LBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS24LBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS25LBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS26LBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS27LBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS28LBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS29LBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      {-90°..-135°}
      procedure LineS30;                                           inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS31LBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS32LBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS33LBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS34LBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS35LBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS36LBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS37LBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS38LBC;                                        inline;   {$ifdef Linux}[local];{$endif}
      procedure LineS39LBC;                                        inline;   {$ifdef Linux}[local];{$endif}

    public
      {Solid line drawing}
      {Fast  line solid mode 'Normal'}
      procedure LineSMN           (const x0,y0,x1,y1    :integer); inline;   {$ifdef Linux}[local];{$endif}
      {Fast  line solid mode 'Extended'}
      procedure LineSME           (const x0,y0,x1,y1    :integer;
                                   const proc_ptr_a,
                                         proc_ptr_b,
                                         proc_ptr_c     :TProc0);  inline;   {$ifdef Linux}[local];{$endif}

      {Fast line clipping}
      procedure ClippedLine1      (      x0,y0,x1,y1    :integer;
                                   const rct_clp        :TPtRect;
                                   const proc1          :TProc3;
                                   const proc2,
                                         proc3,
                                         proc4          :TProc0);            {$ifdef Linux}[local];{$endif}
      procedure ClippedLine2      (      x0,y0,x1,y1    :integer;
                                   const rct_clp        :TPtRect;
                                   const proc1          :TProc3;
                                   const proc2,
                                         proc3,
                                         proc4          :TProc0);            {$ifdef Linux}[local];{$endif}
      procedure ClippedLine2      (      x0,y0,x1,y1    :double;
                                   const rct_clp        :TPtRect;
                                   const proc1          :TProc20;
                                   const proc2,
                                         proc3,
                                         proc4,
                                         proc5          :TProc0);            {$ifdef Linux}[local];{$endif}
      procedure ClippedLine2      (      x0,y0,x1,y1    :integer;
                                   const rct_clp        :TPtRect);           {$ifdef Linux}[local];{$endif}
      procedure FilBuffer         (const rct_clp        :TPtRect);           {$ifdef Linux}[local];{$endif} {$endregion}

  end; {$endregion}
  PFastLine          =^TFastLine;
  {****************************************************************************} {$endregion}



  {Fast text ******************************************************************} {$region -fold}
  // parametric text stored in CSR format:
  TFastText          =class {$region -fold}
    public
      var
        {Text sprite}
        fst_img   : TFastImageItem;
        {Text local properties}
        local_prop: TFTextProp;
      constructor Create;            {$ifdef Linux}[local];{$endif}
      destructor  Destroy; override; {$ifdef Linux}[local];{$endif}
    {TODO}
  end; {$endregion}
  PFastText          =^TFastText;
  {****************************************************************************} {$endregion}



  {Function Statement *********************************************************} {$region -fold}

(***************************** Some basic routines ****************************)
//
//
function  FloatToFixed          (const    x                  :double            ): integer;       inline; {$ifdef Linux}[local];{$endif}
// (Swapping two values) Поменять местами два значения:
procedure Swap1                 (var      x,y                :integer);                           inline; {$ifdef Linux}[local];{$endif}
procedure Swap2                 (var      x,y                :integer);                           inline; {$ifdef Linux}[local];{$endif}
procedure Swap3                 (var      x,y                :double);                            inline; {$ifdef Linux}[local];{$endif}
//
function  GetEnumVal            (         enum               :TDrawingStyle     ): TColor;        inline; {$ifdef Linux}[local];{$endif}
function  GetEnumVal            (         enum               :TDrawingStyle     ): integer;       inline; {$ifdef Linux}[local];{$endif}
// (Minimum of values):
function  Min0                  (const    a1,a2              :PtrInt            ): PtrInt;        inline; {$ifdef Linux}[local];{$endif}
function  Min1                  (const    a1,a2              :double            ): double;        inline; {$ifdef Linux}[local];{$endif}
function  Min2                  (const    a1,a2              :integer           ): integer;       inline; {$ifdef Linux}[local];{$endif}
function  Min3                  (const    a1,a2              :TColor            ): TColor;        inline; {$ifdef Linux}[local];{$endif}
function  Min4                  (const    arr                :TIntrArr;
                                 const    max_item_val       :integer;
                                 const    item_cnt           :integer           ): integer;       inline; {$ifdef Linux}[local];{$endif}
function  Min5                  (const    arr                :TColorArr;
                                 const    max_item_val       :TColor;
                                 const    item_cnt           :TColor            ): TColor;        inline; {$ifdef Linux}[local];{$endif}
function  Min6                  (const    arr                :TIntrArr;
                                 const    max_item_val       :integer;
                                 const    item_cnt           :integer;
                                 const    b                  :boolean           ): integer;       inline; {$ifdef Linux}[local];{$endif}
function  Min7                  (const    arr                :TColorArr;
                                 const    max_item_val       :TColor;
                                 const    item_cnt           :TColor;
                                 const    b                  :boolean           ): TColor;        inline; {$ifdef Linux}[local];{$endif}
function  Min8                  (const    arr                :TEdgeArr;
                                 const    max_item_val       :integer;
                                 const    item_cnt           :integer           ): integer;       inline; {$ifdef Linux}[local];{$endif}
function  Min9                  (const    arr                :TEdgeArr;
                                 const    max_item_val       :TColor;
                                 const    item_cnt           :TColor            ): TColor;        inline; {$ifdef Linux}[local];{$endif}
// (Maximum of values):
function  Max0                  (const    a1,a2              :PtrInt            ): PtrInt;        inline; {$ifdef Linux}[local];{$endif}
function  Max1                  (const    a1,a2              :double            ): double;        inline; {$ifdef Linux}[local];{$endif}
function  Max2                  (const    a1,a2              :integer           ): integer;       inline; {$ifdef Linux}[local];{$endif}
function  Max3                  (const    a1,a2              :TColor            ): TColor;        inline; {$ifdef Linux}[local];{$endif}
function  Max4                  (const    arr                :TIntrArr;
                                 const    min_item_val       :integer;
                                 const    item_cnt           :integer           ): integer;       inline; {$ifdef Linux}[local];{$endif}
function  Max5                  (const    arr                :TColorArr;
                                 const    min_item_val       :TColor;
                                 const    item_cnt           :TColor            ): TColor;        inline; {$ifdef Linux}[local];{$endif}
function  Max6                  (const    arr                :TIntrArr;
                                 const    min_item_val       :integer;
                                 const    item_cnt           :integer;
                                 const    b                  :boolean           ): integer;       inline; {$ifdef Linux}[local];{$endif}
function  Max7                  (const    arr                :TColorArr;
                                 const    min_item_val       :TColor;
                                 const    item_cnt           :TColor;
                                 const    b                  :boolean           ): TColor;        inline; {$ifdef Linux}[local];{$endif}
function  Max8                  (const    arr                :TEdgeArr;
                                 const    min_item_val       :integer;
                                 const    item_cnt           :integer           ): integer;       inline; {$ifdef Linux}[local];{$endif}
function  Max9                  (const    arr                :TEdgeArr;
                                 const    min_item_val       :TColor;
                                 const    item_cnt           :TColor            ): TColor;        inline; {$ifdef Linux}[local];{$endif}
// (MinSubMax:important condition!: c>d):
function  MinSubMax0            (const    a,b,c,d            :integer           ): integer;       inline; {$ifdef Linux}[local];{$endif}
function  MinSubMax1            (const    a,b,c,d            :integer           ): TPtPos4;       inline; {$ifdef Linux}[local];{$endif}
function  MinSubMax2            (const    a,b,c,d            :integer           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
//
function  InvSqrt               (const    x                  :single            ): single;        inline; {$ifdef Linux}[local];{$endif}
//
function  Limit                 (         x                  :integer           ): byte;          inline; {$ifdef Linux}[local];{$endif}
//
procedure MaxSpriteWHRctInit    (var      rct                :TPtRect);                           inline; {$ifdef Linux}[local];{$endif}
//
function  ArcTan4               (const    x0,y0,x1,y1        :double            ): double;        inline; {$ifdef Linux}[local];{$endif}
//
function  IndexOfSubStr         (const    list               :TStrings;
                                 var      sub_string         :string            ): integer;       inline; {$ifdef Linux}[local];{$endif}
// (Binary search) Бинарный поиск:
function  BinarySearch0         (const    n                  :word;
                                 const    arr_item_ptr       :PWord;
                                 const    right_border       :integer           ): integer;       inline; {$ifdef Linux}[local];{$endif}
function  BinarySearch1         (const    n                  :word;
                                 const    arr_item_ptr       :PWord;
                                 const    right_border       :word              ): word;          inline; {$ifdef Linux}[local];{$endif}
function  BinarySearch2         (const    n                  :TColor;
                                 const    arr_item_ptr       :PInteger;
                                 const    right_border       :integer           ): integer;       inline; {$ifdef Linux}[local];{$endif}
function  BinarySearch3         (const    n                  :TColor;
                                 const    arr_item_ptr       :PInteger;
                                 const    right_border       :integer           ): integer;       inline; {$ifdef Linux}[local];{$endif}
function  BinarySearch4         (const    n                  :TColor;
                                 const    arr_item_ptr       :PDouble;
                                 const    right_border       :double            ): TColor;        inline; {$ifdef Linux}[local];{$endif}
function  BinarySearch5         (const    n                  :TColor;
                                 const    arr_item_ptr       :PWord;
                                 const    right_border       :double            ): integer;       inline; {$ifdef Linux}[local];{$endif}
// (Checks if both values x and y have not equal signs) Проверяет, имеют ли оба значения x и y не одинаковые знаки:
// returns True if x and y are not equal 0 and have not equal signs, otherwise returns False.
function  NotEqualSign          (         x,y                :double            ): boolean;       inline; {$ifdef Linux}[local];{$endif}
// (Calculation of the global axis shift error during the movement of the block motion of the layer) Вычисление ошибки смещения глобальной оси при блочном движении слоя:
procedure ShiftErrorCalc        (         x0,x1              :double;
                                 var      err                :integer;
                                          df_exp             :boolean);                           inline; {$ifdef Linux}[local];{$endif}
// (Set point) Установить точку:
function  PtPos                 (const    pt                 :TPtPosF           ): TPtPos;        inline; {$ifdef Linux}[local];{$endif}
function  PtPos                 (const    pos_x,pos_y        :integer           ): TPtPos;        inline; {$ifdef Linux}[local];{$endif}
function  PtPos                 (const    pos_x,pos_y        :double            ): TPtPos;        inline; {$ifdef Linux}[local];{$endif}
function  PtPos2                (const    pt                 :TPtPosF           ): TPtPos2;       inline; {$ifdef Linux}[local];{$endif}
function  PtPos2                (const    pos_x,pos_y        :TColor            ): TPtPos2;       inline; {$ifdef Linux}[local];{$endif}
function  PtPos2                (const    pos_x,pos_y        :double            ): TPtPos2;       inline; {$ifdef Linux}[local];{$endif}
function  PtPosF                (const    pt                 :TPtPos            ): TPtPosF;       inline; {$ifdef Linux}[local];{$endif}
function  PtPosF                (const    pos_x,pos_y        :double            ): TPtPosF;       inline; {$ifdef Linux}[local];{$endif}
function  PtPosF                (const    pos_x,pos_y        :integer           ): TPtPosF;       inline; {$ifdef Linux}[local];{$endif}
function  PtPosF                (const    pt                 :TPtPos2           ): TPtPosF;       inline; {$ifdef Linux}[local];{$endif}
// (Set line) Установить линию:
{get coefficients of reflection ray}
{x0,y0,x1,y1       - first  segment;
 v0,w0,v1,w1       - second segment;
 int_pt_x,int_pt_y - intersection point of two segments;
 result            - coefficients of reflection ray equation}
{second segment is horizontal line}
function  LnCoefRefl0           (const    int_pt_x,
                                          x0,y0,x1,y1        :double            ): TPtPosF;       inline; {$ifdef Linux}[local];{$endif}
{second segment is vertical   line}
function  LnCoefRefl1           (const    int_pt_y,
                                          x0,y0,x1,y1        :double            ): TPtPosF;       inline; {$ifdef Linux}[local];{$endif}
{second segment is regular    line}
function  LnCoefRefl2           (const    int_pt_x,int_pt_y,
                                          x0,y0,x1,y1,
                                          v0,w0,v1,w1        :double            ): TPtPosF;       inline; {$ifdef Linux}[local];{$endif}
function  LnCoef                (const    x0,y0,x1,y1        :double            ): TPtPosF;       inline; {$ifdef Linux}[local];{$endif}
function  LnCoef                (const    x0,y0,x1,y1        :integer           ): TPtPosF;       inline; {$ifdef Linux}[local];{$endif}
function  LnCoef                (const    vec                :TLnPosF           ): TPtPosF;       inline; {$ifdef Linux}[local];{$endif}
function  LnPos                 (const    vec                :TLnPosF           ): TLnPos;        inline; {$ifdef Linux}[local];{$endif}
function  LnPos                 (const    x0,y0,x1,y1        :integer           ): TLnPos;        inline; {$ifdef Linux}[local];{$endif}
function  LnPosF                (const    vec                :TLnPos            ): TLnPosF;       inline; {$ifdef Linux}[local];{$endif}
function  LnPosF                (const    x0,y0,x1,y1        :double            ): TLnPosF;       inline; {$ifdef Linux}[local];{$endif}
function  LnPosF                (const    x0,y0,x1,y1        :integer           ): TLnPosF;       inline; {$ifdef Linux}[local];{$endif}
// (Bounding rectangle of points set) Ограничиваюший прямоугольник множества точек:
function  PtsRngRctCalc         (const    pts                :TPtPosFArr;
                                 var      rct_bnd_ind_arr    :TEnum2Arr;
                                 const    start_pts_ind      :TColor=0;
                                 const    end_pts_ind        :TColor=0          ): TRect;                 {$ifdef Linux}[local];{$endif}
function  PtsRngRctCalc2        (const    pts                :TPtPosFArr;
                                 var      rct_bnd_ind_arr    :TEnum2Arr;
                                 const    start_pts_ind      :TColor=0;
                                 const    end_pts_ind        :TColor=0          ): TPtRectF;              {$ifdef Linux}[local];{$endif}
function  PtsRngIndsRctCalc     (const    pts                :TPtPosFArr;
                                 const    sel_pts_inds       :TColorArr;
                                 const    pts_cnt            :TColor            ): TRect;                 {$ifdef Linux}[local];{$endif}
// (Set rectangle) Установить прямоугольник:
procedure PtRct                 (const    pts                :TPtPosFArr;
                                 const    rct_bnd_ind_arr    :TEnum2Arr;
                                 var      rct                :TRect);                             inline; {$ifdef Linux}[local];{$endif}
procedure PtRctF                (const    pts                :TPtPosFArr;
                                 const    rct_bnd_ind_arr    :TEnum2Arr;
                                 var      rct                :TPtRectF);                          inline; {$ifdef Linux}[local];{$endif}
function  PtRctF                (const    rct_left,
                                          rct_top,
                                          rct_right,
                                          rct_bottom         :double            ): TPtRectF;      inline; {$ifdef Linux}[local];{$endif}
function  PtRctF                (const    rct                :TPtRect           ): TPtRectF;      inline; {$ifdef Linux}[local];{$endif}
function  PtRctB                (const    rct_left,
                                          rct_top,
                                          rct_right,
                                          rct_bottom         :integer           ): TPtRectB;      inline; {$ifdef Linux}[local];{$endif}
function  PtRct                 (const    rct_left,
                                          rct_top,
                                          rct_right,
                                          rct_bottom         :integer           ): TPtRect;       inline; {$ifdef Linux}[local];{$endif}
function  PtRct                 (const    rct                :TRect             ): TPtRect;       inline; {$ifdef Linux}[local];{$endif}
function  PtRct                 (const    rct                :TPtRectF          ): TPtRect;       inline; {$ifdef Linux}[local];{$endif}
function  PtRct                 (const    rct                :TPtPosFArr        ): TPtRect;       inline; {$ifdef Linux}[local];{$endif}
function  PtBounds              (const    rct_left,
                                          rct_top,
                                          rct_width,
                                          rct_height         :integer           ): TPtRect;       inline; {$ifdef Linux}[local];{$endif}
function  PtBounds              (const    rct                :TRect             ): TPtRect;       inline; {$ifdef Linux}[local];{$endif}
function  PtBoundsF             (const    rct_left,
                                          rct_top,
                                          rct_width,
                                          rct_height         :integer           ): TPtRectF;      inline; {$ifdef Linux}[local];{$endif}
function  PtBoundsF             (const    rct_left,
                                          rct_top,
                                          rct_width,
                                          rct_height         :double            ): TPtRectF;      inline; {$ifdef Linux}[local];{$endif}
function  SetRct                (         index              :PtrInt;
                                 const    rct_dst            :TPtRect;
                                 const    block_count        :integer           ): TPtRect;       inline; {$ifdef Linux}[local];{$endif}
// (Inner clipped rectangle) Внутренний обрезанный прямоугольник:
function  ClippedRctB           (const    out_rct,
                                          inn_rct            :TPtRect;
                                 var      b                  :byte              ): TPtRect;       inline; {$ifdef Linux}[local];{$endif}
function  ClippedRct            (const    out_rct,
                                          mrg_rct,
                                          inn_rct            :TPtRect;
                                 var      pix_clp_type       :byte              ): TPtRect;       inline; {$ifdef Linux}[local];{$endif}
function  ClippedRct            (const    out_rct,
                                          inn_rct            :TPtRect           ): TPtRect;       inline; {$ifdef Linux}[local];{$endif}
function  ClippedRct            (const    out_rct            :TPtRect;
                                 const    inn_rct            :TPtRectF          ): TPtRect;       inline; {$ifdef Linux}[local];{$endif}
function  ClippedRct            (const    out_rct,
                                          inn_rct            :TRect             ): TPtRect;       inline; {$ifdef Linux}[local];{$endif}
function  ClippedRct            (const    out_rct            :TPtRect;
                                 const    inn_rct            :TRect             ): TPtRect;       inline; {$ifdef Linux}[local];{$endif}
function  ClippedRct            (const    out_rct            :TRect;
                                 const    inn_rct            :TPtRect           ): TPtRect;       inline; {$ifdef Linux}[local];{$endif}
function  ClippedRct            (const    out_rct            :TRect;
                                 const    inn_rct            :TPtRectF          ): TPtRect;       inline; {$ifdef Linux}[local];{$endif}
function  ClippedRct            (const    out_rct            :TPtRect;
                                 const    inn_rct            :TRect;
                                          b                  :boolean           ): TRect;         inline; {$ifdef Linux}[local];{$endif}
function  ClippedRct            (const    out_rct,
                                          inn_rct            :TRect;
                                          b                  :boolean           ): TRect;         inline; {$ifdef Linux}[local];{$endif}
// (Find rectangle with not coprime width and height(GCD(src_rect.width,src_rect.height)<>1) for source rectangle src_rect) Находит прямоугольник с не взаимно простыми сторонами(GCD(src_rect.Width,src_rect.Height)<>1) для исходного прямоугольника src_rect:
function  NCSRectCalc           (const    rct_src            :TPtRectF;
                                 const    bucket_width,
                                          bucket_heigth      :integer           ): TPtRectF;      inline; {$ifdef Linux}[local];{$endif}
// (Two rectangles bounding rectangle 1) Ограничивающий прямоугольник для двух заданных прямоугольников:
function  TwoRctsBoundingRct    (const    rct1,
                                          rct2               :TRect             ): TRect;         inline; {$ifdef Linux}[local];{$endif}
function  TwoRctsBoundingRct    (const    rct1,
                                          rct2               :TPtRect           ): TPtRect;       inline; {$ifdef Linux}[local];{$endif}
// (Checking if two rectangles are equal) Проверка на равенство двух прямоугольников:
function  AreRct1AndRct2Eq      (const    rct1,
                                          rct2               :TPtRect           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
// (Rectangle in rectangle) Прямоугольник в прямоугольнике:
function  IsRct1InRct2          (const    rct1,
                                          rct2               :TRect             ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  IsRct1InRct2          (const    rct1,
                                          rct2               :TPtRect           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  IsRct1InRct2          (const    rct1               :TRect;
                                 const    rct2               :TPtRect           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
// (Rectangle out of rectangle) Прямоугольник вне прямоугольника:
function  IsRct1OutOfRct2       (const    rct1,
                                          rct2               :TRect             ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  IsRct1OutOfRct2       (const    rct1,
                                          rct2               :TPtRect           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  IsRct1OutOfRct2       (const    rct1               :TRect;
                                 const    rct2               :TPtRect           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  IsRct1OutOfRct2       (const    rct1               :TPtRectF;
                                 const    rct2               :TPtRect           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
// (Line bounding rectangle) Ограничивающий линию прямоугольник:
function  LineBndRct            (const    x0,y0,x1,y1,
                                          ln_width           :integer           ): TPtRect;       inline; {$ifdef Linux}[local];{$endif}
// (Point in rectangle) Точка в прямоугольнике:
function  IsPtInRct             (const    x,y,
                                          rct_dst_left,
                                          rct_dst_top,
                                          rct_dst_right,
                                          rct_dst_bottom     :integer           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  IsPtInRct             (const    x,y                :integer;
                                 const    rct_dst            :TRect             ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  IsPtInRct             (const    x,y                :integer;
                                 const    rct_dst            :TPtRect           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  IsPtInRct             (const    x,y                :double;
                                 const    rct_dst            :TPtRect           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  IsPtInRct             (const    x,y                :double;
                                 const    rct_dst            :TPtRectF          ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  IsPtInRct             (const    pt                 :TPtPos;
                                 const    rct_dst            :TRect             ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  IsPtInRct             (const    pt                 :TPtPos;
                                 const    rct_dst            :TPtRect           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  IsPtInRct             (const    pt                 :TPtPosF;
                                 const    rct_dst            :TRect             ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  IsPtInRct             (const    pt                 :TPtPosF;
                                 const    rct_dst            :TPtRect           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  IsPtInRct             (const    pt                 :TPtPosF;
                                 const    rct_dst            :TPtRect;
                                 const    rad                :integer           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  IsPtInRct             (const    pt                 :TPtPosF;
                                 const    rct_dst            :TPtRectF          ): boolean;       inline; {$ifdef Linux}[local];{$endif}
// (Point in circle) Точка в окружности:
function  IsPtInCrc             (const    x,y                :integer;
                                 const    crc_dst            :TCrPos;
                                 const    prec               :integer           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  IsPtInCrc             (const    x,y                :integer;
                                 const    crc_dst            :TCrPosF;
                                 const    prec               :integer           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  IsPtInCrc             (const    x,y                :double;
                                 const    crc_dst            :TCrPosF;
                                 const    prec               :integer           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  IsPtInCrc             (const    x,y                :double;
                                 const    crc_x,
                                          crc_y,
                                          crc_r              :integer;
                                 const    prec               :integer           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  IsPtInCrc             (const    x,y                :integer;
                                 const    crc_x,
                                          crc_y,
                                          crc_r              :integer;
                                 const    prec               :integer           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
// (Distance between two points) Расстояние между двумя точками:
function  PtDist                (const    x0,y0,x1,y1        :integer           ): double ;       inline; {$ifdef Linux}[local];{$endif}
function  PtDist                (const    x0,y0,x1,y1        :double            ): double ;       inline; {$ifdef Linux}[local];{$endif}
function  PtDistSqr             (const    x0,y0,x1,y1        :integer           ): integer;       inline; {$ifdef Linux}[local];{$endif}
function  PtDistSqr             (const    x0,y0,x1,y1        :integer           ): double ;       inline; {$ifdef Linux}[local];{$endif}
function  PtDistSqr             (const    x0,y0,x1,y1        :double            ): double ;       inline; {$ifdef Linux}[local];{$endif}
function  PtDistSqr             (const    pt0,pt1            :TPtPosF           ): double ;       inline; {$ifdef Linux}[local];{$endif}
// (Line-line intersection point) Точка пересечения двух линий:
function  LineLineIntPt         (const    x0,y0,x1,y1,
                                          v0,w0,v1,w1        :double            ): TPtPosF;       inline; {$ifdef Linux}[local];{$endif}
// (Line-circle intersection points) Точки пересечения линии и окружности:
function  LineCrcIntPt          (const    x0,y0,x1,y1        :double;
                                 const    crc_dst            :TCrPosF           ): TLnPosF;       inline; {$ifdef Linux}[local];{$endif}
function  LineCrcIntPt          (const    x0,y0,x1,y1        :double;
                                 const    x,y,r              :double            ): TLnPosF;       inline; {$ifdef Linux}[local];{$endif}
function  LineCrcIntPt          (const    x0,y0,x1,y1        :integer;
                                 const    x,y,r,v            :double            ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  CrcPosF               (const    x,y,r              :double            ): TCrPosF;       inline; {$ifdef Linux}[local];{$endif}
// (Circle-circle intersection) Пересечение двух окружностей:
function  CrcCrcInt             (const    x0,y0,r0,x1,y1,r1  :double            ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  CrcCrcInt             (const    x0,y0,r0,x1,y1,r1  :integer           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  CrcCrcInt             (const    crc0,crc1          :TCrPosF           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  CrcCrcInt             (const    crc0,crc1          :TCrPos            ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  CrcCrcInt             (const    vec0,vec1          :TLnPosF;
                                 const    r0,r1              :double            ): TPtPosF;       inline; {$ifdef Linux}[local];{$endif}
function  CrcCrcInt             (const    vec0,vec1          :TLnPosF;
                                 const    r0,r1              :double            ): TLnPosF3;      inline; {$ifdef Linux}[local];{$endif}
function  CrcCrcInt             (const    vec0,vec1          :TLnPosF;
                                 const    r0,r1              :double;
                                 const    k,t                :integer;
                                 var      b                  :byte              ): TLnPosF;       inline; {$ifdef Linux}[local];{$endif}
// (Rectangle-circle intersection) Пересечение прямоугольника и окружности:
function  RctCrcInt             (const    rct                :TRect;
                                 const    x,y,r              :integer           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  RctCrcInt             (const    rct                :TPtRect;
                                 const    x,y,r              :integer           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
// (Angle between two connected segments,(x1,y1) - connection point) Угол между двумя соединенными сегментами,(x1,y1) - точка соединения:
function  GetAngle              (const    pt0,pt1,pt2        :TPtPosF           ): double;        inline; {$ifdef Linux}[local];{$endif}
function  GetAngle              (const    x0,y0,x1,y1,x2,y2  :double            ): double;        inline; {$ifdef Linux}[local];{$endif}
// (Gauss's area formula, area multiplied by 2) Формула площади Гаусса, площадь, умноженная на 2:
function  GaussPolygonArea      (         pt_cnt             :integer;
                                          first_pt_ptr       :PPtPosF           ): double;        inline; {$ifdef Linux}[local];{$endif}
function  GaussSumTrisArea      (         pt_cnt             :integer;
                                          first_pt_ptr,pt_out:PPtPosF           ): double;        inline; {$ifdef Linux}[local];{$endif}



(******************************* Color transform ******************************)
function  Red                   (         pixel              :TColor            ): byte;          inline; {$ifdef Linux}[local];{$endif}
function  Green                 (         pixel              :TColor            ): byte;          inline; {$ifdef Linux}[local];{$endif}
function  Blue                  (         pixel              :TColor            ): byte;          inline; {$ifdef Linux}[local];{$endif}
function  Alpha                 (         pixel              :TColor            ): byte;          inline; {$ifdef Linux}[local];{$endif}
function  RGB                   (         r,g,b              :byte              ): TColor;        inline; {$ifdef Linux}[local];{$endif}
function  RGBA                  (         r,g,b,a            :byte              ): TColor;        inline; {$ifdef Linux}[local];{$endif}
function  ValToRGBA             (         r,g,b,a            :byte              ): TRGBA;         inline; {$ifdef Linux}[local];{$endif}
function  DWordToByte           (         pixel              :TColor            ): byte;          inline; {$ifdef Linux}[local];{$endif}
procedure ScalePix              (const    dst_pix_ptr,
                                          src_pix_ptr        :PInteger;
                                 const    s                  :TColor);                            inline; {$ifdef Linux}[local];{$endif}
function  PixCmp0               (         pixel              :TColor;
                                 const    pow                :byte              ): byte;          inline; {$ifdef Linux}[local];{$endif}
function  PixCmp0               (         pixel_ptr          :PInteger;
                                 const    pow                :byte              ): byte;          inline; {$ifdef Linux}[local];{$endif}
function  PixCmp1               (         pixel              :TColor;
                                 const    pow                :byte              ): byte;          inline; {$ifdef Linux}[local];{$endif}
function  PixCmp1               (         pixel_ptr          :PInteger;
                                 const    pow                :byte              ): byte;          inline; {$ifdef Linux}[local];{$endif}
function  SetColorInv           (         pixel              :TColor            ): TColor;        inline; {$ifdef Linux}[local];{$endif}
function  Color0                (         pixel              :TColor;
                                 const    r                  :byte=0;
                                 const    g                  :byte=0;
                                 const    b                  :byte=0;
                                 const    alpha              :byte=0;
                                 const    d_alpha            :byte=MAXBYTE;
                                 const    pow                :byte=64;
                                 const    d                  :smallint=0        ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure Color1                (         pixel_ptr          :PInteger;
                                 const    src_pix            :TColor);                            inline; {$ifdef Linux}[local];{$endif}
function  Additive0             (         pixel              :TColor;
                                 const    r                  :byte=0;
                                 const    g                  :byte=0;
                                 const    b                  :byte=0;
                                 const    alpha              :byte=0;
                                 const    d_alpha            :byte=MAXBYTE;
                                 const    pow                :byte=64;
                                 const    d                  :smallint=0        ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure Additive1             (         pixel_ptr          :PInteger;
                                 const    src_pix            :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure Additive2             (         pixel_ptr          :PInteger;
                                 const    src_pix            :TColor);                            inline; {$ifdef Linux}[local];{$endif}
function  AlphaBlend0           (         pixel              :TColor;
                                 const    r                  :byte=0;
                                 const    g                  :byte=0;
                                 const    b                  :byte=0;
                                 const    alpha              :byte=0;
                                 const    d_alpha            :byte=MAXBYTE;
                                 const    pow                :byte=64;
                                 const    d                  :smallint=0        ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure AlphaBlend1           (         pixel_ptr          :PInteger;
                                 const    src_pix            :TColor;
                                 const    alpha              :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure AlphaBlend2           (         pixel_ptr          :PInteger;
                                 const    src_pix            :TColor;
                                 const    alpha              :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure AlphaBlend3           (         pixel_ptr          :PInteger;
                                 const    r,g,b              :byte;
                                 const    alpha              :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure AlphaBlend4           (         dst_pix_ptr        :PInteger;
                                 const    src_pix_ptr        :PColor;
                                 const    alpha              :byte;
                                 const    h                  :integer);                           inline; {$ifdef Linux}[local];{$endif}
procedure AlphaBlend5           (         dst_pix_ptr        :PInteger;
                                 const    src_pix_ptr        :PColor;
                                 const    alpha              :byte;
                                 const    h                  :integer);                           inline; {$ifdef Linux}[local];{$endif}
function  Inverse0              (         pixel              :TColor;
                                 const    r                  :byte=0;
                                 const    g                  :byte=0;
                                 const    b                  :byte=0;
                                 const    alpha              :byte=0;
                                 const    d_alpha            :byte=MAXBYTE;
                                 const    pow                :byte=64;
                                 const    d                  :smallint=0        ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure Inverse1              (         pixel_ptr          :PInteger);                          inline; {$ifdef Linux}[local];{$endif}
function  Inverse2              (         pixel              :TColor            ): TColor;        inline; {$ifdef Linux}[local];{$endif}
function  Highlight0            (         pixel              :TColor;
                                 const    r                  :byte=0;
                                 const    g                  :byte=0;
                                 const    b                  :byte=0;
                                 const    alpha              :byte=0;
                                 const    d_alpha            :byte=MAXBYTE;
                                 const    pow                :byte=64;
                                 const    d                  :smallint=0        ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure Highlight1            (         pixel_ptr          :PInteger;
                                 const    pow                :byte);                              inline; {$ifdef Linux}[local];{$endif}
function  Highlight2            (         pixel              :TColor;
                                 const    pow                :byte              ): TColor;        inline; {$ifdef Linux}[local];{$endif}
function  HighlightLimit        (         pixel              :TColor;
                                 const    pow                :byte              ): TColor;        inline; {$ifdef Linux}[local];{$endif}
function  Darken0               (         pixel              :TColor;
                                 const    r                  :byte=0;
                                 const    g                  :byte=0;
                                 const    b                  :byte=0;
                                 const    alpha              :byte=0;
                                 const    d_alpha            :byte=MAXBYTE;
                                 const    pow                :byte=64;
                                 const    d                  :smallint=0        ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure Darken1               (         pixel_ptr          :PInteger;
                                 const    pow                :byte);                              inline; {$ifdef Linux}[local];{$endif}
function  Darken2               (         pixel              :TColor;
                                 const    pow                :byte              ): TColor;        inline; {$ifdef Linux}[local];{$endif}
function  DarkenLimit           (         pixel              :TColor;
                                 const    pow                :byte              ): TColor;        inline; {$ifdef Linux}[local];{$endif}
function  GrayscaleR0           (         pixel              :TColor;
                                 const    r                  :byte=0;
                                 const    g                  :byte=0;
                                 const    b                  :byte=0;
                                 const    alpha              :byte=0;
                                 const    d_alpha            :byte=MAXBYTE;
                                 const    pow                :byte=64;
                                 const    d                  :smallint=0        ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure GrayscaleR1           (         pixel_ptr          :PInteger);                          inline; {$ifdef Linux}[local];{$endif}
function  GrayscaleG0           (         pixel              :TColor;
                                 const    r                  :byte=0;
                                 const    g                  :byte=0;
                                 const    b                  :byte=0;
                                 const    alpha              :byte=0;
                                 const    d_alpha            :byte=MAXBYTE;
                                 const    pow                :byte=64;
                                 const    d                  :smallint=0        ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure GrayscaleG1           (         pixel_ptr          :PInteger);                          inline; {$ifdef Linux}[local];{$endif}
function  GrayscaleB0           (         pixel              :TColor;
                                 const    r                  :byte=0;
                                 const    g                  :byte=0;
                                 const    b                  :byte=0;
                                 const    alpha              :byte=0;
                                 const    d_alpha            :byte=MAXBYTE;
                                 const    pow                :byte=64;
                                 const    d                  :smallint=0        ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure GrayscaleB1           (         pixel_ptr          :PInteger);                          inline; {$ifdef Linux}[local];{$endif}
function  ColorizeR0            (         pixel              :TColor;
                                 const    r                  :byte=0;
                                 const    g                  :byte=0;
                                 const    b                  :byte=0;
                                 const    alpha              :byte=0;
                                 const    d_alpha            :byte=MAXBYTE;
                                 const    pow                :byte=64;
                                 const    d                  :smallint=0        ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure ColorizeR1            (         pixel_ptr          :PInteger;
                                 const    pow                :byte);                              inline; {$ifdef Linux}[local];{$endif}
function  ColorizeG0            (         pixel              :TColor;
                                 const    r                  :byte=0;
                                 const    g                  :byte=0;
                                 const    b                  :byte=0;
                                 const    alpha              :byte=0;
                                 const    d_alpha            :byte=MAXBYTE;
                                 const    pow                :byte=64;
                                 const    d                  :smallint=0        ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure ColorizeG1            (         pixel_ptr          :PInteger;
                                 const    pow                :byte);                              inline; {$ifdef Linux}[local];{$endif}
function  ColorizeB0            (         pixel              :TColor;
                                 const    r                  :byte=0;
                                 const    g                  :byte=0;
                                 const    b                  :byte=0;
                                 const    alpha              :byte=0;
                                 const    d_alpha            :byte=MAXBYTE;
                                 const    pow                :byte=64;
                                 const    d                  :smallint=0        ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure ColorizeB1            (         pixel_ptr          :PInteger;
                                 const    pow                :byte);                              inline; {$ifdef Linux}[local];{$endif}
function  BlurRGB4_             (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor            ): TColor;        inline; {$ifdef Linux}[local];{$endif}
function  BlurRGB5_             (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor            ): TColor;        inline; {$ifdef Linux}[local];{$endif}
function  BlurRGB8_             (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor            ): TColor;        inline; {$ifdef Linux}[local];{$endif}
function  BlurRGB9_             (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor            ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGB4              (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGB5              (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGB9              (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRB4              (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGR4              (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGB4              (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGG4              (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurBGB4              (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRBB4              (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRR4              (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGG4              (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurBBB4              (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
{RGB}
procedure BlurRGBProc0          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGBProc1          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGBProc2          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGBProc3          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGBProc4          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGBProc5          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGBProc6          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGBProc7          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGBProc8          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
{RRB}
procedure BlurRRBProc0          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRBProc1          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRBProc2          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRBProc3          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRBProc4          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRBProc5          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRBProc6          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRBProc7          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRBProc8          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
{RGR}
procedure BlurRGRProc0          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGRProc1          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGRProc2          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGRProc3          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGRProc4          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGRProc5          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGRProc6          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGRProc7          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGRProc8          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
{GGB}
procedure BlurGGBProc0          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGBProc1          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGBProc2          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGBProc3          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGBProc4          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGBProc5          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGBProc6          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGBProc7          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGBProc8          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
{RGG}
procedure BlurRGGProc0          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGGProc1          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGGProc2          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGGProc3          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGGProc4          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGGProc5          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGGProc6          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGGProc7          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGGProc8          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
{BGB}
procedure BlurBGBProc0          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurBGBProc1          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurBGBProc2          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurBGBProc3          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurBGBProc4          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurBGBProc5          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurBGBProc6          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurBGBProc7          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurBGBProc8          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
{RBB}
procedure BlurRBBProc0          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRBBProc1          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRBBProc2          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRBBProc3          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRBBProc4          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRBBProc5          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRBBProc6          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRBBProc7          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRBBProc8          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
{RRR}
procedure BlurRRRProc0          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRRProc1          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRRProc2          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRRProc3          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRRProc4          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRRProc5          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRRProc6          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRRProc7          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRRProc8          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
{GGG}
procedure BlurGGGProc0          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGGProc1          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGGProc2          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGGProc3          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGGProc4          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGGProc5          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGGProc6          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGGProc7          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGGProc8          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
{BBB}
procedure BlurBBBProc0          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurBBBProc1          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurBBBProc2          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurBBBProc3          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurBBBProc4          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurBBBProc5          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurBBBProc6          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurBBBProc7          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BlurBBBProc8          (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}

function  Contrast0             (         pixel              :TColor;
                                 const    r                  :byte=0;
                                 const    g                  :byte=0;
                                 const    b                  :byte=0;
                                 const    alpha              :byte=0;
                                 const    d_alpha            :byte=MAXBYTE;
                                 const    pow                :byte=64;
                                 const    d                  :smallint=0        ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure Contrast1             (         pixel_ptr          :PInteger;
                                 const    r,g,b              :byte;
                                 const    pow                :double);                            inline; {$ifdef Linux}[local];{$endif}
procedure Contrast2             (         pixel_ptr          :PInteger;
                                 const    r,g,b              :byte;
                                 const    pow                :integer);                           inline; {$ifdef Linux}[local];{$endif}
function  GammaPrecalc          (const    pow                :double            ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure Gamma                 (         pixel_ptr          :PInteger;
                                 const    pow                :integer);                           inline; {$ifdef Linux}[local];{$endif}
procedure RandNoise0            (         pixel_ptr          :PInteger;
                                 const    arr_ind            :integer;
                                 const    pow1,pow2          :byte              );                inline; {$ifdef Linux}[local];{$endif}
procedure RandNoise1            (         pixel_ptr          :PInteger;
                                 const    arr_ind            :integer;
                                 const    pow1,pow2          :byte              );                inline; {$ifdef Linux}[local];{$endif}
procedure RandNoise2            (         pixel_ptr          :PInteger;
                                 const    arr_ind            :integer;
                                 const    pow1,pow2          :byte              );                inline; {$ifdef Linux}[local];{$endif}
procedure RandNoise3            (         pixel_ptr          :PInteger;
                                 const    arr_ind            :integer;
                                 const    pow1,pow2          :byte              );                inline; {$ifdef Linux}[local];{$endif}
procedure RandNoise4            (         pixel_ptr          :PInteger;
                                 const    arr_ind            :integer;
                                 const    pow1,pow2          :byte              );                inline; {$ifdef Linux}[local];{$endif}
function  AdditiveDec0          (         pixel              :TColor;
                                 const    r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 const    alpha_fade         :byte;
                                 const    pow                :byte;
                                 const    d                  :smallint          ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure AdditiveDec1          (         pixel_ptr          :PInteger;
                                 const    src_pix            :TColor;
                                 const    alpha_fade         :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure AdditiveDec2          (         pixel_ptr          :PInteger;
                                 const    src_pix            :TColor);                            inline; {$ifdef Linux}[local];{$endif}
function  AlphaBlendDec0        (         pixel              :TColor;
                                 const    r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 const    alpha_fade         :byte;
                                 const    pow                :byte;
                                 const    d                  :smallint          ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure AlphaBlendDec1        (         pixel_ptr          :PInteger;
                                 const    src_pix            :TColor;
                                          alpha              :byte;
                                 const    alpha_fade         :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure AlphaBlendDec2        (         pixel_ptr          :PInteger;
                                 const    src_pix            :TColor;
                                 const    alpha_fade         :byte);                              inline; {$ifdef Linux}[local];{$endif}
function  InverseDec0           (         pixel              :TColor;
                                 const    r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 const    alpha_fade         :byte;
                                 const    pow                :byte;
                                 const    d                  :smallint          ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure InverseDec1           (         pixel_ptr          :PInteger;
                                 const    alpha_fade         :byte);                              inline; {$ifdef Linux}[local];{$endif}
function  HighlightDec0         (         pixel              :TColor;
                                 const    r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 const    alpha_fade         :byte;
                                 const    pow                :byte;
                                 const    d                  :smallint          ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure HighlightDec1         (         pixel_ptr          :PInteger;
                                 const    alpha_fade         :byte;
                                 const    pow                :byte=64);                           inline; {$ifdef Linux}[local];{$endif}
function  DarkenDec0            (         pixel              :TColor;
                                 const    r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 const    alpha_fade         :byte;
                                 const    pow                :byte;
                                 const    d                  :smallint          ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure DarkenDec1            (         pixel_ptr          :PInteger;
                                 const    alpha_fade         :byte;
                                 const    pow                :byte=64);                           inline; {$ifdef Linux}[local];{$endif}
function  GrayscaleRDec0        (         pixel              :TColor;
                                 const    r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 const    alpha_fade         :byte;
                                 const    pow                :byte;
                                 const    d                  :smallint          ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure GrayscaleRDec1        (         pixel_ptr          :PInteger;
                                 const    alpha_fade         :byte);                              inline; {$ifdef Linux}[local];{$endif}
function  GrayscaleGDec0        (         pixel              :TColor;
                                 const    r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 const    alpha_fade         :byte;
                                 const    pow                :byte;
                                 const    d                  :smallint          ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure GrayscaleGDec1        (         pixel_ptr          :PInteger;
                                 const    alpha_fade         :byte);                              inline; {$ifdef Linux}[local];{$endif}
function  GrayscaleBDec0        (         pixel              :TColor;
                                 const    r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 const    alpha_fade         :byte;
                                 const    pow                :byte;
                                 const    d                  :smallint          ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure GrayscaleBDec1        (         pixel_ptr          :PInteger;
                                 const    alpha_fade         :byte);                              inline; {$ifdef Linux}[local];{$endif}
function  ColorizeRDec0         (         pixel              :TColor;
                                 const    r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 const    alpha_fade         :byte;
                                 const    pow                :byte;
                                 const    d                  :smallint          ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure ColorizeRDec1         (         pixel_ptr          :PInteger;
                                 const    alpha_fade         :byte;
                                 const    pow                :byte);                              inline; {$ifdef Linux}[local];{$endif}
function  ColorizeGDec0         (         pixel              :TColor;
                                 const    r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 const    alpha_fade         :byte;
                                 const    pow                :byte;
                                 const    d                  :smallint          ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure ColorizeGDec1         (         pixel_ptr          :PInteger;
                                 const    alpha_fade         :byte;
                                 const    pow                :byte);                              inline; {$ifdef Linux}[local];{$endif}
function  ColorizeBDec0         (         pixel              :TColor;
                                 const    r,g,b              :byte;
                                          alpha,
                                          d_alpha            :byte;
                                 const    alpha_fade         :byte;
                                 const    pow                :byte;
                                 const    d                  :smallint          ): TColor;        inline; {$ifdef Linux}[local];{$endif}
procedure ColorizeBDec1         (         pixel_ptr          :PInteger;
                                 const    alpha_fade         :byte;
                                 const    pow                :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGB4Dec           (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    alpha_fade         :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRB4Dec           (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    alpha_fade         :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGR4Dec           (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    alpha_fade         :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGB4Dec           (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    alpha_fade         :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure BlurRGG4Dec           (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    alpha_fade         :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure BlurBGB4Dec           (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    alpha_fade         :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure BlurRBB4Dec           (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    alpha_fade         :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure BlurRRR4Dec           (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    alpha_fade         :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure BlurGGG4Dec           (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    alpha_fade         :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure BlurBBB4Dec           (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    alpha_fade         :byte);                              inline; {$ifdef Linux}[local];{$endif}
function  ContrastDec0          (         pixel_ptr          :PInteger;
                                 const    r,g,b              :byte;
                                 const    alpha_fade         :byte;
                                 const    pow                :integer           ): TColor;        inline; {$ifdef Linux}[local];{$endif}
function  ContrastDec1          (         dst_pix,src_pix    :TColor;
                                 const    alpha_fade         :byte;
                                 const    pow                :integer           ): TColor;        inline; {$ifdef Linux}[local];{$endif}
function  ContrastDec2          (         dst_pix,src_pix    :TColor;
                                 const    alpha_fade         :byte;
                                 const    pow                :integer           ): TColor;        inline; {$ifdef Linux}[local];{$endif}
{Test}
procedure PPTestFX              (         pixel_ptr          :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    pow                :byte);



(******************************* Array routines *******************************)
// Arrays addition:
procedure ArrAdd                (var      arr_src1           :T1Byte1Arr;
                                 const    arr_src2           :T2Byte1Arr;
                                 const    rct_dst            :TPtrect;
                                 const    arr_dst_width,
                                          arr_dst_height     :TColor);                                    {$ifdef Linux}[local];{$endif}
// 2D array to 1D array:
procedure Arr2DTo1D             (const    arr_src            :T2Byte1Arr;
                                 var      arr_dst            :T1Byte1Arr;
                                 const    arr_src_width,
                                          arr_src_height     :TColor);                                    {$ifdef Linux}[local];{$endif}
// Clear arrays:
procedure BmpClr                (         bmp                :Graphics.TBitmap);                  inline; {$ifdef Linux}[local];{$endif}
procedure ArrClr                (         arr_ptr            :PInteger;
                                 const    rct_dst            :TPtRect;
                                 const    arr_width          :TColor;
                                 const    val                :TColor=0);                          inline; {$ifdef Linux}[local];{$endif}
procedure ArrClr                (var      arr                :T1Byte1Arr;
                                 const    rct_dst            :TPtRect;
                                 const    arr_width          :TColor;
                                 const    val                :byte=0);                            inline; {$ifdef Linux}[local];{$endif}
procedure ArrClr                (var      arr                :TColorArr;
                                 const    rct_dst            :TPtRect;
                                 const    arr_width          :TColor;
                                 const    val                :TColor=0);                          inline; {$ifdef Linux}[local];{$endif}
procedure ArrClr                (var      arr_ptr            :PInteger;
                                 const    rct_dst            :TPtRect;
                                 const    arr_width          :TColor;
                                 const    val                :TColor;
                                          b1,b2              :boolean);                           inline; {$ifdef Linux}[local];{$endif}
procedure ArrClr                (var      arr                :T2Byte1Arr;
                                 const    rct_dst            :TPtRect;
                                 const    val                :byte=0);                            inline; {$ifdef Linux}[local];{$endif}
procedure ArrClr                (var      arr                :TPtPos3Arr;
                                 const    rct_dst            :TPtRect;
                                 const    arr_width          :TColor);                            inline; {$ifdef Linux}[local];{$endif}
// Clear alpha channel:
function  ArrClr                (         arr_ptr            :PInteger;
                                 const    rct_dst            :TPtRect;
                                 const    arr_width          :TColor;
                                 const    val                :TColor=0;
                                          b                  :boolean=False     ):byte;           inline; {$ifdef Linux}[local];{$endif}
// Fill arrays on bitmap:
procedure ArrFil                (const    arr0               :TPtPos3Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtrect;
                                 const    col                :TColor);
procedure ArrFil                (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtrect);
procedure ArrFilProc00          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc01          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc02          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc03          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc04          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc05          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc06          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc07          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc08          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc09          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc10          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc11          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc12          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc13          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc14          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc15          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc16          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc17          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc18          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc19          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc20          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc21          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc22          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc23          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc24          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
procedure ArrFilProc25          (const    arr0               :T1Byte1Arr;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width,
                                          bmp_height         :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    alpha              :byte=120);
// Copy fields of it_cnt items of arr_src separately to arr_dst0,arr_dst1,arr_dst2 from start_ind:
procedure FillArray             (const    arr_src            :TPtPosFArr;
                                 var      arr_dst0,arr_dst1  :TDublArr;
                                 var      arr_dst2           :TColorArr;
                                 const    start_ind,it_cnt   :TColor);
// Shell Sort:
procedure ShellSortX            (var      arr_dst0,arr_dst1  :TDublArr;
                                 var      arr_dst2           :TColorArr;
                                 const    start_ind,it_cnt   :integer);
procedure ShellSortY            (var      arr_dst0,arr_dst1  :TDublArr;
                                 var      arr_dst2           :TColorArr;
                                 const    start_ind,it_cnt   :integer);
// Sum of array elements:
function  ArrNzItSum            (const    arr                :T1Byte1Arr        ): TColor;                {$ifdef Linux}[local];{$endif}
function  ArrNzItSum            (const    arr                :TWordArr          ): TColor;                {$ifdef Linux}[local];{$endif}
function  ArrNzItSum            (const    arr                :TColorArr         ): TColor;                {$ifdef Linux}[local];{$endif}
// Non-zero items count:
function  ArrNzItCnt            (const    bmp_dst_ptr        :PInteger;
                                 const    rct_dst            :TPtRect;
                                 const    bmp_dst_width      :TColor;
                                 const    col                :TColor            ): TColor;                {$ifdef Linux}[local];{$endif}
function  ArrNzItCnt            (const    arr1_ptr           :PShortInt;
                                 const    arr2_ptr           :PByte;
                                 const    length             :integer           ): TColor;                {$ifdef Linux}[local];{$endif}
function  ArrNzItCnt            (const    arr1_ptr           :PShortInt;
                                 const    length             :integer;
                                          b                  :boolean           ): TColor;                {$ifdef Linux}[local];{$endif}
function  ArrNzItCnt            (const    arr                :T1Byte1Arr;
                                 const    max_arr_it_val     :TColor=MAXBYTE    ): TColor;                {$ifdef Linux}[local];{$endif}
function  ArrNzItCnt            (const    arr                :TWordArr;
                                 const    max_arr_it_val     :TColor=MAXWORD    ): TColor;                {$ifdef Linux}[local];{$endif}
function  ArrNzItCnt            (const    arr                :TColorArr;
                                 const    max_arr_it_val     :TColor=MAXDWORD   ): TColor;                {$ifdef Linux}[local];{$endif}
function  NzBitCnt              (const    arr                :T1Byte1Arr;
                                 const    bit_cnt            :word              ): TColor;                {$ifdef Linux}[local];{$endif}
// Test:
function  ArrNzItCnt            (const    grid_prop          :TGrid;
                                          grid_arr_ptr       :PInteger;
                                          pts_arr_ptr        :PPtPosF;
                                          dst_canvas         :TCanvas           ): TColor;                {$ifdef Linux}[local];{$endif}
// Create array with "visible" items:
procedure ArrNzItCrt            (const    arr1_src_ptr       :PShortInt;
                                 const    arr2_src_ptr       :PByte;
                                          arr_dst_ptr        :PColor;
                                 const    length1,
                                          length2            :integer);                                   {$ifdef Linux}[local];{$endif}
procedure ArrNzItCrt            (const    arr1_src_ptr       :PShortInt;
                                          arr_dst_ptr        :PColor;
                                 const    length1,
                                          length2            :integer);                                   {$ifdef Linux}[local];{$endif}
// Copy one array to another:
procedure ArrToArr1             (         arr_src_ptr        :PPtPosF;
                                          arr_dst_ptr        :PPtPosF;
                                          pts_cnt            :integer);                                   {$ifdef Linux}[local];{$endif}
procedure ArrToArr2             (         arr_src_ptr        :PPtPosF;
                                          arr_dst_ptr        :PPtPosF;
                                          pts_cnt            :integer);                                   {$ifdef Linux}[local];{$endif}
// Search for the first non-zero item starting from data_start; length is the number of items which need to be checked:
function  NotIndexByte          (         data_start         :PByte;
                                          length             :integer           ): integer;               {$ifdef Linux}[local];{$endif}
function  NotIndexWord          (         data_start         :PWord;
                                          length             :integer           ): integer;               {$ifdef Linux}[local];{$endif}
function  NotIndexDWord         (         data_start         :PDWord;
                                          length             :integer           ): integer;               {$ifdef Linux}[local];{$endif}
function  NotIndexQWord         (         data_start         :PQWord;
                                          length             :integer           ): integer;               {$ifdef Linux}[local];{$endif}
// Search for the last non-zero item starting from data_start; length is the number of items which need to be checked:
function  NotIndexWord2         (         data_start         :PWord;
                                          length             :integer           ): integer;               {$ifdef Linux}[local];{$endif}
// Fill primitives on array:
procedure SetGridProp0          (var      grid_prop          :TGrid;
                                 const    grid_rct_          :TPtRectF;
                                 const    shift_             :TPtPosF;
                                 const    grid_density_      :TPtPos;
                                 const    val_               :integer);                           inline; {$ifdef Linux}[local];{$endif}
procedure FillLnOnGrid          (const    grid_prop          :TGrid;
                                          grid_arr_ptr       :PInteger;
                                          pts_arr_ptr        :PPtPosF);                           inline; {$ifdef Linux}[local];{$endif}
procedure FillLnOnGrid          (const    grid_prop          :TGrid;
                                          grid_arr_ptr       :PInteger;
                                          pts_arr_ptr        :PPtPosF;
                                 const    pts_cnt            :integer);                           inline; {$ifdef Linux}[local];{$endif}
procedure FillPtOnGrid          (const    grid_prop          :TGrid;
                                          grid_arr_ptr       :PInteger;
                                          pts_arr_ptr        :PPtPosF);                           inline; {$ifdef Linux}[local];{$endif}
procedure FillPtOnGrid          (const    grid_prop          :TGrid;
                                          grid_arr_ptr       :PInteger;
                                          pts_arr_ptr        :PPtPosF;
                                 const    pts_cnt            :integer);                           inline; {$ifdef Linux}[local];{$endif}
procedure SetGridProp1          (var      grid_prop          :TGrid;
                                          grid_arr_ptr       :PInteger;
                                 var      rct_inn,rct_out    :TPtRectF);                          inline; {$ifdef Linux}[local];{$endif}
procedure FillRtOnGrid          (const    grid_prop          :TGrid;
                                          grid_arr_ptr       :PInteger;
                                          b                  :boolean);                           inline; {$ifdef Linux}[local];{$endif}
procedure FillRtOnGrid          (const    grid_prop          :TGrid;
                                          grid_arr_ptr       :PInteger);                          inline; {$ifdef Linux}[local];{$endif}



(******************************** Linked lists ********************************)
procedure LinkArrIt             (const    arr                :T1Byte1Arr;
                                 var      list_as_arr        :TListItemArr);
procedure AddListItem           (const    pt_x               :integer;
                                 var      first_item,p1,p2   :PIList);
procedure AddListItem           (const    pt                 :TPtPosF;
                                 var      first_item,p1,p2   :PFList);
procedure ArrToList1            (const    arr_src            :TIntrArr;
                                 var      first_item,p1,p2   :PIList);
procedure ArrToList2            (const    arr_src            :TIntrArr;
                                 var      first_item,p1,p2   :PIList);
procedure ListToArr             (var      arr_dst            :TIntrArr;
                                 var      first_item,p1,p2   :PIList);
procedure ListToArr             (var      arr_dst            :TPtPosFArr;
                                 var      first_item,p1,p2   :PFList);
procedure FreeList1             (var      first_item,p1,p2   :PIList);
procedure FreeList2             (var      first_item,p1,p2   :PFList);



(***************************** Edge anti-aliasing *****************************)
procedure BorderCalc00          (const    arr_src_ptr        :PInteger;
                                 var      arr_dst            :T1Byte1Arr;
                                 const    ft_cnt             :TColor;
                                 const    arr_src_width,
                                          arr_src_height,
                                          arr_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    background_color   :TColor);                                    {$ifdef Linux}[local];{$endif}
procedure BorderCalc01          (const    arr_src_ptr        :PInteger;
                                 var      arr_dst            :T1Byte1Arr;
                                 const    ft_cnt             :TColor;
                                 const    arr_src_width,
                                          arr_src_height,
                                          arr_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    background_color   :TColor);                                    {$ifdef Linux}[local];{$endif}
procedure BorderCalc02          (const    arr_src            :T1Byte1Arr;
                                 var      arr_dst            :T1Byte1Arr;
                                 const    arr_src_width,
                                          arr_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 var      aa_nz_arr_it_cnt   :TColor);                                    {$ifdef Linux}[local];{$endif}
procedure BorderCalc0           (const    arr_src_ptr        :PInteger;
                                 var      arr_dst            :T1Byte1Arr;
                                 const    arr_src_width,
                                          arr_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 var      aa_nz_arr_it_cnt   :TColor;
                                 const    background_color   :TColor);                                    {$ifdef Linux}[local];{$endif}
procedure BorderCalc1           (const    arr_src_ptr        :PInteger;
                                 var      arr_dst            :T1Byte1Arr;
                                 const    arr_src_width,
                                          arr_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 var      aa_nz_arr_it_cnt   :TColor);                                    {$ifdef Linux}[local];{$endif}
procedure BorderCalc1           (const    arr_src            :TColorArr;
                                 var      arr_dst            :T1Byte1Arr;
                                 const    arr_src_width,
                                          arr_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 var      aa_nz_arr_it_cnt   :TColor);                                    {$ifdef Linux}[local];{$endif}
procedure BorderCalc1           (const    arr_src            :T1Byte1Arr;
                                 var      arr_dst            :T1Byte1Arr;
                                 const    arr_src_width,
                                          arr_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 var      aa_nz_arr_it_cnt   :TColor);                                    {$ifdef Linux}[local];{$endif}
// Mixed: image has circle and other contours:
procedure BorderCalc20          (const    arr_src_ptr        :PInteger;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 const    arr_src_width,
                                          arr_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                                    {$ifdef Linux}[local];{$endif}
procedure BorderCalc20          (const    arr_src            :TColorArr;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 const    arr_src_width,
                                          arr_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                                    {$ifdef Linux}[local];{$endif}
procedure BorderCalc20          (const    arr_src            :T1Byte1Arr;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 const    arr_src_width,
                                          arr_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                                    {$ifdef Linux}[local];{$endif}
// Image has only circle contours:
procedure BorderCalc21          (const    arr_src_ptr        :PInteger;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 const    arr_src_width,
                                          arr_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                                    {$ifdef Linux}[local];{$endif}
procedure BorderCalc21          (const    arr_src            :TColorArr;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 const    arr_src_width,
                                          arr_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                                    {$ifdef Linux}[local];{$endif}
procedure BorderCalc21          (const    arr_src            :T1Byte1Arr;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 const    arr_src_width,
                                          arr_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                                    {$ifdef Linux}[local];{$endif}
// Image has no circle contours:
procedure BorderCalc22          (const    arr_src_ptr        :PInteger;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 const    arr_src_width,
                                          arr_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                                    {$ifdef Linux}[local];{$endif}
procedure BorderCalc22          (const    arr_src            :TColorArr;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 const    arr_src_width,
                                          arr_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                                    {$ifdef Linux}[local];{$endif}
procedure BorderCalc22          (const    arr_src            :T1Byte1Arr;
                                 var      arr_dst            :T1Byte1Arr;
                                 var      arr_alpha          :TAALnArr;
                                 const    arr_src_width,
                                          arr_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 out      line_cnt           :TColor);                                    {$ifdef Linux}[local];{$endif}

procedure BorderFill            (const    arr_src            :TAALnArr;
                                 const    rct_dst_left,
                                          rct_dst_top        :integer;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width          :TColor;
                                 const    line_cnt           :TColor;
                                 const    col                :TColor;
                                          args               :TFunc0Args;
                                          Func0              :TFunc0);
procedure BorderFill            (const    arr_src            :TAALnArr;
                                 const    rct_dst_left,
                                          rct_dst_top        :integer;
                                 const    bmp_ptr            :PInteger;
                                 const    bmp_width          :TColor;
                                 const    line_cnt           :TColor;
                                 const    col                :TColor;
                                          args               :TFunc0Args);
procedure BorderFill            (const    arr_src            :TAALnArr;
                                 const    rct_dst_left,
                                          rct_dst_top        :integer;
                                 const    bmp_ptr            :PByte;
                                 const    bmp_width          :TColor;
                                 const    line_cnt           :TColor;
                                 const    col                :TColor;
                                          args               :TFunc0Args);
// One-pixel border-blur calculation:
procedure BorderPixCh           (         arr_src_ptr        :PInteger;
                                 const    arr_src_width      :TColor;
                                 const    background_color   :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BorderPixCh           (         arr_src_ptr        :PInteger;
                                 const    arr_src_width      :TColor;
                                 const    alpha_color        :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure BorderPixCh           (         arr_src_ptr        :PInteger;
                                 const    arr_src_width      :TColor;
                                 const    alpha_color        :byte;
                                 const    alpha_mask         :TColor);                            inline; {$ifdef Linux}[local];{$endif}
// Border blur:
procedure BorderBlur            (const    arr_src_ptr        :PInteger;
                                 var      arr_dst            :T1Byte1Arr;
                                 const    arr_src_width,
                                          arr_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    background_color   :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BorderBlur            (const    arr_src_ptr        :PInteger;
                                 const    arr_src_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    alpha_color        :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure BorderBlur            (const    arr_src_ptr        :PInteger;
                                 const    arr_src_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    alpha_color        :byte;
                                 const    mask               :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure BorderBlur            (const    arr_src_ptr        :PByte;
                                 const    arr_dst_ptr        :PInteger;
                                 const    arr_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    alpha_color        :byte;
                                 const    mask               :TColor);                            inline; {$ifdef Linux}[local];{$endif}



(******************************* Bitmap loading *******************************)
function  CrtTPicInstFromHDDSrc (const    location           :string            ): TPicture;      inline; {$ifdef Linux}[local];{$endif}
function  CrtTBmpInstFromImgLst (const    ImgLstGetBmp       :TProc1;
                                 const    img_ind            :TColor=0          ): TBitmap;       inline; {$ifdef Linux}[local];{$endif}
function  CrtTBmpInst           (const    bmp_src            :TBitmap;
                                 var      bmp_dst_ptr        :PInteger          ): TBitmap;       inline; {$ifdef Linux}[local];{$endif}
function  CrtTBmpInst           (const    bmp_dst_width,
                                          bmp_dst_height     :TColor;
                                 var      bmp_src_ptr        :PInteger          ): TBitmap;       inline; {$ifdef Linux}[local];{$endif}



(****************************** Points transform ******************************)
// (Align points to horizontal line, from left to right) Выровнять точки по горизонтали, слева направо:
procedure PtsRawH               (var      pts                :TPtPosFArr;
                                 const    start_ind,
                                          end_ind            :TColor;
                                 const    pts_dist           :TColor);                            inline; {$ifdef Linux}[local];{$endif}
// (Align points to vertical line, from top to bottom) Выровнять точки по вертикали, сверху вниз:
procedure PtsRawV               (var      pts                :TPtPosFArr;
                                 const    start_ind,
                                          end_ind            :TColor;
                                 const    pts_dist           :TColor);                            inline; {$ifdef Linux}[local];{$endif}
// (Reset points position) Восстановить позицию точек:
procedure PtsRes                (const    fst_pt_ptr1,
                                          fst_pt_ptr2        :PPtPosF;
                                 const    pts_cnt            :TColor;
                                 const    pt_pos_curr,
                                          pt_pos_prev        :TPtPosF);                       deprecated; {$ifdef Linux}[local];{$endif}
// (Points pivot) Ось точек:
procedure PtsPvt                (var      pvt                :TPtPosF;
                                 var      pts                :TPtPosFArr;
                                 const    pts_cnt            :TColor);                            inline; {$ifdef Linux}[local];{$endif}
// (Points moving) Перемещение точек:
procedure PtsMov                (const    pvt                :TPtPos;
                                 var      pts                :TPtPosFArr;
                                 const    fst_ind,
                                          lst_ind            :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure PtsMov                (const    pvt                :TPtPos;
                                 var      rct                :TPtRect);                           inline; {$ifdef Linux}[local];{$endif}
procedure PtsMov                (const    pvt                :TPtPos;
                                 var      rct                :TRect);                             inline; {$ifdef Linux}[local];{$endif}
procedure PtsMov                (const    pvt                :TPtPos;
                                 var      rct                :TPtRectF);                          inline; {$ifdef Linux}[local];{$endif}

procedure WndSht                (const    outer_rect         :TPtRect;
                                 const    inner_rect         :TPtPosFArr;
                                 var      shift_power        :integer;
                                 const    mul                :integer);                           inline; {$ifdef Linux}[local];{$endif}
procedure MDCalc                (var      rct                :TPtRectF;
                                 const    mov_dir            :TMovingDirection;
                                 const    parallax_shift     :TPtPosF);                           inline; {$ifdef Linux}[local];{$endif}
// (Points scaling) Масштабирование точек:
procedure PtsScl                (const    pvt                :TPtPosF;
                                 var      pts                :TPtPosFArr;
                                          scl_mul            :TPtPosF;
                                 const    scl_dir            :TSclDir;
                                          fst_ind            :TColor=0;
                                          lst_ind            :TColor=0);                          inline; {$ifdef Linux}[local];{$endif}
procedure PtsScl                (const    pvt                :TPtPosF;
                                 var      rct                :TPtRectF;
                                          scl_mul            :TPtPosF;
                                 const    scl_dir            :TSclDir);                           inline; {$ifdef Linux}[local];{$endif}
procedure PtsScl                (const    pvt                :TPtPosF;
                                 const    rct_src            :TPtRect;
                                 var      rct_dst            :TPtRectF;
                                          scl_mul            :TPtPosF;
                                 const    scl_dir            :TSclDir);                           inline; {$ifdef Linux}[local];{$endif}
procedure PtsScl                (const    pvt                :TPtPosF;
                                 const    rct_src            :TPtRectF;
                                 var      rct_dst            :TPtRectF;
                                          scl_mul            :TPtPosF;
                                 const    scl_dir            :TSclDir);                           inline; {$ifdef Linux}[local];{$endif}
function  GetDir1               (         prev_pos,
                                          curr_pos,
                                          pvt                :TPtPosF           ): TSclDir;       inline; {$ifdef Linux}[local];{$endif}
function  GetDir2               (         prev_pos,
                                          curr_pos,
                                          pvt                :TPtPosF           ): TSclDir;       inline; {$ifdef Linux}[local];{$endif}
procedure SetMul                (         prev_pos,
                                          curr_pos,
                                          pvt                :TPtPosF;
                                 var      scl_mul            :TPtPosF;
                                 const    scl_dir            :TSclDir);                           inline; {$ifdef Linux}[local];{$endif}
// (Points rotation) Вращение точек:
procedure GetRot                (const    pvt                :TPtPos;
                                 const    angle              :double;
                                 var      c,s,v,w            :double);                            inline; {$ifdef Linux}[local];{$endif}
procedure GetRot                (const    pvt                :TPtPos;
                                 const    angle              :double;
                                 var      c,s,v,w            :integer;
                                 const    x,y                :integer);                           inline; {$ifdef Linux}[local];{$endif}
procedure GetRot                (const    pvt                :TPtPosF;
                                 const    angle              :double;
                                 var      c,s,v,w            :double);                            inline; {$ifdef Linux}[local];{$endif}
procedure GetRotRound           (const    pvt                :TPtPos;
                                 const    angle              :double;
                                 var      c,s,v,w            :double;
                                 const    x,y                :integer);                           inline; {$ifdef Linux}[local];{$endif}
procedure GetRotNotRound        (const    pvt                :TPtPos;
                                 const    angle              :double;
                                 var      c,s,v,w            :double;
                                 const    x,y                :integer);                           inline; {$ifdef Linux}[local];{$endif}
procedure GetRotNotRound2       (const    pvt                :TPtPos;
                                 const    angle              :double;
                                 var      c,s,v,w            :integer;
                                 const    x,y                :integer);                           inline; {$ifdef Linux}[local];{$endif}
procedure PtsRot                (var      pts                :TPtPosFArr;
                                 const    pts_cnt            :TColor;
                                 const    angle              :double;
                                 var      c,s,v,w            :double;
                                 const    fst_ind            :TColor=0);                          inline; {$ifdef Linux}[local];{$endif}
function  PtsRot                (         rct                :TPtRectF;
                                 const    angle              :double;
                                 var      c,s,v,w            :double;
                                 const    margin             :TColor=1          ): TPtRectF;      inline; {$ifdef Linux}[local];{$endif}
function  PtsRot                (         rct                :TRect;
                                 const    angle              :double;
                                 var      c,s,v,w            :double;
                                 const    margin             :TColor=1          ): TRect;         inline; {$ifdef Linux}[local];{$endif}
function  PtsRot                (         rct                :TPtRect;
                                 const    angle              :double;
                                 var      c,s,v,w            :double;
                                 const    margin             :TColor=1          ): TPtRect;       inline; {$ifdef Linux}[local];{$endif}
// (Points simplification) Точечное упрощение:
function  PtsSimplify0          (const    pts_arr_ptr        :PPtPosF;
                                          ind_arr_ptr        :PColor;
                                 const    pts_cnt            :TColor;
                                 const    angle              :double            ): integer;       inline; {$ifdef Linux}[local];{$endif}
function  PtsSimplify1          (const    pts_arr_ptr        :PPtPosF;
                                          ind_arr_ptr        :PColor;
                                 const    pts_cnt            :TColor;
                                 const    distance           :integer           ): integer;       inline; {$ifdef Linux}[local];{$endif}



(************************** Miscellaneous primitives **************************)
// Color info:
procedure SetColorInfo          (constref pix_col_           :TColor;
                                 var      color_info         :TColorInfo);                        inline; {$ifdef Linux}[local];{$endif}
procedure SetColorInfo1         (constref pix_col_           :TColor;
                                 var      color_info         :TColorInfo);                        inline; {$ifdef Linux}[local];{$endif}
procedure SetColorInfo2         (constref pix_col_           :TColor;
                                 var      color_info         :TColorInfo;
                                          alpha1             :byte=180;
                                          alpha2             :byte=080);                          inline; {$ifdef Linux}[local];{$endif}
// (Line segment) Отрезок:
function  LineS                 (constref v0,w0,k ,b ,r      :double;
                                 constref ln_kind            :byte              ): TLnPosF;       inline; {$ifdef Linux}[local];{$endif}
function  LineS                 (constref v0,w0,v1,w1,r      :double            ): TLnPosF;       inline; {$ifdef Linux}[local];{$endif}
function  LineS                 (constref v0,w0,v1,w1,r      :double;
                                 constref dir                :shortint          ): TPtPosF;       inline; {$ifdef Linux}[local];{$endif}
// (Line direction) Направление линии:
procedure LineD                 (constref x0,y0,x1,y1        :double;
                                 var      dir_x,dir_y        :shortint);                          inline; {$ifdef Linux}[local];{$endif}
procedure LineD                 (constref vec                :TLnPosF;
                                 var      dir_x,dir_y        :shortint);                          inline; {$ifdef Linux}[local];{$endif}
// Monochrome line:
procedure Line                  (         x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo);                        inline; {$ifdef Linux}[local];{$endif}
procedure Line                  (         x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure Line                  (         x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :byte);                              inline; {$ifdef Linux}[local];{$endif}
// Line segments intersection:
function  LineSI                (         x0,y0,x1,y1,
                                          v0,w0,v1,w1        :double            ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  LineSI                (         x0,y0,x1,y1,
                                          v0,w0,v1,w1        :integer           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
// Line clipping:
function  LineCF                (var      x0,y0,x1,y1        :double;
                                 constref rct_clp            :TPtRectF          ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  LineC                 (var      x0,y0,x1,y1        :integer;
                                 constref rct_clp            :TPtRect           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
// Monochrome anti-aliased line(width - 1 pixel):
procedure LineA                 (         x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo);                        inline; {$ifdef Linux}[local];{$endif}
procedure LineAC                ({var}    x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref color_info         :TColorInfo);                        inline; {$ifdef Linux}[local];{$endif}
// Monochrome anti-aliased broken clipped line(width - 1 pixel):
procedure LineABC               (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref shift              :TPtPos;
                                          exp_               :boolean=False);                     inline; {$ifdef Linux}[local];{$endif}
// Gradient(highlight) anti-aliased broken clipped line(width - 1 pixel):
procedure LineABCG              (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect;
                                 var      color_info         :TColorInfo;
                                 constref shift              :TPtPos;
                                          exp_               :boolean=False);                     inline; {$ifdef Linux}[local];{$endif}
// Equidistant line(width - 1 pixel):
function  LineE1                (constref v0,w0,v1,w1,rad    :double            ): TLnPosF;       inline; {$ifdef Linux}[local];{$endif}
function  LineE2                (constref v0,w0,v1,w1,rad    :double            ): TLnPosF;       inline; {$ifdef Linux}[local];{$endif}
// Equidistant curve for antialiased broken clipped line(width - 1 pixel):
procedure LineABCE              (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);                     inline; {$ifdef Linux}[local];{$endif}
// Equidistant curve for not anti-aliased broken clipped line(width - 1 pixel):
procedure LineBCE               (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);                     inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE               (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref val                :TColor;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);                     inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE               (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref val                :byte;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);                     inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE               (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);                     inline; {$ifdef Linux}[local];{$endif}
// Equidistant curve for not anti-aliased broken clipped line(width - 1 pixel):
procedure LineBCE2              (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);                     inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE2              (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref val                :TColor;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);                     inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE2              (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref val                :byte;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);                     inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE2              (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);                     inline; {$ifdef Linux}[local];{$endif}
// Equidistant curve for not anti-aliased broken clipped line(width - 3 pixel):
procedure LineBCE3              (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);                     inline; {$ifdef Linux}[local];{$endif}
procedure LineBCE3              (constref pts                :TPtPosFArr;
                                 constref start_ind,
                                          end_ind            :TColor;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref shift              :TPtPos;
                                 constref rad                :TColor;
                                          exp_               :boolean=False);                     inline; {$ifdef Linux}[local];{$endif}
// Resilient line(width - 1 pixel):
procedure LineR0                (constref x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 const    rct_clp            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref seg_cnt            :TColor);                            inline; {$ifdef Linux}[local];{$endif}
function LineR1                 (constref x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 const    rct_clp            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref seg_length         :TColor            ): TPtPosF;       inline; {$ifdef Linux}[local];{$endif}
// Line grid(width - 1 pixel):
procedure Grid                  (const    x,y                :integer;
                                 const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_clp            :TPtRect;
                                 const    color_info         :TColorInfo;
                                 const    arr_cell_width,
                                          arr_cell_height,
                                          cnt_x,cnt_y        :TColor);                            inline; {$ifdef Linux}[local];{$endif}
// Monochrome horizontal line(width - 1 pixel):
function  LineHC                (var      x0,y0,x1           :integer;
                                 constref rct_clp            :TPtRect           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
procedure LineH                 (         x0,y0,x1           :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo);                        inline; {$ifdef Linux}[local];{$endif}
procedure LineH                 (         x0,y0,x1           :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure LineH                 (         x0,y0,x1           :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :byte);                              inline; {$ifdef Linux}[local];{$endif}
// Monochrome vertical line(width - 1 pixel):
function  LineVC                (var      x0,y0,y1           :integer;
                                 constref rct_clp            :TPtRect           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
procedure LineV                 (         x0,y0,y1           :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo);                        inline; {$ifdef Linux}[local];{$endif}
procedure LineV                 (         x0,y0,y1           :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure LineV                 (         x0,y0,y1           :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :byte);                              inline; {$ifdef Linux}[local];{$endif}
// Point:
procedure Point                 (const    x,y                :integer;
                                 const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    color_info         :TColorInfo);                        inline; {$ifdef Linux}[local];{$endif}
procedure Point                 (const    x,y                :integer;
                                 const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_clp            :TPtRect;
                                 const    color_info         :TColorInfo);                        inline; {$ifdef Linux}[local];{$endif}
procedure Point                 (const    x,y                :integer;
                                 const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_clp            :TPtRect;
                                 const    color_info         :TColorInfo;
                                 const    alpha_fade         :byte);                              inline; {$ifdef Linux}[local];{$endif}
// Point collisin drawing on array:
function  PointCollDraw         (const    x,y                :integer;
                                 const    bmp_src_width      :TColor;
                                 const    rct_clp            :TPtRect;
                                 var      bmp_src            :T1Byte1Arr        ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  PointCollDraw         (const    x,y                :integer;
                                 const    bmp_src_width      :TColor;
                                 const    rct_clp            :TPtRect;
                                 const    bmp_src            :T1Byte1Arr;
                                 const    b                  :byte              ): boolean;       inline; {$ifdef Linux}[local];{$endif}
// Rectangle:
procedure SetRctDupId           (var      sln_prop_var       :TCurveProp);                        inline; {$ifdef Linux}[local];{$endif}
procedure SetEdsWidth           (var      sln_prop_var       :TCurveProp);                        inline; {$ifdef Linux}[local];{$endif}
procedure SetRctWidth           (var      sln_prop_var       :TCurveProp);                        inline; {$ifdef Linux}[local];{$endif}
procedure SetRctHeight          (var      sln_prop_var       :TCurveProp);                        inline; {$ifdef Linux}[local];{$endif}
procedure SetRctValues          (var      sln_prop_var       :TCurveProp);                        inline; {$ifdef Linux}[local];{$endif}
procedure Rectangle             (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width,
                                          bmp_dst_height     :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref sln_prop_var       :TCurveProp);                        inline; {$ifdef Linux}[local];{$endif}
procedure Rectangle             (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width,
                                          bmp_dst_height     :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref sln_prop_var       :TCurveProp;
                                 constref PPFloodFillProc    :TProc4);                            inline; {$ifdef Linux}[local];{$endif}
procedure Rectangle             (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width,
                                          bmp_dst_height     :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref sln_prop_var       :TCurveProp;
                                 constref PPFloodFillProc    :TProc4_1);                          inline; {$ifdef Linux}[local];{$endif}
procedure Rectangle             (constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width,
                                          bmp_dst_height     :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure Rectangle             (         x0,y0,x1,y1        :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_dst            :TPtRect;
                                 constref col                :TColor);                            inline; {$ifdef Linux}[local];{$endif}
// Rhombus:
procedure Rombus                (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo);                        inline; {$ifdef Linux}[local];{$endif}
// Circle drawing(midpoint algorithm):
procedure Circle                (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref color_info         :TColorInfo);                        inline; {$ifdef Linux}[local];{$endif}
procedure Circle                (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure Circle                (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure Circle                (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :TColor;
                                 constref val                :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure Circle                (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure CircleC               (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref color_info         :TColorInfo);                        inline; {$ifdef Linux}[local];{$endif}
procedure CircleC               (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref val                :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure CircleC               (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect);                            inline; {$ifdef Linux}[local];{$endif}
procedure CircleC               (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect;
                                 constref val                :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleC               (constref x0,y0,rad          :integer;
                                 constref bmp_dst_ptr        :PByte;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_clp            :TPtRect);                            inline; {$ifdef Linux}[local];{$endif}
// Wave search:
function  CircleW               (constref x0,y0,rad          :integer;
                                 constref arr_dst            :TPtPos3Arr;
                                 constref arr_dst_width      :TColor;
                                 var      pt                 :TPtPosF           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
function  CircleWC              (constref x0,y0,rad          :integer;
                                 constref arr_dst            :TPtPos3Arr;
                                 constref arr_dst_width      :TColor;
                                 constref rct_clp            :TPtRect;
                                 var      pt                 :TPtPosF           ): boolean;       inline; {$ifdef Linux}[local];{$endif}
// Circle floodfill:
procedure CircleFloodFill0      (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam               :TColor;
                                 constref pow                :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleFloodFill1      (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam               :TColor;
                                 constref pow                :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleFloodFill2      (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam               :TColor;
                                 constref pow                :byte);                              inline; {$ifdef Linux}[local];{$endif}
// Spotlight:
procedure SqrtArr0Init          (const    w                  :integer=3840;
                                 const    h                  :integer=2160);                      inline; {$ifdef Linux}[local];{$endif}
procedure CircleHighlight000    (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam               :TColor;
                                 constref pow                :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleHighlight001    (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam               :TColor;
                                 constref pow                :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleHighlight002    (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam               :TColor;
                                 constref pow                :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleHighlight003    (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam               :TColor;
                                 constref pow                :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleHighlight004    (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam               :TColor;
                                 constref pow                :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleHighlight005    (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam               :TColor;
                                 constref pow                :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleHighlight006    (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam               :TColor;
                                 constref pow                :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleHighlight007    (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam               :TColor;
                                 constref pow                :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleHighlight008    (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam               :TColor;
                                 constref pow                :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleHighlight009    (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam               :TColor;
                                 constref pow                :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleHighlight010    (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam               :TColor;
                                 constref pow                :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleHighlight011    (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam               :TColor;
                                 constref pow                :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleHighlight100    (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam,mrg           :TColor;
                                 constref pow1,pow2          :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleHighlight101    (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam,mrg           :TColor;
                                 constref pow1,pow2          :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleHighlight102    (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam,mrg           :TColor;
                                 constref pow1,pow2          :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleHighlight103    (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam,mrg           :TColor;
                                 constref pow1,pow2          :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleHighlight104    (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam,mrg           :TColor;
                                 constref pow1,pow2          :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleHighlight105    (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam,mrg           :TColor;
                                 constref pow1,pow2          :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleHighlight106    (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam,mrg           :TColor;
                                 constref pow1,pow2          :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleHighlight107    (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam,mrg           :TColor;
                                 constref pow1,pow2          :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleHighlight108    (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam,mrg           :TColor;
                                 constref pow1,pow2          :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleHighlight109    (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam,mrg           :TColor;
                                 constref pow1,pow2          :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleHighlight110    (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam,mrg           :TColor;
                                 constref pow1,pow2          :byte);                              inline; {$ifdef Linux}[local];{$endif}
procedure CircleHighlight111    (constref x,y                :integer;
                                 constref bmp_dst_ptr        :PInteger;
                                 constref bmp_dst_width      :TColor;
                                 constref rct_out            :TPtRect;
                                 constref color_info         :TColorInfo;
                                 constref diam,mrg           :TColor;
                                 constref pow1,pow2          :byte);                              inline; {$ifdef Linux}[local];{$endif}
// Text:
procedure SetTextInfo           (constref dst_canvas         :TCanvas;
                                 constref height_            :integer      =27;
                                 constref font_color         :TColor       =$006C754A;
                                 constref font_name          :string       ='AR CENA';
                                 constref font_charset       :TFontCharSet =ANSI_CHARSET;
                                 constref font_quality       :TFontQuality =fqAntialiased;
                                 constref pen_mode           :TFPPenMode   =pmXor;
                                 constref brush_style        :TFPBrushStyle=bsClear);             inline; {$ifdef Linux}[local];{$endif}
procedure Text                  (constref x,y                :integer;
                                 constref dst_canvas         :TCanvas;
                                 constref text_              :string);                            inline; {$ifdef Linux}[local];{$endif}
// ...
procedure TextGrid              (constref x,y                :integer;
                                 constref dst_canvas         :TCanvas;
                                 const    arr_cell_width,
                                          arr_cell_height,
                                          cnt_x,cnt_y        :TColor);                            inline; {$ifdef Linux}[local];{$endif}



(********************************** Blitters **********************************)
// Get bitmap handle:
function  GetBmpHandle          (         bmp                :TBitmap           ): PInteger{pointer}; inline;
procedure GLBitmapInit          (         tex_id             :TColor;
                                          bmp                :Graphics.TBitmap;
                                          b                  :boolean);                           inline;
// Drawing of GL canvas:
procedure CnvDraw0              (         left,
                                          top,
                                          right,
                                          bottom             :GLfloat;
                                 const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width,
                                          bmp_dst_height     :integer);                           inline; {$ifdef Linux}[local];{$endif}
procedure CnvDraw1              (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width,
                                          bmp_dst_height     :integer);                           inline; {$ifdef Linux}[local];{$endif}
procedure CnvDraw2              (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width,
                                          bmp_dst_height     :integer;
                                 const    alpha_pow          :single=1.0;
                                 const    pixel_format       :GLInt=GL_RGBA);                     inline; {$ifdef Linux}[local];{$endif}
// GL camera pos.:
procedure GLCameraSetPos        (         x,y                :GLfloat;
                                 const    bmp_dst_width,
                                          bmp_dst_height     :integer);                           inline; {$ifdef Linux}[local];{$endif}
// (Store color channel into integer array) Сохранить цветовой канал в целочисленный массив:
procedure BmpToArr              (const    bmp_src_ptr        :PInteger;
                                 var      bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_src_height     :TColor;
                                 var      bmp_dst_width,
                                          bmp_dst_height     :TColor;
                                 const    bmp_src_rct        :TPtRect;
                                 var      arr_dst            :TColorArr);                         inline; {$ifdef Linux}[local];{$endif}
// Copy one canvas to another:
procedure CnvToCnv              (         rct_dst            :TPtRect;
                                          cnv_dst,
                                          cnv_src            :TCanvas;
                                          copy_mode          :integer);                           inline; {$ifdef Linux}[local];{$endif}
// Blitter0:
procedure BitBlt0               (var      arr_src            :TColorArr;
                                 const    rct_src_width,
                                          rct_src_height,
                                          rct_dst_left,
                                          rct_dst_top        :integer);                           inline; {$ifdef Linux}[local];{$endif}
// Blitter1:
procedure BitBlt1               (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width,
                                          rct_dst_left,
                                          rct_dst_top        :integer;
                                 const    rct_src            :TPtRect);                           inline;
procedure BitBlt1               (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width,
                                          rct_src_left,
                                          rct_src_top,
                                          rct_src_width,
                                          rct_src_height,
                                          rct_dst_left,
                                          rct_dst_top        :integer);                           inline;
// Blitter1(x-inverted):
procedure BitBlt1X              (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width,
                                          rct_dst_left,
                                          rct_dst_top        :integer;
                                 const    rct_src            :TPtRect);                           inline;
procedure BitBlt1X              (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width,
                                          rct_src_left,
                                          rct_src_top,
                                          rct_src_width,
                                          rct_src_height,
                                          rct_dst_left,
                                          rct_dst_top        :integer);                           inline;
// Blitter1(y-inverted):
procedure BitBlt1Y              (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width,
                                          rct_dst_left,
                                          rct_dst_top        :integer;
                                 const    rct_src            :TPtRect);                           inline;
procedure BitBlt1Y              (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width,
                                          rct_src_left,
                                          rct_src_top,
                                          rct_src_width,
                                          rct_src_height,
                                          rct_dst_left,
                                          rct_dst_top        :integer);                           inline;
// Blitter1(xy-inverted):
procedure BitBlt1XY             (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width,
                                          rct_dst_left,
                                          rct_dst_top        :integer;
                                 const    rct_src            :TPtRect);                           inline;
procedure BitBlt1XY             (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width,
                                          rct_src_left,
                                          rct_src_top,
                                          rct_src_width,
                                          rct_src_height,
                                          rct_dst_left,
                                          rct_dst_top        :integer);                           inline;
// Blitter2:
procedure BitBlt2               (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width,
                                          rct_dst_left,
                                          rct_dst_top        :integer;
                                 const    rct_src            :TPtRect);                           inline;
procedure BitBlt2               (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width,
                                          rct_src_left,
                                          rct_src_top,
                                          rct_src_width,
                                          rct_src_height,
                                          rct_dst_left,
                                          rct_dst_top        :integer);                           inline;
procedure BmpToBmp2             (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :integer;
                                 const    clp_rct            :TPtRect;
                                 const    inn_wnd_mrg_       :integer);                           inline; {$ifdef Linux}[local];{$endif}
// Blitter3:
procedure BitBlt3               (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width,
                                          rct_dst_left,
                                          rct_dst_top        :integer;
                                 const    rct_src            :TPtRect;
                                          transparent_color  :TColor);                            inline;
procedure BitBlt3               (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width,
                                          rct_src_left,
                                          rct_src_top,
                                          rct_src_width,
                                          rct_src_height,
                                          rct_dst_left,
                                          rct_dst_top        :integer;
                                          transparent_color  :TColor);                            inline; {$ifdef Linux}[local];{$endif}



(******************************* Image transform ******************************)
// Scale:
procedure SqrtArr1Init          (const    arr_length         :integer=10000);                     inline; {$ifdef Linux}[local];{$endif}
procedure ImgSclDown0           (const    bmp_src_ptr        :PInteger;
                                 const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width,
                                          bmp_dst_height     :TColor;
                                 const    ker_w,
                                          ker_h              :integer);                           inline; {$ifdef Linux}[local];{$endif}
procedure ImgSclDown1           (         fast_img_data_ptr  :PFastImageData);                    inline; {$ifdef Linux}[local];{$endif}
// m0=0, m1=0:
procedure ImgSclDown2           (         fast_img_data_ptr  :PFastImageData);                    inline; {$ifdef Linux}[local];{$endif}
// m0=0, m1=0, scl_mul.x=1:
procedure ImgSclDown3           (         fast_img_data_ptr  :PFastImageData);                    inline; {$ifdef Linux}[local];{$endif}
// m0=0, m1=0, scl_mul.y=1:
procedure ImgSclDown4           (         fast_img_data_ptr  :PFastImageData);                    inline; {$ifdef Linux}[local];{$endif}
// Rotate:
procedure ImgRotLoop0           (const    rct_src            :TPtRect;
                                          bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width,
                                          d_width,
                                          c,s,v,w,
                                          lt,tp,rt,bt        :integer;
                                 const    mask_alpha         :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure ImgRotLoop1           (const    rct_src            :TPtRect;
                                          bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width,
                                          d_width,
                                          c,s,v,w,
                                          lt,tp,rt,bt        :integer;
                                 const    mask_alpha         :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure ImgRotLoop2           (const    rct_src            :TPtRect;
                                          bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width,
                                          d_width,
                                          c,s,v,w,
                                          lt,tp,rt,bt        :integer;
                                 const    mask_alpha         :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure ImgRotLoop3           (const    rct_src            :TPtRect;
                                          bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width,
                                          d_width,
                                          c,s,v,w,
                                          lt,tp,rt,bt        :integer;
                                 const    mask_alpha         :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure ImgRotLoop4           (const    rct_src            :TPtRect;
                                          bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width,
                                          d_width,
                                          c,s,v,w,
                                          lt,tp,rt,bt        :integer;
                                 const    mask_alpha         :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure ImgRotLoop5           (const    rct_src            :TPtRect;
                                          bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width,
                                          d_width,
                                          c,s,v,w,
                                          lt,tp,rt,bt        :integer;
                                 const    mask_alpha         :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure ImgRot1               (const    pvt                :TPtPos;
                                 const    rct_src,
                                          rct_clp            :TPtRect;
                                 const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    angle              :double;
                                 const    x,
                                          y                  :integer;
                                 const    add_alpha_mask     :byte;
                                 var      bounding_rct       :TPtRect;
                                 const    mask_alpha         :TColor);                            inline; {$ifdef Linux}[local];{$endif}
procedure ImgRot2               (const    pvt                :TPtPos;
                                 const    rct_src,
                                          rct_clp            :TPtRect;
                                 const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    angle              :double;
                                 const    x,
                                          y,
                                          inn_wnd_mrg,
                                          bmp_src_height     :integer);                           inline; {$ifdef Linux}[local];{$endif}



(******************************* Post-Processing ******************************)
procedure PPBlurProcInit;
procedure PPDec0ProcInit;
procedure ArrFilProcInit;
// (Flood fill) Заливка:
procedure PPFloodFillAdd        (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect);
procedure PPFloodFillSub        (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect);
procedure PPFloodFill           (const    bmp_dst_ptr        :PByte;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect);
procedure PPFloodFill           (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor);
procedure PPFloodFill           (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst_width,
                                          rct_dst_height,
                                          first_pix_pos      :integer;
                                 const    col                :TColor);
procedure PPFloodFill           (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                          flood_fill_inc     :boolean);
// (Write alpha channel to area(all pixels)) установить альфа-канал всем пикселям области:
procedure PPWriteAlpha          (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    alpha              :byte);
// (Additive) Аддитивное смешивание:
procedure PPAdditive            (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor);
procedure PPAdditive            (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    rct_src            :TPtRect;
                                 const    rct_dst            :TPtRect);
procedure PPAdditiveX           (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    rct_src            :TPtRect;
                                 const    rct_dst            :TPtRect);
procedure PPAdditiveY           (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    rct_src            :TPtRect;
                                 const    rct_dst            :TPtRect);
procedure PPAdditiveXY          (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    rct_src            :TPtRect;
                                 const    rct_dst            :TPtRect);
procedure PPAdditiveDec         (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    pow                :byte=64);
procedure PPAdditiveDec         (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    rct_src,
                                          rct_dst            :TPtRect;
                                 const    pow                :byte=64);
procedure PPAdditiveDecX        (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    rct_src,
                                          rct_dst            :TPtRect;
                                 const    pow                :byte=64);
procedure PPAdditiveDecY        (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    rct_src,
                                          rct_dst            :TPtRect;
                                 const    pow                :byte=64);
procedure PPAdditiveDecXY       (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    rct_src,
                                          rct_dst            :TPtRect;
                                 const    pow                :byte=64);
// (AlphaBlend) Полупрозрачность:
procedure PPAlphaBlend          (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    pow                :byte=64);
procedure PPAlphaBlend          (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    rct_src,
                                          rct_dst            :TPtRect;
                                 const    pow                :byte=64);
procedure PPAlphaBlendX         (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    rct_src,
                                          rct_dst            :TPtRect;
                                 const    pow                :byte=64);
procedure PPAlphaBlendY         (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    rct_src,
                                          rct_dst            :TPtRect;
                                 const    pow                :byte=64);
procedure PPAlphaBlendXY        (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    rct_src,
                                          rct_dst            :TPtRect;
                                 const    pow                :byte=64);
// (Inverse) Инверсия:
procedure PPInverse             (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect);
procedure PPInverseDec          (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    pow                :byte=64);
// (HighLight) Подсветка:
procedure PPHighlight           (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    pow                :byte=64);
procedure PPHighlightLimit      (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    pow                :byte=64);
// (Darken) Затемнение:
procedure PPDarken              (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    pow                :byte=64);
procedure PPDarkenLimit         (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    pow                :byte=64);
// (GrayscaleR) Оттенок серого: красный канал:
procedure PPGrayscaleR          (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect);
procedure PPGrayscaleRDec       (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    pow                :byte=64);
// (GrayscaleG) Оттенок серого: красный канал:
procedure PPGrayscaleG          (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect);
procedure PPGrayscaleGDec       (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    pow                :byte=64);
// (GrayscaleB) Оттенок серого: красный канал:
procedure PPGrayscaleB          (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect);
procedure PPGrayscaleBDec       (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    pow                :byte=64);
// (Monochrome Noise) Монохромный шум:
procedure PPMonoNoise           (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor);
procedure PPMonoNoiseDec        (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    col                :TColor;
                                 const    pow                :byte=64);
// (Random noise) Разноцветный шум:
procedure RandArrInit           (const    arr_length         :integer=10000);
procedure PPRandNoise           (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    PPRandNoiseProc    :TProc23;
                                          pow1,pow2          :byte);
// (Blur) Размытие:
procedure PPBlur                (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    PPBlurProc         :TProc8;
                                 const    border_filter      :TBorderFilter=efNotTiled);
procedure PPBlurDec             (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    PPBlurDecProc      :TProc19;
                                 const    alpha              :byte);
procedure PPBlurLeft            (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    PPBlurProc         :TProc8);
procedure PPBlurRight           (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    PPBlurProc         :TProc8);
procedure PPBlurUp              (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    PPBlurProc         :TProc8);
procedure PPBlurDown            (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    PPBlurProc         :TProc8);
procedure PPBlurRGB9            (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    blur_type          :TBlurType=btRGB);
// (Colorize) Окраска:
procedure PPColorCorrectionM0   (         ColorizeM          :TProc17;
                                 const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    pow                :byte=32);
procedure PPColorCorrectionP0   (         ColorizeP          :TProc17;
                                 const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    pow                :byte=32);
procedure PPColorCorrectionM0   (         ColorizeM          :TProc17;
                                 const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    rct_src,
                                          rct_dst            :TPtRect;
                                 const    pow                :byte=32);
procedure PPColorCorrectionP0   (         ColorizeP          :TProc17;
                                 const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    rct_src,
                                          rct_dst            :TPtRect;
                                 const    pow                :byte=32);
procedure PPColorCorrectionM1   (         ColorizeM          :TProc18;
                                 const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    rct_src,
                                          rct_dst            :TPtRect;
                                 const    pow                :byte=32);
procedure PPColorCorrectionP1   (         ColorizeP          :TProc18;
                                 const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    rct_src,
                                          rct_dst            :TPtRect;
                                 const    pow                :byte=32);
// (Vertical gradient) Вертикальный градиент:
procedure PPGrVMonochrome       (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                          grad_prop          :TGradProp);
procedure PPGrVAdditive         (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                          grad_prop          :TGradProp);
procedure PPGrVAdditive         (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    rct_src,
                                          rct_dst            :TPtRect;
                                          grad_prop          :TGradProp);
procedure PPGrVAdditiveX        (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    rct_src,
                                          rct_dst            :TPtRect;
                                          grad_prop          :TGradProp);
procedure PPGrVAdditiveY        (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    rct_src,
                                          rct_dst            :TPtRect;
                                          grad_prop          :TGradProp);
procedure PPGrVAdditiveXY       (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    rct_src,
                                          rct_dst            :TPtRect;
                                          grad_prop          :TGradProp);
procedure PPGrVAlphablend       (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                          grad_prop          :TGradProp);
procedure PPGrVAlphablend       (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    rct_src,
                                          rct_dst            :TPtRect;
                                          grad_prop          :TGradProp);
procedure PPGrVAlphablendX      (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    rct_src,
                                          rct_dst            :TPtRect;
                                          grad_prop          :TGradProp);
procedure PPGrVAlphablendY      (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    rct_src,
                                          rct_dst            :TPtRect;
                                          grad_prop          :TGradProp);
procedure PPGrVAlphablendXY     (const    bmp_src_ptr,
                                          bmp_dst_ptr        :PInteger;
                                 const    bmp_src_width,
                                          bmp_dst_width      :TColor;
                                 const    rct_src,
                                          rct_dst            :TPtRect;
                                          grad_prop          :TGradProp);
procedure PPGrVInverse          (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                          grad_prop          :TGradProp);
procedure PPGrV16               (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                          grad_prop          :TGradProp;
                                          Proc16             :TProc16);
procedure PPGrV17               (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                          grad_prop          :TGradProp;
                                          Proc17             :TProc17);
procedure PPGrVMonoNoise        (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                          grad_prop          :TGradProp);
procedure PPGrV18               (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                          grad_prop          :TGradProp;
                                          Proc18             :TProc18);
procedure PPGrV19               (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                          grad_prop          :TGradProp;
                                          Proc19             :TProc19);
procedure PPGrVContrast         (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                          grad_prop          :TGradProp);
// (Contrast) Контрастность:
procedure PPContrast1           (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    pow                :byte=64);
procedure PPContrast2           (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    pow                :byte=64);
// (Gamma) Гамма:
{0.0<pow<7.0}
procedure PowArrInit            (const    digits_cnt         :byte=2);
procedure PPGamma               (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                 const    pow                :double);
{Test FX}
procedure PPTest0               (const    arr_src_ptr,
                                          arr_dst_ptr        :PInteger;
                                 const    arr_src_width,
                                          arr_dst_width      :TColor;
                                 const    rct_dst            :TPtRect);
procedure PPTest1               (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst,
                                          rct_dst3           :TPtRect;
                                          rad1__             :TColor;
                                          pow__              :byte);
procedure PPTest2               (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst,
                                          rct_dst3           :TPtRect;
                                          rad1__             :TColor;
                                          pow__              :byte;
                                          t                  :byte);
procedure TestArrInit           (const    bmp_dst_ptr        :PInteger;
                                 const    bmp_dst_width      :TColor;
                                 const    rct_dst            :TPtRect;
                                          rad2__             :TColor=03;
                                          rad3__             :TColor=03);
{$endregion}



var

  color_level_arr     : array[0..6] of TColor=(%00000000111111101111111011111110,
                                               %00000000111111001111110011111100,
                                               %00000000111110001111100011111000,
                                               %00000000111100001111000011110000,
                                               %00000000111000001110000011100000,
                                               %00000000110000001100000011000000,
                                               %00000000110000001000000010000000);

  fast_image_proc_var : TFastImageProc;
  //fast_image_data_arr : array of TFastImageData;

  {Precalculated tables of sqrt(x)}
  sqrt_arr0           : TDublArr;
  sqrt_arr1           : TIntrArr;

  {Precalculated table of random(x)}
  rand_arr            : T1Byte1Arr;

  {Precalculated table of power(x)}
  pow_arr             : T2Byte2Arr;

  {Precalculated table of greatest common divisors(GCD)}
  // Array of GCD:
  gcd_arr             : TGCDArr;
  // Precision of calculation:
  grid_pt_rad         : TColor;

  DefaultParallaxShift: TPtPos=(x:16; y:16);
  PPBlurProcArr       : array[0..90] of TProc8;
  PPDec0ProcArr       : array[0..29] of TFunc0;
  ArrFilProcArr       : array[0..29] of TProc5;
  curve_default_prop  : TCurveProp={$region -fold}
  (
    dup_pts_id               : (arr:(0,0,0,0,0,0); obj_ind:-1; pts_ind:-1; dup_pts_cnt:0);
    curve_obj_ind            : 0;
    pts_cnt                  : 0;
    pts_cnt_val              : 256;
    eds_smpl_angle           : 2.0;

    rct_eds_col_ptr          : Nil;
    rct_eds_col              : $00D95BBA;
    rct_eds_col_inv          : $00000000;
    rct_eds_col_rnd          : False;
    rct_eds_col_fall_off     : False;
    rct_eds_col_fall_off_inc : 1;

    rct_pts_col_ptr          : Nil;
    rct_pts_col              : $00922176;
    rct_pts_col_inv          : $00000000;
    rct_pts_col_rnd          : False;
    rct_pts_col_fall_off     : False;
    rct_pts_col_fall_off_inc : 1;

    eds_col_ptr              : Nil;
    eds_col                  : $00CBC97C;
    eds_col_inv              : $00000000;
    eds_col_rnd              : False;
    eds_col_fall_off         : False;
    eds_col_fall_off_inc     : 1;
    eds_width                : 1;
    eds_width_half           : 0;
    eds_width_odd            : 0;
    eds_aa                   : False;

    pts_col_ptr              : Nil;
    pts_col                  : clWhite;//$00383716;
    pts_col_inv              : $00000000;
    pts_col_rnd              : False;
    pts_col_fall_off         : False;
    pts_col_fall_off_inc     : 1;
    pts_width                : 5;
    pts_width__half          : 2;
    pts_width__odd           : 0;
    pts_height               : 5;
    pts_height_half          : 2;
    pts_height_odd           : 0;

    {rectangle}
    rct_val_arr              : (-2,-2,2,-1,2);
    pts_rct_width            : 5;
    pts_rct_width__half      : 2;
    pts_rct_width__odd       : 0;
    pts_rct_height           : 5;
    pts_rct_height_half      : 2;
    pts_rct_height_odd       : 0;
    pts_rct_tns_left         : 1;
    pts_rct_tns_top          : 1;
    pts_rct_tns_right        : 1;
    pts_rct_tns_bottom       : 1;
    pts_rct_inn_width        : 3;
    pts_rct_inn_width__odd   : 1;
    pts_rct_inn_height       : 3;
    pts_rct_inn_height_odd   : 1;

    {circle}
    pts_crc_diam_inn         : 5;
    pts_crc_diam_inn_half    : 2;
    pts_crc_diam_out         : 5;
    pts_crc_diam_out_half    : 2;

    {polygon}
    pts_plg_diam             : 5;
    pts_plg_diam_half        : 2;
    pts_plg_ang_cnt          : 3;

    {sprite}
    pts_srt_width            : 5;
    pts_srt_height           : 5;

    sln_pts_frq              : 4;
    sln_type                 : TSplineType     (0);
    sln_mode                 : TSplineMode     (0);
    spray_rad                : 32;
    eds_bld_stl              : TDrawingStyle   (0);
    pts_bld_stl              : TDrawingStyle   (0);
    rct_eds_bld_stl          : TDrawingStyle   (2);
    rct_pts_bld_stl          : TDrawingStyle   (2);
    clp_stl                  : TClipStyle      (0);
    grd_pts_dns              : 2;
    eds_lod                  : True;
    eds_lod_on_create        : True;
    eds_simpl_angle          : 20.0;
    hid_ln_elim              : True;
    best_ends_quality        : True;
    best_precision           : False;
    lazy_repaint             : True;
    lazy_repaint_prev        : False;
    byte_mode                : True;
    better_quality           : False;
    grid_clipping_eds        : False;
    grid_clipping_pts        : True;
    grid_clipping_adaptive   : True;
    only_fit_to_wnd_calc     : False;
    free_mem_on_out_of_wnd   : True;
    free_mem_on_scale_down   : False;
    realloc_mem              : False;
    remove_brunching         : True;
    rct_eds_show             : False;
    rct_pts_show             : False;
    eds_show                 : False;
    pts_show                 : False;
    cnc_ends                 : False;
    pts_ord_inv              : False;
    is_out_of_wnd            : False;
    dyn_stl                  : dsNone;

    fml_type                 : TSplineFormula  (0);

    {Cycloid}
    cycloid_pts_cnt          : 256;
    cycloid_loop_cnt         : 003;
    cycloid_loop_rad         : 064.0;
    cycloid_curvature        : 001.0;
    cycloid_dir_x            : TMovingDirection(1);
    cycloid_dir_y            : TMovingDirection(2);

    {Epicycloid}
    epicycloid_pts_cnt       : 256;
    epicycloid_petals_cnt    : 008.0;
    epicycloid_rad           : 256.0;
    epicycloid_rot           : 000.0;
    epicycloid_angle         : 360.0;

    {Rose}
    rose_pts_cnt             : 256;
    rose_petals_cnt          : 007.0;
    rose_rad                 : 256.0;
    rose_rot                 : 000.0;
    rose_angle               : 180.0;
    rose_mobius_grid         : False;

    {Spiral}
    spiral_pts_cnt           : 256;
    spiral_coil_step         : 001.0;
    spiral_rad               : 256.0;
    spiral_rot               : 000.0;
    spiral_angle             : 720.0;

    {Superellipse}
    superellipse_pts_cnt     : 256;
    superellipse_curvature0  : 006.0;
    superellipse_curvature1  : 006.0;
    superellipse_curvature2  : 000.1;
    superellipse_curvature3  : 000.1;
    superellipse_rad         : 006.0;
    superellipse_rot         : 000.0;
    superellipse_angle       : 360.0;

    res_fld                  : 0;

  ); {$endregion}
  ftext_default_prop  : TFTextProp={$region -fold}
  (
    bkgnd_col    : clWhite;
    bkgnd_draw   : False;
    bkgnd_rnd_col: false;
  ); {$endregion}
  selit_default_prop  : TSelItProp={$region -fold}
  (
    bkgnd_style   : bsBoth;
    selection_mode: smCircle;
  ); {$endregion}

  {Test1}
  texture_id2         : TColor;
  texture_test_ptr    : PInteger;
  texture_test_ptr2   : ^TBitmap;
  texture_test_width,
  texture_test_height : integer;

  {Test}
  test_arr       : TColorArr;
  test_arr_ptr   : PInteger;
  test_arr_width : integer;
  test_arr_height: integer;



implementation

{uses

   Main;}

(***************************** Some basic routines ****************************) {$region -fold}

//
class operator TPtPos2 .=(r1,r2:TPtPos2): boolean;                                                                 inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(r1.x=r2.x) and (r1.y=r2.y);
end;  {$endregion}
//
class operator TPtPosF2.=(r1,r2:TPtPosF2): boolean;                                                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(r1.x=r2.x) and (r1.y=r2.y);
end;  {$endregion}
class operator TPtPos3 .=(r1,r2:TPtPos3 ): boolean;                                                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(r1*r2) and (r1.obj_ind=r2.obj_ind) and (r1.dup_pts_cnt=r2.dup_pts_cnt);
end;  {$endregion}
class operator TPtPos3 .*(r1,r2:TPtPos3 ): boolean;                                                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(r1.arr[0]=r2.arr[0]) and
          (r1.arr[1]=r2.arr[1]) and
          (r1.arr[2]=r2.arr[2]) and
          (r1.arr[3]=r2.arr[3]) and
          (r1.arr[4]=r2.arr[4]) and
          (r1.arr[5]=r2.arr[5]);
end;  {$endregion}
//
procedure      TPtPos3 .SetEqual1(var r1:TPtPos3; const r2:TPtPos3);                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  r1.arr        :=r2.arr;
  r1.obj_ind    :=-1;
  r1.pts_ind    :=-1;
  r1.dup_pts_cnt:=r2.dup_pts_cnt;
end; {$endregion}
procedure      TPtPos3 .SetEqual2(var r1:TPtPos3; const r2:TPtPos3);                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  r1.arr:=r2.arr;
end; {$endregion}
//
function FloatToFixed(const x:double): integer;                                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=Trunc(x*ONE_SHL_16);
end; {$endregion}
// (Swapping two values) Поменять местами два значения:
procedure Swap1(var x,y:integer);                                                                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  x:=x xor y;
  y:=x xor y;
  x:=x xor y;
end; {$endregion}
procedure Swap2(var x,y:integer);                                                                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  x-=y;
  y+=x;
  x:=y-x;
end; {$endregion}
procedure Swap3(var x,y:double);                                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  t: double;
begin
  t:=x;
  x:=y;
  y:=t;
end; {$endregion}
//
function GetEnumVal(enum:TDrawingStyle): integer;                                                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=GetEnumValue(TypeInfo(enum),GetEnumName(TypeInfo(enum),Ord(enum)));
end; {$endregion}
function GetEnumVal(enum:TDrawingStyle): TColor;                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=GetEnumValue(TypeInfo(enum),GetEnumName(TypeInfo(enum),Ord(enum)));
end; {$endregion}
// (Minimum of values):
function Min0(const a1,a2:PtrInt                                                                      ): PtrInt;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (a1<a2) then
    Result:=a1
  else
    Result:=a2;
end; {$endregion}
function Min1(const a1,a2:double                                                                      ): double;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (a1<a2) then
    Result:=a1
  else
    Result:=a2;
end; {$endregion}
function Min2(const a1,a2:integer                                                                     ): integer;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (a1<a2) then
    Result:=a1
  else
    Result:=a2;
end; {$endregion}
function Min3(const a1,a2:TColor                                                                      ): TColor;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (a1<a2) then
    Result:=a1
  else
    Result:=a2;
end; {$endregion}
function Min4(const arr:TIntrArr;  const max_item_val:integer; const item_cnt:integer                 ): integer;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=max_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]<=Result) then
      Result:=arr[i];
end; {$endregion}
function Min5(const arr:TColorArr; const max_item_val:TColor;  const item_cnt:TColor                  ): TColor;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=max_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]<=Result) then
      Result:=arr[i];
end; {$endregion}
function Min6(const arr:TIntrArr;  const max_item_val:integer; const item_cnt:integer; const b:boolean): integer;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,a: integer;
begin
  Result:=0;
  a  :=max_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]<=a) then
      begin
        a  :=arr[i];
        Result:=i;
      end;
end; {$endregion}
function Min7(const arr:TColorArr; const max_item_val:TColor;  const item_cnt:TColor;  const b:boolean): TColor;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
  a: TColor;
begin
  Result:=0;
  a     :=max_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]<=a) then
      begin
        a     :=arr[i];
        Result:=i;
      end;
end; {$endregion}
function Min8(const arr:TEdgeArr;  const max_item_val:integer; const item_cnt:integer                 ): integer;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=max_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i].obj_ind<=Result) then
      Result:=arr[i].obj_ind;
end; {$endregion}
function Min9(const arr:TEdgeArr;  const max_item_val:TColor;  const item_cnt:TColor                  ): TColor;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=max_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i].obj_ind<=Result) then
      Result:=arr[i].obj_ind;
end; {$endregion}
// (Maximum of values):
function Max0(const a1,a2:PtrInt                                                                      ): PtrInt;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (a1>a2) then
    Result:=a1
  else
    Result:=a2;
end; {$endregion}
function Max1(const a1,a2:double                                                                      ): double;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (a1>a2) then
    Result:=a1
  else
    Result:=a2;
end; {$endregion}
function Max2(const a1,a2:integer                                                                     ): integer;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (a1>a2) then
    Result:=a1
  else
    Result:=a2;
end; {$endregion}
function Max3(const a1,a2:TColor                                                                      ): TColor;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (a1>a2) then
    Result:=a1
  else
    Result:=a2;
end; {$endregion}
function Max4(const arr:TIntrArr;  const min_item_val:integer; const item_cnt:integer                 ): integer;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=min_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]>=Result) then
      Result:=arr[i];
end; {$endregion}
function Max5(const arr:TColorArr; const min_item_val:TColor;  const item_cnt:TColor                  ): TColor;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=min_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]>=Result) then
      Result:=arr[i];
end; {$endregion}
function Max6(const arr:TIntrArr;  const min_item_val:integer; const item_cnt:integer; const b:boolean): integer;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,a: integer;
begin
  Result:=0;
  a     :=min_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]>=a) then
      begin
        a     :=arr[i];
        Result:=i;
      end;
end; {$endregion}
function Max7(const arr:TColorArr; const min_item_val:TColor;  const item_cnt:TColor;  const b:boolean): TColor;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
  a: TColor;
begin
  Result:=0;
  a     :=min_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i]>=a) then
      begin
        a     :=arr[i];
        Result:=i;
      end;
end; {$endregion}
function Max8(const arr:TEdgeArr;  const min_item_val:integer; const item_cnt:integer                 ): integer;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=min_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i].obj_ind>=Result) then
      Result:=arr[i].obj_ind;
end; {$endregion}
function Max9(const arr:TEdgeArr;  const min_item_val:TColor;  const item_cnt:TColor                  ): TColor;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=min_item_val;
  for i:=0 to item_cnt-1 do
    if (arr[i].obj_ind>=Result) then
      Result:=arr[i].obj_ind;
end; {$endregion}
// (MinSubMax:important condition!: c>d):
function MinSubMax0(const a,b,c,d:integer                                                             ): integer;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (a>b) then
    Result:=b+d-a
  else
    Result:=a+c-b;
end; {$endregion}
function MinSubMax1(const a,b,c,d:integer                                                             ): TPtPos4;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    if (a>b) then
      begin
        x:=b+d-a;
        y:=True;
      end
    else
      begin
        x:=a+c-b;
        y:=a+c>b+d;
      end;
end; {$endregion}
function MinSubMax2(const a,b,c,d:integer                                                             ): boolean;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
    if (a>b) then
      Result:=True
    else
      Result:=a+c>b+d;
end; {$endregion}
//
function InvSqrt(const x:single): single;                                                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  result_as_int: UInt32 absolute Result;
begin
  Result       :=x;
  result_as_int:=$5F3759DF-(result_as_int>>1);
  Result       *=(1.5-(x*0.5*Result*Result));
end; {$endregion}
//
function Limit(x:integer): byte;                                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (x<0) then
    Result:=0
  else
  if (x>MAXBYTE) then
    Result:=MAXBYTE
  else
    Result:=x;
end; {$endregion}
//
procedure MaxSpriteWHRctInit(var rct:TPtRect);                                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  rct:=PtBounds
  (
    0,
    0,
    MAX_SPRITE_WIDTH,
    MAX_SPRITE_HEIGHT
  )
end; {$endregion}
function ArcTan4(const x0,y0,x1,y1:double): double;                                                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v1,w1,k,b,dx: double;
  angle       : double;
begin
  if (x1=x0) then
    begin
      Result:=pi/2;
      Exit;
    end;
  if (y1=y0) then
    begin
      Result:=0;
      Exit;
    end;
  angle:=Abs(ArcTan((y1-y0)/(x1-x0)));
  if ((y1>y0) and (x1>x0)) or
     ((y1<y0) and (x1<x0)) then
    Result:=angle
  else
  if ((y1>y0) and (x1<x0)) or
     ((y1<y0) and (x1>x0)) then
    Result:=pi-angle;
end; {$endregion}
// (Finding a substring in a TStrings) Поиск подстроки в строке:
function IndexOfSubStr(const list:TStrings; var sub_string:string): integer;                                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  index: integer;
begin
  Result:=-1;
  if list.Count=0 then
    Exit;
  sub_string:=UpperCase(sub_string);
  for index:=0 to list.Count-1 do
    if (Pos(sub_string,UpperCase(list[index]))>0) then
      begin
        Result:=index;
        Break;
      end;
end; {$endregion}
// (Binary search) Бинарный поиск:
function BinarySearch0(const n:word;   const arr_item_ptr:PWord;    const right_border:integer): integer;          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  a,b: integer;
begin
  a     :=0;
  b     :=n-1;
  Result:=(a+b)>>1;
  while  ((b-a)> 1) do
    begin
      if ((arr_item_ptr+Result)^<right_border) then
        a:=Result
      else
        b:=Result;
      Result:=(a+b)>>1;
    end;
end; {$endregion}
function BinarySearch1(const n:word;   const arr_item_ptr:PWord;    const right_border:word   ): word;             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  a,b: word;
begin
  a     :=0;
  b     :=n-1;
  Result:=(a+b)>>1;
  while  ((b-a)> 1) do
    begin
      if ((arr_item_ptr+Result)^<right_border) then
        a:=Result
      else
        b:=Result;
      Result:=(a+b)>>1;
    end;
end; {$endregion}
function BinarySearch2(const n:TColor; const arr_item_ptr:PInteger; const right_border:integer): integer;          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  a,b: integer;
begin
  a     :=0;
  b     :=n-1;
  Result:=(a+b)>>1;
  while  ((b-a)> 1) do
    begin
      if ((arr_item_ptr+Result)^<right_border) then
        a:=Result
      else
        b:=Result;
      Result:=(a+b)>>1;
    end;
end; {$endregion}
function BinarySearch3(const n:TColor; const arr_item_ptr:PInteger; const right_border:integer): integer;          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  a,b: integer;
begin
  a     :=0;
  b     :=n;
  Result:=(a+b)>>1;
  while  ((b-a)> 1) do
    begin
      if ((arr_item_ptr+Result)^<=right_border) then
        a:=Result
      else
        b:=Result;
      Result:=(a+b)>>1;
    end;
end; {$endregion}
function BinarySearch4(const n:TColor; const arr_item_ptr:PDouble;  const right_border:double ): TColor;           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  a,b: integer;
begin
  if ((arr_item_ptr+n-1)^<right_border) then
    begin
     Result:=n-1;
     Exit;
    end;
  a     :=0;
  b     :=n-1;
  Result:=(a+b)>>1;
  while  ((b-a)> 1) do
    begin
      if ((arr_item_ptr+Result)^<right_border) then
        a:=Result
      else
        b:=Result;
      Result:=(a+b)>>1;
    end;
end; {$endregion}
function BinarySearch5(const n:TColor; const arr_item_ptr:PWord;    const right_border:double ): integer;          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  a,b: integer;
begin
  if ((arr_item_ptr+000)^>=right_border) then
    begin
     Result:=0-1;
     Exit;
    end;
  if ((arr_item_ptr+n-1)^< right_border) then
    begin
     Result:=n-1;
     Exit;
    end;
  a     :=0;
  b     :=n-1;
  Result:=(a+b)>>1;
  while  ((b-a)> 1) do
    begin
      if ((arr_item_ptr+Result)^<right_border) then
        a:=Result
      else
        b:=Result;
      Result:=(a+b)>>1;
    end;
end; {$endregion}
// (Interpolation Search) Интерполирующий поиск:
{TODO}
// (Checks if both values x and y have not equal signs) Проверяет, имеют ли оба значения x и y не одинаковые знаки:
function NotEqualSign(x,y:double): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=((x>0) and (y<0)) or ((x<0) and (y>0));
end; {$endregion}
// (Calculation of the global axis shift error during the movement of the block motion of the layer) Вычисление ошибки смещения глобальной оси при блочном движении слоя:
procedure ShiftErrorCalc(x0,x1:double; var err:integer; df_exp:boolean); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f0,f1,df:double;
begin
  err:=0;
  f0 :=Frac(x0);
  f1 :=Frac(x1);
  df :=f0- (f1);
  if ((    df_exp) and (df<0)) or
     ((not df_exp) and (df>0)) then
    err:=1;
  if NotEqualSign(f0,f1) then
    begin
      err-=1;
      if (Trunc(df)=0) then
        err+=1;
    end;
end; {$endregion}
// (Set point) Установить точку:
function PtPos (const pt:TPtPosF         ): TPtPos;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=Trunc(pt.x);
  Result.y:=Trunc(pt.y);
end; {$endregion}
function PtPos (const pos_x,pos_y:integer): TPtPos;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=pos_x;
  Result.y:=pos_y;
end; {$endregion}
function PtPos (const pos_x,pos_y:double ): TPtPos;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=Trunc(pos_x);
  Result.y:=Trunc(pos_y);
end; {$endregion}
function PtPos2(const pt         :TPtPosF): TPtPos2; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=Trunc(pt.x);
  Result.y:=Trunc(pt.y);
end; {$endregion}
function PtPos2(const pos_x,pos_y:TColor ): TPtPos2; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=pos_x;
  Result.y:=pos_y;
end; {$endregion}
function PtPos2(const pos_x,pos_y:double ): TPtPos2; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=Trunc(pos_x);
  Result.y:=Trunc(pos_y);
end; {$endregion}
function PtPosF(const pt         :TPtPos ): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=pt.x;
  Result.y:=pt.y;
end; {$endregion}
function PtPosF(const pos_x,pos_y:double ): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=pos_x;
  Result.y:=pos_y;
end; {$endregion}
function PtPosF(const pos_x,pos_y:integer): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=pos_x;
  Result.y:=pos_y;
end; {$endregion}
function PtPosF(const pt         :TPtPos2): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=pt.x;
  Result.y:=pt.y;
end; {$endregion}
// (Set line) Установить линию:
{get coefficients of reflection ray}
{x0,y0,x1,y1       - first  segment;
 v0,w0,v1,w1       - second segment;
 int_pt_x,int_pt_y - intersection point of two segments;
 result            - coefficients of reflection ray equation}
{second segment is horizontal line}
function LnCoefRefl0(const int_pt_x,         x0,y0,x1,y1            :double ): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt: TPtPosF;
begin
  with Result do
    begin
      //pt:=LnCoef(x0,y0,x1,y1);
      //x := -pt.x;
      //y :=2*pt.x*int_pt_x+pt.y;
    end;
end; {$endregion}
{second segment is vertical   line}
function LnCoefRefl1(const          int_pt_y,x0,y0,x1,y1            :double ): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt: TPtPosF;
begin
  with Result do
    begin
      //pt:=LnCoef(x0,y0,x1,y1);
      //x :=-pt.x;
      //y :=2*int_pt_y-pt.y;
    end;
end; {$endregion}
{second segment is regular    line}
function LnCoefRefl2(const int_pt_x,int_pt_y,x0,y0,x1,y1,v0,w0,v1,w1:double ): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m,p0,p1,p2: double;
begin
  with Result do
    begin
      m :=(((x1-x0)   *(w1-w0)-
            (y1-y0)   *(v1-v0))*2)/
        (sqr(w1-w0)+sqr(v1-v0));
      p0:=  (x1-x0)-m *(w1-w0);
      p1:=  (y1-y0)+m *(v1-v0);
      p2:=p1/p0;
      x :=          p2;
      y :=int_pt_y -p2*int_pt_x;
    end;
end; {$endregion}
function LnCoef     (const x0,y0,x1,y1                              :double ): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      x:=(y1-y0)/
         (x1-x0);
      y:= y1-x1*x;
    end;
end; {$endregion}
function LnCoef     (const x0,y0,x1,y1                              :integer): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      x:=(y1-y0)/
         (x1-x0);
      y:= y1-x1*x;
    end;
end; {$endregion}
function LnCoef     (const vec                                      :TLnPosF): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      x:=(vec.y1-vec.y0)/
         (vec.x1-vec.x0);
      y:= vec.y1-vec.x1*x;
    end;
end; {$endregion}
function LnPos      (const vec                                      :TLnPosF): TLnPos;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      x0:=Trunc(vec.x0);
      y0:=Trunc(vec.y0);
      x1:=Trunc(vec.x1);
      y1:=Trunc(vec.y1);
    end;
end; {$endregion}
function LnPos      (const x0,y0,x1,y1                              :integer): TLnPos;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x0:=x0;
  Result.y0:=y0;
  Result.x1:=x1;
  Result.y1:=y1;
end; {$endregion}
function LnPosF     (const vec                                      :TLnPos ): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      x0:=vec.x0;
      y0:=vec.y0;
      x1:=vec.x1;
      y1:=vec.y1;
    end;
end; {$endregion}
function LnPosF     (const x0,y0,x1,y1                              :double ): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x0:=x0;
  Result.y0:=y0;
  Result.x1:=x1;
  Result.y1:=y1;
end; {$endregion}
function LnPosF     (const x0,y0,x1,y1                              :integer): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x0:=x0;
  Result.y0:=y0;
  Result.x1:=x1;
  Result.y1:=y1;
end; {$endregion}
// (Bounding rectangle of points set) Ограничиваюший прямоугольник множества точек:
function PtsRngRctCalc    (const pts:TPtPosFArr; var rct_bnd_ind_arr:TEnum2Arr; const start_pts_ind:TColor=0; const end_pts_ind:TColor=0): TRect;    {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr                                : PPtPosF;
  min_x,min_y,max_x,max_y                : double;
  ind_min_x,ind_min_y,ind_max_x,ind_max_y: integer;
  i                                      : integer;
begin

  {Misc. Precalc.-----------------} {$region -fold}
  Result:=Default(TRect);

  ind_min_x:=0;
  ind_min_y:=0;
  ind_max_x:=0;
  ind_max_y:=0;

  with pts[start_pts_ind] do
    begin
      min_x:=x;
      min_y:=y;
      max_x:=x;
      max_y:=y;
    end; {$endregion}

  {Calc. of Rectangle-------------} {$region -fold}
  pts_ptr:=Unaligned(@pts[start_pts_ind]);
  for i:=start_pts_ind to end_pts_ind do
    begin
      if ({Trunc(}pts_ptr^.x{)}<=min_x) then
        begin
          min_x    :={Trunc(}pts_ptr^.x{)};
          ind_min_x:=i;
        end;
      if ({Trunc(}pts_ptr^.y{)}<=min_y) then
        begin
          min_y    :={Trunc(}pts_ptr^.y{)};
          ind_min_y:=i;
        end;
      if ({Trunc(}pts_ptr^.x{)}>=max_x) then
        begin
          max_x    :={Trunc(}pts_ptr^.x{)};
          ind_max_x:=i;
        end;
      if ({Trunc(}pts_ptr^.y{)}>=max_y) then
        begin
          max_y    :={Trunc(}pts_ptr^.y{)};
          ind_max_y:=i;
        end;
      Inc(pts_ptr);
    end; {$endregion}

  {Set Rectangle------------------} {$region -fold}
  with Result do
    begin
      left  :=Trunc(pts[ind_min_x].x)+0;
      top   :=Trunc(pts[ind_min_y].y)+0;
      right :=Trunc(pts[ind_max_x].x)+1;
      bottom:=Trunc(pts[ind_max_y].y)+1;
      width :=right-left;
      height:=bottom-top;
    end; {$endregion}

  {Save Indices of Borders(Points)} {$region -fold}
  rct_bnd_ind_arr[0]:=ind_min_x;
  rct_bnd_ind_arr[1]:=ind_min_y;
  rct_bnd_ind_arr[2]:=ind_max_x;
  rct_bnd_ind_arr[3]:=ind_max_y; {$endregion}

end; {$endregion}
function PtsRngRctCalc2   (const pts:TPtPosFArr; var rct_bnd_ind_arr:TEnum2Arr; const start_pts_ind:TColor=0; const end_pts_ind:TColor=0): TPtRectF; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr                                : PPtPosF;
  min_x,min_y,max_x,max_y                : double;
  ind_min_x,ind_min_y,ind_max_x,ind_max_y: integer;
  i                                      : integer;
begin

  {Misc. Precalc.-----------------} {$region -fold}
  Result:=Default(TPtRectF);

  ind_min_x:=0;
  ind_min_y:=0;
  ind_max_x:=0;
  ind_max_y:=0;

  with pts[start_pts_ind] do
    begin
      min_x:=x;
      min_y:=y;
      max_x:=x;
      max_y:=y;
    end; {$endregion}

  {Calc. of Rectangle-------------} {$region -fold}
  pts_ptr:=Unaligned(@pts[start_pts_ind]);
  for i:=start_pts_ind to end_pts_ind do
    begin
      if (pts_ptr^.x<=min_x) then
        begin
          min_x    :=pts_ptr^.x;
          ind_min_x:=i;
        end;
      if (pts_ptr^.y<=min_y) then
        begin
          min_y    :=pts_ptr^.y;
          ind_min_y:=i;
        end;
      if (pts_ptr^.x>=max_x) then
        begin
          max_x    :=pts_ptr^.x;
          ind_max_x:=i;
        end;
      if (pts_ptr^.y>=max_y) then
        begin
          max_y    :=pts_ptr^.y;
          ind_max_y:=i;
        end;
      Inc(pts_ptr);
    end; {$endregion}

  {Set Rectangle------------------} {$region -fold}
  with Result do
    begin
      left  :=pts[ind_min_x].x+0;
      top   :=pts[ind_min_y].y+0;
      right :=pts[ind_max_x].x+1;
      bottom:=pts[ind_max_y].y+1;
      width :=right-left;
      height:=bottom-top;
    end; {$endregion}

  {Save Indices of Borders(Points)} {$region -fold}
  rct_bnd_ind_arr[0]:=ind_min_x;
  rct_bnd_ind_arr[1]:=ind_min_y;
  rct_bnd_ind_arr[2]:=ind_max_x;
  rct_bnd_ind_arr[3]:=ind_max_y; {$endregion}

end; {$endregion}
function PtsRngIndsRctCalc(const pts:TPtPosFArr; const  sel_pts_inds:TColorArr; const pts_cnt:TColor                                    ): TRect;    {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr                                : PPtPosF;
  sel_pts_inds_ptr                       : PInteger;
  min_x,min_y,max_x,max_y                : double;
  ind_min_x,ind_min_y,ind_max_x,ind_max_y: integer;
  i                                      : integer;
begin

  {Misc. Precalc.----} {$region -fold}
  Result:=Default(TRect);

  ind_min_x:=0;
  ind_min_y:=0;
  ind_max_x:=0;
  ind_max_y:=0;

  with pts[sel_pts_inds[0]] do
    begin
      min_x:=x;
      min_y:=y;
      max_x:=x;
      max_y:=y;
    end; {$endregion}

  {Calc. of Rectangle} {$region -fold}
  pts_ptr         :=Unaligned(@pts         [0]);
  sel_pts_inds_ptr:=Unaligned(@sel_pts_inds[0]);
  for i:=0 to pts_cnt-1 do
    begin
      if ((pts_ptr+sel_pts_inds_ptr^)^.x<=min_x) then
        begin
          min_x    :=(pts_ptr+sel_pts_inds_ptr^)^.x;
          ind_min_x:=sel_pts_inds_ptr^;
        end;
      if ((pts_ptr+sel_pts_inds_ptr^)^.y<=min_y) then
        begin
          min_y    :=(pts_ptr+sel_pts_inds_ptr^)^.y;
          ind_min_y:=sel_pts_inds_ptr^;
        end;
      if ((pts_ptr+sel_pts_inds_ptr^)^.x>=max_x) then
        begin
          max_x    :=(pts_ptr+sel_pts_inds_ptr^)^.x;
          ind_max_x:=sel_pts_inds_ptr^;
        end;
      if ((pts_ptr+sel_pts_inds_ptr^)^.y>=max_y) then
        begin
          max_y    :=(pts_ptr+sel_pts_inds_ptr^)^.y;
          ind_max_y:=sel_pts_inds_ptr^;
        end;
      Inc(sel_pts_inds_ptr);
    end; {$endregion}

  {Set Rectangle-----} {$region -fold}
  with Result do
    begin
      left  :=Trunc(pts[ind_min_x].x)+0;
      top   :=Trunc(pts[ind_min_y].y)+0;
      right :=Trunc(pts[ind_max_x].x)+1;
      bottom:=Trunc(pts[ind_max_y].y)+1;
      width :=right-left;
      height:=bottom-top;
    end; {$endregion}

end; {$endregion}
// (Set rectangle) Установить прямоугольник:
procedure PtRct   (const pts:TPtPosFArr; const rct_bnd_ind_arr:TEnum2Arr; var rct:TRect   ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct do
    begin
      left  :=Trunc(pts[rct_bnd_ind_arr[0]].x)+0;
      top   :=Trunc(pts[rct_bnd_ind_arr[1]].y)+0;
      right :=Trunc(pts[rct_bnd_ind_arr[2]].x)+1;
      bottom:=Trunc(pts[rct_bnd_ind_arr[3]].y)+1;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
procedure PtRctF  (const pts:TPtPosFArr; const rct_bnd_ind_arr:TEnum2Arr; var rct:TPtRectF); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct do
    begin
      left  :=pts[rct_bnd_ind_arr[0]].x+0;
      top   :=pts[rct_bnd_ind_arr[1]].y+0;
      right :=pts[rct_bnd_ind_arr[2]].x+1;
      bottom:=pts[rct_bnd_ind_arr[3]].y+1;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function PtRctF   (const rct_left,rct_top,rct_right,rct_bottom:double ): TPtRectF;           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct_left  ;
      top   :=rct_top   ;
      right :=rct_right ;
      bottom:=rct_bottom;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function PtRctF   (const rct:TPtRect                                  ): TPtRectF;           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct.left  ;
      top   :=rct.top   ;
      right :=rct.right ;
      bottom:=rct.bottom;
      width :=rct.width ;
      height:=rct.height;
    end;
end; {$endregion}
function PtRctB   (const rct_left,rct_top,rct_right,rct_bottom:integer): TPtRectB;           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=Default(TPtrectB);
  with Result.pt_rct do
    begin
      left  :=rct_left  ;
      top   :=rct_top   ;
      right :=rct_right ;
      bottom:=rct_bottom;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function PtRct    (const rct_left,rct_top,rct_right,rct_bottom:integer): TPtRect;            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct_left  ;
      top   :=rct_top   ;
      right :=rct_right ;
      bottom:=rct_bottom;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function PtRct    (const rct:TRect                                    ): TPtRect;            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct.left  ;
      top   :=rct.top   ;
      right :=rct.right ;
      bottom:=rct.bottom;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function PtRct    (const rct:TPtRectF                                 ): TPtRect;            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=Trunc(rct.left  );
      top   :=Trunc(rct.top   );
      right :=Trunc(rct.right );
      bottom:=Trunc(rct.bottom);
      width :=right -left;
      height:=bottom-top ;
    end;
end; {$endregion}
function PtRct    (const rct:TPtPosFArr                               ): TPtRect;            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=Trunc(rct[0].x);
      top   :=Trunc(rct[0].y);
      right :=Trunc(rct[1].x);
      bottom:=Trunc(rct[1].y);
      width :=right -left;
      height:=bottom-top ;
    end;
end; {$endregion}
function PtBounds (const rct_left,rct_top,rct_width,rct_height:integer): TPtRect;            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct_left  ;
      top   :=rct_top   ;
      width :=rct_width ;
      height:=rct_height;
      right :=left+width;
      bottom:=top+height;
    end;
end; {$endregion}
function PtBounds (const rct:TRect                                    ): TPtRect;            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct.left  ;
      top   :=rct.top   ;
      width :=rct.width ;
      height:=rct.height;
      right :=left+width;
      bottom:=top+height;
    end;
end; {$endregion}
function PtBoundsF(const rct_left,rct_top,rct_width,rct_height:integer): TPtRectF;           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct_left  ;
      top   :=rct_top   ;
      width :=rct_width ;
      height:=rct_height;
      right :=left+width;
      bottom:=top+height;
    end;
end; {$endregion}
function PtBoundsF(const rct_left,rct_top,rct_width,rct_height:double ): TPtRectF;           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct_left  ;
      top   :=rct_top   ;
      width :=rct_width ;
      height:=rct_height;
      right :=left+width;
      bottom:=top+height;
    end;
end; {$endregion}
function SetRct   (index:PtrInt; const rct_dst:TPtRect; const block_count:integer): TPtRect; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pixels_per_block_y0: integer;
  pixels_per_block_y1: integer;
begin
  pixels_per_block_y0:=Round(rct_dst.height/block_count);
  if (index<block_count-1) then
    pixels_per_block_y1:=pixels_per_block_y0
  else
    pixels_per_block_y1:=      rct_dst.height   -pixels_per_block_y0*(block_count-1);
  Result               :=PtRct(rct_dst.left,
                               rct_dst.top+index*pixels_per_block_y0,
                               rct_dst.right,
                               rct_dst.top+index*pixels_per_block_y0+
                                                 pixels_per_block_y1);
end; {$endregion}
// (Inner clipped rectangle) Внутренний обрезанный прямоугольник:
function ClippedRctB(const out_rct,                       inn_rct:TPtRect;  var b           :byte): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b0,b1,b2,b3: boolean;
begin
  b0:=(out_rct.left  <=inn_rct.left  );
  b1:=(out_rct.top   <=inn_rct.top   );
  b2:=(out_rct.right >=inn_rct.right );
  b3:=(out_rct.bottom>=inn_rct.bottom);
  {Inner Rectangle Is In Outer Rectangle}
  if (b0 and b1 and b2 and b3) then
    begin
      Result:=inn_rct;
      b     :=0;
      Exit;
    end
  else
  {Inner Rectangle Is Out Of Outer Rectangle}
  if (out_rct.left  >=inn_rct.right ) or
     (out_rct.top   >=inn_rct.bottom) or
     (out_rct.right <=inn_rct.left  ) or
     (out_rct.bottom<=inn_rct.top   ) then
    begin
      Result:=Default(TPtRect);
      b     :=2;
      Exit;
    end
  else
  {Inner Rectangle Is Clipped By Outer Rectangle}
  with Result do
    begin
      b:=1;
      if b0 then
        left  :=inn_rct.left
      else
        left  :=out_rct.left;
      if b1 then
        top   :=inn_rct.top
      else
        top   :=out_rct.top;
      if b2 then
        right :=inn_rct.right
      else
        right :=out_rct.right;
      if b3 then
        bottom:=inn_rct.bottom
      else
        bottom:=out_rct.bottom;
      width   :=right -left;
      height  :=bottom-top;
    end;
end; {$endregion}
function ClippedRct (const out_rct,               mrg_rct,inn_rct:TPtRect;  var pix_clp_type:byte): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  clp_arr: array[0..3] of boolean;
  mrg_arr: array[0..3] of boolean;
  clp    : longword absolute clp_arr;
  mrg    : longword absolute mrg_arr;
begin
  with Result do
    begin
      //Result:=Default(TPtRect);
      if IsRct1OutOfRct2(inn_rct,out_rct) then
        begin
          pix_clp_type:=3;
          Exit;
        end;
      clp_arr[0]:=(out_rct.left  >=inn_rct.left  );
      clp_arr[1]:=(out_rct.top   >=inn_rct.top   );
      clp_arr[2]:=(out_rct.right <=inn_rct.right );
      clp_arr[3]:=(out_rct.bottom<=inn_rct.bottom);
      mrg_arr[0]:=(mrg_rct.left  <>00000000000000);
      mrg_arr[1]:=(mrg_rct.top   <>00000000000000);
      mrg_arr[2]:=(mrg_rct.right <>00000000000000);
      mrg_arr[3]:=(mrg_rct.bottom<>00000000000000);
      {l.b. - last bit}
      case clp of
        {No Clip----------------------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        0       {%00000000000000000000000000000000}: {$region -fold}
          begin
            left  :=inn_rct.left;
            top   :=inn_rct.top;
            right :=inn_rct.right;
            bottom:=inn_rct.bottom;
            width :=right -left;
            height:=bottom-top;
            case mrg of
                      { l.b.    l.b.    l.b.    l.b.    }
              0       {%00000000000000000000000000000000}: {$region -fold}
                begin
                  pix_clp_type:=0;
                  Exit;
                end; {$endregion}
                      { l.b.    l.b.    l.b.    l.b.    }
              256     {%00000000000000000000000100000000},
              16777216{%00000001000000000000000000000000},
              16777472{%00000001000000000000000100000000}: {$region -fold}
                begin
                  pix_clp_type:=1;
                  Exit;
                end; {$endregion}
              otherwise                                    {$region -fold}
                begin
                  pix_clp_type:=2;
                  Exit;
                end; {$endregion}
            end;
          end; {$endregion}
        {Top-Clipped------------------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        256     {%00000000000000000000000100000000},
        {Bottom-Clipped---------------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        16777216{%00000001000000000000000000000000},
        {Top-Bottom-Clipped-----------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        16777472{%00000001000000000000000100000000}: {$region -fold}
          begin
            left  :=inn_rct.left;
            top   :=Max(out_rct.top,inn_rct.top);
            right :=inn_rct.right;
            bottom:=Min(out_rct.bottom,inn_rct.bottom);
            width :=right -left;
            height:=bottom-top;
            case mrg of
                { l.b.    l.b.    l.b.    l.b.    }
              0       {%00000000000000000000000000000000},
              256     {%00000000000000000000000100000000},
              16777216{%00000001000000000000000000000000},
              16777472{%00000001000000000000000100000000}: {$region -fold}
                begin
                  pix_clp_type:=1;
                  Exit;
                end; {$endregion}
              otherwise                                    {$region -fold}
                begin
                  pix_clp_type:=2;
                  Exit;
                end; {$endregion}
            end;
          end; {$endregion}
        otherwise                                    {$region -fold}
       {{Left-Clipped-----------------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        1       {%00000000000000000000000000000001},
        {Left-Top-Clipped-------------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        257     {%00000000000000000000000100000001},
        {Left-Bottom-Clipped----------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        16777217{%00000001000000000000000000000001},
        {Top-Left-Bottom-Clipped------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        16777473{%00000001000000000000000100000001},
        {Right-Clipped----------------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        65536   {%00000000000000010000000000000000},
        {Right-Top-Clipped------------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        65792   {%00000000000000010000000100000000},
        {Right-Bottom-Clipped---------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        16842752{%00000001000000010000000000000000},
        {Top-Right-Bottom-Clipped-----------------}
                { l.b.    l.b.    l.b.    l.b.    }
        16843008{%00000001000000010000000100000000},
        {Left-Top-Right-Clipped-------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        65793   {%00000000000000010000000100000001},
        {Left-Bottom-Right-Clipped----------------}
                { l.b.    l.b.    l.b.    l.b.    }
        16842753{%00000001000000010000000000000001},
        {Left-Right-Clipped-----------------------}
                { l.b.    l.b.    l.b.    l.b.    }
        65537   {%00000000000000010000000000000001},
        {Left-Top-Right-Bottom-Clipped------------}
                { l.b.    l.b.    l.b.    l.b.    }
        16843009{%00000001000000010000000100000001}:}
          begin
            left        :=Max(out_rct.left  ,inn_rct.left  );
            top         :=Max(out_rct.top   ,inn_rct.top   );
            right       :=Min(out_rct.right ,inn_rct.right );
            bottom      :=Min(out_rct.bottom,inn_rct.bottom);
            width       :=right -left;
            height      :=bottom-top;
            pix_clp_type:=2;
          end; {$endregion}
      end;
    end;
end; {$endregion}
function ClippedRct (const out_rct,                       inn_rct:TPtRect                        ): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;
      if (out_rct.left  >=inn_rct.left  ) then
        left  :=out_rct.left
      else
        left  :=inn_rct.left;
      if (out_rct.top   >=inn_rct.top   ) then
        top   :=out_rct.top
      else
        top   :=inn_rct.top;
      if (out_rct.right <=inn_rct.right ) then
        right :=out_rct.right
      else
        right :=inn_rct.right;
      if (out_rct.bottom<=inn_rct.bottom) then
        bottom:=out_rct.bottom
      else
        bottom:=inn_rct.bottom;
      {if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;}
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedRct (const out_rct:TPtRect; const         inn_rct:TPtRectF                       ): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;
      if (out_rct.left  >=inn_rct.left  ) then
        left  :=Trunc(out_rct.left)
      else
        left  :=Trunc(inn_rct.left);
      if (out_rct.top   >=inn_rct.top   ) then
        top   :=Trunc(out_rct.top)
      else
        top   :=Trunc(inn_rct.top);
      if (out_rct.right <=inn_rct.right ) then
        right :=Trunc(out_rct.right)
      else
        right :=Trunc(inn_rct.right);
      if (out_rct.bottom<=inn_rct.bottom) then
        bottom:=Trunc(out_rct.bottom)
      else
        bottom:=Trunc(inn_rct.bottom);
      {if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;}
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedRct (const out_rct,                       inn_rct:TRect                          ): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;
      if (out_rct.left  >=inn_rct.left  ) then
        left  :=out_rct.left
      else
        left  :=inn_rct.left;
      if (out_rct.top   >=inn_rct.top   ) then
        top   :=out_rct.top
      else
        top   :=inn_rct.top;
      if (out_rct.right <=inn_rct.right ) then
        right :=out_rct.right
      else
        right :=inn_rct.right;
      if (out_rct.bottom<=inn_rct.bottom) then
        bottom:=out_rct.bottom
      else
        bottom:=inn_rct.bottom;
      {if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;}
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedRct (const out_rct:TPtRect; const         inn_rct:TRect                          ): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;
      if (out_rct.left  >=inn_rct.left  ) then
        left  :=out_rct.left
      else
        left  :=inn_rct.left;
      if (out_rct.top   >=inn_rct.top   ) then
        top   :=out_rct.top
      else
        top   :=inn_rct.top;
      if (out_rct.right <=inn_rct.right ) then
        right :=out_rct.right
      else
        right :=inn_rct.right;
      if (out_rct.bottom<=inn_rct.bottom) then
        bottom:=out_rct.bottom
      else
        bottom:=inn_rct.bottom;
      {if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;}
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedRct (const out_rct:TRect;   const         inn_rct:TPtRect                        ): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;
      if (out_rct.left  >=inn_rct.left  ) then
        left  :=out_rct.left
      else
        left  :=Trunc(inn_rct.left);
      if (out_rct.top   >=inn_rct.top   ) then
        top   :=out_rct.top
      else
        top   :=Trunc(inn_rct.top);
      if (out_rct.right <=inn_rct.right ) then
        right :=out_rct.right
      else
        right :=Trunc(inn_rct.right);
      if (out_rct.bottom<=inn_rct.bottom) then
        bottom:=out_rct.bottom
      else
        bottom:=Trunc(inn_rct.bottom);
      {if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;}
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedRct (const out_rct:TRect;   const         inn_rct:TPtRectF                       ): TPtRect;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;
      if (out_rct.left  >=inn_rct.left  ) then
        left  :=out_rct.left
      else
        left  :=Trunc(inn_rct.left);
      if (out_rct.top   >=inn_rct.top   ) then
        top   :=out_rct.top
      else
        top   :=Trunc(inn_rct.top);
      if (out_rct.right <=inn_rct.right ) then
        right :=out_rct.right
      else
        right :=Trunc(inn_rct.right);
      if (out_rct.bottom<=inn_rct.bottom) then
        bottom:=out_rct.bottom
      else
        bottom:=Trunc(inn_rct.bottom);
      {if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;}
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedRct (const out_rct:TPtRect; const         inn_rct:TRect; b:boolean               ): TRect;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;
      if (out_rct.left  >=inn_rct.left  ) then
        left  :=out_rct.left
      else
        left  :=inn_rct.left;
      if (out_rct.top   >=inn_rct.top   ) then
        top   :=out_rct.top
      else
        top   :=inn_rct.top;
      if (out_rct.right <=inn_rct.right ) then
        right :=out_rct.right
      else
        right :=inn_rct.right;
      if (out_rct.bottom<=inn_rct.bottom) then
        bottom:=out_rct.bottom
      else
        bottom:=inn_rct.bottom;
      {if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;}
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function ClippedRct (const out_rct,                       inn_rct:TRect; b:boolean               ): TRect;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;
      if (out_rct.left  >=inn_rct.left  ) then
        left  :=out_rct.left
      else
        left  :=inn_rct.left;
      if (out_rct.top   >=inn_rct.top   ) then
        top   :=out_rct.top
      else
        top   :=inn_rct.top;
      if (out_rct.right <=inn_rct.right ) then
        right :=out_rct.right
      else
        right :=inn_rct.right;
      if (out_rct.bottom<=inn_rct.bottom) then
        bottom:=out_rct.bottom
      else
        bottom:=inn_rct.bottom;
      {if (out_rct.left  >=inn_rct.right ) or
         (out_rct.right <=inn_rct.left  ) then
        begin
          width:=0;
          Exit;
        end;
      if (out_rct.top   >=inn_rct.bottom) or
         (out_rct.bottom<=inn_rct.top   ) then
        begin
          height:=0;
          Exit;
        end;}
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
// (Find rectangle with not coprime width and height(GCD(src_rect.width,src_rect.height)<>1) for source rectangle src_rect) Находит прямоугольник с не взаимно простыми сторонами(GCD(src_rect.width,src_rect.height)<>1) для исходного прямоугольника src_rect:
function NCSRectCalc(const rct_src:TPtRectF; const bucket_width,bucket_heigth:integer): TPtRectF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=rct_src.left;
      top   :=rct_src.top ;
      width :=(Trunc(rct_src.width /bucket_width )+1)*bucket_width ;
      height:=(Trunc(rct_src.height/bucket_heigth)+1)*bucket_heigth;
      right :=left+width;
      bottom:=top+height;
    end;
end; {$endregion}
// (Two rectangles bounding rectangle 1) Ограничивающий прямоугольник для двух заданных прямоугольников:
function TwoRctsBoundingRct(const rct1,rct2:TRect  ): TRect;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=Min2(rct1.left  ,rct2.left  );
      top   :=Min2(rct1.top   ,rct2.top   );
      right :=Max2(rct1.right ,rct2.right );
      bottom:=Max2(rct1.bottom,rct2.bottom);
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function TwoRctsBoundingRct(const rct1,rct2:TPtRect): TPtRect; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      left  :=Min2(rct1.left  ,rct2.left  );
      top   :=Min2(rct1.top   ,rct2.top   );
      right :=Max2(rct1.right ,rct2.right );
      bottom:=Max2(rct1.bottom,rct2.bottom);
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
// (Checking if two rectangles are equal) Проверка на равенство двух прямоугольников:
function AreRct1AndRct2Eq  (const rct1,rct2:TPtRect): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.left  =rct2.left  ) and
          (rct1.top   =rct2.top   ) and
          (rct1.right =rct2.right ) and
          (rct1.bottom=rct2.bottom);
end; {$endregion}
// (Rectangle in rectangle) Прямоугольник в прямоугольнике:
function IsRct1InRct2(const rct1,             rct2:TRect  ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.left  >=rct2.left  ) and
          (rct1.top   >=rct2.top   ) and
          (rct1.right <=rct2.right ) and
          (rct1.bottom<=rct2.bottom);
end; {$endregion}
function IsRct1InRct2(const rct1,             rct2:TPtRect): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.left  >=rct2.left  ) and
          (rct1.top   >=rct2.top   ) and
          (rct1.right <=rct2.right ) and
          (rct1.bottom<=rct2.bottom);
end; {$endregion}
function IsRct1InRct2(const rct1:TRect; const rct2:TPtRect): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.left  >=rct2.left  ) and
          (rct1.top   >=rct2.top   ) and
          (rct1.right <=rct2.right ) and
          (rct1.bottom<=rct2.bottom);
end; {$endregion}
// (Rectangle out of rectangle) Прямоугольник вне прямоугольника:
function IsRct1OutOfRct2(const rct1,                rct2:TRect  ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.right <=rct2.left  ) or
          (rct1.bottom<=rct2.top   ) or
          (rct1.left  >=rct2.right ) or
          (rct1.top   >=rct2.bottom);
end; {$endregion}
function IsRct1OutOfRct2(const rct1,                rct2:TPtRect): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.right <=rct2.left  ) or
          (rct1.bottom<=rct2.top   ) or
          (rct1.left  >=rct2.right ) or
          (rct1.top   >=rct2.bottom);
end; {$endregion}
function IsRct1OutOfRct2(const rct1:TRect   ; const rct2:TPtRect): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.right <=rct2.left  ) or
          (rct1.bottom<=rct2.top   ) or
          (rct1.left  >=rct2.right ) or
          (rct1.top   >=rct2.bottom);
end; {$endregion}
function IsRct1OutOfRct2(const rct1:TPtRectF; const rct2:TPtRect): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct1.right <=rct2.left  ) or
          (rct1.bottom<=rct2.top   ) or
          (rct1.left  >=rct2.right ) or
          (rct1.top   >=rct2.bottom);
end; {$endregion}
// (Line bounding rectangle) Ограничивающий линию прямоугольник:
function LineBndRct(const x0,y0,x1,y1,ln_width:integer): TPtRect; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_width2: integer;
begin
  ln_width2:=ln_width>>1;
  with Result do
    begin
      if (x0=x1) then
        begin
          left :=x0-ln_width2;
          right:=x0+ln_width2;
        end
      else
      if (x0<x1) then
        begin
          left :=x0-ln_width2;
          right:=x1+ln_width2;
        end
      else
        begin
          left :=x1-ln_width2;
          right:=x0+ln_width2;
        end;
      if (y0=y1) then
        begin
          top   :=y0-ln_width2;
          bottom:=y0+ln_width2;
        end
      else
      if (y0<y1) then
        begin
          top   :=y0-ln_width2;
          bottom:=y1+ln_width2;
        end
      else
        begin
          top   :=y1-ln_width2;
          bottom:=y0+ln_width2;
        end;
    end;
end; {$endregion}
// (Point in rectangle) Точка в прямоугольнике:
function IsPtInRct(const x,y,rct_dst_left,rct_dst_top,rct_dst_right,rct_dst_bottom:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct_dst_left  <=x) and
          (rct_dst_top   <=y) and
          (rct_dst_right > x) and
          (rct_dst_bottom> y);
end; {$endregion}
function IsPtInRct(const x,y:integer; const rct_dst:TRect                                 ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct_dst.left  <=x) and
          (rct_dst.top   <=y) and
          (rct_dst.right > x) and
          (rct_dst.bottom> y);
end; {$endregion}
function IsPtInRct(const x,y:integer; const rct_dst:TPtRect                               ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct_dst.left  <=x) and
          (rct_dst.top   <=y) and
          (rct_dst.right > x) and
          (rct_dst.bottom> y);
end; {$endregion}
function IsPtInRct(const x,y:double ; const rct_dst:TPtRect                               ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct_dst.left  <=x) and
          (rct_dst.top   <=y) and
          (rct_dst.right > x) and
          (rct_dst.bottom> y);
end; {$endregion}
function IsPtInRct(const x,y:double ; const rct_dst:TPtRectF                              ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(rct_dst.left  <=x) and
          (rct_dst.top   <=y) and
          (rct_dst.right > x) and
          (rct_dst.bottom> y);
end; {$endregion}
function IsPtInRct(const pt:TPtPos  ; const rct_dst:TRect                                 ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with pt do
    Result:=(rct_dst.left  <=x) and
            (rct_dst.top   <=y) and
            (rct_dst.right > x) and
            (rct_dst.bottom> y);
end; {$endregion}
function IsPtInRct(const pt:TPtPos  ; const rct_dst:TPtRect                               ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with pt do
    Result:=(rct_dst.left  <=x) and
            (rct_dst.top   <=y) and
            (rct_dst.right > x) and
            (rct_dst.bottom> y);
end; {$endregion}
function IsPtInRct(const pt:TPtPosF ; const rct_dst:TRect                                 ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with pt do
    Result:=(rct_dst.left  <=x) and
            (rct_dst.top   <=y) and
            (rct_dst.right > x) and
            (rct_dst.bottom> y);
end; {$endregion}
function IsPtInRct(const pt:TPtPosF ; const rct_dst:TPtRect                               ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with pt do
    Result:=(rct_dst.left  <=x) and
            (rct_dst.top   <=y) and
            (rct_dst.right > x) and
            (rct_dst.bottom> y);
end; {$endregion}
function IsPtInRct(const pt:TPtPosF ; const rct_dst:TPtRect; const rad:integer            ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with pt do
    Result:=(rct_dst.left  <=x-rad) and
            (rct_dst.top   <=y-rad) and
            (rct_dst.right > x+rad) and
            (rct_dst.bottom> y+rad);
end; {$endregion}
function IsPtInRct(const pt:TPtPosF ; const rct_dst:TPtRectF                              ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with pt do
    Result:=(rct_dst.left  <=x) and
            (rct_dst.top   <=y) and
            (rct_dst.right > x) and
            (rct_dst.bottom> y);
end; {$endregion}
// (Point in circle) Точка в окружности:
function IsPtInCrc(const x,y:integer; const crc_dst          :TCrPos ; const prec:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x-crc_dst.x)*(x-crc_dst.x)+(y-crc_dst.y)*(y-crc_dst.y)<=(crc_dst.r+prec)*(crc_dst.r+prec);
end; {$endregion}
function IsPtInCrc(const x,y:integer; const crc_dst          :TCrPosF; const prec:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x-crc_dst.x)*(x-crc_dst.x)+(y-crc_dst.y)*(y-crc_dst.y)<=(crc_dst.r+prec)*(crc_dst.r+prec);
end; {$endregion}
function IsPtInCrc(const x,y:double ; const crc_dst          :TCrPosF; const prec:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x-crc_dst.x)*(x-crc_dst.x)+(y-crc_dst.y)*(y-crc_dst.y)<=(crc_dst.r+prec)*(crc_dst.r+prec);
end; {$endregion}
function IsPtInCrc(const x,y:double ; const crc_x,crc_y,crc_r:integer; const prec:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x-crc_x)*(x-crc_x)+(y-crc_y)*(y-crc_y)<=(crc_r+prec)*(crc_r+prec);
end; {$endregion}
function IsPtInCrc(const x,y:integer; const crc_x,crc_y,crc_r:integer; const prec:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(x-crc_x)*(x-crc_x)+(y-crc_y)*(y-crc_y)<=(crc_r+prec)*(crc_r+prec);
end; {$endregion}
// (Distance between two points) Расстояние между двумя точками:
function PtDist   (const x0,y0,x1,y1:integer): double ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=sqrt(sqr(x1-x0)+sqr(y1-y0));
end; {$endregion}
function PtDist   (const x0,y0,x1,y1:double ): double ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=sqrt(sqr(x1-x0)+sqr(y1-y0));
end; {$endregion}
function PtDistSqr(const x0,y0,x1,y1:integer): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=sqr(x1-x0)+sqr(y1-y0);
end; {$endregion}
function PtDistSqr(const x0,y0,x1,y1:integer): double ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=sqr(x1-x0)+sqr(y1-y0);
end; {$endregion}
function PtDistSqr(const x0,y0,x1,y1:double ): double ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=sqr(x1-x0)+sqr(y1-y0);
end; {$endregion}
function PtDistSqr(const pt0,pt1    :TPtPosF): double ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=sqr(pt1.x-pt0.x)+sqr(pt1.y-pt0.y);
end; {$endregion}
// (Line-line intersection point) Точка пересечения двух линий:
function LineLineIntPt(const x0,y0,x1,y1,v0,w0,v1,w1:double):TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=-((x1-x0)*(v1*w0-v0*w1)-(v1-v0)*(x1*y0-x0*y1))/((x1-x0)*(w1-w0)-(v1-v0)*(y1-y0));
  Result.y:= ((y1-y0)*Result.x     +        (x1*y0-x0*y1))/ (x1-x0);
end; {$endregion}
// (Line-circle intersection points) Точки пересечения линии и окружности:
function LineCrcIntPt(const x0,y0,x1,y1:double ; const crc_dst:TCrPosF): TLnPosF;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  dx,dy,dz,b,g,s,one_div_dx,one_div_dz: double;
begin
  dx        :=x1-x0;
  dy        :=y1-y0;
  dz        :=sqr(dx)+sqr(dy);
  b         :=x1*y0-x0*y1;
  g         :=b-crc_dst.y*dx;
  s         :=sqrt(dz*sqr(crc_dst.r)-sqr(g+crc_dst.x*dy));
  one_div_dx:=1/dx;
  one_div_dz:=1/dz;
  Result.x0 :=one_div_dz*(-dy*g-s*dx+crc_dst.x*sqr(dx));
  Result.x1 :=one_div_dz*(-dy*g+s*dx+crc_dst.x*sqr(dx));
  Result.y0 :=one_div_dx*( dy*Result.x0+b );
  Result.y1 :=one_div_dx*( dy*Result.x1+b );
end; {$endregion}
function LineCrcIntPt(const x0,y0,x1,y1:double ; const x,y,r  :double ): TLnPosF;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  dx,dy,dz,b,g,s,one_div_dx,one_div_dz: double;
begin
  dx        :=x1-x0;
  dy        :=y1-y0;
  dz        :=sqr(dx)+sqr(dy);
  b         :=x1*y0-x0*y1;
  g         :=b-y*dx;
  s         :=sqrt(dz*sqr(r)-sqr(g+x*dy));
  one_div_dx:=1/dx;
  one_div_dz:=1/dz;
  Result.x0 :=one_div_dz*(-dy*g-s*dx+x*sqr(dx));
  Result.x1 :=one_div_dz*(-dy*g+s*dx+x*sqr(dx));
  Result.y0 :=one_div_dx*( dy*Result.x0+b );
  Result.y1 :=one_div_dx*( dy*Result.x1+b );
end; {$endregion}
function LineCrcIntPt(const x0,y0,x1,y1:integer; const x,y,r,v:double ): boolean;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=((sqr(x1-x0)+sqr(y1-y0))*sqr(r)-sqr(x1*y0-x0*y1+x*(y1-y0)-y*(x1-x0))>=0);
end; {$endregion}
function CrcPosF     (                           const x,y,r  :double ): TCrPosF;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.x:=x;
  Result.y:=y;
  Result.r:=r;
end; {$endregion}
// (Circle-Circle Intersection) Пересечение двух окружностей:
function CrcCrcInt(const x0,y0,r0,x1,y1,r1:double                                                    ): boolean;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(sqr(r1+r0)<=sqr(x1-x0)+sqr(y1-y0));
end; {$endregion}
function CrcCrcInt(const x0,y0,r0,x1,y1,r1:integer                                                   ): boolean;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(sqr(r1+r0)<=sqr(x1-x0)+sqr(y1-y0));
end; {$endregion}
function CrcCrcInt(const crc0,crc1        :TCrPosF                                                   ): boolean;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(sqr(crc1.r+crc0.r)<=sqr(crc1.x-crc0.x)+sqr(crc1.y-crc0.y));
end; {$endregion}
function CrcCrcInt(const crc0,crc1        :TCrPos                                                    ): boolean;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(sqr(crc1.r+crc0.r)<=sqr(crc1.x-crc0.x)+sqr(crc1.y-crc0.y));
end; {$endregion}
function CrcCrcInt(const vec0,vec1        :TLnPosF; const r0,r1:double                               ): TPtPosF;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  sqrt_d,d,v,w : double;
  f0,f1,f2,f3  : double;
  dir0_x,dir0_y: shortint;
  dir1_x,dir1_y: shortint;
begin
  Result:=Default(TPtPosF);
  LineD     (vec0,dir0_x,dir0_y);
  f0    :=  (vec0.x1-vec0.x0)*dir0_x;
  f2    :=  (vec0.y1-vec0.y0)*dir0_y;
  LineD     (vec1,dir1_x,dir1_y);
  f1    :=  (vec1.x1-vec1.x0)*dir1_x;
  f3    :=  (vec1.y1-vec1.y0)*dir1_y;
  v     :=-((vec0.x0-vec1.x0)*(f0-f1)+
            (vec0.y0-vec1.y0)*(f2-f3));
  w     :=sqr(f0-f1)+sqr(f2-f3);
  d     :=sqr(r0+r1)*w-sqr((vec0.x0-vec1.x0)*(f2-f3)-
                           (vec0.y0-vec1.y0)*(f0-f1));
  if (d<0) then
    Exit;
  sqrt_d:=sqrt(d);
  with Result do
    begin
      x:=(v-sqrt_d)/w;
      y:=(v+sqrt_d)/w;
    end;
end; {$endregion}
function CrcCrcInt(const vec0,vec1        :TLnPosF; const r0,r1:double                               ): TLnPosF3; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt           : TPtPosF;
  sqrt_d,d,v,w : double;
  f0,f1,f2,f3  : double;
  dir0_x,dir0_y: shortint;
  dir1_x,dir1_y: shortint;
begin
  Result:=Default(TLnPosF3);
  LineD     (vec0,dir0_x,dir0_y);
  f0    :=  (vec0.x1-vec0.x0)*dir0_x;
  f2    :=  (vec0.y1-vec0.y0)*dir0_y;
  LineD     (vec1,dir1_x,dir1_y);
  f1    :=  (vec1.x1-vec1.x0)*dir1_x;
  f3    :=  (vec1.y1-vec1.y0)*dir1_y;
  v     :=-((vec0.x0-vec1.x0)*(f0-f1)+
            (vec0.y0-vec1.y0)*(f2-f3));
  w     :=sqr(f0-f1)+sqr(f2-f3);
  d     :=sqr(r0+r1)*w-sqr((vec0.x0-vec1.x0)*(f2-f3)-
                           (vec0.y0-vec1.y0)*(f0-f1));
  if (d<0) then
    Exit;
  sqrt_d:=sqrt(d);
  with pt do
    begin
      x:=(v-sqrt_d)/w;
      y:=(v+sqrt_d)/w;
      with Result.vec0 do
        begin
          x0:=vec0.x0+f0*x;
          y0:=vec0.y0+f2*x;
          x1:=vec0.x0+f0*y;
          y1:=vec0.y0+f2*y;
        end;
      with Result.vec1 do
        begin
          x0:=vec1.x0+f1*x;
          y0:=vec1.y0+f3*x;
          x1:=vec1.x0+f1*y;
          y1:=vec1.y0+f3*y;
        end;
    end;
end; {$endregion}
function CrcCrcInt(const vec0,vec1        :TLnPosF; const r0,r1:double; const k,t:integer; var b:byte): TLnPosF;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt                  : TPtPosF;
  sqrt_d,d,v,w,k_div_t: double;
  f0,f1,f2,f3         : double;
  dir0_x,dir0_y       : shortint;
  dir1_x,dir1_y       : shortint;
  t_                  : integer;
begin
  t_     :=Max(t,1);
  k_div_t:=k/t_;
  LineD       (vec0,dir0_x,dir0_y);
  f0     :=Abs(vec0.x1-vec0.x0)*dir0_x;
  f2     :=Abs(vec0.y1-vec0.y0)*dir0_y;
  LineD       (vec1,dir1_x,dir1_y);
  f1     :=Abs(vec1.x1-vec1.x0)*dir1_x;
  f3     :=Abs(vec1.y1-vec1.y0)*dir1_y;
  with Result do
    begin
      x0:=vec0.x0+f0*k_div_t;
      y0:=vec0.y0+f2*k_div_t;
      x1:=vec1.x0+f1*k_div_t;
      y1:=vec1.y0+f3*k_div_t;
    end;
  v:= -((vec0.x0-vec1.x0)*(f0-f1)+
        (vec0.y0-vec1.y0)*(f2-f3));
  w:=sqr(f0-f1)+sqr(f2-f3);
  d:=sqr(r0+r1)*w-sqr((vec0.x0-vec1.x0)*(f2-f3)-
                      (vec0.y0-vec1.y0)*(f0-f1));
  b:=0;
  if (d<0) then
    begin
      b:=1;
      Exit;
    end;
  sqrt_d:=sqrt(d);
  with pt do
    begin
      x:=(v-sqrt_d)/w;
      y:=(v+sqrt_d)/w;
      b:=2+Byte((x<=k_div_t) and (k_div_t<=y));
      with Result do
        begin
          x0:=vec0.x0+f0*x;
          y0:=vec0.y0+f2*x;
          x1:=vec1.x0+f1*x;
          y1:=vec1.y0+f3*x;
        end;
    end;
end; {$endregion}
// (Rectangle-circle intersection) Пересечение прямоугольника и окружности:
function RctCrcInt(const rct:TRect  ; const x,y,r:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=False;
  if (rct.width =0) then
    Exit;
  if (rct.height=0) then
    Exit;
  with rct do
    Result:=IsPtInRct(x,y,left-r,top   ,right+r,bottom  ) or
            IsPtInRct(x,y,left  ,top-r ,right  ,bottom+r) or
            IsPtInCrc(x,y,left  ,top   ,r      ,0       ) or
            IsPtInCrc(x,y,left  ,bottom,r      ,0       ) or
            IsPtInCrc(x,y,right ,top   ,r      ,0       ) or
            IsPtInCrc(x,y,right ,bottom,r      ,0       );
end; {$endregion}
function RctCrcInt(const rct:TPtRect; const x,y,r:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=False;
  if (rct.width =0) then
    Exit;
  if (rct.height=0) then
    Exit;
  with rct do
    Result:=IsPtInRct(x,y,left-r,top   ,right+r,bottom  ) or
            IsPtInRct(x,y,left  ,top-r ,right  ,bottom+r) or
            IsPtInCrc(x,y,left  ,top   ,r      ,0       ) or
            IsPtInCrc(x,y,left  ,bottom,r      ,0       ) or
            IsPtInCrc(x,y,right ,top   ,r      ,0       ) or
            IsPtInCrc(x,y,right ,bottom,r      ,0       );
end; {$endregion}
// (Angle between two connected segments,(x1,y1) - connection point) Угол между двумя соединенными сегментами,(x1,y1) - точка соединения:
function GetAngle(const pt0,pt1,pt2      :TPtPosF): double; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
//Result:=ONE_DIV_BY_FULL_ROT*ArcCos(((pt0.x-pt1.x)*(pt2.x-pt1.x)+(pt0.y-pt1.y)*(pt2.y-pt1.y))/   Sqrt((Sqr(pt0.x-pt1.x)+Sqr(pt0.y-pt1.y))*(Sqr(pt2.x-pt1.x)+Sqr(pt2.y-pt1.y))));
  Result:=ONE_DIV_BY_FULL_ROT*ArcCos(((pt0.x-pt1.x)*(pt2.x-pt1.x)+(pt0.y-pt1.y)*(pt2.y-pt1.y))*InvSqrt((Sqr(pt0.x-pt1.x)+Sqr(pt0.y-pt1.y))*(Sqr(pt2.x-pt1.x)+Sqr(pt2.y-pt1.y))));
end; {$endregion}
function GetAngle(const x0,y0,x1,y1,x2,y2:double ): double; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
//Result:=ONE_DIV_BY_FULL_ROT*ArcCos(((x0-x1)*(x2-x1)+(y0-y1)*(y2-y1))/   Sqrt((Sqr(x0-x1)+Sqr(y0-y1))*(Sqr(x2-x1)+Sqr(y2-y1))));
  Result:=ONE_DIV_BY_FULL_ROT*ArcCos(((x0-x1)*(x2-x1)+(y0-y1)*(y2-y1))*InvSqrt((Sqr(x0-x1)+Sqr(y0-y1))*(Sqr(x2-x1)+Sqr(y2-y1))));
end; {$endregion}
// (Gauss's area formula, area multiplied by 2) Формула площади Гаусса, площадь, умноженная на 2:
function GaussPolygonArea(pt_cnt:integer; first_pt_ptr       :PPtPosF): double; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  s1: double=0;
  s2: double=0;
  i : integer;
begin
  for i :=0 to pt_cnt-2 do
    s1  +=(first_pt_ptr+i+0)^.x*
          (first_pt_ptr+i+1)^.y;
  for i :=0 to pt_cnt-2 do
    s2  +=(first_pt_ptr+i+0)^.y*
          (first_pt_ptr+i+1)^.x;
  Result:=Abs(s1-s2+(first_pt_ptr+pt_cnt-1)^.x*
                    (first_pt_ptr+00000000)^.y-
                    (first_pt_ptr+pt_cnt-1)^.y*
                    (first_pt_ptr+00000000)^.x){/2};
end; {$endregion}
function GaussSumTrisArea(pt_cnt:integer; first_pt_ptr,pt_out:PPtPosF): double; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;

  function GaussTriArea(pt0,pt1,pt2:TPtPosF): double; {$region -fold}
  begin
    Result:=Abs(pt0.x*(pt1.y-pt2.y)+pt1.x*(pt2.y-pt0.y)+pt2.x*(pt0.y-pt1.y)){/2};
  end; {$endregion}

begin
  Result  :=0;
  for i   :=0 to pt_cnt-2 do
    Result+=GaussTriArea((first_pt_ptr+i+000000)^,(first_pt_ptr+i+1)^,pt_out^);
    Result+=GaussTriArea((first_pt_ptr+pt_cnt-1)^,(first_pt_ptr+000)^,pt_out^);
end; {$endregion}

{$endregion}



(******************************* Color transform ******************************) {$region -fold}

//
function  Red            (pixel             :TColor): byte;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=TRGBA(pixel).r;
end; {$endregion}
function  Green          (pixel             :TColor): byte;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=TRGBA(pixel).g;
end; {$endregion}
function  Blue           (pixel             :TColor): byte;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=TRGBA(pixel).b;
end; {$endregion}
function  Alpha          (pixel             :TColor): byte;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=TRGBA(pixel).a;
end; {$endregion}
function  RGB            (r,g,b             :byte  ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(b<<16) or (g<<08) or r;
end; {$endregion}
function  RGBA           (r,g,b,a           :byte  ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=(a<<24) or (b<<16) or (g<<08) or r;
end; {$endregion}
function  ValToRGBA      (r,g,b,a           :byte  ): TRGBA ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result.r:=r;
  Result.g:=g;
  Result.b:=b;
  Result.a:=a;
end; {$endregion}
function  DWordToByte    (pixel             :TColor): byte;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=((TRGBA(pixel).r and 1)<<0)+
          ((TRGBA(pixel).g and 1)<<1)+
          ((TRGBA(pixel).b and 1)<<2)+
          ((TRGBA(pixel).a and 1)<<3);
end; {$endregion}
procedure ScalePix       (const dst_pix_ptr,src_pix_ptr:PInteger; const s:TColor); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
        (dst_pix_ptr)^:=
  (PRGBA(dst_pix_ptr)^.r+(s*(PRGBA(src_pix_ptr)^.r-PRGBA(dst_pix_ptr)^.r))>>16)<<00+
  (PRGBA(dst_pix_ptr)^.g+(s*(PRGBA(src_pix_ptr)^.g-PRGBA(dst_pix_ptr)^.g))>>16)<<08+
  (PRGBA(dst_pix_ptr)^.b+(s*(PRGBA(src_pix_ptr)^.b-PRGBA(dst_pix_ptr)^.b))>>16)<<16;
end; {$endregion}
function  PixCmp0        (pixel             :TColor;                                                                                                                              const pow:byte                       ): byte;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=Byte((TRGBA(pixel).r+pow<MAXBYTE) and
               (TRGBA(pixel).g+pow<MAXBYTE) and
               (TRGBA(pixel).b+pow<MAXBYTE));
end; {$endregion}
function  PixCmp0        (pixel_ptr         :PInteger;                                                                                                                            const pow:byte                       ): byte;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=Byte((PRGBA(pixel_ptr)^.r+pow<MAXBYTE) and
               (PRGBA(pixel_ptr)^.g+pow<MAXBYTE) and
               (PRGBA(pixel_ptr)^.b+pow<MAXBYTE));
end; {$endregion}
function  PixCmp1        (pixel             :TColor;                                                                                                                              const pow:byte                       ): byte;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=Byte((TRGBA(pixel).r-pow>=0) and
               (TRGBA(pixel).g-pow>=0) and
               (TRGBA(pixel).b-pow>=0));
end; {$endregion}
function  PixCmp1        (pixel_ptr         :PInteger;                                                                                                                            const pow:byte                       ): byte;   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=Byte((PRGBA(pixel_ptr)^.r-pow>=0) and
               (PRGBA(pixel_ptr)^.g-pow>=0) and
               (PRGBA(pixel_ptr)^.b-pow>=0));
end; {$endregion}
// Regular effect:
function  SetColorInv    (pixel             :TColor                                                                                                                                                                    ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  TRGBA(Result).r:=TRGBA(pixel).b;
  TRGBA(Result).g:=TRGBA(pixel).g;
  TRGBA(Result).b:=TRGBA(pixel).r;
end; {$endregion}
function  Color0         (pixel             :TColor;   const r            :byte=0; const g      :byte=0; const b         :byte=0; const alpha:byte=0; const d_alpha:byte=MAXBYTE; const pow:byte=64; const d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=pixel+d;
end; {$endregion}
procedure Color1         (pixel_ptr         :PInteger; const src_pix      :TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=src_pix;
end; {$endregion}
function  Additive0      (pixel             :TColor;   const r            :byte=0; const g      :byte=0; const b         :byte=0; const alpha:byte=0; const d_alpha:byte=MAXBYTE; const pow:byte=64; const d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Min(TRGBA(pixel).r+b,MAXBYTE),
              Min(TRGBA(pixel).g+g,MAXBYTE),
              Min(TRGBA(pixel).b+r,MAXBYTE));
end; {$endregion}
procedure Additive1      (pixel_ptr         :PInteger; const src_pix      :TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(Min(PRGBA(pixel_ptr)^.r+TRGBA(src_pix).r,MAXBYTE),
                  Min(PRGBA(pixel_ptr)^.g+TRGBA(src_pix).g,MAXBYTE),
                  Min(PRGBA(pixel_ptr)^.b+TRGBA(src_pix).b,MAXBYTE));
end; {$endregion}
procedure Additive2      (pixel_ptr         :PInteger; const src_pix      :TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(Min(PRGBA(pixel_ptr)^.r+TRGBA(src_pix).b,MAXBYTE),
                  Min(PRGBA(pixel_ptr)^.g+TRGBA(src_pix).g,MAXBYTE),
                  Min(PRGBA(pixel_ptr)^.b+TRGBA(src_pix).r,MAXBYTE));
end; {$endregion}
function  AlphaBlend0    (pixel             :TColor;   const r            :byte=0; const g      :byte=0; const b         :byte=0; const alpha:byte=0; const d_alpha:byte=MAXBYTE; const pow:byte=64; const d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=   (((TRGBA(pixel).b-r)*d_alpha)>>8+r)<<16+
             (((TRGBA(pixel).g-g)*d_alpha)>>8+g)<<08+
             (((TRGBA(pixel).r-b)*d_alpha)>>8+b)<<00;
         {RGB(((Red  (pixel)-b)*d_alpha+b<<8-b)>>8,
              ((Green(pixel)-g)*d_alpha+g<<8-g)>>8,
              ((Blue (pixel)-r)*d_alpha+r<<8-r)>>8);}
         {RGB(((Red  (pixel)-b)*d_alpha)>>8+b,
              ((Green(pixel)-g)*d_alpha)>>8+g,
              ((Blue (pixel)-r)*d_alpha)>>8+r);}
         {RGB((Red  (pixel)*d_alpha+b*alpha)>>8,
              (Green(pixel)*d_alpha+g*alpha)>>8,
              (Blue (pixel)*d_alpha+r*alpha)>>8);}
end; {$endregion}
procedure AlphaBlend1    (pixel_ptr         :PInteger; const src_pix      :TColor;                                                const alpha:byte                                                                     );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=(((PRGBA(pixel_ptr)^.b-TRGBA(src_pix).b)*alpha)>>8+TRGBA(src_pix).b)<<16+
              (((PRGBA(pixel_ptr)^.g-TRGBA(src_pix).g)*alpha)>>8+TRGBA(src_pix).g)<<08+
              (((PRGBA(pixel_ptr)^.r-TRGBA(src_pix).r)*alpha)>>8+TRGBA(src_pix).r)<<00;
end; {$endregion}
procedure AlphaBlend2    (pixel_ptr         :PInteger; const src_pix      :TColor;                                                const alpha:byte                                                                     );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=(((TRGBA(src_pix).b-PRGBA(pixel_ptr)^.b)*alpha)>>8+PRGBA(pixel_ptr)^.b)<<16+
              (((TRGBA(src_pix).g-PRGBA(pixel_ptr)^.g)*alpha)>>8+PRGBA(pixel_ptr)^.g)<<08+
              (((TRGBA(src_pix).r-PRGBA(pixel_ptr)^.r)*alpha)>>8+PRGBA(pixel_ptr)^.r)<<00;
end; {$endregion}
procedure AlphaBlend3    (pixel_ptr         :PInteger; const r,g,b        :byte;                                                  const alpha:byte                                                                     );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=(((PRGBA(pixel_ptr)^.b-b)*alpha)>>8+b)<<16+
              (((PRGBA(pixel_ptr)^.g-g)*alpha)>>8+g)<<08+
              (((PRGBA(pixel_ptr)^.r-r)*alpha)>>8+r)<<00;
end; {$endregion}
procedure AlphaBlend4    (dst_pix_ptr       :PInteger; const src_pix_ptr  :PColor;                                                const alpha:byte; const h:integer                                                    );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  //r,g,b: integer;
  a    : byte;}
begin
  //a           :=256-alpha;
  dst_pix_ptr^:=(PRGBA(dst_pix_ptr)^.r+(alpha*((h*(PRGBA(src_pix_ptr)^.r-PRGBA(dst_pix_ptr)^.r))>>16))>>8)<<00+
                (PRGBA(dst_pix_ptr)^.g+(alpha*((h*(PRGBA(src_pix_ptr)^.g-PRGBA(dst_pix_ptr)^.g))>>16))>>8)<<08+
                (PRGBA(dst_pix_ptr)^.b+(alpha*((h*(PRGBA(src_pix_ptr)^.b-PRGBA(dst_pix_ptr)^.b))>>16))>>8)<<16;
 {r:=        (h*(PRGBA(src_pix_ptr)^.r-PRGBA(dst_pix_ptr)^.r))>>16;
  g:=        (h*(PRGBA(src_pix_ptr)^.g-PRGBA(dst_pix_ptr)^.g))>>16;
  b:=        (h*(PRGBA(src_pix_ptr)^.b-PRGBA(dst_pix_ptr)^.b))>>16;
  dst_pix_ptr^:=(PRGBA(dst_pix_ptr)^.r+(r*a)>>8)<<00+
                (PRGBA(dst_pix_ptr)^.g+(g*a)>>8)<<08+
                (PRGBA(dst_pix_ptr)^.b+(b*a)>>8)<<16;}
 {dst_pix_ptr^:=((-r*alpha)>>8+PRGBA(dst_pix_ptr)^.r +r)<<00+
                ((-g*alpha)>>8+PRGBA(dst_pix_ptr)^.g +g)<<08+
                ((-b*alpha)>>8+PRGBA(dst_pix_ptr)^.b +b)<<16;}
end; {$endregion}
procedure AlphaBlend5    (dst_pix_ptr       :PInteger; const src_pix_ptr  :PColor;                                                const alpha:byte; const h:integer                                                    );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  a0      : integer;
  r1,g1,b1: smallint;
  a       : byte;
begin
  a :=256-alpha;
  r1:=PRGBA(src_pix_ptr)^.r-PRGBA(dst_pix_ptr)^.r;
  g1:=PRGBA(src_pix_ptr)^.g-PRGBA(dst_pix_ptr)^.g;
  b1:=PRGBA(src_pix_ptr)^.b-PRGBA(dst_pix_ptr)^.b;
  if (r1*g1*b1>=000) and
     (h       < 515) then
    begin
      a0          :=a*(h>>24);
      dst_pix_ptr^:=(PRGBA(dst_pix_ptr)^.r+r1*a0)<<00+
                    (PRGBA(dst_pix_ptr)^.g+g1*a0)<<08+
                    (PRGBA(dst_pix_ptr)^.b+b1*a0)<<16;
    end
  else
    begin
      dst_pix_ptr^:=(PRGBA(dst_pix_ptr)^.r+(((h*r1)>>16)*a)>>8)<<00+
                    (PRGBA(dst_pix_ptr)^.g+(((h*g1)>>16)*a)>>8)<<08+
                    (PRGBA(dst_pix_ptr)^.b+(((h*b1)>>16)*a)>>8)<<16;
     {dst_pix_ptr^:=((-r0*alpha)>>8+PRGBA(dst_pix_ptr)^.r +r0)<<00+
                    ((-g0*alpha)>>8+PRGBA(dst_pix_ptr)^.g +g0)<<08+
                    ((-b0*alpha)>>8+PRGBA(dst_pix_ptr)^.b +b0)<<16;}
    end;
end; {$endregion}
function  Inverse0       (pixel             :TColor;   const r            :byte=0; const g      :byte=0; const b         :byte=0; const alpha:byte=0; const d_alpha:byte=MAXBYTE; const pow:byte=64; const d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=Integer($ffffffff-pixel);
end; {$endregion}
procedure Inverse1       (pixel_ptr         :PInteger                                                                                                                                                                  );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:={Integer}($ffffffff-pixel_ptr^);
end; {$endregion}
function  Inverse2       (pixel             :TColor                                                                                                                                                                    ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=TColor($ffffffff-pixel);
end; {$endregion}
function  Highlight0     (pixel             :TColor;   const r            :byte=0; const g      :byte=0; const b         :byte=0; const alpha:byte=0; const d_alpha:byte=MAXBYTE; const pow:byte=64; const d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Min3(TRGBA (pixel).r+pow,MAXBYTE),
              Min3(TRGBA (pixel).g+pow,MAXBYTE),
              Min3(TRGBA (pixel).b+pow,MAXBYTE));
end; {$endregion}
procedure Highlight1     (pixel_ptr         :PInteger;                                                                                                                            const pow:byte                       );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(Min3(PRGBA(pixel_ptr)^.r+pow,MAXBYTE),
                  Min3(PRGBA(pixel_ptr)^.g+pow,MAXBYTE),
                  Min3(PRGBA(pixel_ptr)^.b+pow,MAXBYTE));
end; {$endregion}
function  Highlight2     (pixel             :TColor;                                                                                                                              const pow:byte                       ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Min3(TRGBA (pixel).r+pow,MAXBYTE),
              Min3(TRGBA (pixel).g+pow,MAXBYTE),
              Min3(TRGBA (pixel).b+pow,MAXBYTE));
end; {$endregion}
function  HighlightLimit (pixel             :TColor;                                                                                                                              const pow:byte                       ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if Boolean(PixCmp0(pixel,pow)) then
    Result:=RGB(Min3(TRGBA (pixel).r+pow,MAXBYTE),
                Min3(TRGBA (pixel).g+pow,MAXBYTE),
                Min3(TRGBA (pixel).b+pow,MAXBYTE))
  else
    Result:=pixel;
end; {$endregion}
function  Darken0        (pixel             :TColor;   const r            :byte=0; const g      :byte=0; const b         :byte=0; const alpha:byte=0; const d_alpha:byte=MAXBYTE; const pow:byte=64; const d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Max2(TRGBA (pixel).r-pow,0),
              Max2(TRGBA (pixel).g-pow,0),
              Max2(TRGBA (pixel).b-pow,0));
end; {$endregion}
procedure Darken1        (pixel_ptr         :PInteger;                                                                                                                            const pow:byte                       );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(Max2(PRGBA(pixel_ptr)^.r-pow,0),
                  Max2(PRGBA(pixel_ptr)^.g-pow,0),
                  Max2(PRGBA(pixel_ptr)^.b-pow,0));
end; {$endregion}
function  Darken2        (pixel             :TColor;                                                                                                                              const pow:byte                       ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Max2(TRGBA (pixel).r-pow,0),
              Max2(TRGBA (pixel).g-pow,0),
              Max2(TRGBA (pixel).b-pow,0));
end; {$endregion}
function  DarkenLimit    (pixel             :TColor;                                                                                                                              const pow:byte                       ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if Boolean(PixCmp1(pixel,pow)) then
    Result:=RGB(Max2(TRGBA(pixel).r-pow,0),
                Max2(TRGBA(pixel).g-pow,0),
                Max2(TRGBA(pixel).b-pow,0))
  else
    Result:=pixel;
end; {$endregion}
function  GrayscaleR0    (pixel             :TColor;   const r            :byte=0; const g      :byte=0; const b         :byte=0; const alpha:byte=0; const d_alpha:byte=MAXBYTE; const pow:byte=64; const d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(TRGBA(pixel).r,
              TRGBA(pixel).r,
              TRGBA(pixel).r);
end; {$endregion}
procedure GrayscaleR1    (pixel_ptr         :PInteger                                                                                                                                                                  );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(PRGBA(pixel_ptr)^.r,
                  PRGBA(pixel_ptr)^.r,
                  PRGBA(pixel_ptr)^.r);
end; {$endregion}
function  GrayscaleG0    (pixel             :TColor;   const r            :byte=0; const g      :byte=0; const b         :byte=0; const alpha:byte=0; const d_alpha:byte=MAXBYTE; const pow:byte=64; const d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(TRGBA(pixel).g,
              TRGBA(pixel).g,
              TRGBA(pixel).g);
end; {$endregion}
procedure GrayscaleG1    (pixel_ptr         :PInteger                                                                                                                                                                  );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(PRGBA(pixel_ptr)^.g,
                  PRGBA(pixel_ptr)^.g,
                  PRGBA(pixel_ptr)^.g);
end; {$endregion}
function  GrayscaleB0    (pixel             :TColor;   const r            :byte=0; const g      :byte=0; const b         :byte=0; const alpha:byte=0; const d_alpha:byte=MAXBYTE; const pow:byte=64; const d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(TRGBA(pixel).b,
              TRGBA(pixel).b,
              TRGBA(pixel).b);
end; {$endregion}
procedure GrayscaleB1    (pixel_ptr         :PInteger                                                                                                                                                                  );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(PRGBA(pixel_ptr)^.b,
                  PRGBA(pixel_ptr)^.b,
                  PRGBA(pixel_ptr)^.b);
end; {$endregion}
function  ColorizeR0     (pixel             :TColor;   const r            :byte=0; const g      :byte=0; const b         :byte=0; const alpha:byte=0; const d_alpha:byte=MAXBYTE; const pow:byte=64; const d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=pixel-TRGBA(pixel).b<<16+Byte(TRGBA(pixel).r+pow>>1-64)<<16;
end; {$endregion}
procedure ColorizeR1     (pixel_ptr         :PInteger; const pow          :byte                                                                                                                                        );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=pixel_ptr^-PRGBA(pixel_ptr)^.b<<16+Byte(PRGBA(pixel_ptr)^.r+pow>>1-64)<<16;
end; {$endregion}
function  ColorizeG0     (pixel             :TColor;   const r            :byte=0; const g      :byte=0; const b         :byte=0; const alpha:byte=0; const d_alpha:byte=MAXBYTE; const pow:byte=64; const d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=pixel-TRGBA(pixel).g<<08+Byte(TRGBA(pixel).g+pow>>1-64)<<08;
end; {$endregion}
procedure ColorizeG1     (pixel_ptr         :PInteger; const pow          :byte                                                                                                                                        );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=pixel_ptr^-PRGBA(pixel_ptr)^.g<<08+Byte(PRGBA(pixel_ptr)^.g+pow>>1-64)<<08;
end; {$endregion}
function  ColorizeB0     (pixel             :TColor;   const r            :byte=0; const g      :byte=0; const b         :byte=0; const alpha:byte=0; const d_alpha:byte=MAXBYTE; const pow:byte=64; const d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=pixel-TRGBA(pixel).r<<00+Byte(TRGBA(pixel).b+pow>>1-64)<<00;
end; {$endregion}
procedure ColorizeB1     (pixel_ptr         :PInteger; const pow          :byte                                                                                                                                        );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=pixel_ptr^-PRGBA(pixel_ptr)^.r<<00+Byte(PRGBA(pixel_ptr)^.b+pow>>1-64)<<00;
end; {$endregion}
function  BlurRGB4_      (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(      (Red  ((pixel_ptr-bmp_dst_width-1)^)+                                    Red  ((pixel_ptr-bmp_dst_width+1)^)+Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))>>2,
                    (Green((pixel_ptr-bmp_dst_width-1)^)+                                    Green((pixel_ptr-bmp_dst_width+1)^)+Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+1)^))>>2,
                    (Blue ((pixel_ptr-bmp_dst_width-1)^)+                                    Blue ((pixel_ptr-bmp_dst_width+1)^)+Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))>>2);
end; {$endregion}
function  BlurRGB5_      (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Trunc((Red  ((pixel_ptr-bmp_dst_width-1)^)+                                    Red  ((pixel_ptr-bmp_dst_width+1)^)+Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+1)^)+                                                          Red  ((pixel_ptr+0)^))/5),
              Trunc((Green((pixel_ptr-bmp_dst_width-1)^)+                                    Green((pixel_ptr-bmp_dst_width+1)^)+Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+1)^)+                                                          Green((pixel_ptr+0)^))/5),
              Trunc((Blue ((pixel_ptr-bmp_dst_width-1)^)+                                    Blue ((pixel_ptr-bmp_dst_width+1)^)+Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+1)^)+                                                          Blue ((pixel_ptr+0)^))/5));
end; {$endregion}
function  BlurRGB8_      (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr-1)^)+Red  ((pixel_ptr+1)^))>>3,
              (Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+1)^)+Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr-1)^)+Green((pixel_ptr+1)^))>>3,
              (Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr-1)^)+Blue ((pixel_ptr+1)^))>>3);
end; {$endregion}
function  BlurRGB9_      (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Trunc((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr-1)^)+Red  ((pixel_ptr+0)^)+Red  ((pixel_ptr+1)^))/9),
              Trunc((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+1)^)+Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr-1)^)+Green((pixel_ptr+0)^)+Green((pixel_ptr+1)^))/9),
              Trunc((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr-1)^)+Blue ((pixel_ptr+0)^)+Blue ((pixel_ptr+1)^))/9));
end; {$endregion}
procedure BlurRGB4       (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(  (Red  ((pixel_ptr-bmp_dst_width-1)^)+                                    Red  ((pixel_ptr-bmp_dst_width+1)^)+Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))>>2,
                    (Green((pixel_ptr-bmp_dst_width-1)^)+                                    Green((pixel_ptr-bmp_dst_width+1)^)+Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+1)^))>>2,
                    (Blue ((pixel_ptr-bmp_dst_width-1)^)+                                    Blue ((pixel_ptr-bmp_dst_width+1)^)+Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))>>2);
end; {$endregion}
procedure BlurRGB5       (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(Trunc((Red  ((pixel_ptr-bmp_dst_width-1)^)+                                    Red  ((pixel_ptr-bmp_dst_width+1)^)+Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+1)^)+                                                          Red  ((pixel_ptr+0)^))/5),
                  Trunc((Green((pixel_ptr-bmp_dst_width-1)^)+                                    Green((pixel_ptr-bmp_dst_width+1)^)+Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+1)^)+                                                          Green((pixel_ptr+0)^))/5),
                  Trunc((Blue ((pixel_ptr-bmp_dst_width-1)^)+                                    Blue ((pixel_ptr-bmp_dst_width+1)^)+Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+1)^)+                                                          Blue ((pixel_ptr+0)^))/5));
end; {$endregion}
procedure BlurRGB9       (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(Trunc((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^)+Red  ((pixel_ptr-1)^)+Red  ((pixel_ptr+0)^)+Red  ((pixel_ptr+1)^))/9),
                  Trunc((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^)+Green((pixel_ptr-1)^)+Green((pixel_ptr+0)^)+Green((pixel_ptr+1)^))/9),
                  Trunc((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^)+Blue ((pixel_ptr-1)^)+Blue ((pixel_ptr+0)^)+Blue ((pixel_ptr+1)^))/9));
end; {$endregion}
procedure BlurRRB4       (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=        (Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+Red ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))>>2;
  pixel_ptr^:=RGB(r,r,(Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+Blue((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))>>2);
end; {$endregion}
procedure BlurRGR4       (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=        (Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))>>2;
  pixel_ptr^:=RGB(r,  (Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+1)^)+Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+1)^))>>2,r);
end; {$endregion}
procedure BlurGGB4       (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=        (Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+1)^)+Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+1)^))>>2;
  pixel_ptr^:=RGB(g,g,(Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))>>2);
end; {$endregion}
procedure BlurRGG4       (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=        (Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+1)^)+Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+1)^))>>2;
  pixel_ptr^:=RGB(    (Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))>>2,g,g);
end; {$endregion}
procedure BlurBGB4       (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=        (Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))>>2;
  pixel_ptr^:=RGB(b,  (Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+1)^)+Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+1)^))>>2,b);
end; {$endregion}
procedure BlurRBB4       (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=        (Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))>>2;
  pixel_ptr^:=RGB(    (Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))>>2,b,b);
end; {$endregion}
procedure BlurRRR4       (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r:=(Red((pixel_ptr-bmp_dst_width-1)^)+
      Red((pixel_ptr-bmp_dst_width+1)^)+
      Red((pixel_ptr+bmp_dst_width-1)^)+
      Red((pixel_ptr+bmp_dst_width+1)^))>>2;
           pixel_ptr^:=RGB(r,r,r);
end; {$endregion}
procedure BlurGGG4       (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g:=(Green((pixel_ptr-bmp_dst_width-1)^)+
      Green((pixel_ptr-bmp_dst_width+1)^)+
      Green((pixel_ptr+bmp_dst_width-1)^)+
      Green((pixel_ptr+bmp_dst_width+1)^))>>2;
             pixel_ptr^:=RGB(g,g,g);
end; {$endregion}
procedure BlurBBB4       (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b:=(Blue((pixel_ptr-bmp_dst_width-1)^)+
      Blue((pixel_ptr-bmp_dst_width+1)^)+
      Blue((pixel_ptr+bmp_dst_width-1)^)+
      Blue((pixel_ptr+bmp_dst_width+1)^))>>2;
            pixel_ptr^:=RGB(b,b,b);
end; {$endregion}
{RGB}
procedure BlurRGBProc0   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(Trunc((                                                                                                                                  Red  ((pixel_ptr+1)^)+                                    Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))/3),
                  Trunc((                                                                                                                                  Green((pixel_ptr+1)^)+                                    Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^))/3),
                  Trunc((                                                                                                                                  Blue ((pixel_ptr+1)^)+                                    Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))/3));
end; {$endregion}
procedure BlurRGBProc1   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(Trunc((                                                                                                            Red  ((pixel_ptr-1)^)+Red  ((pixel_ptr+1)^)+Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))/5),
                  Trunc((                                                                                                            Green((pixel_ptr-1)^)+Green((pixel_ptr+1)^)+Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^))/5),
                  Trunc((                                                                                                            Blue ((pixel_ptr-1)^)+Blue ((pixel_ptr+1)^)+Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))/5));
end; {$endregion}
procedure BlurRGBProc2   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(Trunc((                                                                                                            Red  ((pixel_ptr-1)^)+                      Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)                                    )/3),
                  Trunc((                                                                                                            Green((pixel_ptr-1)^)+                      Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)                                    )/3),
                  Trunc((                                                                                                            Blue ((pixel_ptr-1)^)+                      Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)                                    )/3));
end; {$endregion}
procedure BlurRGBProc3   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(Trunc((                                    Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+                      Red  ((pixel_ptr+1)^)+                                    Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))/5),
                  Trunc((                                    Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+                      Green((pixel_ptr+1)^)+                                    Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^))/5),
                  Trunc((                                    Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+                      Blue ((pixel_ptr+1)^)+                                    Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))/5));
end; {$endregion}
procedure BlurRGBProc4   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(     ((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+Red  ((pixel_ptr-1)^)+Red  ((pixel_ptr+1)^)+Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))>>3),
                       ((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+Green((pixel_ptr-1)^)+Green((pixel_ptr+1)^)+Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^))>>3),
                       ((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+Blue ((pixel_ptr-1)^)+Blue ((pixel_ptr+1)^)+Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))>>3));
end; {$endregion}
procedure BlurRGBProc5   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(Trunc((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+                                    Red  ((pixel_ptr-1)^)+                      Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)                                    )/5),
                  Trunc((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+                                    Green((pixel_ptr-1)^)+                      Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)                                    )/5),
                  Trunc((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+                                    Blue ((pixel_ptr-1)^)+                      Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)                                    )/5));
end; {$endregion}
procedure BlurRGBProc6   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(Trunc((                                    Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+                      Red  ((pixel_ptr+1)^)                                                                                                            )/3),
                  Trunc((                                    Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+                      Green((pixel_ptr+1)^)                                                                                                            )/3),
                  Trunc((                                    Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+                      Blue ((pixel_ptr+1)^)                                                                                                            )/3));
end; {$endregion}
procedure BlurRGBProc7   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(Trunc((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+Red  ((pixel_ptr-1)^)+Red  ((pixel_ptr+1)^)                                                                                                            )/5),
                  Trunc((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+Green((pixel_ptr-1)^)+Green((pixel_ptr+1)^)                                                                                                            )/5),
                  Trunc((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+Blue ((pixel_ptr-1)^)+Blue ((pixel_ptr+1)^)                                                                                                            )/5));
end; {$endregion}
procedure BlurRGBProc8   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(Trunc((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+                                    Red  ((pixel_ptr-1)^)                                                                                                                                  )/3),
                  Trunc((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+                                    Green((pixel_ptr-1)^)                                                                                                                                  )/3),
                  Trunc((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+                                    Blue ((pixel_ptr-1)^)                                                                                                                                  )/3));
end; {$endregion}
{RRB}
procedure BlurRRBProc0   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=        Trunc((                                                                                                                                  Red  ((pixel_ptr+1)^)+                                    Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))/3);
  pixel_ptr^:=RGB(r,r,Trunc((                                                                                                                                  Blue ((pixel_ptr+1)^)+                                    Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))/3));
end; {$endregion}
procedure BlurRRBProc1   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=        Trunc((                                                                                                            Red  ((pixel_ptr-1)^)+Red  ((pixel_ptr+1)^)+Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))/5);
  pixel_ptr^:=RGB(r,r,Trunc((                                                                                                            Blue ((pixel_ptr-1)^)+Blue ((pixel_ptr+1)^)+Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))/5));
end; {$endregion}
procedure BlurRRBProc2   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=        Trunc((                                                                                                            Red  ((pixel_ptr-1)^)+                      Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)                                    )/3);
  pixel_ptr^:=RGB(r,r,Trunc((                                                                                                            Blue ((pixel_ptr-1)^)+                      Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)                                    )/3));
end; {$endregion}
procedure BlurRRBProc3   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=        Trunc((                                    Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+                      Red  ((pixel_ptr+1)^)+                                    Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))/5);
  pixel_ptr^:=RGB(r,r,Trunc((                                    Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+                      Blue ((pixel_ptr+1)^)+                                    Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))/5));
end; {$endregion}
procedure BlurRRBProc4   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=             ((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+Red  ((pixel_ptr-1)^)+Red  ((pixel_ptr+1)^)+Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))>>3);
  pixel_ptr^:=RGB(r,r,     ((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+Blue ((pixel_ptr-1)^)+Blue ((pixel_ptr+1)^)+Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))>>3));
end; {$endregion}
procedure BlurRRBProc5   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=        Trunc((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+                                    Red  ((pixel_ptr-1)^)+                      Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)                                    )/5);
  pixel_ptr^:=RGB(r,r,Trunc((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+                                    Blue ((pixel_ptr-1)^)+                      Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)                                    )/5));
end; {$endregion}
procedure BlurRRBProc6   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=        Trunc((                                    Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+                      Red  ((pixel_ptr+1)^)                                                                                                            )/3);
  pixel_ptr^:=RGB(r,r,Trunc((                                    Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+                      Blue ((pixel_ptr+1)^)                                                                                                            )/3));
end; {$endregion}
procedure BlurRRBProc7   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=        Trunc((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+Red  ((pixel_ptr-1)^)+Red  ((pixel_ptr+1)^)                                                                                                            )/5);
  pixel_ptr^:=RGB(r,r,Trunc((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+Blue ((pixel_ptr-1)^)+Blue ((pixel_ptr+1)^)                                                                                                            )/5));
end; {$endregion}
procedure BlurRRBProc8   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=        Trunc((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+                                    Red  ((pixel_ptr-1)^)                                                                                                                                  )/3);
  pixel_ptr^:=RGB(r,r,Trunc((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+                                    Blue ((pixel_ptr-1)^)                                                                                                                                  )/3));
end; {$endregion}
{RGR}
procedure BlurRGRProc0   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=      Trunc((                                                                                                                                  Red  ((pixel_ptr+1)^)+                                    Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))/3);
  pixel_ptr^:=RGB(r,Trunc((                                                                                                                                  Green((pixel_ptr+1)^)+                                    Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^))/3),r);
end; {$endregion}
procedure BlurRGRProc1   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=      Trunc((                                                                                                            Red  ((pixel_ptr-1)^)+Red  ((pixel_ptr+1)^)+Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))/5);
  pixel_ptr^:=RGB(r,Trunc((                                                                                                            Green((pixel_ptr-1)^)+Green((pixel_ptr+1)^)+Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^))/5),r);
end; {$endregion}
procedure BlurRGRProc2   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=      Trunc((                                                                                                            Red  ((pixel_ptr-1)^)+                      Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)                                    )/3);
  pixel_ptr^:=RGB(r,Trunc((                                                                                                            Green((pixel_ptr-1)^)+                      Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)                                    )/3),r);
end; {$endregion}
procedure BlurRGRProc3   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=      Trunc((                                    Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+                      Red  ((pixel_ptr+1)^)+                                    Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))/5);
  pixel_ptr^:=RGB(r,Trunc((                                    Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+                      Green((pixel_ptr+1)^)+                                    Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^))/5),r);
end; {$endregion}
procedure BlurRGRProc4   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=           ((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+Red  ((pixel_ptr-1)^)+Red  ((pixel_ptr+1)^)+Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))>>3);
  pixel_ptr^:=RGB(r,     ((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+Green((pixel_ptr-1)^)+Green((pixel_ptr+1)^)+Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^))>>3),r);
end; {$endregion}
procedure BlurRGRProc5   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=      Trunc((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+                                    Red  ((pixel_ptr-1)^)+                      Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)                                    )/5);
  pixel_ptr^:=RGB(r,Trunc((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+                                    Green((pixel_ptr-1)^)+                      Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)                                    )/5),r);
end; {$endregion}
procedure BlurRGRProc6   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=      Trunc((                                    Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+                      Red  ((pixel_ptr+1)^)                                                                                                            )/3);
  pixel_ptr^:=RGB(r,Trunc((                                    Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+                      Green((pixel_ptr+1)^)                                                                                                            )/3),r);
end; {$endregion}
procedure BlurRGRProc7   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=      Trunc((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+Red  ((pixel_ptr-1)^)+Red  ((pixel_ptr+1)^)                                                                                                            )/5);
  pixel_ptr^:=RGB(r,Trunc((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+Green((pixel_ptr-1)^)+Green((pixel_ptr+1)^)                                                                                                            )/5),r);
end; {$endregion}
procedure BlurRGRProc8   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=      Trunc((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+                                    Red  ((pixel_ptr-1)^)                                                                                                                                  )/3);
  pixel_ptr^:=RGB(r,Trunc((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+                                    Green((pixel_ptr-1)^)                                                                                                                                  )/3),r);
end; {$endregion}
{GGB}
procedure BlurGGBProc0   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=        Trunc((                                                                                                                                  Green((pixel_ptr+1)^)+                                    Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^))/3);
  pixel_ptr^:=RGB(g,g,Trunc((                                                                                                                                  Blue ((pixel_ptr+1)^)+                                    Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))/3));
end; {$endregion}
procedure BlurGGBProc1   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=        Trunc((                                                                                                            Green((pixel_ptr-1)^)+Green((pixel_ptr+1)^)+Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^))/5);
  pixel_ptr^:=RGB(g,g,Trunc((                                                                                                            Blue ((pixel_ptr-1)^)+Blue ((pixel_ptr+1)^)+Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))/5));
end; {$endregion}
procedure BlurGGBProc2   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=        Trunc((                                                                                                            Green((pixel_ptr-1)^)+                      Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)                                    )/3);
  pixel_ptr^:=RGB(g,g,Trunc((                                                                                                            Blue ((pixel_ptr-1)^)+                      Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)                                    )/3));
end; {$endregion}
procedure BlurGGBProc3   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=        Trunc((                                    Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+                      Green((pixel_ptr+1)^)+                                    Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^))/5);
  pixel_ptr^:=RGB(g,g,Trunc((                                    Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+                      Blue ((pixel_ptr+1)^)+                                    Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))/5));
end; {$endregion}
procedure BlurGGBProc4   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=             ((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+Green((pixel_ptr-1)^)+Green((pixel_ptr+1)^)+Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^))>>3);
  pixel_ptr^:=RGB(g,g,     ((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+Blue ((pixel_ptr-1)^)+Blue ((pixel_ptr+1)^)+Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))>>3));
end; {$endregion}
procedure BlurGGBProc5   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=        Trunc((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+                                    Green((pixel_ptr-1)^)+                      Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)                                    )/5);
  pixel_ptr^:=RGB(g,g,Trunc((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+                                    Blue ((pixel_ptr-1)^)+                      Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)                                    )/5));
end; {$endregion}
procedure BlurGGBProc6   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=        Trunc((                                    Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+                      Green((pixel_ptr+1)^)                                                                                                            )/3);
  pixel_ptr^:=RGB(g,g,Trunc((                                    Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+                      Blue ((pixel_ptr+1)^)                                                                                                            )/3));
end; {$endregion}
procedure BlurGGBProc7   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=        Trunc((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+Green((pixel_ptr-1)^)+Green((pixel_ptr+1)^)                                                                                                            )/5);
  pixel_ptr^:=RGB(g,g,Trunc((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+Blue ((pixel_ptr-1)^)+Blue ((pixel_ptr+1)^)                                                                                                            )/5));
end; {$endregion}
procedure BlurGGBProc8   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=        Trunc((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+                                    Green((pixel_ptr-1)^)                                                                                                                                  )/3);
  pixel_ptr^:=RGB(g,g,Trunc((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+                                    Blue ((pixel_ptr-1)^)                                                                                                                                  )/3));
end; {$endregion}
{RGG}
procedure BlurRGGProc0   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=    Trunc((                                                                                                                                  Green((pixel_ptr+1)^)+                                    Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^))/3);
  pixel_ptr^:=RGB(Trunc((                                                                                                                                  Red  ((pixel_ptr+1)^)+                                    Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))/3),g,g);
end; {$endregion}
procedure BlurRGGProc1   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=    Trunc((                                                                                                            Green((pixel_ptr-1)^)+Green((pixel_ptr+1)^)+Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^))/5);
  pixel_ptr^:=RGB(Trunc((                                                                                                            Red  ((pixel_ptr-1)^)+Red  ((pixel_ptr+1)^)+Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))/5),g,g);
end; {$endregion}
procedure BlurRGGProc2   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=    Trunc((                                                                                                            Green((pixel_ptr-1)^)+                      Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)                                    )/3);
  pixel_ptr^:=RGB(Trunc((                                                                                                            Red  ((pixel_ptr-1)^)+                      Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)                                    )/3),g,g);
end; {$endregion}
procedure BlurRGGProc3   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=    Trunc((                                    Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+                      Green((pixel_ptr+1)^)+                                    Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^))/5);
  pixel_ptr^:=RGB(Trunc((                                    Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+                      Red  ((pixel_ptr+1)^)+                                    Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))/5),g,g);
end; {$endregion}
procedure BlurRGGProc4   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=         ((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+Green((pixel_ptr-1)^)+Green((pixel_ptr+1)^)+Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^))>>3);
  pixel_ptr^:=RGB(     ((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+Red  ((pixel_ptr-1)^)+Red  ((pixel_ptr+1)^)+Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))>>3),g,g);
end; {$endregion}
procedure BlurRGGProc5   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=    Trunc((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+                                    Green((pixel_ptr-1)^)+                      Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)                                    )/5);
  pixel_ptr^:=RGB(Trunc((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+                                    Red  ((pixel_ptr-1)^)+                      Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)                                    )/5),g,g);
end; {$endregion}
procedure BlurRGGProc6   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=    Trunc((                                    Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+                      Green((pixel_ptr+1)^)                                                                                                            )/3);
  pixel_ptr^:=RGB(Trunc((                                    Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+                      Red  ((pixel_ptr+1)^)                                                                                                            )/3),g,g);
end; {$endregion}
procedure BlurRGGProc7   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=    Trunc((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+Green((pixel_ptr-1)^)+Green((pixel_ptr+1)^)                                                                                                            )/5);
  pixel_ptr^:=RGB(Trunc((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+Red  ((pixel_ptr-1)^)+Red  ((pixel_ptr+1)^)                                                                                                            )/5),g,g);
end; {$endregion}
procedure BlurRGGProc8   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=    Trunc((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+                                    Green((pixel_ptr-1)^)                                                                                                                                  )/3);
  pixel_ptr^:=RGB(Trunc((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+                                    Red  ((pixel_ptr-1)^)                                                                                                                                  )/3),g,g);
end; {$endregion}
{BGB}
procedure BlurBGBProc0   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=      Trunc((                                                                                                                                  Blue ((pixel_ptr+1)^)+                                    Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))/3);
  pixel_ptr^:=RGB(b,Trunc((                                                                                                                                  Green((pixel_ptr+1)^)+                                    Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^))/3),b);
end; {$endregion}
procedure BlurBGBProc1   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=      Trunc((                                                                                                            Blue ((pixel_ptr-1)^)+Blue ((pixel_ptr+1)^)+Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))/5);
  pixel_ptr^:=RGB(b,Trunc((                                                                                                            Green((pixel_ptr-1)^)+Green((pixel_ptr+1)^)+Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^))/5),b);
end; {$endregion}
procedure BlurBGBProc2   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=      Trunc((                                                                                                            Blue ((pixel_ptr-1)^)+                      Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)                                    )/3);
  pixel_ptr^:=RGB(b,Trunc((                                                                                                            Green((pixel_ptr-1)^)+                      Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)                                    )/3),b);
end; {$endregion}
procedure BlurBGBProc3   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=      Trunc((                                    Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+                      Blue ((pixel_ptr+1)^)+                                    Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))/5);
  pixel_ptr^:=RGB(b,Trunc((                                    Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+                      Green((pixel_ptr+1)^)+                                    Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^))/5),b);
end; {$endregion}
procedure BlurBGBProc4   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=           ((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+Blue ((pixel_ptr-1)^)+Blue ((pixel_ptr+1)^)+Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))>>3);
  pixel_ptr^:=RGB(b,     ((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+Green((pixel_ptr-1)^)+Green((pixel_ptr+1)^)+Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^))>>3),b);
end; {$endregion}
procedure BlurBGBProc5   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=      Trunc((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+                                    Blue ((pixel_ptr-1)^)+                      Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)                                    )/5);
  pixel_ptr^:=RGB(b,Trunc((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+                                    Green((pixel_ptr-1)^)+                      Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)                                    )/5),b);
end; {$endregion}
procedure BlurBGBProc6   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=      Trunc((                                    Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+                      Blue ((pixel_ptr+1)^)                                                                                                            )/3);
  pixel_ptr^:=RGB(b,Trunc((                                    Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+                      Green((pixel_ptr+1)^)                                                                                                            )/3),b);
end; {$endregion}
procedure BlurBGBProc7   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=      Trunc((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+Blue ((pixel_ptr-1)^)+Blue ((pixel_ptr+1)^)                                                                                                            )/5);
  pixel_ptr^:=RGB(b,Trunc((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+Green((pixel_ptr-1)^)+Green((pixel_ptr+1)^)                                                                                                            )/5),b);
end; {$endregion}
procedure BlurBGBProc8   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=      Trunc((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+                                    Blue ((pixel_ptr-1)^)                                                                                                                                  )/3);
  pixel_ptr^:=RGB(b,Trunc((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+                                    Green((pixel_ptr-1)^)                                                                                                                                  )/3),b);
end; {$endregion}
{RBB}
procedure BlurRBBProc0   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=    Trunc((                                                                                                                                  Blue ((pixel_ptr+1)^)+                                    Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))/3);
  pixel_ptr^:=RGB(Trunc((                                                                                                                                  Red  ((pixel_ptr+1)^)+                                    Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))/3),b,b);
end; {$endregion}
procedure BlurRBBProc1   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=    Trunc((                                                                                                            Blue ((pixel_ptr-1)^)+Blue ((pixel_ptr+1)^)+Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))/5);
  pixel_ptr^:=RGB(Trunc((                                                                                                            Red  ((pixel_ptr-1)^)+Red  ((pixel_ptr+1)^)+Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))/5),b,b);
end; {$endregion}
procedure BlurRBBProc2   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=    Trunc((                                                                                                            Blue ((pixel_ptr-1)^)+                      Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)                                    )/3);
  pixel_ptr^:=RGB(Trunc((                                                                                                            Red  ((pixel_ptr-1)^)+                      Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)                                    )/3),b,b);
end; {$endregion}
procedure BlurRBBProc3   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=    Trunc((                                    Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+                      Blue ((pixel_ptr+1)^)+                                    Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))/5);
  pixel_ptr^:=RGB(Trunc((                                    Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+                      Red  ((pixel_ptr+1)^)+                                    Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))/5),b,b);
end; {$endregion}
procedure BlurRBBProc4   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=         ((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+Blue ((pixel_ptr-1)^)+Blue ((pixel_ptr+1)^)+Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))>>3);
  pixel_ptr^:=RGB(     ((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+Red  ((pixel_ptr-1)^)+Red  ((pixel_ptr+1)^)+Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))>>3),b,b);
end; {$endregion}
procedure BlurRBBProc5   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=    Trunc((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+                                    Blue ((pixel_ptr-1)^)+                      Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)                                    )/5);
  pixel_ptr^:=RGB(Trunc((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+                                    Red  ((pixel_ptr-1)^)+                      Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)                                    )/5),b,b);
end; {$endregion}
procedure BlurRBBProc6   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=    Trunc((                                    Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+                      Blue ((pixel_ptr+1)^)                                                                                                            )/3);
  pixel_ptr^:=RGB(Trunc((                                    Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+                      Red  ((pixel_ptr+1)^)                                                                                                            )/3),b,b);
end; {$endregion}
procedure BlurRBBProc7   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=    Trunc((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+Blue ((pixel_ptr-1)^)+Blue ((pixel_ptr+1)^)                                                                                                            )/5);
  pixel_ptr^:=RGB(Trunc((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+Red  ((pixel_ptr-1)^)+Red  ((pixel_ptr+1)^)                                                                                                            )/5),b,b);
end; {$endregion}
procedure BlurRBBProc8   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=    Trunc((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+                                    Blue ((pixel_ptr-1)^)                                                                                                                                  )/3);
  pixel_ptr^:=RGB(Trunc((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+                                    Red  ((pixel_ptr-1)^)                                                                                                                                  )/3),b,b);
end; {$endregion}
{RRR}
procedure BlurRRRProc0   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=Trunc((                                                                                                                                  Red  ((pixel_ptr+1)^)+                                    Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))/3);
  pixel_ptr^:=RGB(r,r,r);
end; {$endregion}
procedure BlurRRRProc1   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=Trunc((                                                                                                            Red  ((pixel_ptr-1)^)+Red  ((pixel_ptr+1)^)+Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))/5);
  pixel_ptr^:=RGB(r,r,r);
end; {$endregion}
procedure BlurRRRProc2   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=Trunc((                                                                                                            Red  ((pixel_ptr-1)^)+                      Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)                                    )/3);
  pixel_ptr^:=RGB(r,r,r);
end; {$endregion}
procedure BlurRRRProc3   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=Trunc((                                    Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+                      Red  ((pixel_ptr+1)^)+                                    Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))/5);
  pixel_ptr^:=RGB(r,r,r);
end; {$endregion}
procedure BlurRRRProc4   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=     ((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+Red  ((pixel_ptr-1)^)+Red  ((pixel_ptr+1)^)+Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)+Red  ((pixel_ptr+bmp_dst_width+1)^))>>3);
  pixel_ptr^:=RGB(r,r,r);
end; {$endregion}
procedure BlurRRRProc5   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=Trunc((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+                                    Red  ((pixel_ptr-1)^)+                      Red  ((pixel_ptr+bmp_dst_width-1)^)+Red  ((pixel_ptr+bmp_dst_width+0)^)                                    )/5);
  pixel_ptr^:=RGB(r,r,r);
end; {$endregion}
procedure BlurRRRProc6   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=Trunc((                                    Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+                      Red  ((pixel_ptr+1)^)                                                                                                            )/3);
  pixel_ptr^:=RGB(r,r,r);
end; {$endregion}
procedure BlurRRRProc7   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=Trunc((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+Red  ((pixel_ptr-bmp_dst_width+1)^)+Red  ((pixel_ptr-1)^)+Red  ((pixel_ptr+1)^)                                                                                                            )/5);
  pixel_ptr^:=RGB(r,r,r);
end; {$endregion}
procedure BlurRRRProc8   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r: byte;
begin
  r         :=Trunc((Red  ((pixel_ptr-bmp_dst_width-1)^)+Red  ((pixel_ptr-bmp_dst_width+0)^)+                                    Red  ((pixel_ptr-1)^)                                                                                                                                  )/3);
  pixel_ptr^:=RGB(r,r,r);
end; {$endregion}
{GGG}
procedure BlurGGGProc0   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=Trunc((                                                                                                                                  Green((pixel_ptr+1)^)+                                    Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^))/3);
  pixel_ptr^:=RGB(g,g,g);
end; {$endregion}
procedure BlurGGGProc1   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=Trunc((                                                                                                            Green((pixel_ptr-1)^)+Green((pixel_ptr+1)^)+Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^))/5);
  pixel_ptr^:=RGB(g,g,g);
end; {$endregion}
procedure BlurGGGProc2   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=Trunc((                                                                                                            Green((pixel_ptr-1)^)+                      Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)                                    )/3);
  pixel_ptr^:=RGB(g,g,g);
end; {$endregion}
procedure BlurGGGProc3   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=Trunc((                                    Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+                      Green((pixel_ptr+1)^)+                                    Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^))/5);
  pixel_ptr^:=RGB(g,g,g);
end; {$endregion}
procedure BlurGGGProc4   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=     ((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+Green((pixel_ptr-1)^)+Green((pixel_ptr+1)^)+Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)+Green((pixel_ptr+bmp_dst_width+1)^))>>3);
  pixel_ptr^:=RGB(g,g,g);
end; {$endregion}
procedure BlurGGGProc5   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=Trunc((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+                                    Green((pixel_ptr-1)^)+                      Green((pixel_ptr+bmp_dst_width-1)^)+Green((pixel_ptr+bmp_dst_width+0)^)                                    )/5);
  pixel_ptr^:=RGB(g,g,g);
end; {$endregion}
procedure BlurGGGProc6   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=Trunc((                                    Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+                      Green((pixel_ptr+1)^)                                                                                                            )/3);
  pixel_ptr^:=RGB(g,g,g);
end; {$endregion}
procedure BlurGGGProc7   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=Trunc((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+Green((pixel_ptr-bmp_dst_width+1)^)+Green((pixel_ptr-1)^)+Green((pixel_ptr+1)^)                                                                                                            )/5);
  pixel_ptr^:=RGB(g,g,g);
end; {$endregion}
procedure BlurGGGProc8   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  g: byte;
begin
  g         :=Trunc((Green((pixel_ptr-bmp_dst_width-1)^)+Green((pixel_ptr-bmp_dst_width+0)^)+                                    Green((pixel_ptr-1)^)                                                                                                                                  )/3);
  pixel_ptr^:=RGB(g,g,g);
end; {$endregion}
{BBB}
procedure BlurBBBProc0   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=Trunc((                                                                                                                                  Blue ((pixel_ptr+1)^)+                                    Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))/3);
  pixel_ptr^:=RGB(b,b,b);
end; {$endregion}
procedure BlurBBBProc1   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=Trunc((                                                                                                            Blue ((pixel_ptr-1)^)+Blue ((pixel_ptr+1)^)+Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))/5);
  pixel_ptr^:=RGB(b,b,b);
end; {$endregion}
procedure BlurBBBProc2   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=Trunc((                                                                                                            Blue ((pixel_ptr-1)^)+                      Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)                                    )/3);
  pixel_ptr^:=RGB(b,b,b);
end; {$endregion}
procedure BlurBBBProc3   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=Trunc((                                    Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+                      Blue ((pixel_ptr+1)^)+                                    Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))/5);
  pixel_ptr^:=RGB(b,b,b);
end; {$endregion}
procedure BlurBBBProc4   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=     ((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+Blue ((pixel_ptr-1)^)+Blue ((pixel_ptr+1)^)+Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)+Blue ((pixel_ptr+bmp_dst_width+1)^))>>3);
  pixel_ptr^:=RGB(b,b,b);
end; {$endregion}
procedure BlurBBBProc5   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=Trunc((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+                                    Blue ((pixel_ptr-1)^)+                      Blue ((pixel_ptr+bmp_dst_width-1)^)+Blue ((pixel_ptr+bmp_dst_width+0)^)                                    )/5);
  pixel_ptr^:=RGB(b,b,b);
end; {$endregion}
procedure BlurBBBProc6   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=Trunc((                                    Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+                      Blue ((pixel_ptr+1)^)                                                                                                            )/3);
  pixel_ptr^:=RGB(b,b,b);
end; {$endregion}
procedure BlurBBBProc7   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=Trunc((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+Blue ((pixel_ptr-bmp_dst_width+1)^)+Blue ((pixel_ptr-1)^)+Blue ((pixel_ptr+1)^)                                                                                                            )/5);
  pixel_ptr^:=RGB(b,b,b);
end; {$endregion}
procedure BlurBBBProc8   (pixel_ptr         :PInteger; const bmp_dst_width:TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  b         :=Trunc((Blue ((pixel_ptr-bmp_dst_width-1)^)+Blue ((pixel_ptr-bmp_dst_width+0)^)+                                    Blue ((pixel_ptr-1)^)                                                                                                                                  )/3);
  pixel_ptr^:=RGB(b,b,b);
end; {$endregion}

function  Contrast0      (pixel             :TColor;   const r            :byte=0; const g      :byte=0; const b         :byte=0; const alpha:byte=0; const d_alpha:byte=MAXBYTE; const pow:byte=64; const d:smallint=0): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=RGB(Limit(r+(TRGBA(pixel).r-r)*pow),
              Limit(g+(TRGBA(pixel).g-g)*pow),
              Limit(b+(TRGBA(pixel).b-b)*pow));
end; {$endregion}
procedure Contrast1      (pixel_ptr         :PInteger; const r,g,b        :byte;                                                                                                  const pow:double                     );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(Limit(r+Trunc((PRGBA(pixel_ptr)^.r-r)*pow)),
                  Limit(g+Trunc((PRGBA(pixel_ptr)^.g-g)*pow)),
                  Limit(b+Trunc((PRGBA(pixel_ptr)^.b-b)*pow)));
end; {$endregion}
procedure Contrast2      (pixel_ptr         :PInteger; const r,g,b        :byte;                                                                                                  const pow:integer                    );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(Limit(r+((PRGBA(pixel_ptr)^.r-r)*pow)>>16),
                  Limit(g+((PRGBA(pixel_ptr)^.g-g)*pow)>>16),
                  Limit(b+((PRGBA(pixel_ptr)^.b-b)*pow)>>16));
end; {$endregion}
function  GammaPrecalc   (                                                                                                                                                        const pow:double                     ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=Trunc(pow*Length(pow_arr)/GAMMA_MAX);
end; {$endregion}
procedure Gamma          (pixel_ptr         :PInteger;                                                                                                                            const pow:integer                    );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(pow_arr[pow,PRGBA(pixel_ptr)^.r],
                  pow_arr[pow,PRGBA(pixel_ptr)^.g],
                  pow_arr[pow,PRGBA(pixel_ptr)^.b]);
end; {$endregion}
procedure RandNoise0     (pixel_ptr         :PInteger; const arr_ind      : integer;                                                                                              const pow1,pow2:byte                 );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(Limit(PRGBA(pixel_ptr)^.r         +      (rand_arr[arr_ind]-pow1)>>pow2),
                  Limit(PRGBA(pixel_ptr)^.g         +      (rand_arr[arr_ind]-pow1)>>pow2),
                  Limit(PRGBA(pixel_ptr)^.b         +      (rand_arr[arr_ind]-pow1)>>pow2));
end; {$endregion}
procedure RandNoise1     (pixel_ptr         :PInteger; const arr_ind      : integer;                                                                                              const pow1,pow2:byte                 );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(     (PRGBA(pixel_ptr)^.r        and not (rand_arr[arr_ind]-pow1))>>pow2,
                       (PRGBA(pixel_ptr)^.g        and not (rand_arr[arr_ind]-pow1))>>pow2,
                       (PRGBA(pixel_ptr)^.b        and not (rand_arr[arr_ind]-pow1))>>pow2);
end; {$endregion}
procedure RandNoise2     (pixel_ptr         :PInteger; const arr_ind      : integer;                                                                                              const pow1,pow2:byte                 );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(     (PRGBA(pixel_ptr)^.r        xor     (rand_arr[arr_ind]-pow1))>>pow2,
                       (PRGBA(pixel_ptr)^.g        xor     (rand_arr[arr_ind]-pow1))>>pow2,
                       (PRGBA(pixel_ptr)^.b        xor     (rand_arr[arr_ind]-pow1))>>pow2);
end; {$endregion}
procedure RandNoise3     (pixel_ptr         :PInteger; const arr_ind      : integer;                                                                                              const pow1,pow2:byte                 );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(     (PRGBA(pixel_ptr)^.r         or     (rand_arr[arr_ind]-pow1))>>pow2,
                       (PRGBA(pixel_ptr)^.g         or     (rand_arr[arr_ind]-pow1))>>pow2,
                       (PRGBA(pixel_ptr)^.b         or     (rand_arr[arr_ind]-pow1))>>pow2);
end; {$endregion}
procedure RandNoise4     (pixel_ptr         :PInteger; const arr_ind      : integer;                                                                                              const pow1,pow2:byte                 );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pixel_ptr^:=RGB(     (PRGBA(pixel_ptr)^.r>>pow1)  or     (rand_arr[arr_ind]       >>pow2),
                       (PRGBA(pixel_ptr)^.g>>pow1)  or     (rand_arr[arr_ind]       >>pow2),
                       (PRGBA(pixel_ptr)^.b>>pow1)  or     (rand_arr[arr_ind]       >>pow2));
end; {$endregion}
// Decrease effect:
function  AdditiveDec0   (pixel             :TColor;   const r,g,b        :byte;   alpha,d_alpha:byte;   const alpha_fade:byte;                                                   const pow:byte;    const d:smallint  ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2: TColor;
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(pixel).r;
  g_  :=TRGBA(pixel).g;
  b_  :=TRGBA(pixel).b;
  m0  :=Min3(r_+b,MAXBYTE);
  if   (m0>  r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  m1  :=Min3(g_+g,MAXBYTE);
  if   (m1>  g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  m2  :=Min3(b_+r,MAXBYTE);
  if   (m2>  b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  Result:=RGB(r_,g_,b_);
end; {$endregion}
procedure AdditiveDec1   (pixel_ptr         :PInteger; const src_pix      :TColor;                       const alpha_fade:byte                                                                                         );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2: TColor;
  r_,g_,b_: byte;
begin
  r_  :=PRGBA(pixel_ptr)^.r;
  g_  :=PRGBA(pixel_ptr)^.g;
  b_  :=PRGBA(pixel_ptr)^.b;
  m0  :=Min3(r_+TRGBA(src_pix).r,MAXBYTE);
  if   (m0>  r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  m1  :=Min3(g_+TRGBA(src_pix).g,MAXBYTE);
  if   (m1>  g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  m2  :=Min3(b_+TRGBA(src_pix).b,MAXBYTE);
  if   (m2>  b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  pixel_ptr^:=RGB(r_,g_,b_);
end; {$endregion}
procedure AdditiveDec2   (pixel_ptr         :PInteger; const src_pix      :TColor                                                                                                                                      );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2: TColor;
  r_,g_,b_: byte;
begin
  r_  :=PRGBA(pixel_ptr)^.r;
  g_  :=PRGBA(pixel_ptr)^.g;
  b_  :=PRGBA(pixel_ptr)^.b;
  m0  :=Min3(r_+TRGBA(src_pix).b,MAXBYTE);
  if   (m0>  r_) then
    r_:=m0-(TRGBA(src_pix).a*( m0-r_))>>8
  else
    r_:=m0+(TRGBA(src_pix).a*(-m0+r_))>>8;
  m1  :=Min3(g_+TRGBA(src_pix).g,MAXBYTE);
  if   (m1>  g_) then
    g_:=m1-(TRGBA(src_pix).a*( m1-g_))>>8
  else
    g_:=m1+(TRGBA(src_pix).a*(-m1+g_))>>8;
  m2  :=Min3(b_+TRGBA(src_pix).r,MAXBYTE);
  if   (m2>  b_) then
    b_:=m2-(TRGBA(src_pix).a*( m2-b_))>>8
  else
    b_:=m2+(TRGBA(src_pix).a*(-m2+b_))>>8;
  pixel_ptr^:=RGB(r_,g_,b_);
end; {$endregion}
function  AlphaBlendDec0 (pixel             :TColor;   const r,g,b        :byte;   alpha,d_alpha:byte;   const alpha_fade:byte;                                                   const pow:byte;    const d:smallint  ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  alpha  :=Max2(alpha-Byte(d),0);
  d_alpha:=MAXBYTE-alpha;
  Result:=(((TRGBA(pixel).b-r)*d_alpha)>>8+r)<<16+
          (((TRGBA(pixel).g-g)*d_alpha)>>8+g)<<08+
          (((TRGBA(pixel).r-b)*d_alpha)>>8+b)<<00;
end; {$endregion}
procedure AlphaBlendDec1 (pixel_ptr         :PInteger; const src_pix      :TColor; alpha        :byte;   const alpha_fade:byte                                                                                         );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  d_alpha:byte;
begin
  d_alpha   :=MAXBYTE-Max2(alpha-alpha_fade,0);
  pixel_ptr^:=(((PRGBA(pixel_ptr)^.b-TRGBA(src_pix).b)*d_alpha)>>8+TRGBA(src_pix).b)<<16+
              (((PRGBA(pixel_ptr)^.g-TRGBA(src_pix).g)*d_alpha)>>8+TRGBA(src_pix).g)<<08+
              (((PRGBA(pixel_ptr)^.r-TRGBA(src_pix).r)*d_alpha)>>8+TRGBA(src_pix).r)<<00;
end; {$endregion}
procedure AlphaBlendDec2 (pixel_ptr         :PInteger; const src_pix      :TColor;                       const alpha_fade:byte                                                                                         );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  d_alpha:byte;
begin
  d_alpha   :=MAXBYTE-Max2(TRGBA(src_pix  ) .a-alpha_fade,0);
  pixel_ptr^:=          (((PRGBA(pixel_ptr)^.b-TRGBA(src_pix).b)*d_alpha)>>8+TRGBA(src_pix).b)<<16+
                        (((PRGBA(pixel_ptr)^.g-TRGBA(src_pix).g)*d_alpha)>>8+TRGBA(src_pix).g)<<08+
                        (((PRGBA(pixel_ptr)^.r-TRGBA(src_pix).r)*d_alpha)>>8+TRGBA(src_pix).r)<<00;
end; {$endregion}
function  InverseDec0    (pixel             :TColor;   const r,g,b        :byte;   alpha,d_alpha:byte;   const alpha_fade:byte;                                                   const pow:byte;    const d:smallint  ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(pixel).r;
  g_  :=TRGBA(pixel).g;
  b_  :=TRGBA(pixel).b;
  if   (MAXBYTE>r_<<1) then
    r_:=MAXBYTE-r_-(alpha_fade*( MAXBYTE-r_<<1))>>8
  else
    r_:=MAXBYTE-r_+(alpha_fade*(-MAXBYTE+r_<<1))>>8;
  if   (MAXBYTE>g_<<1) then
    g_:=MAXBYTE-g_-(alpha_fade*( MAXBYTE-g_<<1))>>8
  else
    g_:=MAXBYTE-g_+(alpha_fade*(-MAXBYTE+g_<<1))>>8;
  if   (MAXBYTE>b_<<1) then
    b_:=MAXBYTE-b_-(alpha_fade*( MAXBYTE-b_<<1))>>8
  else
    b_:=MAXBYTE-b_+(alpha_fade*(-MAXBYTE+b_<<1))>>8;
  Result:=RGB(r_,g_,b_);
end; {$endregion}
procedure InverseDec1    (pixel_ptr         :PInteger;                                                   const alpha_fade:byte                                                                                         );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin
  r_  :=PRGBA(pixel_ptr)^.r;
  g_  :=PRGBA(pixel_ptr)^.g;
  b_  :=PRGBA(pixel_ptr)^.b;
  if   (MAXBYTE>r_<<1) then
    r_:=MAXBYTE-r_-(alpha_fade*( MAXBYTE-r_<<1))>>8
  else
    r_:=MAXBYTE-r_+(alpha_fade*(-MAXBYTE+r_<<1))>>8;
  if   (MAXBYTE>g_<<1) then
    g_:=MAXBYTE-g_-(alpha_fade*( MAXBYTE-g_<<1))>>8
  else
    g_:=MAXBYTE-g_+(alpha_fade*(-MAXBYTE+g_<<1))>>8;
  if   (MAXBYTE>b_<<1) then
    b_:=MAXBYTE-b_-(alpha_fade*( MAXBYTE-b_<<1))>>8
  else
    b_:=MAXBYTE-b_+(alpha_fade*(-MAXBYTE+b_<<1))>>8;
  pixel_ptr^:=RGB(r_,g_,b_);
end; {$endregion}
function  HighlightDec0  (pixel             :TColor;   const r,g,b        :byte;   alpha,d_alpha:byte;   const alpha_fade:byte;                                                   const pow:byte;    const d:smallint  ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2: TColor;
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(pixel).r;
  g_  :=TRGBA(pixel).g;
  b_  :=TRGBA(pixel).b;
  m0  :=Min3(r_+pow,MAXBYTE);
  if   (m0>  r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  m1  :=Min3(g_+pow,MAXBYTE);
  if   (m1>  g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  m2  :=Min3(b_+pow,MAXBYTE);
  if   (m2>  b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  Result:=RGB(r_,g_,b_);
end; {$endregion}
procedure HighlightDec1  (pixel_ptr         :PInteger;                                                   const alpha_fade:byte;                                                   const pow:byte                       );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2: TColor;
  r_,g_,b_: byte;
begin
  r_  :=PRGBA(pixel_ptr)^.r;
  g_  :=PRGBA(pixel_ptr)^.g;
  b_  :=PRGBA(pixel_ptr)^.b;
  m0  :=Min3(r_+pow,MAXBYTE);
  if   (m0>  r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  m1  :=Min3(g_+pow,MAXBYTE);
  if   (m1>  g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  m2  :=Min3(b_+pow,MAXBYTE);
  if   (m2>  b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  pixel_ptr^:=RGB(r_,g_,b_);
end; {$endregion}
function  DarkenDec0     (pixel             :TColor;   const r,g,b        :byte;   alpha,d_alpha:byte;   const alpha_fade:byte;                                                   const pow:byte;    const d:smallint  ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2: integer;
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(pixel).r;
  g_  :=TRGBA(pixel).g;
  b_  :=TRGBA(pixel).b;
  m0  :=Max2(r_-pow,0);
  if   (m0>  r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  m1  :=Max2(g_-pow,0);
  if   (m1>  g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  m2  :=Max2(b_-pow,0);
  if   (m2>  b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  Result:=RGB(r_,g_,b_);
end; {$endregion}
procedure DarkenDec1     (pixel_ptr         :PInteger;                                                   const alpha_fade:byte;                                                   const pow:byte                       );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2: integer;
  r_,g_,b_: byte;
begin
  r_  :=PRGBA(pixel_ptr)^.r;
  g_  :=PRGBA(pixel_ptr)^.g;
  b_  :=PRGBA(pixel_ptr)^.b;
  m0  :=Max2(r_-pow,0);
  if   (m0>  r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  m1  :=Max2(g_-pow,0);
  if   (m1>  g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  m2  :=Max2(b_-pow,0);
  if   (m2>  b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  pixel_ptr^:=RGB(r_,g_,b_);
end; {$endregion}
function  GrayscaleRDec0 (pixel             :TColor;   const r,g,b        :byte;   alpha,d_alpha:byte;   const alpha_fade:byte;                                                   const pow:byte;    const d:smallint  ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(pixel).r;
  g_  :=TRGBA(pixel).g;
  b_  :=TRGBA(pixel).b;
  if   (g_>r_) then
    g_:=g_-(alpha_fade*(+g_-r_))>>8
  else
    g_:=g_+(alpha_fade*(-g_+r_))>>8;
  if   (b_>r_) then
    b_:=b_-(alpha_fade*(+b_-r_))>>8
  else
    b_:=b_+(alpha_fade*(-b_+r_))>>8;
  Result:=RGB(r_,g_,b_);
end; {$endregion}
procedure GrayscaleRDec1 (pixel_ptr         :PInteger;                                                   const alpha_fade:byte                                                                                         );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin
  r_  :=PRGBA(pixel_ptr)^.r;
  g_  :=PRGBA(pixel_ptr)^.g;
  b_  :=PRGBA(pixel_ptr)^.b;
  if   (g_>r_) then
    g_:=g_-(alpha_fade*(+g_-r_))>>8
  else
    g_:=g_+(alpha_fade*(-g_+r_))>>8;
  if   (b_>r_) then
    b_:=b_-(alpha_fade*(+b_-r_))>>8
  else
    b_:=b_+(alpha_fade*(-b_+r_))>>8;
  pixel_ptr^:=RGB(r_,g_,b_);
end; {$endregion}
function  GrayscaleGDec0 (pixel             :TColor;   const r,g,b        :byte;   alpha,d_alpha:byte;   const alpha_fade:byte;                                                   const pow:byte;    const d:smallint  ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(pixel).r;
  g_  :=TRGBA(pixel).g;
  b_  :=TRGBA(pixel).b;
  if   (r_>g_) then
    r_:=r_-(alpha_fade*(+r_-g_))>>8
  else
    r_:=r_+(alpha_fade*(-r_+g_))>>8;
  if   (b_>g_) then
    b_:=b_-(alpha_fade*(+b_-g_))>>8
  else
    b_:=b_+(alpha_fade*(-b_+g_))>>8;
  Result:=RGB(r_,g_,b_);
end; {$endregion}
procedure GrayscaleGDec1 (pixel_ptr         :PInteger;                                                   const alpha_fade:byte                                                                                         );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin
  r_  :=PRGBA(pixel_ptr)^.r;
  g_  :=PRGBA(pixel_ptr)^.g;
  b_  :=PRGBA(pixel_ptr)^.b;
  if   (r_>g_) then
    r_:=r_-(alpha_fade*(+r_-g_))>>8
  else
    r_:=r_+(alpha_fade*(-r_+g_))>>8;
  if   (b_>g_) then
    b_:=b_-(alpha_fade*(+b_-g_))>>8
  else
    b_:=b_+(alpha_fade*(-b_+g_))>>8;
  pixel_ptr^:=RGB(r_,g_,b_);
end; {$endregion}
function  GrayscaleBDec0 (pixel             :TColor;   const r,g,b        :byte;   alpha,d_alpha:byte;   const alpha_fade:byte;                                                   const pow:byte;    const d:smallint  ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(pixel).r;
  g_  :=TRGBA(pixel).g;
  b_  :=TRGBA(pixel).b;
  if   (r_>b_) then
    r_:=r_-(alpha_fade*( r_-b_))>>8
  else
    r_:=r_+(alpha_fade*(-r_+b_))>>8;
  if   (g_>b_) then
    g_:=g_-(alpha_fade*( g_-b_))>>8
  else
    g_:=g_+(alpha_fade*(-g_+b_))>>8;
  Result:=RGB(r_,g_,b_);
end; {$endregion}
procedure GrayscaleBDec1 (pixel_ptr         :PInteger;                                                   const alpha_fade:byte                                                                                         );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  r_,g_,b_: byte;
begin
  r_  :=PRGBA(pixel_ptr)^.r;
  g_  :=PRGBA(pixel_ptr)^.g;
  b_  :=PRGBA(pixel_ptr)^.b;
  if   (r_>b_) then
    r_:=r_-(alpha_fade*(+r_-b_))>>8
  else
    r_:=r_+(alpha_fade*(-r_+b_))>>8;
  if   (g_>b_) then
    g_:=g_-(alpha_fade*( g_-b_))>>8
  else
    g_:=g_+(alpha_fade*(-g_+b_))>>8;
  pixel_ptr^:=RGB(r_,g_,b_);
end; {$endregion}
function  ColorizeRDec0  (pixel             :TColor;   const r,g,b        :byte;   alpha,d_alpha:byte;   const alpha_fade:byte;                                                   const pow:byte;    const d:smallint  ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v : integer;
  b_: byte;
begin
  v :=Byte(               Red (pixel)+pow>>1-64);
  if   (v>                Blue(pixel)) then
    b_:=v-(alpha_fade*(+v-Blue(pixel)))>>08
  else
    b_:=v+(alpha_fade*(-v+Blue(pixel)))>>08;
  Result:=pixel-          Blue(pixel)  <<16+b_<<16;
end; {$endregion}
procedure ColorizeRDec1  (pixel_ptr         :PInteger;                                                   const alpha_fade:byte;                                                   const pow:byte                       );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v : integer;
  b_: byte;
begin
  v :=Byte(               Red (pixel_ptr^)+pow>>1-64);
  if   (v>                Blue(pixel_ptr^)) then
    b_:=v-(alpha_fade*(+v-Blue(pixel_ptr^)))>>08
  else
    b_:=v+(alpha_fade*(-v+Blue(pixel_ptr^)))>>08;
  pixel_ptr^:=pixel_ptr^- Blue(pixel_ptr^)  <<16+b_<<16;
end; {$endregion}
function  ColorizeGDec0  (pixel             :TColor;   const r,g,b        :byte;   alpha,d_alpha:byte;   const alpha_fade:byte;                                                   const pow:byte;    const d:smallint  ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v : integer;
  g_: byte;
begin
  v :=Byte(               Green(pixel)+pow>>1-64);
  if   (v>                Green(pixel)) then
    g_:=v-(alpha_fade*(+v-Green(pixel)))>>08
  else
    g_:=v+(alpha_fade*(-v+Green(pixel)))>>08;
  Result:=pixel-          Green(pixel)  <<08+g_<<08;
end; {$endregion}
procedure ColorizeGDec1  (pixel_ptr         :PInteger;                                                   const alpha_fade:byte;                                                   const pow:byte                       );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v : integer;
  g_: byte;
begin
  v :=Byte(               Green(pixel_ptr^)+pow>>1-64);
  if   (v>                Green(pixel_ptr^)) then
    g_:=v-(alpha_fade*(+v-Green(pixel_ptr^)))>>08
  else
    g_:=v+(alpha_fade*(-v+Green(pixel_ptr^)))>>08;
  pixel_ptr^:=pixel_ptr^- Green(pixel_ptr^)  <<08+g_<<08;
end; {$endregion}
function  ColorizeBDec0  (pixel             :TColor;   const r,g,b        :byte;   alpha,d_alpha:byte;   const alpha_fade:byte;                                                   const pow:byte;    const d:smallint  ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v : integer;
  r_: byte;
begin
  v :=Byte(               Blue(pixel)+pow>>1-64);
  if   (v>                Red (pixel)) then
    r_:=v-(alpha_fade*(+v-Red (pixel)))>>08
  else
    r_:=v+(alpha_fade*(-v+Red (pixel)))>>08;
  Result:=pixel-          Red (pixel)  <<00+r_<<00;
end; {$endregion}
procedure ColorizeBDec1  (pixel_ptr         :PInteger;                                                   const alpha_fade:byte;                                                   const pow:byte                       );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v : integer;
  r_: byte;
begin
  v :=Byte(               Blue(pixel_ptr^)+pow>>1-64);
  if   (v>                Red (pixel_ptr^)) then
    r_:=v-(alpha_fade*(+v-Red (pixel_ptr^)))>>08
  else
    r_:=v+(alpha_fade*(-v+Red (pixel_ptr^)))>>08;
  pixel_ptr^:=pixel_ptr^- Red (pixel_ptr^)  <<00+r_<<00;
end; {$endregion}
procedure BlurRGB4Dec    (pixel_ptr         :PInteger; const bmp_dst_width:TColor;                       const alpha_fade:byte                                                                                         );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2   : TColor;
  v0,v1,v2,v3: TColor;
  r_,g_,b_   : byte;
begin
  v0  :=     ((pixel_ptr+0                 )^);
  v1  :=     ((pixel_ptr+2                 )^);
  v2  :=     ((pixel_ptr+bmp_dst_width<<1  )^);
  v3  :=     ((pixel_ptr+bmp_dst_width<<1+2)^);
  r_  :=Red  ((pixel_ptr+bmp_dst_width   +1)^);
  g_  :=Green((pixel_ptr+bmp_dst_width   +1)^);
  b_  :=Blue ((pixel_ptr+bmp_dst_width   +1)^);
  m0  :=(Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00)+Byte(    (v3)>>00))>>2;
  m1  :=(Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08))>>2;
  m2  :=(Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16)+Byte(    (v3)>>16))>>2;
  {Red}
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  {Green}
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  {Blue}
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  {Color output}
  (pixel_ptr+bmp_dst_width+1)^:=RGB(r_,g_,b_);
end; {$endregion}
procedure BlurRRB4Dec    (pixel_ptr         :PInteger; const bmp_dst_width:TColor;                       const alpha_fade:byte                                                                                         );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2   : TColor;
  v0,v1,v2,v3: TColor;
  r_,g_,b_   : byte;
begin
  v0  :=     ((pixel_ptr+0                 )^);
  v1  :=     ((pixel_ptr+2                 )^);
  v2  :=     ((pixel_ptr+bmp_dst_width<<1  )^);
  v3  :=     ((pixel_ptr+bmp_dst_width<<1+2)^);
  r_  :=Red  ((pixel_ptr+bmp_dst_width   +1)^);
  g_  :=Green((pixel_ptr+bmp_dst_width   +1)^);
  b_  :=Blue ((pixel_ptr+bmp_dst_width   +1)^);
  m0  :=(Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00)+Byte(    (v3)>>00))>>2;
  m1  :=m0;
  m2  :=(Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16)+Byte(    (v3)>>16))>>2;
  {Red}
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  {Green}
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  {Blue}
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  {Color output}
  (pixel_ptr+bmp_dst_width+1)^:=RGB(r_,g_,b_);
end; {$endregion}
procedure BlurRGR4Dec    (pixel_ptr         :PInteger; const bmp_dst_width:TColor;                       const alpha_fade:byte                                                                                         );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2   : TColor;
  v0,v1,v2,v3: TColor;
  r_,g_,b_   : byte;
begin
  v0  :=     ((pixel_ptr+0                 )^);
  v1  :=     ((pixel_ptr+2                 )^);
  v2  :=     ((pixel_ptr+bmp_dst_width<<1  )^);
  v3  :=     ((pixel_ptr+bmp_dst_width<<1+2)^);
  r_  :=Red  ((pixel_ptr+bmp_dst_width   +1)^);
  g_  :=Green((pixel_ptr+bmp_dst_width   +1)^);
  b_  :=Blue ((pixel_ptr+bmp_dst_width   +1)^);
  m0  :=(Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00)+Byte(    (v3)>>00))>>2;
  m1  :=(Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08))>>2;
  m2  :=m0;
  {Red}
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  {Green}
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  {Blue}
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  {Color output}
  (pixel_ptr+bmp_dst_width+1)^:=RGB(r_,g_,b_);
end; {$endregion}
procedure BlurGGB4Dec    (pixel_ptr         :PInteger; const bmp_dst_width:TColor;                       const alpha_fade:byte                                                                                         );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2   : TColor;
  v0,v1,v2,v3: TColor;
  r_,g_,b_   : byte;
begin
  v0  :=     ((pixel_ptr+0                 )^);
  v1  :=     ((pixel_ptr+2                 )^);
  v2  :=     ((pixel_ptr+bmp_dst_width<<1  )^);
  v3  :=     ((pixel_ptr+bmp_dst_width<<1+2)^);
  r_  :=Red  ((pixel_ptr+bmp_dst_width   +1)^);
  g_  :=Green((pixel_ptr+bmp_dst_width   +1)^);
  b_  :=Blue ((pixel_ptr+bmp_dst_width   +1)^);
  m1  :=(Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08))>>2;
  m0  :=m1;
  m2  :=(Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16)+Byte(    (v3)>>16))>>2;
  {Red}
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  {Green}
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  {Blue}
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  {Color output}
  (pixel_ptr+bmp_dst_width+1)^:=RGB(r_,g_,b_);
end; {$endregion}
procedure BlurRGG4Dec    (pixel_ptr         :PInteger; const bmp_dst_width:TColor;                       const alpha_fade:byte                                                                                         );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2   : TColor;
  v0,v1,v2,v3: TColor;
  r_,g_,b_   : byte;
begin
  v0  :=     ((pixel_ptr+0                 )^);
  v1  :=     ((pixel_ptr+2                 )^);
  v2  :=     ((pixel_ptr+bmp_dst_width<<1  )^);
  v3  :=     ((pixel_ptr+bmp_dst_width<<1+2)^);
  r_  :=Red  ((pixel_ptr+bmp_dst_width   +1)^);
  g_  :=Green((pixel_ptr+bmp_dst_width   +1)^);
  b_  :=Blue ((pixel_ptr+bmp_dst_width   +1)^);
  m0  :=(Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00)+Byte(    (v3)>>00))>>2;
  m1  :=(Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08))>>2;
  m2  :=m1;
  {Red}
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  {Green}
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  {Blue}
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  {Color output}
  (pixel_ptr+bmp_dst_width+1)^:=RGB(r_,g_,b_);
end; {$endregion}
procedure BlurBGB4Dec    (pixel_ptr         :PInteger; const bmp_dst_width:TColor;                       const alpha_fade:byte                                                                                         );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2   : TColor;
  v0,v1,v2,v3: TColor;
  r_,g_,b_   : byte;
begin
  v0  :=     ((pixel_ptr+0                 )^);
  v1  :=     ((pixel_ptr+2                 )^);
  v2  :=     ((pixel_ptr+bmp_dst_width<<1  )^);
  v3  :=     ((pixel_ptr+bmp_dst_width<<1+2)^);
  r_  :=Red  ((pixel_ptr+bmp_dst_width   +1)^);
  g_  :=Green((pixel_ptr+bmp_dst_width   +1)^);
  b_  :=Blue ((pixel_ptr+bmp_dst_width   +1)^);
  m2  :=(Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16)+Byte(    (v3)>>16))>>2;
  m0  :=m2;
  m1  :=(Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08))>>2;
  {Red}
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  {Green}
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  {Blue}
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  {Color output}
  (pixel_ptr+bmp_dst_width+1)^:=RGB(r_,g_,b_);
end; {$endregion}
procedure BlurRBB4Dec    (pixel_ptr         :PInteger; const bmp_dst_width:TColor;                       const alpha_fade:byte                                                                                         );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2   : TColor;
  v0,v1,v2,v3: TColor;
  r_,g_,b_   : byte;
begin
  v0  :=     ((pixel_ptr+0                 )^);
  v1  :=     ((pixel_ptr+2                 )^);
  v2  :=     ((pixel_ptr+bmp_dst_width<<1  )^);
  v3  :=     ((pixel_ptr+bmp_dst_width<<1+2)^);
  r_  :=Red  ((pixel_ptr+bmp_dst_width   +1)^);
  g_  :=Green((pixel_ptr+bmp_dst_width   +1)^);
  b_  :=Blue ((pixel_ptr+bmp_dst_width   +1)^);
  m0  :=(Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00)+Byte(    (v3)>>00))>>2;
  m2  :=(Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16)+Byte(    (v3)>>16))>>2;
  m1  :=m2;
  {Red}
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  {Green}
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  {Blue}
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  {Color output}
  (pixel_ptr+bmp_dst_width+1)^:=RGB(r_,g_,b_);
end; {$endregion}
procedure BlurRRR4Dec    (pixel_ptr         :PInteger; const bmp_dst_width:TColor;                       const alpha_fade:byte                                                                                         );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2   : TColor;
  v0,v1,v2,v3: TColor;
  r_,g_,b_   : byte;
begin
  v0  :=     ((pixel_ptr+0                 )^);
  v1  :=     ((pixel_ptr+2                 )^);
  v2  :=     ((pixel_ptr+bmp_dst_width<<1  )^);
  v3  :=     ((pixel_ptr+bmp_dst_width<<1+2)^);
  r_  :=Red  ((pixel_ptr+bmp_dst_width   +1)^);
  g_  :=Green((pixel_ptr+bmp_dst_width   +1)^);
  b_  :=Blue ((pixel_ptr+bmp_dst_width   +1)^);
  m0  :=(Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00)+Byte(    (v3)>>00))>>2;
  m1  :=m0;
  m2  :=m0;
  {Red}
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  {Green}
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  {Blue}
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  {Color output}
  (pixel_ptr+bmp_dst_width+1)^:=RGB(r_,g_,b_);
end; {$endregion}
procedure BlurGGG4Dec    (pixel_ptr         :PInteger; const bmp_dst_width:TColor;                       const alpha_fade:byte                                                                                         );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2   : TColor;
  v0,v1,v2,v3: TColor;
  r_,g_,b_   : byte;
begin
  v0  :=     ((pixel_ptr+0                 )^);
  v1  :=     ((pixel_ptr+2                 )^);
  v2  :=     ((pixel_ptr+bmp_dst_width<<1  )^);
  v3  :=     ((pixel_ptr+bmp_dst_width<<1+2)^);
  r_  :=Red  ((pixel_ptr+bmp_dst_width   +1)^);
  g_  :=Green((pixel_ptr+bmp_dst_width   +1)^);
  b_  :=Blue ((pixel_ptr+bmp_dst_width   +1)^);
  m1  :=(Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08)+Byte(Word(v3)>>08))>>2;
  m0  :=m1;
  m2  :=m1;
  {Red}
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  {Green}
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  {Blue}
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  {Color output}
  (pixel_ptr+bmp_dst_width+1)^:=RGB(r_,g_,b_);
end; {$endregion}
procedure BlurBBB4Dec    (pixel_ptr         :PInteger; const bmp_dst_width:TColor;                       const alpha_fade:byte                                                                                         );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2   : TColor;
  v0,v1,v2,v3: TColor;
  r_,g_,b_   : byte;
begin
  v0  :=     ((pixel_ptr+0                 )^);
  v1  :=     ((pixel_ptr+2                 )^);
  v2  :=     ((pixel_ptr+bmp_dst_width<<1  )^);
  v3  :=     ((pixel_ptr+bmp_dst_width<<1+2)^);
  r_  :=Red  ((pixel_ptr+bmp_dst_width   +1)^);
  g_  :=Green((pixel_ptr+bmp_dst_width   +1)^);
  b_  :=Blue ((pixel_ptr+bmp_dst_width   +1)^);
  m2  :=(Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16)+Byte(    (v3)>>16))>>2;
  m0  :=m2;
  m1  :=m2;
  {Red}
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  {Green}
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  {Blue}
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  {Color output}
  (pixel_ptr+bmp_dst_width+1)^:=RGB(r_,g_,b_);
end; {$endregion}
function  ContrastDec0   (pixel_ptr         :PInteger; const r,g,b        :byte;                         const alpha_fade:byte;                                                   const pow:integer                    ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2: TColor;
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(pixel_ptr^).r;
  g_  :=TRGBA(pixel_ptr^).g;
  b_  :=TRGBA(pixel_ptr^).b;
  m0  :=Limit(r+((r_-r)*pow)>>16);
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  m1  :=Limit(g+((g_-g)*pow)>>16);
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  m2  :=Limit(b+((b_-b)*pow)>>16);
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  Result:=RGB{ToColor}(r_,g_,b_);
end; {$endregion}
function  ContrastDec1   (dst_pix,src_pix   :TColor;                                                     const alpha_fade:byte;                                                   const pow:integer                    ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2: TColor;
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(dst_pix).r;
  g_  :=TRGBA(dst_pix).g;
  b_  :=TRGBA(dst_pix).b;
  m0  :=Limit(TRGBA(src_pix).r+((r_-TRGBA(src_pix).r)*pow)>>16);
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  m1  :=Limit(TRGBA(src_pix).g+((g_-TRGBA(src_pix).g)*pow)>>16);
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  m2  :=Limit(TRGBA(src_pix).b+((b_-TRGBA(src_pix).b)*pow)>>16);
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  Result:=RGB{ToColor}(r_,g_,b_);
end; {$endregion}
function  ContrastDec2   (dst_pix,src_pix   :TColor;                                                     const alpha_fade:byte;                                                   const pow:integer                    ): TColor; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m0,m1,m2: TColor;
  r_,g_,b_: byte;
begin
  r_  :=TRGBA(dst_pix).r;
  g_  :=TRGBA(dst_pix).g;
  b_  :=TRGBA(dst_pix).b;
  m0  :=Limit(TRGBA(src_pix).b+((r_-TRGBA(src_pix).b)*pow)>>16);
  if   (m0>   r_) then
    r_:=m0-(alpha_fade*( m0-r_))>>8
  else
    r_:=m0+(alpha_fade*(-m0+r_))>>8;
  m1  :=Limit(TRGBA(src_pix).g+((g_-TRGBA(src_pix).g)*pow)>>16);
  if   (m1>   g_) then
    g_:=m1-(alpha_fade*( m1-g_))>>8
  else
    g_:=m1+(alpha_fade*(-m1+g_))>>8;
  m2  :=Limit(TRGBA(src_pix).r+((b_-TRGBA(src_pix).r)*pow)>>16);
  if   (m2>   b_) then
    b_:=m2-(alpha_fade*( m2-b_))>>8
  else
    b_:=m2+(alpha_fade*(-m2+b_))>>8;
  Result:=RGB{ToColor}(r_,g_,b_);
end; {$endregion}
{Test}
procedure PPTestFX       (pixel_ptr         :PInteger; const bmp_dst_width:TColor;                                                                                                const pow:byte                       );         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  sqr_pix: integer;
begin
  //pixel_ptr-^:=AlphaBlend1(dst_pixel_ptr+x,col,d_alpha);
  {sqr_pix:=Limit(Trunc(sqrt(sqr(PRGBA(pixel_ptr)^.r)+
                            sqr(PRGBA(pixel_ptr)^.g)+
                            sqr(PRGBA(pixel_ptr)^.b))));
  pixel_ptr^:=RGB((Trunc(sqr_pix*ln(sqr_pix))>>2+Trunc(sin(sqr_pix/(pi*1))*Limit(PRGBA(pixel_ptr)^.r))>>1)>>2{(Trunc((sqr_pix+{sin(1/3)*PRGBA(dst_pixel_ptr+x)^.r*}{ln}sqrt(PRGBA(dst_pixel_ptr+x)^.r))))},
                  (Trunc(sqr_pix*ln(sqr_pix))>>2+Trunc(sin(sqr_pix/(pi*2))*Limit(PRGBA(pixel_ptr)^.g))>>1)>>2{(Trunc((sqr_pix+{sin(2/3)*PRGBA(dst_pixel_ptr+x)^.g*}{ln}sqrt(PRGBA(dst_pixel_ptr+x)^.g))))},
                  (Trunc(sqr_pix*ln(sqr_pix))>>2+Trunc(sin(sqr_pix/(pi*3))*Limit(PRGBA(pixel_ptr)^.b))>>1)>>2{(Trunc((sqr_pix+{sin(3/3)*PRGBA(dst_pixel_ptr+x)^.b*}{ln}sqrt(PRGBA(dst_pixel_ptr+x)^.b))))});}
end; {$endregion}

{$endregion}



(******************************* Array routines *******************************) {$region -fold}

// Arrays addition:
procedure ArrAdd      (var   arr_src1:T1Byte1Arr; const arr_src2:T2Byte1Arr; const rct_dst:TPtrect; const arr_dst_width,arr_dst_height:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,v: integer;
begin
  v    :=arr_dst_width* rct_dst.top;
  for y:=rct_dst.top to rct_dst.bottom-1 do
    begin
      for x:=rct_dst.left to rct_dst.right-1 do
        arr_src1[x+v]+=arr_src2[x,y];
      Inc(v,arr_dst_width);
    end;
end; {$endregion}
// 2D array to 1D array:
procedure Arr2DTo1D   (const arr_src:T2Byte1Arr; var arr_dst:T1Byte1Arr; const arr_src_width,arr_src_height:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr: PByte;
  arr_dst_ptr: PByte;
  x,y        : integer;
begin
  SetLength(arr_dst,arr_src_width*arr_src_height);
  for x:=0 to arr_src_width-1 do
    begin
      arr_src_ptr:=Unaligned(@arr_src[x,0]);
      arr_dst_ptr:=Unaligned(@arr_dst[x  ]);
      for y:=0 to arr_src_height-1 do
        begin
          arr_dst_ptr^:=arr_src_ptr^;
          Inc(arr_dst_ptr,arr_src_width);
          Inc(arr_src_ptr);
        end;
    end;
end; {$endregion}
// Clear arrays:
procedure BmpClr      (bmp:Graphics.TBitmap);                                                                                   {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  //PatBlt(bmp.Canvas.Handle,0,0,bmp.width,bmp.height,WHITENESS);
  bmp.Canvas.Clear;
end; {$endregion}
procedure ArrClr      (    arr_ptr:PInteger;   const rct_dst:TPtRect; const arr_width:TColor; const val:TColor=0             ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to rct_dst.height-1 do
    begin
      FillByte(arr_ptr^,rct_dst.width,val);
      Inc     (arr_ptr ,arr_width);
    end;
end; {$endregion}
procedure ArrClr      (var arr    :T1Byte1Arr; const rct_dst:TPtRect; const arr_width:TColor; const val:byte  =0             ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p: PByte;
  i: integer;
begin
  p:=Unaligned(@arr[rct_dst.left+arr_width*rct_dst.top]);
  for i:=0 to rct_dst.height-1 do
    begin
      FillByte(p^,rct_dst.width,val);
      Inc     (p ,arr_width);
    end;
end; {$endregion}
procedure ArrClr      (var arr    :TColorArr;  const rct_dst:TPtRect; const arr_width:TColor; const val:TColor=0             ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p: PInteger;
  i: integer;
begin
  p:=Unaligned(@arr[rct_dst.left+arr_width*rct_dst.top]);
  for i:=0 to rct_dst.height-1 do
    begin
      FillDWord(p^,rct_dst.width,val);
      Inc      (p ,arr_width);
    end;
end; {$endregion}
procedure ArrClr      (var arr_ptr:PInteger;   const rct_dst:TPtRect; const arr_width:TColor; const val:TColor; b1,b2:boolean); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p: PInteger;
  i: integer;
begin
  p:=@arr_ptr[0{rct_dst.left+arr_width*rct_dst.top}];
  for i:=0 to rct_dst.height-1 do
    begin
      FillDWord(p^,arr_width,val);
      Inc(p,arr_width);
    end;
end; {$endregion}
procedure ArrClr      (var arr    :T2Byte1Arr; const rct_dst:TPtRect;                         const val:byte  =0             ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to rct_dst.width-1 do
    FillByte(arr[rct_dst.left+i,rct_dst.top],rct_dst.height,val);
end; {$endregion}
procedure ArrClr      (var arr    :TPtPos3Arr; const rct_dst:TPtRect; const arr_width:TColor                                 ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p      : PPtPos3;
  i,j    : integer;
  d_width: integer;
begin
  d_width:=arr_width-rct_dst.width;
  p      :=Unaligned(@arr[rct_dst.left+arr_width*rct_dst.top]);
  for j:=0 to rct_dst.height-1 do
    begin
      for i:=0 to rct_dst.width-1 do
        begin
          if (p^.obj_ind<>-1) then
            p^.SetEqual1(p^,Default(TPtPos3));
          Inc(p);
        end;
      Inc(p,d_width);
    end;
end; {$endregion}
// Clear alpha channel:
function  ArrClr      (    arr_ptr:PInteger;   const rct_dst:TPtRect; const arr_width:TColor; const val:TColor=0; b:boolean=False):byte; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p  : PInteger;
  x,y: integer;
label
  emd;
begin
  Result:=0;
  p     :=Unaligned(@arr_ptr[rct_dst.left+arr_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          (p+x)^:=(p+x)^ and NT_BIT_MASK_ALPHA2; //(p+x)^:=(p+x)^<<8>>8;
          {if (((p+x)^>>24)<>0) then
            begin
              Result:=1;
              goto emd;
            end;}
        end;
      Inc(p,arr_width);
    end;
  emd:
end; {$endregion}
// Fill arrays on bitmap:
procedure ArrFil      (const arr0:TPtPos3Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor);                       {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PPtPos3;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^.obj_ind<>-1) then
            pixel_ptr^:=col;
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFil      (const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect);                                         {$region -fold}
var
  pixel_ptr: PInteger;
  d_width  : integer;
  x,y      : integer;
begin
  d_width  :=bmp_width-rct_dst.width;
  pixel_ptr:=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (pixel_ptr^<>0) then
            arr0[pixel_ptr^-1]:=1;
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFilProc00(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
var
//pixel_ptr0 : PInteger;
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(TRGBA(col).b,TRGBA(col).g,TRGBA(col).r);
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
//pixel_ptr0 :=pixel_ptr;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
            (pixel_ptr  +x)^:=pix_color;
      Inc   (pixel_ptr  ,bmp_width);
      Inc   (f_arr_0_ptr,bmp_width);
    end;
  {chess order}
  {for y:=0 to Trunc(rct_dst.height/2)-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
          if Odd(PInteger(pixel_ptr+x+1)-PInteger(pixel_ptr0)) then
            (pixel_ptr+x)^:=pix_color;
      Inc(pixel_ptr  ,bmp_width);
      Inc(f_arr_0_ptr,bmp_width);
      for x:=0 to rct_dst.width-1 do
        if ((f_arr_0_ptr+x)^<>0) then
          if Odd(PInteger(pixel_ptr+x)-PInteger(pixel_ptr0)) then
            (pixel_ptr+x)^:=pix_color;
      Inc(pixel_ptr  ,bmp_width);
      Inc(f_arr_0_ptr,bmp_width);
    end;}
end; {$endregion}
procedure ArrFilProc01(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
  r,g,b      : byte;
begin
  r          :=TRGBA(col).r;
  g          :=TRGBA(col).g;
  b          :=TRGBA(col).b;
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            pixel_ptr^:={Additive0(pixel_ptr^,r,g,b);} RGB(Min(TRGBA(pixel_ptr^).r+b,MAXBYTE),
                                                           Min(TRGBA(pixel_ptr^).g+g,MAXBYTE),
                                                           Min(TRGBA(pixel_ptr^).b+r,MAXBYTE));
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFilProc02(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
  col_inv    : TColor;
  d_alpha1   : byte;
begin
  col_inv    :=SetColorInv(col);
  d_alpha1   :=MAXBYTE-alpha;
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            AlphaBlend1(pixel_ptr,col_inv,d_alpha1);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFilProc03(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            Inverse1(pixel_ptr);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFilProc04(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            Highlight1(pixel_ptr,64);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFilProc05(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            Darken1(pixel_ptr,64);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFilProc06(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            GrayscaleR1(pixel_ptr);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFilProc07(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            GrayscaleG1(pixel_ptr);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFilProc08(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
begin
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) then
            GrayscaleB1(pixel_ptr);
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFilProc09(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
var
  pixel_ptr  : PInteger;
  f_arr_0_ptr: PByte;
  d_width    : integer;
  x,y        : integer;
  pix_color  : TColor;
begin
  pix_color  :=RGB(TRGBA(col).b,TRGBA(col).g,TRGBA(col).r);
  d_width    :=bmp_width-rct_dst.width;
  pixel_ptr  :=Unaligned(@bmp_ptr[rct_dst.left+bmp_width*rct_dst.top]);
  f_arr_0_ptr:=Unaligned(@arr0   [rct_dst.left+bmp_width*rct_dst.top]);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (f_arr_0_ptr^<>0) and Odd(pixel_ptr^) then
            pixel_ptr^:=pix_color;
          Inc(pixel_ptr  );
          Inc(f_arr_0_ptr);
        end;
      Inc(pixel_ptr  ,d_width);
      Inc(f_arr_0_ptr,d_width);
    end;
end; {$endregion}
procedure ArrFilProc10(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
begin
  {TODO}
end; {$endregion}
procedure ArrFilProc11(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
begin
  {TODO}
end; {$endregion}
procedure ArrFilProc12(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
begin
  {TODO}
end; {$endregion}
procedure ArrFilProc13(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
begin
  {TODO}
end; {$endregion}
procedure ArrFilProc14(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
begin
  {TODO}
end; {$endregion}
procedure ArrFilProc15(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
begin
  {TODO}
end; {$endregion}
procedure ArrFilProc16(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
begin
  {TODO}
end; {$endregion}
procedure ArrFilProc17(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
begin
  {TODO}
end; {$endregion}
procedure ArrFilProc18(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
begin
  {TODO}
end; {$endregion}
procedure ArrFilProc19(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
begin
  {TODO}
end; {$endregion}
procedure ArrFilProc20(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
begin
  {TODO}
end; {$endregion}
procedure ArrFilProc21(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
begin
  {TODO}
end; {$endregion}
procedure ArrFilProc22(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
begin
  {TODO}
end; {$endregion}
procedure ArrFilProc23(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
begin
  {TODO}
end; {$endregion}
procedure ArrFilProc24(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
begin
  {TODO}
end; {$endregion}
procedure ArrFilProc25(const arr0:T1Byte1Arr; const bmp_ptr:PInteger; const bmp_width,bmp_height:TColor; const rct_dst:TPtrect; const col:TColor; const alpha:byte=120); {$region -fold}
begin
  {TODO}
end; {$endregion}
// Copy fields of it_cnt items of arr_src separately to arr_dst0,arr_dst1,arr_dst2 from start_ind:
procedure FillArray   (const arr_src:TPtPosFArr; var arr_dst0,arr_dst1:TDublArr; var arr_dst2:TColorArr; const start_ind,it_cnt:TColor); {$region -fold}
var
  arr_src_ptr: PPtPosF;
  i          : integer;
begin
  arr_src_ptr:=@arr_src[start_ind];
  for i:=0 to it_cnt-1 do
    begin
      arr_dst0[i]:=(PDouble(arr_src_ptr+i)+0)^;
      arr_dst1[i]:=(PDouble(arr_src_ptr+i)+1)^;
      arr_dst2[i]:=start_ind+i;
    end;
end; {$endregion}
// Shell Sort:
procedure ShellSortX  (var arr_dst0,arr_dst1:TDublArr; var arr_dst2:TColorArr; const start_ind,it_cnt:integer); {$region -fold}
var
  arr_dst_ptr0: PDouble;
  arr_dst_ptr1: PDouble;
  arr_dst_ptr2: PInteger;
  tmp0        : double;
  tmp1        : double;
  tmp2        : integer;
  i,j,k       : integer;
begin
  arr_dst_ptr0:=@arr_dst0[start_ind];
  arr_dst_ptr1:=@arr_dst1[start_ind];
  arr_dst_ptr2:=@arr_dst2[start_ind];
  k           :=1;
  while (k<=it_cnt/3) do
    k:=k*3+1;
  while (k>0) do
    begin
      for j:=k to it_cnt-1 do
        begin
          tmp0:=(arr_dst_ptr0+j)^;
          tmp1:=(arr_dst_ptr1+j)^;
          tmp2:=(arr_dst_ptr2+j)^;
          i   :=j;
          while (i>k-1) and ((arr_dst_ptr0+i-k)^>tmp0) do
            begin
              (arr_dst_ptr0+i)^:=(arr_dst_ptr0+i-k)^;
              (arr_dst_ptr1+i)^:=(arr_dst_ptr1+i-k)^;
              (arr_dst_ptr2+i)^:=(arr_dst_ptr2+i-k)^;
              i                -=k;
            end;
          (arr_dst_ptr0+i)^:=tmp0;
          (arr_dst_ptr1+i)^:=tmp1;
          (arr_dst_ptr2+i)^:=tmp2;
        end;
      k:=Trunc((k-1)/3);
    end;
end; {$endregion}
procedure ShellSortY  (var arr_dst0,arr_dst1:TDublArr; var arr_dst2:TColorArr; const start_ind,it_cnt:integer); {$region -fold}
var
  arr_dst_ptr0: PDouble;
  arr_dst_ptr1: PDouble;
  arr_dst_ptr2: PInteger;
  tmp0        : double;
  tmp1        : double;
  tmp2        : integer;
  i,j,k       : integer;
begin
  arr_dst_ptr0:=@arr_dst0[start_ind];
  arr_dst_ptr1:=@arr_dst1[start_ind];
  arr_dst_ptr2:=@arr_dst2[start_ind];
  k           :=1;
  while (k<=it_cnt/3) do
    k:=k*3+1;
  while (k>0) do
    begin
      for j:=k to it_cnt-1 do
        begin
          tmp0:=(arr_dst_ptr0+j)^;
          tmp1:=(arr_dst_ptr1+j)^;
          tmp2:=(arr_dst_ptr2+j)^;
          i   :=j;
          while (i>k-1) and ((arr_dst_ptr1+i-k)^>tmp1) do
            begin
              (arr_dst_ptr0+i)^:=(arr_dst_ptr0+i-k)^;
              (arr_dst_ptr1+i)^:=(arr_dst_ptr1+i-k)^;
              (arr_dst_ptr2+i)^:=(arr_dst_ptr2+i-k)^;
              i                -=k;
            end;
          (arr_dst_ptr0+i)^:=tmp0;
          (arr_dst_ptr1+i)^:=tmp1;
          (arr_dst_ptr2+i)^:=tmp2;
        end;
      k:=Trunc((k-1)/3);
    end;
end; {$endregion}
// Sum of array elements:
function ArrNzItSum   (const arr:T1Byte1Arr): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=0;
  for i:=0 to Length(arr)-1 do
    Inc(Result,arr[i]);
end; {$endregion}
function ArrNzItSum   (const arr:TWordArr  ): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=0;
  for i:=0 to Length(arr)-1 do
    Inc(Result,arr[i]);
end; {$endregion}
function ArrNzItSum   (const arr:TColorArr ): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=0;
  for i:=0 to Length(arr)-1 do
    Inc(Result,arr[i]);
end; {$endregion}
// Non-zero items count:
function ArrNzItCnt   (const bmp_dst_ptr:PInteger; const rct_dst:TPtRect; const bmp_dst_width:TColor; const col:TColor): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  Result       :=0;
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        Inc(Result,Byte((dst_pixel_ptr+x)^=col));
      Inc               (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
function ArrNzItCnt   (const arr1_ptr:PShortInt;   const arr2_ptr:PByte;  const length:integer                        ): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=0;
  for i:=0 to length-1 do
    Inc(Result,Byte(((arr1_ptr+i)^=0) and
                    ((arr2_ptr+i)^=1)));
end; {$endregion}
function ArrNzItCnt   (const arr1_ptr:PShortInt;                          const length:integer; b:boolean             ): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=0;
  for i:=0 to length-1 do
    Inc(Result,Byte((arr1_ptr+i)^=0));
end; {$endregion}
function ArrNzItCnt   (const arr:T1Byte1Arr; const max_arr_it_val:TColor=MAXBYTE                                      ): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  //n,m: TColor;
  i  : integer;
begin
  Result:=0;
  {n     :=1+Trunc(Ln(Double(max_arr_it_val-1))/Ln(2)); // instead of max_arr_it_val, you can substitute any other number in the interval [2**Trunc(Ln(Double(max_arr_it_val))/Ln(2))+1;+inf)
  m     :=1<<n-1;}
  for i:=0 to Length(arr)-1 do
    Inc(Result,(arr[i]+NZ_ITEM_COEFF20{m})>>NZ_ITEM_COEFF10{n}); // Inc(Result,Ord(arr[i]<>0));// the less array is sparse the faster it is
                                                                                               // as compared with:
                                                                                               // "if arr[i]<>0 then
                                                                                               //    Inc(Result);"
end; {$endregion}
function ArrNzItCnt   (const arr:TWordArr;   const max_arr_it_val:TColor=MAXWORD                                      ): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  //n,m: TColor;
  i  : integer;
begin
  Result:=0;
  {n     :=1+Trunc(Ln(Double(max_arr_it_val-1))/Ln(2)); // instead of max_arr_it_val, you can substitute any other number in the interval [2**Trunc(Ln(Double(max_arr_it_val))/Ln(2))+1;+inf)
  m     :=1<<n-1;}
  for i:=0 to Length(arr)-1 do
    Inc(Result,(arr[i]+NZ_ITEM_COEFF21{m})>>NZ_ITEM_COEFF11{n}); // Inc(Result,Ord(arr[i]<>0));// the less array is sparse the faster it is
                                                                                               // as compared with:
                                                                                               // "if arr[i]<>0 then
                                                                                               //    Inc(Result);"
end; {$endregion}
function ArrNzItCnt   (const arr:TColorArr;  const max_arr_it_val:TColor=MAXDWORD                                     ): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  //n,m: TColor;
  i  : integer;
begin
  Result:=0;
  {n     :=1+Trunc(Ln(Double(max_arr_it_val-1))/Ln(2)); // instead of max_arr_it_val, you can substitute any other number in the interval [2**Trunc(Ln(Double(max_arr_it_val))/Ln(2))+1;+inf)
  m     :=1<<n-1;}
  for i:=0 to Length(arr)-1 do
    Inc(Result,(arr[i]+NZ_ITEM_COEFF22{m})>>NZ_ITEM_COEFF12{n}); // Inc(Result,Ord(arr[i]<>0));// the less array is sparse the faster it is
                                                                                               // as compared with:
                                                                                               // "if arr[i]<>0 then
                                                                                               //    Inc(Result);"
end; {$endregion}
function NzBitCnt     (const arr:T1Byte1Arr; const bit_cnt       :word                                                ): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j,k: integer;
begin
  Result :=0;
  k      :=0;
  for   i:=0 to Length(arr)-1 do
    for j:=0 to 7 do
      begin
        Inc(Result,(((arr[i]>>j) and 1)+NZ_ITEM_COEFF20)>>
                                        NZ_ITEM_COEFF10);
        Inc(k);
        if (k=bit_cnt) then
          Exit;
      end;
end; {$endregion}
// Test:
function  ArrNzItCnt  (const grid_prop:TGrid; grid_arr_ptr:PInteger; pts_arr_ptr:PPtPosF; dst_canvas:TCanvas          ): TColor; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j,k: integer;

  function GetCoef(n:integer): integer; {$region -fold}
  begin
    Result:=5*(1<<(1+Trunc(ln(n)/ln(2))-3));
  end; {$endregion}

begin
  with grid_prop do
    begin
      Result:=0;
      for j:=0 to grid_density.y-1 do
        for i:=0 to grid_density.x-1 do
          begin
            k:=i+grid_density.x*j;
            if (grid_arr_ptr+k)^<>0 then
              begin
                Text
                (
                  Trunc(grid_rct.left+i*grid_dx),
                  Trunc(grid_rct.top +j*grid_dy),
                  dst_canvas,
                  IntToStr((grid_arr_ptr+k)^)
                );
                Inc(Result,(grid_arr_ptr+k)^);
              end;
          end;
      Text
      (
        Trunc(grid_rct.left+(grid_density.x-1)*grid_dx),
        Trunc(grid_rct.top +(grid_density.y  )*grid_dy-GetCoef(dst_canvas.font.height)),
        dst_canvas,
        IntToStr(Result)
      );
    end;
end; {$endregion}
// Create array with "visible" items:
procedure ArrNzItCrt  (const arr1_src_ptr:PShortInt; const arr2_src_ptr:PByte; arr_dst_ptr:PColor; const length1,length2:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_dst_ptr0: PColor;
  i           : integer;
begin
  arr_dst_ptr0:=arr_dst_ptr;
  for i:=0 to length1-1 do
    if ((arr1_src_ptr+i)^=0) and
       ((arr2_src_ptr+i)^=1) then
      begin
        arr_dst_ptr^:=i;
        Inc(arr_dst_ptr);
        if (arr_dst_ptr-arr_dst_ptr0=length2) then
          Break;
      end;
end; {$endregion}
procedure ArrNzItCrt  (const arr1_src_ptr:PShortInt;                           arr_dst_ptr:PColor; const length1,length2:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_dst_ptr0: PColor;
  i           : integer;
begin
  arr_dst_ptr0:=arr_dst_ptr;
  for i:=0 to length1-1 do
    if ((arr1_src_ptr+i)^=0) then
      begin
        arr_dst_ptr^:=i;
        Inc(arr_dst_ptr);
        if (arr_dst_ptr-arr_dst_ptr0=length2) then
          Break;
      end;
end; {$endregion}
// Copy one array to another:
procedure ArrToArr1   (arr_src_ptr:PPtPosF; arr_dst_ptr:PPtPosF; pts_cnt:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to pts_cnt-1 do
    (arr_dst_ptr+i)^:=(arr_src_ptr+i)^;
end; {$endregion}
procedure ArrToArr2   (arr_src_ptr:PPtPosF; arr_dst_ptr:PPtPosF; pts_cnt:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to pts_cnt-1 do
    (arr_src_ptr+i)^:=(arr_dst_ptr+i)^;
end; {$endregion}
// Search for the first non-zero item starting from data_start; length is the number of items to check:
function NotIndexByte (data_start:PByte ; length:integer): integer; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j,k,n: integer;
begin
  Result:=-1;
  k     :=00;
  for i:=0 to length>>3-1 do
    if ((PQWord(data_start+i<<3))^<>0) then
      begin
        Result:=i<<3;
        Break;
      end;
  if (Result=-1) then
    begin
      k         :=Trunc(length/8)<<3;
      data_start+=k;
    end
  else
    Exit;
  n:=-1;
  for j:=0 to Min(7,length-k) do
    if (PByte(data_start+j<<0)^<>0) then
      begin
        k+=j<<0;
        n:=0;
        Break;
      end;
  if (n<>-1) then
    Result:=k;
end; {$endregion}
function NotIndexWord (data_start:PWord ; length:integer): integer; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j,k,n: integer;
begin
  Result:=-1;
  k     :=00;
  for i:=0 to length>>2-1 do
    if ((PQWord(data_start+i<<2))^<>0) then
      begin
        Result:=i<<2;
        Break;
      end;
  if (Result=-1) then
    begin
      k         :=Trunc(length/4)<<2;
      data_start+=k;
    end
  else
    Exit;
  n:=-1;
  for j:=0 to Min(3,length-k) do
    if (PWord(data_start+j<<0)^<>0) then
      begin
        k+=j<<0;
        n:=0;
        Break;
      end;
  if (n<>-1) then
    Result:=k;
end; {$endregion}
function NotIndexDWord(data_start:PDWord; length:integer): integer; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j,k,n: integer;
begin
  Result:=-1;
  k     :=00;
  for i:=0 to length>>1-1 do
    if ((PQWord(data_start+i<<1))^<>0) then
      begin
        Result:=i<<1;
        Break;
      end;
  if (Result=-1) then
    begin
      k         :=Trunc(length/2)<<1;
      data_start+=k;
    end
  else
    Exit;
  n:=-1;
  for j:=0 to Min(1,length-k) do
    if (PDWord(data_start+j<<0)^<>0) then
      begin
        k+=j<<0;
        n:=0;
        Break;
      end;
  if (n<>-1) then
    Result:=k;
end; {$endregion}
function NotIndexQWord(data_start:PQWord; length:integer): integer; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Result:=-1;
  for i:=0 to length>>0-1 do
    if (PQWord(data_start+i<<0)^<>0) then
      begin
        Result:=i<<0;
        Break;
      end;
end; {$endregion}
// Search for the last non-zero item starting from data_start; length is the number of items to check:
function NotIndexWord2(data_start:PWord ; length:integer): integer; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to length do
    if ((data_start-i)^<>0) then
      begin
        Result:=i;
        Break;
      end;
end; {$endregion}
// Fill primitives on array:
procedure SetGridProp0(var   grid_prop:TGrid; const grid_rct_:TPtRectF; const shift_:TPtPosF; const grid_density_:TPtPos; const val_:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with grid_prop do
    begin
      grid_rct    :=grid_rct_;
      shift       :=shift_;
      grid_density:=grid_density_;
      grid_dx     :=grid_rct.width /grid_density.x;
      grid_dy     :=grid_rct.height/grid_density.y;
      grid_dx_inv :=1/grid_dx;
      grid_dy_inv :=1/grid_dy;
      val         :=val_;
    end;
end; {$endregion}
procedure FillLnOnGrid(const grid_prop:TGrid; grid_arr_ptr:PInteger; pts_arr_ptr:PPtPosF                                                    ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  c_prop_arr                                         : array[0..1] of TPtPos5=((x0:0; x1:1; x2:0; x3:0; x4:01),
                                                                               (x0:1; x1:0; x2:1; x3:1; x4:-1));
  ln_pt                                              : TPtPos=(x:0; y:0);
  p0,p1                                              : TPtPosF;
  t0,t1,a0,a1,a_inv,p                                : double;
  add0,add1,add4,add5,add6,add7,add8,add9,add10,add11: integer;
  b                                                  : boolean;

  procedure FillGridCalc0;                       {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    with grid_prop do
      begin
        if ((pts_arr_ptr+1)^.x>=
            (pts_arr_ptr+0)^.x) then
          begin
            p0.x:=(pts_arr_ptr+0)^.x+shift.x;
            p0.y:=(pts_arr_ptr+0)^.y+shift.y;
            p1.x:=(pts_arr_ptr+1)^.x+shift.x;
            p1.y:=(pts_arr_ptr+1)^.y+shift.y;
          end
        else
          begin
            p0.x:=(pts_arr_ptr+1)^.x+shift.x;
            p0.y:=(pts_arr_ptr+1)^.y+shift.y;
            p1.x:=(pts_arr_ptr+0)^.x+shift.x;
            p1.y:=(pts_arr_ptr+0)^.y+shift.y;
          end;
        ln_pt.x:=Trunc((p0.y-grid_rct.top)*grid_dy_inv);
        ln_pt.y:=Trunc((p1.y-grid_rct.top)*grid_dy_inv);
        b:=(p1.y<p0.y);
        if b then
          begin
          //g0  := grid_rct.top+(ln_pt.x+1)*grid_dy-p0.y;
          //g1  :=-grid_rct.top-(ln_pt.y+0)*grid_dy+p1.y;
           {p   :=(ln_pt.x+ln_pt.y+1)*grid_dy-p0.y-p1.y-2*grid_rct.top; //p:=g0-g1;
            p0.y+=p;
            p1.y+=p;}
            Swap3(p0.y,p1.y);
            Swap1(ln_pt.x,ln_pt.y);
            //ln_pt.y-=1;
          end;
        a_inv:=       (p1.x-p0.x)/(p1.y-p0.y);
        t0   :=      ((p0.x-grid_rct.left)      *grid_dx_inv);
        a0   :=       (grid_dy           *a_inv *grid_dx_inv);
        a1   :=a0+t0-((p0.y-grid_rct.top)*a_inv)*grid_dx_inv ;
      end;
  end; {$endregion}

  procedure FillGridCalc1(const c_prop:TPtPos5); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    with grid_prop,c_prop do
      begin
        add6:=x0*ln_pt.x+x1*ln_pt.y;
        add7:=x2*ln_pt.x+x3*ln_pt.y;
        add8:=x4;
      //add4:=add7*grid_density.x;
        add5:=add8*grid_density.x;
      end;
  end; {$endregion}

  procedure FillGridCalc2;                       {$ifdef Linux}[local];{$endif} {$region -fold}
  var
    j,q1,q2: integer;
    q0     : double;

    procedure FillGridCalc3;                        {$ifdef Linux}[local];{$endif} {$region -fold}
    var
      i: integer;
    begin
      add10:=Max2(000000,-add0);
      add11:=Min2(add9-1,-add0+Trunc(q0));
      add1 +=add10;
      for i:=add10 to add11 do //for i:=0 to Trunc(q0)-add0 do
        begin
          //if (i>=-add0) and (i<add9) then
            (grid_arr_ptr+add1)^+=1;
          Inc(add1);
        end;
    end; {$endregion}

  begin
    with grid_prop do
      begin
        q0:=ln_pt.x*a0  +a1  ;
        q1:=ln_pt.x*add8+add7;
        q2:=q1*grid_density.x;
        for j:=0 to ln_pt.y-ln_pt.x-1 do //for j:=ln_pt.x to ln_pt.y-1 do
          begin
            if (q1>=0) and (q1<grid_density.y) then
              begin
                //t1:=q0; //t1:=j*a0+a1; //t1:=(((j+1)*grid_dy-p0.y+grid_rct.top)*a_inv+p0.x-grid_rct.left)*grid_dx_inv;
                add0:=Trunc(t0);
                add1:=add0+q2; //add1:=add0+add4+add5*j; //add1=add0+i+((ln_pt.x+j)*add8+add7)*grid_density.x;
                add9:=grid_density.x-add0;
                FillGridCalc3;
              end;
            t0:=q0;
            q0+=a0;
            q1+=add8;
            q2+=add5;
          end;
        if (add6>=0) and (add6<grid_density.y) then
          begin
            add0:=Trunc(t0);
            add1:=grid_density.x*add6+add0;
            add9:=grid_density.x*0001-add0;
            t0  :=(p0.x-grid_rct.left+(grid_dy*ln_pt.y-(p0.y-grid_rct.top))*a_inv)*grid_dx_inv;
            t1  :=(p1.x-grid_rct.left+0000000000000000000000000000000000000000000)*grid_dx_inv;
            q0  :=t1;
            FillGridCalc3;
          end;
      end;
  end; {$endregion}

begin
  FillGridCalc0;
  FillGridCalc1(c_prop_arr[Byte(b)]);
  FillGridCalc2;
end; {$endregion}
procedure FillLnOnGrid(const grid_prop:TGrid; grid_arr_ptr:PInteger; pts_arr_ptr:PPtPosF; const pts_cnt:integer                             ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  with grid_prop do
    for i:=0 to pts_cnt-2 do
      FillLnOnGrid(grid_prop,
                   grid_arr_ptr,
                   pts_arr_ptr+i);
end; {$endregion}
procedure FillPtOnGrid(const grid_prop:TGrid; grid_arr_ptr:PInteger; pts_arr_ptr:PPtPosF                                                    ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p: TPtPosF;
begin
  with grid_prop do
    begin
      p.x:=pts_arr_ptr^.x+shift.x-grid_rct.left;
      p.y:=pts_arr_ptr^.y+shift.y-grid_rct.top;
      if IsPtInRct(p.x+grid_rct.left,p.y+grid_rct.top,grid_rct) then
        (grid_arr_ptr+Trunc(p.x*grid_dx_inv)+grid_density.x*Trunc(p.y*grid_dy_inv))^+=1;
    end;
end; {$endregion}
procedure FillPtOnGrid(const grid_prop:TGrid; grid_arr_ptr:PInteger; pts_arr_ptr:PPtPosF; const pts_cnt:integer                             ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  with grid_prop do
    for i:=0 to pts_cnt-1 do
      FillPtOnGrid(grid_prop,
                   grid_arr_ptr,
                   pts_arr_ptr+i);
end; {$endregion}
procedure SetGridProp1(var   grid_prop:TGrid; grid_arr_ptr:PInteger; var rct_inn,rct_out:TPtRectF                                           ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  v0,v1: double;
  j    : integer;
begin
  with grid_prop do
    begin
      v0:=grid_density.x/rct_out.width;
      v1:=grid_density.y/rct_out.height;
      i0:=Trunc((rct_inn.left  -rct_out.left)*v0);
      i1:=Trunc((rct_inn.right -rct_out.left)*v0);
      if (i1 =  (rct_inn.right -rct_out.left)*v0) then
          i1-=1;
      j0:=Trunc((rct_inn.top   -rct_out.top )*v1);
      j1:=Trunc((rct_inn.bottom-rct_out.top )*v1);
      if (j1 =  (rct_inn.bottom-rct_out.top )*v1) then
          j1-=1;
      di:=i1-i0+1;
      dj:=j1-j0;
    end;
end; {$endregion}
procedure FillRtOnGrid(const grid_prop:TGrid; grid_arr_ptr:PInteger; b:boolean                                                              ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  grid_arr_ptr2: PInteger;
  j            : integer;
begin
  with grid_prop do
    begin
      //SetGridProp1...;
      grid_arr_ptr2:=grid_arr_ptr+i0+j0*grid_density.x;
      for j:=0 to dj do
        begin
          FillDWord(grid_arr_ptr2^,di,val);
          Inc(grid_arr_ptr2,grid_density.x);
        end;
    end;
end; {$endregion}
procedure FillRtOnGrid(const grid_prop:TGrid; grid_arr_ptr:PInteger                                                                         ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  grid_arr_ptr2: PInteger;
  i,j          : integer;
begin
  with grid_prop do
    begin
      //SetGridProp1...;
      grid_arr_ptr2:=grid_arr_ptr+i0+j0*grid_density.x;
      for j:=0 to dj do
        begin
          for i:=0 to di do
            (grid_arr_ptr2+i)^+=val;
          Inc(grid_arr_ptr2,grid_density.x);
        end;
    end;
end; {$endregion}

{$endregion}



(******************************** Linked lists ********************************) {$region -fold}

procedure LinkArrIt  (const arr    :T1Byte1Arr; var list_as_arr     :TListItemArr); {$region -fold}
var
  i,j,k: integer;
begin
  k      :=0;
  for   i:=0 to Length(arr)-1 do
    for j:=0 to 7 do
      begin
        if (((arr[i]>>j) and 1)<>0) then
          begin
            with list_as_arr[k] do
              begin
                ind          :=j+i<<3;
                next_item_ptr:=@list_as_arr[k+1];
              end;
            Inc(k);
          end;
        if (k=Length(list_as_arr)) then
          begin
            list_as_arr[k-1].next_item_ptr:=Nil;
            Exit;
          end;
      end;
end; {$endregion}
procedure AddListItem(const pt_x   :integer;    var first_item,p1,p2:PIList);       {$region -fold}
begin
  New(p1);
  New(p1^.x_ptr);
  p1^.x_ptr^:=pt_x;
  if (first_item=Nil) then
    first_item:=p1
  else
    p2^.next_item:=p1;
  p2:=p1;
end; {$endregion}
procedure AddListItem(const pt     :TPtPosF;    var first_item,p1,p2:PFList);       {$region -fold}
begin
  New(p1);
  p1^.x:=pt.x;
  p1^.y:=pt.y;
  if (first_item=Nil) then
    first_item:=p1
  else
    p2^.next_item:=p1;
  p2:=p1;
end; {$endregion}
procedure ArrToList1 (const arr_src:TIntrArr;   var first_item,p1,p2:PIList);       {$region -fold}
var
  arr_src_ptr:^integer;
  i          : integer;
begin
  arr_src_ptr:=@arr_src[0];
  first_item :=Nil;
  for i:=0 to Length(arr_src)-1 do
    begin
      New(p1);
      p1^.x_ptr:=arr_src_ptr;
      if (first_item=Nil) then
        first_item:=p1
      else
        p2^.next_item:=p1;
      p2:=p1;
      Inc(arr_src_ptr);
    end;
  p2^.next_item:=Nil;
end; {$endregion}
procedure ArrToList2 (const arr_src:TIntrArr;   var first_item,p1,p2:PIList);       {$region -fold}
var
  arr_src_ptr:^integer;
  i          : integer;
begin
  arr_src_ptr:=@arr_src[0];
  first_item :=Nil;
  for i:=0 to Length(arr_src)-1 do
    begin
      New(p1);
      New(p1^.x_ptr);
      p1^.x_ptr^:=arr_src_ptr^;
      if (first_item=Nil) then
        first_item:=p1
      else
        p2^.next_item:=p1;
      p2:=p1;
      Inc(arr_src_ptr);
    end;
  p2^.next_item:=Nil;
end; {$endregion}
procedure ListToArr  (var   arr_dst:TIntrArr;   var first_item,p1,p2:PIList);       {$region -fold}
var
  arr_dst_ptr:^integer;
  i          : integer;
begin
  arr_dst_ptr:=@arr_dst[0];
  p1         :=first_item;
  for i:=0 to Length(arr_dst)-1 do
    begin
      arr_dst_ptr^:=p1^.x_ptr^;
      p1          :=p1^.next_item;
      Inc(arr_dst_ptr);
    end;
  p2^.next_item:=Nil;
end; {$endregion}
procedure ListToArr  (var   arr_dst:TPtPosFArr; var first_item,p1,p2:PFList);       {$region -fold}
var
  arr_dst_ptr: PPtPosF;
  i          : integer;
begin
  arr_dst_ptr:=@arr_dst[0];
  p1         :=first_item;
  for i:=0 to Length(arr_dst)-1 do
    begin
      arr_dst_ptr^.x:=p1^.x;
      arr_dst_ptr^.y:=p1^.y;
      p1            :=p1^.next_item;
      Inc(arr_dst_ptr);
    end;
  p2^.next_item:=Nil;
end; {$endregion}
procedure FreeList1 (                           var first_item,p1,p2:PIList);       {$region -fold}
var
  t:PIList;
begin
  p1:=first_item;
  while (p1<>Nil) do
    begin
      t :=p1;
      p1:=p1^.next_item;
      Dispose(t);
    end;
  first_item:=Nil;
  p1        :=Nil;
  p2        :=Nil;
end; {$endregion}
procedure FreeList2 (                           var first_item,p1,p2:PFList);       {$region -fold}
var
  t:PFList;
begin
  p1:=first_item;
  while (p1<>Nil) do
    begin
      t :=p1;
      p1:=p1^.next_item;
      Dispose(t);
    end;
  first_item:=Nil;
  p1        :=Nil;
  p2        :=Nil;
end; {$endregion}

{$endregion}



(***************************** Edge anti-aliasing *****************************) {$region -fold}

//
procedure BorderCalc00(const arr_src_ptr:PInteger  ; var arr_dst:T1Byte1Arr; const ft_cnt:TColor;    const arr_src_width,arr_src_height,arr_dst_width:TColor; const rct_dst:TPtRect;                 const background_color:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2         : PInteger;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
begin
  if (arr_src_width*arr_src_height=0) then
    Exit;
  d_width1    := arr_src_width-rct_dst.width;
  d_width2    := arr_dst_width-rct_dst.width;
  arr_src_ptr2:= arr_src_ptr  +rct_dst.left+arr_src_width*rct_dst.top;
  arr_dst_ptr :=@arr_dst      [rct_dst.left+arr_dst_width*rct_dst.top];
  if (ft_cnt=arr_src_width*arr_src_height) then
    for y:=0 to rct_dst.height-1 do
      begin
        for x:=0 to rct_dst.width-1 do
          begin
            arr_dst_ptr^:=Byte(arr_src_ptr2^<>background_color);
            Inc(arr_src_ptr2);
            Inc(arr_dst_ptr );
          end;
        Inc(arr_src_ptr2,d_width1);
        Inc(arr_dst_ptr ,d_width2);
      end
  else
    for y:=0 to rct_dst.height-1 do
      begin
        for x:=0 to rct_dst.width-1 do
          begin
            arr_dst_ptr^:=Byte((arr_src_ptr2^>>24)<>0);
            Inc(arr_src_ptr2);
            Inc(arr_dst_ptr );
          end;
        Inc(arr_src_ptr2,d_width1);
        Inc(arr_dst_ptr ,d_width2);
      end;
end; {$endregion}
procedure BorderCalc01(const arr_src_ptr:PInteger  ; var arr_dst:T1Byte1Arr; const ft_cnt:TColor;    const arr_src_width,arr_src_height,arr_dst_width:TColor; const rct_dst:TPtRect;                 const background_color:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_arr1,pt_arr2      : array[0..4] of integer;
  arr_src_ptr2         : PInteger;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
  ft_pix_cnt_          : TColor;

  procedure TByteArrInit(b0,b1,b2,b3:byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    arr_dst_ptr^:=(b0<<0)+
                  (b1<<1)+
                  (b2<<2)+
                  (b3<<3);
  end; {$endregion}

begin
  if (arr_src_width*arr_src_height=0) then
    Exit;
  ft_pix_cnt_          :=ft_cnt;
  d_width1             :=                             arr_src_width- rct_dst.width;
  d_width2             :=                             arr_dst_width- rct_dst.width;
  pt_arr1[0]           :=rct_dst.left+                arr_src_width* rct_dst.top;
  pt_arr1[1]           :=rct_dst.left+rct_dst.width-1+arr_src_width* rct_dst.top;
  pt_arr1[2]           :=rct_dst.left+                arr_src_width*(rct_dst.top+rct_dst.height-1);
  pt_arr1[3]           :=rct_dst.left+rct_dst.width-1+arr_src_width*(rct_dst.top+rct_dst.height-1);
  pt_arr1[4]           :=rct_dst.left+              1+arr_src_width*(rct_dst.top+               1);
  pt_arr2[0]           :=rct_dst.left+                arr_dst_width* rct_dst.top;
  pt_arr2[1]           :=rct_dst.left+rct_dst.width-1+arr_dst_width* rct_dst.top;
  pt_arr2[2]           :=rct_dst.left+                arr_dst_width*(rct_dst.top+rct_dst.height-1);
  pt_arr2[3]           :=rct_dst.left+rct_dst.width-1+arr_dst_width*(rct_dst.top+rct_dst.height-1);
  pt_arr2[4]           :=rct_dst.left+              1+arr_dst_width*(rct_dst.top+               1);
  if (ft_pix_cnt_=arr_src_width*arr_src_height) then {$region -fold}
    begin
      {Fill Borders-} {$region -fold}
      arr_src_ptr2:=Unaligned( arr_src_ptr+pt_arr1[0] );
      arr_dst_ptr :=Unaligned(@arr_dst    [pt_arr2[0]]);
      if (arr_src_width=1) then
        begin
          if (arr_src_height=1) then
            {1 pixel--} {$region -fold}
            begin
              TByteArrInit(
                0,
                0,
                0,
                0);
              Exit;
            end {$endregion}
          else
            {Left Line} {$region -fold}
            begin
              {Left Line: first pixel       (000000000000000000000)} {$region -fold}
              TByteArrInit(
                0,
                0,
                0,
                Byte((arr_src_ptr2+arr_src_width)^<>background_color));
              Inc(arr_src_ptr2,arr_src_width);
              Inc(arr_dst_ptr ,arr_dst_width); {$endregion}
              {Left Line: from top to bottom(1 to rct_dst.height-2)} {$region -fold}
              if (arr_src_height>=3) then
                for y:=0 to rct_dst.height-3 do
                  begin
                    TByteArrInit(
                      Byte((arr_src_ptr2-arr_src_width)^<>background_color),
                      0,
                      0,
                      Byte((arr_src_ptr2+arr_src_width)^<>background_color));
                    Inc(arr_src_ptr2,arr_src_width);
                    Inc(arr_dst_ptr ,arr_dst_width);
                  end; {$endregion}
              {Left Line: last  pixel       (     rct_dst.height-1)} {$region -fold}
              TByteArrInit(
                Byte((arr_src_ptr2-arr_src_width)^<>background_color),
                0,
                0,
                0);
              Exit; {$endregion}
            end; {$endregion}
        end
      else
        begin
          if (arr_src_height=1) then
            {Top   Line} {$region -fold}
            begin
              {Top Line: first pixel       (00000000000000000000)} {$region -fold}
              TByteArrInit(
                0,
                0,
                Byte((arr_src_ptr2+0000000000001)^<>background_color),
                0);
              Inc(arr_src_ptr2);
              Inc(arr_dst_ptr ); {$endregion}
              {Top Line: from left to right(1 to rct_dst.width-2)} {$region -fold}
              if (arr_src_width>=3) then
                for x:=0 to rct_dst.width-3 do
                  begin
                    TByteArrInit(
                      0,
                      Byte((arr_src_ptr2-0000000000001)^<>background_color),
                      Byte((arr_src_ptr2+0000000000001)^<>background_color),
                      0);
                    Inc(arr_src_ptr2);
                    Inc(arr_dst_ptr );
                  end; {$endregion}
              {Top Line: last  pixel       (     rct_dst.width-1)} {$region -fold}
              TByteArrInit(
                0,
                Byte((arr_src_ptr2-0000000000001)^<>background_color),
                0,
                0);
              Exit; {$endregion}
            end {$endregion}
          else
            begin

              {Left   Line} {$region -fold}
              begin
                {Left Line: first pixel       (000000000000000000000)} {$region -fold}
                TByteArrInit(
                  0,
                  0,
                  Byte((arr_src_ptr2+0000000000001)^<>background_color),
                  Byte((arr_src_ptr2+arr_src_width)^<>background_color));
                Inc(arr_src_ptr2,arr_src_width);
                Inc(arr_dst_ptr ,arr_dst_width); {$endregion}
                {Left Line: from top to bottom(1 to rct_dst.height-2)} {$region -fold}
                if (arr_src_height>=3) then
                  for y:=0 to rct_dst.height-3 do
                    begin
                      TByteArrInit(
                        Byte((arr_src_ptr2-arr_src_width)^<>background_color),
                        0,
                        Byte((arr_src_ptr2+0000000000001)^<>background_color),
                        Byte((arr_src_ptr2+arr_src_width)^<>background_color));
                      Inc(arr_src_ptr2,arr_src_width);
                      Inc(arr_dst_ptr ,arr_dst_width);
                    end; {$endregion}
                {Left Line: last  pixel       (     rct_dst.height-1)} {$region -fold}
                TByteArrInit(
                  Byte((arr_src_ptr2-arr_src_width)^<>background_color),
                  0,
                  Byte((arr_src_ptr2+0000000000001)^<>background_color),
                  0); {$endregion}
              end; {$endregion}

              {Right  Line} {$region -fold}
              begin
                arr_src_ptr2:=Unaligned( arr_src_ptr+pt_arr1[1] );
                arr_dst_ptr :=Unaligned(@arr_dst    [pt_arr2[1]]);
                {Right Line: first pixel       (000000000000000000000)} {$region -fold}
                TByteArrInit(
                  0,
                  Byte((arr_src_ptr2-0000000000001)^<>background_color),
                  0,
                  Byte((arr_src_ptr2+arr_src_width)^<>background_color));
                Inc(arr_src_ptr2,arr_src_width);
                Inc(arr_dst_ptr ,arr_dst_width); {$endregion}
                {Right Line: from top to bottom(1 to rct_dst.height-2)} {$region -fold}
                if (arr_src_height>=3) then
                  for y:=0 to rct_dst.height-3 do
                    begin
                      TByteArrInit(
                        Byte((arr_src_ptr2-arr_src_width)^<>background_color),
                        Byte((arr_src_ptr2-0000000000001)^<>background_color),
                        0,
                        Byte((arr_src_ptr2+arr_src_width)^<>background_color));
                      Inc(arr_src_ptr2,arr_src_width);
                      Inc(arr_dst_ptr ,arr_dst_width);
                    end; {$endregion}
                {Right Line: last  pixel       (     rct_dst.height-1)} {$region -fold}
                TByteArrInit(
                  Byte((arr_src_ptr2-arr_src_width)^<>background_color),
                  Byte((arr_src_ptr2-0000000000001)^<>background_color),
                  0,
                  0); {$endregion}
              end; {$endregion}

              {Top    Line} {$region -fold}
              arr_src_ptr2:=Unaligned( arr_src_ptr+pt_arr1[0] );
              arr_dst_ptr :=Unaligned(@arr_dst    [pt_arr2[0]]);
              begin
                {Top Line: first pixel       (00000000000000000000)} {$region -fold}
                TByteArrInit(
                  0,
                  0,
                  Byte((arr_src_ptr2+0000000000001)^<>background_color),
                  Byte((arr_src_ptr2+arr_src_width)^<>background_color));
                Inc(arr_src_ptr2);
                Inc(arr_dst_ptr ); {$endregion}
                {Top Line: from left to right(1 to rct_dst.width-2)} {$region -fold}
                if (arr_src_width>=3) then
                  for x:=0 to rct_dst.width-3 do
                    begin
                      TByteArrInit(
                        0,
                        Byte((arr_src_ptr2-0000000000001)^<>background_color),
                        Byte((arr_src_ptr2+0000000000001)^<>background_color),
                        Byte((arr_src_ptr2+arr_src_width)^<>background_color));
                      Inc(arr_src_ptr2);
                      Inc(arr_dst_ptr );
                    end; {$endregion}
                {Top Line: last  pixel       (     rct_dst.width-1)} {$region -fold}
                TByteArrInit(
                  0,
                  Byte((arr_src_ptr2-0000000000001)^<>background_color),
                  0,
                  Byte((arr_src_ptr2+arr_src_width)^<>background_color)); {$endregion}
              end; {$endregion}

              {Bottom Line} {$region -fold}
              arr_src_ptr2:=Unaligned( arr_src_ptr+pt_arr1[2] );
              arr_dst_ptr :=Unaligned(@arr_dst    [pt_arr2[2]]);
              begin
                {Bottom Line: first pixel       (00000000000000000000)} {$region -fold}
                TByteArrInit(
                  Byte((arr_src_ptr2-arr_src_width)^<>background_color),
                  0,
                  Byte((arr_src_ptr2+0000000000001)^<>background_color),
                  0);
                Inc(arr_src_ptr2);
                Inc(arr_dst_ptr ); {$endregion}
                {Bottom Line: from left to right(1 to rct_dst.width-2)} {$region -fold}
                if (arr_src_width>=3) then
                  for x:=0 to rct_dst.width-3 do
                    begin
                      TByteArrInit(
                        Byte((arr_src_ptr2-arr_src_width)^<>background_color),
                        Byte((arr_src_ptr2-0000000000001)^<>background_color),
                        Byte((arr_src_ptr2+0000000000001)^<>background_color),
                        0);
                      Inc(arr_src_ptr2);
                      Inc(arr_dst_ptr );
                    end; {$endregion}
                {Bottom Line: last  pixel       (     rct_dst.width-1)} {$region -fold}
                TByteArrInit(
                  Byte((arr_src_ptr2-arr_src_width)^<>background_color),
                  Byte((arr_src_ptr2-0000000000001)^<>background_color),
                  0,
                  0); {$endregion}
              end {$endregion}

            end;
        end; {$endregion}
      {Inner Area---} {$region -fold}
      if (arr_src_width<=2) or (arr_src_height<=2) then
        Exit;
      arr_src_ptr2:=Unaligned( arr_src_ptr+pt_arr1[4] );
      arr_dst_ptr :=Unaligned(@arr_dst    [pt_arr2[4]]);
      for y:=0 to rct_dst.height-3 do
        begin
          for x:=0 to rct_dst.width-3 do
            begin
              TByteArrInit(
                Byte((arr_src_ptr2-arr_src_width)^<>background_color),
                Byte((arr_src_ptr2-0000000000001)^<>background_color),
                Byte((arr_src_ptr2+0000000000001)^<>background_color),
                Byte((arr_src_ptr2+arr_src_width)^<>background_color));
              Inc(arr_src_ptr2);
              Inc(arr_dst_ptr );
            end;
          Inc(arr_src_ptr2,d_width1+2);
          Inc(arr_dst_ptr ,d_width2+2);
        end; {$endregion}
    end {$endregion}
  else {$region -fold}
    begin
      {Fill Borders-} {$region -fold}
      arr_src_ptr2:=Unaligned( arr_src_ptr+pt_arr1[0] );
      arr_dst_ptr :=Unaligned(@arr_dst    [pt_arr2[0]]);
      if (arr_src_width=1) then
        begin
          if (arr_src_height=1) then
            {1 pixel--} {$region -fold}
            begin
              TByteArrInit(
                0,
                0,
                0,
                0);
              Exit;
            end {$endregion}
          else
            {Left Line} {$region -fold}
            begin
              {Left Line: first pixel       (000000000000000000000)} {$region -fold}
              TByteArrInit(
                0,
                0,
                0,
                Byte(((arr_src_ptr2+arr_src_width)^>>24)<>0));
              Inc(arr_src_ptr2,arr_src_width);
              Inc(arr_dst_ptr ,arr_dst_width); {$endregion}
              {Left Line: from top to bottom(1 to rct_dst.height-2)} {$region -fold}
              if (arr_src_height>=3) then
                for y:=0 to rct_dst.height-3 do
                  begin
                    TByteArrInit(
                      Byte(((arr_src_ptr2-arr_src_width)^>>24)<>0),
                      0,
                      0,
                      Byte(((arr_src_ptr2+arr_src_width)^>>24)<>0));
                    Inc(arr_src_ptr2,arr_src_width);
                    Inc(arr_dst_ptr ,arr_dst_width);
                  end; {$endregion}
              {Left Line: last  pixel       (     rct_dst.height-1)} {$region -fold}
              TByteArrInit(
                Byte(((arr_src_ptr2-arr_src_width)^>>24)<>0),
                0,
                0,
                0);
              Exit; {$endregion}
            end; {$endregion}
        end
      else
        begin
          if (arr_src_height=1) then
            {Top   Line} {$region -fold}
            begin
              {Top Line: first pixel       (00000000000000000000)} {$region -fold}
              TByteArrInit(
                0,
                0,
                Byte(((arr_src_ptr2+0000000000001)^>>24)<>0),
                0);
              Inc(arr_src_ptr2);
              Inc(arr_dst_ptr ); {$endregion}
              {Top Line: from left to right(1 to rct_dst.width-2)} {$region -fold}
              if (arr_src_width>=3) then
                for x:=0 to rct_dst.width-3 do
                  begin
                    TByteArrInit(
                      0,
                      Byte(((arr_src_ptr2-0000000000001)^>>24)<>0),
                      Byte(((arr_src_ptr2+0000000000001)^>>24)<>0),
                      0);
                    Inc(arr_src_ptr2);
                    Inc(arr_dst_ptr );
                  end; {$endregion}
              {Top Line: last  pixel       (     rct_dst.width-1)} {$region -fold}
              TByteArrInit(
                0,
                Byte(((arr_src_ptr2-0000000000001)^>>24)<>0),
                0,
                0);
              Exit; {$endregion}
            end {$endregion}
          else
            begin

              {Left   Line} {$region -fold}
              begin
                {Left Line: first pixel       (000000000000000000000)} {$region -fold}
                TByteArrInit(
                  0,
                  0,
                  Byte(((arr_src_ptr2+0000000000001)^>>24)<>0),
                  Byte(((arr_src_ptr2+arr_src_width)^>>24)<>0));
                Inc(arr_src_ptr2,arr_src_width);
                Inc(arr_dst_ptr ,arr_dst_width); {$endregion}
                {Left Line: from top to bottom(1 to rct_dst.height-2)} {$region -fold}
                if (arr_src_height>=3) then
                  for y:=0 to rct_dst.height-3 do
                    begin
                      TByteArrInit(
                        Byte(((arr_src_ptr2-arr_src_width)^>>24)<>0),
                        0,
                        Byte(((arr_src_ptr2+0000000000001)^>>24)<>0),
                        Byte(((arr_src_ptr2+arr_src_width)^>>24)<>0));
                      Inc(arr_src_ptr2,arr_src_width);
                      Inc(arr_dst_ptr ,arr_dst_width);
                    end; {$endregion}
                {Left Line: last  pixel       (     rct_dst.height-1)} {$region -fold}
                TByteArrInit(
                  Byte(((arr_src_ptr2-arr_src_width)^>>24)<>0),
                  0,
                  Byte(((arr_src_ptr2+0000000000001)^>>24)<>0),
                  0); {$endregion}
              end; {$endregion}

              {Right  Line} {$region -fold}
              begin
                arr_src_ptr2:=Unaligned( arr_src_ptr+pt_arr1[1] );
                arr_dst_ptr :=Unaligned(@arr_dst    [pt_arr2[1]]);
                {Right Line: first pixel       (000000000000000000000)} {$region -fold}
                TByteArrInit(
                  0,
                  Byte(((arr_src_ptr2-0000000000001)^>>24)<>0),
                  0,
                  Byte(((arr_src_ptr2+arr_src_width)^>>24)<>0));
                Inc(arr_src_ptr2,arr_src_width);
                Inc(arr_dst_ptr ,arr_dst_width); {$endregion}
                {Right Line: from top to bottom(1 to rct_dst.height-2)} {$region -fold}
                if (arr_src_height>=3) then
                  for y:=0 to rct_dst.height-3 do
                    begin
                      TByteArrInit(
                        Byte(((arr_src_ptr2-arr_src_width)^>>24)<>0),
                        Byte(((arr_src_ptr2-0000000000001)^>>24)<>0),
                        0,
                        Byte(((arr_src_ptr2+arr_src_width)^>>24)<>0));
                      Inc(arr_src_ptr2,arr_src_width);
                      Inc(arr_dst_ptr ,arr_dst_width);
                    end; {$endregion}
                {Right Line: last  pixel       (     rct_dst.height-1)} {$region -fold}
                TByteArrInit(
                  Byte(((arr_src_ptr2-arr_src_width)^>>24)<>0),
                  Byte(((arr_src_ptr2-0000000000001)^>>24)<>0),
                  0,
                  0); {$endregion}
              end; {$endregion}

              {Top    Line} {$region -fold}
              arr_src_ptr2:=Unaligned( arr_src_ptr+pt_arr1[0] );
              arr_dst_ptr :=Unaligned(@arr_dst    [pt_arr2[0]]);
              begin
                {Top Line: first pixel       (00000000000000000000)} {$region -fold}
                TByteArrInit(
                  0,
                  0,
                  Byte(((arr_src_ptr2+0000000000001)^>>24)<>0),
                  Byte(((arr_src_ptr2+arr_src_width)^>>24)<>0));
                Inc(arr_src_ptr2);
                Inc(arr_dst_ptr ); {$endregion}
                {Top Line: from left to right(1 to rct_dst.width-2)} {$region -fold}
                if (arr_src_width>=3) then
                  for x:=0 to rct_dst.width-3 do
                    begin
                      TByteArrInit(
                        0,
                        Byte(((arr_src_ptr2-0000000000001)^>>24)<>0),
                        Byte(((arr_src_ptr2+0000000000001)^>>24)<>0),
                        Byte(((arr_src_ptr2+arr_src_width)^>>24)<>0));
                      Inc(arr_src_ptr2);
                      Inc(arr_dst_ptr );
                    end; {$endregion}
                {Top Line: last  pixel       (     rct_dst.width-1)} {$region -fold}
                TByteArrInit(
                  0,
                  Byte(((arr_src_ptr2-0000000000001)^>>24)<>0),
                  0,
                  Byte(((arr_src_ptr2+arr_src_width)^>>24)<>0)); {$endregion}
              end; {$endregion}

              {Bottom Line} {$region -fold}
              arr_src_ptr2:=Unaligned( arr_src_ptr+pt_arr1[2] );
              arr_dst_ptr :=Unaligned(@arr_dst    [pt_arr2[2]]);
              begin
                {Bottom Line: first pixel       (00000000000000000000)} {$region -fold}
                TByteArrInit(
                  Byte(((arr_src_ptr2-arr_src_width)^>>24)<>0),
                  0,
                  Byte(((arr_src_ptr2+0000000000001)^>>24)<>0),
                  0);
                Inc(arr_src_ptr2);
                Inc(arr_dst_ptr ); {$endregion}
                {Bottom Line: from left to right(1 to rct_dst.width-2)} {$region -fold}
                if (arr_src_width>=3) then
                  for x:=0 to rct_dst.width-3 do
                    begin
                      TByteArrInit(
                        Byte(((arr_src_ptr2-arr_src_width)^>>24)<>0),
                        Byte(((arr_src_ptr2-0000000000001)^>>24)<>0),
                        Byte(((arr_src_ptr2+0000000000001)^>>24)<>0),
                        0);
                      Inc(arr_src_ptr2);
                      Inc(arr_dst_ptr );
                    end; {$endregion}
                {Bottom Line: last  pixel       (     rct_dst.width-1)} {$region -fold}
                TByteArrInit(
                  Byte(((arr_src_ptr2-arr_src_width)^>>24)<>0),
                  Byte(((arr_src_ptr2-0000000000001)^>>24)<>0),
                  0,
                  0); {$endregion}
              end {$endregion}

            end;
        end; {$endregion}
      {Inner Area---} {$region -fold}
      if (arr_src_width<=2) or (arr_src_height<=2) then
        Exit;
      arr_src_ptr2:=Unaligned( arr_src_ptr+pt_arr1[4] );
      arr_dst_ptr :=Unaligned(@arr_dst    [pt_arr2[4]]);
      for y:=0 to rct_dst.height-3 do
        begin
          for x:=0 to rct_dst.width-3 do
            begin
              TByteArrInit(
                Byte(((arr_src_ptr2-arr_src_width)^>>24)<>0),
                Byte(((arr_src_ptr2-0000000000001)^>>24)<>0),
                Byte(((arr_src_ptr2+0000000000001)^>>24)<>0),
                Byte(((arr_src_ptr2+arr_src_width)^>>24)<>0));
              Inc(arr_src_ptr2);
              Inc(arr_dst_ptr );
            end;
          Inc(arr_src_ptr2,d_width1+2);
          Inc(arr_dst_ptr ,d_width2+2);
        end; {$endregion}
    end; {$endregion}
end; {$endregion}
procedure BorderCalc02(const arr_src    :T1Byte1Arr; var arr_dst:T1Byte1Arr;                         const arr_src_width,arr_dst_width:TColor; const rct_dst:TPtRect; var   aa_nz_arr_it_cnt:TColor);                                {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr          : PByte;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
  pix_cnt_btw_pts      : integer;
  p                    : byte=0;
label
  l1;
begin
  pix_cnt_btw_pts      :=0;
  aa_nz_arr_it_cnt     :=0;
  d_width1             :=                                arr_src_width- rct_dst.width;
  d_width2             :=                                arr_dst_width- rct_dst.width;
  arr_src_ptr          :=Unaligned(@arr_src[rct_dst.left+arr_src_width*(rct_dst.top+1)]);
  arr_dst_ptr          :=Unaligned(@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr^<>0) then
            goto l1;
          Inc(arr_src_ptr);
          Inc(arr_dst_ptr);
        end;
      Inc(arr_src_ptr,d_width1);
      Inc(arr_dst_ptr,d_width2);
    end;
  l1:
  arr_dst_ptr^:=3;

  //Inc(pix_cnt_btw_pts);
  while (arr_dst_ptr^<>3) and (p=1) do//repeat
    begin
      {0 0 0
       1 0 0
       0 0 0}
      if ((arr_src_ptr-1)^<>0) and ((arr_dst_ptr-1)^=0) then
        begin
          arr_src_ptr +=arr_src_width-1;
          arr_dst_ptr +=arr_dst_width-1;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {0 0 0
       0 0 0
       1 0 0}
      if ((arr_src_ptr+arr_src_width-1)^<>0) and ((arr_dst_ptr+arr_src_width-1)^=0) then
        begin
          arr_src_ptr +=arr_src_width-1;
          arr_dst_ptr +=arr_dst_width-1;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {0 0 0
       0 0 0
       0 1 0}
      if ((arr_src_ptr+arr_src_width)^<>0) and ((arr_dst_ptr+arr_src_width)^=0) then
        begin
          arr_src_ptr +=arr_src_width;
          arr_dst_ptr +=arr_dst_width;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {0 0 0
       0 0 0
       0 0 1}
      if ((arr_src_ptr+arr_src_width+1)^<>0) and ((arr_dst_ptr+arr_src_width+1)^=0) then
        begin
          arr_src_ptr +=arr_src_width+1;
          arr_dst_ptr +=arr_dst_width+1;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {0 0 0
       0 0 1
       0 0 0}
      if ((arr_src_ptr+1)^<>0) and ((arr_dst_ptr+1)^=0) then
        begin
          arr_src_ptr +=1;
          arr_dst_ptr +=1;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {0 0 1
       0 0 0
       0 0 0}
      if ((arr_src_ptr-arr_src_width+1)^<>0) and ((arr_dst_ptr-arr_src_width+1)^=0) then
        begin
          arr_src_ptr -=arr_src_width+1;
          arr_dst_ptr -=arr_dst_width+1;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {0 1 0
       0 0 0
       0 0 0}
      if ((arr_src_ptr-arr_src_width)^<>0) and ((arr_dst_ptr-arr_src_width)^=0) then
        begin
          arr_src_ptr -=arr_src_width;
          arr_dst_ptr -=arr_dst_width;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end
      else
      {1 0 0
       0 0 0
       0 0 0}
      if ((arr_src_ptr-arr_src_width-1)^<>0) and ((arr_dst_ptr-arr_src_width-1)^=0) then
        begin
          arr_src_ptr -=arr_src_width-1;
          arr_dst_ptr -=arr_dst_width-1;
          arr_dst_ptr^:=1;
          //Inc(pix_cnt_btw_pts);
          //Continue;
        end;
    end;
    //until (arr_dst_ptr^<>3);
end; {$endregion}
//
procedure BorderCalc0 (const arr_src_ptr:PInteger  ; var arr_dst:T1Byte1Arr;                         const arr_src_width,arr_dst_width:TColor; const rct_dst:TPtRect; var   aa_nz_arr_it_cnt:TColor; const background_color:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2         : PInteger;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
begin
  aa_nz_arr_it_cnt:=0;
  d_width1        :=                                    arr_src_width- rct_dst.width   ;
  d_width2        :=                                    arr_dst_width- rct_dst.width   ;
  arr_src_ptr2    :=Unaligned( arr_src_ptr+rct_dst.left+arr_src_width*(rct_dst.top+1) );
  arr_dst_ptr     :=Unaligned(@arr_dst    [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr2^ and NT_BIT_MASK_ALPHA<>Byte(background_color)) then
            begin
              if ((arr_src_ptr2-arr_src_width)^ and NT_BIT_MASK_ALPHA=Byte(background_color)) then
                begin
                  (arr_dst_ptr-arr_dst_width)^:=1;
                  //(arr_src_ptr2-arr_src_width)^:=clRed and NT_BIT_MASK_ALPHA2;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr2+arr_src_width)^ and NT_BIT_MASK_ALPHA=Byte(background_color)) then
                begin
                  (arr_dst_ptr+arr_dst_width)^:=1;
                  //(arr_src_ptr2+arr_src_width)^:=clRed and NT_BIT_MASK_ALPHA2;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr2-1)^ and NT_BIT_MASK_ALPHA=Byte(background_color)) then
                begin
                  (arr_dst_ptr-1)^:=1;
                  //(arr_src_ptr2-1)^:=clRed and NT_BIT_MASK_ALPHA2;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr2+1)^ and NT_BIT_MASK_ALPHA=Byte(background_color)) then
                begin
                  (arr_dst_ptr+1)^:=1;
                  //(arr_src_ptr2+1)^:=clRed and NT_BIT_MASK_ALPHA2;
                  //Inc(aa_nz_arr_it_cnt);
                end;
            end;
          Inc(arr_src_ptr2);
          Inc(arr_dst_ptr );
        end;
      Inc(arr_src_ptr2,d_width1);
      Inc(arr_dst_ptr ,d_width2);
    end;
end; {$endregion}
procedure BorderCalc1 (const arr_src_ptr:PInteger  ; var arr_dst:T1Byte1Arr;                         const arr_src_width,arr_dst_width:TColor; const rct_dst:TPtRect; var   aa_nz_arr_it_cnt:TColor                               ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2         : PInteger;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
begin
  aa_nz_arr_it_cnt     :=0;
  d_width1             :=                                    arr_src_width- rct_dst.width   ;
  d_width2             :=                                    arr_dst_width- rct_dst.width   ;
  arr_src_ptr2         :=Unaligned( arr_src_ptr+rct_dst.left+arr_src_width*(rct_dst.top+1) );
  arr_dst_ptr          :=Unaligned(@arr_dst    [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr2^<>0) then
            begin
              if ((arr_src_ptr2-arr_src_width)^=0) then
                begin
                  (arr_dst_ptr-arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr2+arr_src_width)^=0) then
                begin
                  (arr_dst_ptr+arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr2-1)^=0) then
                begin
                  (arr_dst_ptr-1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr2+1)^=0) then
                begin
                  (arr_dst_ptr+1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
            end;
          Inc(arr_src_ptr2);
          Inc(arr_dst_ptr );
        end;
      Inc(arr_src_ptr2,d_width1);
      Inc(arr_dst_ptr ,d_width2);
    end;
end; {$endregion}
procedure BorderCalc1 (const arr_src    :TColorArr ; var arr_dst:T1Byte1Arr;                         const arr_src_width,arr_dst_width:TColor; const rct_dst:TPtRect; var   aa_nz_arr_it_cnt:TColor                               ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr          : PInteger;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
begin
  aa_nz_arr_it_cnt     :=0;
  d_width1             :=                                arr_src_width- rct_dst.width;
  d_width2             :=                                arr_dst_width- rct_dst.width;
  arr_src_ptr          :=Unaligned(@arr_src[rct_dst.left+arr_src_width*(rct_dst.top+1)]);
  arr_dst_ptr          :=Unaligned(@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr^<>0) then
            begin
              if ((arr_src_ptr-arr_src_width)^=0) then
                begin
                  (arr_dst_ptr-arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr+arr_src_width)^=0) then
                begin
                  (arr_dst_ptr+arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr-1)^=0) then
                begin
                  (arr_dst_ptr-1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr+1)^=0) then
                begin
                  (arr_dst_ptr+1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
            end;
          Inc(arr_src_ptr);
          Inc(arr_dst_ptr);
        end;
      Inc(arr_src_ptr,d_width1);
      Inc(arr_dst_ptr,d_width2);
    end;
end; {$endregion}
procedure BorderCalc1 (const arr_src    :T1Byte1Arr; var arr_dst:T1Byte1Arr;                         const arr_src_width,arr_dst_width:TColor; const rct_dst:TPtRect; var   aa_nz_arr_it_cnt:TColor                               ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr          : PByte;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
begin
  aa_nz_arr_it_cnt     :=0;
  d_width1             :=                                arr_src_width- rct_dst.width;
  d_width2             :=                                arr_dst_width- rct_dst.width;
  arr_src_ptr          :=Unaligned(@arr_src[rct_dst.left+arr_src_width*(rct_dst.top+1)]);
  arr_dst_ptr          :=Unaligned(@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr^<>0) then
            begin
              if ((arr_src_ptr-arr_src_width)^=0) then
                begin
                  (arr_dst_ptr-arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr+arr_src_width)^=0) then
                begin
                  (arr_dst_ptr+arr_dst_width)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr-1)^=0) then
                begin
                  (arr_dst_ptr-1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
              if ((arr_src_ptr+1)^=0) then
                begin
                  (arr_dst_ptr+1)^:=1;
                  //Inc(aa_nz_arr_it_cnt);
                end;
            end;
          Inc(arr_src_ptr);
          Inc(arr_dst_ptr);
        end;
      Inc(arr_src_ptr,d_width1);
      Inc(arr_dst_ptr,d_width2);
    end;
end; {$endregion}
// Mixed: image has circle and other contours:
procedure BorderCalc20(const arr_src_ptr:PInteger  ; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; const arr_src_width,arr_dst_width:TColor; const rct_dst:TPtRect; out   line_cnt:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Circle----------} {$region -fold}
              if //((arr_dst_ptr                 -1)^=0) and ((arr_dst_ptr                 +1)^=0) and
                 ((arr_dst_ptr+arr_dst_width   -1)^=1) and ((arr_dst_ptr+arr_dst_width   +1)^=1) and
                 //((arr_dst_ptr+arr_dst_width<<1-1)^=0) and ((arr_dst_ptr+arr_dst_width<<1+1)^=0) and
                 ((arr_dst_ptr+arr_dst_width<<1  )^=1) then
                begin
                   arr_dst_ptr^                  :=2;
                  (arr_dst_ptr+arr_dst_width -1)^:=2;
                  (arr_dst_ptr+arr_dst_width +1)^:=2;
                  (arr_dst_ptr+arr_dst_width<<1)^:=2;
                  arr_alpha_ptr^.line_kind       :=11;
                  arr_alpha_ptr^.first_pt_x      :=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y      :=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end {$endregion}
              {Fill Horizontal Line-} {$region -fold}
              else
              if ((arr_dst_ptr+1)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr);
                    end;
                  arr_alpha_ptr^.line_shift:=arr_dst_ptr-line_first_pt_ptr;
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=arr_dst_ptr      -arr_dst_left_ptr+d0;
                  line_kind_arr[3]         :=((arr_src_ptr+d1-1)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2  )^<>0);
                  {line_kind=2----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=2;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=0,1,3} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1  -arr_src_width)^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2  -arr_src_width)^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1+arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1  +arr_src_width)^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2  +arr_src_width)^<>0);
                      case line_kind of
                        {line_kind=0} {$region -fold}
                        {can be rolled to line_kind=1}
                        AA_LINE_KIND000,AA_LINE_KIND001,AA_LINE_KIND002,AA_LINE_KIND003,AA_LINE_KIND004,AA_LINE_KIND005,
                        AA_LINE_KIND006,AA_LINE_KIND007,AA_LINE_KIND008,AA_LINE_KIND009,AA_LINE_KIND010,AA_LINE_KIND011,
                        AA_LINE_KIND012,AA_LINE_KIND013,AA_LINE_KIND014,AA_LINE_KIND015,AA_LINE_KIND016,AA_LINE_KIND017,
                        AA_LINE_KIND018:
                          begin
                            arr_alpha_ptr^.line_kind :=0;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=1} {$region -fold}
                        {can be rolled to line_kind=0}
                        AA_LINE_KIND100,AA_LINE_KIND101,AA_LINE_KIND102,AA_LINE_KIND103,AA_LINE_KIND104,AA_LINE_KIND105,
                        AA_LINE_KIND106,AA_LINE_KIND107,AA_LINE_KIND108,AA_LINE_KIND109,AA_LINE_KIND110,AA_LINE_KIND111,
                        AA_LINE_KIND112,AA_LINE_KIND113,AA_LINE_KIND114,AA_LINE_KIND115,AA_LINE_KIND116,AA_LINE_KIND117,
                        AA_LINE_KIND118:
                          begin
                            arr_alpha_ptr^.line_kind :=1;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=3} {$region -fold}
                        AA_LINE_KIND300:
                        if ((arr_src_ptr+d2-arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        AA_LINE_KIND301:
                        if ((arr_src_ptr+d2+arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill Vertical Line---} {$region -fold}
              else
              if ((arr_dst_ptr+arr_dst_width)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr,arr_dst_width);
                    end;
                  arr_alpha_ptr^.line_shift:=Trunc((arr_dst_ptr-line_first_pt_ptr)/arr_dst_width);
                  Dec(arr_dst_ptr,arr_dst_ptr-line_first_pt_ptr);
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=d1+arr_src_width*arr_alpha_ptr^.line_shift;
                  line_kind_arr[3]         :=((arr_src_ptr+d1 -arr_src_width)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2               )^<>0);
                  {line_kind=7----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=7;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=5,6,8} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1+1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1+1              )^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2+1              )^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1-1              )^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2-1              )^<>0);
                      case line_kind of
                        {line_kind=5} {$region -fold}
                        {can be rolled to line_kind=6}
                        AA_LINE_KIND000,AA_LINE_KIND001,AA_LINE_KIND002,AA_LINE_KIND003,AA_LINE_KIND004,AA_LINE_KIND005,
                        AA_LINE_KIND006,AA_LINE_KIND007,AA_LINE_KIND008,AA_LINE_KIND009,AA_LINE_KIND010,AA_LINE_KIND011,
                        AA_LINE_KIND012,AA_LINE_KIND013,AA_LINE_KIND014,AA_LINE_KIND015,AA_LINE_KIND016,AA_LINE_KIND017,
                        AA_LINE_KIND018:
                          begin
                            arr_alpha_ptr^.line_kind :=5;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=6} {$region -fold}
                        {can be rolled to line_kind=5}
                        AA_LINE_KIND100,AA_LINE_KIND101,AA_LINE_KIND102,AA_LINE_KIND103,AA_LINE_KIND104,AA_LINE_KIND105,
                        AA_LINE_KIND106,AA_LINE_KIND107,AA_LINE_KIND108,AA_LINE_KIND109,AA_LINE_KIND110,AA_LINE_KIND111,
                        AA_LINE_KIND112,AA_LINE_KIND113,AA_LINE_KIND114,AA_LINE_KIND115,AA_LINE_KIND116,AA_LINE_KIND117,
                        AA_LINE_KIND118:
                          begin
                            arr_alpha_ptr^.line_kind :=6;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=8} {$region -fold}
                        AA_LINE_KIND300:
                        if ((arr_src_ptr+d2+1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        AA_LINE_KIND301:
                        if ((arr_src_ptr+d2-1-arr_src_width)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill One Pixel-------} {$region -fold}
              else
              if (((arr_dst_ptr-arr_dst_width)^<>1) and ((arr_dst_ptr-1)^<>1)) or
                 (((arr_dst_ptr+arr_dst_width)^<>1) and ((arr_dst_ptr+1)^<>1)) then
                begin
                  arr_dst_ptr^             :=2;
                  arr_alpha_ptr^.line_kind :=10;
                  arr_alpha_ptr^.first_pt_x:=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end; {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
procedure BorderCalc20(const arr_src    :TColorArr ; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; const arr_src_width,arr_dst_width:TColor; const rct_dst:TPtRect; out   line_cnt:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_src_ptr           : PInteger;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_src_ptr     :=Unaligned(@arr_src  [000000000000000000000000000000000000000000]);
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Circle----------} {$region -fold}
              if //((arr_dst_ptr                 -1)^=0) and ((arr_dst_ptr                 +1)^=0) and
                 ((arr_dst_ptr+arr_dst_width   -1)^=1) and ((arr_dst_ptr+arr_dst_width   +1)^=1) and
                 //((arr_dst_ptr+arr_dst_width<<1-1)^=0) and ((arr_dst_ptr+arr_dst_width<<1+1)^=0) and
                 ((arr_dst_ptr+arr_dst_width<<1  )^=1) then
                begin
                   arr_dst_ptr^                  :=2;
                  (arr_dst_ptr+arr_dst_width -1)^:=2;
                  (arr_dst_ptr+arr_dst_width +1)^:=2;
                  (arr_dst_ptr+arr_dst_width<<1)^:=2;
                  arr_alpha_ptr^.line_kind       :=11;
                  arr_alpha_ptr^.first_pt_x      :=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y      :=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end {$endregion}
              {Fill Horizontal Line-} {$region -fold}
              else
              if ((arr_dst_ptr+1)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr);
                    end;
                  arr_alpha_ptr^.line_shift:=arr_dst_ptr-line_first_pt_ptr;
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=arr_dst_ptr      -arr_dst_left_ptr+d0;
                  line_kind_arr[3]         :=((arr_src_ptr+d1-1)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2  )^<>0);
                  {line_kind=2----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=2;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=0,1,3} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1  -arr_src_width)^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2  -arr_src_width)^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1+arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1  +arr_src_width)^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2  +arr_src_width)^<>0);
                      case line_kind of
                        {line_kind=0} {$region -fold}
                        {can be rolled to line_kind=1}
                        AA_LINE_KIND000,AA_LINE_KIND001,AA_LINE_KIND002,AA_LINE_KIND003,AA_LINE_KIND004,AA_LINE_KIND005,
                        AA_LINE_KIND006,AA_LINE_KIND007,AA_LINE_KIND008,AA_LINE_KIND009,AA_LINE_KIND010,AA_LINE_KIND011,
                        AA_LINE_KIND012,AA_LINE_KIND013,AA_LINE_KIND014,AA_LINE_KIND015,AA_LINE_KIND016,AA_LINE_KIND017,
                        AA_LINE_KIND018:
                          begin
                            arr_alpha_ptr^.line_kind :=0;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=1} {$region -fold}
                        {can be rolled to line_kind=0}
                        AA_LINE_KIND100,AA_LINE_KIND101,AA_LINE_KIND102,AA_LINE_KIND103,AA_LINE_KIND104,AA_LINE_KIND105,
                        AA_LINE_KIND106,AA_LINE_KIND107,AA_LINE_KIND108,AA_LINE_KIND109,AA_LINE_KIND110,AA_LINE_KIND111,
                        AA_LINE_KIND112,AA_LINE_KIND113,AA_LINE_KIND114,AA_LINE_KIND115,AA_LINE_KIND116,AA_LINE_KIND117,
                        AA_LINE_KIND118:
                          begin
                            arr_alpha_ptr^.line_kind :=1;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=3} {$region -fold}
                        AA_LINE_KIND300:
                        if ((arr_src_ptr+d2-arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        AA_LINE_KIND301:
                        if ((arr_src_ptr+d2+arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill Vertical Line---} {$region -fold}
              else
              if ((arr_dst_ptr+arr_dst_width)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr,arr_dst_width);
                    end;
                  arr_alpha_ptr^.line_shift:=Trunc((arr_dst_ptr-line_first_pt_ptr)/arr_dst_width);
                  Dec(arr_dst_ptr,arr_dst_ptr-line_first_pt_ptr);
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=d1+arr_src_width*arr_alpha_ptr^.line_shift;
                  line_kind_arr[3]         :=((arr_src_ptr+d1 -arr_src_width)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2               )^<>0);
                  {line_kind=7----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=7;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=5,6,8} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1+1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1+1              )^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2+1              )^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1-1              )^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2-1              )^<>0);
                      case line_kind of
                        {line_kind=5} {$region -fold}
                        {can be rolled to line_kind=6}
                        AA_LINE_KIND000,AA_LINE_KIND001,AA_LINE_KIND002,AA_LINE_KIND003,AA_LINE_KIND004,AA_LINE_KIND005,
                        AA_LINE_KIND006,AA_LINE_KIND007,AA_LINE_KIND008,AA_LINE_KIND009,AA_LINE_KIND010,AA_LINE_KIND011,
                        AA_LINE_KIND012,AA_LINE_KIND013,AA_LINE_KIND014,AA_LINE_KIND015,AA_LINE_KIND016,AA_LINE_KIND017,
                        AA_LINE_KIND018:
                          begin
                            arr_alpha_ptr^.line_kind :=5;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=6} {$region -fold}
                        {can be rolled to line_kind=5}
                        AA_LINE_KIND100,AA_LINE_KIND101,AA_LINE_KIND102,AA_LINE_KIND103,AA_LINE_KIND104,AA_LINE_KIND105,
                        AA_LINE_KIND106,AA_LINE_KIND107,AA_LINE_KIND108,AA_LINE_KIND109,AA_LINE_KIND110,AA_LINE_KIND111,
                        AA_LINE_KIND112,AA_LINE_KIND113,AA_LINE_KIND114,AA_LINE_KIND115,AA_LINE_KIND116,AA_LINE_KIND117,
                        AA_LINE_KIND118:
                          begin
                            arr_alpha_ptr^.line_kind :=6;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=8} {$region -fold}
                        AA_LINE_KIND300:
                        if ((arr_src_ptr+d2+1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        AA_LINE_KIND301:
                        if ((arr_src_ptr+d2-1-arr_src_width)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill One Pixel-------} {$region -fold}
              else
              if (((arr_dst_ptr-arr_dst_width)^<>1) and ((arr_dst_ptr-1)^<>1)) or
                 (((arr_dst_ptr+arr_dst_width)^<>1) and ((arr_dst_ptr+1)^<>1)) then
                begin
                  arr_dst_ptr^             :=2;
                  arr_alpha_ptr^.line_kind :=10;
                  arr_alpha_ptr^.first_pt_x:=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end; {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
procedure BorderCalc20(const arr_src    :T1Byte1Arr; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; const arr_src_width,arr_dst_width:TColor; const rct_dst:TPtRect; out   line_cnt:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_src_ptr           : PByte;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_src_ptr     :=Unaligned(@arr_src  [000000000000000000000000000000000000000000]);
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Circle----------} {$region -fold}
              if //((arr_dst_ptr                 -1)^=0) and ((arr_dst_ptr                 +1)^=0) and
                 ((arr_dst_ptr+arr_dst_width   -1)^=1) and ((arr_dst_ptr+arr_dst_width   +1)^=1) and
                 //((arr_dst_ptr+arr_dst_width<<1-1)^=0) and ((arr_dst_ptr+arr_dst_width<<1+1)^=0) and
                 ((arr_dst_ptr+arr_dst_width<<1  )^=1) then
                begin
                   arr_dst_ptr^                  :=2;
                  (arr_dst_ptr+arr_dst_width -1)^:=2;
                  (arr_dst_ptr+arr_dst_width +1)^:=2;
                  (arr_dst_ptr+arr_dst_width<<1)^:=2;
                  arr_alpha_ptr^.line_kind       :=11;
                  arr_alpha_ptr^.first_pt_x      :=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y      :=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end {$endregion}
              {Fill Horizontal Line-} {$region -fold}
              else
              if ((arr_dst_ptr+1)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr);
                    end;
                  arr_alpha_ptr^.line_shift:=arr_dst_ptr-line_first_pt_ptr;
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=arr_dst_ptr      -arr_dst_left_ptr+d0;
                  line_kind_arr[3]         :=((arr_src_ptr+d1-1)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2  )^<>0);
                  {line_kind=2----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=2;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=0,1,3} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1  -arr_src_width)^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2  -arr_src_width)^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1+arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1  +arr_src_width)^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2  +arr_src_width)^<>0);
                      case line_kind of
                        {line_kind=0} {$region -fold}
                        {can be rolled to line_kind=1}
                        AA_LINE_KIND000,AA_LINE_KIND001,AA_LINE_KIND002,AA_LINE_KIND003,AA_LINE_KIND004,AA_LINE_KIND005,
                        AA_LINE_KIND006,AA_LINE_KIND007,AA_LINE_KIND008,AA_LINE_KIND009,AA_LINE_KIND010,AA_LINE_KIND011,
                        AA_LINE_KIND012,AA_LINE_KIND013,AA_LINE_KIND014,AA_LINE_KIND015,AA_LINE_KIND016,AA_LINE_KIND017,
                        AA_LINE_KIND018:
                          begin
                            arr_alpha_ptr^.line_kind :=0;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=1} {$region -fold}
                        {can be rolled to line_kind=0}
                        AA_LINE_KIND100,AA_LINE_KIND101,AA_LINE_KIND102,AA_LINE_KIND103,AA_LINE_KIND104,AA_LINE_KIND105,
                        AA_LINE_KIND106,AA_LINE_KIND107,AA_LINE_KIND108,AA_LINE_KIND109,AA_LINE_KIND110,AA_LINE_KIND111,
                        AA_LINE_KIND112,AA_LINE_KIND113,AA_LINE_KIND114,AA_LINE_KIND115,AA_LINE_KIND116,AA_LINE_KIND117,
                        AA_LINE_KIND118:
                          begin
                            arr_alpha_ptr^.line_kind :=1;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=3} {$region -fold}
                        AA_LINE_KIND300:
                        if ((arr_src_ptr+d2-arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        AA_LINE_KIND301:
                        if ((arr_src_ptr+d2+arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill Vertical Line---} {$region -fold}
              else
              if ((arr_dst_ptr+arr_dst_width)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr,arr_dst_width);
                    end;
                  arr_alpha_ptr^.line_shift:=Trunc((arr_dst_ptr-line_first_pt_ptr)/arr_dst_width);
                  Dec(arr_dst_ptr,arr_dst_ptr-line_first_pt_ptr);
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=d1+arr_src_width*arr_alpha_ptr^.line_shift;
                  line_kind_arr[3]         :=((arr_src_ptr+d1 -arr_src_width)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2               )^<>0);
                  {line_kind=7----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=7;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=5,6,8} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1+1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1+1              )^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2+1              )^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1-1              )^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2-1              )^<>0);
                      case line_kind of
                        {line_kind=5} {$region -fold}
                        {can be rolled to line_kind=6}
                        AA_LINE_KIND000,AA_LINE_KIND001,AA_LINE_KIND002,AA_LINE_KIND003,AA_LINE_KIND004,AA_LINE_KIND005,
                        AA_LINE_KIND006,AA_LINE_KIND007,AA_LINE_KIND008,AA_LINE_KIND009,AA_LINE_KIND010,AA_LINE_KIND011,
                        AA_LINE_KIND012,AA_LINE_KIND013,AA_LINE_KIND014,AA_LINE_KIND015,AA_LINE_KIND016,AA_LINE_KIND017,
                        AA_LINE_KIND018:
                          begin
                            arr_alpha_ptr^.line_kind :=5;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=6} {$region -fold}
                        {can be rolled to line_kind=5}
                        AA_LINE_KIND100,AA_LINE_KIND101,AA_LINE_KIND102,AA_LINE_KIND103,AA_LINE_KIND104,AA_LINE_KIND105,
                        AA_LINE_KIND106,AA_LINE_KIND107,AA_LINE_KIND108,AA_LINE_KIND109,AA_LINE_KIND110,AA_LINE_KIND111,
                        AA_LINE_KIND112,AA_LINE_KIND113,AA_LINE_KIND114,AA_LINE_KIND115,AA_LINE_KIND116,AA_LINE_KIND117,
                        AA_LINE_KIND118:
                          begin
                            arr_alpha_ptr^.line_kind :=6;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=8} {$region -fold}
                        AA_LINE_KIND300:
                        if ((arr_src_ptr+d2+1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        AA_LINE_KIND301:
                        if ((arr_src_ptr+d2-1-arr_src_width)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill One Pixel-------} {$region -fold}
              else
              if (((arr_dst_ptr-arr_dst_width)^<>1) and ((arr_dst_ptr-1)^<>1)) or
                 (((arr_dst_ptr+arr_dst_width)^<>1) and ((arr_dst_ptr+1)^<>1)) then
                begin
                  arr_dst_ptr^             :=2;
                  arr_alpha_ptr^.line_kind :=10;
                  arr_alpha_ptr^.first_pt_x:=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end; {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
// Image has only circle contours:
procedure BorderCalc21(const arr_src_ptr:PInteger  ; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; const arr_src_width,arr_dst_width:TColor; const rct_dst:TPtRect; out   line_cnt:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Circle----------} {$region -fold}
              if //((arr_dst_ptr                 -1)^=0) and ((arr_dst_ptr                 +1)^=0) and
                 ((arr_dst_ptr+arr_dst_width   -1)^=1) and ((arr_dst_ptr+arr_dst_width   +1)^=1) and
                 //((arr_dst_ptr+arr_dst_width<<1-1)^=0) and ((arr_dst_ptr+arr_dst_width<<1+1)^=0) and
                 ((arr_dst_ptr+arr_dst_width<<1  )^=1) then
                begin
                   arr_dst_ptr^                  :=2;
                  (arr_dst_ptr+arr_dst_width -1)^:=2;
                  (arr_dst_ptr+arr_dst_width +1)^:=2;
                  (arr_dst_ptr+arr_dst_width<<1)^:=2;
                  arr_alpha_ptr^.line_kind       :=11;
                  arr_alpha_ptr^.first_pt_x      :=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y      :=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end; {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
procedure BorderCalc21(const arr_src    :TColorArr ; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; const arr_src_width,arr_dst_width:TColor; const rct_dst:TPtRect; out   line_cnt:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_src_ptr           : PInteger;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_src_ptr     :=Unaligned(@arr_src  [000000000000000000000000000000000000000000]);
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Circle----------} {$region -fold}
              if //((arr_dst_ptr                 -1)^=0) and ((arr_dst_ptr                 +1)^=0) and
                 ((arr_dst_ptr+arr_dst_width   -1)^=1) and ((arr_dst_ptr+arr_dst_width   +1)^=1) and
                 //((arr_dst_ptr+arr_dst_width<<1-1)^=0) and ((arr_dst_ptr+arr_dst_width<<1+1)^=0) and
                 ((arr_dst_ptr+arr_dst_width<<1  )^=1) then
                begin
                   arr_dst_ptr^                  :=2;
                  (arr_dst_ptr+arr_dst_width -1)^:=2;
                  (arr_dst_ptr+arr_dst_width +1)^:=2;
                  (arr_dst_ptr+arr_dst_width<<1)^:=2;
                  arr_alpha_ptr^.line_kind       :=11;
                  arr_alpha_ptr^.first_pt_x      :=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y      :=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
procedure BorderCalc21(const arr_src    :T1Byte1Arr; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; const arr_src_width,arr_dst_width:TColor; const rct_dst:TPtRect; out   line_cnt:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_src_ptr           : PByte;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_src_ptr     :=Unaligned(@arr_src  [000000000000000000000000000000000000000000]);
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Circle----------} {$region -fold}
              if //((arr_dst_ptr                 -1)^=0) and ((arr_dst_ptr                 +1)^=0) and
                 ((arr_dst_ptr+arr_dst_width   -1)^=1) and ((arr_dst_ptr+arr_dst_width   +1)^=1) and
                 //((arr_dst_ptr+arr_dst_width<<1-1)^=0) and ((arr_dst_ptr+arr_dst_width<<1+1)^=0) and
                 ((arr_dst_ptr+arr_dst_width<<1  )^=1) then
                begin
                   arr_dst_ptr^                  :=2;
                  (arr_dst_ptr+arr_dst_width -1)^:=2;
                  (arr_dst_ptr+arr_dst_width +1)^:=2;
                  (arr_dst_ptr+arr_dst_width<<1)^:=2;
                  arr_alpha_ptr^.line_kind       :=11;
                  arr_alpha_ptr^.first_pt_x      :=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y      :=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
// Image has no circle contours:
procedure BorderCalc22(const arr_src_ptr:PInteger  ; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; const arr_src_width,arr_dst_width:TColor; const rct_dst:TPtRect; out   line_cnt:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Horizontal Line-} {$region -fold}
              if ((arr_dst_ptr+1)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr);
                    end;
                  arr_alpha_ptr^.line_shift:=arr_dst_ptr-line_first_pt_ptr;
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=arr_dst_ptr      -arr_dst_left_ptr+d0;
                  line_kind_arr[3]         :=((arr_src_ptr+d1-1)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2  )^<>0);
                  {line_kind=2----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=2;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=0,1,3} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1  -arr_src_width)^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2  -arr_src_width)^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1+arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1  +arr_src_width)^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2  +arr_src_width)^<>0);
                      case line_kind of
                        {line_kind=0} {$region -fold}
                        {can be rolled to line_kind=1}
                        AA_LINE_KIND000,AA_LINE_KIND001,AA_LINE_KIND002,AA_LINE_KIND003,AA_LINE_KIND004,AA_LINE_KIND005,
                        AA_LINE_KIND006,AA_LINE_KIND007,AA_LINE_KIND008,AA_LINE_KIND009,AA_LINE_KIND010,AA_LINE_KIND011,
                        AA_LINE_KIND012,AA_LINE_KIND013,AA_LINE_KIND014,AA_LINE_KIND015,AA_LINE_KIND016,AA_LINE_KIND017,
                        AA_LINE_KIND018:
                          begin
                            arr_alpha_ptr^.line_kind :=0;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=1} {$region -fold}
                        {can be rolled to line_kind=0}
                        AA_LINE_KIND100,AA_LINE_KIND101,AA_LINE_KIND102,AA_LINE_KIND103,AA_LINE_KIND104,AA_LINE_KIND105,
                        AA_LINE_KIND106,AA_LINE_KIND107,AA_LINE_KIND108,AA_LINE_KIND109,AA_LINE_KIND110,AA_LINE_KIND111,
                        AA_LINE_KIND112,AA_LINE_KIND113,AA_LINE_KIND114,AA_LINE_KIND115,AA_LINE_KIND116,AA_LINE_KIND117,
                        AA_LINE_KIND118:
                          begin
                            arr_alpha_ptr^.line_kind :=1;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=3} {$region -fold}
                        AA_LINE_KIND300:
                        if ((arr_src_ptr+d2-arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        AA_LINE_KIND301:
                        if ((arr_src_ptr+d2+arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill Vertical Line---} {$region -fold}
              else
              if ((arr_dst_ptr+arr_dst_width)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr,arr_dst_width);
                    end;
                  arr_alpha_ptr^.line_shift:=Trunc((arr_dst_ptr-line_first_pt_ptr)/arr_dst_width);
                  Dec(arr_dst_ptr,arr_dst_ptr-line_first_pt_ptr);
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=d1+arr_src_width*arr_alpha_ptr^.line_shift;
                  line_kind_arr[3]         :=((arr_src_ptr+d1 -arr_src_width)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2               )^<>0);
                  {line_kind=7----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=7;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=5,6,8} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1+1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1+1              )^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2+1              )^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1-1              )^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2-1              )^<>0);
                      case line_kind of
                        {line_kind=5} {$region -fold}
                        {can be rolled to line_kind=6}
                        AA_LINE_KIND000,AA_LINE_KIND001,AA_LINE_KIND002,AA_LINE_KIND003,AA_LINE_KIND004,AA_LINE_KIND005,
                        AA_LINE_KIND006,AA_LINE_KIND007,AA_LINE_KIND008,AA_LINE_KIND009,AA_LINE_KIND010,AA_LINE_KIND011,
                        AA_LINE_KIND012,AA_LINE_KIND013,AA_LINE_KIND014,AA_LINE_KIND015,AA_LINE_KIND016,AA_LINE_KIND017,
                        AA_LINE_KIND018:
                          begin
                            arr_alpha_ptr^.line_kind :=5;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=6} {$region -fold}
                        {can be rolled to line_kind=5}
                        AA_LINE_KIND100,AA_LINE_KIND101,AA_LINE_KIND102,AA_LINE_KIND103,AA_LINE_KIND104,AA_LINE_KIND105,
                        AA_LINE_KIND106,AA_LINE_KIND107,AA_LINE_KIND108,AA_LINE_KIND109,AA_LINE_KIND110,AA_LINE_KIND111,
                        AA_LINE_KIND112,AA_LINE_KIND113,AA_LINE_KIND114,AA_LINE_KIND115,AA_LINE_KIND116,AA_LINE_KIND117,
                        AA_LINE_KIND118:
                          begin
                            arr_alpha_ptr^.line_kind :=6;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=8} {$region -fold}
                        AA_LINE_KIND300:
                        if ((arr_src_ptr+d2+1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        AA_LINE_KIND301:
                        if ((arr_src_ptr+d2-1-arr_src_width)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill One Pixel-------} {$region -fold}
              else
              if (((arr_dst_ptr-arr_dst_width)^<>1) and ((arr_dst_ptr-1)^<>1)) or
                 (((arr_dst_ptr+arr_dst_width)^<>1) and ((arr_dst_ptr+1)^<>1)) then
                begin
                  arr_dst_ptr^             :=2;
                  arr_alpha_ptr^.line_kind :=10;
                  arr_alpha_ptr^.first_pt_x:=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end; {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
procedure BorderCalc22(const arr_src    :TColorArr ; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; const arr_src_width,arr_dst_width:TColor; const rct_dst:TPtRect; out   line_cnt:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_src_ptr           : PInteger;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_src_ptr     :=Unaligned(@arr_src  [000000000000000000000000000000000000000000]);
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Horizontal Line-} {$region -fold}
              if ((arr_dst_ptr+1)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr);
                    end;
                  arr_alpha_ptr^.line_shift:=arr_dst_ptr-line_first_pt_ptr;
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=arr_dst_ptr      -arr_dst_left_ptr+d0;
                  line_kind_arr[3]         :=((arr_src_ptr+d1-1)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2  )^<>0);
                  {line_kind=2----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=2;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=0,1,3} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1  -arr_src_width)^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2  -arr_src_width)^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1+arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1  +arr_src_width)^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2  +arr_src_width)^<>0);
                      case line_kind of
                        {line_kind=0} {$region -fold}
                        {can be rolled to line_kind=1}
                        AA_LINE_KIND000,AA_LINE_KIND001,AA_LINE_KIND002,AA_LINE_KIND003,AA_LINE_KIND004,AA_LINE_KIND005,
                        AA_LINE_KIND006,AA_LINE_KIND007,AA_LINE_KIND008,AA_LINE_KIND009,AA_LINE_KIND010,AA_LINE_KIND011,
                        AA_LINE_KIND012,AA_LINE_KIND013,AA_LINE_KIND014,AA_LINE_KIND015,AA_LINE_KIND016,AA_LINE_KIND017,
                        AA_LINE_KIND018:
                          begin
                            arr_alpha_ptr^.line_kind :=0;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=1} {$region -fold}
                        {can be rolled to line_kind=0}
                        AA_LINE_KIND100,AA_LINE_KIND101,AA_LINE_KIND102,AA_LINE_KIND103,AA_LINE_KIND104,AA_LINE_KIND105,
                        AA_LINE_KIND106,AA_LINE_KIND107,AA_LINE_KIND108,AA_LINE_KIND109,AA_LINE_KIND110,AA_LINE_KIND111,
                        AA_LINE_KIND112,AA_LINE_KIND113,AA_LINE_KIND114,AA_LINE_KIND115,AA_LINE_KIND116,AA_LINE_KIND117,
                        AA_LINE_KIND118:
                          begin
                            arr_alpha_ptr^.line_kind :=1;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=3} {$region -fold}
                        AA_LINE_KIND300:
                        if ((arr_src_ptr+d2-arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        AA_LINE_KIND301:
                        if ((arr_src_ptr+d2+arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill Vertical Line---} {$region -fold}
              else
              if ((arr_dst_ptr+arr_dst_width)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr,arr_dst_width);
                    end;
                  arr_alpha_ptr^.line_shift:=Trunc((arr_dst_ptr-line_first_pt_ptr)/arr_dst_width);
                  Dec(arr_dst_ptr,arr_dst_ptr-line_first_pt_ptr);
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=d1+arr_src_width*arr_alpha_ptr^.line_shift;
                  line_kind_arr[3]         :=((arr_src_ptr+d1 -arr_src_width)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2               )^<>0);
                  {line_kind=7----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=7;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=5,6,8} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1+1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1+1              )^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2+1              )^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1-1              )^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2-1              )^<>0);
                      case line_kind of
                        {line_kind=5} {$region -fold}
                        {can be rolled to line_kind=6}
                        AA_LINE_KIND000,AA_LINE_KIND001,AA_LINE_KIND002,AA_LINE_KIND003,AA_LINE_KIND004,AA_LINE_KIND005,
                        AA_LINE_KIND006,AA_LINE_KIND007,AA_LINE_KIND008,AA_LINE_KIND009,AA_LINE_KIND010,AA_LINE_KIND011,
                        AA_LINE_KIND012,AA_LINE_KIND013,AA_LINE_KIND014,AA_LINE_KIND015,AA_LINE_KIND016,AA_LINE_KIND017,
                        AA_LINE_KIND018:
                          begin
                            arr_alpha_ptr^.line_kind :=5;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=6} {$region -fold}
                        {can be rolled to line_kind=5}
                        AA_LINE_KIND100,AA_LINE_KIND101,AA_LINE_KIND102,AA_LINE_KIND103,AA_LINE_KIND104,AA_LINE_KIND105,
                        AA_LINE_KIND106,AA_LINE_KIND107,AA_LINE_KIND108,AA_LINE_KIND109,AA_LINE_KIND110,AA_LINE_KIND111,
                        AA_LINE_KIND112,AA_LINE_KIND113,AA_LINE_KIND114,AA_LINE_KIND115,AA_LINE_KIND116,AA_LINE_KIND117,
                        AA_LINE_KIND118:
                          begin
                            arr_alpha_ptr^.line_kind :=6;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=8} {$region -fold}
                        AA_LINE_KIND300:
                        if ((arr_src_ptr+d2+1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        AA_LINE_KIND301:
                        if ((arr_src_ptr+d2-1-arr_src_width)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill One Pixel-------} {$region -fold}
              else
              if (((arr_dst_ptr-arr_dst_width)^<>1) and ((arr_dst_ptr-1)^<>1)) or
                 (((arr_dst_ptr+arr_dst_width)^<>1) and ((arr_dst_ptr+1)^<>1)) then
                begin
                  arr_dst_ptr^             :=2;
                  arr_alpha_ptr^.line_kind :=10;
                  arr_alpha_ptr^.first_pt_x:=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end; {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
procedure BorderCalc22(const arr_src    :T1Byte1Arr; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; const arr_src_width,arr_dst_width:TColor; const rct_dst:TPtRect; out   line_cnt:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_kind_arr         : array[0..7] of boolean;
  line_kind             : qword absolute line_kind_arr;
  arr_alpha_ptr         : PFastAALine;
  arr_src_ptr           : PByte;
  arr_dst_ptr           : PByte;
  arr_dst_left_ptr      : PByte;
  arr_dst_rect_right_ptr: PByte;
  line_first_pt_ptr     : PByte;
  y_,i,d0,d1,d2         : integer;
begin
  {Fill Borders} {$region -fold}
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*rct_dst.top];
  //Top Line
  FillByte(arr_dst_ptr^,rct_dst.width,0);
  // Left Line
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  // Right Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+rct_dst.width-1+arr_dst_width*rct_dst.top];
  for i:=0 to rct_dst.height-1 do
    begin
      arr_dst_ptr^:=0;
      Inc(arr_dst_ptr,arr_dst_width);
    end;
  //Bottom Line
  arr_dst_ptr:=@arr_dst[rct_dst.left+arr_dst_width*(rct_dst.top+rct_dst.height-1)];
  FillByte(arr_dst_ptr^,rct_dst.width,0); {$endregion}
  arr_src_ptr     :=Unaligned(@arr_src  [000000000000000000000000000000000000000000]);
  arr_dst_ptr     :=Unaligned(@arr_dst  [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  arr_alpha_ptr   :=Unaligned(@arr_alpha[000000000000000000000000000000000000000000]);
  arr_dst_left_ptr:=Unaligned(@arr_dst  [arr_dst_width*rct_dst.top                 ]);
  d0              :=                     arr_src_width*rct_dst.top;
  for y_:=0 to rct_dst.height-2 do
    begin
      arr_dst_rect_right_ptr:=arr_dst_left_ptr+rct_dst.left+rct_dst.width-1;
      repeat
        begin
          if (arr_dst_ptr^=1) then
            begin
              {Fill Horizontal Line-} {$region -fold}
              if ((arr_dst_ptr+1)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr);
                    end;
                  arr_alpha_ptr^.line_shift:=arr_dst_ptr-line_first_pt_ptr;
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=arr_dst_ptr      -arr_dst_left_ptr+d0;
                  line_kind_arr[3]         :=((arr_src_ptr+d1-1)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2  )^<>0);
                  {line_kind=2----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=2;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=0,1,3} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1  -arr_src_width)^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2  -arr_src_width)^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1+arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1  +arr_src_width)^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2  +arr_src_width)^<>0);
                      case line_kind of
                        {line_kind=0} {$region -fold}
                        {can be rolled to line_kind=1}
                        AA_LINE_KIND000,AA_LINE_KIND001,AA_LINE_KIND002,AA_LINE_KIND003,AA_LINE_KIND004,AA_LINE_KIND005,
                        AA_LINE_KIND006,AA_LINE_KIND007,AA_LINE_KIND008,AA_LINE_KIND009,AA_LINE_KIND010,AA_LINE_KIND011,
                        AA_LINE_KIND012,AA_LINE_KIND013,AA_LINE_KIND014,AA_LINE_KIND015,AA_LINE_KIND016,AA_LINE_KIND017,
                        AA_LINE_KIND018:
                          begin
                            arr_alpha_ptr^.line_kind :=0;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=1} {$region -fold}
                        AA_LINE_KIND100,AA_LINE_KIND101,AA_LINE_KIND102,AA_LINE_KIND103,AA_LINE_KIND104,AA_LINE_KIND105,
                        AA_LINE_KIND106,AA_LINE_KIND107,AA_LINE_KIND108,AA_LINE_KIND109,AA_LINE_KIND110,AA_LINE_KIND111,
                        AA_LINE_KIND112,AA_LINE_KIND113,AA_LINE_KIND114,AA_LINE_KIND115,AA_LINE_KIND116,AA_LINE_KIND117,
                        AA_LINE_KIND118:
                          begin
                            arr_alpha_ptr^.line_kind :=1;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=3} {$region -fold}
                        AA_LINE_KIND300:
                        if ((arr_src_ptr+d2-arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        AA_LINE_KIND301:
                        if ((arr_src_ptr+d2+arr_src_width-1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=3;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill Vertical Line---} {$region -fold}
              else
              if ((arr_dst_ptr+arr_dst_width)^=1) then
                begin
                  line_first_pt_ptr:=arr_dst_ptr;
                  while (arr_dst_ptr^=1) do
                    begin
                      arr_dst_ptr^:=2;
                      Inc(arr_dst_ptr,arr_dst_width);
                    end;
                  arr_alpha_ptr^.line_shift:=Trunc((arr_dst_ptr-line_first_pt_ptr)/arr_dst_width);
                  Dec(arr_dst_ptr,arr_dst_ptr-line_first_pt_ptr);
                  d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                  d2                       :=d1+arr_src_width*arr_alpha_ptr^.line_shift;
                  line_kind_arr[3]         :=((arr_src_ptr+d1 -arr_src_width)^<>0);
                  line_kind_arr[4]         :=((arr_src_ptr+d2               )^<>0);
                  {line_kind=7----} {$region -fold}
                  if (line_kind_arr[3] and line_kind_arr[4]) then
                    begin
                      arr_alpha_ptr^.line_kind :=7;
                      arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                      arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                      Inc(arr_alpha_ptr);
                    end {$endregion}
                  else
                  {line_kind=5,6,8} {$region -fold}
                    begin
                      line_kind_arr[0]:=((arr_src_ptr+d1+1-arr_src_width)^<>0);
                      line_kind_arr[1]:=((arr_src_ptr+d1+1              )^<>0);
                      line_kind_arr[2]:=((arr_src_ptr+d2+1              )^<>0);
                      line_kind_arr[5]:=((arr_src_ptr+d1-1-arr_src_width)^<>0);
                      line_kind_arr[6]:=((arr_src_ptr+d1-1              )^<>0);
                      line_kind_arr[7]:=((arr_src_ptr+d2-1              )^<>0);
                      case line_kind of
                        {line_kind=5} {$region -fold}
                        {can be rolled to line_kind=6}
                        AA_LINE_KIND000,AA_LINE_KIND001,AA_LINE_KIND002,AA_LINE_KIND003,AA_LINE_KIND004,AA_LINE_KIND005,
                        AA_LINE_KIND006,AA_LINE_KIND007,AA_LINE_KIND008,AA_LINE_KIND009,AA_LINE_KIND010,AA_LINE_KIND011,
                        AA_LINE_KIND012,AA_LINE_KIND013,AA_LINE_KIND014,AA_LINE_KIND015,AA_LINE_KIND016,AA_LINE_KIND017,
                        AA_LINE_KIND018:
                          begin
                            arr_alpha_ptr^.line_kind :=5;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=6} {$region -fold}
                        {can be rolled to line_kind=5}
                        AA_LINE_KIND100,AA_LINE_KIND101,AA_LINE_KIND102,AA_LINE_KIND103,AA_LINE_KIND104,AA_LINE_KIND105,
                        AA_LINE_KIND106,AA_LINE_KIND107,AA_LINE_KIND108,AA_LINE_KIND109,AA_LINE_KIND110,AA_LINE_KIND111,
                        AA_LINE_KIND112,AA_LINE_KIND113,AA_LINE_KIND114,AA_LINE_KIND115,AA_LINE_KIND116,AA_LINE_KIND117,
                        AA_LINE_KIND118:
                          begin
                            arr_alpha_ptr^.line_kind :=6;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                        {line_kind=8} {$region -fold}
                        AA_LINE_KIND300:
                        if ((arr_src_ptr+d2+1)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end;
                        AA_LINE_KIND301:
                        if ((arr_src_ptr+d2-1-arr_src_width)^<>0) then
                          begin
                            arr_alpha_ptr^.line_kind :=8;
                            arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                            arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                            Inc(arr_alpha_ptr);
                          end; {$endregion}
                      end;
                    end; {$endregion}
                end {$endregion}
              {Fill One Pixel-------} {$region -fold}
              else
              if (((arr_dst_ptr-arr_dst_width)^<>1) and ((arr_dst_ptr-1)^<>1)) or
                 (((arr_dst_ptr+arr_dst_width)^<>1) and ((arr_dst_ptr+1)^<>1)) then
                begin
                  arr_dst_ptr^             :=2;
                  arr_alpha_ptr^.line_kind :=10;
                  arr_alpha_ptr^.first_pt_x:=arr_dst_ptr-arr_dst_left_ptr;
                  arr_alpha_ptr^.first_pt_y:=rct_dst.top+y_;
                  Inc(arr_alpha_ptr);
                end; {$endregion}
            end;
          Inc(arr_dst_ptr);
        end;
      until (arr_dst_ptr>arr_dst_rect_right_ptr);
      Inc(arr_dst_ptr);
      Inc(arr_dst_left_ptr,arr_dst_width);
      Inc(d0              ,arr_src_width);
    end;
  line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
end; {$endregion}
//
procedure BorderFill  (const arr_src    :TAALnArr; const rct_dst_left,rct_dst_top:integer; const bmp_ptr:PInteger; const bmp_width:TColor;                            const line_cnt:TColor; const col:TColor; args:TFunc0Args; Func0:TFunc0); {$region -fold}
var
  arr_src_ptr : PFastAALine;
  pixel_ptr   : Pinteger;
  i,j         : integer;
  alpha_shift3: integer;
  alpha_shift2: integer;
  alpha_shift1: byte;
    alpha1    : byte;
  d_alpha1    : byte;
    alpha2    : byte;
  d_alpha2    : byte;
begin
  if (line_cnt=0) then
    Exit;
  with args do
    begin
      r           :=TRGBA(col).r;
      g           :=TRGBA(col).g;
      b           :=TRGBA(col).b;
      alpha1      :=alpha;
      d_alpha1    :=MAXBYTE-alpha1;
      alpha_shift1:=MAXBYTE-alpha;
      arr_src_ptr :=Unaligned(@arr_src[0]);
      for i:=0 to line_cnt-1 do
        begin
          pixel_ptr:=Unaligned(bmp_ptr+arr_src_ptr^.first_pt_x+rct_dst_left+bmp_width*(arr_src_ptr^.first_pt_y+rct_dst_top));
          case arr_src_ptr^.line_kind of
            00{00 - horizontal line: 2 points from left to right---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=alpha1+j*alpha_shift3;
                    d_alpha2  :=MAXBYTE-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clFuchsia);
                    Func0(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                    Inc  (alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            01{01 - horizontal line: 2 points from right to left---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=MAXBYTE-alpha_shift3-j*alpha_shift3;
                    d_alpha2  :=MAXBYTE-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clBlue);
                    Func0(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                    Dec  (alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            02{02 - horizontal line: outer line from ends to middle}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift>>1;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=alpha1+j*alpha_shift3;
                    d_alpha2  :=MAXBYTE-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func0(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                    Inc  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                    alpha2    :=MAXBYTE-alpha_shift3;
                    d_alpha2  :=        alpha_shift3;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func0(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                  end;
                alpha2:=MAXBYTE-alpha_shift3;
                for j:=0 to     alpha_shift2-1 do
                  begin
                  //alpha2    :=MAXBYTE-j*alpha_shift3;
                    d_alpha2  :=MAXBYTE-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func0(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                    Dec  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=
                  //SetColorInv({clGreen}clPurple);
                  Func0(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
              end; {$endregion}
            03{03 - horizontal line: inner line from middle to ends}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift>>1;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=MAXBYTE-j*alpha_shift3;
                    d_alpha2  :=MAXBYTE-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clWhite);
                    Func0(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                    Dec  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                    alpha2    :=MAXBYTE+alpha_shift3;
                    d_alpha2  :=       -alpha_shift3;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func0(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                  end;
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=alpha1+j*alpha_shift3;
                    d_alpha2  :=MAXBYTE-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clWhite);
                    Func0(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr);
                    Inc  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=
                  //SetColorInv({clGreen}clWhite);
                  Func0(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
              end; {$endregion}
            04{04 - horizontal line: const fill--------------------}: {$region -fold}
              begin

              end; {$endregion}
            05{05 - vertical   line: 2 points from top to bottom---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=alpha1+j*alpha_shift3;
                    d_alpha2  :=MAXBYTE-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clFuchsia);
                    Func0(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                    Inc  (alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            06{06 - vertical   line: 2 points from bottom to top---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                  //alpha2    :=MAXBYTE-alpha_shift3-j*alpha_shift3;
                    d_alpha2  :=MAXBYTE-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clBlue);
                    Func0(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                    Dec  (alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            07{07 - vertical   line: inner line from ends to middle}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift>>1;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                    //alpha2    :=alpha1+j*alpha_shift3;
                    d_alpha2  :=MAXBYTE-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func0(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                    Inc  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                    alpha2    :=MAXBYTE-alpha_shift3;
                    d_alpha2  :=        alpha_shift3;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func0(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                  end;
                alpha2:=MAXBYTE-alpha_shift3;
                for j:=0 to     alpha_shift2-1 do
                  begin
                    //alpha2  :=MAXBYTE-j*alpha_shift3;
                    d_alpha2  :=MAXBYTE-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func0(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                    Dec  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=
                  //SetColorInv({clGreen}clPurple);
                  Func0(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
              end; {$endregion}
            08{08 - vertical   line: outer line from middle to ends}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift>>1;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                    //alpha2  :=MAXBYTE-j*alpha_shift3;
                    d_alpha2  :=MAXBYTE-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clWhite);
                    Func0(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                    Dec  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                    alpha2    :=MAXBYTE+alpha_shift3;
                    d_alpha2  :=       -alpha_shift3;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clPurple);
                    Func0(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                  end;
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                    //alpha2  :=alpha1+j*alpha_shift3;
                    d_alpha2  :=MAXBYTE-alpha2;
                    pixel_ptr^:=
                    //SetColorInv({clGreen}clWhite);
                    Func0(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
                    Inc  (pixel_ptr,bmp_width);
                    Inc  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=
                  //SetColorInv({clGreen}clWhite);
                  Func0(pixel_ptr^,r,g,b,d_alpha2,alpha2,alpha2,pow,d);
              end; {$endregion}
            09{09 - vertical   line: const fill--------------------}: {$region -fold}
              begin

              end; {$endregion}
            10{10 - 1 point----------------------------------------}: {$region -fold}
              begin
                pixel_ptr^:=
                //SetColorInv(clRed);
                Func0(pixel_ptr^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
              end; {$endregion}
            11{11 - circle-----------------------------------------}: {$region -fold}
              begin
                (pixel_ptr               )^:=Func0((pixel_ptr               )^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
                (pixel_ptr+bmp_width   -1)^:=Func0((pixel_ptr+bmp_width   -1)^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
                (pixel_ptr+bmp_width   +1)^:=Func0((pixel_ptr+bmp_width   +1)^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
                (pixel_ptr+bmp_width<<1+0)^:=Func0((pixel_ptr+bmp_width<<1+0)^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
                (pixel_ptr             -1)^:=Func0((pixel_ptr             -1)^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
                (pixel_ptr             +1)^:=Func0((pixel_ptr             +1)^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
                (pixel_ptr+bmp_width<<1-1)^:=Func0((pixel_ptr+bmp_width<<1-1)^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
                (pixel_ptr+bmp_width<<1+1)^:=Func0((pixel_ptr+bmp_width<<1+1)^,r,g,b,d_alpha1,alpha1,alpha1,pow,d);
              end; {$endregion}
          end;
          Inc(arr_src_ptr);
        end;
    end;
end; {$endregion}
procedure BorderFill  (const arr_src    :TAALnArr; const rct_dst_left,rct_dst_top:integer; const bmp_ptr:PInteger; const bmp_width:TColor;                            const line_cnt:TColor; const col:TColor; args:TFunc0Args              ); {$region -fold}
var
  arr_src_ptr : PFastAALine;
  pixel_ptr   : Pinteger;
  i,j         : integer;
  alpha_shift3: integer;
  alpha_shift2: integer;
  alpha_shift1: byte;
    alpha1    : byte;
  d_alpha1    : byte;
    alpha2    : byte;
  d_alpha3    : TColor;
  d_alpha4    : TColor;
begin
  if (line_cnt=0) then
    Exit;
  with args do
    begin
      alpha1      :=0000000+alpha;
      d_alpha1    :=MAXBYTE-alpha;
      d_alpha3    :=d_alpha1<<24;
      d_alpha4    :=Max2(d_alpha1-150,0)<<24;
      alpha_shift1:=d_alpha1;
      arr_src_ptr :=Unaligned(@arr_src[0]);
      for i:=0 to line_cnt-1 do
        begin
          pixel_ptr:=Unaligned(bmp_ptr+arr_src_ptr^.first_pt_x+rct_dst_left+bmp_width*(arr_src_ptr^.first_pt_y+rct_dst_top));
          case arr_src_ptr^.line_kind of
            00{00 - horizontal line: 2 points from left to right---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(MAXBYTE-alpha2)<<24;
                    Inc(pixel_ptr);
                    Inc(alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            01{01 - horizontal line: 2 points from right to left---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(MAXBYTE-alpha2)<<24;
                    Inc(pixel_ptr);
                    Dec(alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            02{02 - horizontal line: outer line from ends to middle}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift>>1;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(MAXBYTE-alpha2)<<24;
                    Inc(pixel_ptr);
                    Inc(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                        pixel_ptr^:=alpha_shift3<<24;
                    Inc(pixel_ptr);
                  end;
                alpha2:=MAXBYTE-alpha_shift3;
                for j:=0 to     alpha_shift2-1 do
                  begin
                    pixel_ptr^:=(MAXBYTE-alpha2)<<24;
                    Inc  (pixel_ptr);
                    Dec  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=alpha_shift3<<24;
              end; {$endregion}
            03{03 - horizontal line: inner line from middle to ends}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift>>1;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(MAXBYTE-alpha2)<<24;
                    Inc(pixel_ptr);
                    Dec(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                        pixel_ptr^:=(-alpha_shift3)<<24;
                    Inc(pixel_ptr);
                  end;
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(MAXBYTE-alpha2)<<24;
                    Inc(pixel_ptr);
                    Inc(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=(MAXBYTE-alpha2)<<24;
              end; {$endregion}
            04{04 - horizontal line: const fill--------------------}: {$region -fold}
              begin

              end; {$endregion}
            05{05 - vertical   line: 2 points from top to bottom---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(MAXBYTE-alpha2)<<24;
                    Inc(pixel_ptr,bmp_width);
                    Inc(alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            06{06 - vertical   line: 2 points from bottom to top---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(MAXBYTE-alpha2)<<24;
                    Inc(pixel_ptr,bmp_width);
                    Dec(alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            07{07 - vertical   line: inner line from ends to middle}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift>>1;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(MAXBYTE-alpha2)<<24;
                    Inc(pixel_ptr,bmp_width);
                    Inc(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                    pixel_ptr^:=alpha_shift3<<24;
                    Inc(pixel_ptr,bmp_width);
                  end;
                alpha2:=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(MAXBYTE-alpha2)<<24;
                    Inc(pixel_ptr,bmp_width);
                    Dec(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=(MAXBYTE-alpha2)<<24;
              end; {$endregion}
            08{08 - vertical   line: outer line from middle to ends}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift>>1;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(MAXBYTE-alpha2)<<24;
                    Inc(pixel_ptr,bmp_width);
                    Dec(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                        pixel_ptr^:=(-alpha_shift3)<<24;
                    Inc(pixel_ptr,bmp_width);
                  end;
                alpha2:=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=(MAXBYTE-alpha2)<<24;
                    Inc(pixel_ptr,bmp_width);
                    Inc(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=(MAXBYTE-alpha2)<<24;
              end; {$endregion}
            09{09 - vertical   line: const fill--------------------}: {$region -fold}
              begin

              end; {$endregion}
            10{10 - 1 point----------------------------------------}: {$region -fold}
              pixel_ptr^:=d_alpha1<<24; {$endregion}
            11{11 - circle-----------------------------------------}: {$region -fold}
              begin
                (pixel_ptr               )^:=d_alpha3;
                (pixel_ptr+bmp_width   -1)^:=d_alpha3;
                (pixel_ptr+bmp_width   +1)^:=d_alpha3;
                (pixel_ptr+bmp_width<<1+0)^:=d_alpha3;
                (pixel_ptr             -1)^:=d_alpha4;
                (pixel_ptr             +1)^:=d_alpha4;
                (pixel_ptr+bmp_width<<1-1)^:=d_alpha4;
                (pixel_ptr+bmp_width<<1+1)^:=d_alpha4;
              end; {$endregion}
          end;
          Inc(arr_src_ptr);
        end;
    end;
end; {$endregion}
procedure BorderFill  (const arr_src    :TAALnArr; const rct_dst_left,rct_dst_top:integer; const bmp_ptr:PByte   ; const bmp_width:TColor;                            const line_cnt:TColor; const col:TColor; args:TFunc0Args              ); {$region -fold}
var
  arr_src_ptr : PFastAALine;
  pixel_ptr   : PByte;
  i,j         : integer;
  alpha_shift3: integer;
  alpha_shift2: integer;
  alpha_shift1: byte;
    alpha1    : byte;
  d_alpha1    : byte;
    alpha2    : byte;
//d_alpha3    : byte;
  d_alpha4    : byte;
begin
  if (line_cnt=0) then
    Exit;
  with args do
    begin
      alpha1      :=0000000+alpha;
      d_alpha1    :=MAXBYTE-alpha;
      d_alpha4    :=Max2(d_alpha1-150,0);
      alpha_shift1:=d_alpha1;
      arr_src_ptr :=Unaligned(@arr_src[0]);
      for i:=0 to line_cnt-1 do
        begin
          pixel_ptr:=Unaligned(bmp_ptr+arr_src_ptr^.first_pt_x+rct_dst_left+bmp_width*(arr_src_ptr^.first_pt_y+rct_dst_top));
          case arr_src_ptr^.line_kind of
            00{00 - horizontal line: 2 points from left to right---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=MAXBYTE-alpha2;
                    Inc(pixel_ptr);
                    Inc(alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            01{01 - horizontal line: 2 points from right to left---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=MAXBYTE-alpha2;
                    Inc(pixel_ptr);
                    Dec(alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            02{02 - horizontal line: outer line from ends to middle}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift>>1;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=MAXBYTE-alpha2;
                    Inc(pixel_ptr);
                    Inc(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                        pixel_ptr^:=alpha_shift3;
                    Inc(pixel_ptr);
                  end;
                alpha2:=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                    pixel_ptr^:=MAXBYTE-alpha2;
                    Inc  (pixel_ptr);
                    Dec  (alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=alpha_shift3;
              end; {$endregion}
            03{03 - horizontal line: inner line from middle to ends}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift>>1;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=MAXBYTE-alpha2;
                    Inc(pixel_ptr);
                    Dec(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                        pixel_ptr^:=-alpha_shift3;
                    Inc(pixel_ptr);
                  end;
                alpha2:=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=MAXBYTE-alpha2;
                    Inc(pixel_ptr);
                    Inc(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=MAXBYTE-alpha2;
              end; {$endregion}
            04{04 - horizontal line: const fill--------------------}: {$region -fold}
              begin

              end; {$endregion}
            05{05 - vertical   line: 2 points from top to bottom---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=MAXBYTE-alpha2;
                    Inc(pixel_ptr,bmp_width);
                    Inc(alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            06{06 - vertical   line: 2 points from bottom to top---}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=MAXBYTE-alpha2;
                    Inc(pixel_ptr,bmp_width);
                    Dec(alpha2,alpha_shift3);
                  end;
              end; {$endregion}
            07{07 - vertical   line: inner line from ends to middle}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift>>1;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=MAXBYTE-alpha2;
                    Inc(pixel_ptr,bmp_width);
                    Inc(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                    pixel_ptr^:=alpha_shift3;
                    Inc(pixel_ptr,bmp_width);
                  end;
                alpha2:=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=MAXBYTE-alpha2;
                    Inc(pixel_ptr,bmp_width);
                    Dec(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=MAXBYTE-alpha2;
              end; {$endregion}
            08{08 - vertical   line: outer line from middle to ends}: {$region -fold}
              begin
                alpha_shift2:=arr_src_ptr^.line_shift>>1;
                alpha_shift3:=Trunc(alpha_shift1/alpha_shift2);
                alpha2      :=MAXBYTE-alpha_shift3;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=MAXBYTE-alpha2;
                    Inc(pixel_ptr,bmp_width);
                    Dec(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  begin
                        pixel_ptr^:=-alpha_shift3;
                    Inc(pixel_ptr,bmp_width);
                  end;
                alpha2:=alpha1;
                for j:=0 to alpha_shift2-1 do
                  begin
                        pixel_ptr^:=MAXBYTE-alpha2;
                    Inc(pixel_ptr,bmp_width);
                    Inc(alpha2,alpha_shift3);
                  end;
                if Odd(arr_src_ptr^.line_shift) then
                  pixel_ptr^:=MAXBYTE-alpha2;
              end; {$endregion}
            09{09 - vertical   line: const fill--------------------}: {$region -fold}
              begin

              end; {$endregion}
            10{10 - 1 point----------------------------------------}: {$region -fold}
              pixel_ptr^:=d_alpha1; {$endregion}
            11{11 - circle-----------------------------------------}: {$region -fold}
              begin
                (pixel_ptr               )^:=d_alpha1;
                (pixel_ptr+bmp_width   -1)^:=d_alpha1;
                (pixel_ptr+bmp_width   +1)^:=d_alpha1;
                (pixel_ptr+bmp_width<<1+0)^:=d_alpha1;
                (pixel_ptr             -1)^:=d_alpha4;
                (pixel_ptr             +1)^:=d_alpha4;
                (pixel_ptr+bmp_width<<1-1)^:=d_alpha4;
                (pixel_ptr+bmp_width<<1+1)^:=d_alpha4;
              end; {$endregion}
          end;
          Inc(arr_src_ptr);
        end;
    end;
end; {$endregion}
// One-pixel border-blur calculation:
procedure BorderPixCh (arr_src_ptr:PInteger; const arr_src_width:TColor; const background_color:TColor                       ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2    : PInteger;
  r               : TColor=0;
  g               : TColor=0;
  b               : TColor=0;
  non_zero_pix_cnt: byte  =0;

  procedure RGBCalc0; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    r+=TRGBA(arr_src_ptr2^).r;
    g+=TRGBA(arr_src_ptr2^).g;
    b+=TRGBA(arr_src_ptr2^).b;
    Inc(non_zero_pix_cnt);
  end; {$endregion}

  procedure RGBCalc1; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    if (arr_src_ptr2^<>background_color) then
      RGBCalc0;
    Inc(arr_src_ptr2);
    if (arr_src_ptr2^<>background_color) then
      RGBCalc0;
    Inc(arr_src_ptr2);
    if (arr_src_ptr2^<>background_color) then
      RGBCalc0;
  end; {$endregion}

begin
  // pixel-border scheme:
  // 012
  // 345
  // 678
  // 4 - arr_src_ptr;
  // 0,1,2,3,5,6,7,8 - pixel-border;
  arr_src_ptr2:=arr_src_ptr-arr_src_width-1;
  RGBCalc1;
  Inc(arr_src_ptr2,arr_src_width-2);
  RGBCalc1;
  Inc(arr_src_ptr2,arr_src_width-2);
  RGBCalc1;
  arr_src_ptr^:={clRed}RGB(Trunc(r/non_zero_pix_cnt),
                           Trunc(g/non_zero_pix_cnt),
                           Trunc(b/non_zero_pix_cnt));
end; {$endregion}
procedure BorderPixCh (arr_src_ptr:PInteger; const arr_src_width:TColor; const alpha_color     :byte                         ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2    : PInteger;
  r               : TColor=0;
  g               : TColor=0;
  b               : TColor=0;
  non_zero_pix_cnt: byte  =0;

  procedure RGBCalc0; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    r+=TRGBA(arr_src_ptr2^).r;
    g+=TRGBA(arr_src_ptr2^).g;
    b+=TRGBA(arr_src_ptr2^).b;
    Inc(non_zero_pix_cnt);
  end; {$endregion}

begin
  // pixel-border scheme:
  // 012
  // 345
  // 678
  // 4 - arr_src_ptr;
  // 0,1,2,3,5,6,7,8 - pixel-border;
  arr_src_ptr2:=arr_src_ptr-arr_src_width-1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    RGBCalc0;
  arr_src_ptr2:=arr_src_ptr-arr_src_width;
  if (arr_src_ptr2^>>24<>alpha_color) then
    RGBCalc0;
  arr_src_ptr2:=arr_src_ptr-arr_src_width+1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    RGBCalc0;
  arr_src_ptr2:=arr_src_ptr-1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    RGBCalc0;
  {if (arr_src_ptr^>>24<>alpha_color) then
    RGBCalc0;}
  arr_src_ptr2:=arr_src_ptr+1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    RGBCalc0;
  arr_src_ptr2:=arr_src_ptr+arr_src_width-1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    RGBCalc0;
  arr_src_ptr2:=arr_src_ptr+arr_src_width;
  if (arr_src_ptr2^>>24<>alpha_color) then
    RGBCalc0;
  arr_src_ptr2:=arr_src_ptr+arr_src_width+1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    RGBCalc0;
  if (non_zero_pix_cnt in [0..4]) then
    Exit;
  arr_src_ptr^:={clRed}RGB(Trunc(r/non_zero_pix_cnt),
                           Trunc(g/non_zero_pix_cnt),
                           Trunc(b/non_zero_pix_cnt));
end; {$endregion}
procedure BorderPixCh (arr_src_ptr:PInteger; const arr_src_width:TColor; const alpha_color     :byte; const alpha_mask:TColor); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2    : PInteger;
  r               : TColor=0;
  g               : TColor=0;
  b               : TColor=0;
  non_zero_pix_cnt: byte  =0;

  procedure RGBCalc0; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    r+=TRGBA(arr_src_ptr2^).r;
    g+=TRGBA(arr_src_ptr2^).g;
    b+=TRGBA(arr_src_ptr2^).b;
    Inc(non_zero_pix_cnt);
  end; {$endregion}

begin
  // pixel-border scheme:
  // 012
  // 345
  // 678
  // 4 - arr_src_ptr;
  // 0,1,2,3,5,6,7,8 - pixel-border;
  arr_src_ptr2:=arr_src_ptr-arr_src_width-1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    RGBCalc0;
  arr_src_ptr2:=arr_src_ptr-arr_src_width;
  if (arr_src_ptr2^>>24<>alpha_color) then
    RGBCalc0;
  arr_src_ptr2:=arr_src_ptr-arr_src_width+1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    RGBCalc0;
  arr_src_ptr2:=arr_src_ptr-1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    RGBCalc0;
  {if (arr_src_ptr^>>24<>alpha_color) then
    RGBCalc0;}
  arr_src_ptr2:=arr_src_ptr+1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    RGBCalc0;
  arr_src_ptr2:=arr_src_ptr+arr_src_width-1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    RGBCalc0;
  arr_src_ptr2:=arr_src_ptr+arr_src_width;
  if (arr_src_ptr2^>>24<>alpha_color) then
    RGBCalc0;
  arr_src_ptr2:=arr_src_ptr+arr_src_width+1;
  if (arr_src_ptr2^>>24<>alpha_color) then
    RGBCalc0;
  if (non_zero_pix_cnt=0 {in [0..4{6}]}) then
    Exit;
  arr_src_ptr^:=(RGB(Trunc(r/non_zero_pix_cnt),
                     Trunc(g/non_zero_pix_cnt),
                     Trunc(b/non_zero_pix_cnt)) and NT_BIT_MASK_ALPHA2)+alpha_mask;
end; {$endregion}
// Border blur:
procedure BorderBlur  (const arr_src_ptr:PInteger; var arr_dst:T1Byte1Arr;  const arr_src_width,arr_dst_width:TColor; const rct_dst:TPtRect; const background_color:TColor                 ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2         : PInteger;
  arr_dst_ptr          : PByte;
  d_width1,d_width2,x,y: integer;
begin
  d_width1    :=                                    arr_src_width- rct_dst.width   ;
  d_width2    :=                                    arr_dst_width- rct_dst.width   ;
  arr_src_ptr2:=Unaligned( arr_src_ptr+rct_dst.left+arr_src_width*(rct_dst.top+1) );
  arr_dst_ptr :=Unaligned(@arr_dst    [rct_dst.left+arr_dst_width*(rct_dst.top+1)]);
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_dst_ptr^=1) then
            BorderPixCh(arr_src_ptr2,arr_src_width,background_color);
          Inc(arr_src_ptr2);
          Inc(arr_dst_ptr );
        end;
      Inc(arr_src_ptr2,d_width1);
      Inc(arr_dst_ptr ,d_width2);
    end;
end; {$endregion}
procedure BorderBlur  (const arr_src_ptr:PInteger;                          const arr_src_width              :TColor; const rct_dst:TPtRect; const alpha_color     :byte                   ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2: PInteger;
  d_width,x,y : integer;
begin
  d_width     :=0000000000000000000000000000000000+arr_src_width- rct_dst.width  ;
  arr_src_ptr2:=Unaligned(arr_src_ptr+rct_dst.left+arr_src_width*(rct_dst.top+1));
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr2^>>24=alpha_color) then
            {arr_src_ptr2^:=clRed;}BorderPixCh(arr_src_ptr2,arr_src_width,alpha_color);
          Inc(arr_src_ptr2);
        end;
      Inc(arr_src_ptr2,d_width);
    end;
end; {$endregion}
procedure BorderBlur  (const arr_src_ptr:PInteger;                          const arr_src_width              :TColor; const rct_dst:TPtRect; const alpha_color     :byte; const mask:TColor); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2: PInteger;
  d_width,x,y : integer;
begin
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  d_width     :=0000000000000000000000000000000000+arr_src_width- rct_dst.width  ;
  arr_src_ptr2:=Unaligned(arr_src_ptr+rct_dst.left+arr_src_width*(rct_dst.top+1));
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr2^>>24=alpha_color) then
            {arr_src_ptr2^:=clRed;}BorderPixCh(arr_src_ptr2,arr_src_width,alpha_color,mask);
          Inc(arr_src_ptr2);
        end;
      Inc(arr_src_ptr2,d_width);
    end;
end; {$endregion}
procedure BorderBlur  (const arr_src_ptr:PByte; const arr_dst_ptr:PInteger; const arr_dst_width              :TColor; const rct_dst:TPtRect; const alpha_color     :byte; const mask:TColor); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr2: PByte;
  arr_dst_ptr2: PInteger;
  d_width,x,y : integer;

  procedure BorderPixCh; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  var
    r               : TColor=0;
    g               : TColor=0;
    b               : TColor=0;
    non_zero_pix_cnt: byte  =0;
    arr_dst_ptr3: PInteger;

    procedure RGBCalc0; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
    begin
      r+=TRGBA(arr_dst_ptr3^).r;
      g+=TRGBA(arr_dst_ptr3^).g;
      b+=TRGBA(arr_dst_ptr3^).b;
      Inc(non_zero_pix_cnt);
    end; {$endregion}

  begin
    r               :=0;
    g               :=0;
    b               :=0;
    // pixel-border scheme:
    // 012
    // 345
    // 678
    // 4 - arr_dst_ptr;
    // 0,1,2,3,5,6,7,8 - pixel-border;
    arr_dst_ptr3:=arr_dst_ptr2-arr_dst_width-1;
    if (arr_dst_ptr3^>>24<>alpha_color) then
      RGBCalc0;
    arr_dst_ptr3:=arr_dst_ptr2-arr_dst_width;
    if (arr_dst_ptr3^>>24<>alpha_color) then
      RGBCalc0;
    arr_dst_ptr3:=arr_dst_ptr2-arr_dst_width+1;
    if (arr_dst_ptr3^>>24<>alpha_color) then
      RGBCalc0;
    arr_dst_ptr3:=arr_dst_ptr2-1;
    if (arr_dst_ptr3^>>24<>alpha_color) then
      RGBCalc0;
    {if (arr_dst_ptr3^>>24<>alpha_color) then
      RGBCalc0;}
    arr_dst_ptr3:=arr_dst_ptr2+1;
    if (arr_dst_ptr3^>>24<>alpha_color) then
      RGBCalc0;
    arr_dst_ptr3:=arr_dst_ptr2+arr_dst_width-1;
    if (arr_dst_ptr3^>>24<>alpha_color) then
      RGBCalc0;
    arr_dst_ptr3:=arr_dst_ptr2+arr_dst_width;
    if (arr_dst_ptr3^>>24<>alpha_color) then
      RGBCalc0;
    arr_dst_ptr3:=arr_dst_ptr2+arr_dst_width+1;
    if (arr_dst_ptr3^>>24<>alpha_color) then
      RGBCalc0;
    if (non_zero_pix_cnt=0 {in [0..4{6}]}) then
      Exit;
    arr_dst_ptr2^:=(RGB(Trunc(r/non_zero_pix_cnt),
                        Trunc(g/non_zero_pix_cnt),
                        Trunc(b/non_zero_pix_cnt)) and NT_BIT_MASK_ALPHA2)+mask;
  end; {$endregion}

begin
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  d_width     :=0000000000000000000000000000000000+arr_dst_width- rct_dst.width  ;
  arr_dst_ptr2:=Unaligned(arr_dst_ptr+rct_dst.left+arr_dst_width*(rct_dst.top+1));
  arr_src_ptr2:=Unaligned(arr_src_ptr+rct_dst.left+arr_dst_width*(rct_dst.top+1));
  for y:=0 to rct_dst.height-3 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          if (arr_src_ptr2^=1) then
             {arr_dst_ptr2^:=clRed;//}BorderPixCh;
          Inc(arr_src_ptr2);
          Inc(arr_dst_ptr2);
        end;
      Inc(arr_src_ptr2,d_width);
      Inc(arr_dst_ptr2,d_width);
    end;
end; {$endregion}

{$endregion}



(******************************* Bitmap loading *******************************) {$region -fold}

function CrtTPicInstFromHDDSrc(const location:string): TPicture;                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=TPicture.Create;
  Result.LoadFromFile(location);
end; {$endregion}
function CrtTBmpInstFromImgLst(const ImgLstGetBmp:TProc1; const img_ind:TColor=0): TBitmap;                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=TBitmap.Create;
  ImgLstGetBmp(img_ind,Result);
end; {$endregion}
function CrtTBmpInst          (const bmp_src:TBitmap; var bmp_dst_ptr:PInteger): TBitmap;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      Result     :=TBitmap.Create;
      Width      :=bmp_src.width;
      Height     :=bmp_src.height;
      bmp_dst_ptr:=GetBmpHandle(Result);
      Canvas.Draw(0,0,bmp_src);
    end;
end; {$endregion}
function CrtTBmpInst          (const bmp_dst_width,bmp_dst_height:TColor; var bmp_src_ptr:PInteger): TBitmap; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with Result do
    begin
      Result     :=TBitmap.Create;
      PixelFormat:=pf32bit;
      Width      :=bmp_dst_width;
      Height     :=bmp_dst_height;
      bmp_src_ptr:=GetBmpHandle(Result);
    end;
end; {$endregion}

{$endregion}



(***************************** CSR-image routines *****************************) {$region -fold}

{Clear all specified buffers---------------------------} {$region -fold}
procedure TFastImageProc.ClrArr(arr_clear_val:word); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin

      {Color/Alpha of current layer} {$region -fold}

      // NT - not transparent pixels;
      if Odd(arr_clear_val>>10) then
        begin
          nt_pix_ccl_arr:=Nil;
          {SetLength(nt_pix_ccl_arr,1);
          nt_pix_ccl_arr[0]:=0;}
        end;

      // PT - partly transparent pixels;
      // color channel;
      if Odd(arr_clear_val>>09) then
        begin
          pt_pix_ccl_arr:=Nil;
          {SetLength(pt_pix_ccl_arr,1);
          pt_pix_ccl_arr[0]:=0;}
        end;
      // alpha channel
      if Odd(arr_clear_val>>08) then
        begin
          pt_pix_acl_arr:=Nil;
          {SetLength(pt_pix_acl_arr,1);
          pt_pix_acl_arr[0]:=0;}
        end; {$endregion}

      {Color       of lower   layer} {$region -fold}

      // NT - not transparent pixels;
      if Odd(arr_clear_val>>07) then
        begin
          //nt_pix_cll_arr:=Nil;
          {SetLength(nt_pix_cll_arr,1);
          nt_pix_cll_arr[0]:=0;}
        end;

      // PT - partly transparent pixels;
      if Odd(arr_clear_val>>06) then
        begin
          //pt_pix_cll_arr:=Nil;
          {SetLength(pt_pix_cll_arr,1);
          pt_pix_cll_arr[0]:=0;}
        end; {$endregion}

      {Value       of current layer} {$region -fold}

      // NT - not transparent pixels;
      if Odd(arr_clear_val>>05) then
        begin
          //nt_pix_val_arr:=Nil;
          {SetLength(nt_pix_val_arr,1);
          nt_pix_val_arr[0]:=0;}
        end;

      // PT - partly transparent pixels; reserved;
      if Odd(arr_clear_val>>04) then
        begin
          //pt_pix_val_arr:=Nil;
          {SetLength(pt_pix_val_arr,1);
          pt_pix_val_arr[0]:=0;}
        end; {$endregion}

      {Counts of items in rows-----} {$region -fold}

      // NT - not transparent pixels;
      if Odd(arr_clear_val>>03) then
        begin
          nt_pix_cnt_arr:=Nil;
          {SetLength(nt_pix_cnt_arr,1);
          nt_pix_cnt_arr[0]:=0;}
        end;

      // PT - partly transparent pixels;
      if Odd(arr_clear_val>>02) then
        begin
          pt_pix_cnt_arr:=Nil;
          {SetLength(pt_pix_cnt_arr,1);
          pt_pix_cnt_arr[0]:=0;}
        end; {$endregion}

      {Items shifts----------------} {$region -fold}

      // NT - not transparent pixels;
      if Odd(arr_clear_val>>01) then
        begin
          //nt_pix_sht_arr:=Nil;
          {SetLength(nt_pix_sht_arr,1);
          nt_pix_sht_arr[0]:=0;}
        end;

      // PT - partly transparent pixels;
      if Odd(arr_clear_val>>00) then
        begin
          //pt_pix_sht_arr:=Nil;
          {SetLength(pt_pix_sht_arr,1);
          pt_pix_sht_arr[0]:=0;}
        end; {$endregion}

    end;
end; {$endregion}
procedure TFastImageProc.ClrArr;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin

      // experimental:
      nt_pix_cnt    :=0;
      pt_pix_cnt    :=0;

      {Color       of Lower   Layer} {$region -fold}
      // NT - not transparent pixels;
      nt_pix_cll_arr:=Nil;
      // PT - partly transparent pixels;
      pt_pix_cll_arr:=Nil; {$endregion}

      {Value       of Current Layer} {$region -fold}
      // NT - not transparent pixels;
      nt_pix_val_arr:=Nil;
      // PT - partly transparent pixels; reserved;
      pt_pix_val_arr:=Nil; {$endregion}

      {Items Shifts----------------} {$region -fold}
      // NT - not transparent pixels;
      nt_pix_sht_arr:=Nil;
      // PT - partly transparent pixels;
      pt_pix_sht_arr:=Nil; {$endregion}

    end;
end; {$endregion} {$endregion}

{Define image kind-------------------------------------} {$region -fold}
procedure TFastImageProc.DetImageKind; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr  : PInteger;
  first_pix_alpha: TColor;
  x,y            : integer;
  d_width,w_mul_h: integer;
begin

  with fast_image_data_ptr0^ do
    begin

      if (rct_ent.width =0) or (bmp_src_rct_clp.width =0) or
         (rct_ent.height=0) or (bmp_src_rct_clp.height=0) then
        begin
          img_kind  :=10;
          nt_pix_cnt:=0;
          pt_pix_cnt:=0;
          Exit;
        end;

      if (img_kind=11) then
        begin
          nt_pix_cnt:=0;
          pt_pix_cnt:=0;
          Exit;
        end;

      d_width        := rct_ent.width-bmp_src_rct_clp.width;
      pix_color_ptr  :=@bmp_color_ptr[bmp_src_rct_clp.left+
                        rct_ent.width*bmp_src_rct_clp.top];
      first_pix_alpha:=pix_color_ptr^>>24;
      zr_pix_cnt     :=0;
      ft_pix_cnt     :=0;
      pt_pix_cng_cnt :=0;
      nt_pix_cnt     :=0;
      pt_pix_cnt     :=0;
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          for x:=0 to bmp_src_rct_clp.width-1 do
            begin

              {alpha_precision}
              {if (PRGBA(pix_color_ptr)^.a<=64{120}) then
                  PRGBA(pix_color_ptr)^.a:=000;}

              Inc(zr_pix_cnt,Byte(pix_color_ptr^<<08=000000000));
              if (pix_color_ptr^>>24=000000000) then
                Inc(ft_pix_cnt)
              else
              if (pix_color_ptr^>>24=MAXBYTE) then
                Inc(nt_pix_cnt)
              else
             {if (pix_color_ptr^>>24>000000000) and
                 (pix_color_ptr^>>24<MAXBYTE) then}
                begin
                  Inc(pt_pix_cng_cnt,Byte(pix_color_ptr^>>24=first_pix_alpha));
                  Inc(pt_pix_cnt);
                end;
              Inc(pix_color_ptr);
            end;
          Inc(pix_color_ptr,d_width)
        end;

      if tile_map_calc then
        begin
          img_kind                     :=12;
          fx_arr[0].nt_fx_prop.cfx_pow0:=first_pix_alpha;
          fx_arr[0].pt_fx_prop.cfx_pow0:=first_pix_alpha;
          Exit;
        end;

      w_mul_h:=bmp_src_rct_clp.width*bmp_src_rct_clp.height;
      if (pt_pix_cng_cnt<>w_mul_h)  and
         (zr_pix_cnt    <>w_mul_h)  and
         (nt_pix_cnt     >0000000)  and
         (pt_pix_cnt     >0000000) then
        img_kind:=0;

      if (pt_pix_cng_cnt<>w_mul_h)  and
         (zr_pix_cnt    <>w_mul_h)  and
         (nt_pix_cnt     >0000000)  and
         (pt_pix_cnt     =0000000) then
        img_kind:=1;

      if (pt_pix_cng_cnt<>w_mul_h)  and
         (zr_pix_cnt    <>w_mul_h)  and
         (nt_pix_cnt     =0000000)  and
         (pt_pix_cnt     >0000000) then
        img_kind:=2;

      if (pt_pix_cng_cnt<>w_mul_h)  and
         (zr_pix_cnt    <>w_mul_h)  and
        ((nt_pix_cnt     =w_mul_h)   or
         (ft_pix_cnt     =w_mul_h)   or
         (nt_pix_cnt     =0000000)) and
         (pt_pix_cnt     =0000000) then
        img_kind:=3;

      if (pt_pix_cng_cnt =w_mul_h)  and
         (zr_pix_cnt    <>w_mul_h)  and
         (nt_pix_cnt     =0000000)  and
         (pt_pix_cnt     =w_mul_h) then
        begin
          img_kind                     :=4;
          fx_arr[0].nt_fx_prop.cfx_pow0:=first_pix_alpha;
          fx_arr[0].pt_fx_prop.cfx_pow0:=first_pix_alpha;
        end;

      if (pt_pix_cng_cnt<>w_mul_h)  and
         (zr_pix_cnt     =w_mul_h)  and
         (nt_pix_cnt     >0000000)  and
         (pt_pix_cnt     >0000000) then
        img_kind:=5;

      if (pt_pix_cng_cnt<>w_mul_h)  and
         (zr_pix_cnt     =w_mul_h)  and
         (nt_pix_cnt     >0000000)  and
         (pt_pix_cnt     =0000000) then
        img_kind:=6;

      if (pt_pix_cng_cnt<>w_mul_h)  and
         (zr_pix_cnt     =w_mul_h)  and
         (nt_pix_cnt     =0000000)  and
         (pt_pix_cnt     >0000000) then
        img_kind:=7;

      if (pt_pix_cng_cnt =0000000)  and
         (zr_pix_cnt     =w_mul_h)  and
         (nt_pix_cnt     =w_mul_h)  and
         (pt_pix_cnt     =0000000) then
        img_kind:=8;

      if (pt_pix_cng_cnt =w_mul_h)  and
         (zr_pix_cnt     =w_mul_h)  and
         (nt_pix_cnt     =0000000)  and
         (pt_pix_cnt     =w_mul_h) then
        img_kind:=9;

      if (pt_pix_cng_cnt =w_mul_h)  and
         (zr_pix_cnt     =w_mul_h)  and
         (nt_pix_cnt     =0)        and
         (pt_pix_cnt     =0)       then
        img_kind:=10;

     {nt_pix_cnt:=0;
      pt_pix_cnt:=0;}

    end;

end; {$endregion} {$endregion}

{Create array    of items counts  in rows from bitmap--} {$region -fold}
// color and alpha are in separate bitmaps
// NT - not transparent pixels;
procedure TFastImageProc.CrtNTCountBmpS; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr     : PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_cnt_row    : word=0;
//nt_pix_clm_end    : boolean=True;
  x,y,m             : integer;
  d_width           : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or  (bmp_src_rct_clp.height=0) then
        Exit;
      SetLength(nt_pix_cnt_arr,         bmp_src_rct_clp.height);
      d_width           :=rct_ent.width-bmp_src_rct_clp.width;
      nt_pix_cnt        :=0;
    //nt_pix_clm        :=0;
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[000000000000000000000000000000000000000000000000000000]);
      pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr [bmp_src_rct_clp.left+rct_ent.width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          for x:=0 to bmp_src_rct_clp.width-1 do
            begin
              Inc(nt_pix_cnt_row,Byte(pix_alpha_ptr^=$FFFFFF));
              Inc(pix_alpha_ptr);
            end;
          if (nt_pix_cnt_row<>0) then
            begin
              nt_pix_cnt_arr_ptr^:=nt_pix_cnt_row;
              nt_pix_cnt         +=nt_pix_cnt_row;
              nt_pix_cnt_row     :=0;
              {if (nt_pix_clm_end =True) then
                begin
                  nt_pix_clm_end :=False;
                  nt_pix_clm     +=1;
                end;}
            end
          {else
              nt_pix_clm_end     :=True};
          Inc(nt_pix_cnt_arr_ptr);
          Inc(pix_alpha_ptr,d_width);
        end;
      if (nt_pix_cnt=0) then
        Exit;

      {Find Top Margin Value}
      m:=NotIndexWord(@nt_pix_cnt_arr[0],bmp_src_rct_clp.height-1);
      if (m=-1) then
        nt_pix_arr_row_mrg_top:=0
      else
        nt_pix_arr_row_mrg_top:=m;

      {Find Bottom Margin Value}
          nt_pix_arr_row_mrg_btm:=0;
      if (nt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
          nt_pix_arr_row_mrg_btm:=NotIndexWord2(
         @nt_pix_cnt_arr[bmp_src_rct_clp.height-1],
                         bmp_src_rct_clp.height);

    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImageProc.CrtPTCountBmpS; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr     : PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_cnt_row    : word=0;
//pt_pix_clm_end    : boolean=True;
  x,y,m             : integer;
  d_width           : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or  (bmp_src_rct_clp.height=0) then
        Exit;
      SetLength(pt_pix_cnt_arr,         bmp_src_rct_clp.height);
      d_width           :=rct_ent.width-bmp_src_rct_clp.width;
      pt_pix_cnt        :=0;
    //pt_pix_clm        :=0;
      pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr[000000000000000000000000000000000000000000000000000000]);
      pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr [bmp_src_rct_clp.left+rct_ent.width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          for x:=0 to bmp_src_rct_clp.width-1 do
            begin
              Inc(pt_pix_cnt_row,Byte((pix_alpha_ptr^>0) and (pix_alpha_ptr^<MAXBYTE)));
              Inc(pix_alpha_ptr,4);
            end;
          if (pt_pix_cnt_row<>0) then
            begin
              pt_pix_cnt_arr_ptr^:=pt_pix_cnt_row;
              pt_pix_cnt         +=pt_pix_cnt_row;
              pt_pix_cnt_row     :=0;
              {if (pt_pix_clm_end  =True) then
                begin
                  pt_pix_clm_end :=False;
                  pt_pix_clm     +=1;
                end;}
            end
          {else
              pt_pix_clm_end     :=True};
          Inc(pt_pix_cnt_arr_ptr);
          Inc(pix_alpha_ptr,d_width<<2);
        end;
      if (pt_pix_cnt=0) then
        Exit;

      {Find Top Margin Value}
      m:=NotIndexWord(@pt_pix_cnt_arr[0],bmp_src_rct_clp.height-1);
      if (m=-1) then
        pt_pix_arr_row_mrg_top:=0
      else
        pt_pix_arr_row_mrg_top:=m;

      {Find Bottom Margin Value}
          pt_pix_arr_row_mrg_btm:=0;
      if (pt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
          pt_pix_arr_row_mrg_btm:=NotIndexWord2(
         @pt_pix_cnt_arr[bmp_src_rct_clp.height-1],
                         bmp_src_rct_clp.height);

    end;
end; {$endregion}
// color and alpha are in one bitmap
// NT - not transparent pixels;
procedure TFastImageProc.CrtNTCountBmpO; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr     : PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_cnt_row    : word=0;
//nt_pix_clm_end    : boolean=True;
  x,y,m             : integer;
  d_width           : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or  (bmp_src_rct_clp.height=0) then
        Exit;
      SetLength(nt_pix_cnt_arr,         bmp_src_rct_clp.height);
      d_width           :=rct_ent.width-bmp_src_rct_clp.width;
      nt_pix_cnt        :=0;
    //nt_pix_clm        :=0;
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[000000000000000000000000000000000000000000000000000000]);
      pix_color_ptr     :=Unaligned(@bmp_color_ptr [bmp_src_rct_clp.left+rct_ent.width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          for x:=0 to bmp_src_rct_clp.width-1 do
            begin
              Inc(nt_pix_cnt_row,Byte(PRGBA(pix_color_ptr)^.a=MAXBYTE));
              Inc(pix_color_ptr);
            end;
          if (nt_pix_cnt_row<>0) then
            begin
              nt_pix_cnt_arr_ptr^:=nt_pix_cnt_row;
              nt_pix_cnt         +=nt_pix_cnt_row;
              nt_pix_cnt_row     :=0;
              {if (nt_pix_clm_end  =True) then
                begin
                  nt_pix_clm_end :=False;
                  nt_pix_clm     +=1;
                end;}
            end
          {else
              nt_pix_clm_end     :=True};
          Inc(nt_pix_cnt_arr_ptr);
          Inc(pix_color_ptr,d_width);
        end;
      if (nt_pix_cnt=0) then
        Exit;

      {Find Top Margin Value}
      m:=NotIndexWord(@nt_pix_cnt_arr[0],bmp_src_rct_clp.height-1);
      if (m=-1) then
        nt_pix_arr_row_mrg_top:=0
      else
        nt_pix_arr_row_mrg_top:=m;

      {Find Bottom Margin Value}
          nt_pix_arr_row_mrg_btm:=0;
      if (nt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
          nt_pix_arr_row_mrg_btm:=NotIndexWord2(
         @nt_pix_cnt_arr[bmp_src_rct_clp.height-1],
                         bmp_src_rct_clp.height);

    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImageProc.CrtPTCountBmpO; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_color_ptr     : PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_cnt_row    : word=0;
//pt_pix_clm_end    : boolean=True;
  x,y,m             : integer;
  d_width           : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or  (bmp_src_rct_clp.height=0) then
        Exit;
      SetLength(pt_pix_cnt_arr,         bmp_src_rct_clp.height);
      d_width           :=rct_ent.width-bmp_src_rct_clp.width;
      pt_pix_cnt        :=0;
    //pt_pix_clm        :=0;
      pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr[000000000000000000000000000000000000000000000000000000]);
      pix_color_ptr     :=Unaligned(@bmp_color_ptr [bmp_src_rct_clp.left+rct_ent.width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          for x:=0 to bmp_src_rct_clp.width-1 do
            begin
              Inc(pt_pix_cnt_row,Byte((PRGBA(pix_color_ptr)^.a>0) and (PRGBA(pix_color_ptr)^.a<MAXBYTE)));
              Inc(pix_color_ptr);
            end;
          if (pt_pix_cnt_row<>0) then
            begin
              pt_pix_cnt_arr_ptr^:=pt_pix_cnt_row;
              pt_pix_cnt         +=pt_pix_cnt_row;
              pt_pix_cnt_row     :=0;
              {if (pt_pix_clm_end  =True) then
                begin
                  pt_pix_clm_end :=False;
                  pt_pix_clm     +=1;
                end;}
            end
          {else
              pt_pix_clm_end     :=True};
          Inc(pt_pix_cnt_arr_ptr);
          Inc(pix_color_ptr,d_width);
        end;
      if (pt_pix_cnt=0) then
        Exit;

      {Find Top Margin Value}
      m:=NotIndexWord(@pt_pix_cnt_arr[0],bmp_src_rct_clp.height-1);
      if (m=-1) then
        pt_pix_arr_row_mrg_top:=0
      else
        pt_pix_arr_row_mrg_top:=m;

      {Find Bottom Margin Value}
          pt_pix_arr_row_mrg_btm:=0;
      if (pt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
          pt_pix_arr_row_mrg_btm:=NotIndexWord2(
         @pt_pix_cnt_arr[bmp_src_rct_clp.height-1],
                         bmp_src_rct_clp.height);

    end;
end; {$endregion} {$endregion}

{Create array    of items counts  in rows from array---} {$region -fold}
// NT - not transparent pixels;
procedure TFastImageProc.CrtNTCountArrA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr     : PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_cnt_row    : word=0;
//nt_pix_clm_end    : boolean=True;
  x,y,j,m           : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      nt_pix_cnt_prev:=nt_pix_cnt;
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        begin
          nt_pix_cnt:=0;
          Exit;
        end;
      SetLength(nt_pix_cnt_arr,bmp_src_rct_clp.height);
      nt_pix_cnt        :=0;
    //nt_pix_clm        :=0;
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[000000000000000000000000000000000000000000000000000000]);
      pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr [bmp_src_rct_clp.left+rct_ent.width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          j:=NotIndexDWord(pix_alpha_ptr,bmp_src_rct_clp.width);
          if (j<>-1) then
            for x:=j to bmp_src_rct_clp.width-1 do
              Inc(nt_pix_cnt_row,((pix_alpha_ptr+x)^+NZ_ITEM_COEFF22)>>NZ_ITEM_COEFF12);//Inc(nt_pix_cnt_row,Byte((pix_alpha_ptr+x)^<>0));
          if     (nt_pix_cnt_row<>0) then
            begin
              nt_pix_cnt_arr_ptr^:=nt_pix_cnt_row;
              nt_pix_cnt         +=nt_pix_cnt_row;
              nt_pix_cnt_row     :=0;
              {if (nt_pix_clm_end  =True) then
                begin
                  nt_pix_clm_end :=False;
                  nt_pix_clm     +=1;
                end;}
            end
          {else
              nt_pix_clm_end     :=True};
          Inc(nt_pix_cnt_arr_ptr);
          Inc(pix_alpha_ptr,rct_ent.width);
        end;
      if (nt_pix_cnt=0) then
        Exit;

      {Find Top Margin Value}
      m:=NotIndexWord(@nt_pix_cnt_arr[0],bmp_src_rct_clp.height-1);
      if (m=-1) then
        nt_pix_arr_row_mrg_top:=0
      else
        nt_pix_arr_row_mrg_top:=m;

      {Find Bottom Margin Value}
          nt_pix_arr_row_mrg_btm:=0;
      if (nt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
          nt_pix_arr_row_mrg_btm:=NotIndexWord2(
         @nt_pix_cnt_arr[bmp_src_rct_clp.height-1],
                         bmp_src_rct_clp.height);

    end;
end; {$endregion}
procedure TFastImageProc.CrtNTCountArrB; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr     : PByte;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_cnt_row    : word=0;
//nt_pix_clm_end    : boolean=True;
  x,y,j,m           : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      nt_pix_cnt_prev:=nt_pix_cnt;
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        begin
          nt_pix_cnt:=0;
          Exit;
        end;
      SetLength(nt_pix_cnt_arr,bmp_src_rct_clp.height);
      nt_pix_cnt        :=0;
    //nt_pix_clm        :=0;
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[000000000000000000000000000000000000000000000000000000]);
      pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr2[bmp_src_rct_clp.left+rct_ent.width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          j:=NotIndexByte(pix_alpha_ptr,bmp_src_rct_clp.width);
          if (j<>-1) then
            for x:=j to bmp_src_rct_clp.width-1 do
              Inc(nt_pix_cnt_row,((pix_alpha_ptr+x)^+NZ_ITEM_COEFF20)>>NZ_ITEM_COEFF10); //Inc(nt_pix_cnt_row,Byte((pix_alpha_ptr+x)^<>0));
          if     (nt_pix_cnt_row<>0) then
            begin
              nt_pix_cnt_arr_ptr^:=nt_pix_cnt_row;
              nt_pix_cnt         +=nt_pix_cnt_row;
              nt_pix_cnt_row     :=0;
              {if (nt_pix_clm_end  =True) then
                begin
                  nt_pix_clm_end :=False;
                  nt_pix_clm     +=1;
                end;}
            end
          {else
              nt_pix_clm_end     :=True};
          Inc(nt_pix_cnt_arr_ptr);
          Inc(pix_alpha_ptr,rct_ent.width);
        end;
      if (nt_pix_cnt=0) then
        Exit;

      {Find Top Margin Value}
      m:=NotIndexWord(@nt_pix_cnt_arr[0],bmp_src_rct_clp.height-1);
      if (m=-1) then
        nt_pix_arr_row_mrg_top:=0
      else
        nt_pix_arr_row_mrg_top:=m;

      {Find Bottom Margin Value}
          nt_pix_arr_row_mrg_btm:=0;
      if (nt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
          nt_pix_arr_row_mrg_btm:=NotIndexWord2(
         @nt_pix_cnt_arr[bmp_src_rct_clp.height-1],
                         bmp_src_rct_clp.height);

    end;
end; {$endregion}
procedure TFastImageProc.CrtNTCountArrC; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr     : PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_cnt_row    : word=0;
//nt_pix_clm_end    : boolean=True;
  x,y,j,m           : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      nt_pix_cnt_prev:=nt_pix_cnt;
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        begin
          nt_pix_cnt:=0;
          Exit;
        end;
      SetLength(nt_pix_cnt_arr,bmp_src_rct_clp.height);
      nt_pix_cnt        :=0;
    //nt_pix_clm        :=0;
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[000000000000000000000000000000000000000000000000000000]);
      pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr [bmp_src_rct_clp.left+rct_ent.width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          j:=NotIndexDWord(pix_alpha_ptr,bmp_src_rct_clp.width);
          if (j<>-1) then
            for x:=j to bmp_src_rct_clp.width-1 do
              Inc(nt_pix_cnt_row,((pix_alpha_ptr+x)^+NZ_ITEM_COEFF22)>>NZ_ITEM_COEFF12);
          if     (nt_pix_cnt_row<>0) then
            begin
              nt_pix_cnt_arr_ptr^:=nt_pix_cnt_row;
              nt_pix_cnt         +=nt_pix_cnt_row;
              nt_pix_cnt_row     :=0;
              {if (nt_pix_clm_end  =True) then
                begin
                  nt_pix_clm_end :=False;
                  nt_pix_clm     +=1;
                end;}
            end
          {else
              nt_pix_clm_end     :=True};
          Inc(nt_pix_cnt_arr_ptr);
          Inc(pix_alpha_ptr,rct_ent.width);
        end;
      if (nt_pix_cnt=0) then
        Exit;

      {Find Top Margin Value}
      m:=NotIndexWord(@nt_pix_cnt_arr[0],bmp_src_rct_clp.height-1);
      if (m=-1) then
        nt_pix_arr_row_mrg_top:=0
      else
        nt_pix_arr_row_mrg_top:=m;

      {Find Bottom Margin Value}
          nt_pix_arr_row_mrg_btm:=0;
      if (nt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
          nt_pix_arr_row_mrg_btm:=NotIndexWord2(
         @nt_pix_cnt_arr[bmp_src_rct_clp.height-1],
                         bmp_src_rct_clp.height);

    end;
end; {$endregion}
procedure TFastImageProc.CrtNTCountArrD; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr     : PByte;
  pix_alpha_ptr2    : PByte;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_cnt_row    :  word=0;
//nt_pix_clm_end    : boolean=True;
  x,y,z,j,m,k       : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      nt_pix_cnt_prev:=nt_pix_cnt;
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        begin
          nt_pix_cnt:=0;
          Exit;
        end;
      SetLength(nt_pix_cnt_arr,bmp_src_rct_clp.height);
      nt_pix_cnt        :=0;
    //nt_pix_clm        :=0;
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[000000000000000000000000000000000000000000000000000000]);
      pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr2[bmp_src_rct_clp.left+rct_ent.width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          j:=NotIndexByte(pix_alpha_ptr,bmp_src_rct_clp.width);
          if (j<>-1) then
            {$ifdef win64}
            begin
              k             :=((bmp_src_rct_clp.width-1-j)>>4)-1;
              pix_alpha_ptr2:=pix_alpha_ptr+j;
              for x:=0 to k do
                begin
                  {$region -fold}
                 {Inc(nt_pix_cnt_row,((pix_alpha_ptr+j+16*x+00)^+NZ_ITEM_COEFF20)>>NZ_ITEM_COEFF10);
                  Inc(nt_pix_cnt_row,((pix_alpha_ptr+j+16*x+01)^+NZ_ITEM_COEFF20)>>NZ_ITEM_COEFF10);
                  Inc(nt_pix_cnt_row,((pix_alpha_ptr+j+16*x+02)^+NZ_ITEM_COEFF20)>>NZ_ITEM_COEFF10);
                  Inc(nt_pix_cnt_row,((pix_alpha_ptr+j+16*x+03)^+NZ_ITEM_COEFF20)>>NZ_ITEM_COEFF10);
                  Inc(nt_pix_cnt_row,((pix_alpha_ptr+j+16*x+04)^+NZ_ITEM_COEFF20)>>NZ_ITEM_COEFF10);
                  Inc(nt_pix_cnt_row,((pix_alpha_ptr+j+16*x+05)^+NZ_ITEM_COEFF20)>>NZ_ITEM_COEFF10);
                  Inc(nt_pix_cnt_row,((pix_alpha_ptr+j+16*x+06)^+NZ_ITEM_COEFF20)>>NZ_ITEM_COEFF10);
                  Inc(nt_pix_cnt_row,((pix_alpha_ptr+j+16*x+07)^+NZ_ITEM_COEFF20)>>NZ_ITEM_COEFF10);
                  Inc(nt_pix_cnt_row,((pix_alpha_ptr+j+16*x+08)^+NZ_ITEM_COEFF20)>>NZ_ITEM_COEFF10);
                  Inc(nt_pix_cnt_row,((pix_alpha_ptr+j+16*x+09)^+NZ_ITEM_COEFF20)>>NZ_ITEM_COEFF10);
                  Inc(nt_pix_cnt_row,((pix_alpha_ptr+j+16*x+10)^+NZ_ITEM_COEFF20)>>NZ_ITEM_COEFF10);
                  Inc(nt_pix_cnt_row,((pix_alpha_ptr+j+16*x+11)^+NZ_ITEM_COEFF20)>>NZ_ITEM_COEFF10);
                  Inc(nt_pix_cnt_row,((pix_alpha_ptr+j+16*x+12)^+NZ_ITEM_COEFF20)>>NZ_ITEM_COEFF10);
                  Inc(nt_pix_cnt_row,((pix_alpha_ptr+j+16*x+13)^+NZ_ITEM_COEFF20)>>NZ_ITEM_COEFF10);
                  Inc(nt_pix_cnt_row,((pix_alpha_ptr+j+16*x+14)^+NZ_ITEM_COEFF20)>>NZ_ITEM_COEFF10);
                  Inc(nt_pix_cnt_row,((pix_alpha_ptr+j+16*x+15)^+NZ_ITEM_COEFF20)>>NZ_ITEM_COEFF10);}
                 {with NZByteCnt128(Fast_SIMD.PRGBA2(pix_alpha_ptr2)^,MSK0,MSK1) do
                    Inc(nt_pix_cnt_row,PopCnt(r)+PopCnt(g)+PopCnt(b)+PopCnt(a));
                  Inc(pix_alpha_ptr2,16);}
                  {$endregion}
                  Inc(nt_pix_cnt_row,NZByteCnt128(PRGBA04(pix_alpha_ptr2)^,{MSK0_128,}MSK1_128));
                  Inc(pix_alpha_ptr2,16);
                end;
              for z:=j+(k+1)<<4 to bmp_src_rct_clp.width-1 do
                Inc(nt_pix_cnt_row,((pix_alpha_ptr+z)^+NZ_ITEM_COEFF20)>>NZ_ITEM_COEFF10);
            end;
            {$else}
            for x:=j to bmp_src_rct_clp.width-1 do
              Inc(nt_pix_cnt_row,((pix_alpha_ptr+x)^+NZ_ITEM_COEFF20)>>NZ_ITEM_COEFF10);
            {$endif}
          if (nt_pix_cnt_row<>0) then
            begin
              nt_pix_cnt_arr_ptr^:=nt_pix_cnt_row;
              nt_pix_cnt         +=nt_pix_cnt_row;
              nt_pix_cnt_row     :=0;
              {if (nt_pix_clm_end  =True) then
                begin
                  nt_pix_clm_end :=False;
                  nt_pix_clm     +=1;
                end;}
            end
          {else
              nt_pix_clm_end     :=True};
          Inc(nt_pix_cnt_arr_ptr);
          Inc(pix_alpha_ptr,rct_ent.width);
        end;
      if (nt_pix_cnt=0) then
        Exit;

      {Find Top Margin Value}
      m:=NotIndexWord(@nt_pix_cnt_arr[0],bmp_src_rct_clp.height-1);
      if (m=-1) then
        nt_pix_arr_row_mrg_top:=0
      else
        nt_pix_arr_row_mrg_top:=m;

      {Find Bottom Margin Value}
          nt_pix_arr_row_mrg_btm:=0;
      if (nt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
          nt_pix_arr_row_mrg_btm:=NotIndexWord2(
         @nt_pix_cnt_arr[bmp_src_rct_clp.height-1],
                         bmp_src_rct_clp.height);

    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImageProc.CrtPTCountArrA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr     : PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_cnt_row    : word=0;
//pt_pix_clm_end    : boolean=True;
  x,y,m             : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      pt_pix_cnt_prev:=pt_pix_cnt;
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        begin
          pt_pix_cnt:=0;
          Exit;
        end;
      SetLength(pt_pix_cnt_arr,bmp_src_rct_clp.height);
      pt_pix_cnt        :=0;
    //pt_pix_clm        :=0;
      pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr[000000000000000000000000000000000000000000000000000000]);
      pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr [bmp_src_rct_clp.left+rct_ent.width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          for x:=0 to bmp_src_rct_clp.width-1 do
            Inc(pt_pix_cnt_row,Byte(((pix_alpha_ptr+x)^>>24<>0) and ((pix_alpha_ptr+x)^>>24<>MAXBYTE)));
          if   (pt_pix_cnt_row<>0) then
            begin
              pt_pix_cnt_arr_ptr^:=pt_pix_cnt_row;
              pt_pix_cnt         +=pt_pix_cnt_row;
              pt_pix_cnt_row     :=0;
              {if (pt_pix_clm_end  =True) then
                begin
                  pt_pix_clm_end :=False;
                  pt_pix_clm     +=1;
                end;}
            end
          {else
              pt_pix_clm_end     :=True};
          Inc(pt_pix_cnt_arr_ptr);
          Inc(pix_alpha_ptr,rct_ent.width);
        end;
      if (pt_pix_cnt=0) then
        Exit;

      {Find Top Margin Value}
      m:=NotIndexWord(@pt_pix_cnt_arr[0],bmp_src_rct_clp.height-1);
      if (m=-1) then
        pt_pix_arr_row_mrg_top:=0
      else
        pt_pix_arr_row_mrg_top:=m;

      {Find Bottom Margin Value}
          pt_pix_arr_row_mrg_btm:=0;
      if (pt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
          pt_pix_arr_row_mrg_btm:=NotIndexWord2(
         @pt_pix_cnt_arr[bmp_src_rct_clp.height-1],
                         bmp_src_rct_clp.height);

    end;
end; {$endregion}
procedure TFastImageProc.CrtPTCountArrB; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr     : PByte;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_cnt_row    : word=0;
//pt_pix_clm_end    : boolean=True;
  x,y,m             : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      pt_pix_cnt_prev:=pt_pix_cnt;
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        begin
          pt_pix_cnt:=0;
          Exit;
        end;
      SetLength(pt_pix_cnt_arr,bmp_src_rct_clp.height);
      pt_pix_cnt        :=0;
    //pt_pix_clm        :=0;
      pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr[000000000000000000000000000000000000000000000000000000]);
      pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr2[bmp_src_rct_clp.left+rct_ent.width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          for x:=0 to bmp_src_rct_clp.width-1 do
            Inc(pt_pix_cnt_row,Byte(((pix_alpha_ptr+x)^<>0) and ((pix_alpha_ptr+x)^<>MAXBYTE)));
          if   (pt_pix_cnt_row<>0) then
            begin
              pt_pix_cnt_arr_ptr^:=pt_pix_cnt_row;
              pt_pix_cnt         +=pt_pix_cnt_row;
              pt_pix_cnt_row     :=0;
              {if (pt_pix_clm_end  =True) then
                begin
                  pt_pix_clm_end :=False;
                  pt_pix_clm     +=1;
                end;}
            end
          {else
              pt_pix_clm_end     :=True};
          Inc(pt_pix_cnt_arr_ptr);
          Inc(pix_alpha_ptr,rct_ent.width);
        end;
      if (pt_pix_cnt=0) then
        Exit;

      {Find Top Margin Value}
      m:=NotIndexWord(@pt_pix_cnt_arr[0],bmp_src_rct_clp.height-1);
      if (m=-1) then
        pt_pix_arr_row_mrg_top:=0
      else
        pt_pix_arr_row_mrg_top:=m;

      {Find Bottom Margin Value}
          pt_pix_arr_row_mrg_btm:=0;
      if (pt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
          pt_pix_arr_row_mrg_btm:=NotIndexWord2(
         @pt_pix_cnt_arr[bmp_src_rct_clp.height-1],
                         bmp_src_rct_clp.height);

    end;
end; {$endregion}
procedure TFastImageProc.CrtPTCountArrC; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr     : PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_cnt_row    : word=0;
//pt_pix_clm_end    : boolean=True;
  x,y,m             : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      pt_pix_cnt_prev:=pt_pix_cnt;
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        begin
          pt_pix_cnt:=0;
          Exit;
        end;
      SetLength(pt_pix_cnt_arr,bmp_src_rct_clp.height);
      pt_pix_cnt        :=0;
    //pt_pix_clm        :=0;
      pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr[000000000000000000000000000000000000000000000000000000]);
      pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr [bmp_src_rct_clp.left+rct_ent.width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          for x:=0 to bmp_src_rct_clp.width-1 do
            Inc(pt_pix_cnt_row,Byte(((pix_alpha_ptr+x)^>>24<>0) and ((pix_alpha_ptr+x)^>>24<>MAXBYTE)));
          if   (pt_pix_cnt_row<>0) then
            begin
              pt_pix_cnt_arr_ptr^:=pt_pix_cnt_row;
              pt_pix_cnt         +=pt_pix_cnt_row;
              pt_pix_cnt_row     :=0;
              {if (pt_pix_clm_end  =True) then
                begin
                  pt_pix_clm_end :=False;
                  pt_pix_clm     +=1;
                end;}
            end
          {else
              pt_pix_clm_end     :=True};
          Inc(pt_pix_cnt_arr_ptr);
          Inc(pix_alpha_ptr,rct_ent.width);
        end;
      if (pt_pix_cnt=0) then
        Exit;

      {Find Top Margin Value}
      m:=NotIndexWord(@pt_pix_cnt_arr[0],bmp_src_rct_clp.height-1);
      if (m=-1) then
        pt_pix_arr_row_mrg_top:=0
      else
        pt_pix_arr_row_mrg_top:=m;

      {Find Bottom Margin Value}
          pt_pix_arr_row_mrg_btm:=0;
      if (pt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
          pt_pix_arr_row_mrg_btm:=NotIndexWord2(
         @pt_pix_cnt_arr[bmp_src_rct_clp.height-1],
                         bmp_src_rct_clp.height);

    end;
end; {$endregion}
procedure TFastImageProc.CrtPTCountArrD; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr     : PByte;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_cnt_row    : word=0;
//pt_pix_clm_end    : boolean=True;
  x,y,m             : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      pt_pix_cnt_prev:=pt_pix_cnt;
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        begin
          pt_pix_cnt:=0;
          Exit;
        end;
      SetLength(pt_pix_cnt_arr,bmp_src_rct_clp.height);
      pt_pix_cnt        :=0;
    //pt_pix_clm        :=0;
      pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr[000000000000000000000000000000000000000000000000000000]);
      pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr2[bmp_src_rct_clp.left+rct_ent.width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          for x:=0 to bmp_src_rct_clp.width-1 do
            Inc(pt_pix_cnt_row,Byte(((pix_alpha_ptr+x)^<>0) and ((pix_alpha_ptr+x)^<>MAXBYTE)));
          if   (pt_pix_cnt_row<>0) then
            begin
              pt_pix_cnt_arr_ptr^:=pt_pix_cnt_row;
              pt_pix_cnt         +=pt_pix_cnt_row;
              pt_pix_cnt_row     :=0;
              {if (pt_pix_clm_end  =True) then
                begin
                  pt_pix_clm_end :=False;
                  pt_pix_clm     +=1;
                end;}
            end
          {else
              pt_pix_clm_end     :=True};
          Inc(pt_pix_cnt_arr_ptr);
          Inc(pix_alpha_ptr,rct_ent.width);
        end;
      if (pt_pix_cnt=0) then
        Exit;

      {Find Top Margin Value}
      m:=NotIndexWord(@pt_pix_cnt_arr[0],bmp_src_rct_clp.height-1);
      if (m=-1) then
        pt_pix_arr_row_mrg_top:=0
      else
        pt_pix_arr_row_mrg_top:=m;

      {Find Bottom Margin Value}
          pt_pix_arr_row_mrg_btm:=0;
      if (pt_pix_arr_row_mrg_top<bmp_src_rct_clp.height) then
          pt_pix_arr_row_mrg_btm:=NotIndexWord2(
         @pt_pix_cnt_arr[bmp_src_rct_clp.height-1],
                         bmp_src_rct_clp.height);

    end;
end; {$endregion} {$endregion}

{Create array    of items shifts  in rows from bitmap--} {$region -fold}
// color and alpha are in separate bitmaps
// NT - not transparent pixels;
procedure TFastImageProc.CrtNTShiftBmpS; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  pix_alpha_ptr     : PInteger;
  x,y               : integer;
  d_width           : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        Exit;
      if (nt_pix_cnt=0) then
        Exit;
      SetLength(nt_pix_sht_arr,nt_pix_cnt);
      d_width           :=rct_ent.width-bmp_src_rct_clp.width;
      nt_pix_sht_arr_ptr:=Unaligned(@nt_pix_sht_arr[000000000000000000000000000000000000000000000000000000]);
      pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr [bmp_src_rct_clp.left+rct_ent.width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          for x:=0 to bmp_src_rct_clp.width-1 do
            begin
              if (pix_alpha_ptr^=$FFFFFF) then
                begin
                      nt_pix_sht_arr_ptr^:=x;
                  Inc(nt_pix_sht_arr_ptr);
                end;
              Inc(pix_alpha_ptr);
            end;
          Inc(pix_alpha_ptr,d_width);
        end;
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImageProc.CrtPTShiftBmpS; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pix_alpha_ptr     : PByte;
  x,y               : integer;
  d_width           : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        Exit;
      if (pt_pix_cnt=0) then
        Exit;
      SetLength(pt_pix_sht_arr,pt_pix_cnt);
      d_width           :=rct_ent.width-bmp_src_rct_clp.width;
      pt_pix_sht_arr_ptr:=Unaligned(@pt_pix_sht_arr[000000000000000000000000000000000000000000000000000000]);
      pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr [bmp_src_rct_clp.left+rct_ent.width*bmp_src_rct_clp.top]);
      for y:=0 to bmp_src_rct_clp.height-1 do
        begin
          for x:=0 to bmp_src_rct_clp.width-1 do
            begin
              if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<MAXBYTE) then
                begin
                      pt_pix_sht_arr_ptr^:=x;
                  Inc(pt_pix_sht_arr_ptr);
                end;
              Inc(pix_alpha_ptr,4);
            end;
          Inc(pix_alpha_ptr,d_width<<2);
        end;
    end;
end; {$endregion}
// color and alpha are in one bitmap
// NT - not transparent pixels;
procedure TFastImageProc.CrtNTShiftBmpO; {$ifdef Linux}[local];{$endif} {$region -fold}
var
       pix_color_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        Exit;
      if (nt_pix_cnt=0) then
        Exit;
      SetLength(nt_pix_sht_arr,nt_pix_cnt);
           pix_color_ptr:=Unaligned(@bmp_color_ptr [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*rct_ent.width+bmp_src_rct_clp.left]);
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000]);
      nt_pix_sht_arr_ptr:=Unaligned(@nt_pix_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          if (nt_pix_cnt_arr_ptr^<>0) then
            for x:=0 to bmp_src_rct_clp.width-1 do
              if (PRGBA(pix_color_ptr+x)^.a=MAXBYTE) then
                begin
                      nt_pix_sht_arr_ptr^:=x;
                  Inc(nt_pix_sht_arr_ptr);
                end;
          Inc        (nt_pix_cnt_arr_ptr);
          Inc(pix_color_ptr,rct_ent.width);
        end;
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImageProc.CrtPTShiftBmpO; {$ifdef Linux}[local];{$endif} {$region -fold}
var
       pix_color_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        Exit;
      if (pt_pix_cnt=0) then
        Exit;
      SetLength(pt_pix_sht_arr,pt_pix_cnt);
           pix_color_ptr:=Unaligned(@bmp_color_ptr [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*rct_ent.width+bmp_src_rct_clp.left]);
      pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr[ pt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000]);
      pt_pix_sht_arr_ptr:=Unaligned(@pt_pix_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          if (pt_pix_cnt_arr_ptr^<>0) then
            for x:=0 to bmp_src_rct_clp.width-1 do
              if (PRGBA(pix_color_ptr+x)^.a>0) and (PRGBA(pix_color_ptr+x)^.a<MAXBYTE) then
                begin
                      pt_pix_sht_arr_ptr^:=x;
                  Inc(pt_pix_sht_arr_ptr);
                end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc(pix_color_ptr,rct_ent.width);
        end;
    end;
end; {$endregion} {$endregion}

{Create array    of items shifts  in rows from array---} {$region -fold}
// NT - not transparent pixels;
procedure TFastImageProc.CrtNTShiftArrA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
       pix_alpha_ptr  : PInteger;
  nt_pix_cnt_arr_ptr  : PWord;
  nt_pix_sht_arr_ptr  : PWord;
  x,y,pix_cnt_in_a_row: integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (nt_pix_cnt=0) then
        Exit;
      if (nt_pix_cnt>Length(nt_pix_sht_arr)) or (nt_pix_sht_arr=Nil) or ((nt_pix_cnt_prev<nt_pix_cnt) and realloc_mem) then
        SetLength          (nt_pix_sht_arr,nt_pix_cnt);
           pix_alpha_ptr:=Unaligned(@bmp_alpha_ptr [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*rct_ent.width+bmp_src_rct_clp.left]);
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000]);
      nt_pix_sht_arr_ptr:=Unaligned(@nt_pix_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          if (nt_pix_cnt_arr_ptr^<>0) then
            begin
              pix_cnt_in_a_row:=0;
              for x:=NotIndexDWord(pix_alpha_ptr,bmp_src_rct_clp.width-1) to bmp_src_rct_clp.width-1 do
                if ((pix_alpha_ptr+x)^<>0) then
                  begin
                        nt_pix_sht_arr_ptr^:=x;
                    Inc(nt_pix_sht_arr_ptr);
                    Inc(pix_cnt_in_a_row);
                    if (pix_cnt_in_a_row=nt_pix_cnt_arr_ptr^) then
                      Break;
                  end;
            end;
          Inc(nt_pix_cnt_arr_ptr);
          Inc(pix_alpha_ptr,rct_ent.width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.CrtNTShiftArrB; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr                 : PByte;
//pix_alpha_ptr2                : PByte;
  nt_pix_cnt_arr_ptr            : PWord;
  nt_pix_sht_arr_ptr            : PWord;
  x,y,{z,}pix_cnt_in_a_row{,k,j}: integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (nt_pix_cnt=0) then
        Exit;
      if (nt_pix_cnt>Length(nt_pix_sht_arr)) or (nt_pix_sht_arr=Nil) or ((nt_pix_cnt_prev<nt_pix_cnt) and realloc_mem) then
        SetLength          (nt_pix_sht_arr,nt_pix_cnt);
      pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr2[(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*rct_ent.width+bmp_src_rct_clp.left]);
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000]);
      nt_pix_sht_arr_ptr:=Unaligned(@nt_pix_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          if (nt_pix_cnt_arr_ptr^<>0) then
            begin
              pix_cnt_in_a_row:=0;
              {{$ifdef win64}
              j             :=NotIndexByte(pix_alpha_ptr,bmp_src_rct_clp.width-1);
              k             :=((bmp_src_rct_clp.width-1-j)>>4)-1;
              pix_alpha_ptr2:=pix_alpha_ptr+j;
              for x:=0 to k do
                begin
                  if (NZByteCnt128(PRGBA04(pix_alpha_ptr2)^,{MSK0_128,}MSK1_128)<>0) then //if (PQWord(pix_alpha_ptr2)^<>0) then
                    for z:=0 to 15 do
                      if ((pix_alpha_ptr2+z)^<>0) then
                        begin
                              nt_pix_sht_arr_ptr^:=j+16*x+z;
                          Inc(nt_pix_sht_arr_ptr);
                          Inc(pix_cnt_in_a_row);
                          if (pix_cnt_in_a_row=nt_pix_cnt_arr_ptr^) then
                            Break;
                        end;
                  Inc(pix_alpha_ptr2,16);
                end;
              for x:=j+(k+1)<<4 to bmp_src_rct_clp.width-1 do
                if ((pix_alpha_ptr+x)^<>0) then
                  begin
                        nt_pix_sht_arr_ptr^:=x;
                    Inc(nt_pix_sht_arr_ptr);
                    Inc(pix_cnt_in_a_row);
                    if (pix_cnt_in_a_row=nt_pix_cnt_arr_ptr^) then
                      Break;
                  end;
              {$else}}
              for x:=NotIndexByte(pix_alpha_ptr,bmp_src_rct_clp.width-1) to bmp_src_rct_clp.width-1 do
                if ((pix_alpha_ptr+x)^<>0) then
                  begin
                        nt_pix_sht_arr_ptr^:=x;
                    Inc(nt_pix_sht_arr_ptr);
                    Inc(pix_cnt_in_a_row);
                    if (pix_cnt_in_a_row=nt_pix_cnt_arr_ptr^) then
                      Break;
                  end;
              //{$endif}
            end;
          Inc(nt_pix_cnt_arr_ptr);
          Inc(pix_alpha_ptr,rct_ent.width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.CrtNTShiftArrC; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr       : PInteger;
  nt_pix_cnt_arr_ptr  : PWord;
  nt_pix_sht_arr_ptr  : PWord;
  x,y,pix_cnt_in_a_row: integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (nt_pix_cnt=0) then
        Exit;
      if (nt_pix_cnt>Length(nt_pix_sht_arr)) or (nt_pix_sht_arr=Nil) or ((nt_pix_cnt_prev<nt_pix_cnt) and realloc_mem) then
        SetLength          (nt_pix_sht_arr,nt_pix_cnt);
      pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*rct_ent.width+bmp_src_rct_clp.left]);
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000]);
      nt_pix_sht_arr_ptr:=Unaligned(@nt_pix_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          if (nt_pix_cnt_arr_ptr^<>0) then
            begin
              pix_cnt_in_a_row:=0;
              for x:=IndexDWord(pix_alpha_ptr^,bmp_src_rct_clp.width-1,1) to bmp_src_rct_clp.width-1 do
                if ((pix_alpha_ptr+x)^=1) then
                  begin
                        nt_pix_sht_arr_ptr^:=x;
                    Inc(nt_pix_sht_arr_ptr);
                    Inc(pix_cnt_in_a_row);
                    if (pix_cnt_in_a_row=nt_pix_cnt_arr_ptr^) then
                      Break;
                  end;
            end;
          Inc(nt_pix_cnt_arr_ptr);
          Inc(pix_alpha_ptr,rct_ent.width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.CrtNTShiftArrD; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr       : PByte;
  nt_pix_cnt_arr_ptr  : PWord;
  nt_pix_sht_arr_ptr  : PWord;
  x,y,pix_cnt_in_a_row: integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (nt_pix_cnt=0) then
        Exit;
      if (nt_pix_cnt>Length(nt_pix_sht_arr)) or (nt_pix_sht_arr=Nil) or ((nt_pix_cnt_prev<nt_pix_cnt) and realloc_mem) then
        SetLength          (nt_pix_sht_arr,nt_pix_cnt);
      pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr2[(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*rct_ent.width+bmp_src_rct_clp.left]);
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000]);
      nt_pix_sht_arr_ptr:=Unaligned(@nt_pix_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          if (nt_pix_cnt_arr_ptr^<>0) then
            begin
              pix_cnt_in_a_row:=0;
              for x:=IndexByte(pix_alpha_ptr^,bmp_src_rct_clp.width-1,1) to bmp_src_rct_clp.width-1 do
                if ((pix_alpha_ptr+x)^=1) then
                  begin
                        nt_pix_sht_arr_ptr^:=x;
                    Inc(nt_pix_sht_arr_ptr);
                    Inc(pix_cnt_in_a_row);
                    if (pix_cnt_in_a_row=nt_pix_cnt_arr_ptr^) then
                      Break;
                  end;
            end;
          Inc(nt_pix_cnt_arr_ptr);
          Inc(pix_alpha_ptr,rct_ent.width);
        end;
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImageProc.CrtPTShiftArrA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr       : PInteger;
  pt_pix_cnt_arr_ptr  : PWord;
  pt_pix_sht_arr_ptr  : PWord;
  x,y,pix_cnt_in_a_row: integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (pt_pix_cnt=0) then
        Exit;
      if (pt_pix_cnt>Length(pt_pix_sht_arr)) or (pt_pix_sht_arr=Nil) or ((pt_pix_cnt_prev<pt_pix_cnt) and realloc_mem) then
        SetLength          (pt_pix_sht_arr,pt_pix_cnt);
      pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*rct_ent.width+bmp_src_rct_clp.left]);
      pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr[ pt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000]);
      pt_pix_sht_arr_ptr:=Unaligned(@pt_pix_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          if (pt_pix_cnt_arr_ptr^<>0) then
            begin
              pix_cnt_in_a_row:=0;
              for x:=NotIndexDWord(pix_alpha_ptr,bmp_src_rct_clp.width-1) to bmp_src_rct_clp.width-1 do
                if ((pix_alpha_ptr+x)^<>0) then
                  begin
                        pt_pix_sht_arr_ptr^:=x;
                    Inc(pt_pix_sht_arr_ptr);
                    Inc(pix_cnt_in_a_row);
                    if (pix_cnt_in_a_row=pt_pix_cnt_arr_ptr^) then
                      Break;
                  end;
            end;
          Inc(pt_pix_cnt_arr_ptr);
          Inc(pix_alpha_ptr,rct_ent.width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.CrtPTShiftArrB; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr       : PByte;
  pt_pix_cnt_arr_ptr  : PWord;
  pt_pix_sht_arr_ptr  : PWord;
  x,y,pix_cnt_in_a_row: integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (pt_pix_cnt=0) then
        Exit;
      if (pt_pix_cnt>Length(pt_pix_sht_arr)) or (pt_pix_sht_arr=Nil) or ((pt_pix_cnt_prev<pt_pix_cnt) and realloc_mem) then
        SetLength          (pt_pix_sht_arr,pt_pix_cnt);
      pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr2[(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*rct_ent.width+bmp_src_rct_clp.left]);
      pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr[ pt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000]);
      pt_pix_sht_arr_ptr:=Unaligned(@pt_pix_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          if (pt_pix_cnt_arr_ptr^<>0) then
            begin
              pix_cnt_in_a_row:=0;
              for x:=NotIndexByte(pix_alpha_ptr,bmp_src_rct_clp.width-1) to bmp_src_rct_clp.width-1 do
                if ((pix_alpha_ptr+x)^<>0) then
                  begin
                        pt_pix_sht_arr_ptr^:=x;
                    Inc(pt_pix_sht_arr_ptr);
                    Inc(pix_cnt_in_a_row);
                    if (pix_cnt_in_a_row=pt_pix_cnt_arr_ptr^) then
                      Break;
                  end;
            end;
          Inc(pt_pix_cnt_arr_ptr);
          Inc(pix_alpha_ptr,rct_ent.width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.CrtPTShiftArrC; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr       : PInteger;
  pt_pix_cnt_arr_ptr  : PWord;
  pt_pix_sht_arr_ptr  : PWord;
  x,y,pix_cnt_in_a_row: integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (pt_pix_cnt=0) then
        Exit;
      if (pt_pix_cnt>Length(pt_pix_sht_arr)) or (pt_pix_sht_arr=Nil) or ((pt_pix_cnt_prev<pt_pix_cnt) and realloc_mem) then
        SetLength          (pt_pix_sht_arr,pt_pix_cnt);
      pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*rct_ent.width+bmp_src_rct_clp.left]);
      pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr[ pt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000]);
      pt_pix_sht_arr_ptr:=Unaligned(@pt_pix_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          if (pt_pix_cnt_arr_ptr^<>0) then
            begin
              pix_cnt_in_a_row:=0;
              for x:=IndexDWord(pix_alpha_ptr^,bmp_src_rct_clp.width-1,1) to bmp_src_rct_clp.width-1 do
                if ((pix_alpha_ptr+x)^=1) then
                  begin
                        pt_pix_sht_arr_ptr^:=x;
                    Inc(pt_pix_sht_arr_ptr);
                    Inc(pix_cnt_in_a_row);
                    if (pix_cnt_in_a_row=pt_pix_cnt_arr_ptr^) then
                      Break;
                  end;
            end;
          Inc(pt_pix_cnt_arr_ptr);
          Inc(pix_alpha_ptr,rct_ent.width);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.CrtPTShiftArrD; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr       : PByte;
  pt_pix_cnt_arr_ptr  : PWord;
  pt_pix_sht_arr_ptr  : PWord;
  x,y,pix_cnt_in_a_row: integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (pt_pix_cnt=0) then
        Exit;
      if (pt_pix_cnt>Length(pt_pix_sht_arr)) or (pt_pix_sht_arr=Nil) or ((pt_pix_cnt_prev<pt_pix_cnt) and realloc_mem) then
        SetLength          (pt_pix_sht_arr,pt_pix_cnt);
      pix_alpha_ptr     :=Unaligned(@bmp_alpha_ptr2[(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*rct_ent.width+bmp_src_rct_clp.left]);
      pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr[ pt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000]);
      pt_pix_sht_arr_ptr:=Unaligned(@pt_pix_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          if (pt_pix_cnt_arr_ptr^<>0) then
            begin
              pix_cnt_in_a_row:=0;
              for x:=IndexByte(pix_alpha_ptr^,bmp_src_rct_clp.width-1,1) to bmp_src_rct_clp.width-1 do
                if ((pix_alpha_ptr+x)^=1) then
                  begin
                        pt_pix_sht_arr_ptr^:=x;
                    Inc(pt_pix_sht_arr_ptr);
                    Inc(pix_cnt_in_a_row);
                    if (pix_cnt_in_a_row=pt_pix_cnt_arr_ptr^) then
                      Break;
                  end;
            end;
          Inc(pt_pix_cnt_arr_ptr);
          Inc(pix_alpha_ptr,rct_ent.width);
        end;
    end;
end; {$endregion} {$endregion}

{Create array    of items indices in rows from array---} {$region -fold}
procedure TFastImageProc.CrtNTCntIndArr; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_cnt_ind_arr_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
//nt_pix_clm_arr_ptr: PPtPosW;
//nt_pix_clm_end    : boolean=False;
  i                 : integer;
  s                 : longword=0;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        Exit;
      if (nt_pix_cnt=0) then
        Exit;
      SetLength(nt_cnt_ind_arr,bmp_src_rct_clp.height);
    //SetLength(nt_pix_clm_arr,nt_pix_clm);
      nt_cnt_ind_arr_ptr:=Unaligned(@nt_cnt_ind_arr[0]);
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[0]);
    //nt_pix_clm_arr_ptr:=Unaligned(@nt_pix_clm_arr[0]);
    //Dec(nt_pix_clm_arr_ptr);
      for i:=0 to bmp_src_rct_clp.height-1 do
        begin
                  nt_cnt_ind_arr_ptr^:=s;
          Inc    (nt_cnt_ind_arr_ptr);
          s+=     nt_pix_cnt_arr_ptr^;
          {if     (nt_pix_cnt_arr_ptr^<>0) then
            begin
              if (nt_pix_clm_end=False) then
                begin
                  nt_pix_clm_arr_ptr   +=1;
                  nt_pix_clm_arr_ptr^.x:=i;
                  nt_pix_clm_arr_ptr^.y+=1;
                  nt_pix_clm_end       :=True;
                end
              else
              if (nt_pix_clm_end=True) then
                  nt_pix_clm_arr_ptr^.y+=1;
            end
          else
                  nt_pix_clm_end:=False;}
          Inc    (nt_pix_cnt_arr_ptr);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.CrtPTCntIndArr; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_cnt_ind_arr_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
//pt_pix_clm_arr_ptr: PPtPosW;
//pt_pix_clm_end    : boolean=False;
  i                 : integer;
  s                 : longword=0;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) then
        Exit;
      if (pt_pix_cnt=0) then
        Exit;
      SetLength(pt_cnt_ind_arr,bmp_src_rct_clp.height);
    //SetLength(pt_pix_clm_arr,pt_pix_clm);
      pt_cnt_ind_arr_ptr:=Unaligned(@pt_cnt_ind_arr[0]);
      pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr[0]);
    //pt_pix_clm_arr_ptr:=Unaligned(@pt_pix_clm_arr[0]);
    //Dec(pt_pix_clm_arr_ptr);
      for i:=0 to bmp_src_rct_clp.height-1 do
        begin
                  pt_cnt_ind_arr_ptr^:=s;
          Inc    (pt_cnt_ind_arr_ptr);
          s+=     pt_pix_cnt_arr_ptr^;
          {if     (pt_pix_cnt_arr_ptr^<>0) then
            begin
              if (pt_pix_clm_end=False) then
                begin
                  pt_pix_clm_arr_ptr   +=1;
                  pt_pix_clm_arr_ptr^.x:=i;
                  pt_pix_clm_arr_ptr^.y+=1;
                  pt_pix_clm_end       :=True;
                end
              else
              if (pt_pix_clm_end=True) then
                  pt_pix_clm_arr_ptr^.y+=1;
            end
          else
                  pt_pix_clm_end:=False;}
          Inc    (pt_pix_cnt_arr_ptr);
        end;
    end;
end; {$endregion} {$endregion}

{Store color     of current layer         from bmp/arr-} {$region -fold}
// NT - not transparent pixels;
{store color channel}
procedure TFastImageProc.StrNTColorBmpA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  nt_pix_ccl_arr_ptr: PInteger;
  x,y               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (nt_pix_cnt=0) then
        Exit;
      SetLength(nt_pix_ccl_arr,nt_pix_cnt);
       first_row_pix_ptr:=Unaligned(@bmp_color_ptr [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*rct_ent.width+bmp_src_rct_clp.left]);
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000]);
      nt_pix_sht_arr_ptr:=Unaligned(@nt_pix_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      nt_pix_ccl_arr_ptr:=Unaligned(@nt_pix_ccl_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          for x:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
                      nt_pix_ccl_arr_ptr^:=
                     (nt_pix_sht_arr_ptr^+first_row_pix_ptr)^;
              Inc    (nt_pix_sht_arr_ptr);
              Inc    (nt_pix_ccl_arr_ptr);
            end;
          Inc        (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,rct_ent.width);
        end;
    end;
end; {$endregion}
// PT - partly transparent pixels;
{store color channel}
procedure TFastImageProc.StrPTColorBmpA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  x,y               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (pt_pix_cnt=0) then
        Exit;
      SetLength(pt_pix_ccl_arr,pt_pix_cnt);
       first_row_pix_ptr:=Unaligned(@bmp_color_ptr [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*rct_ent.width+bmp_src_rct_clp.left]);
      pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr[ pt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000]);
      pt_pix_sht_arr_ptr:=Unaligned(@pt_pix_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      pt_pix_ccl_arr_ptr:=Unaligned(@pt_pix_ccl_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
                      pt_pix_ccl_arr_ptr^:=
                     (pt_pix_sht_arr_ptr^+first_row_pix_ptr)^;
              Inc    (pt_pix_sht_arr_ptr);
              Inc    (pt_pix_ccl_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,rct_ent.width);
        end;
    end;
end; {$endregion}
//** color and alpha are in separate bitmaps
{store alpha channel into byte array---}
procedure TFastImageProc.StrPTAlphaArrS; {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PByte;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (pt_pix_cnt=0) then
        Exit;
      SetLength(pt_pix_acl_arr,pt_pix_cnt);
       first_row_pix_ptr:=Unaligned(@bmp_alpha_ptr [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*rct_ent.width+bmp_src_rct_clp.left]);
      pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr[ pt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000]);
      pt_pix_sht_arr_ptr:=Unaligned(@pt_pix_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      pt_pix_acl_arr_ptr:=Unaligned(@pt_pix_acl_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
                      pt_pix_acl_arr_ptr^:=
                    ((pt_pix_sht_arr_ptr^<<2)+first_row_pix_ptr)^;
              Inc    (pt_pix_sht_arr_ptr);
              Inc    (pt_pix_acl_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,rct_ent.width<<2);
        end;
    end;
end; {$endregion}
{store alpha channel into color channel}
procedure TFastImageProc.StrPTAlphaBmpS; {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PByte;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  x,y               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (pt_pix_cnt=0) then
        Exit;
       first_row_pix_ptr:=Unaligned(@bmp_alpha_ptr [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*rct_ent.width+bmp_src_rct_clp.left]);
      pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr[ pt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000]);
      pt_pix_sht_arr_ptr:=Unaligned(@pt_pix_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      pt_pix_ccl_arr_ptr:=Unaligned(@pt_pix_ccl_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
                      pt_pix_ccl_arr_ptr^+=
                    ((pt_pix_sht_arr_ptr^<<2)+first_row_pix_ptr)^<<24;
              Inc    (pt_pix_sht_arr_ptr);
              Inc    (pt_pix_ccl_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,rct_ent.width<<2);
        end;
    end;
end; {$endregion}
//** color and alpha are in one bitmap
{store alpha channel into byte array---}
procedure TFastImageProc.StrPTAlphaArrO; {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (pt_pix_cnt=0) then
        Exit;
      SetLength(pt_pix_acl_arr,pt_pix_cnt);
       first_row_pix_ptr:=Unaligned(@bmp_color_ptr [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*rct_ent.width+bmp_src_rct_clp.left]);
      pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr[ pt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000]);
      pt_pix_sht_arr_ptr:=Unaligned(@pt_pix_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      pt_pix_acl_arr_ptr:=Unaligned(@pt_pix_acl_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
                      pt_pix_acl_arr_ptr^:=
                     (pt_pix_sht_arr_ptr^+first_row_pix_ptr)^>>24;
              Inc    (pt_pix_sht_arr_ptr);
              Inc    (pt_pix_acl_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,rct_ent.width);
        end;
    end;
end; {$endregion}
{store alpha channel into color channel}
procedure TFastImageProc.StrPTAlphaBmpO; {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  x,y               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (pt_pix_cnt=0) then
        Exit;
       first_row_pix_ptr:=Unaligned(@bmp_color_ptr [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*rct_ent.width+bmp_src_rct_clp.left]);
      pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr[ pt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000]);
      pt_pix_sht_arr_ptr:=Unaligned(@pt_pix_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      pt_pix_ccl_arr_ptr:=Unaligned(@pt_pix_ccl_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
                      pt_pix_ccl_arr_ptr^:=
                     (pt_pix_sht_arr_ptr^+first_row_pix_ptr)^;
              Inc    (pt_pix_sht_arr_ptr);
              Inc    (pt_pix_ccl_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,rct_ent.width);
        end;
    end;
end; {$endregion} {$endregion}

{Store color     of lower   layer         from bitmap--} {$region -fold}
// NT - not transparent pixels;
procedure TFastImageProc.StrNTLowerBmpA(const fast_image_data_ptr_:PFastImageData); {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  nt_pix_cll_arr_ptr: PInteger;
  x,y               : integer;
begin
  with fast_image_data_ptr_{fast_image_data_ptr0}^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (nt_pix_cnt=0) then
        Exit;
      if (nt_pix_cnt>Length(nt_pix_cll_arr)) or (nt_pix_cll_arr=Nil) then
        SetLength          (nt_pix_cll_arr,nt_pix_cnt);
       first_row_pix_ptr:=@bmp_bkgnd_ptr [(nt_pix_arr_row_mrg_top+fast_image_data_ptr_^.rct_ent.top)*bmp_bkgnd_width+fast_image_data_ptr_^.rct_ent.left];
      nt_pix_cnt_arr_ptr:=@nt_pix_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000000000000000000000000000000000];
      nt_pix_sht_arr_ptr:=@nt_pix_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000];
      nt_pix_cll_arr_ptr:=@nt_pix_cll_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000];
      for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          for x:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
                      nt_pix_cll_arr_ptr^:=
                     (nt_pix_sht_arr_ptr^+first_row_pix_ptr)^;
              Inc    (nt_pix_sht_arr_ptr);
              Inc    (nt_pix_cll_arr_ptr);
            end;
          Inc        (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImageProc.StrPTLowerBmpA(const fast_image_data_ptr_:PFastImageData); {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_cll_arr_ptr: PInteger;
  x,y               : integer;
begin
  with fast_image_data_ptr_{fast_image_data_ptr0}^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (pt_pix_cnt=0) then
        Exit;
      if (pt_pix_cnt>Length(pt_pix_cll_arr)) or (pt_pix_cll_arr=Nil) then
        SetLength          (pt_pix_cll_arr,pt_pix_cnt);
       first_row_pix_ptr:=@bmp_bkgnd_ptr [(pt_pix_arr_row_mrg_top+fast_image_data_ptr_^.rct_ent.top)*bmp_bkgnd_width+fast_image_data_ptr_^.rct_ent.left];
      pt_pix_cnt_arr_ptr:=@pt_pix_cnt_arr[ pt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000000000000000000000000000000000];
      pt_pix_sht_arr_ptr:=@pt_pix_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000];
      pt_pix_cll_arr_ptr:=@pt_pix_cll_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000];
      for y:=0 to bmp_src_rct_clp.height- pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
                      pt_pix_cll_arr_ptr^:=
                     (pt_pix_sht_arr_ptr^+first_row_pix_ptr)^;
              Inc    (pt_pix_sht_arr_ptr);
              Inc    (pt_pix_cll_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bkgnd_width);
        end;
    end;
end; {$endregion}
// store alpha from byte array;
procedure TFastImageProc.StrPTLowerArrA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_cll_arr_ptr: PInteger;
  pt_pix_acl_arr_ptr: PByte;
  i                 : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      pt_pix_cll_arr_ptr:=Unaligned(@pt_pix_cll_arr[0]);
      pt_pix_acl_arr_ptr:=Unaligned(@pt_pix_acl_arr[0]);
      for i:=0 to pt_pix_cnt-1 do
        begin
                  pt_pix_cll_arr_ptr^+=
                  pt_pix_acl_arr_ptr^<<24;
          Inc    (pt_pix_cll_arr_ptr);
          Inc    (pt_pix_acl_arr_ptr);
        end;
    end;
end; {$endregion} {$endregion}

{Store value     of current layer         from array---} {$region -fold}
procedure TFastImageProc.StrNTValueArrA; {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  nt_pix_val_arr_ptr: PInteger;
  x,y               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (nt_pix_cnt=0) then
        Exit;
      if (nt_pix_cnt>Length(nt_pix_val_arr)) or (nt_pix_val_arr=Nil) then
        SetLength          (nt_pix_val_arr,nt_pix_cnt);
       first_row_pix_ptr:=Unaligned(@bmp_value_ptr [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*rct_ent.width+bmp_src_rct_clp.left]);
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000]);
      nt_pix_sht_arr_ptr:=Unaligned(@nt_pix_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      nt_pix_val_arr_ptr:=Unaligned(@nt_pix_val_arr[0000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height- nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          for x:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
                      nt_pix_val_arr_ptr^:=
                     (nt_pix_sht_arr_ptr^+first_row_pix_ptr)^;
              Inc    (nt_pix_sht_arr_ptr);
              Inc    (nt_pix_val_arr_ptr);
            end;
          Inc        (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,rct_ent.width);
        end;
    end;
end; {$endregion} {$endregion}

{Set chess order of alpha channel in rows from bitmap--} {$region -fold}
// calculation of image sides parity}
procedure TFastImageProc.CalcSidesParity; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      width_parity :=not Odd(bmp_src_rct_clp.width );
      height_parity:=not Odd(bmp_src_rct_clp.height);
    end;
end; {$endregion}
// color and alpha are in separate bitmaps
// NT - not transparent pixels;
procedure TFastImageProc.SetNTChessBmpS0; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr: PInteger;
  x,y,w,h      : integer;
  d_width      : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (bmp_src_rct_clp.width*bmp_src_rct_clp.height<6) then
        Exit;
      w            :=(bmp_src_rct_clp.width >>1)-1;
      h            :=(bmp_src_rct_clp.height>>1)-1;
      d_width      := rct_ent.width-          bmp_src_rct_clp.width;
      pix_alpha_ptr:=Unaligned(@bmp_alpha_ptr[bmp_src_rct_clp.left+rct_ent.width*bmp_src_rct_clp.top]);
      if width_parity then
        begin
          if height_parity then
            for y:=0 to h do
              begin
                for x:=0 to w do
                  begin
                    if (pix_alpha_ptr^=$FFFFFF) then
                      pix_alpha_ptr^:=$000000;
                    Inc(pix_alpha_ptr,2);
                  end;
                Inc(pix_alpha_ptr,d_width);
                Dec(pix_alpha_ptr);
                for x:=0 to w do
                  begin
                    if (pix_alpha_ptr^=$FFFFFF) then
                      pix_alpha_ptr^:=$000000;
                    Inc(pix_alpha_ptr,2);
                  end;
                Inc(pix_alpha_ptr,d_width);
                Inc(pix_alpha_ptr);
              end
          else
            begin
              for x:=0 to w do
                begin
                  if (pix_alpha_ptr^=$FFFFFF) then
                    pix_alpha_ptr^:=$000000;
                  Inc(pix_alpha_ptr,2);
                end;
              Inc(pix_alpha_ptr,d_width);
            end;
        end
      else
        for y:=0 to bmp_src_rct_clp.height-1 do
          begin
            for x:=0 to w do
              begin
                if (pix_alpha_ptr^=$FFFFFF) then
                  pix_alpha_ptr^:=$000000;
                Inc(pix_alpha_ptr,2);
              end;
            Inc(pix_alpha_ptr,d_width);
          end;
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImageProc.SetPTChessBmpS0; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr: PByte;
  x,y,w,h      : integer;
  d_width      : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (bmp_src_rct_clp.width*bmp_src_rct_clp.height<6) then
        Exit;
      w            :=(bmp_src_rct_clp.width >>1)-1;
      h            :=(bmp_src_rct_clp.height>>1)-1;
      d_width      := rct_ent.width-          bmp_src_rct_clp.width;
      pix_alpha_ptr:=Unaligned(@bmp_alpha_ptr[bmp_src_rct_clp.left+rct_ent.width*bmp_src_rct_clp.top]);
      if width_parity then
        begin
          if height_parity then
            for y:=0 to h do
              begin
                for x:=0 to w do
                  begin
                    if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<MAXBYTE) then
                      pix_alpha_ptr^:=$000000;
                    Inc(pix_alpha_ptr,8);
                  end;
                Inc(pix_alpha_ptr,d_width<<2);
                Dec(pix_alpha_ptr,4);
                for x:=0 to w do
                  begin
                    if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<MAXBYTE) then
                      pix_alpha_ptr^:=$000000;
                    Inc(pix_alpha_ptr,8);
                  end;
                Inc(pix_alpha_ptr,d_width<<2);
                Inc(pix_alpha_ptr,4);
              end
          else
            begin
              for x:=0 to w do
                begin
                  if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<MAXBYTE) then
                    pix_alpha_ptr^:=$000000;
                  Inc(pix_alpha_ptr,8);
                end;
              Inc(pix_alpha_ptr,d_width<<2);
            end;
        end
      else
        for y:=0 to bmp_src_rct_clp.height-1 do
          begin
            for x:=0 to w do
              begin
                if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<MAXBYTE) then
                  pix_alpha_ptr^:=$000000;
                Inc(pix_alpha_ptr,8);
              end;
            Inc(pix_alpha_ptr,d_width<<2);
          end;
    end;
end; {$endregion}
// color and alpha are in one bitmap
// NT - not transparent pixels;
procedure TFastImageProc.SetNTChessBmpO0; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr: PInteger;
  x,y,w,h      : integer;
  d_width      : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (bmp_src_rct_clp.width*bmp_src_rct_clp.height<6) then
        Exit;
      w            :=(bmp_src_rct_clp.width >>1)-1;
      h            :=(bmp_src_rct_clp.height>>1)-1;
      d_width      := rct_ent.width-          bmp_src_rct_clp.width;
      pix_alpha_ptr:=Unaligned(@bmp_color_ptr[bmp_src_rct_clp.left+rct_ent.width*bmp_src_rct_clp.top]);
      if width_parity then
        begin
          if height_parity then
            for y:=0 to h do
              begin
                for x:=0 to w do
                  begin
                    if (pix_alpha_ptr^>>24=MAXBYTE) then
                      pix_alpha_ptr^:=0;
                    Inc(pix_alpha_ptr,2);
                  end;
                Inc(pix_alpha_ptr,d_width);
                Dec(pix_alpha_ptr);
                for x:=0 to w do
                  begin
                    if (pix_alpha_ptr^>>24=MAXBYTE) then
                      pix_alpha_ptr^:=0;
                    Inc(pix_alpha_ptr,2);
                  end;
                Inc(pix_alpha_ptr,d_width);
                Inc(pix_alpha_ptr);
              end
          else
            begin
              for x:=0 to w do
                begin
                  if (pix_alpha_ptr^>>24=MAXBYTE) then
                    pix_alpha_ptr^:=0;
                  Inc(pix_alpha_ptr,2);
                end;
              Inc(pix_alpha_ptr,d_width);
            end;
        end
      else
        for y:=0 to bmp_src_rct_clp.height-1 do
          begin
            for x:=0 to w do
              begin
                if (pix_alpha_ptr^>>24=MAXBYTE) then
                  pix_alpha_ptr^:=0;
                Inc(pix_alpha_ptr,2);
              end;
            Inc(pix_alpha_ptr,d_width);
          end;
    end;
end; {$endregion}
// PT - partly transparent pixels;
procedure TFastImageProc.SetPTChessBmpO0; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_alpha_ptr: PInteger;
  x,y,w,h      : integer;
  d_width      : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (bmp_src_rct_clp.width=0) or (bmp_src_rct_clp.height=0) or (bmp_src_rct_clp.width*bmp_src_rct_clp.height<6) then
        Exit;
      w            :=(bmp_src_rct_clp.width >>1)-1;
      h            :=(bmp_src_rct_clp.height>>1)-1;
      d_width      := rct_ent.width-          bmp_src_rct_clp.width;
      pix_alpha_ptr:=Unaligned(@bmp_color_ptr[bmp_src_rct_clp.left+rct_ent.width*bmp_src_rct_clp.top]);
      if width_parity then
        begin
          if height_parity then
            for y:=0 to h do
              begin
                for x:=0 to w do
                  begin
                    if (pix_alpha_ptr^>0) and (pix_alpha_ptr^<MAXBYTE) then
                      pix_alpha_ptr^:=0;
                    Inc(pix_alpha_ptr,2);
                  end;
                Inc(pix_alpha_ptr,d_width);
                Dec(pix_alpha_ptr);
                for x:=0 to w do
                  begin
                    if (pix_alpha_ptr^>>24>0) and (pix_alpha_ptr^>>24<MAXBYTE) then
                      pix_alpha_ptr^:=0;
                    Inc(pix_alpha_ptr,2);
                  end;
                Inc(pix_alpha_ptr,d_width);
                Inc(pix_alpha_ptr);
              end
          else
            begin
              for x:=0 to w do
                begin
                  if (pix_alpha_ptr^>>24>0) and (pix_alpha_ptr^>>24<MAXBYTE) then
                    pix_alpha_ptr^:=0;
                  Inc(pix_alpha_ptr,2);
                end;
              Inc(pix_alpha_ptr,d_width);
            end;
        end
      else
        for y:=0 to bmp_src_rct_clp.height-1 do
          begin
            for x:=0 to w do
              begin
                if (pix_alpha_ptr^>>24>0) and (pix_alpha_ptr^>>24<MAXBYTE) then
                  pix_alpha_ptr^:=0;
                Inc(pix_alpha_ptr,2);
              end;
            Inc(pix_alpha_ptr,d_width);
          end;
    end;
end; {$endregion} {$endregion}

{Create array of tiles bounding rectangles-------------} {$region -fold}
procedure TFastImageProc.CrtRectArr; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    SetLength(rect_src_arr,tiles_cnt);
end; {$endregion} {$endregion}

{CSR-image compression---------------------------------} {$region -fold}
// img. kind: 000:
procedure TFastImageProc.CmpProc000 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // NT - not transparent pixels;
  CrtNTCountBmpO;
  CrtNTShiftBmpO;
  CrtNTCntIndArr;
  StrNTColorBmpA;
  // PT - partly transparent pixels;
  CrtPTCountBmpO;
  CrtPTShiftBmpO;
  CrtPTCntIndArr;
  StrPTColorBmpA;
  // store alpha channel;
  StrPTAlphaArrO;
end; {$endregion}
// img. kind: 001:
procedure TFastImageProc.CmpProc001 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // NT - not transparent pixels;
  CrtNTCountBmpO;
  CrtNTShiftBmpO;
  CrtNTCntIndArr;
  StrNTColorBmpA;
end; {$endregion}
// img. kind: 002:
procedure TFastImageProc.CmpProc002 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // PT - partly transparent pixels;
  CrtPTCountBmpO;
  CrtPTCntIndArr;
  CrtPTShiftBmpO;
  StrPTColorBmpA;
  // store alpha channel;
  StrPTAlphaArrO;
end; {$endregion}
// img. kind: 003: empty:
procedure TFastImageProc.CmpProc003 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {do nothing}
end; {$endregion}
// img. kind: 004: empty:
procedure TFastImageProc.CmpProc004 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {do nothing}
end; {$endregion}
// img. kind: 005:
procedure TFastImageProc.CmpProc005 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // NT - not transparent pixels;
  CrtNTCountBmpO;
  CrtNTCntIndArr;
  CrtNTShiftBmpO;
  // PT - partly transparent pixels;
  CrtPTCountBmpO;
  CrtPTCntIndArr;
  CrtPTShiftBmpO;
  // store alpha channel;
  StrPTAlphaArrO;
end; {$endregion}
// img. kind: 006:
procedure TFastImageProc.CmpProc006 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // NT - not transparent pixels;
  CrtNTCountBmpO;
  CrtNTCntIndArr;
  CrtNTShiftBmpO;
end; {$endregion}
// img. kind: 007:
procedure TFastImageProc.CmpProc007 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // PT - partly transparent pixels;
  CrtPTCountBmpO;
  CrtPTCntIndArr;
  CrtPTShiftBmpO;
  // store alpha channel;
  StrPTAlphaArrO;
end; {$endregion}
// img. kind: 008: empty:
procedure TFastImageProc.CmpProc008 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {do nothing}
end; {$endregion}
// img. kind: 009:
procedure TFastImageProc.CmpProc009 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {do nothing}
end; {$endregion}
// img. kind: 010:
procedure TFastImageProc.CmpProc010 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {do nothing}
end; {$endregion}
// img. kind: 011:
procedure TFastImageProc.CmpProc011 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      // NT - not transparent pixels;
      if (bmp_alpha_ptr2=Nil) then // byte mode - off:
        begin
          if (not remove_brunching) then
            CrtNTCountArrA
          else
            CrtNTCountArrC;
          if (not better_quality) then
            CrtNTShiftArrA
          else
            CrtNTShiftArrC;
          CrtNTCntIndArr;
          if need_store_value then
            StrNTValueArrA;
          //StrNTLowerBmpA;
        end
      else // byte mode - on:
        begin
          if (not remove_brunching) then
            CrtNTCountArrB
          else
            CrtNTCountArrD;
          if (not better_quality) then
            CrtNTShiftArrB
          else
            CrtNTShiftArrD;
          CrtNTCntIndArr;
          //StrNTLowerBmpA;
        end;
      {// PT - partly transparent pixels;
      CrtPTCountArrA;
      CrtPTCntIndArr;
      CrtPTShiftArrA;
      // store alpha channel;
      StrPTAlphaArrO;}
    end;
end; {$endregion}
// img. kind: 012:
procedure TFastImageProc.CmpProc012 ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // NT - not transparent(not black!) pixels;
  CrtNTCountArrA;
  CrtNTCntIndArr;
  CrtNTShiftArrA;
end; {$endregion}
// Procedures Table Init.:
procedure TFastImageProc.CmpProcInit; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  {Image Description} {$region -fold}
  {
    ----------------Image Has Alpha Channel And Color Channel---------------
    0:
    image has:     not monochrome alpha channel,
                   not monochrome color channel,
    count of fully not transparent pixels>0;
    count of partly    transparent pixels>0;

    1:
    image has:     not monochrome alpha channel,
                   not monochrome color channel,
    count of fully not transparent pixels>0;
    count of partly    transparent pixels=0;

    2:
    image has:     not monochrome alpha channel,
                   not monochrome color channel,
    count of fully not transparent pixels=0;
    count of partly    transparent pixels>0;

    3:
    image has:         monochrome alpha channel(white, not transparent),
                   not monochrome color channel,
    count of fully not transparent pixels>0;
    count of partly    transparent pixels=0;

    4:
    image has:         monochrome alpha channel(transparent),
                   not monochrome color channel,
    count of fully not transparent pixels=0;
    count of partly    transparent pixels>0;


    ----------------------Image Has Only Alpha Channel----------------------
    5:
    image has:     not monochrome alpha channel,
                               no color channel,
    count of fully not transparent pixels>0;
    count of partly    transparent pixels>0;

    6:
    image has:     not monochrome alpha channel,
                               no color channel,
    count of fully not transparent pixels>0;
    count of partly    transparent pixels=0;

    7:
    image has:     not monochrome alpha channel,
                               no color channel,
    count of fully not transparent pixels=0;
    count of partly    transparent pixels>0;

    8:
    image has:         monochrome alpha channel(white, not transparent),
                               no color channel,
    count of fully not transparent pixels>0;
    count of partly    transparent pixels=0;

    9:
    image has:         monochrome alpha channel(transparent),
                               no color channel,
    count of fully not transparent pixels=0;
    count of partly    transparent pixels>0;


    --------------Image Has No Alpha Channel And Color Channel--------------
    10:
    image has:      no alpha channel(black, invisible),
                    no color channel,
    count of fully not transparent pixels=0;
    count of partly    transparent pixels=0;


    --------------------------Image is Value Array--------------------------
    11:
    count of fully not transparent pixels>0;
    count of partly    transparent pixels>0;

    --------------------------Image is Mask--------------------------
    12:
    count of fully not transparent pixels>0;
    count of partly    transparent pixels=0;
  } {$endregion}

  // img. kind: 000:
  CmpProc[000]:=@CmpProc000;
  // img. kind: 001:
  CmpProc[001]:=@CmpProc001;
  // img. kind: 002:
  CmpProc[002]:=@CmpProc002;
  // img. kind: 003:
  CmpProc[003]:=@CmpProc003;
  // img. kind: 004:
  CmpProc[004]:=@CmpProc004;
  // img. kind: 005:
  CmpProc[005]:=@CmpProc005;
  // img. kind: 006:
  CmpProc[006]:=@CmpProc006;
  // img. kind: 007:
  CmpProc[007]:=@CmpProc007;
  // img. kind: 008:
  CmpProc[008]:=@CmpProc008;
  // img. kind: 009:
  CmpProc[009]:=@CmpProc009;
  // img. kind: 010:
  CmpProc[010]:=@CmpProc010;
  // img. kind: 011:
  CmpProc[011]:=@CmpProc011;
  // img. kind: 012:
  CmpProc[012]:=@CmpProc012;

end; {$endregion}

// Final image compression:
procedure TFastImageProc.ImgToCImg  ; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      DetImageKind;
      CmpProc[img_kind];
      SetSdrType(fast_image_data_ptr0^);
      SdrProcInd(fast_image_data_ptr0^);
    end;
end; {$endregion}

{$endregion}

{CSR-image drawing-------------------------------------} {$region -fold}

{Regular  floodFill------------------------------------} {$region -fold}

// NT - not transparent pixels:

{Auxiliary procedure}
procedure TFastImageProc.RegNTResVar0 (                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b0,b1: byte;
begin
  with fast_image_data_ do
    begin
      b0      :=Byte(img_inv_type in [0,1]);
      b1      :=Byte(img_inv_type in [1,3]);
      res_var0:=Max2(               fast_image_data_ptr_^.nt_pix_arr_row_mrg_top,rct_src.top);
      res_var1:=                    fast_image_data_ptr_^.nt_cnt_ind_arr[res_var0];
      res_var2:=Min2(rct_ent.height-fast_image_data_ptr_^.nt_pix_arr_row_mrg_btm,rct_src.bottom)-res_var0-1;
      res_var3:=2*b0-1;
      res_var4:=res_var3*res_var0+b0*rct_ent.top+(1-b0)*(rct_ent.bottom-1);
      res_var5:=res_var3*bmp_bkgnd_width;
      res_var6:=rct_dst.left+b1*(rct_src.width-1);
      res_var7:=res_var4*bmp_bkgnd_width+res_var6;
      res_var8:=1-2*b1;
    end;
end; {$endregion}
procedure TFastImageProc.RegNTResVar1 (                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b0: byte;
begin
  with fast_image_data_,fip_scale_data_var1 do
    begin
        b0      :=Byte(img_inv_type in [0,1]);
        res_var3:=2*b0-1;
        res_var0:=Max2(               rct_src_mrg.top   ,Trunc((   b0 *rct_clp_ptr^.top+(1-b0)*rct_clp_ptr^.bottom-m1)/(res_var3*scl_mul.y))+(1-b0));
        res_var2:=Min2(rct_ent.height-rct_src_mrg.bottom,Trunc(((1-b0)*rct_clp_ptr^.top+   b0 *rct_clp_ptr^.bottom-m1)/(res_var3*scl_mul.y))+(1-b0))-res_var0{-1};
      if         (fast_image_data_ptr_^.nt_cnt_ind_arr<>Nil) then
        res_var1:=fast_image_data_ptr_^.nt_cnt_ind_arr[res_var0];
    end;
end; {$endregion}
procedure TFastImageProc.RegNTResVar2 (                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b0: byte;
begin
  with fast_image_data_,fip_scale_data_var1 do
    begin
      b0      :=Byte(img_inv_type in [0,1]);
      res_var3:=2*b0-1;
      res_var0:=Max2(               Max2(fast_image_data_ptr_^.nt_pix_arr_row_mrg_top,rct_src_mrg.top   ),Trunc((   b0 *rct_clp_ptr^.top+(1-b0)*rct_clp_ptr^.bottom-m1)/(res_var3*scl_mul.y))+(1-b0));
      res_var2:=Min2(rct_ent.height-Max2(fast_image_data_ptr_^.nt_pix_arr_row_mrg_btm,rct_src_mrg.bottom),Trunc(((1-b0)*rct_clp_ptr^.top+   b0 *rct_clp_ptr^.bottom-m1)/(res_var3*scl_mul.y))+(1-b0))-res_var0{-1};
      res_var1:=                         fast_image_data_ptr_^.nt_cnt_ind_arr[res_var0];
    end;
end; {$endregion}
procedure TFastImageProc.RegNTResVar3 (                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b1: byte;
begin
  with fast_image_data_,fip_scale_data_var1 do
    begin
      b1       :=Byte(img_inv_type in [1,3]);
      res_var8 :=1-2*b1;
      res_var9 :=((1-b1)*rct_clp_ptr^.left+(  b1)*rct_clp_ptr^.right-m0)/(res_var8*scl_mul.x);
      res_var10:=((  b1)*rct_clp_ptr^.left+(1-b1)*rct_clp_ptr^.right-m0)/(res_var8*scl_mul.x);
    end;
end; {$endregion}
procedure TFastImageProc.SclNTResVar0 (                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,fip_scale_data_var0 do
    begin
      rct_ent_left:=                                                                          rct_ent.left<<15;
      _scl_mul_x  :=Trunc(ONE_SHL_15* scl_mul.x);
      _scl_mul_y  :=Trunc(ONE_SHL_15* scl_mul.y);
      d1          :=     (ONE_SHL_15-_scl_mul_x)*                                             rct_ent.left;
      d2          :=     (ONE_SHL_15-_scl_mul_y)*                                             rct_ent.top;
      scl_mul_x   :=                 _scl_mul_x<<1;
      scl_mul_y   :=                 _scl_mul_y<<1;
      r1          :=                  scl_mul_x*(                                             rct_ent.left)+d1<<1;
      v3          :=                  scl_mul_y*(fast_image_data_ptr_^.nt_pix_arr_row_mrg_top+rct_ent.top )+d2<<1;
      g2          :=                 _scl_mul_y* fast_image_data_ptr_^.nt_pix_arr_row_mrg_top+rct_ent.top<<15;
    end;
end; {$endregion}
procedure TFastImageProc.SclNTResVar1 (                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,fip_scale_data_var1 do
    begin
      m0:=scl_mul.x*(rct_ent.left+Byte(img_inv_type in [1,3])*(rct_ent.width -1))+(1-scl_mul.x)*pvt0.x;
      m1:=scl_mul.y*(rct_ent.top +Byte(img_inv_type in [2,3])*(rct_ent.height-1))+(1-scl_mul.y)*pvt0.y;
    end;
end; {$endregion}

{Color} {$region -fold}

{||scl_mul||=1:                  } {$region -fold}

{Empty}
procedure TFastImageProc.RegNTColor009(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Color of Curent Layer}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegNTColorA00(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  nt_pix_ccl_arr_ptr: PInteger;
  x,y               : integer;
//z,k,c1,c2         : integer;
begin
  with fast_image_data_ do
    begin
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      nt_pix_ccl_arr_ptr:=                       nt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          if      not ((nt_pix_cnt_arr_ptr^>=4) and
                      ((nt_pix_sht_arr_ptr+
                        nt_pix_cnt_arr_ptr^-1)^-
                        nt_pix_sht_arr_ptr^=
                        nt_pix_cnt_arr_ptr^-1)) then
            for x:=0 to nt_pix_cnt_arr_ptr^-1 do
              begin
                Color1 (nt_pix_sht_arr_ptr^+first_row_pix_ptr,
                        nt_pix_ccl_arr_ptr^);
                Inc    (nt_pix_sht_arr_ptr);
                Inc    (nt_pix_ccl_arr_ptr);
              end
          else
            begin
              Move     (nt_pix_ccl_arr_ptr^,
                       (nt_pix_sht_arr_ptr^+first_row_pix_ptr)^,
                        nt_pix_cnt_arr_ptr^<<2);
              Inc      (nt_pix_sht_arr_ptr,
                        nt_pix_cnt_arr_ptr^);
              Inc      (nt_pix_ccl_arr_ptr,
                        nt_pix_cnt_arr_ptr^);
            end;
          Inc          (nt_pix_cnt_arr_ptr);
          Inc   (first_row_pix_ptr,res_var5);
        end;
    end;

  {with fast_image_data_^ do
    begin
      nt_pix_clm_arr_ptr:=@fast_image_data_ptr_^.nt_pix_clm_arr[0]);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [(nt_pix_clm_arr_ptr^.x+rct_ent.top)*bmp_bkgnd_width+rct_dst.left];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[ nt_pix_clm_arr_ptr^.x+00000000000000000000000000000000000000000];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[ 000000000000000000000000000000000000000000000000000000000000000];
      nt_pix_ccl_arr_ptr:=                       nt_pix_arr_ptr[ 000000000000000000000000000000000000000000000000000000000000000];
      for z:=0 to           nt_pix_clm-1 do
        begin
          for y:=0 to       nt_pix_clm_arr_ptr^.y-1 do
            begin
              if      not ((nt_pix_cnt_arr_ptr^>=4) and
                          ((nt_pix_sht_arr_ptr+
                            nt_pix_cnt_arr_ptr^-1)^-
                            nt_pix_sht_arr_ptr^=
                            nt_pix_cnt_arr_ptr^-1)) then
                for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                  begin
                    Color1((nt_pix_sht_arr_ptr^+first_row_pix_ptr),
                            nt_pix_ccl_arr_ptr^);
                    Inc    (nt_pix_sht_arr_ptr);
                    Inc    (nt_pix_ccl_arr_ptr);
                  end
              else
                begin
                  Move     (nt_pix_ccl_arr_ptr^,
                           (nt_pix_sht_arr_ptr^+first_row_pix_ptr)^,
                            nt_pix_cnt_arr_ptr^<<2);
                  Inc      (nt_pix_sht_arr_ptr,
                            nt_pix_cnt_arr_ptr^);
                  Inc      (nt_pix_ccl_arr_ptr,
                            nt_pix_cnt_arr_ptr^);
                end;
              Inc          (nt_pix_cnt_arr_ptr);
              Inc(first_row_pix_ptr,bmp_bkgnd_width);
            end;
          Inc              (nt_pix_clm_arr_ptr);
          k:=               nt_pix_clm_arr_ptr^.x-
                          ((nt_pix_clm_arr_ptr-1)^.x+
                           (nt_pix_clm_arr_ptr-1)^.y);
          Inc              (nt_pix_cnt_arr_ptr,     k);
          Inc       (first_row_pix_ptr,bmp_bkgnd_width*k);
        end;
    end;}

  {with fast_image_data_^ do
      begin
        {
         first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [(res_var0+rct_ent.top)*bmp_bkgnd_width+rct_dst.left];
        nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[ res_var0+00000000000000000000000000000000000000000];
        nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[ res_var1+00000000000000000000000000000000000000000];
        nt_pix_ccl_arr_ptr:=                       nt_pix_arr_ptr+ res_var1;


        with fast_image_data_^ do
          begin
            res_var0:=rct_src.top;
            res_var1:=fast_image_data_ptr_^.nt_cnt_ind_arr[rct_src.top];
            res_var2:=rct_src.height-1;
          end;}

        c1:=BinarySearch1(nt_pix_clm,
                          nt_pix_clm_arr_ptr^.x,rct_src.top);
        c2:=BinarySearch1(nt_pix_cnt_arr_ptr^,
                          nt_pix_clm,rct_src.bottom);


        nt_pix_clm_arr_ptr:=@fast_image_data_ptr_^.nt_pix_clm_arr[c1];
         first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [(nt_pix_clm_arr_ptr^.x+rct_ent.top)*bmp_bkgnd_width+rct_dst.left];
        nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[ nt_pix_clm_arr_ptr^.x+00000000000000000000000000000000000000000];
        nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[ 000000000000000000000000000000000000000000000000000000000000000];
        nt_pix_ccl_arr_ptr:=                       nt_pix_arr_ptr[ 000000000000000000000000000000000000000000000000000000000000000];
        for z:=0 to c2-c1-1 do
          begin
            for y:=0 to       nt_pix_clm_arr_ptr^.y-1 do
              begin
                if      not ((nt_pix_cnt_arr_ptr^>=4) and
                            ((nt_pix_sht_arr_ptr+
                              nt_pix_cnt_arr_ptr^-1)^-
                              nt_pix_sht_arr_ptr^=
                              nt_pix_cnt_arr_ptr^-1)) then
                  for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                    begin
                      Color1((nt_pix_sht_arr_ptr^+first_row_pix_ptr),
                              nt_pix_ccl_arr_ptr^);
                      Inc    (nt_pix_sht_arr_ptr);
                      Inc    (nt_pix_ccl_arr_ptr);
                    end
                else
                  begin
                    Move     (nt_pix_ccl_arr_ptr^,
                             (nt_pix_sht_arr_ptr^+first_row_pix_ptr)^,
                              nt_pix_cnt_arr_ptr^<<2);
                    Inc      (nt_pix_sht_arr_ptr,
                              nt_pix_cnt_arr_ptr^);
                    Inc      (nt_pix_ccl_arr_ptr,
                              nt_pix_cnt_arr_ptr^);
                  end;
                Inc          (nt_pix_cnt_arr_ptr);
                Inc(first_row_pix_ptr,bmp_bkgnd_width);
              end;
            Inc              (nt_pix_clm_arr_ptr);
            k:=               nt_pix_clm_arr_ptr^.x-
                            ((nt_pix_clm_arr_ptr-1)^.x+
                             (nt_pix_clm_arr_ptr-1)^.y);
            Inc              (nt_pix_cnt_arr_ptr,     k);
            Inc    (first_row_pix_ptr,bmp_bkgnd_width*k);
          end;
      end;}

end; {$endregion}
procedure TFastImageProc.RegNTColor000(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  nt_pix_ccl_arr_ptr: PInteger;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      if img_inv_type in [0,2] then
        begin
          RegNTColorA00   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      nt_pix_ccl_arr_ptr:=                       nt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          for x:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
              Color1(-nt_pix_sht_arr_ptr^+first_row_pix_ptr,
                      nt_pix_ccl_arr_ptr^);
              Inc    (nt_pix_sht_arr_ptr);
              Inc    (nt_pix_ccl_arr_ptr);
            end;
          Inc        (nt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTColorA04(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  nt_pix_ccl_arr_ptr: PInteger;
  v                 : PInteger;
  c,c1,c2           : integer;
  x,y               : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      nt_pix_ccl_arr_ptr:=                       nt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  Inc               (nt_pix_ccl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left;
                  if           not ((c2-c1-4>=0) and
                                   ((nt_pix_sht_arr_ptr+
                                     c2-c1-1)^-
                                     nt_pix_sht_arr_ptr^=
                                     c2-c1-1)) then
                    for x:=0 to      c2-c1-1 do
                      begin
                        Color1      (nt_pix_sht_arr_ptr^+v,
                                     nt_pix_ccl_arr_ptr^);
                        Inc         (nt_pix_sht_arr_ptr);
                        Inc         (nt_pix_ccl_arr_ptr);
                      end
                  else
                    begin
                      Move          (nt_pix_ccl_arr_ptr^,
                                    (nt_pix_sht_arr_ptr^+v)^,(c2-c1)<<2);
                      Inc           (nt_pix_sht_arr_ptr     , c2-c1);
                      Inc           (nt_pix_ccl_arr_ptr     , c2-c1);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^    -(c2+ 1));
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^    -(c2+ 1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr, c+1);
                  Inc               (nt_pix_ccl_arr_ptr, c+1);
                  v:=first_row_pix_ptr-rct_src.left;
                  if           not ((nt_pix_cnt_arr_ptr^-c-5>=0) and
                                   ((nt_pix_sht_arr_ptr+
                                     nt_pix_cnt_arr_ptr^-c-2)^-
                                     nt_pix_sht_arr_ptr^=
                                     nt_pix_cnt_arr_ptr^-c-2)) then
                    for x:=0 to      nt_pix_cnt_arr_ptr^-c-2 do
                      begin
                        Color1      (nt_pix_sht_arr_ptr^+v,
                                     nt_pix_ccl_arr_ptr^);
                        Inc         (nt_pix_sht_arr_ptr);
                        Inc         (nt_pix_ccl_arr_ptr);
                      end
                  else
                    begin
                      Move          (nt_pix_ccl_arr_ptr^,
                                    (nt_pix_sht_arr_ptr^+v)^,
                                    (nt_pix_cnt_arr_ptr^-c-1)<<2);
                      Inc           (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-c-1);
                      Inc           (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-c-1);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left;
                  if           not ((c-3>=0) and
                                   ((nt_pix_sht_arr_ptr +c)^-
                                     nt_pix_sht_arr_ptr^=c)) then
                    for x:=0 to c do
                      begin
                        Color1      (nt_pix_sht_arr_ptr^+v,
                                     nt_pix_ccl_arr_ptr^);
                        Inc         (nt_pix_sht_arr_ptr);
                        Inc         (nt_pix_ccl_arr_ptr);
                      end
                  else
                    begin
                      Move          (nt_pix_ccl_arr_ptr^,
                                    (nt_pix_sht_arr_ptr^+v)^,(c+1)<<2);
                      Inc           (nt_pix_sht_arr_ptr,      c+1);
                      Inc           (nt_pix_ccl_arr_ptr,      c+1);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left;
                  if           not ((nt_pix_cnt_arr_ptr^-4>=0) and
                                   ((nt_pix_sht_arr_ptr+
                                     nt_pix_cnt_arr_ptr^-1)^-
                                     nt_pix_sht_arr_ptr^=
                                     nt_pix_cnt_arr_ptr^-1)) then
                    for x:=0 to      nt_pix_cnt_arr_ptr^-1 do
                      begin
                        Color1      (nt_pix_sht_arr_ptr^+v,
                                     nt_pix_ccl_arr_ptr^);
                        Inc         (nt_pix_sht_arr_ptr);
                        Inc         (nt_pix_ccl_arr_ptr);
                      end
                  else
                    begin
                      Move          (nt_pix_ccl_arr_ptr^,
                                    (nt_pix_sht_arr_ptr^+v)^,
                                     nt_pix_cnt_arr_ptr^<<2);
                      Inc           (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                      Inc           (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegNTColor004(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  nt_pix_ccl_arr_ptr: PInteger;
  v                 : PInteger;
  c,c1,c2           : integer;
  x,y               : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      if img_inv_type in [0,2] then
        begin
          RegNTColorA04   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      nt_pix_ccl_arr_ptr:=                       nt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  Inc               (nt_pix_ccl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr+rct_src.left;
                  for x:=0 to c2-c1-1 do
                    begin
                      Color1       (-nt_pix_sht_arr_ptr^+v,
                                     nt_pix_ccl_arr_ptr^);
                      Inc           (nt_pix_sht_arr_ptr);
                      Inc           (nt_pix_ccl_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr,c+1);
                  Inc               (nt_pix_ccl_arr_ptr,c+1);
                  v:=first_row_pix_ptr+rct_src.left;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Color1       (-nt_pix_sht_arr_ptr^+v,
                                     nt_pix_ccl_arr_ptr^);
                      Inc           (nt_pix_sht_arr_ptr);
                      Inc           (nt_pix_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr+rct_src.left;
                  for x:=0 to c do
                    begin
                      Color1       (-nt_pix_sht_arr_ptr^+v,
                                     nt_pix_ccl_arr_ptr^);
                      Inc           (nt_pix_sht_arr_ptr);
                      Inc           (nt_pix_ccl_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr+rct_src.left;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      Color1       (-nt_pix_sht_arr_ptr^+v,
                                     nt_pix_ccl_arr_ptr^);
                      Inc           (nt_pix_sht_arr_ptr);
                      Inc           (nt_pix_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTColor006(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    case img_inv_type of
      0: BitBlt1  (fast_image_data_ptr_^.bmp_color_ptr,
                   fast_image_data_ptr_^.bmp_bkgnd_ptr,
                   bmp_ftimg_width_origin{rct_ent.width},
                   bmp_bkgnd_width,
                   rct_dst.left,
                   rct_dst.top,
                   rct_src);
      1: BitBlt1X (fast_image_data_ptr_^.bmp_color_ptr,
                   fast_image_data_ptr_^.bmp_bkgnd_ptr,
                   bmp_ftimg_width_origin{rct_ent.width},
                   bmp_bkgnd_width,
                   rct_dst.left,
                   rct_dst.top,
                   rct_src);
      2: BitBlt1Y (fast_image_data_ptr_^.bmp_color_ptr,
                   fast_image_data_ptr_^.bmp_bkgnd_ptr,
                   bmp_ftimg_width_origin{rct_ent.width},
                   bmp_bkgnd_width,
                   rct_dst.left,
                   rct_dst.top,
                   rct_src);
      3: BitBlt1XY(fast_image_data_ptr_^.bmp_color_ptr,
                   fast_image_data_ptr_^.bmp_bkgnd_ptr,
                   bmp_ftimg_width_origin{rct_ent.width},
                   bmp_bkgnd_width,
                   rct_dst.left,
                   rct_dst.top,
                   rct_src);
    end;
end; {$endregion}
// (fading):
// same;

{Color of Curent Layer(Additive)}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegNTColor010(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  nt_pix_ccl_arr_ptr: PInteger;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      nt_pix_ccl_arr_ptr:=                       nt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          for x:=0 to   nt_pix_cnt_arr_ptr^-1 do
            begin
              Additive1(nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
                        nt_pix_ccl_arr_ptr^);
              Inc      (nt_pix_sht_arr_ptr);
              Inc      (nt_pix_ccl_arr_ptr);
            end;
          Inc          (nt_pix_cnt_arr_ptr);
          Inc   (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTColor014(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  nt_pix_ccl_arr_ptr: PInteger;
  v                 : PInteger;
  c,c1,c2           : integer;
  x,y               : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      nt_pix_ccl_arr_ptr:=                       nt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  Inc               (nt_pix_ccl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Additive1     (nt_pix_sht_arr_ptr^*res_var8+v,
                                     nt_pix_ccl_arr_ptr^);
                      Inc           (nt_pix_sht_arr_ptr);
                      Inc           (nt_pix_ccl_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr,c+1);
                  Inc               (nt_pix_ccl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Additive1     (nt_pix_sht_arr_ptr^*res_var8+v,
                                     nt_pix_ccl_arr_ptr^);
                      Inc           (nt_pix_sht_arr_ptr);
                      Inc           (nt_pix_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Additive1     (nt_pix_sht_arr_ptr^*res_var8+v,
                                     nt_pix_ccl_arr_ptr^);
                      Inc           (nt_pix_sht_arr_ptr);
                      Inc           (nt_pix_ccl_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      Additive1     (nt_pix_sht_arr_ptr^*res_var8+v,
                                     nt_pix_ccl_arr_ptr^);
                      Inc           (nt_pix_sht_arr_ptr);
                      Inc           (nt_pix_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTColor016(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    case img_inv_type of
      0: PPAdditive  (fast_image_data_ptr_^.bmp_color_ptr,
                      fast_image_data_ptr_^.bmp_bkgnd_ptr,
                      bmp_ftimg_width_origin{bmp_ftimg_width},
                      bmp_bkgnd_width,
                      rct_src,
                      rct_dst);
      1: PPAdditiveX (fast_image_data_ptr_^.bmp_color_ptr,
                      fast_image_data_ptr_^.bmp_bkgnd_ptr,
                      bmp_ftimg_width_origin{bmp_ftimg_width},
                      bmp_bkgnd_width,
                      rct_src,
                      rct_dst);
      2: PPAdditiveY (fast_image_data_ptr_^.bmp_color_ptr,
                      fast_image_data_ptr_^.bmp_bkgnd_ptr,
                      bmp_ftimg_width_origin{bmp_ftimg_width},
                      bmp_bkgnd_width,
                      rct_src,
                      rct_dst);
      3: PPAdditiveXY(fast_image_data_ptr_^.bmp_color_ptr,
                      fast_image_data_ptr_^.bmp_bkgnd_ptr,
                      bmp_ftimg_width_origin{bmp_ftimg_width},
                      bmp_bkgnd_width,
                      rct_src,
                      rct_dst);
    end;
end; {$endregion}
// (fading) auxiliary procedure:
procedure TFastImageProc.RegNTColor011(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  nt_pix_ccl_arr_ptr: PInteger;
  cfx_pow0_         : byte;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTColor010   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      nt_pix_ccl_arr_ptr:=                       nt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          for x:=0 to      nt_pix_cnt_arr_ptr^-1 do
            begin
              AdditiveDec1(nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
                           nt_pix_ccl_arr_ptr^,cfx_pow0_);
              Inc         (nt_pix_sht_arr_ptr);
              Inc         (nt_pix_ccl_arr_ptr);
            end;
          Inc             (nt_pix_cnt_arr_ptr);
          Inc      (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTColor015(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  nt_pix_ccl_arr_ptr: PInteger;
  v                 : PInteger;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
  x,y               : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTColor014   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      nt_pix_ccl_arr_ptr:=                       nt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  Inc               (nt_pix_ccl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AdditiveDec1  (nt_pix_sht_arr_ptr^*res_var8+v,
                                     nt_pix_ccl_arr_ptr^,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                      Inc           (nt_pix_ccl_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr,c+1);
                  Inc               (nt_pix_ccl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AdditiveDec1  (nt_pix_sht_arr_ptr^*res_var8+v,
                                     nt_pix_ccl_arr_ptr^,cfx_pow0_);;
                      Inc           (nt_pix_sht_arr_ptr);
                      Inc           (nt_pix_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AdditiveDec1  (nt_pix_sht_arr_ptr^*res_var8+v,
                                     nt_pix_ccl_arr_ptr^,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                      Inc           (nt_pix_ccl_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      AdditiveDec1  (nt_pix_sht_arr_ptr^*res_var8+v,
                                     nt_pix_ccl_arr_ptr^,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                      Inc           (nt_pix_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTColor017(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTColor016(fast_image_data_ptr_,fast_image_data_)
    else
      case img_inv_type of
        0: PPAdditiveDec  (fast_image_data_ptr_^.bmp_color_ptr,
                           fast_image_data_ptr_^.bmp_bkgnd_ptr,
                           bmp_ftimg_width_origin{bmp_ftimg_width},
                           bmp_bkgnd_width,
                           rct_src,
                           rct_dst,
                           MAXBYTE-cfx_pow0);
        1: PPAdditiveDecX (fast_image_data_ptr_^.bmp_color_ptr,
                           fast_image_data_ptr_^.bmp_bkgnd_ptr,
                           bmp_ftimg_width_origin{bmp_ftimg_width},
                           bmp_bkgnd_width,
                           rct_src,
                           rct_dst,
                           MAXBYTE-cfx_pow0);
        2: PPAdditiveDecY (fast_image_data_ptr_^.bmp_color_ptr,
                           fast_image_data_ptr_^.bmp_bkgnd_ptr,
                           bmp_ftimg_width_origin{bmp_ftimg_width},
                           bmp_bkgnd_width,
                           rct_src,
                           rct_dst,
                           MAXBYTE-cfx_pow0);
        3: PPAdditiveDecXY(fast_image_data_ptr_^.bmp_color_ptr,
                           fast_image_data_ptr_^.bmp_bkgnd_ptr,
                           bmp_ftimg_width_origin{bmp_ftimg_width},
                           bmp_bkgnd_width,
                           rct_src,
                           rct_dst,
                           MAXBYTE-cfx_pow0);
      end;
end; {$endregion}

{Color of Curent Layer(Alphablend)}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegNTColor020(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  nt_pix_ccl_arr_ptr: PInteger;
  cfx_pow0_         : byte;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTColor000   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      nt_pix_ccl_arr_ptr:=                       nt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          for x:=0 to     nt_pix_cnt_arr_ptr^-1 do
            begin
              AlphaBlend1(nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
                          nt_pix_ccl_arr_ptr^,cfx_pow0_);
              Inc        (nt_pix_sht_arr_ptr);
              Inc        (nt_pix_ccl_arr_ptr);
            end;
          Inc            (nt_pix_cnt_arr_ptr);
          Inc     (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTColor024(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  nt_pix_ccl_arr_ptr: PInteger;
  v                 : PInteger;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
  x,y               : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTColor004   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      nt_pix_ccl_arr_ptr:=                       nt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  Inc               (nt_pix_ccl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AlphaBlend1   (nt_pix_sht_arr_ptr^*res_var8+v,
                                     nt_pix_ccl_arr_ptr^,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                      Inc           (nt_pix_ccl_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr,c+1);
                  Inc               (nt_pix_ccl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AlphaBlend1   (nt_pix_sht_arr_ptr^*res_var8+v,
                                     nt_pix_ccl_arr_ptr^,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                      Inc           (nt_pix_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AlphaBlend1   (nt_pix_sht_arr_ptr^*res_var8+v,
                                     nt_pix_ccl_arr_ptr^,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                      Inc           (nt_pix_ccl_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      AlphaBlend1   (nt_pix_sht_arr_ptr^*res_var8+v,
                                     nt_pix_ccl_arr_ptr^,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                      Inc           (nt_pix_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTColor026(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTColor006(fast_image_data_ptr_,fast_image_data_)
    else
      case img_inv_type of
        0: PPAlphaBlend  (fast_image_data_ptr_^.bmp_color_ptr,
                          fast_image_data_ptr_^.bmp_bkgnd_ptr,
                          bmp_ftimg_width_origin{bmp_ftimg_width},
                          bmp_bkgnd_width,
                          rct_src,
                          rct_dst,
                          cfx_pow0);
        1: PPAlphaBlendX (fast_image_data_ptr_^.bmp_color_ptr,
                          fast_image_data_ptr_^.bmp_bkgnd_ptr,
                          bmp_ftimg_width_origin{bmp_ftimg_width},
                          bmp_bkgnd_width,
                          rct_src,
                          rct_dst,
                          cfx_pow0);
        2: PPAlphaBlendY (fast_image_data_ptr_^.bmp_color_ptr,
                          fast_image_data_ptr_^.bmp_bkgnd_ptr,
                          bmp_ftimg_width_origin{bmp_ftimg_width},
                          bmp_bkgnd_width,
                          rct_src,
                          rct_dst,
                          cfx_pow0);
        3: PPAlphaBlendXY(fast_image_data_ptr_^.bmp_color_ptr,
                          fast_image_data_ptr_^.bmp_bkgnd_ptr,
                          bmp_ftimg_width_origin{bmp_ftimg_width},
                          bmp_bkgnd_width,
                          rct_src,
                          rct_dst,
                          cfx_pow0);
      end;
end; {$endregion}
// (fading):
// same;

{$endregion}

{||scl_mul||<1: (SD - Scale Down)} {$region -fold}

{Experimental dummies} {$region -fold}
{
procedure TFastImageProc.FilNTColorScaleDownMip0; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_cnt_arr_ptr                      : PInteger;
  nt_pix_sht_arr_ptr                      : PInteger;
  nt_pix_ccl_arr_ptr                      : PInteger;
   first_row_pix_ptr                      : PInteger;
  scl_mul_x,scl_mul_y,d1_,d2_,x,y,r1,r2,r3: integer;
  d1,d2                                   : double;
  row_parity                              : boolean;
  _scl_mul_x,_scl_mul_y,_d1,_d2           : TPtPos;
const
  mul=ONE_SHL_15;
begin
  with fast_image_data_ptr0^ do
    begin
     _scl_mul_x.x       :=Trunc(mul* scl_mul.x);
     _scl_mul_y.x       :=Trunc(mul* scl_mul.y);
      scl_mul.x         := _scl_mul_x.x/ mul;
      scl_mul.y         := _scl_mul_y.x/ mul;
     _d1.x              :=     (mul-_scl_mul_x.x)*bmp_ftimg_left;
     _d2.x              :=     (mul-_scl_mul_y.x)*bmp_ftimg_top ;
      d1                :=_d1.x/mul;
      d2                :=_d2.x/mul;
      d1_               :=Trunc(65536*d1                );                 Trunc(65536*(((ONE_SHL_15-_scl_mul_x.x)*bmp_ftimg_left)/ONE_SHL_15))
      d2_               :=Trunc(65536*d2                );
      scl_mul_x         :=Trunc(65536*(_scl_mul_x.x/mul));
      scl_mul_y         :=Trunc(65536*(_scl_mul_y.x/mul));
      r1                :=              scl_mul_x*  (                       bmp_ftimg_left)+d1_;
      r2                :=              scl_mul_y*  (nt_pix_arr_row_mrg_top+bmp_ftimg_top )+d2_;
       first_row_pix_ptr:=Unaligned(@bmp_bkgnd_ptr [(nt_pix_arr_row_mrg_top+bmp_ftimg_top )*bmp_bkgnd_width+bmp_ftimg_left]);
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000]);
      nt_pix_sht_arr_ptr:=Unaligned(@nt_pix_sht_arr[0000000000000000000000000000000000000000000000000000000000000000000000]);
      nt_pix_ccl_arr_ptr:=Unaligned( nt_pix_arr_ptr);
      for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          row_parity:=not row_parity;
          r3        :=((scl_mul_y*y+r2)>>16)*bmp_bkgnd_width;
          for x:=0 to                      nt_pix_cnt_arr_ptr^-1 do
            begin
              if Odd                      (nt_pix_sht_arr_ptr-first_row_pix_ptr) and row_parity then
                (bmp_bkgnd_ptr+((scl_mul_x*nt_pix_sht_arr_ptr^+r1)>>16)+r3)^:=
                                           nt_pix_ccl_arr_ptr^;
              Inc                         (nt_pix_sht_arr_ptr);
              Inc                         (nt_pix_ccl_arr_ptr);
            end;
          Inc                             (nt_pix_cnt_arr_ptr);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.FilNTColorScaleDownMip1; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_cnt_arr_ptr                      : PInteger;
  nt_pix_sht_arr_ptr                      : PInteger;
  nt_pix_ccl_arr_ptr                      : PInteger;
  scl_mul_x,scl_mul_y,d1_,d2_,x,y,r1,r2,r3: integer;
  d1,d2                                   : double;
  _scl_mul_x,_scl_mul_y,_d1,_d2           : TPtPos;
const
  mul=ONE_SHL_15;
begin
  with fast_image_data_ptr0^ do
    begin
     _scl_mul_x.x       :=Trunc(mul* scl_mul.x);
     _scl_mul_y.x       :=Trunc(mul* scl_mul.y);
      scl_mul.x         := _scl_mul_x.x/ mul;
      scl_mul.y         := _scl_mul_y.x/ mul;
     _d1.x              :=     (mul-_scl_mul_x.x)*bmp_ftimg_left;
     _d2.x              :=     (mul-_scl_mul_y.x)*bmp_ftimg_top ;
      d1                :=_d1.x/mul;
      d2                :=_d2.x/mul;
      d1_               :=Trunc(65536*d1                );
      d2_               :=Trunc(65536*d2                );
      scl_mul_x         :=Trunc(65536*(_scl_mul_x.x/mul));
      scl_mul_y         :=Trunc(65536*(_scl_mul_y.x/mul));
      r1                :=              scl_mul_x* (                       bmp_ftimg_left)+d1_;
      r2                :=              scl_mul_y* (nt_pix_arr_row_mrg_top+bmp_ftimg_top )+d2_;
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[nt_pix_arr_row_mrg_top]);
      nt_pix_sht_arr_ptr:=Unaligned(@nt_pix_sht_arr[0000000000000000000000]);
      nt_pix_ccl_arr_ptr:=Unaligned( nt_pix_arr_ptr);
      for y:=0 to bmp_ftimg_height-  nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          r3:=((scl_mul_y*y+r2)>>16)*bmp_bkgnd_width;
          for x:=0 to                     nt_pix_cnt_arr_ptr^-1 do
            begin
              (bmp_bkgnd_ptr+((scl_mul_x* nt_pix_sht_arr_ptr^+r1)>>16)+r3)^:=
                                          nt_pix_ccl_arr_ptr^;
              Inc                        (nt_pix_sht_arr_ptr);
              Inc                        (nt_pix_ccl_arr_ptr);
            end;
          Inc                            (nt_pix_cnt_arr_ptr);
        end;
    end;
end; {$endregion}
{dont remove!!!--important details!!!}                                           {$region -fold}
{procedure TFastImageProc.FilNTColorScaleDownMip2; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_cnt_arr_ptr                                                                                       : PInteger;
  nt_pix_sht_arr_ptr                                                                                       : PInteger;
  nt_pix_ccl_arr_ptr                                                                                       : PInteger;
   first_row_pix_ptr                                                                                       : PInteger;
  bmp_bkgnd_ptr2                                                                                           : PInteger;
  scl_mul_x,scl_mul_y,d1_,d2_,s1_,s2_,x,y,v1,v2,v2_,v3,r1,r3,bmp_ftimg_left_,bmp_ftimg_top_                : integer;
  px,py,s0,s1,s2,g1,g2,alpha,alpha_inv,alpha_inv_mul_65536,_alpha_inv_mul_65536,d1,d2,alpha_sqr,k1,k2,r4,r5: double;
  row_parity                                                                                               : boolean;
  sqr_mul_0_1,sqr_mul_0_5                                                                                  : double;
  _scl_mul_x,_scl_mul_y,_d1,_d2,_r4,_r5,_alpha,_g1,_g2,_px,_py,_s0,_s1,_k1,_k2,_alpha_sqr                  : TPtPos;
  sqr_mul                                                                                                  : integer;
const
  mul                                                                                                      : integer={10000}1<<15{100};
begin
  with fast_image_data_ptr0^ do
    begin
      bmp_ftimg_left_   :=mul*bmp_ftimg_left;
      bmp_ftimg_top_    :=mul*bmp_ftimg_top;
      sqr_mul           :=mul*mul;
      sqr_mul_0_1       :=0000000.1* sqr_mul;
      sqr_mul_0_5       :=0000000.5* sqr_mul;
     _scl_mul_x.x       :=Trunc(mul* scl_mul.x);
     _scl_mul_y.x       :=Trunc(mul* scl_mul.y);
      scl_mul.x         := _scl_mul_x.x/ mul;
      scl_mul.y         := _scl_mul_y.x/ mul;
     _d1.x              :=     (mul-_scl_mul_x.x)*bmp_ftimg_left;
     _d2.x              :=     (mul-_scl_mul_y.x)*bmp_ftimg_top ;
      d1                :=_d1.x/mul;                      //bmp_ftimg_left*(1-scl_mul.x);
      d2                :=_d2.x/mul;                      //bmp_ftimg_top *(1-scl_mul.y);
      d1_               :=Trunc(65536*d1                );
      d2_               :=Trunc(65536*d2                );
      scl_mul_x         :=Trunc(65536*(_scl_mul_x.x/mul));//Trunc($0010000*   scl_mul.x);
      scl_mul_y         :=Trunc(65536*(_scl_mul_y.x/mul));//Trunc($0010000*   scl_mul.y);
      r1                :=              scl_mul_x*  (                       bmp_ftimg_left)+d1_;
      v3                :=              scl_mul_y*  (nt_pix_arr_row_mrg_top+bmp_ftimg_top )+d2_;
      r4                :=              scl_mul.x*  (                       bmp_ftimg_left)+d1 ;
      r5                :=              scl_mul.y*  (nt_pix_arr_row_mrg_top+bmp_ftimg_top )+d2 ;
     _r4.x              :=                                                  bmp_ftimg_left_;
     _r5.x              :=             _scl_mul_y.x* nt_pix_arr_row_mrg_top+bmp_ftimg_top_;
     {g2                :=scl_mul.y*y+r5;}
     _g2.x              :=             _scl_mul_y.x* nt_pix_arr_row_mrg_top+bmp_ftimg_top_;
       first_row_pix_ptr:=Unaligned(@bmp_bkgnd_ptr [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
           bmp_bkgnd_ptr:=Unaligned(@bmp_bkgnd_ptr [000000000000000000000000000000000000000000000000000000000000000000000]);
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000000000]);
      nt_pix_sht_arr_ptr:=Unaligned(@nt_pix_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
      nt_pix_ccl_arr_ptr:=Unaligned( nt_pix_arr_ptr);
      alpha              :=Exp(((_scl_mul_x.x+_scl_mul_y.x)/(mul<<1))*LN_0_95);//Exp(((scl_mul.x+scl_mul.y)/2)*LN_0_95);
     _alpha.x            :=Trunc(mul* alpha);
   // alpha              :=          _alpha.x/mul;
      alpha_inv          :=mul/      _alpha.x;//1/alpha;
      alpha_inv_mul_65536:=65536*mul/_alpha.x;//alpha_inv*65536;
   //_alpha_inv_mul_65536:=alpha_inv_mul_65536/sqr_mul;
     _alpha_sqr.x        :=_alpha.x* _alpha.x;
   //_alpha_sqr.y        :=sqr_mul;
      alpha_sqr          :=_alpha_sqr.x/sqr_mul{-0.25};
      for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          row_parity:=not row_parity;
          v2        :=v3>>16;
          v2_       :=v2*bmp_bkgnd_width;
          for x:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
              if Odd (nt_pix_sht_arr_ptr-first_row_pix_ptr) and row_parity then
                begin
                  v1                                    :=((scl_mul_x*nt_pix_sht_arr_ptr^+r1)>>16);
                 {g1                                    :=  scl_mul.x*nt_pix_sht_arr_ptr^+r4;
                  px                                    :=(Min(v1+1,g1+scl_mul.x)-Max(v1,g1));
                  py                                    :=(Min(v2+1,g2+scl_mul.y)-Max(v2,g2));
                  s0                                    :=px   *py;
                  k1                                    :=alpha*px;
                  k2                                    :=alpha*py;}
                 _g1.x                                  := _scl_mul_x.x*nt_pix_sht_arr_ptr^+bmp_ftimg_left_;
                 _px.x                                  :=(Min2(v1{*mul}<<15+mul,_g1.x+_scl_mul_x.x)-Max2(v1{*mul}<<15,_g1.x));
                 //_px.y                                  :=mul;
                 _py.x                                  :=(Min2(v2{*mul}<<15+mul,_g2.x+_scl_mul_y.x)-Max2(v2{*mul}<<15,_g2.x));
                 //_py.y                                  :=mul;
                 _s0.x                                  :=(         _px.x*_py.x);
                 //_s0.y                                  :=sqr_mul;
                 _k1.x                                  :=(_alpha.x*_px.x      );
                 //_k1.y                                  :=sqr_mul;
                 _k2.x                                  :=(_alpha.x*      _py.x);
                 //_k2.y                                  :=sqr_mul;
                  bmp_bkgnd_ptr2                        :=bmp_bkgnd_ptr+v1+v2_;
                  if (_s0.x>sqr_mul_0_1) then//if (s0>0.1) then
                    begin
                      s1_                               :=(_s0.x<<1) div _alpha.x;//(_s0.x<<16) div (_alpha.x*mul);{s1_:=Trunc(_alpha_inv_mul_65536*_s0);}
                    //s1_                               :=Trunc(alpha_inv_mul_65536*s0);
                     {s2                                :=alpha-s0;
                      s2_                               :=65536-s1_-1;{Trunc(alpha_inv_mul_65536*s2);}
                     (bmp_bkgnd_ptr2+00000000000000000)^:=((s2_*PRGBA(bmp_bkgnd_ptr2+0)^.r+s1_*PRGBA(nt_pix_ccl_arr_ptr)^.r)>>16)<<00+
                                                          ((s2_*PRGBA(bmp_bkgnd_ptr2+0)^.g+s1_*PRGBA(nt_pix_ccl_arr_ptr)^.g)>>16)<<08+
                                                          ((s2_*PRGBA(bmp_bkgnd_ptr2+0)^.b+s1_*PRGBA(nt_pix_ccl_arr_ptr)^.b)>>16)<<16;}
                     (bmp_bkgnd_ptr2+00000000000000000)^:=(PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.r+(s1_*(PRGBA(nt_pix_ccl_arr_ptr)^.r-PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.r))>>16)<<00+
                                                          (PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.g+(s1_*(PRGBA(nt_pix_ccl_arr_ptr)^.g-PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.g))>>16)<<08+
                                                          (PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.b+(s1_*(PRGBA(nt_pix_ccl_arr_ptr)^.b-PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.b))>>16)<<16;
                    end;
                      _s1.x                             :=_k2.x-_s0.x;//s1:=k2-s0;//(alpha-px)*py;
                    //_s1.y                             :=sqr_mul;
                  if (_s1.x>sqr_mul_0_1) then//if (s1>0.1) then
                    begin
                      s1_                               :=(_s1.x<<1) div _alpha.x;//(_s1.x<<16) div (_alpha.x*mul);{s1_:=Trunc(_alpha_inv_mul_65536*_s1);}
                    //s1_                               :=Trunc(alpha_inv_mul_65536*s1);
                     {s2                                :=alpha-s1;
                      s2_                               :=65536-s1_-1;{Trunc(alpha_inv_mul_65536*s2);}
                     (bmp_bkgnd_ptr2+000000000000000+1)^:=((s2_*PRGBA(bmp_bkgnd_ptr2+1)^.r+s1_*PRGBA(nt_pix_ccl_arr_ptr)^.r)>>16)<<00+
                                                          ((s2_*PRGBA(bmp_bkgnd_ptr2+1)^.g+s1_*PRGBA(nt_pix_ccl_arr_ptr)^.g)>>16)<<08+
                                                          ((s2_*PRGBA(bmp_bkgnd_ptr2+1)^.b+s1_*PRGBA(nt_pix_ccl_arr_ptr)^.b)>>16)<<16;}
                     (bmp_bkgnd_ptr2+000000000000000+1)^:=(PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.r+(s1_*(PRGBA(nt_pix_ccl_arr_ptr)^.r-PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.r))>>16)<<00+
                                                          (PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.g+(s1_*(PRGBA(nt_pix_ccl_arr_ptr)^.g-PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.g))>>16)<<08+
                                                          (PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.b+(s1_*(PRGBA(nt_pix_ccl_arr_ptr)^.b-PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.b))>>16)<<16;
                    end;
                      _s1.x                             :=_k1.x-_s0.x;//s1:=k1-s0;//(alpha-py)*px;
                    //_s1.y                             :=sqr_mul;
                  if (_s1.x>sqr_mul_0_5) then//if (s1>0.5) then
                    begin
                      s1_                               :=(_s1.x<<1) div _alpha.x;//(_s1.x<<16) div (_alpha.x*mul);{s1_:=Trunc(_alpha_inv_mul_65536*_s1);}
                    //s1_                               :=Trunc(alpha_inv_mul_65536*s1);
                     {s2                                :=alpha-s1;
                      s2_                               :=65536-s1_-1;{Trunc(alpha_inv_mul_65536*s2);}
                     (bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^:=((s2_*PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.r+s1_*PRGBA(nt_pix_ccl_arr_ptr)^.r)>>16)<<00+
                                                          ((s2_*PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.g+s1_*PRGBA(nt_pix_ccl_arr_ptr)^.g)>>16)<<08+
                                                          ((s2_*PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.b+s1_*PRGBA(nt_pix_ccl_arr_ptr)^.b)>>16)<<16;}
                     (bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^:=(PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.r+(s1_*(PRGBA(nt_pix_ccl_arr_ptr)^.r-PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.r))>>16)<<00+
                                                          (PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.g+(s1_*(PRGBA(nt_pix_ccl_arr_ptr)^.g-PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.g))>>16)<<08+
                                                          (PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.b+(s1_*(PRGBA(nt_pix_ccl_arr_ptr)^.b-PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.b))>>16)<<16;
                    end
                  else
                     (bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^:=nt_pix_ccl_arr_ptr^;
                      _s1.x                             :=_alpha_sqr.x-_k1.x-_k2.x+_s0.x;//s1:=alpha_sqr-k1-k2+s0;//(alpha-py)*(alpha-px);
                    //_s1.y                             :=sqr_mul;
                  if (_s1.x>sqr_mul_0_5) then//if (s1>0.5) then
                    begin
                      s1_                               :=(_s1.x<<1) div _alpha.x;//(_s1.x<<16) div (_alpha.x*mul);{s1_:=Trunc(_alpha_inv_mul_65536*_s1);}
                    //s1_                               :=Trunc(alpha_inv_mul_65536*s1);
                     {s2                                :=alpha-s1;
                      s2_                               :=65536-s1_-1;{Trunc(alpha_inv_mul_65536*s2);}
                     (bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^:=((s2_*PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.r+s1_*PRGBA(nt_pix_ccl_arr_ptr)^.r)>>16)<<00+
                                                          ((s2_*PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.g+s1_*PRGBA(nt_pix_ccl_arr_ptr)^.g)>>16)<<08+
                                                          ((s2_*PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.b+s1_*PRGBA(nt_pix_ccl_arr_ptr)^.b)>>16)<<16;}
                     (bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^:=(PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.r+(s1_*(PRGBA(nt_pix_ccl_arr_ptr)^.r-PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.r))>>16)<<00+
                                                          (PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.g+(s1_*(PRGBA(nt_pix_ccl_arr_ptr)^.g-PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.g))>>16)<<08+
                                                          (PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.b+(s1_*(PRGBA(nt_pix_ccl_arr_ptr)^.b-PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.b))>>16)<<16;
                    end
                  else
                     (bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^:=nt_pix_ccl_arr_ptr^;
                end;
              Inc                                        (nt_pix_sht_arr_ptr);
              Inc                                        (nt_pix_ccl_arr_ptr);
            end;
          Inc                                            (nt_pix_cnt_arr_ptr);
          Inc( v3  , scl_mul_y  );
          Inc(_g2.x,_scl_mul_y.x);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.FilNTColorScaleDownMip2; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_cnt_arr_ptr                                                                              : PInteger;
  nt_pix_sht_arr_ptr                                                                              : PInteger;
  nt_pix_ccl_arr_ptr                                                                              : PInteger;
   first_row_pix_ptr                                                                              : PInteger;
  bmp_bkgnd_ptr2                                                                                  : PInteger;
  scl_mul_x  , scl_mul_y,d1_,d2_,x,y,v1,v2,v2_,v3,r1,s1_,s0_mul_2_div_alpha,bmp_ftimg_left_       : integer;
 _scl_mul_x  ,_scl_mul_y,d1 ,d2 ,alpha,g1,g2,px,py,t,s1 ,s0,k1,k2,alpha_sqr,bmp_ftimg_top_,sqr_mul: integer;
  sqr_mul_0_1, sqr_mul_0_5                                                                        : integer{double};
  row_parity                                                                                      : boolean;
const
  mul1                                                                                            : integer=1<<15;
  mul2                                                                                            : integer=1<<16;
begin
  with fast_image_data_ptr0^ do
    begin
      sqr_mul           :=      mul1*      mul1;
      sqr_mul_0_1       :=Trunc(0.1*   sqr_mul  );//0000000.1*    sqr_mul;
      sqr_mul_0_5       :=Trunc(0.5*   sqr_mul  );//0000000.5*    sqr_mul;
     _scl_mul_x         :=Trunc(mul1*  scl_mul.x);
     _scl_mul_y         :=Trunc(mul1*  scl_mul.y);
      bmp_ftimg_left_   :=      mul1*             bmp_ftimg_left;
      bmp_ftimg_top_    :=      mul1*             bmp_ftimg_top ;
      d1                :=     (mul1- _scl_mul_x)*bmp_ftimg_left;
      d2                :=     (mul1- _scl_mul_y)*bmp_ftimg_top ;
      d1_               :=Trunc(mul2*(        d1/mul1));
      d2_               :=Trunc(mul2*(        d2/mul1));
      scl_mul_x         :=Trunc(mul2*(_scl_mul_x/mul1));
      scl_mul_y         :=Trunc(mul2*(_scl_mul_y/mul1));
      r1                :=             scl_mul_x*   (                       bmp_ftimg_left)+d1_;
      v3                :=             scl_mul_y*   (nt_pix_arr_row_mrg_top+bmp_ftimg_top )+d2_;
      g2                :=            _scl_mul_y*    nt_pix_arr_row_mrg_top+bmp_ftimg_top_;
       first_row_pix_ptr:=Unaligned(@bmp_bkgnd_ptr [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
           bmp_bkgnd_ptr:=Unaligned(@bmp_bkgnd_ptr [0000000000000000000000]);
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[nt_pix_arr_row_mrg_top]);
      nt_pix_sht_arr_ptr:=Unaligned(@nt_pix_sht_arr[0000000000000000000000]);
      nt_pix_ccl_arr_ptr:=Unaligned( nt_pix_arr_ptr);
      alpha             :=mul1;//Trunc(mul1*Exp(((_scl_mul_x+_scl_mul_y)/(mul1<<1))*LN_0_95));
      alpha_sqr         :=alpha*alpha;
      for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          row_parity:=not row_parity;
          v2        :=v3>>16;
          v2_       :=v2*bmp_bkgnd_width;
          py        :=MinSubMax(v2<<15,g2,mul1,_scl_mul_y);//(Min2(v2<<15+mul1,g2+_scl_mul_y)-Max2(v2<<15,g2));
          k2        :=py<<15;//alpha*py;
          t         :=alpha-py;
          for x:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
              if Odd (nt_pix_sht_arr_ptr-first_row_pix_ptr) and row_parity then
                begin
                  v1                                    :=(scl_mul_x*nt_pix_sht_arr_ptr^+r1)>>16;
                  g1                                    :=_scl_mul_x*nt_pix_sht_arr_ptr^+bmp_ftimg_left_;
                  px                                    :=MinSubMax(v1<<15,g1,mul1,_scl_mul_x);//(Min2(v1<<15+mul1,g1+_scl_mul_x)-Max2(v1<<15,g1));
                  s0                                    :=px*py;
                  k1                                    :=px<<15;//px*alpha;
                  bmp_bkgnd_ptr2                        :=bmp_bkgnd_ptr+v1+v2_;
                  s0_mul_2_div_alpha                    :=s0>>14;//(s0<<1) div alpha;
                  if (s0>sqr_mul_0_1) then
                    begin
                    //s1_                               :=(s0<<1) div alpha;
                     (bmp_bkgnd_ptr2+00000000000000000)^:=(PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.r+(s0_mul_2_div_alpha{s1_}*(PRGBA(nt_pix_ccl_arr_ptr)^.r-PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.r))>>16)<<00+
                                                          (PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.g+(s0_mul_2_div_alpha{s1_}*(PRGBA(nt_pix_ccl_arr_ptr)^.g-PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.g))>>16)<<08+
                                                          (PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.b+(s0_mul_2_div_alpha{s1_}*(PRGBA(nt_pix_ccl_arr_ptr)^.b-PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.b))>>16)<<16;
                    end;
                    //s1                                :=k2-s0;
                  if (k2-s0>sqr_mul_0_1) then//if (s1>sqr_mul_0_1) then
                    begin
                      s1_                               :=py<<1-s0_mul_2_div_alpha;//(s1<<1) div alpha;
                     (bmp_bkgnd_ptr2+000000000000000+1)^:=(PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.r+(s1_*(PRGBA(nt_pix_ccl_arr_ptr)^.r-PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.r))>>16)<<00+
                                                          (PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.g+(s1_*(PRGBA(nt_pix_ccl_arr_ptr)^.g-PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.g))>>16)<<08+
                                                          (PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.b+(s1_*(PRGBA(nt_pix_ccl_arr_ptr)^.b-PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.b))>>16)<<16;
                    end;
                    //s1                                :=k1-s0;
                  {if (k1-s0>sqr_mul_0_5) then//if (s1>sqr_mul_0_5) then
                    begin
                      s1_                               :=px<<1-s0_mul_2_div_alpha;//(s1<<1) div alpha;
                     (bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^:=(PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.r+(s1_*(PRGBA(nt_pix_ccl_arr_ptr)^.r-PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.r))>>16)<<00+
                                                          (PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.g+(s1_*(PRGBA(nt_pix_ccl_arr_ptr)^.g-PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.g))>>16)<<08+
                                                          (PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.b+(s1_*(PRGBA(nt_pix_ccl_arr_ptr)^.b-PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^.b))>>16)<<16;
                    end
                  else}
                  if (k1-s0<=sqr_mul_0_5) then
                     (bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^:=nt_pix_ccl_arr_ptr^;
                    //s1                                :=alpha_sqr-k1-k2+s0;
                  {if (alpha_sqr-k1-k2+s0>sqr_mul_0_5) then//if (s1>sqr_mul_0_5) then
                    begin
                      s1_                               :=(t-px)<<1+s0_mul_2_div_alpha;//(s1<<1) div alpha;
                     (bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^:=(PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.r+(s1_*(PRGBA(nt_pix_ccl_arr_ptr)^.r-PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.r))>>16)<<00+
                                                          (PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.g+(s1_*(PRGBA(nt_pix_ccl_arr_ptr)^.g-PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.g))>>16)<<08+
                                                          (PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.b+(s1_*(PRGBA(nt_pix_ccl_arr_ptr)^.b-PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^.b))>>16)<<16;
                    end
                  else}
                  if (alpha_sqr-k1-k2+s0<=sqr_mul_0_5) then
                     (bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^:=nt_pix_ccl_arr_ptr^;
                end;
              Inc                                        (nt_pix_sht_arr_ptr);
              Inc                                        (nt_pix_ccl_arr_ptr);
            end;
          Inc                                            (nt_pix_cnt_arr_ptr);
          Inc(v3, scl_mul_y);
          Inc(g2,_scl_mul_y);
        end;
    end;
end; {$endregion}} {$endregion}
procedure TFastImageProc.FilNTColorScaleDownMip2; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_cnt_arr_ptr                                                                       : PInteger;
  nt_pix_sht_arr_ptr                                                                       : PInteger;
  nt_pix_ccl_arr_ptr                                                                       : PInteger;
   first_row_pix_ptr                                                                       : PInteger;
       bmp_bkgnd_ptr2                                                                      : PInteger;
  scl_mul_x  , scl_mul_y,d1_,d2_,x,y,v1,v2,v2_,v3,r1,s1_,s0_mul_2_div_alpha,bmp_ftimg_left_: integer;
 _scl_mul_x  ,_scl_mul_y,d1 ,d2 ,g1,g2,px,py,s0,k1,k2,bmp_ftimg_top_,sqr_mul               : integer;
  sqr_mul_0_1, sqr_mul_0_5                                                                 : integer;
  row_parity                                                                               : boolean;
const
  mul1=ONE_SHL_15;
  mul2=ONE_SHL_16;
  mul3=ONE_SHL_30;
begin
  with fast_image_data_ptr0^ do
    begin
      sqr_mul           :=      mul1*      mul1;
      sqr_mul_0_1       :=Trunc(00.1*  sqr_mul  );
      sqr_mul_0_5       :=Trunc(00.5*  sqr_mul  );
     _scl_mul_x         :=Trunc(mul1*  scl_mul.x);
     _scl_mul_y         :=Trunc(mul1*  scl_mul.y);
      bmp_ftimg_left_   :=      mul1*             bmp_ftimg_left;
      bmp_ftimg_top_    :=      mul1*             bmp_ftimg_top ;
      d1                :=     (mul1- _scl_mul_x)*bmp_ftimg_left;
      d2                :=     (mul1- _scl_mul_y)*bmp_ftimg_top ;
      d1_               :=Trunc(mul2*(        d1/mul1));
      d2_               :=Trunc(mul2*(        d2/mul1));
      scl_mul_x         :=Trunc(mul2*(_scl_mul_x/mul1));
      scl_mul_y         :=Trunc(mul2*(_scl_mul_y/mul1));
      r1                :=             scl_mul_x*   (                       bmp_ftimg_left)+d1_;
      v3                :=             scl_mul_y*   (nt_pix_arr_row_mrg_top+bmp_ftimg_top )+d2_;
      g2                :=            _scl_mul_y*    nt_pix_arr_row_mrg_top+bmp_ftimg_top_;
       first_row_pix_ptr:=Unaligned(@bmp_bkgnd_ptr [(nt_pix_arr_row_mrg_top+bmp_ftimg_top)*bmp_bkgnd_width+bmp_ftimg_left]);
           bmp_bkgnd_ptr:=Unaligned(@bmp_bkgnd_ptr [000000000000000000000000000000000000000000000000000000000000000000000]);
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000]);
      nt_pix_sht_arr_ptr:=Unaligned(@nt_pix_sht_arr[000000000000000000000000000000000000000000000000000000000000000000000]);
      nt_pix_ccl_arr_ptr:=Unaligned( nt_pix_arr_ptr);
      for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          row_parity:=not row_parity;
          v2        :=v3>>16;
          v2_       :=v2*bmp_bkgnd_width;
          py        :=MinSubMax(v2<<15,g2,mul1,_scl_mul_y);
          k2        :=py<<15;
          for x:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
              if Odd (nt_pix_sht_arr_ptr-first_row_pix_ptr) and row_parity then
                begin
                  v1                                    :=(scl_mul_x*nt_pix_sht_arr_ptr^+r1)>>16;
                  g1                                    :=_scl_mul_x*nt_pix_sht_arr_ptr^+bmp_ftimg_left_;
                  px                                    :=MinSubMax(v1<<15,g1,mul1,_scl_mul_x);
                  s0                                    :=px*py;
                  k1                                    :=px<<15;
                  bmp_bkgnd_ptr2                        :=bmp_bkgnd_ptr+v1+v2_;
                  s0_mul_2_div_alpha                    :=s0>>14;
                  if (s0>sqr_mul_0_1) then
                    begin
                     (bmp_bkgnd_ptr2+00000000000000000)^:=(PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.r+(s0_mul_2_div_alpha*(PRGBA(nt_pix_ccl_arr_ptr)^.r-PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.r))>>16)<<00+
                                                          (PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.g+(s0_mul_2_div_alpha*(PRGBA(nt_pix_ccl_arr_ptr)^.g-PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.g))>>16)<<08+
                                                          (PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.b+(s0_mul_2_div_alpha*(PRGBA(nt_pix_ccl_arr_ptr)^.b-PRGBA(bmp_bkgnd_ptr2+00000000000000000)^.b))>>16)<<16;
                    end;
                  if (k2-s0>sqr_mul_0_1) then
                    begin
                      s1_                               :=py<<1-s0_mul_2_div_alpha;
                     (bmp_bkgnd_ptr2+000000000000000+1)^:=(PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.r+(s1_*(PRGBA(nt_pix_ccl_arr_ptr)^.r-PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.r))>>16)<<00+
                                                          (PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.g+(s1_*(PRGBA(nt_pix_ccl_arr_ptr)^.g-PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.g))>>16)<<08+
                                                          (PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.b+(s1_*(PRGBA(nt_pix_ccl_arr_ptr)^.b-PRGBA(bmp_bkgnd_ptr2+000000000000000+1)^.b))>>16)<<16;
                    end;
                  if (k1-s0<=sqr_mul_0_5) then
                     (bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^:=nt_pix_ccl_arr_ptr^;
                  if (mul3-k1-k2+s0<=sqr_mul_0_5) then
                     (bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^:=nt_pix_ccl_arr_ptr^;
                end;
              Inc                                        (nt_pix_sht_arr_ptr);
              Inc                                        (nt_pix_ccl_arr_ptr);
            end;
          Inc                                            (nt_pix_cnt_arr_ptr);
          Inc(v3, scl_mul_y);
          Inc(g2,_scl_mul_y);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.FilNTColorScaleDownMip3; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_cnt_arr_ptr                                                                       : PInteger;
  nt_pix_sht_arr_ptr                                                                       : PInteger;
  nt_pix_ccl_arr_ptr                                                                       : PInteger;
       bmp_bkgnd_ptr2                                                                      : PInteger;
  scl_mul_x  , scl_mul_y,d1_,d2_,x,y,v1,v2,v2_,v3,r1,s1_,s0_mul_2_div_alpha,bmp_ftimg_left_: integer;
 _scl_mul_x  ,_scl_mul_y,d1 ,d2 ,g1,g2,px,py,s0,k1,k2,bmp_ftimg_top_,sqr_mul               : integer;
  sqr_mul_0_1, sqr_mul_0_5                                                                 : integer;
const
  mul1=ONE_SHL_15;
  mul2=ONE_SHL_16;
  mul3=ONE_SHL_30;
begin
  with fast_image_data_ptr0^ do
    begin
      sqr_mul           :=      mul1*      mul1;
      sqr_mul_0_1       :=Trunc(00.1*  sqr_mul  );
      sqr_mul_0_5       :=Trunc(00.5*  sqr_mul  );
     _scl_mul_x         :=Trunc(mul1*  scl_mul.x);
     _scl_mul_y         :=Trunc(mul1*  scl_mul.y);
      bmp_ftimg_left_   :=      mul1*             bmp_ftimg_left;
      bmp_ftimg_top_    :=      mul1*             bmp_ftimg_top ;
      d1                :=     (mul1- _scl_mul_x)*bmp_ftimg_left;
      d2                :=     (mul1- _scl_mul_y)*bmp_ftimg_top ;
      d1_               :=Trunc(mul2*(        d1/mul1));
      d2_               :=Trunc(mul2*(        d2/mul1));
      scl_mul_x         :=Trunc(mul2*(_scl_mul_x/mul1));
      scl_mul_y         :=Trunc(mul2*(_scl_mul_y/mul1));
      r1                :=             scl_mul_x*  (                       bmp_ftimg_left)+d1_;
      v3                :=             scl_mul_y*  (nt_pix_arr_row_mrg_top+bmp_ftimg_top )+d2_;
      g2                :=            _scl_mul_y*   nt_pix_arr_row_mrg_top+bmp_ftimg_top_;
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[nt_pix_arr_row_mrg_top]);
      nt_pix_sht_arr_ptr:=Unaligned(@nt_pix_sht_arr[0000000000000000000000]);
      nt_pix_ccl_arr_ptr:=Unaligned( nt_pix_arr_ptr);
      for y:=0 to bmp_ftimg_height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          v2   :=v3>>16;
          v2_  :=v2*bmp_bkgnd_width;
          py   :=MinSubMax(v2<<15,g2,mul1,_scl_mul_y);
          k2   :=py<<15;
          for x:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
              v1                                    :=(scl_mul_x*nt_pix_sht_arr_ptr^+r1)>>16;
              g1                                    :=_scl_mul_x*nt_pix_sht_arr_ptr^+bmp_ftimg_left_;
              px                                    :=MinSubMax(v1<<15,g1,mul1,_scl_mul_x);
              s0                                    :=px*py;
              k1                                    :=px<<15;
              bmp_bkgnd_ptr2                        :=bmp_bkgnd_ptr+v1+v2_;
              s0_mul_2_div_alpha                    :=s0>>14;
              if (s0>sqr_mul_0_1) then
                begin
                 (bmp_bkgnd_ptr2+00000000000000000)^:=(PRGBA(bmp_bkgnd_ptr2+0)^.r+(s0_mul_2_div_alpha*(PRGBA(nt_pix_ccl_arr_ptr)^.r-PRGBA(bmp_bkgnd_ptr2+0)^.r))>>16)<<00+
                                                      (PRGBA(bmp_bkgnd_ptr2+0)^.g+(s0_mul_2_div_alpha*(PRGBA(nt_pix_ccl_arr_ptr)^.g-PRGBA(bmp_bkgnd_ptr2+0)^.g))>>16)<<08+
                                                      (PRGBA(bmp_bkgnd_ptr2+0)^.b+(s0_mul_2_div_alpha*(PRGBA(nt_pix_ccl_arr_ptr)^.b-PRGBA(bmp_bkgnd_ptr2+0)^.b))>>16)<<16;
                end;
              if (k2-s0>sqr_mul_0_1) then
                begin
                  s1_                               :=py<<1-s0_mul_2_div_alpha;
                 (bmp_bkgnd_ptr2+00000000000000001)^:=(PRGBA(bmp_bkgnd_ptr2+1)^.r+(s1_               *(PRGBA(nt_pix_ccl_arr_ptr)^.r-PRGBA(bmp_bkgnd_ptr2+1)^.r))>>16)<<00+
                                                      (PRGBA(bmp_bkgnd_ptr2+1)^.g+(s1_               *(PRGBA(nt_pix_ccl_arr_ptr)^.g-PRGBA(bmp_bkgnd_ptr2+1)^.g))>>16)<<08+
                                                      (PRGBA(bmp_bkgnd_ptr2+1)^.b+(s1_               *(PRGBA(nt_pix_ccl_arr_ptr)^.b-PRGBA(bmp_bkgnd_ptr2+1)^.b))>>16)<<16;
                end;
              if (k1-s0<=sqr_mul_0_5) then
                 (bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^:=nt_pix_ccl_arr_ptr^;
              if (mul3-k1-k2+s0<=sqr_mul_0_5) then
                 (bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^:=nt_pix_ccl_arr_ptr^;
              Inc                                    (nt_pix_sht_arr_ptr);
              Inc                                    (nt_pix_ccl_arr_ptr);
            end;
          Inc                                        (nt_pix_cnt_arr_ptr);
          Inc(v3, scl_mul_y);
          Inc(g2,_scl_mul_y);
        end;
    end;
end; {$endregion}
} {$endregion}

{Empty}
procedure TFastImageProc.RSDNTColor009(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Color of Curent Layer}
// (constant) not clipped:
procedure TFastImageProc.RSDNTColorA00(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_cnt_arr_ptr   : PWord;
  nt_pix_sht_arr_ptr   : PWord;
  nt_pix_ccl_arr_ptr   : PInteger;
       bmp_bkgnd_ptr2  : PInteger;
  skip_pix0,skip_pix1  : TPtPos4;
  x,y,t,v1,v2,s0_,px,py: integer;
begin
  with fast_image_data_,fip_scale_data_var0 do
    begin
      SclNTResVar0        (fast_image_data_ptr_,fast_image_data_);
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[fast_image_data_ptr_^.nt_pix_arr_row_mrg_top];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[00000000000000000000000000000000000000000000];
      nt_pix_ccl_arr_ptr:=                       nt_pix_arr_ptr;
      for y:=0 to rct_ent.height-fast_image_data_ptr_^.nt_pix_arr_row_mrg_top-fast_image_data_ptr_^.nt_pix_arr_row_mrg_btm-1 do
        begin
          v2       :=(v3>>16)*bmp_bkgnd_width;
          skip_pix0:=MinSubMax1((v3>>16)<<15,g2,ONE_SHL_15,_scl_mul_y); //(Min2((v3>>16)<<15+ONE_SHL_15,g2+_scl_mul_y)-Max2((v3>>16)<<15,g2));
          py       :=skip_pix0.x;
          t        :=ONE_SHL_15-py;
          if skip_pix0.y then
            for x:=0 to nt_pix_cnt_arr_ptr^-1 do
              begin
                v1                           :=(scl_mul_x*nt_pix_sht_arr_ptr^+r1)>>16;
              //g1                           :=_scl_mul_x*nt_pix_sht_arr_ptr^+rct_ent_left;
                skip_pix1                    :=MinSubMax1(v1<<15,_scl_mul_x*nt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x); //(Min2(v1<<15+ONE_SHL_15,g1+_scl_mul_x)-Max2(v1<<15,g1));
                s0_                          :=(skip_pix1.x*py)>>14;
                             bmp_bkgnd_ptr2  :=fast_image_data_ptr_^.bmp_bkgnd_ptr+v1+v2;
                {$ifdef win64}
                ScalePix128A(MSK2_128,bmp_bkgnd_ptr2^,nt_pix_ccl_arr_ptr^,s0_,py<<1-s0_,(not skip_pix1.y));
                {$else}
                    ScalePix(bmp_bkgnd_ptr2  ,nt_pix_ccl_arr_ptr,      s0_);
                if (not skip_pix1.y) then
                    ScalePix(bmp_bkgnd_ptr2+1,nt_pix_ccl_arr_ptr,py<<1-s0_);
                {$endif}
                Inc(nt_pix_sht_arr_ptr);
                Inc(nt_pix_ccl_arr_ptr);
              end
          else
            for x:=0 to nt_pix_cnt_arr_ptr^-1 do
              begin
                v1                       :=(scl_mul_x*nt_pix_sht_arr_ptr^+r1)>>16;
              //g1                       :=_scl_mul_x*nt_pix_sht_arr_ptr^+rct_ent_left;
                px                       :=MinSubMax0(v1<<15,_scl_mul_x*nt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x); //(Min2(v1<<15+ONE_SHL_15,g1+_scl_mul_x)-Max2(v1<<15,g1));
                s0_                      :=(px*py)>>14;
                           bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+v1+v2;
                  ScalePix(bmp_bkgnd_ptr2,   nt_pix_ccl_arr_ptr,          s0_);
                Inc       (bmp_bkgnd_ptr2);
                  ScalePix(bmp_bkgnd_ptr2,   nt_pix_ccl_arr_ptr,   py <<1-s0_);
                Inc       (bmp_bkgnd_ptr2,bmp_bkgnd_width-1);
                  ScalePix(bmp_bkgnd_ptr2,   nt_pix_ccl_arr_ptr,   px <<1-s0_);
                Inc       (bmp_bkgnd_ptr2);
                if (PRGBA (bmp_bkgnd_ptr2)^.a=0) then
                          (bmp_bkgnd_ptr2)^:=nt_pix_ccl_arr_ptr^
                else
                  ScalePix(bmp_bkgnd_ptr2,   nt_pix_ccl_arr_ptr,(t-px)<<1+s0_);
                Inc(nt_pix_sht_arr_ptr);
                Inc(nt_pix_ccl_arr_ptr);
              end;
          Inc      (nt_pix_cnt_arr_ptr);
          Inc(v3, scl_mul_y);
          Inc(g2,_scl_mul_y);
        end;
    end;
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTColorA02(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_cnt_arr_ptr : PWord;
  nt_pix_sht_arr_ptr : PWord;
  nt_pix_ccl_arr_ptr : PInteger;
       bmp_bkgnd_ptr2: PInteger;
   x, y,v1,v2,s0_    : integer;
  px,py,t            : integer;
  skip_pix0,skip_pix1: TPtPos4;
  b0,b1              : boolean;
begin
  with fast_image_data_,fip_scale_data_var0 do
    begin
      RegNTResVar0            (fast_image_data_ptr_,fast_image_data_);
      SclNTResVar0            (fast_image_data_ptr_,fast_image_data_);
      nt_pix_cnt_arr_ptr    :=@fast_image_data_ptr_^.nt_pix_cnt_arr[fast_image_data_ptr_^.nt_pix_arr_row_mrg_top];
      nt_pix_sht_arr_ptr    :=@fast_image_data_ptr_^.nt_pix_sht_arr[0000000000000000000000];
      nt_pix_ccl_arr_ptr    :=                       nt_pix_arr_ptr;
      dh                    :=rct_src.top-    fast_image_data_ptr_^.nt_pix_arr_row_mrg_top;
      if (dh>0) then
        begin
          v3                += scl_mul_y*dh;
          g2                +=_scl_mul_y*dh;
          nt_pix_cnt_arr_ptr+=           dh;
          nt_pix_sht_arr_ptr+=res_var1-fast_image_data_ptr_^.nt_cnt_ind_arr[fast_image_data_ptr_^.nt_pix_arr_row_mrg_top];
          nt_pix_ccl_arr_ptr+=res_var1-fast_image_data_ptr_^.nt_cnt_ind_arr[fast_image_data_ptr_^.nt_pix_arr_row_mrg_top];
        end;
      if (res_var2<0) then
        Exit;
      for y:=0 to res_var2+1 do
        begin
          if (PWord(nt_pix_sht_arr_ptr)-PWord(@fast_image_data_ptr_^.nt_pix_sht_arr[0])>Length(fast_image_data_ptr_^.nt_pix_sht_arr)-1) then
            Exit;
          v2       :=(v3>>16)*bmp_bkgnd_width;
          skip_pix0:=MinSubMax1((v3>>16)<<15,g2,ONE_SHL_15,_scl_mul_y);
          py       :=skip_pix0.x;
          t        :=ONE_SHL_15-py;
          if skip_pix0.y then
            begin
              b0:=((v3>>16)>=rct_clp_ptr^.top) and ((v3>>16)<rct_clp_ptr^.bottom);
              if b0 then
                for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                  begin
                    v1                         :=                  (scl_mul_x*nt_pix_sht_arr_ptr^+r1)>>16;
                    skip_pix1                  :=MinSubMax1(v1<<15,_scl_mul_x*nt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x);
                    s0_                        :=(skip_pix1.x*py)>>14;
                                 bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+v1+v2;
                        ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,      s0_);
                    if (not skip_pix1.y) then
                      begin
                        Inc     (bmp_bkgnd_ptr2);
                        ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,py<<1-s0_);
                      end;
                    Inc(nt_pix_sht_arr_ptr);
                    Inc(nt_pix_ccl_arr_ptr);
                  end
              else
                for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                  begin
                    Inc(nt_pix_sht_arr_ptr);
                    Inc(nt_pix_ccl_arr_ptr);
                  end;
            end
          else
            begin
              b0:=(0+(v3>>16)>=rct_clp_ptr^.top) and (0+(v3>>16)<rct_clp_ptr^.bottom);
              b1:=(1+(v3>>16)>=rct_clp_ptr^.top) and (1+(v3>>16)<rct_clp_ptr^.bottom);
              if b0 then
                begin
                  if b1 then
                    for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                      begin
                        v1                       :=                  (scl_mul_x*nt_pix_sht_arr_ptr^+r1)>>16;
                        px                       :=MinSubMax0(v1<<15,_scl_mul_x*nt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x);
                        s0_                      :=(px*py)>>14;
                                   bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+v1+v2;
                          ScalePix(bmp_bkgnd_ptr2,   nt_pix_ccl_arr_ptr,          s0_);
                        Inc       (bmp_bkgnd_ptr2);
                          ScalePix(bmp_bkgnd_ptr2,   nt_pix_ccl_arr_ptr,   py <<1-s0_);
                        Inc       (bmp_bkgnd_ptr2,bmp_bkgnd_width-1);
                          ScalePix(bmp_bkgnd_ptr2,   nt_pix_ccl_arr_ptr,   px <<1-s0_);
                        Inc       (bmp_bkgnd_ptr2);
                        if (PRGBA (bmp_bkgnd_ptr2)^.a=0) then
                                  (bmp_bkgnd_ptr2)^:=nt_pix_ccl_arr_ptr^
                        else
                          ScalePix(bmp_bkgnd_ptr2,   nt_pix_ccl_arr_ptr,(t-px)<<1+s0_);
                        Inc(nt_pix_sht_arr_ptr);
                        Inc(nt_pix_ccl_arr_ptr);
                      end
                  else
                    for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                      begin
                        v1                       :=                   (scl_mul_x*nt_pix_sht_arr_ptr^+r1)>>16;
                        s0_                      :=(MinSubMax0(v1<<15,_scl_mul_x*nt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x)*py)>>14;
                                   bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+v1+v2;
                          ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,       s0_);
                        Inc       (bmp_bkgnd_ptr2);
                          ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,py <<1-s0_);
                        Inc(nt_pix_sht_arr_ptr);
                        Inc(nt_pix_ccl_arr_ptr);
                      end;
                end
              else
                begin
                  if b1 then
                    for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                      begin
                        v1                       :=                  (scl_mul_x*nt_pix_sht_arr_ptr^+r1)>>16;
                        px                       :=MinSubMax0(v1<<15,_scl_mul_x*nt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x);
                        s0_                      :=(px*py)>>14;
                                   bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+v1+v2;
                        Inc       (bmp_bkgnd_ptr2, bmp_bkgnd_width);
                          ScalePix(bmp_bkgnd_ptr2,   nt_pix_ccl_arr_ptr,   px <<1-s0_);
                        Inc       (bmp_bkgnd_ptr2);
                        if (PRGBA (bmp_bkgnd_ptr2)^.a=0) then
                                  (bmp_bkgnd_ptr2)^:=nt_pix_ccl_arr_ptr^
                        else
                          ScalePix(bmp_bkgnd_ptr2,   nt_pix_ccl_arr_ptr,(t-px)<<1+s0_);
                        Inc(nt_pix_sht_arr_ptr);
                        Inc(nt_pix_ccl_arr_ptr);
                      end
                  else
                    for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                      begin
                        Inc(nt_pix_sht_arr_ptr);
                        Inc(nt_pix_ccl_arr_ptr);
                      end;
                end;
            end;
          Inc(nt_pix_cnt_arr_ptr);
          Inc(v3, scl_mul_y);
          Inc(g2,_scl_mul_y);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTColorA04(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_cnt_arr_ptr : PWord;
  nt_pix_sht_arr_ptr : PWord;
  nt_pix_ccl_arr_ptr : PInteger;
       bmp_bkgnd_ptr2: PInteger;
   x, y,v1,v2,s0_    : integer;
  px,py,s0,t         : integer;
  skip_pix0,skip_pix1: TPtPos4;
  b0,b1              : boolean;
  c0,c1              : boolean;
begin
  with fast_image_data_,fip_scale_data_var0 do
    begin
      RegNTResVar0            (fast_image_data_ptr_,fast_image_data_);
      SclNTResVar0            (fast_image_data_ptr_,fast_image_data_);
      nt_pix_cnt_arr_ptr    :=@fast_image_data_ptr_^.nt_pix_cnt_arr[fast_image_data_ptr_^.nt_pix_arr_row_mrg_top];
      nt_pix_sht_arr_ptr    :=@fast_image_data_ptr_^.nt_pix_sht_arr[00000000000000000000000000000000000000000000];
      nt_pix_ccl_arr_ptr    :=                       nt_pix_arr_ptr;
      dh                    :=rct_src.top-fast_image_data_ptr_^.nt_pix_arr_row_mrg_top;
      if (dh>0) then
        begin
          v3                += scl_mul_y*dh;
          g2                +=_scl_mul_y*dh;
          nt_pix_cnt_arr_ptr+=           dh;
          nt_pix_sht_arr_ptr+=res_var1-fast_image_data_ptr_^.nt_cnt_ind_arr[fast_image_data_ptr_^.nt_pix_arr_row_mrg_top];
          nt_pix_ccl_arr_ptr+=res_var1-fast_image_data_ptr_^.nt_cnt_ind_arr[fast_image_data_ptr_^.nt_pix_arr_row_mrg_top];
        end;
      if (res_var2<0) then
        Exit;
      for y:=0 to res_var2+1 do
        begin
          if (PWord(nt_pix_sht_arr_ptr)-PWord(@fast_image_data_ptr_^.nt_pix_sht_arr[0])>Length(fast_image_data_ptr_^.nt_pix_sht_arr)-1) then
            Exit;
          v2       :=(v3>>16)*bmp_bkgnd_width;
          skip_pix0:=MinSubMax1((v3>>16)<<15,g2,ONE_SHL_15,_scl_mul_y); //(Min2((v3>>16)<<15+ONE_SHL_15,g2+_scl_mul_y)-Max2((v3>>16)<<15,g2));
          py       :=skip_pix0.x;
          t        :=ONE_SHL_15-py;
          if skip_pix0.y then
            begin
              b0:=((v3>>16)>=rct_clp_ptr^.top) and ((v3>>16)<rct_clp_ptr^.bottom);
              if b0 then
                for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                  begin
                    v1                           :=                  (scl_mul_x*nt_pix_sht_arr_ptr^+r1)>>16;
                  //g1                           :=                  _scl_mul_x*nt_pix_sht_arr_ptr^+rct_ent_left;
                    skip_pix1                    :=MinSubMax1(v1<<15,_scl_mul_x*nt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x); //(Min2(v1<<15+ONE_SHL_15,g1+_scl_mul_x)-Max2(v1<<15,g1));
                    px                           :=skip_pix1.x;
                    s0                           :=px*py;
                    s0_                          :=s0>>14;
                                   bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+v1+v2;
                    if   (v1+0>=rct_clp_ptr^.left) and (v1+0<rct_clp_ptr^.right) then
                          ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,      s0_);
                    if (not skip_pix1.y) then
                      if (v1+1>=rct_clp_ptr^.left) and (v1+1<rct_clp_ptr^.right) then
                        begin
                          Inc     (bmp_bkgnd_ptr2);
                          ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,py<<1-s0_);
                        end;
                    Inc(nt_pix_sht_arr_ptr);
                    Inc(nt_pix_ccl_arr_ptr);
                  end
              else
                for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                  begin
                    Inc(nt_pix_sht_arr_ptr);
                    Inc(nt_pix_ccl_arr_ptr);
                  end;
            end
          else
            begin
              b0:=(0+(v3>>16)>=rct_clp_ptr^.top) and (0+(v3>>16)<rct_clp_ptr^.bottom);
              b1:=(1+(v3>>16)>=rct_clp_ptr^.top) and (1+(v3>>16)<rct_clp_ptr^.bottom);
              if b0 then
                begin
                  if b1 then
                    for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                      begin
                        v1                           :=                  (scl_mul_x*nt_pix_sht_arr_ptr^+r1)>>16;
                      //g1                           :=                  _scl_mul_x*nt_pix_sht_arr_ptr^+rct_ent_left;
                        px                           :=MinSubMax0(v1<<15,_scl_mul_x*nt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x); //(Min2(v1<<15+ONE_SHL_15,g1+_scl_mul_x)-Max2(v1<<15,g1));
                        s0                           :=px*py;
                        s0_                          :=s0>>14;
                        c0                           :=(v1+0>=rct_clp_ptr^.left) and (v1+0<rct_clp_ptr^.right);
                        c1                           :=(v1+1>=rct_clp_ptr^.left) and (v1+1<rct_clp_ptr^.right);
                        if c0 then
                          begin
                                       bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+v1+v2;
                              ScalePix(bmp_bkgnd_ptr2,   nt_pix_ccl_arr_ptr,           s0_);
                            Inc       (bmp_bkgnd_ptr2, bmp_bkgnd_width);
                              ScalePix(bmp_bkgnd_ptr2,   nt_pix_ccl_arr_ptr,    px <<1-s0_);
                          end;
                        if c1 then
                          begin
                                       bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+v1+v2+1;
                              ScalePix(bmp_bkgnd_ptr2,   nt_pix_ccl_arr_ptr,    py <<1-s0_);
                            Inc       (bmp_bkgnd_ptr2, bmp_bkgnd_width);
                            if  (PRGBA(bmp_bkgnd_ptr2)^.a=0) then
                                      (bmp_bkgnd_ptr2)^ :=nt_pix_ccl_arr_ptr^
                            else
                              ScalePix(bmp_bkgnd_ptr2,    nt_pix_ccl_arr_ptr,(t-px)<<1+s0_);
                          end;
                        Inc(nt_pix_sht_arr_ptr);
                        Inc(nt_pix_ccl_arr_ptr);
                      end
                  else
                    for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                      begin
                        v1                       :=                  (scl_mul_x*nt_pix_sht_arr_ptr^+r1)>>16;
                      //g1                       :=                  _scl_mul_x*nt_pix_sht_arr_ptr^+rct_ent_left;
                        px                       :=MinSubMax0(v1<<15,_scl_mul_x*nt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x); //(Min2(v1<<15+ONE_SHL_15,g1+_scl_mul_x)-Max2(v1<<15,g1));
                        s0                       :=px*py;
                        s0_                      :=s0>>14;
                                   bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+v1+v2;
                        if (v1+0>=rct_clp_ptr^.left) and (v1+0<rct_clp_ptr^.right) then
                          ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,       s0_);
                        Inc       (bmp_bkgnd_ptr2);
                        if (v1+1>=rct_clp_ptr^.left) and (v1+1<rct_clp_ptr^.right) then
                          ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,py <<1-s0_);
                        Inc(nt_pix_sht_arr_ptr);
                        Inc(nt_pix_ccl_arr_ptr);
                      end;
                end
              else
                begin
                  if b1 then
                    for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                      begin
                        v1                           :=                  (scl_mul_x*nt_pix_sht_arr_ptr^+r1)>>16;
                      //g1                           :=                  _scl_mul_x*nt_pix_sht_arr_ptr^+rct_ent_left;
                        px                           :=MinSubMax0(v1<<15,_scl_mul_x*nt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x); //(Min2(v1<<15+ONE_SHL_15,g1+_scl_mul_x)-Max2(v1<<15,g1));
                        s0                           :=px*py;
                        s0_                          :=s0>>14;
                                       bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+v1+v2;
                        Inc           (bmp_bkgnd_ptr2, bmp_bkgnd_width);
                        if (v1+0>=rct_clp_ptr^.left) and (v1+0<rct_clp_ptr^.right) then
                              ScalePix(bmp_bkgnd_ptr2,   nt_pix_ccl_arr_ptr,   px <<1-s0_);
                        Inc           (bmp_bkgnd_ptr2);
                        if (v1+1>=rct_clp_ptr^.left) and (v1+1<rct_clp_ptr^.right) then
                          begin
                            if (PRGBA (bmp_bkgnd_ptr2)^.a=0) then
                                      (bmp_bkgnd_ptr2)^:=nt_pix_ccl_arr_ptr^
                            else
                              ScalePix(bmp_bkgnd_ptr2,   nt_pix_ccl_arr_ptr,(t-px)<<1+s0_);
                          end;
                        Inc(nt_pix_sht_arr_ptr);
                        Inc(nt_pix_ccl_arr_ptr);
                      end
                  else
                    for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                      begin
                        Inc(nt_pix_sht_arr_ptr);
                        Inc(nt_pix_ccl_arr_ptr);
                      end;
                end;
            end;
          Inc(nt_pix_cnt_arr_ptr);
          Inc(v3, scl_mul_y);
          Inc(g2,_scl_mul_y);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTColorA06(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

// (constant) not clipped:
procedure TFastImageProc.RSDNTColorA10(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_cnt_arr_ptr : PWord;
  nt_pix_sht_arr_ptr : PWord;
  nt_pix_ccl_arr_ptr : PInteger;
       bmp_bkgnd_ptr2: PInteger;
  pix_area           : TPtPosF;
  scl_mul_           : TPtPosF;
  d0,d1,d2,d3,d4,d2_ : double;
  x,y,h0,h1          : integer;
  b0                 : boolean;
begin
  with fast_image_data_,fip_scale_data_var1 do
    begin
      SclNTResVar1        (fast_image_data_ptr_,fast_image_data_);
      RegNTResVar2        (fast_image_data_ptr_,fast_image_data_);
      RegNTResVar3        (fast_image_data_ptr_,fast_image_data_);
      if (res_var2<=0) then
        Exit;
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      nt_pix_ccl_arr_ptr:=                       nt_pix_arr_ptr+res_var1;
      d4                :=1/scl_mul.x;
      d2_               :=sqrt(scl_mul.y)*ONE_SHL_16;
      scl_mul_          :=PtPosF(res_var8*scl_mul.x,res_var3*scl_mul.y);
      for y:=0 to res_var2 do
        begin
          d1        :=scl_mul_.y*(res_var0+y);
          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1        *=bmp_bkgnd_width;
          if (pix_area.y<scl_mul.y) then
            begin
              d2:=sqrt(          pix_area.y)*ONE_SHL_16;
              d3:=sqrt(scl_mul.y-pix_area.y)*ONE_SHL_16;
              for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                begin
                  d0                                     :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                  h0                                     :=Trunc  (d0+m0);
                    pix_area.x                           :=(h0+1)-(d0+m0);
                  b0                                     :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                           :=scl_mul.x;
                                           bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  {$ifdef win64}
                  //ScalePix128F(MSK7_128,PQWord(bmp_bkgnd_ptr2)^,nt_pix_ccl_arr_ptr^,Trunc(sqrt(pix_area.x)*d2),Trunc(sqrt(scl_mul.x-pix_area.x)*d2),Trunc(sqrt(pix_area.x)*d3),Trunc(sqrt(scl_mul.x-pix_area.x)*d3),b0,bmp_bkgnd_width);

                  // SIMD scheme(SSE2):
                  //  0             0            scl_mul .x   scl_mul .x  //  a
                  //  pix_area.x    pix_area.x   pix_area.x   pix_area.x  //  b
                  //  d2            d3           d2           d3          //  c

                  // subpd                                                //     (a-b)
                  // sqrtpd                                               // sqrt(a-b)
                  // mulpd                                                // sqrt(a-b)*c

                    ScalePix128B(MSK2_128,(bmp_bkgnd_ptr2+0)^,nt_pix_ccl_arr_ptr^,Trunc({   pix_area.x*d4 }{(           pix_area.x /(scl_mul.x))}{(3*           pix_area.x +1)/(           pix_area.x +3)}sqrt(          pix_area.x)*d2),Trunc({   pix_area.x*d4 }{(           pix_area.x /(scl_mul.x))}{(3*           pix_area.x +1)/(           pix_area.x +3)}sqrt(          pix_area.x)*d3),bmp_bkgnd_width);
                  if b0 then
                    ScalePix128B(MSK2_128,(bmp_bkgnd_ptr2+1)^,nt_pix_ccl_arr_ptr^,Trunc({(1-pix_area.x*d4)}{((scl_mul.x-pix_area.x)/(scl_mul.x))}{(3*(scl_mul.x-pix_area.x)+1)/((scl_mul.x-pix_area.x)+3)}sqrt(scl_mul.x-pix_area.x)*d2),Trunc({(1-pix_area.x*d4)}{((scl_mul.x-pix_area.x)/(scl_mul.x))}{(3*(scl_mul.x-pix_area.x)+1)/((scl_mul.x-pix_area.x)+3)}sqrt(scl_mul.x-pix_area.x)*d3),bmp_bkgnd_width);
                  {$else}
                    ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(          pix_area.x)*d2));
                  Inc       (bmp_bkgnd_ptr2);
                  if b0 then
                    ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(scl_mul.x-pix_area.x)*d2));
                  Inc       (bmp_bkgnd_ptr2,bmp_bkgnd_width-1);
                    ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(          pix_area.x)*d3));
                  Inc       (bmp_bkgnd_ptr2);
                  if b0 then
                    ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(scl_mul.x-pix_area.x)*d3));
                  {$endif}
                  Inc(nt_pix_sht_arr_ptr);
                  Inc(nt_pix_ccl_arr_ptr);
                end;
            end
          else
            begin
              //d2:=sqrt(scl_mul.y)*ONE_SHL_16;
              for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                begin
                  d0                                    :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                  h0                                    :=Trunc  (d0+m0);
                    pix_area.x                          :=(h0+1)-(d0+m0);
                  b0                                    :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                          :=scl_mul.x;
                                          bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  {$ifdef win64}
                  //ScalePix128E(MSK7_128,PQWord(bmp_bkgnd_ptr2)^,nt_pix_ccl_arr_ptr^,Trunc(sqrt(pix_area.x)*d2_),Trunc(sqrt(scl_mul.x-pix_area.x)*d2_),b0);
                    ScalePix128A(MSK2_128,bmp_bkgnd_ptr2^,nt_pix_ccl_arr_ptr^,Trunc({pix_area.x*d4}{(pix_area.x/(scl_mul.x))}{(3*pix_area.x+1)/(pix_area.x+3)}sqrt(pix_area.x)*d2_),Trunc({(1-pix_area.x*d4)}{((scl_mul.x-pix_area.x)/(scl_mul.x))}{(3*(scl_mul.x-pix_area.x)+1)/((scl_mul.x-pix_area.x)+3)}sqrt(scl_mul.x-pix_area.x)*d2_),b0);
                  {$else}
                    ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(          pix_area.x)*d2_));
                  Inc       (bmp_bkgnd_ptr2);
                  if b0 then
                    ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(scl_mul.x-pix_area.x)*d2_));
                  {$endif}
                  Inc(nt_pix_sht_arr_ptr);
                  Inc(nt_pix_ccl_arr_ptr);
                end;
            end;
          Inc        (nt_pix_cnt_arr_ptr);
        end;
    end;
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTColorA12(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_cnt_arr_ptr : PWord;
  nt_pix_sht_arr_ptr : PWord;
  nt_pix_ccl_arr_ptr : PInteger;
       bmp_bkgnd_ptr2: PInteger;
  pix_area           : TPtPosF;
  scl_mul_           : TPtPosF;
  d0,d1,d2,d3,d4,d2_ : double;
  x,y,h0,h1,h1_      : integer;
  check_exit         : boolean=False;
  b0,p0,p1           : boolean;
label
  l1;
begin
  with fast_image_data_,fip_scale_data_var1 do
    begin
      SclNTResVar1        (fast_image_data_ptr_,fast_image_data_);
      RegNTResVar2        (fast_image_data_ptr_,fast_image_data_);
      RegNTResVar3        (fast_image_data_ptr_,fast_image_data_);
      if (res_var2<=0) then
        Exit;
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      nt_pix_ccl_arr_ptr:=                       nt_pix_arr_ptr+res_var1;
      d4                :=1/scl_mul.x;
      d2_               :=sqrt(scl_mul.y)*ONE_SHL_16;
      scl_mul_          :=PtPosF(res_var8*scl_mul.x,res_var3*scl_mul.y);

      {top border---} {$region -fold}
        begin
          d1        :=scl_mul_.y*(res_var0+0);

          l1:

          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1_       := h1;
          h1        *=bmp_bkgnd_width;
          p0        :=(h1_+0>=rct_clp_ptr^.top   ) and
                      (h1_+0< rct_clp_ptr^.bottom);
          p1        :=(h1_+1>=rct_clp_ptr^.top   ) and
                      (h1_+1< rct_clp_ptr^.bottom);
          if (pix_area.y<scl_mul.y) then
            begin
              d2:=sqrt(          pix_area.y)*ONE_SHL_16;
              d3:=sqrt(scl_mul.y-pix_area.y)*ONE_SHL_16;
              for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                begin
                  d0                                     :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                  h0                                     :=Trunc  (d0+m0);
                    pix_area.x                           :=(h0+1)-(d0+m0);
                  b0                                     :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                           :=scl_mul.x;
                                           bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  {$ifdef win64}
                  if p0 then
                    ScalePix128A(MSK2_128,(bmp_bkgnd_ptr2+000000000000000)^,nt_pix_ccl_arr_ptr^,Trunc(sqrt(pix_area.x)*d2),Trunc(sqrt(scl_mul.x-pix_area.x)*d2),b0);
                  if p1 then
                    ScalePix128A(MSK2_128,(bmp_bkgnd_ptr2+bmp_bkgnd_width)^,nt_pix_ccl_arr_ptr^,Trunc(sqrt(pix_area.x)*d2),Trunc(sqrt(scl_mul.x-pix_area.x)*d2),b0);
                  {$else}
                  if p0 then
                    begin
                        ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(          pix_area.x)*d2));
                      Inc       (bmp_bkgnd_ptr2);
                      if b0 then
                        ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(scl_mul.x-pix_area.x)*d2));
                    end;
                  Inc       (bmp_bkgnd_ptr2,bmp_bkgnd_width-1);
                  if p1 then
                    begin
                        ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(          pix_area.x)*d3));
                      Inc       (bmp_bkgnd_ptr2);
                      if b0 then
                        ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(scl_mul.x-pix_area.x)*d3));
                    end;
                  {$endif}
                  Inc(nt_pix_sht_arr_ptr);
                  Inc(nt_pix_ccl_arr_ptr);
                end;
            end
          else
            begin
              //d2:=sqrt(scl_mul.y)*ONE_SHL_16;
              for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                begin
                  d0                                    :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                  h0                                    :=Trunc  (d0+m0);
                    pix_area.x                          :=(h0+1)-(d0+m0);
                  b0                                    :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                          :=scl_mul.x;
                                          bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  {$ifdef win64}
                  if p0 then
                    ScalePix128A(MSK2_128,bmp_bkgnd_ptr2^,nt_pix_ccl_arr_ptr^,Trunc(sqrt(pix_area.x)*d2_),Trunc(sqrt(scl_mul.x-pix_area.x)*d2_),b0);
                  {$else}
                  if p0 then
                    begin
                        ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(          pix_area.x)*d2_));
                      Inc       (bmp_bkgnd_ptr2);
                      if b0 then
                        ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(scl_mul.x-pix_area.x)*d2_));
                    end;
                  {$endif}
                  Inc(nt_pix_sht_arr_ptr);
                  Inc(nt_pix_ccl_arr_ptr);
                end;
            end;
          Inc        (nt_pix_cnt_arr_ptr);

          if check_exit then
            Exit;

        end; {$endregion}

      {main loop----} {$region -fold}
      if (res_var2>1) then
      for y:=1 to res_var2-1 do
        begin
          d1        :=scl_mul_.y*(res_var0+y);
          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1        *=bmp_bkgnd_width;
          if (pix_area.y<scl_mul.y) then
            begin
              d2:=sqrt(          pix_area.y)*ONE_SHL_16;
              d3:=sqrt(scl_mul.y-pix_area.y)*ONE_SHL_16;
              for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                begin
                  d0                                     :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                  h0                                     :=Trunc  (d0+m0);
                    pix_area.x                           :=(h0+1)-(d0+m0);
                  b0                                     :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                           :=scl_mul.x;
                                           bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  {$ifdef win64}
                    ScalePix128B(MSK2_128,(bmp_bkgnd_ptr2+0)^,nt_pix_ccl_arr_ptr^,Trunc(sqrt(          pix_area.x)*d2),Trunc(sqrt(          pix_area.x)*d3),bmp_bkgnd_width);
                  if b0 then
                    ScalePix128B(MSK2_128,(bmp_bkgnd_ptr2+1)^,nt_pix_ccl_arr_ptr^,Trunc(sqrt(scl_mul.x-pix_area.x)*d2),Trunc(sqrt(scl_mul.x-pix_area.x)*d3),bmp_bkgnd_width);
                  {$else}
                    ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(          pix_area.x)*d2));
                  Inc       (bmp_bkgnd_ptr2);
                  if b0 then
                    ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(scl_mul.x-pix_area.x)*d2));
                  Inc       (bmp_bkgnd_ptr2,bmp_bkgnd_width-1);
                    ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(          pix_area.x)*d3));
                  Inc       (bmp_bkgnd_ptr2);
                  if b0 then
                    ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(scl_mul.x-pix_area.x)*d3));
                  {$endif}
                  Inc(nt_pix_sht_arr_ptr);
                  Inc(nt_pix_ccl_arr_ptr);
                end;
            end
          else
            begin
              //d2:=sqrt(scl_mul.y)*ONE_SHL_16;
              for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                begin
                  d0                                  :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                  h0                                  :=Trunc  (d0+m0);
                    pix_area.x                        :=(h0+1)-(d0+m0);
                  b0                                  :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                        :=scl_mul.x;
                                        bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  {$ifdef win64}
                  ScalePix128A(MSK2_128,bmp_bkgnd_ptr2^,nt_pix_ccl_arr_ptr^,Trunc(sqrt(pix_area.x)*d2_),Trunc(sqrt(scl_mul.x-pix_area.x)*d2_),b0);
                  {$else}
                    ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(          pix_area.x)*d2_));
                  Inc       (bmp_bkgnd_ptr2);
                  if b0 then
                    ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(scl_mul.x-pix_area.x)*d2_));
                  {$endif}
                  Inc(nt_pix_sht_arr_ptr);
                  Inc(nt_pix_ccl_arr_ptr);
                end;
            end;
          Inc        (nt_pix_cnt_arr_ptr);
        end; {$endregion}

      {bottom border} {$region -fold}

      {
      if (res_var2>0{1}) then
        begin
          d1        :=scl_mul_.y*(res_var0+res_var2);
          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1_       := h1;
          h1        *=bmp_bkgnd_width;
          p0        :=(h1_+0>=rct_clp_ptr^.top   ) and
                      (h1_+0< rct_clp_ptr^.bottom);
          if p0 then
            for x:=0 to nt_pix_cnt_arr_ptr^-1 do
              begin
                if (PDWord(                       nt_pix_ccl_arr_ptr)-
                    PDWord(@fast_image_data_ptr_^.nt_pix_ccl_arr[0])>
                    Length( fast_image_data_ptr_^.nt_pix_ccl_arr)-1) then
                  Exit;
                d0                                    :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                h0                                    :=Trunc  (d0+m0);
                  pix_area.x                          :=(h0+1)-(d0+m0);
                b0                                    :=(pix_area.x<scl_mul.x);
                if (not b0) then
                  pix_area.x                          :=scl_mul.x;
                                        bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                {$ifdef win64}
                  ScalePix128A(MSK2_128,bmp_bkgnd_ptr2^,nt_pix_ccl_arr_ptr^,Trunc(sqrt(pix_area.x)*d2_),Trunc(sqrt(scl_mul.x-pix_area.x)*d2_),b0);
                {$else}
                  ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(          pix_area.x)*d2_));
                Inc       (bmp_bkgnd_ptr2);
                if b0 then
                  ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(scl_mul.x-pix_area.x)*d2_));
                {$endif}
                Inc(nt_pix_sht_arr_ptr);
                Inc(nt_pix_ccl_arr_ptr);
              end;
        end;
        }

      if (res_var2>0) and
         (PWord (                       nt_pix_cnt_arr_ptr)-
          PWord (@fast_image_data_ptr_^.nt_pix_cnt_arr[0])<
          Length( fast_image_data_ptr_^.nt_pix_cnt_arr)) then
        begin
          d1        :=scl_mul_.y*(res_var0+res_var2);

          check_exit:=True;
          goto l1;

          {
          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1_       := h1;
          h1        *=bmp_bkgnd_width;
          p0        :=(h1_+0>=rct_clp_ptr^.top   ) and
                      (h1_+0< rct_clp_ptr^.bottom);
          p1        :=(h1_+1>=rct_clp_ptr^.top   ) and
                      (h1_+1< rct_clp_ptr^.bottom);
          if (pix_area.y<scl_mul.y) then
            begin
              d2:=sqrt(          pix_area.y)*ONE_SHL_16;
              d3:=sqrt(scl_mul.y-pix_area.y)*ONE_SHL_16;
              for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                begin
                  d0                                     :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                  h0                                     :=Trunc  (d0+m0);
                    pix_area.x                           :=(h0+1)-(d0+m0);
                  b0                                     :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                           :=scl_mul.x;
                                           bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  {$ifdef win64}
                  if p0 then
                    ScalePix128A(MSK2_128,(bmp_bkgnd_ptr2+000000000000000)^,nt_pix_ccl_arr_ptr^,Trunc(sqrt(pix_area.x)*d2),Trunc(sqrt(scl_mul.x-pix_area.x)*d2),b0);
                  if p1 then
                    ScalePix128A(MSK2_128,(bmp_bkgnd_ptr2+bmp_bkgnd_width)^,nt_pix_ccl_arr_ptr^,Trunc(sqrt(pix_area.x)*d2),Trunc(sqrt(scl_mul.x-pix_area.x)*d2),b0);
                  {$else}
                  if p0 then
                    begin
                        ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(          pix_area.x)*d2));
                      Inc       (bmp_bkgnd_ptr2);
                      if b0 then
                        ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(scl_mul.x-pix_area.x)*d2));
                    end;
                  Inc       (bmp_bkgnd_ptr2,bmp_bkgnd_width-1);
                  if p1 then
                    begin
                        ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(          pix_area.x)*d3));
                      Inc       (bmp_bkgnd_ptr2);
                      if b0 then
                        ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(scl_mul.x-pix_area.x)*d3));
                    end;
                  {$endif}
                  Inc(nt_pix_sht_arr_ptr);
                  Inc(nt_pix_ccl_arr_ptr);
                end;
            end
          else
            begin
              //d2:=sqrt(scl_mul.y)*ONE_SHL_16;
              for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                begin
                  d0                                    :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                  h0                                    :=Trunc  (d0+m0);
                    pix_area.x                          :=(h0+1)-(d0+m0);
                  b0                                    :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                          :=scl_mul.x;
                                          bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  {$ifdef win64}
                  if p0 then
                    ScalePix128A(MSK2_128,bmp_bkgnd_ptr2^,nt_pix_ccl_arr_ptr^,Trunc(sqrt(pix_area.x)*d2_),Trunc(sqrt(scl_mul.x-pix_area.x)*d2_),b0);
                  {$else}
                  if p0 then
                    begin
                        ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(          pix_area.x)*d2_));
                      Inc       (bmp_bkgnd_ptr2);
                      if b0 then
                        ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,Trunc(sqrt(scl_mul.x-pix_area.x)*d2_));
                    end;
                  {$endif}
                  Inc(nt_pix_sht_arr_ptr);
                  Inc(nt_pix_ccl_arr_ptr);
                end;
            end;
          }

        end; {$endregion}

    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTColorA14(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTColorA16(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

// (constant) not clipped:
procedure TFastImageProc.RSDNTColor000(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_cnt_arr_ptr : PWord;
  nt_pix_sht_arr_ptr : PWord;
  nt_pix_ccl_arr_ptr : PInteger;
       bmp_bkgnd_ptr2: PInteger;
  pix_area           : TPtPosF;
  scl_mul_           : TPtPosF;
  d0,d1,d2,d3,d2_    : double;
  x,y,h0,h1          : integer;
  b0                 : boolean;
begin
  with fast_image_data_,fip_scale_data_var1 do
    begin
      SclNTResVar1        (fast_image_data_ptr_,fast_image_data_);
      RegNTResVar2        (fast_image_data_ptr_,fast_image_data_);
      RegNTResVar3        (fast_image_data_ptr_,fast_image_data_);
      if (res_var2<=0) then
        Exit;
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      nt_pix_ccl_arr_ptr:=                       nt_pix_arr_ptr+res_var1;
      d2_               :=scl_mul.y*Length(sqrt_arr1);
      scl_mul_          :=PtPosF(res_var8*scl_mul.x,res_var3*scl_mul.y);

      {main loop-----} {$region -fold}
      for y:=0 to res_var2-1 do
        begin
          d1        :=scl_mul_.y*(res_var0+y);
          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1        *=bmp_bkgnd_width;
          if (pix_area.y<scl_mul.y) then
            begin
              d2:=(          pix_area.y)*Length(sqrt_arr1);
              d3:=(scl_mul.y-pix_area.y)*Length(sqrt_arr1);
              for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                begin
                  d0                                     :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                  h0                                     :=Trunc  (d0+m0);
                    pix_area.x                           :=(h0+1)-(d0+m0);
                  b0                                     :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                           :=scl_mul.x;
                                           bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                    ScalePix128B(MSK2_128,(bmp_bkgnd_ptr2+0)^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc((          pix_area.x)*d2)],sqrt_arr1[Trunc((          pix_area.x)*d3)],bmp_bkgnd_width);
                  if b0 then
                    ScalePix128B(MSK2_128,(bmp_bkgnd_ptr2+1)^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)],bmp_bkgnd_width);
                  Inc(nt_pix_sht_arr_ptr);
                  Inc(nt_pix_ccl_arr_ptr);
                end;
            end
          else
            begin
              //d2:=scl_mul.y*Length(sqrt_arr1);
              for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                begin
                  d0                                  :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                  h0                                  :=Trunc  (d0+m0);
                    pix_area.x                        :=(h0+1)-(d0+m0);
                  b0                                  :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                        :=scl_mul.x;
                                        bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  ScalePix128A(MSK2_128,bmp_bkgnd_ptr2^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d2_)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)],b0);
                  Inc(nt_pix_sht_arr_ptr);
                  Inc(nt_pix_ccl_arr_ptr);
                end;
            end;
          Inc        (nt_pix_cnt_arr_ptr);
        end; {$endregion}

      {last pixel row} {$region -fold}
      if (PWord (                       nt_pix_cnt_arr_ptr)-
          PWord (@fast_image_data_ptr_^.nt_pix_cnt_arr[0])<
          Length( fast_image_data_ptr_^.nt_pix_cnt_arr)) then
        begin
          d1        :=scl_mul_.y*(res_var0+res_var2);
          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1        *=bmp_bkgnd_width;
          if (pix_area.y<scl_mul.y) then
            begin
              d2:=(          pix_area.y)*Length(sqrt_arr1);
              d3:=(scl_mul.y-pix_area.y)*Length(sqrt_arr1);
              for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                begin
                  d0                                     :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                  h0                                     :=Trunc  (d0+m0);
                    pix_area.x                           :=(h0+1)-(d0+m0);
                  b0                                     :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                           :=scl_mul.x;
                                           bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                    ScalePix128B(MSK2_128,(bmp_bkgnd_ptr2+0)^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc((          pix_area.x)*d2)],sqrt_arr1[Trunc((          pix_area.x)*d3)],bmp_bkgnd_width);
                  if b0 then
                    ScalePix128B(MSK2_128,(bmp_bkgnd_ptr2+1)^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)],bmp_bkgnd_width);
                  Inc(nt_pix_sht_arr_ptr);
                  Inc(nt_pix_ccl_arr_ptr);
                end;
            end
          else
            begin
              //d2:=scl_mul.y*Length(sqrt_arr1);
              for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                begin
                  d0                                  :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                  h0                                  :=Trunc  (d0+m0);
                    pix_area.x                        :=(h0+1)-(d0+m0);
                  b0                                  :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                        :=scl_mul.x;
                                        bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  ScalePix128A(MSK2_128,bmp_bkgnd_ptr2^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d2_)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)],b0);
                  Inc(nt_pix_sht_arr_ptr);
                  Inc(nt_pix_ccl_arr_ptr);
                end;
            end;
          Inc        (nt_pix_cnt_arr_ptr);
        end; {$endregion}

    end;
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTColor002(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  nt_pix_cnt_arr_ptr : PWord;
  nt_pix_sht_arr_ptr : PWord;
  nt_pix_ccl_arr_ptr : PInteger;
       bmp_bkgnd_ptr2: PInteger;
  pix_area           : TPtPosF;
  scl_mul_           : TPtPosF;
  d0,d1,d2,d3,d2_    : double;
  x,y,h0,h1,h1_      : integer;
  check_exit         : boolean=False;
  b0,p0,p1           : boolean;

  col___: TColor;

label
  l1;
begin

  col___:=Random($FFFFFFFF);

  with fast_image_data_,fip_scale_data_var1 do
    begin
      SclNTResVar1        (fast_image_data_ptr_,fast_image_data_);
      RegNTResVar2        (fast_image_data_ptr_,fast_image_data_);
      RegNTResVar3        (fast_image_data_ptr_,fast_image_data_);
      if (res_var2<=0) then
        Exit;

      {
       Trunc(scl_mul.y*y_0+m1)>=rct_clp_ptr^.top;
       y_0:=(rct_clp_ptr^.top-m1)/scl_mul.y;
      y_0:=Max2(fast_image_data_ptr_^.nt_pix_arr_row_mrg_top,Trunc((rct_clp_ptr^.top-m1)/scl_mul.y)+1);
       Trunc(scl_mul.y*y_1+m1)<rct_clp_ptr^.bottom;
       y_1:=(rct_clp_ptr^.bottom-m1)/scl_mul.y;
      y_1:=Trunc((rct_clp_ptr^.bottom-m1)/scl_mul.y);
      }

      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      nt_pix_ccl_arr_ptr:=                       nt_pix_arr_ptr+res_var1;
      d2_               :=scl_mul.y*Length(sqrt_arr1);
      scl_mul_          :=PtPosF(res_var8*scl_mul.x,res_var3*scl_mul.y);

      {top border---} {$region -fold}
        begin
          d1        :=scl_mul_.y*(res_var0+0);

          l1:

          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1_       := h1;
          h1        *=bmp_bkgnd_width;
          p0        :=(h1_+0>=rct_clp_ptr^.top   ) and
                      (h1_+0< rct_clp_ptr^.bottom);
          p1        :=(h1_+1>=rct_clp_ptr^.top   ) and
                      (h1_+1< rct_clp_ptr^.bottom);
          if (pix_area.y<scl_mul.y) then
            begin
              d2:=(          pix_area.y)*Length(sqrt_arr1);
              d3:=(scl_mul.y-pix_area.y)*Length(sqrt_arr1);
              for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                begin
                  d0                                     :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                  h0                                     :=Trunc  (d0+m0);
                    pix_area.x                           :=(h0+1)-(d0+m0);
                  b0                                     :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                           :=scl_mul.x;
                                           bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  if p0 then
                    {bmp_bkgnd_ptr2^:=col___;//}ScalePix128A(MSK2_128,(bmp_bkgnd_ptr2+000000000000000)^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d2)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)],b0);
                  if p1 then
                    {(bmp_bkgnd_ptr2+bmp_bkgnd_width)^:=col___;//}ScalePix128A(MSK2_128,(bmp_bkgnd_ptr2+bmp_bkgnd_width)^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d3)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)],b0);
                  Inc(nt_pix_sht_arr_ptr);
                  Inc(nt_pix_ccl_arr_ptr);
                end;
            end
          else
            begin
              //d2:=scl_mul.y*Length(sqrt_arr1);
              for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                begin
                  d0                                    :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                  h0                                    :=Trunc  (d0+m0);
                    pix_area.x                          :=(h0+1)-(d0+m0);
                  b0                                    :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                          :=scl_mul.x;
                                          bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  if p0 then
                    {bmp_bkgnd_ptr2^:=col___;//}ScalePix128A(MSK2_128,bmp_bkgnd_ptr2^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d2_)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)],b0);
                  Inc(nt_pix_sht_arr_ptr);
                  Inc(nt_pix_ccl_arr_ptr);
                end;
            end;
          Inc        (nt_pix_cnt_arr_ptr);

          if check_exit then
            Exit;

        end; {$endregion}

      {main loop----} {$region -fold}
      if (res_var2>1) then
      for y:=1 to res_var2-1 do
        begin
          d1        :=scl_mul_.y*(res_var0+y);
          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
        //h1_       :=h1;
          h1        *=bmp_bkgnd_width;
          if (pix_area.y<scl_mul.y) then
            begin
              d2:=(          pix_area.y)*Length(sqrt_arr1);
              d3:=(scl_mul.y-pix_area.y)*Length(sqrt_arr1);
              for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                begin
                  d0                                     :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                  h0                                     :=Trunc  (d0+m0);
                    pix_area.x                           :=(h0+1)-(d0+m0);
                  b0                                     :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                           :=scl_mul.x;
                                           bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  {
                  //if (h1_+0>=rct_clp_ptr^.top) and (h1_+0<rct_clp_ptr^.bottom) then
                    ScalePix128A(MSK2_128,(bmp_bkgnd_ptr2+000000000000000)^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d2)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)],b0);
                  //if (h1_+1>=rct_clp_ptr^.top) and (h1_+1<rct_clp_ptr^.bottom) then
                    ScalePix128A(MSK2_128,(bmp_bkgnd_ptr2+bmp_bkgnd_width)^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d3)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)],b0);
                  }
                    {(bmp_bkgnd_ptr2+0)^:=col___;(bmp_bkgnd_ptr2+bmp_bkgnd_width+0)^:=col___;//}ScalePix128B(MSK2_128,(bmp_bkgnd_ptr2+0)^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc((          pix_area.x)*d2)],sqrt_arr1[Trunc((          pix_area.x)*d3)],bmp_bkgnd_width);
                  if b0 then
                    {(bmp_bkgnd_ptr2+1)^:=col___;(bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^:=col___;//}ScalePix128B(MSK2_128,(bmp_bkgnd_ptr2+1)^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)],bmp_bkgnd_width);
                  Inc(nt_pix_sht_arr_ptr);
                  Inc(nt_pix_ccl_arr_ptr);
                end;
            end
          else
            begin
              //d2:=scl_mul.y*Length(sqrt_arr1);
              for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                begin
                  d0                                    :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                  h0                                    :=Trunc  (d0+m0);
                    pix_area.x                          :=(h0+1)-(d0+m0);
                  b0                                    :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                          :=scl_mul.x;
                                          bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  //if (h1_+0>=rct_clp_ptr^.top) and (h1_+0<rct_clp_ptr^.bottom) then
                    {bmp_bkgnd_ptr2^:=col___;//}ScalePix128A(MSK2_128,bmp_bkgnd_ptr2^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d2_)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)],b0);
                  Inc(nt_pix_sht_arr_ptr);
                  Inc(nt_pix_ccl_arr_ptr);
                end;
            end;
          Inc        (nt_pix_cnt_arr_ptr);
        end; {$endregion}

      {bottom border} {$region -fold}

      {
      if (res_var2>0{1}) then
        begin
          d1        :=scl_mul_.y*(res_var0+res_var2);
          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1_       := h1;
          h1        *=bmp_bkgnd_width;
          p0        :=(h1_+0>=rct_clp_ptr^.top   ) and
                      (h1_+0< rct_clp_ptr^.bottom);
          if p0 then
            for x:=0 to nt_pix_cnt_arr_ptr^-1 do
              begin
                {if (PWord(nt_pix_sht_arr_ptr )-PWord (@fast_image_data_ptr_^.nt_pix_sht_arr[0])>Length(fast_image_data_ptr_^.nt_pix_sht_arr)-1) then
                  Exit;}
                if (PDWord(                       nt_pix_ccl_arr_ptr)-
                    PDWord(@fast_image_data_ptr_^.nt_pix_ccl_arr[0])>
                    Length( fast_image_data_ptr_^.nt_pix_ccl_arr)-1) then
                  Exit;
                {if (nt_pix_sht_arr_ptr=Nil) then
                  Break;
                if (nt_pix_ccl_arr_ptr=Nil) then
                  Break;}
                d0                                  :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                h0                                  :=Trunc  (d0+m0);
                  pix_area.x                        :=(h0+1)-(d0+m0);
                b0                                  :=(pix_area.x<scl_mul.x);
                if (not b0) then
                  pix_area.x                        :=scl_mul.x;
                                      bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                ScalePix128A(MSK2_128,bmp_bkgnd_ptr2^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d2_)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)],b0);
                Inc(nt_pix_sht_arr_ptr);
                Inc(nt_pix_ccl_arr_ptr);
              end;
        end;
      }

      if (res_var2>0) and
         (PWord (                       nt_pix_cnt_arr_ptr)-
          PWord (@fast_image_data_ptr_^.nt_pix_cnt_arr[0])<
          Length( fast_image_data_ptr_^.nt_pix_cnt_arr)) then
        begin
          d1        :=scl_mul_.y*(res_var0+res_var2);

          check_exit:=True;
          goto l1;

          {
          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1_       := h1;
          h1        *=bmp_bkgnd_width;
          p0        :=(h1_+0>=rct_clp_ptr^.top   ) and
                      (h1_+0< rct_clp_ptr^.bottom);
          p1        :=(h1_+1>=rct_clp_ptr^.top   ) and
                      (h1_+1< rct_clp_ptr^.bottom);
          if (pix_area.y<scl_mul.y) then
            begin
              d2:=(          pix_area.y)*Length(sqrt_arr1);
              d3:=(scl_mul.y-pix_area.y)*Length(sqrt_arr1);
              for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                begin
                  d0                                     :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                  h0                                     :=Trunc  (d0+m0);
                    pix_area.x                           :=(h0+1)-(d0+m0);
                  b0                                     :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                           :=scl_mul.x;
                                           bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  if p0 then
                    ScalePix128A(MSK2_128,(bmp_bkgnd_ptr2+000000000000000)^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d2)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)],b0);
                  if p1 then
                    ScalePix128A(MSK2_128,(bmp_bkgnd_ptr2+bmp_bkgnd_width)^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d3)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)],b0);
                  Inc(nt_pix_sht_arr_ptr);
                  Inc(nt_pix_ccl_arr_ptr);
                end;
            end
          else
            begin
              //d2:=scl_mul.y*Length(sqrt_arr1);
              for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                begin
                  d0                                    :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                  h0                                    :=Trunc  (d0+m0);
                    pix_area.x                          :=(h0+1)-(d0+m0);
                  b0                                    :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                          :=scl_mul.x;
                                          bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  if p0 then
                    ScalePix128A(MSK2_128,bmp_bkgnd_ptr2^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d2_)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)],b0);
                  Inc(nt_pix_sht_arr_ptr);
                  Inc(nt_pix_ccl_arr_ptr);
                end;
            end;
          }

        end; {$endregion}

    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTColor004(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_sht_pix_ptr : PWord;
  nt_pix_cnt_arr_ptr : PWord;
  nt_pix_sht_arr_ptr : PWord;
  nt_pix_ccl_arr_ptr : PInteger;
       bmp_bkgnd_ptr2: PInteger;
  pix_area           : TPtPosF;
  scl_mul_           : TPtPosF;
  pix_cnt_inc        : word;
  d0,d1,d2,d3,d2_    : double;
  x,y,h0,h1,h1_      : integer;
  b0,p0,p1           : boolean;
  check_exit         : boolean=False;
  continue_          : boolean=False;
  c1,c2              : integer;
label
  l0,l10,l11,l12,l20,l21,l22;
begin
  with fast_image_data_,fip_scale_data_var1 do
    begin
      SclNTResVar1        (fast_image_data_ptr_,fast_image_data_);
      RegNTResVar2        (fast_image_data_ptr_,fast_image_data_);
      RegNTResVar3        (fast_image_data_ptr_,fast_image_data_);
      if (res_var2<=0) then
        Exit;
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      nt_pix_ccl_arr_ptr:=                       nt_pix_arr_ptr+res_var1;
      d2_               :=scl_mul.y*Length(sqrt_arr1);
      scl_mul_          :=PtPosF(res_var8*scl_mul.x,res_var3*scl_mul.y);

      {top border---} {$region -fold}
        begin
          d1        :=scl_mul_.y*(res_var0+0);

          l0:

          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1_       := h1;
          h1        *=bmp_bkgnd_width;
          p0        :=(h1_+0>=rct_clp_ptr^.top   ) and
                      (h1_+0< rct_clp_ptr^.bottom);
          p1        :=(h1_+1>=rct_clp_ptr^.top   ) and
                      (h1_+1< rct_clp_ptr^.bottom);

          if (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=              nt_pix_sht_arr_ptr;
              c1               :=BinarySearch5(nt_pix_cnt_arr_ptr^,
                                               first_sht_pix_ptr{nt_pix_sht_arr_ptr},res_var9);
              c2               :=BinarySearch5(nt_pix_cnt_arr_ptr^,
                                               first_sht_pix_ptr{nt_pix_sht_arr_ptr},res_var10);
              if (c1<>nt_pix_cnt_arr_ptr^-1) or (c2<>-1) then
                begin

                  pix_cnt_inc:=0;
                  continue_  :=False;

                  if (c1<>-1) then
                    begin
                      Inc(nt_pix_sht_arr_ptr,c1);
                      Inc(nt_pix_ccl_arr_ptr,c1);
                      Inc(pix_cnt_inc,c1);
                    end;

                  if (pix_area.y<scl_mul.y) then
                    begin
                      d2:=(          pix_area.y)*Length(sqrt_arr1);
                      d3:=(scl_mul.y-pix_area.y)*Length(sqrt_arr1);

                      {left pixel-} {$region -fold}
                      if (nt_pix_sht_arr_ptr-first_sht_pix_ptr<nt_pix_cnt_arr_ptr^) and (c1<>-1) then
                        begin

                          l10:

                          d0                       :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                          h0                       :=Trunc  (d0+m0);
                            pix_area.x             :=(h0+1)-(d0+m0);
                          b0                       :=(pix_area.x<scl_mul.x);
                          if (not b0) then
                            pix_area.x             :=scl_mul.x;
                                     bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                          {pixel processing} {$region -fold}
                          if (h0+0>=rct_clp_ptr^.left ) and
                             (h0+0< rct_clp_ptr^.right) then
                          if p0 then
                            ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,sqrt_arr1[Trunc((          pix_area.x)*d2)]);

                          Inc       (bmp_bkgnd_ptr2);

                          if (h0+1>=rct_clp_ptr^.left ) and
                             (h0+1< rct_clp_ptr^.right) then
                          if p0 then
                          if b0 then
                            ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)]);

                          Inc       (bmp_bkgnd_ptr2,bmp_bkgnd_width-1);

                          if (h0+0>=rct_clp_ptr^.left ) and
                             (h0+0< rct_clp_ptr^.right) then
                          if p1 then
                            ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,sqrt_arr1[Trunc((          pix_area.x)*d3)]);

                          Inc       (bmp_bkgnd_ptr2);

                          if (h0+1>=rct_clp_ptr^.left ) and
                             (h0+1< rct_clp_ptr^.right) then
                          if p1 then
                          if b0 then
                            ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)]); {$endregion}

                          Inc(nt_pix_sht_arr_ptr);
                          Inc(nt_pix_ccl_arr_ptr);
                          Inc(pix_cnt_inc);

                          if continue_ then
                            goto l12;

                        end; {$endregion}

                      {main loop--} {$region -fold}
                      if (nt_pix_sht_arr_ptr-first_sht_pix_ptr<nt_pix_cnt_arr_ptr^) then
                        for x:=0 to c2-c1-2 do
                          begin
                            d0                     :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                            h0                     :=Trunc  (d0+m0);
                              pix_area.x           :=(h0+1)-(d0+m0);
                            b0                     :=(pix_area.x<scl_mul.x);
                            if (not b0) then
                              pix_area.x           :=scl_mul.x;
                                     bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                            {pixel processing} {$region -fold}
                            if p0 then
                              ScalePix128A(MSK2_128,(bmp_bkgnd_ptr2+000000000000000)^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d2)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)],b0);
                            if p1 then
                              ScalePix128A(MSK2_128,(bmp_bkgnd_ptr2+bmp_bkgnd_width)^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d3)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)],b0); {$endregion}

                            Inc(nt_pix_sht_arr_ptr);
                            Inc(nt_pix_ccl_arr_ptr);
                            Inc(pix_cnt_inc);
                          end; {$endregion}

                      {right pixel} {$region -fold}
                      if (nt_pix_sht_arr_ptr-first_sht_pix_ptr<nt_pix_cnt_arr_ptr^) then
                        begin
                          continue_:=True;
                          goto l10;
                        end; {$endregion}

                      {
                      for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                        begin
                          d0            :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                          h0            :=Trunc  (d0+m0);
                            pix_area.x  :=(h0+1)-(d0+m0);
                          b0            :=(pix_area.x<scl_mul.x);
                          if (not b0) then
                            pix_area.x  :=scl_mul.x;
                          bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                          {
                          if (h1_+0>=rct_clp_ptr^.top) and (h1_+0<rct_clp_ptr^.bottom) then
                            ScalePix128A(MSK2_128,(bmp_bkgnd_ptr2+000000000000000)^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d2)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)],b0);
                          if (h1_+1>=rct_clp_ptr^.top) and (h1_+1<rct_clp_ptr^.bottom) then
                            ScalePix128A(MSK2_128,(bmp_bkgnd_ptr2+bmp_bkgnd_width)^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d3)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)],b0);
                          }
                          if (h0+0>=rct_clp_ptr^.left ) and
                             (h0+0< rct_clp_ptr^.right) then
                          if p0 then
                            ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,sqrt_arr1[Trunc((          pix_area.x)*d2)]);

                          Inc       (bmp_bkgnd_ptr2);

                          if (h0+1>=rct_clp_ptr^.left ) and
                             (h0+1< rct_clp_ptr^.right) then
                          if p0 then
                          if b0 then
                            ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)]);

                          Inc       (bmp_bkgnd_ptr2,bmp_bkgnd_width-1);

                          if (h0+0>=rct_clp_ptr^.left ) and
                             (h0+0< rct_clp_ptr^.right) then
                          if p1 then
                            ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,sqrt_arr1[Trunc((          pix_area.x)*d3)]);

                          Inc       (bmp_bkgnd_ptr2);

                          if (h0+1>=rct_clp_ptr^.left ) and
                             (h0+1< rct_clp_ptr^.right) then
                          if p1 then
                          if b0 then
                            ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)]);

                          Inc(nt_pix_sht_arr_ptr);
                          Inc(nt_pix_ccl_arr_ptr);
                        end;
                      }

                    end
                  else
                    begin
                      //d2:=scl_mul.y*Length(sqrt_arr1);

                      {left pixel-} {$region -fold}
                      if (nt_pix_sht_arr_ptr-first_sht_pix_ptr<nt_pix_cnt_arr_ptr^) and (c1<>-1) then
                        begin

                          l11:

                          d0                       :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                          h0                       :=Trunc  (d0+m0);
                            pix_area.x             :=(h0+1)-(d0+m0);
                          b0                       :=(pix_area.x<scl_mul.x);
                          if (not b0) then
                            pix_area.x             :=scl_mul.x;
                                     bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                          {pixel processing} {$region -fold}
                          if (h0+0>=rct_clp_ptr^.left ) and
                             (h0+0< rct_clp_ptr^.right) then
                          if p0 then
                            ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,sqrt_arr1[Trunc((          pix_area.x)*d2_)]);

                          Inc       (bmp_bkgnd_ptr2);

                          if (h0+1>=rct_clp_ptr^.left ) and
                             (h0+1< rct_clp_ptr^.right) then
                          if p0 then
                          if b0 then
                            ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)]); {$endregion}

                          Inc(nt_pix_sht_arr_ptr);
                          Inc(nt_pix_ccl_arr_ptr);
                          Inc(pix_cnt_inc);

                          if continue_ then
                            goto l12;

                        end; {$endregion}

                      {main loop--} {$region -fold}
                      if (nt_pix_sht_arr_ptr-first_sht_pix_ptr<nt_pix_cnt_arr_ptr^) then
                        for x:=0 to c2-c1-2 do
                          begin
                            d0                     :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                            h0                     :=Trunc  (d0+m0);
                              pix_area.x           :=(h0+1)-(d0+m0);
                            b0                     :=(pix_area.x<scl_mul.x);
                            if (not b0) then
                              pix_area.x           :=scl_mul.x;
                                     bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                            {pixel processing} {$region -fold}
                            if p0 then
                              ScalePix128A(MSK2_128,bmp_bkgnd_ptr2^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d2_)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)],b0); {$endregion}

                            Inc(nt_pix_sht_arr_ptr);
                            Inc(nt_pix_ccl_arr_ptr);
                            Inc(pix_cnt_inc);
                          end; {$endregion}

                      {right pixel} {$region -fold}
                      if (nt_pix_sht_arr_ptr-first_sht_pix_ptr<nt_pix_cnt_arr_ptr^) then
                        begin
                          continue_:=True;
                          goto l11;
                        end; {$endregion}

                      {
                      for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                        begin
                          d0            :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                          h0            :=Trunc  (d0+m0);
                            pix_area.x  :=(h0+1)-(d0+m0);
                          b0            :=(pix_area.x<scl_mul.x);
                          if (not b0) then
                            pix_area.x  :=scl_mul.x;
                          bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                          {
                          if (h1_+0>=rct_clp_ptr^.top) and (h1_+0<rct_clp_ptr^.bottom) then
                            ScalePix128A(MSK2_128,bmp_bkgnd_ptr2^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d2_)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)],b0);
                          }
                          if (h0+0>=rct_clp_ptr^.left ) and
                             (h0+0< rct_clp_ptr^.right) then
                          if p0 then
                            ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,sqrt_arr1[Trunc((          pix_area.x)*d2_)]);

                          Inc       (bmp_bkgnd_ptr2);

                          if (h0+1>=rct_clp_ptr^.left ) and
                             (h0+1< rct_clp_ptr^.right) then
                          if p0 then
                          if b0 then
                            ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)]);

                          Inc(nt_pix_sht_arr_ptr);
                          Inc(nt_pix_ccl_arr_ptr);
                        end;
                      }

                    end;

                  l12:

                  Inc(nt_pix_sht_arr_ptr,nt_pix_cnt_arr_ptr^-(pix_cnt_inc{nt_pix_sht_arr_ptr-first_sht_pix_ptr}{(c2+1)}));
                  Inc(nt_pix_ccl_arr_ptr,nt_pix_cnt_arr_ptr^-(pix_cnt_inc{nt_pix_sht_arr_ptr-first_sht_pix_ptr}{(c2+1)}));

                end
              else
                begin
                  Inc(nt_pix_sht_arr_ptr,nt_pix_cnt_arr_ptr^);
                  Inc(nt_pix_ccl_arr_ptr,nt_pix_cnt_arr_ptr^);
                end;
            end;
          Inc(nt_pix_cnt_arr_ptr);

          if check_exit then
            Exit;

        end; {$endregion}

      {main loop----} {$region -fold}
      if (res_var2>1{2}) then
      for y:=1 to res_var2-1 do
        begin
          d1        :=scl_mul_.y*(res_var0+y);
          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
        //h1_       :=h1;
          h1        *=bmp_bkgnd_width;
          if (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=              nt_pix_sht_arr_ptr;
              c1               :=BinarySearch5(nt_pix_cnt_arr_ptr^,
                                               first_sht_pix_ptr{nt_pix_sht_arr_ptr},res_var9);
              c2               :=BinarySearch5(nt_pix_cnt_arr_ptr^,
                                               first_sht_pix_ptr{nt_pix_sht_arr_ptr},res_var10);

              {
              Trunc(scl_mul.x*(first_sht_pix_ptr+x)^+m0)< rct_clp_ptr^.left;
                   (scl_mul.x*(first_sht_pix_ptr+x)^+m0)< rct_clp_ptr^.left;
                              (first_sht_pix_ptr+x)^    <(rct_clp_ptr^.left -m0)/
                    scl_mul.x;
              Trunc(scl_mul.x*(first_sht_pix_ptr+x)^+m0)< rct_clp_ptr^.right;
                   (scl_mul.x*(first_sht_pix_ptr+x)^+m0)< rct_clp_ptr^.right;
                              (first_sht_pix_ptr+x)^    <(rct_clp_ptr^.right-m0)/
                    scl_mul.x;
              }

              {
              //                                                            main loop
              //                                             c1     |  c2  |  low  |  high          | nt_pix_cnt_arr_ptr^-(c2+1)
              //      0 | 1 2 3 4 5 | 6 7               //   0      |  5   |  0    |   3(5-0-2)     | 2(8-(6))
              //      0 | 1 2 3 4   |                   //   0      |  4   |  0    |   2(4-0-2)     | 0(5-(5))
              //        | 0 1 2 3 4 | 5 6               //   0(-1)  |  4   |  0    |   3(4-(-1)-2)  | 2(7-(5))
              //        | 0 1 2 3   |                   //   0(-1)  |  3   |  0    |   2(3-(-1)-2)  | 0(4-(4))
              //        |         0 | 1 2               //   0(-1)  |  0   |  0    |  -1(0-(-1)-2)  | 2(3-(1))
              //        |         0 | 1                 //   0(-1)  |  0   |  0    |  -1(0-(-1)-2)  | 2(3-(1))
              //        |         0 |                   //   0(-1)  |  0   |  0    |  -1(0-(-1)-2)  | 2(3-(1))
              //  0 1 2 | 3 4 5 6 7 | 8 9 10 11         //          |      |       |                |
              //  for x:=0 to c2-c1-1 do                //          |      |       |                |
              }

              if (c1<>nt_pix_cnt_arr_ptr^-1) or (c2<>-1) then
                begin

                  pix_cnt_inc:=0;
                  continue_  :=False;

                  if (c1<>-1) then
                    begin
                      Inc(nt_pix_sht_arr_ptr,c1);
                      Inc(nt_pix_ccl_arr_ptr,c1);
                      Inc(pix_cnt_inc,c1);
                    end;

                  if (pix_area.y<scl_mul.y) then
                    begin
                      d2:=(          pix_area.y)*Length(sqrt_arr1);
                      d3:=(scl_mul.y-pix_area.y)*Length(sqrt_arr1);

                      {left pixel-} {$region -fold}
                      if (nt_pix_sht_arr_ptr-first_sht_pix_ptr<nt_pix_cnt_arr_ptr^) and (c1<>-1) then
                        begin

                          l20:

                          d0                                     :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                          h0                                     :=Trunc  (d0+m0);
                            pix_area.x                           :=(h0+1)-(d0+m0);
                          b0                                     :=(pix_area.x<scl_mul.x);
                          if (not b0) then
                            pix_area.x                           :=scl_mul.x;
                                                   bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                          {pixel processing} {$region -fold}
                          if (h0+0>=rct_clp_ptr^.left ) and
                             (h0+0< rct_clp_ptr^.right) then
                            ScalePix128B(MSK2_128,(bmp_bkgnd_ptr2+0)^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc((          pix_area.x)*d2)],sqrt_arr1[Trunc((          pix_area.x)*d3)],bmp_bkgnd_width);
                          if  b0 then
                          if (h0+1>=rct_clp_ptr^.left ) and
                             (h0+1< rct_clp_ptr^.right) then
                            ScalePix128B(MSK2_128,(bmp_bkgnd_ptr2+1)^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)],bmp_bkgnd_width); {$endregion}

                          Inc(nt_pix_sht_arr_ptr);
                          Inc(nt_pix_ccl_arr_ptr);
                          Inc(pix_cnt_inc);

                          if continue_ then
                            goto l22;

                        end; {$endregion}

                      {main loop--} {$region -fold}
                      if (nt_pix_sht_arr_ptr-first_sht_pix_ptr<nt_pix_cnt_arr_ptr^) then
                        for x:=0 to c2-c1-2 do
                          begin
                            d0                                     :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                            h0                                     :=Trunc  (d0+m0);
                              pix_area.x                           :=(h0+1)-(d0+m0);
                            b0                                     :=(pix_area.x<scl_mul.x);
                            if (not b0) then
                              pix_area.x                           :=scl_mul.x;
                                                     bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                            {pixel processing} {$region -fold}
                              ScalePix128B(MSK2_128,(bmp_bkgnd_ptr2+0)^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc((          pix_area.x)*d2)],sqrt_arr1[Trunc((          pix_area.x)*d3)],bmp_bkgnd_width);
                            if b0 then
                              ScalePix128B(MSK2_128,(bmp_bkgnd_ptr2+1)^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)],bmp_bkgnd_width); {$endregion}

                            Inc(nt_pix_sht_arr_ptr);
                            Inc(nt_pix_ccl_arr_ptr);
                            Inc(pix_cnt_inc);
                          end; {$endregion}

                      {right pixel} {$region -fold}
                      if (nt_pix_sht_arr_ptr-first_sht_pix_ptr<nt_pix_cnt_arr_ptr^) then
                        begin
                          continue_:=True;
                          goto l20;
                        end; {$endregion}

                      {
                      for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                        begin
                          d0                                     :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                          h0                                     :=Trunc  (d0+m0);
                            pix_area.x                           :=(h0+1)-(d0+m0);
                          b0                                     :=(pix_area.x<scl_mul.x);
                          if (not b0) then
                            pix_area.x                           :=scl_mul.x;
                                                   bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                          if (x>=c1) and (x<=c2) then
                            begin

                              ScalePix128B(MSK2_128,(bmp_bkgnd_ptr2+0)^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc((          pix_area.x)*d2)],sqrt_arr1[Trunc((          pix_area.x)*d3)],bmp_bkgnd_width);
                            if b0 then
                              ScalePix128B(MSK2_128,(bmp_bkgnd_ptr2+1)^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)],bmp_bkgnd_width);

                            end;

                          Inc(nt_pix_sht_arr_ptr);
                          Inc(nt_pix_ccl_arr_ptr);
                        end;
                      }

                    end
                  else
                    begin

                      {left pixel-} {$region -fold}
                      if (nt_pix_sht_arr_ptr-first_sht_pix_ptr<nt_pix_cnt_arr_ptr^) and (c1<>-1) then
                        begin

                          l21:

                          d0                       :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                          h0                       :=Trunc  (d0+m0);
                            pix_area.x             :=(h0+1)-(d0+m0);
                          b0                       :=(pix_area.x<scl_mul.x);
                          if (not b0) then
                            pix_area.x             :=scl_mul.x;
                                     bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                          {pixel processing} {$region -fold}
                          if (h0+0>=rct_clp_ptr^.left ) and
                             (h0+0< rct_clp_ptr^.right) then
                            ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,sqrt_arr1[Trunc((          pix_area.x)*d2_)]);
                          Inc       (bmp_bkgnd_ptr2);
                          if  b0 then
                          if (h0+1>=rct_clp_ptr^.left ) and
                             (h0+1< rct_clp_ptr^.right) then
                            ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)]); {$endregion}

                          Inc(nt_pix_sht_arr_ptr);
                          Inc(nt_pix_ccl_arr_ptr);
                          Inc(pix_cnt_inc);

                          if continue_ then
                            goto l22;

                        end; {$endregion}

                      {main loop--} {$region -fold}
                      if (nt_pix_sht_arr_ptr-first_sht_pix_ptr<nt_pix_cnt_arr_ptr^) then
                        for x:=0 to c2-c1-2 do
                          begin
                            d0                                  :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                            h0                                  :=Trunc  (d0+m0);
                              pix_area.x                        :=(h0+1)-(d0+m0);
                            b0                                  :=(pix_area.x<scl_mul.x);
                            if (not b0) then
                              pix_area.x                        :=scl_mul.x;
                                                  bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                            {pixel processing} {$region -fold}
                            ScalePix128A(MSK2_128,bmp_bkgnd_ptr2^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d2_)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)],b0); {$endregion}

                            Inc(nt_pix_sht_arr_ptr);
                            Inc(nt_pix_ccl_arr_ptr);
                            Inc(pix_cnt_inc);
                          end; {$endregion}

                      {right pixel} {$region -fold}
                      if (nt_pix_sht_arr_ptr-first_sht_pix_ptr<nt_pix_cnt_arr_ptr^) then
                        begin
                          continue_:=True;
                          goto l21;
                        end; {$endregion}

                      {
                      for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                        begin
                          d0                                  :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                          h0                                  :=Trunc  (d0+m0);
                            pix_area.x                        :=(h0+1)-(d0+m0);
                          b0                                  :=(pix_area.x<scl_mul.x);
                          if (not b0) then
                            pix_area.x                        :=scl_mul.x;
                                                bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                          if (x>=c1) and (x<=c2) then
                            begin

                              ScalePix128A(MSK2_128,bmp_bkgnd_ptr2^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d2_)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)],b0);

                            end;

                          Inc(nt_pix_sht_arr_ptr);
                          Inc(nt_pix_ccl_arr_ptr);
                        end;
                        }

                    end;

                  l22:

                  Inc(nt_pix_sht_arr_ptr,nt_pix_cnt_arr_ptr^-(pix_cnt_inc{nt_pix_sht_arr_ptr-first_sht_pix_ptr}{(c2+1)}));
                  Inc(nt_pix_ccl_arr_ptr,nt_pix_cnt_arr_ptr^-(pix_cnt_inc{nt_pix_sht_arr_ptr-first_sht_pix_ptr}{(c2+1)}));

                end
              else
                begin
                  Inc(nt_pix_sht_arr_ptr,nt_pix_cnt_arr_ptr^);
                  Inc(nt_pix_ccl_arr_ptr,nt_pix_cnt_arr_ptr^);
                end;
            end;
          Inc(nt_pix_cnt_arr_ptr);
        end; {$endregion}

      {bottom border} {$region -fold}
      if (res_var2>0{1}) and
         (PWord (                       nt_pix_cnt_arr_ptr)-
          PWord (@fast_image_data_ptr_^.nt_pix_cnt_arr[0])<
          Length( fast_image_data_ptr_^.nt_pix_cnt_arr)) then
        begin
          d1        :=scl_mul_.y*(res_var0+res_var2);

          check_exit:=True;
          goto l0;

          {
          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1_       := h1;
          h1        *=bmp_bkgnd_width;
          p0        :=(h1_+0>=rct_clp_ptr^.top   ) and
                      (h1_+0< rct_clp_ptr^.bottom);
          if p0 then
            for x:=0 to nt_pix_cnt_arr_ptr^-1 do
              begin
                if (PDWord(                       nt_pix_ccl_arr_ptr)-
                    PDWord(@fast_image_data_ptr_^.nt_pix_ccl_arr[0])>
                    Length( fast_image_data_ptr_^.nt_pix_ccl_arr)-1) then
                  Exit;
                d0            :=scl_mul_.x*nt_pix_sht_arr_ptr^;
                h0            :=Trunc  (d0+m0);
                  pix_area.x  :=(h0+1)-(d0+m0);
                b0            :=(pix_area.x<scl_mul.x);
                if (not b0) then
                  pix_area.x  :=scl_mul.x;
                bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                {
                if (h1_+0>=rct_clp_ptr^.top) and (h1_+0<rct_clp_ptr^.bottom) then
                  ScalePix128A(MSK2_128,bmp_bkgnd_ptr2^,nt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d2_)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)],b0);
                }
                if (h0+0>=rct_clp_ptr^.left ) and
                   (h0+0< rct_clp_ptr^.right) then
                  ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,sqrt_arr1[Trunc((          pix_area.x)*d2_)]);

                Inc       (bmp_bkgnd_ptr2);

                if (h0+1>=rct_clp_ptr^.left ) and
                   (h0+1< rct_clp_ptr^.right) then
                if b0 then
                  ScalePix(bmp_bkgnd_ptr2,nt_pix_ccl_arr_ptr,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)]);

                Inc(nt_pix_sht_arr_ptr);
                Inc(nt_pix_ccl_arr_ptr);
              end;
              }

        end; {$endregion}

    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTColor006(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_sht_pix_ptr : PInteger;
       bmp_bkgnd_ptr2: PInteger;
       bmp_color_ptr2: PInteger;
  pix_area           : TPtPosF;
  scl_mul_           : TPtPosF;
  pix_cnt_inc        : word;
  d0,d1,d2,d3,d2_    : double;
  x,y,h0,h1,h1_      : integer;
  b0,p0,p1           : boolean;
  check_exit         : boolean=False;
  continue_          : boolean=False;
  c1,c2              : integer;

  //col___: TColor;

label
  l0,l10,l11,l12,l20,l21,l22;
begin

  //col___:=Random($FFFFFFFF);

  with fast_image_data_,fip_scale_data_var1 do
    begin
      SclNTResVar1   (fast_image_data_ptr_,fast_image_data_);
      RegNTResVar1   (fast_image_data_ptr_,fast_image_data_);
      RegNTResVar3   (fast_image_data_ptr_,fast_image_data_);
      if (res_var2<=0) then
        Exit;
      bmp_color_ptr2:=fast_image_data_ptr_^.bmp_color_ptr+res_var0*rct_ent.width;
      d2_           :=scl_mul.y*Length(sqrt_arr1);
      scl_mul_      :=PtPosF(res_var8*scl_mul.x,res_var3*scl_mul.y);

          c1        :=Trunc (res_var9 );
      if (c1<0) then
          c1        :=-1
      else
          c1        :=Min2(c1,rct_ent.width-1);

          c2        :=Trunc (res_var10);
      if (c2<0) then
          c2        :=-1
      else
          c2        :=Min2(c2,rct_ent.width-1);

      {
      Trunc(scl_mul.x*x+m0)< rct_clp_ptr^.left;
           (scl_mul.x*x+m0)< rct_clp_ptr^.left;
                      x    <(rct_clp_ptr^.left -m0)/
            scl_mul.x;
      Trunc(scl_mul.x*x+m0)< rct_clp_ptr^.right;
           (scl_mul.x*x+m0)< rct_clp_ptr^.right;
                      x    <(rct_clp_ptr^.right-m0)/
            scl_mul.x;
      }

      {top border---} {$region -fold}
        begin
          d1        :=scl_mul_.y*(res_var0+0);

          l0:

          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1_       := h1;
          h1        *=bmp_bkgnd_width;
          p0        :=(h1_+0>=rct_clp_ptr^.top   ) and
                      (h1_+0< rct_clp_ptr^.bottom);
          p1        :=(h1_+1>=rct_clp_ptr^.top   ) and
                      (h1_+1< rct_clp_ptr^.bottom);
          //if (rct_ent.width<>0) then
            begin

              first_sht_pix_ptr:=bmp_color_ptr2;

              if (c1<>rct_ent.width-1) or (c2<>-1) then
                begin

                  pix_cnt_inc:=0;
                  continue_  :=False;

                  if (c1<>-1) then
                    begin
                      Inc(bmp_color_ptr2,c1);
                      Inc(pix_cnt_inc   ,c1);
                    end;

                  if (pix_area.y<scl_mul.y) then
                    begin
                      d2:=(          pix_area.y)*Length(sqrt_arr1);
                      d3:=(scl_mul.y-pix_area.y)*Length(sqrt_arr1);

                      {left pixel-} {$region -fold}
                      if (bmp_color_ptr2-first_sht_pix_ptr<rct_ent.width) and (c1<>-1) then
                        begin

                          l10:

                          d0                       :=scl_mul_.x*pix_cnt_inc;
                          h0                       :=Trunc  (d0+m0);
                            pix_area.x             :=(h0+1)-(d0+m0);
                          b0                       :=(pix_area.x<scl_mul.x);
                          if (not b0) then
                            pix_area.x             :=scl_mul.x;
                                     bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                          {pixel processing} {$region -fold}
                          if (h0+0>=rct_clp_ptr^.left ) and
                             (h0+0< rct_clp_ptr^.right) then
                          if p0 then
                            {bmp_bkgnd_ptr2^:=col___;//}ScalePix(bmp_bkgnd_ptr2,bmp_color_ptr2,sqrt_arr1[Trunc((          pix_area.x)*d2)]);

                          Inc       (bmp_bkgnd_ptr2);

                          if (h0+1>=rct_clp_ptr^.left ) and
                             (h0+1< rct_clp_ptr^.right) then
                          if p0 then
                          if b0 then
                            {bmp_bkgnd_ptr2^:=col___;//}ScalePix(bmp_bkgnd_ptr2,bmp_color_ptr2,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)]);

                          Inc       (bmp_bkgnd_ptr2,bmp_bkgnd_width-1);

                          if (h0+0>=rct_clp_ptr^.left ) and
                             (h0+0< rct_clp_ptr^.right) then
                          if p1 then
                            {bmp_bkgnd_ptr2^:=col___;//}ScalePix(bmp_bkgnd_ptr2,bmp_color_ptr2,sqrt_arr1[Trunc((          pix_area.x)*d3)]);

                          Inc       (bmp_bkgnd_ptr2);

                          if (h0+1>=rct_clp_ptr^.left ) and
                             (h0+1< rct_clp_ptr^.right) then
                          if p1 then
                          if b0 then
                            {bmp_bkgnd_ptr2^:=col___;//}ScalePix(bmp_bkgnd_ptr2,bmp_color_ptr2,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)]); {$endregion}

                          Inc(bmp_color_ptr2);
                          Inc(pix_cnt_inc);

                          if continue_ then
                            goto l12;

                        end; {$endregion}

                      {main loop--} {$region -fold}
                      if (bmp_color_ptr2-first_sht_pix_ptr<rct_ent.width) then
                        for x:=0 to c2-c1-2 do
                          begin
                            d0                     :=scl_mul_.x*pix_cnt_inc;
                            h0                     :=Trunc  (d0+m0);
                              pix_area.x           :=(h0+1)-(d0+m0);
                            b0                     :=(pix_area.x<scl_mul.x);
                            if (not b0) then
                              pix_area.x           :=scl_mul.x;
                                     bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                            {pixel processing} {$region -fold}
                            if p0 then
                              {bmp_bkgnd_ptr2^:=col___;//}ScalePix128A(MSK2_128,(bmp_bkgnd_ptr2+000000000000000)^,bmp_color_ptr2^,sqrt_arr1[Trunc(pix_area.x*d2)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)],b0);
                            if p1 then
                              {(bmp_bkgnd_ptr2+bmp_bkgnd_width)^:=col___;//}ScalePix128A(MSK2_128,(bmp_bkgnd_ptr2+bmp_bkgnd_width)^,bmp_color_ptr2^,sqrt_arr1[Trunc(pix_area.x*d3)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)],b0); {$endregion}

                            Inc(bmp_color_ptr2);
                            Inc(pix_cnt_inc);
                          end; {$endregion}

                      {right pixel} {$region -fold}
                      if (bmp_color_ptr2-first_sht_pix_ptr<rct_ent.width) then
                        begin
                          continue_:=True;
                          goto l10;
                        end; {$endregion}

                    end
                  else
                    begin

                      {left pixel-} {$region -fold}
                      if (bmp_color_ptr2-first_sht_pix_ptr<rct_ent.width) and (c1<>-1) then
                        begin

                          l11:

                          d0                       :=scl_mul_.x*pix_cnt_inc;
                          h0                       :=Trunc  (d0+m0);
                            pix_area.x             :=(h0+1)-(d0+m0);
                          b0                       :=(pix_area.x<scl_mul.x);
                          if (not b0) then
                            pix_area.x             :=scl_mul.x;
                                     bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                          {pixel processing} {$region -fold}
                          if (h0+0>=rct_clp_ptr^.left ) and
                             (h0+0< rct_clp_ptr^.right) then
                          if p0 then
                            {bmp_bkgnd_ptr2^:=col___;//}ScalePix(bmp_bkgnd_ptr2,bmp_color_ptr2,sqrt_arr1[Trunc((          pix_area.x)*d2_)]);

                          Inc       (bmp_bkgnd_ptr2);

                          if (h0+1>=rct_clp_ptr^.left ) and
                             (h0+1< rct_clp_ptr^.right) then
                          if p0 then
                          if b0 then
                            {bmp_bkgnd_ptr2^:=col___;//}ScalePix(bmp_bkgnd_ptr2,bmp_color_ptr2,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)]); {$endregion}

                          Inc(bmp_color_ptr2);
                          Inc(pix_cnt_inc);

                          if continue_ then
                            goto l12;

                        end; {$endregion}

                      {main loop--} {$region -fold}
                      if (bmp_color_ptr2-first_sht_pix_ptr<rct_ent.width) then
                        for x:=0 to c2-c1-2 do
                          begin
                            d0                     :=scl_mul_.x*pix_cnt_inc;
                            h0                     :=Trunc  (d0+m0);
                              pix_area.x           :=(h0+1)-(d0+m0);
                            b0                     :=(pix_area.x<scl_mul.x);
                            if (not b0) then
                              pix_area.x           :=scl_mul.x;
                                     bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                            {pixel processing} {$region -fold}
                            if p0 then
                              {bmp_bkgnd_ptr2^:=col___;//}ScalePix128A(MSK2_128,bmp_bkgnd_ptr2^,bmp_color_ptr2^,sqrt_arr1[Trunc(pix_area.x*d2_)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)],b0); {$endregion}

                            Inc(bmp_color_ptr2);
                            Inc(pix_cnt_inc);
                          end; {$endregion}

                      {right pixel} {$region -fold}
                      if (bmp_color_ptr2-first_sht_pix_ptr<rct_ent.width) then
                        begin
                          continue_:=True;
                          goto l11;
                        end; {$endregion}

                    end;

                  l12:

                  Inc(bmp_color_ptr2,rct_ent.width-pix_cnt_inc);

                end
              else
                begin
                  Inc(bmp_color_ptr2,rct_ent.width);
                end;
            end;

          if check_exit then
            Exit;

        end; {$endregion}

      {main loop----} {$region -fold}
      if (res_var2>1) then
      for y:=1 to res_var2-1 do
        begin
          d1        :=scl_mul_.y*(res_var0+y);
          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1        *=bmp_bkgnd_width;
          //if (rct_ent.width<>0) then
            begin

              first_sht_pix_ptr:=bmp_color_ptr2;

              if (c1<>rct_ent.width-1) or (c2<>-1) then
                begin

                  pix_cnt_inc:=0;
                  continue_  :=False;

                  if (c1<>-1) then
                    begin
                      Inc(bmp_color_ptr2,c1);
                      Inc(pix_cnt_inc   ,c1);
                    end;

                  if (pix_area.y<scl_mul.y) then
                    begin
                      d2:=(          pix_area.y)*Length(sqrt_arr1);
                      d3:=(scl_mul.y-pix_area.y)*Length(sqrt_arr1);

                      {left pixel-} {$region -fold}
                      if (bmp_color_ptr2-first_sht_pix_ptr<rct_ent.width) and (c1<>-1) then
                        begin

                          l20:

                          d0                                     :=scl_mul_.x*pix_cnt_inc;
                          h0                                     :=Trunc  (d0+m0);
                            pix_area.x                           :=(h0+1)-(d0+m0);
                          b0                                     :=(pix_area.x<scl_mul.x);
                          if (not b0) then
                            pix_area.x                           :=scl_mul.x;
                                                   bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                          {pixel processing} {$region -fold}
                          if (h0+0>=rct_clp_ptr^.left ) and
                             (h0+0< rct_clp_ptr^.right) then
                            {bmp_bkgnd_ptr2^:=col___; (bmp_bkgnd_ptr2+bmp_bkgnd_width)^:=col___;//}ScalePix128B(MSK2_128,(bmp_bkgnd_ptr2+0)^,bmp_color_ptr2^,sqrt_arr1[Trunc((          pix_area.x)*d2)],sqrt_arr1[Trunc((          pix_area.x)*d3)],bmp_bkgnd_width);
                          if  b0 then
                          if (h0+1>=rct_clp_ptr^.left ) and
                             (h0+1< rct_clp_ptr^.right) then
                            {(bmp_bkgnd_ptr2+1)^:=col___; (bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^:=col___;//}ScalePix128B(MSK2_128,(bmp_bkgnd_ptr2+1)^,bmp_color_ptr2^,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)],bmp_bkgnd_width); {$endregion}

                          Inc(bmp_color_ptr2);
                          Inc(pix_cnt_inc);

                          if continue_ then
                            goto l22;

                        end; {$endregion}

                      {main loop--} {$region -fold}
                      if (bmp_color_ptr2-first_sht_pix_ptr<rct_ent.width) then
                        for x:=0 to c2-c1-2 do
                          begin
                            d0                                     :=scl_mul_.x*pix_cnt_inc;
                            h0                                     :=Trunc  (d0+m0);
                              pix_area.x                           :=(h0+1)-(d0+m0);
                            b0                                     :=(pix_area.x<scl_mul.x);
                            if (not b0) then
                              pix_area.x                           :=scl_mul.x;
                                                     bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                            {pixel processing} {$region -fold}
                              {bmp_bkgnd_ptr2^:=col___; (bmp_bkgnd_ptr2+bmp_bkgnd_width)^:=col___;//}ScalePix128B(MSK2_128,(bmp_bkgnd_ptr2+0)^,bmp_color_ptr2^,sqrt_arr1[Trunc((          pix_area.x)*d2)],sqrt_arr1[Trunc((          pix_area.x)*d3)],bmp_bkgnd_width);
                            if b0 then
                              {(bmp_bkgnd_ptr2+1)^:=col___; (bmp_bkgnd_ptr2+bmp_bkgnd_width+1)^:=col___;//}ScalePix128B(MSK2_128,(bmp_bkgnd_ptr2+1)^,bmp_color_ptr2^,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)],bmp_bkgnd_width); {$endregion}

                            Inc(bmp_color_ptr2);
                            Inc(pix_cnt_inc);
                          end; {$endregion}

                      {right pixel} {$region -fold}
                      if (bmp_color_ptr2-first_sht_pix_ptr<rct_ent.width) then
                        begin
                          continue_:=True;
                          goto l20;
                        end; {$endregion}

                    end
                  else
                    begin

                      {left pixel-} {$region -fold}
                      if (bmp_color_ptr2-first_sht_pix_ptr<rct_ent.width) and (c1<>-1) then
                        begin

                          l21:

                          d0                       :=scl_mul_.x*pix_cnt_inc;
                          h0                       :=Trunc  (d0+m0);
                            pix_area.x             :=(h0+1)-(d0+m0);
                          b0                       :=(pix_area.x<scl_mul.x);
                          if (not b0) then
                            pix_area.x             :=scl_mul.x;
                                     bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                          {pixel processing} {$region -fold}
                          if (h0+0>=rct_clp_ptr^.left ) and
                             (h0+0< rct_clp_ptr^.right) then
                            {bmp_bkgnd_ptr2^:=col___;//}ScalePix(bmp_bkgnd_ptr2,bmp_color_ptr2,sqrt_arr1[Trunc((          pix_area.x)*d2_)]);
                          Inc       (bmp_bkgnd_ptr2);
                          if  b0 then
                          if (h0+1>=rct_clp_ptr^.left ) and
                             (h0+1< rct_clp_ptr^.right) then
                            {bmp_bkgnd_ptr2^:=col___;//}ScalePix(bmp_bkgnd_ptr2,bmp_color_ptr2,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)]); {$endregion}

                          Inc(bmp_color_ptr2);
                          Inc(pix_cnt_inc);

                          if continue_ then
                            goto l22;

                        end; {$endregion}

                      {main loop--} {$region -fold}
                      if (bmp_color_ptr2-first_sht_pix_ptr<rct_ent.width) then
                        for x:=0 to c2-c1-2 do
                          begin
                            d0                                  :=scl_mul_.x*pix_cnt_inc;
                            h0                                  :=Trunc  (d0+m0);
                              pix_area.x                        :=(h0+1)-(d0+m0);
                            b0                                  :=(pix_area.x<scl_mul.x);
                            if (not b0) then
                              pix_area.x                        :=scl_mul.x;
                                                  bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                            {pixel processing} {$region -fold}
                            {bmp_bkgnd_ptr2^:=col___;//}ScalePix128A(MSK2_128,bmp_bkgnd_ptr2^,bmp_color_ptr2^,sqrt_arr1[Trunc(pix_area.x*d2_)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)],b0); {$endregion}

                            Inc(bmp_color_ptr2);
                            Inc(pix_cnt_inc);
                          end; {$endregion}

                      {right pixel} {$region -fold}
                      if (bmp_color_ptr2-first_sht_pix_ptr<rct_ent.width) then
                        begin
                          continue_:=True;
                          goto l21;
                        end; {$endregion}

                    end;

                  l22:

                  Inc(bmp_color_ptr2,rct_ent.width-pix_cnt_inc);

                end
              else
                begin
                  Inc(bmp_color_ptr2,rct_ent.width);
                end;
            end;
        end; {$endregion}

      {bottom border} {$region -fold}
      if (res_var2>0) and
         (bmp_color_ptr2-fast_image_data_ptr_^.bmp_color_ptr<rct_ent.width*rct_ent.height) then
        begin
          d1        :=scl_mul_.y*(res_var0+res_var2);
          check_exit:=True;
          goto l0;
        end; {$endregion}

    end;
end; {$endregion}
// (fading):
// same;

{Color of Curent Layer(Additive)}
// (constant) not clipped:
procedure TFastImageProc.RSDNTColor010(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTColor012(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTColor014(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTColor016(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTColor011(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTColor013(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTColor015(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTColor017(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Color of Curent Layer(Alphablend)}
// (constant) not clipped:
procedure TFastImageProc.RSDNTColor020(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTColor022(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTColor024(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTColor026(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{$endregion}

{||scl_mul||>1: (SU - Scale Up  )} {$region -fold}

{Empty}
procedure TFastImageProc.RSUNTColor009(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Color of Curent Layer}
// (constant) not clipped:
procedure TFastImageProc.RSUNTColor000(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTColor002(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTColor004(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTColor006(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Color of Curent Layer(Additive)}
// (constant) not clipped:
procedure TFastImageProc.RSUNTColor010(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTColor012(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTColor014(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTColor016(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTColor011(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTColor013(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTColor015(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTColor017(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Color of Curent Layer(Alphablend)}
// (constant) not clipped:
procedure TFastImageProc.RSUNTColor020(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTColor022(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTColor024(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTColor026(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{$endregion}

{$endregion}

{Value} {$region -fold}

{||scl_mul||=1:                  } {$region -fold}

{Auxiliary procedures}
// (constant) not clipped and top-bottom clipped:
procedure TFastImageProc.RegNTValueA0 (Proc17:TProc17; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
              Proc17 (nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,cfx_pow0);
              Inc    (nt_pix_sht_arr_ptr);
            end;
          Inc        (nt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValueA4 (Proc17:TProc17; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                      Proc17        (nt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                      Proc17        (nt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Proc17        (nt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      Proc17        (nt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) not clipped and top-bottom clipped:
procedure TFastImageProc.RegNTValueB0 (Proc15:TProc15; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
              Proc15 (nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr);
              Inc    (nt_pix_sht_arr_ptr);
            end;
          Inc        (nt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValueB4 (Proc15:TProc15; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                      Proc15        (nt_pix_sht_arr_ptr^*res_var8+v);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                      Proc15        (nt_pix_sht_arr_ptr^*res_var8+v);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Proc15        (nt_pix_sht_arr_ptr^*res_var8+v);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      Proc15        (nt_pix_sht_arr_ptr^*res_var8+v);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) not clipped and top-bottom clipped:
procedure TFastImageProc.RegNTValueC0 (Proc8 :TProc8;  const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
              Proc8  (nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,bmp_bkgnd_width);
              Inc    (nt_pix_sht_arr_ptr);
            end;
          Inc        (nt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValueC4 (Proc8 :TProc8;  const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                      Proc8         (nt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                      Proc8         (nt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Proc8         (nt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      Proc8         (nt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) not clipped and top-bottom clipped:
procedure TFastImageProc.RegNTValueD0 (Proc19:TProc19; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
              Proc19 (nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,bmp_bkgnd_width,cfx_pow0_);
              Inc    (nt_pix_sht_arr_ptr);
            end;
          Inc        (nt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValueD4 (Proc19:TProc19; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1{(c2+1)-(c1+1)}-1 do
                    begin
                      Proc19        (nt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2{(c+1)-1} do
                    begin
                      Proc19        (nt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Proc19        (nt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      Proc19        (nt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}

{Empty}
procedure TFastImageProc.RegNTValue009(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Monochrome}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegNTValueA00(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if       not ((nt_pix_cnt_arr_ptr^>=4) and
                       ((nt_pix_sht_arr_ptr+
                         nt_pix_cnt_arr_ptr^-1)^-
                         nt_pix_sht_arr_ptr^=
                         nt_pix_cnt_arr_ptr^-1)) then
            for x:=0 to  nt_pix_cnt_arr_ptr^-1 do
              begin
                        (nt_pix_sht_arr_ptr^+first_row_pix_ptr)^:=monochrome_val;
                Inc     (nt_pix_sht_arr_ptr);
              end
          else
            begin
              FillDWord((nt_pix_sht_arr_ptr^+first_row_pix_ptr)^,
                         nt_pix_cnt_arr_ptr^,monochrome_val);
              Inc       (nt_pix_sht_arr_ptr,
                         nt_pix_cnt_arr_ptr^);
            end;
          Inc           (nt_pix_cnt_arr_ptr);
          Inc    (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegNTValue000(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      if (img_inv_type in [0,2]) then
        begin
          RegNTValueA00   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
                    (-nt_pix_sht_arr_ptr^+first_row_pix_ptr)^:=monochrome_val;
              Inc    (nt_pix_sht_arr_ptr);
            end;
          Inc        (nt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValueA04(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left;
                  if           not ((c2-c1-4>=0) and
                                   ((nt_pix_sht_arr_ptr+
                                     c2-c1-1)^-
                                     nt_pix_sht_arr_ptr^=
                                     c2-c1-1)) then
                    for x:=0 to      c2-c1-1 do
                      begin
                                    (nt_pix_sht_arr_ptr^+v)^:=monochrome_val;
                        Inc         (nt_pix_sht_arr_ptr);
                      end
                  else
                    begin
                      FillDWord    ((nt_pix_sht_arr_ptr^+v)^,c2-c1,monochrome_val);
                      Inc           (nt_pix_sht_arr_ptr     ,c2-c1);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^   -(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr, c+1);
                  v:=first_row_pix_ptr-rct_src.left;
                  if           not ((nt_pix_cnt_arr_ptr^-c-5>=0) and
                                   ((nt_pix_sht_arr_ptr+
                                     nt_pix_cnt_arr_ptr^-c-2)^-
                                     nt_pix_sht_arr_ptr^=
                                     nt_pix_cnt_arr_ptr^-c-2)) then
                    for x:=0 to      nt_pix_cnt_arr_ptr^-c-2 do
                      begin
                                    (nt_pix_sht_arr_ptr^+v)^:=monochrome_val;
                        Inc         (nt_pix_sht_arr_ptr);
                      end
                  else
                    begin
                      FillDWord    ((nt_pix_sht_arr_ptr^+v)^,
                                     nt_pix_cnt_arr_ptr^-c-1,monochrome_val);
                      Inc           (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-c-1);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left;
                  if           not ((c-3>=0) and
                                   ((nt_pix_sht_arr_ptr +c)^-
                                     nt_pix_sht_arr_ptr^=c)) then
                    for x:=0 to c do
                      begin
                                    (nt_pix_sht_arr_ptr^+v)^:=monochrome_val;
                        Inc         (nt_pix_sht_arr_ptr);
                      end
                  else
                    begin
                      FillDWord    ((nt_pix_sht_arr_ptr^+v)^,c+1,monochrome_val);
                      Inc           (nt_pix_sht_arr_ptr,     c+1);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left;
                  if           not ((nt_pix_cnt_arr_ptr^-4>=0) and
                                   ((nt_pix_sht_arr_ptr+
                                     nt_pix_cnt_arr_ptr^-1)^-
                                     nt_pix_sht_arr_ptr^=
                                     nt_pix_cnt_arr_ptr^-1)) then
                    for x:=0 to      nt_pix_cnt_arr_ptr^-1 do
                      begin
                                    (nt_pix_sht_arr_ptr^+v)^:=monochrome_val;
                        Inc         (nt_pix_sht_arr_ptr);
                      end
                  else
                    begin
                      FillDWord    ((nt_pix_sht_arr_ptr^+v)^,
                                     nt_pix_cnt_arr_ptr^,monochrome_val);
                      Inc           (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegNTValue004(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      if (img_inv_type in [0,2]) then
        begin
          RegNTValueA04   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr+rct_src.left;
                  for x:=0 to      c2-c1-1 do
                    begin
                                   (-nt_pix_sht_arr_ptr^+v)^:=monochrome_val;
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^   -(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr, c+1);
                  v:=first_row_pix_ptr+rct_src.left;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                                   (-nt_pix_sht_arr_ptr^+v)^:=monochrome_val;
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr+rct_src.left;
                  for x:=0 to c do
                    begin
                                   (-nt_pix_sht_arr_ptr^+v)^:=monochrome_val;
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr+rct_src.left;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                                   (-nt_pix_sht_arr_ptr^+v)^:=monochrome_val;
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue006(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    PPFloodFill(fast_image_data_ptr_^.bmp_bkgnd_ptr,
                bmp_bkgnd_width,
                rct_dst,
                monochrome_val);
end; {$endregion}
// (fading):
// same;

{Additive}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegNTValue010(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to   nt_pix_cnt_arr_ptr^-1 do
            begin
              Additive1(nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,monochrome_val);
              Inc      (nt_pix_sht_arr_ptr);
            end;
          Inc          (nt_pix_cnt_arr_ptr);
          Inc   (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue014(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Additive1     (nt_pix_sht_arr_ptr^*res_var8+v,monochrome_val);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Additive1     (nt_pix_sht_arr_ptr^*res_var8+v,monochrome_val);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Additive1     (nt_pix_sht_arr_ptr^*res_var8+v,monochrome_val);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      Additive1     (nt_pix_sht_arr_ptr^*res_var8+v,monochrome_val);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue016(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    PPAdditive(fast_image_data_ptr_^.bmp_bkgnd_ptr,
               bmp_bkgnd_width,
               rct_dst,
               monochrome_val);
end; {$endregion}
// (fading) auxiliary procedure:
procedure TFastImageProc.RegNTValue011(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue010   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to      nt_pix_cnt_arr_ptr^-1 do
            begin
              AdditiveDec1(nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,monochrome_val,cfx_pow0_);
              Inc         (nt_pix_sht_arr_ptr);
            end;
          Inc             (nt_pix_cnt_arr_ptr);
          Inc      (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue015(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue014   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AdditiveDec1  (nt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AdditiveDec1  (nt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AdditiveDec1  (nt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      AdditiveDec1  (nt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue017(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue016(fast_image_data_ptr_,fast_image_data_)
    else
      PPAdditiveDec(fast_image_data_ptr_^.bmp_bkgnd_ptr,
                    bmp_bkgnd_width,
                    rct_dst,
                    monochrome_val,
                    MAXBYTE-cfx_pow0);
end; {$endregion}

{Alphablend}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegNTValue020(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue000   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to     nt_pix_cnt_arr_ptr^-1 do
            begin
              AlphaBlend1(nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,monochrome_val,cfx_pow0_);
              Inc        (nt_pix_sht_arr_ptr);
            end;
          Inc            (nt_pix_cnt_arr_ptr);
          Inc     (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue024(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue004   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AlphaBlend1   (nt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AlphaBlend1   (nt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AlphaBlend1   (nt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      AlphaBlend1   (nt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue026(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue006(fast_image_data_ptr_,fast_image_data_)
    else
      PPAlphaBlend (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                    bmp_bkgnd_width,
                    rct_dst,
                    monochrome_val,
                    cfx_pow0);
end; {$endregion}
// (fading):
// same;

{Inverse}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegNTValue030(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to  nt_pix_cnt_arr_ptr^-1 do
            begin
              Inverse1(nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr);
              Inc     (nt_pix_sht_arr_ptr);
            end;
          Inc         (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue034(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Inverse1      (nt_pix_sht_arr_ptr^*res_var8+v);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Inverse1      (nt_pix_sht_arr_ptr^*res_var8+v);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Inverse1      (nt_pix_sht_arr_ptr^*res_var8+v);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      Inverse1      (nt_pix_sht_arr_ptr^*res_var8+v);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue036(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    PPInverse(fast_image_data_ptr_^.bmp_bkgnd_ptr,
              bmp_bkgnd_width,
              rct_dst);
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegNTValue031(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue030(             fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0*=-1;
      cfx_pow0+=MAXBYTE;
      RegNTValueA0     (@InverseDec1,fast_image_data_ptr_,fast_image_data_);
      cfx_pow0-=MAXBYTE;
      cfx_pow0*=-1;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue035(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue034(             fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0*=-1;
      cfx_pow0+=MAXBYTE;
      RegNTValueA4     (@InverseDec1,fast_image_data_ptr_,fast_image_data_);
      cfx_pow0-=MAXBYTE;
      cfx_pow0*=-1;
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue037(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue036(fast_image_data_ptr_,fast_image_data_)
    else
      PPInverseDec(fast_image_data_ptr_^.bmp_bkgnd_ptr,
                   bmp_bkgnd_width,
                   rct_dst,
                   MAXBYTE-cfx_pow0);
end; {$endregion}

{Highlight}
// (constant) not clipped:
procedure TFastImageProc.RegNTValue040(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueA0(@Highlight1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue044(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueA4(@Highlight1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue046(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    PPHighlight(fast_image_data_ptr_^.bmp_bkgnd_ptr,
                bmp_bkgnd_width,
                rct_dst,
                cfx_pow0);
end; {$endregion}
// (fading):
// same;

{Darken}
// (constant) not clipped:
procedure TFastImageProc.RegNTValue050(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueA0(@Darken1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue054(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueA4(@Darken1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue056(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    PPDarken(fast_image_data_ptr_^.bmp_bkgnd_ptr,
             bmp_bkgnd_width,
             rct_dst,
             cfx_pow0);
end; {$endregion}
// (fading):
// same;

{GrayscaleR}
// (constant) not clipped:
procedure TFastImageProc.RegNTValue060(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueB0(@GrayscaleR1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue064(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueB4(@GrayscaleR1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue066(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    PPGrayscaleR(fast_image_data_ptr_^.bmp_bkgnd_ptr,
                 bmp_bkgnd_width,
                 rct_dst);
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegNTValue061(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue060(                fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueA0 (@GrayscaleRDec1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue065(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue064(                fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueA4 (@GrayscaleRDec1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue067(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue066  (fast_image_data_ptr_,fast_image_data_)
    else
      PPGrayscaleRDec(fast_image_data_ptr_^.bmp_bkgnd_ptr,
                      bmp_bkgnd_width,
                      rct_dst,
                      cfx_pow0);
end; {$endregion}

{GrayscaleG}
// (constant) not clipped:
procedure TFastImageProc.RegNTValue070(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueB0(@GrayscaleG1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue074(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueB4(@GrayscaleG1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue076(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    PPGrayscaleG(fast_image_data_ptr_^.bmp_bkgnd_ptr,
                 bmp_bkgnd_width,
                 rct_dst);
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegNTValue071(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue070(                fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueA0 (@GrayscaleGDec1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue075(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue074(                fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueA4 (@GrayscaleGDec1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue077(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue076  (fast_image_data_ptr_,fast_image_data_)
    else
      PPGrayscaleGDec(fast_image_data_ptr_^.bmp_bkgnd_ptr,
                      bmp_bkgnd_width,
                      rct_dst,
                      cfx_pow0);
end; {$endregion}

{GrayscaleB}
// (constant) not clipped:
procedure TFastImageProc.RegNTValue080(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueB0(@GrayscaleB1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue084(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueB4(@GrayscaleB1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue086(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    PPGrayscaleB(fast_image_data_ptr_^.bmp_bkgnd_ptr,
                 bmp_bkgnd_width,
                 rct_dst);
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegNTValue081(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue080(                fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueA0 (@GrayscaleBDec1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue085(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue084(                fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueA4 (@GrayscaleBDec1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue087(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue086  (fast_image_data_ptr_,fast_image_data_)
    else
      PPGrayscaleBDec(fast_image_data_ptr_^.bmp_bkgnd_ptr,
                      bmp_bkgnd_width,
                      rct_dst,
                      cfx_pow0);
end; {$endregion}

{Monochrome Noise}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegNTValue090(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
              if Odd((nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr)^) then
                     (nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr)^:=monochrome_val;
              Inc    (nt_pix_sht_arr_ptr);
            end;
          Inc        (nt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue094(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      if Odd       ((nt_pix_sht_arr_ptr^*res_var8+v)^) then
                                    (nt_pix_sht_arr_ptr^*res_var8+v)^:=monochrome_val;
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      if Odd       ((nt_pix_sht_arr_ptr^*res_var8+v)^) then
                                    (nt_pix_sht_arr_ptr^*res_var8+v)^:=monochrome_val;
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      if Odd       ((nt_pix_sht_arr_ptr^*res_var8+v)^) then
                                    (nt_pix_sht_arr_ptr^*res_var8+v)^:=monochrome_val;
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      if Odd       ((nt_pix_sht_arr_ptr^*res_var8+v)^) then
                                    (nt_pix_sht_arr_ptr^*res_var8+v)^:=monochrome_val;
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue096(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    PPMonoNoise(fast_image_data_ptr_^.bmp_bkgnd_ptr,
                bmp_bkgnd_width,
                rct_dst,
                monochrome_val);
end; {$endregion}
// (fading) auxiliary procedure:
procedure TFastImageProc.RegNTValue091(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue090   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to       nt_pix_cnt_arr_ptr^-1 do
            begin
              if Odd      ((nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr)^) then
                AlphaBlend1(nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,monochrome_val,cfx_pow0_);
              Inc          (nt_pix_sht_arr_ptr);
            end;
          Inc              (nt_pix_cnt_arr_ptr);
          Inc       (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue095(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegNTValue094   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      if Odd       ((nt_pix_sht_arr_ptr^*res_var8+v)^) then
                        AlphaBlend1 (nt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      if Odd       ((nt_pix_sht_arr_ptr^*res_var8+v)^) then
                        AlphaBlend1 (nt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      if Odd       ((nt_pix_sht_arr_ptr^*res_var8+v)^) then
                        AlphaBlend1 (nt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      if Odd       ((nt_pix_sht_arr_ptr^*res_var8+v)^) then
                        AlphaBlend1 (nt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue097(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue096 (fast_image_data_ptr_,fast_image_data_)
    else
      PPMonoNoiseDec(fast_image_data_ptr_^.bmp_bkgnd_ptr,
                     bmp_bkgnd_width,
                     rct_dst,
                     monochrome_val,
                     cfx_pow0);
end; {$endregion}

{ColorizeR}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegNTValue100(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to    nt_pix_cnt_arr_ptr^-1 do
            begin
              ColorizeR1(nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,cfx_pow0_);
              Inc       (nt_pix_sht_arr_ptr);
            end;
          Inc           (nt_pix_cnt_arr_ptr);
          Inc    (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue104(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      ColorizeR1    (nt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      ColorizeR1    (nt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      ColorizeR1    (nt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      ColorizeR1    (nt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue106(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    PPColorCorrectionM0(@ColorizeR1,
                        fast_image_data_ptr_^.bmp_bkgnd_ptr,
                        bmp_bkgnd_width,
                        rct_dst,
                        MAXBYTE-cfx_pow0);
end; {$endregion}
// (fading):
// same;

{ColorizeG}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegNTValue110(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to    nt_pix_cnt_arr_ptr^-1 do
            begin
              ColorizeG1(nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,cfx_pow0_);
              Inc       (nt_pix_sht_arr_ptr);
            end;
          Inc           (nt_pix_cnt_arr_ptr);
          Inc    (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue114(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      ColorizeG1    (nt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      ColorizeG1    (nt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      ColorizeG1    (nt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      ColorizeG1    (nt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue116(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    PPColorCorrectionM0(@ColorizeG1,
                        fast_image_data_ptr_^.bmp_bkgnd_ptr,
                        bmp_bkgnd_width,
                        rct_dst,
                        MAXBYTE-cfx_pow0);
end; {$endregion}
// (fading):
// same;

{ColorizeB}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegNTValue120(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to    nt_pix_cnt_arr_ptr^-1 do
            begin
              ColorizeB1(nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,cfx_pow0_);
              Inc       (nt_pix_sht_arr_ptr);
            end;
          Inc           (nt_pix_cnt_arr_ptr);
          Inc    (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue124(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      ColorizeB1    (nt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      ColorizeB1    (nt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      ColorizeB1    (nt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      ColorizeB1    (nt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue126(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    PPColorCorrectionM0(@ColorizeB1,
                        fast_image_data_ptr_^.bmp_bkgnd_ptr,
                        bmp_bkgnd_width,
                        rct_dst,
                        MAXBYTE-cfx_pow0);
end; {$endregion}
// (fading):
// same;

{BlurRGB}
// (constant) not clipped:
procedure TFastImageProc.RegNTValue130(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueC0(@BlurRGB4,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue134(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueC4(@BlurRGB4,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue136(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    PPBlur(fast_image_data_ptr_^.bmp_bkgnd_ptr,
           bmp_bkgnd_width,
           rct_dst,
           @BlurRGB4);
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegNTValue131(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue130(             fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueD0 (@BlurRGB4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue135(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue134(             fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueD4 (@BlurRGB4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue137(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue136(fast_image_data_ptr_,fast_image_data_)
    else
      PPBlurDec    (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                    bmp_bkgnd_width,
                    rct_dst,
                    @BlurRGB4Dec,
                    MAXBYTE-cfx_pow0);
end; {$endregion}

{BlurRRB}
// (constant) not clipped:
procedure TFastImageProc.RegNTValue140(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueC0(@BlurRRB4,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue144(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueC4(@BlurRRB4,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue146(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    PPBlur(fast_image_data_ptr_^.bmp_bkgnd_ptr,
           bmp_bkgnd_width,
           rct_dst,
           @BlurRRB4);
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegNTValue141(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue140(             fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueD0 (@BlurRRB4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue145(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue144(             fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueD4 (@BlurRRB4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue147(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue146(fast_image_data_ptr_,fast_image_data_)
    else
      PPBlurDec    (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                    bmp_bkgnd_width,
                    rct_dst,
                    @BlurRRB4Dec,
                    MAXBYTE-cfx_pow0);
end; {$endregion}

{BlurRGR}
// (constant) not clipped:
procedure TFastImageProc.RegNTValue150(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueC0(@BlurRGR4,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue154(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueC4(@BlurRGR4,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue156(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    PPBlur(fast_image_data_ptr_^.bmp_bkgnd_ptr,
           bmp_bkgnd_width,
           rct_dst,
           @BlurRGR4);
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegNTValue151(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue150(             fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueD0 (@BlurRGR4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue155(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue154(             fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueD4 (@BlurRGR4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue157(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue156(fast_image_data_ptr_,fast_image_data_)
    else
      PPBlurDec    (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                    bmp_bkgnd_width,
                    rct_dst,
                    @BlurRGR4Dec,
                    MAXBYTE-cfx_pow0);
end; {$endregion}

{BlurGGB}
// (constant) not clipped:
procedure TFastImageProc.RegNTValue160(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueC0(@BlurGGB4,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue164(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueC4(@BlurGGB4,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue166(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    PPBlur(fast_image_data_ptr_^.bmp_bkgnd_ptr,
           bmp_bkgnd_width,
           rct_dst,
           @BlurGGB4);
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegNTValue161(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue160(             fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueD0 (@BlurGGB4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue165(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue164(             fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueD4 (@BlurGGB4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue167(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue166(fast_image_data_ptr_,fast_image_data_)
    else
      PPBlurDec    (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                    bmp_bkgnd_width,
                    rct_dst,
                    @BlurGGB4Dec,
                    MAXBYTE-cfx_pow0);
end; {$endregion}

{BlurRGG}
// (constant) not clipped:
procedure TFastImageProc.RegNTValue170(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueC0(@BlurRGG4,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue174(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueC4(@BlurRGG4,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue176(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    PPBlur(fast_image_data_ptr_^.bmp_bkgnd_ptr,
           bmp_bkgnd_width,
           rct_dst,
           @BlurRGG4);
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegNTValue171(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue170(             fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueD0 (@BlurRGG4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue175(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue174(             fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueD4 (@BlurRGG4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue177(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue176(fast_image_data_ptr_,fast_image_data_)
    else
      PPBlurDec    (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                    bmp_bkgnd_width,
                    rct_dst,
                    @BlurRGG4Dec,
                    MAXBYTE-cfx_pow0);
end; {$endregion}

{BlurBGB}
// (constant) not clipped:
procedure TFastImageProc.RegNTValue180(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueC0(@BlurBGB4,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue184(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueC4(@BlurBGB4,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue186(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    PPBlur(fast_image_data_ptr_^.bmp_bkgnd_ptr,
           bmp_bkgnd_width,
           rct_dst,
           @BlurBGB4);
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegNTValue181(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue180(             fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueD0 (@BlurBGB4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue185(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue184(             fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueD4 (@BlurBGB4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue187(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue186(fast_image_data_ptr_,fast_image_data_)
    else
      PPBlurDec    (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                    bmp_bkgnd_width,
                    rct_dst,
                    @BlurBGB4Dec,
                    MAXBYTE-cfx_pow0);
end; {$endregion}

{BlurRBB}
// (constant) not clipped:
procedure TFastImageProc.RegNTValue190(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueC0(@BlurRBB4,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue194(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueC4(@BlurRBB4,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue196(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    PPBlur(fast_image_data_ptr_^.bmp_bkgnd_ptr,
           bmp_bkgnd_width,
           rct_dst,
           @BlurRBB4);
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegNTValue191(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue190(             fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueD0 (@BlurRBB4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue195(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue194(             fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueD4 (@BlurRBB4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue197(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue196(fast_image_data_ptr_,fast_image_data_)
    else
      PPBlurDec    (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                    bmp_bkgnd_width,
                    rct_dst,
                    @BlurRBB4Dec,
                    MAXBYTE-cfx_pow0);
end; {$endregion}

{BlurRRR}
// (constant) not clipped:
procedure TFastImageProc.RegNTValue200(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueC0(@BlurRRR4,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue204(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueC4(@BlurRRR4,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue206(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    PPBlur(fast_image_data_ptr_^.bmp_bkgnd_ptr,
           bmp_bkgnd_width,
           rct_dst,
           @BlurRRR4);
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegNTValue201(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue200(             fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueD0 (@BlurRRR4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue205(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue204(             fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueD4 (@BlurRRR4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue207(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue206(fast_image_data_ptr_,fast_image_data_)
    else
      PPBlurDec    (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                    bmp_bkgnd_width,
                    rct_dst,
                    @BlurRRR4Dec,
                    MAXBYTE-cfx_pow0);
end; {$endregion}

{BlurGGG}
// (constant) not clipped:
procedure TFastImageProc.RegNTValue210(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueC0(@BlurGGG4,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue214(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueC4(@BlurGGG4,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue216(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    PPBlur(fast_image_data_ptr_^.bmp_bkgnd_ptr,
           bmp_bkgnd_width,
           rct_dst,
           @BlurGGG4);
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegNTValue211(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue210(             fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueD0 (@BlurGGG4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue215(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue214(             fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueD4 (@BlurGGG4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue217(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue216(fast_image_data_ptr_,fast_image_data_)
    else
      PPBlurDec    (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                    bmp_bkgnd_width,
                    rct_dst,
                    @BlurGGG4Dec,
                    MAXBYTE-cfx_pow0);
end; {$endregion}

{BlurBBB}
// (constant) not clipped:
procedure TFastImageProc.RegNTValue220(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueC0(@BlurBBB4,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue224(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RegNTValueC4(@BlurBBB4,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue226(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    PPBlur(fast_image_data_ptr_^.bmp_bkgnd_ptr,
           bmp_bkgnd_width,
           rct_dst,
           @BlurBBB4);
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegNTValue221(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue220(             fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueD0 (@BlurBBB4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue225(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue224(             fast_image_data_ptr_,fast_image_data_)
    else
      RegNTValueD4 (@BlurBBB4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RegNTValue227(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (cfx_pow0=MAXBYTE) then
      RegNTValue226(fast_image_data_ptr_,fast_image_data_)
    else
      PPBlurDec    (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                    bmp_bkgnd_width,
                    rct_dst,
                    @BlurBBB4Dec,
                    MAXBYTE-cfx_pow0);
end; {$endregion}

{Contrast}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegNTValue230(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  contrast_pow      : integer;
  r                 : byte=128;
  g                 : byte=128;
  b                 : byte=128;
begin
  with fast_image_data_ do
    begin
      contrast_pow      :=FloatToFixed(1+cfx_pow0/10);
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to   nt_pix_cnt_arr_ptr^-1 do
            begin
              Contrast2(nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,r,g,b,contrast_pow);
              Inc      (nt_pix_sht_arr_ptr);
            end;
          Inc          (nt_pix_cnt_arr_ptr);
          Inc   (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegNTValue234(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  contrast_pow      : integer;
  r                 : byte=128;
  g                 : byte=128;
  b                 : byte=128;
label
  label1;
begin
  with fast_image_data_ do
    begin
      contrast_pow      :=FloatToFixed(1+cfx_pow0/10);
      RegNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Contrast2     (nt_pix_sht_arr_ptr^*res_var8+v,r,g,b,contrast_pow);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Contrast2     (nt_pix_sht_arr_ptr^*res_var8+v,r,g,b,contrast_pow);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Contrast2     (nt_pix_sht_arr_ptr^*res_var8+v,r,g,b,contrast_pow);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      Contrast2     (nt_pix_sht_arr_ptr^*res_var8+v,r,g,b,contrast_pow);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegNTValue236(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    PPContrast1(fast_image_data_ptr_^.bmp_bkgnd_ptr,
                bmp_bkgnd_width,
                rct_dst,
                cfx_pow0);
end; {$endregion}
// (fading):
// same;

{$endregion}

{||scl_mul||<1: (SD - Scale Down)} {$region -fold}

{Empty}
procedure TFastImageProc.RSDNTValue009(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Monochrome}
// (constant) not clipped:
procedure TFastImageProc.RSDNTValue000(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTValue002(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue004(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue006(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTValue001(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTValue003(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue005(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue007(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Additive}
// (constant) not clipped:
procedure TFastImageProc.RSDNTValue010(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTValue012(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue014(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue016(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTValue011(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTValue013(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue015(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue017(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Alphablend}
// (constant) not clipped:
procedure TFastImageProc.RSDNTValue020(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTValue022(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue024(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue026(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTValue021(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTValue023(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue025(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue027(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Inverse}
// (constant) not clipped:
procedure TFastImageProc.RSDNTValue030(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTValue032(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue034(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue036(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTValue031(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTValue033(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue035(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue037(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Highlight}
// (constant) not clipped:
procedure TFastImageProc.RSDNTValue040(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTValue042(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue044(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue046(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTValue041(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTValue043(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue045(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue047(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Darken}
// (constant) not clipped:
procedure TFastImageProc.RSDNTValue050(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTValue052(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue054(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue056(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTValue051(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTValue053(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue055(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue057(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{GrayscaleR}
// (constant) not clipped:
procedure TFastImageProc.RSDNTValue060(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTValue062(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue064(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue066(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTValue061(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTValue063(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue065(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue067(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{GrayscaleG}
// (constant) not clipped:
procedure TFastImageProc.RSDNTValue070(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTValue072(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue074(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue076(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTValue071(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTValue073(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue075(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue077(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{GrayscaleB}
// (constant) not clipped:
procedure TFastImageProc.RSDNTValue080(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTValue082(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue084(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue086(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTValue081(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTValue083(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue085(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue087(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Monochrome Noise}
// (constant) not clipped:
procedure TFastImageProc.RSDNTValue090(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTValue092(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue094(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue096(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTValue091(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTValue093(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue095(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue097(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{ColorizeR}
// (constant) not clipped:
procedure TFastImageProc.RSDNTValue100(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTValue102(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue104(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue106(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTValue101(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTValue103(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue105(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue107(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{ColorizeG}
// (constant) not clipped:
procedure TFastImageProc.RSDNTValue110(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTValue112(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue114(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue116(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTValue111(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTValue113(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue115(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue117(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{ColorizeB}
// (constant) not clipped:
procedure TFastImageProc.RSDNTValue120(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTValue122(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue124(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue126(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTValue121(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTValue123(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue125(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue127(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurRGB}
// (constant) not clipped:
procedure TFastImageProc.RSDNTValue130(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTValue132(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue134(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue136(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTValue131(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTValue133(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue135(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue137(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurRRB}
// (constant) not clipped:
procedure TFastImageProc.RSDNTValue140(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTValue142(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue144(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue146(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTValue141(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTValue143(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue145(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue147(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurRGR}
// (constant) not clipped:
procedure TFastImageProc.RSDNTValue150(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTValue152(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue154(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue156(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTValue151(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTValue153(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue155(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue157(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurGGB}
// (constant) not clipped:
procedure TFastImageProc.RSDNTValue160(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTValue162(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue164(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue166(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTValue161(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTValue163(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue165(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue167(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurRGG}
// (constant) not clipped:
procedure TFastImageProc.RSDNTValue170(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTValue172(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue174(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue176(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTValue171(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTValue173(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue175(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue177(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurBGB}
// (constant) not clipped:
procedure TFastImageProc.RSDNTValue180(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTValue182(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue184(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue186(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTValue181(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTValue183(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue185(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue187(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurRBB}
// (constant) not clipped:
procedure TFastImageProc.RSDNTValue190(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTValue192(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue194(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue196(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTValue191(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTValue193(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue195(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue197(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurRRR}
// (constant) not clipped:
procedure TFastImageProc.RSDNTValue200(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTValue202(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue204(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue206(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTValue201(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTValue203(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue205(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue207(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurGGG}
// (constant) not clipped:
procedure TFastImageProc.RSDNTValue210(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTValue212(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue214(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue216(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTValue211(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTValue213(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue215(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue217(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurBBB}
// (constant) not clipped:
procedure TFastImageProc.RSDNTValue220(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTValue222(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue224(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue226(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTValue221(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTValue223(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue225(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue227(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Contrast}
// (constant) not clipped:
procedure TFastImageProc.RSDNTValue230(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDNTValue232(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue234(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue236(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDNTValue231(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDNTValue233(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDNTValue235(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSDNTValue237(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{$endregion}

{||scl_mul||>1: (SU - Scale Up  )} {$region -fold}

{Empty}
procedure TFastImageProc.RSUNTValue009(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Monochrome}
// (constant) not clipped:
procedure TFastImageProc.RSUNTValue000(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTValue002(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue004(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue006(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTValue001(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTValue003(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue005(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue007(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Additive}
// (constant) not clipped:
procedure TFastImageProc.RSUNTValue010(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTValue012(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue014(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue016(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTValue011(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTValue013(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue015(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue017(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Alphablend}
// (constant) not clipped:
procedure TFastImageProc.RSUNTValue020(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTValue022(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue024(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue026(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTValue021(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTValue023(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue025(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue027(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Inverse}
// (constant) not clipped:
procedure TFastImageProc.RSUNTValue030(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTValue032(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue034(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue036(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTValue031(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTValue033(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue035(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue037(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Highlight}
// (constant) not clipped:
procedure TFastImageProc.RSUNTValue040(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTValue042(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue044(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue046(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTValue041(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTValue043(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue045(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue047(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Darken}
// (constant) not clipped:
procedure TFastImageProc.RSUNTValue050(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTValue052(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue054(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue056(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTValue051(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTValue053(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue055(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue057(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{GrayscaleR}
// (constant) not clipped:
procedure TFastImageProc.RSUNTValue060(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTValue062(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue064(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue066(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTValue061(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTValue063(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue065(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue067(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{GrayscaleG}
// (constant) not clipped:
procedure TFastImageProc.RSUNTValue070(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTValue072(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue074(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue076(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTValue071(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTValue073(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue075(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue077(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{GrayscaleB}
// (constant) not clipped:
procedure TFastImageProc.RSUNTValue080(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTValue082(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue084(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue086(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTValue081(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTValue083(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue085(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue087(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Monochrome Noise}
// (constant) not clipped:
procedure TFastImageProc.RSUNTValue090(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTValue092(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue094(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue096(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTValue091(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTValue093(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue095(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue097(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{ColorizeR}
// (constant) not clipped:
procedure TFastImageProc.RSUNTValue100(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTValue102(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue104(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue106(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTValue101(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTValue103(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue105(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue107(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{ColorizeG}
// (constant) not clipped:
procedure TFastImageProc.RSUNTValue110(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTValue112(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue114(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue116(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTValue111(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTValue113(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue115(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue117(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{ColorizeB}
// (constant) not clipped:
procedure TFastImageProc.RSUNTValue120(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTValue122(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue124(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue126(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTValue121(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTValue123(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue125(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue127(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurRGB}
// (constant) not clipped:
procedure TFastImageProc.RSUNTValue130(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTValue132(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue134(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue136(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTValue131(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTValue133(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue135(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue137(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurRRB}
// (constant) not clipped:
procedure TFastImageProc.RSUNTValue140(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTValue142(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue144(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue146(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTValue141(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTValue143(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue145(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue147(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurRGR}
// (constant) not clipped:
procedure TFastImageProc.RSUNTValue150(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTValue152(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue154(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue156(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTValue151(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTValue153(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue155(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue157(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurGGB}
// (constant) not clipped:
procedure TFastImageProc.RSUNTValue160(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTValue162(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue164(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue166(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTValue161(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTValue163(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue165(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue167(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurRGG}
// (constant) not clipped:
procedure TFastImageProc.RSUNTValue170(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTValue172(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue174(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue176(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTValue171(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTValue173(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue175(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue177(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurBGB}
// (constant) not clipped:
procedure TFastImageProc.RSUNTValue180(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTValue182(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue184(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue186(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTValue181(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTValue183(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue185(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue187(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurRBB}
// (constant) not clipped:
procedure TFastImageProc.RSUNTValue190(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTValue192(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue194(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue196(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTValue191(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTValue193(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue195(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue197(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurRRR}
// (constant) not clipped:
procedure TFastImageProc.RSUNTValue200(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTValue202(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue204(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue206(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTValue201(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTValue203(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue205(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue207(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurGGG}
// (constant) not clipped:
procedure TFastImageProc.RSUNTValue210(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTValue212(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue214(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue216(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTValue211(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTValue213(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue215(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue217(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurBBB}
// (constant) not clipped:
procedure TFastImageProc.RSUNTValue220(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTValue222(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue224(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue226(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTValue221(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTValue223(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue225(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue227(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Contrast}
// (constant) not clipped:
procedure TFastImageProc.RSUNTValue230(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUNTValue232(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue234(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue236(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUNTValue231(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUNTValue233(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUNTValue235(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
procedure TFastImageProc.RSUNTValue237(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{$endregion}

{$endregion}

// PT - partly transparent pixels:

{Auxiliary procedure}
procedure TFastImageProc.RegPTResVar0 (                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b0,b1: byte;
begin
  with fast_image_data_ do
    begin
      b0      :=Byte(img_inv_type in [0,1]);
      b1      :=Byte(img_inv_type in [1,3]);
      res_var0:=Max2(               fast_image_data_ptr_^.pt_pix_arr_row_mrg_top,rct_src.top);
      res_var1:=                    fast_image_data_ptr_^.pt_cnt_ind_arr[res_var0];
      res_var2:=Min2(rct_ent.height-fast_image_data_ptr_^.pt_pix_arr_row_mrg_btm,rct_src.bottom)-res_var0-1;
      res_var3:=2*b0-1;
      res_var4:=res_var3*res_var0+b0*rct_ent.top+(1-b0)*(rct_ent.bottom-1);
      res_var5:=res_var3*bmp_bkgnd_width;
      res_var6:=rct_dst.left+b1*(rct_src.width-1);
      res_var7:=res_var4*bmp_bkgnd_width+res_var6;
      res_var8:=1-2*b1;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTResVar1 (                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b0: byte;
begin
  with fast_image_data_,fip_scale_data_var1 do
    begin
        b0      :=Byte(img_inv_type in [0,1]);
        res_var3:=2*b0-1;
        res_var0:=Max2(               rct_src_mrg.top   ,Trunc((   b0 *rct_clp_ptr^.top+(1-b0)*rct_clp_ptr^.bottom-m1)/(res_var3*scl_mul.y))+(1-b0));
        res_var2:=Min2(rct_ent.height-rct_src_mrg.bottom,Trunc(((1-b0)*rct_clp_ptr^.top+   b0 *rct_clp_ptr^.bottom-m1)/(res_var3*scl_mul.y))+(1-b0))-res_var0{-1};
      if         (fast_image_data_ptr_^.pt_cnt_ind_arr<>Nil) then
        res_var1:=fast_image_data_ptr_^.pt_cnt_ind_arr[res_var0];
    end;
end; {$endregion}
procedure TFastImageProc.RegPTResVar2 (                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b0: byte;
begin
  with fast_image_data_,fip_scale_data_var1 do
    begin
      b0      :=Byte(img_inv_type in [0,1]);
      res_var3:=2*b0-1;
      res_var0:=Max2(               Max2(fast_image_data_ptr_^.pt_pix_arr_row_mrg_top,rct_src_mrg.top   ),Trunc((   b0 *rct_clp_ptr^.top+(1-b0)*rct_clp_ptr^.bottom-m1)/(res_var3*scl_mul.y))+(1-b0));
      res_var2:=Min2(rct_ent.height-Max2(fast_image_data_ptr_^.pt_pix_arr_row_mrg_btm,rct_src_mrg.bottom),Trunc(((1-b0)*rct_clp_ptr^.top+   b0 *rct_clp_ptr^.bottom-m1)/(res_var3*scl_mul.y))+(1-b0))-res_var0{-1};
      res_var1:=                         fast_image_data_ptr_^.pt_cnt_ind_arr[res_var0];
    end;
end; {$endregion}
procedure TFastImageProc.RegPTResVar3 (                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b1: byte;
begin
  with fast_image_data_,fip_scale_data_var1 do
    begin
      b1       :=Byte(img_inv_type in [1,3]);
      res_var8 :=1-2*b1;
      res_var9 :=((1-b1)*rct_clp_ptr^.left+(  b1)*rct_clp_ptr^.right-m0)/(res_var8*scl_mul.x);
      res_var10:=((  b1)*rct_clp_ptr^.left+(1-b1)*rct_clp_ptr^.right-m0)/(res_var8*scl_mul.x);
    end;
end; {$endregion}
procedure TFastImageProc.SclPTResVar0 (                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,fip_scale_data_var0 do
    begin
      rct_ent_left:=                                                                          rct_ent.left<<15;
     _scl_mul_x   :=Trunc(ONE_SHL_15* scl_mul.x);
     _scl_mul_y   :=Trunc(ONE_SHL_15* scl_mul.y);
      d1          :=     (ONE_SHL_15-_scl_mul_x)*                                             rct_ent.left;
      d2          :=     (ONE_SHL_15-_scl_mul_y)*                                             rct_ent.top ;
      scl_mul_x   :=                 _scl_mul_x<<1;
      scl_mul_y   :=                 _scl_mul_y<<1;
      r1          :=                  scl_mul_x*(                                             rct_ent.left)+d1<<1;
      v3          :=                  scl_mul_y*(fast_image_data_ptr_^.pt_pix_arr_row_mrg_top+rct_ent.top )+d2<<1;
      g2          :=                 _scl_mul_y* fast_image_data_ptr_^.pt_pix_arr_row_mrg_top+rct_ent.top <<15;
    end;
end; {$endregion}
procedure TFastImageProc.SclPTResVar1 (                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,fip_scale_data_var1 do
    begin
      m0:=scl_mul.x*(rct_ent.left+Byte(img_inv_type in [1,3])*(rct_ent.width -1))+(1-scl_mul.x)*pvt0.x;
      m1:=scl_mul.y*(rct_ent.top +Byte(img_inv_type in [2,3])*(rct_ent.height-1))+(1-scl_mul.y)*pvt0.y;
    end;
end; {$endregion}

{Color} {$region -fold}

{||scl_mul||=1:                  } {$region -fold}

{Empty}
procedure TFastImageProc.RegPTColor009(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Color of Curent Layer}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTColorA00(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          for x:=0 to     pt_pix_cnt_arr_ptr^-1 do
            begin
              AlphaBlend1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
                          pt_pix_ccl_arr_ptr^,MAXBYTE-
              TRGBA      (pt_pix_ccl_arr_ptr^).a);
              Inc        (pt_pix_sht_arr_ptr);
              Inc        (pt_pix_ccl_arr_ptr);
            end;
          Inc            (pt_pix_cnt_arr_ptr);
          Inc     (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTColorB00(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr)^:=
                      pt_pix_ccl_arr_ptr^;
              Inc    (pt_pix_sht_arr_ptr);
              Inc    (pt_pix_ccl_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.RegPTColor000(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTColorA00(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTColorB00(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTColorA04(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_ccl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AlphaBlend1   (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,MAXBYTE-
                      TRGBA         (pt_pix_ccl_arr_ptr^).a);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_ccl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AlphaBlend1   (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,MAXBYTE-
                      TRGBA         (pt_pix_ccl_arr_ptr^).a);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AlphaBlend1   (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,MAXBYTE-
                      TRGBA         (pt_pix_ccl_arr_ptr^).a);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      AlphaBlend1   (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,MAXBYTE-
                      TRGBA         (pt_pix_ccl_arr_ptr^).a);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTColorB04(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_ccl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=
                                     pt_pix_ccl_arr_ptr^;
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_ccl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=
                                     pt_pix_ccl_arr_ptr^;
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=
                                     pt_pix_ccl_arr_ptr^;
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=
                                     pt_pix_ccl_arr_ptr^;
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTColor004(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTColorA04(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTColorB04(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has transparent alpha channel:
procedure TFastImageProc.RegPTColor006(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegNTColor026(fast_image_data_ptr_,fast_image_data_)
    else
      RegNTColor006(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading):
// same;

{Color of Curent Layer(Additive)}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTColorA10(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          for x:=0 to      pt_pix_cnt_arr_ptr^-1 do
            begin
              AdditiveDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
                           pt_pix_ccl_arr_ptr^,MAXBYTE-
              TRGBA       (pt_pix_ccl_arr_ptr^).a);
              Inc         (pt_pix_sht_arr_ptr);
              Inc         (pt_pix_ccl_arr_ptr);
            end;
          Inc             (pt_pix_cnt_arr_ptr);
          Inc      (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTColorB10(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          for x:=0 to   pt_pix_cnt_arr_ptr^-1 do
            begin
              Additive1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
                        pt_pix_ccl_arr_ptr^);
              Inc      (pt_pix_sht_arr_ptr);
              Inc      (pt_pix_ccl_arr_ptr);
            end;
          Inc          (pt_pix_cnt_arr_ptr);
          Inc   (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.RegPTColor010(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTColorA10(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTColorB10(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTColorA14(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_ccl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,MAXBYTE-
                      TRGBA         (pt_pix_ccl_arr_ptr^).a);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_ccl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,MAXBYTE-
                      TRGBA         (pt_pix_ccl_arr_ptr^).a);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,MAXBYTE-
                      TRGBA         (pt_pix_ccl_arr_ptr^).a);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,MAXBYTE-
                      TRGBA         (pt_pix_ccl_arr_ptr^).a);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTColorB14(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_ccl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Additive1     (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_ccl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Additive1     (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Additive1     (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      Additive1     (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTColor014(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTColorA14(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTColorB14(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RegPTColor016(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegNTColor017(fast_image_data_ptr_,fast_image_data_)
    else
      RegNTColor016(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTColorA11(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          for x:=0 to      pt_pix_cnt_arr_ptr^-1 do
            begin
              AdditiveDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
                           pt_pix_ccl_arr_ptr^,MAXBYTE-Max(
              TRGBA       (pt_pix_ccl_arr_ptr^).a-cfx_pow0_,0));
              Inc         (pt_pix_sht_arr_ptr);
              Inc         (pt_pix_ccl_arr_ptr);
            end;
          Inc             (pt_pix_cnt_arr_ptr);
          Inc      (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTColorB11(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          for x:=0 to      pt_pix_cnt_arr_ptr^-1 do
            begin
              AdditiveDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
                           pt_pix_ccl_arr_ptr^,cfx_pow0_);
              Inc         (pt_pix_sht_arr_ptr);
              Inc         (pt_pix_ccl_arr_ptr);
            end;
          Inc             (pt_pix_cnt_arr_ptr);
          Inc      (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegPTColor011(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTColorA11(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTColorB11(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTColorA15(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_ccl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,MAXBYTE-Max(
                      TRGBA         (pt_pix_ccl_arr_ptr^).a-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_ccl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,MAXBYTE-Max(
                      TRGBA         (pt_pix_ccl_arr_ptr^).a-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,MAXBYTE-Max(
                      TRGBA         (pt_pix_ccl_arr_ptr^).a-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,MAXBYTE-Max(
                      TRGBA         (pt_pix_ccl_arr_ptr^).a-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTColorB15(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_ccl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_ccl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTColor015(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTColorA15(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTColorB15(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) image has monochrome color channel
// same as (constant)

{Color of Curent Layer(Alphablend)}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTColorA20(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
            begin
              AlphaBlendDec2(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
                             pt_pix_ccl_arr_ptr^,cfx_pow0_);
              Inc           (pt_pix_sht_arr_ptr);
              Inc           (pt_pix_ccl_arr_ptr);
            end;
          Inc               (pt_pix_cnt_arr_ptr);
          Inc        (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTColorB20(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          for x:=0 to     pt_pix_cnt_arr_ptr^-1 do
            begin
              AlphaBlend1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
                          pt_pix_ccl_arr_ptr^,cfx_pow0_);
              Inc        (pt_pix_sht_arr_ptr);
              Inc        (pt_pix_ccl_arr_ptr);
            end;
          Inc            (pt_pix_cnt_arr_ptr);
          Inc     (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.RegPTColor020(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTColorA20(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTColorB20(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTColorA24(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_ccl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AlphaBlendDec2(pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_ccl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AlphaBlendDec2(pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AlphaBlendDec2(pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      AlphaBlendDec2(pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTColorB24(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_ccl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AlphaBlend1   (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_ccl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AlphaBlend1   (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AlphaBlend1   (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      AlphaBlend1   (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTColor024(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTColorA24(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTColorB24(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading):
// same;

{$endregion}

{||scl_mul||<1: (SD - Scale Down)} {$region -fold}

{Empty}
procedure TFastImageProc.RSDPTColor009(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Color of Curent Layer}
// (constant) not clipped:
procedure TFastImageProc.RSDPTColorA00(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_cnt_arr_ptr : PWord;
  pt_pix_sht_arr_ptr : PWord;
  pt_pix_ccl_arr_ptr : PInteger;
       bmp_bkgnd_ptr2: PInteger;
   x, y,v1,v2,s0_,s1_: integer;
  px,py,s0,t         : integer;
  skip_pix0,skip_pix1: TPtPos4;
begin
  with fast_image_data_,fip_scale_data_var0 do
    begin
      SclPTResVar0        (fast_image_data_ptr_,fast_image_data_);
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[fast_image_data_ptr_^.pt_pix_arr_row_mrg_top];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[00000000000000000000000000000000000000000000];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr;
      for y:=0 to rct_ent.height-fast_image_data_ptr_^.pt_pix_arr_row_mrg_top-fast_image_data_ptr_^.pt_pix_arr_row_mrg_btm-1 do
        begin
          v2       :=(v3>>16)*bmp_bkgnd_width;
          skip_pix0:=MinSubMax1((v3>>16)<<15,g2,ONE_SHL_15,_scl_mul_y); //(Min2((v3>>16)<<15+ONE_SHL_15,g2+_scl_mul_y)-Max2((v3>>16)<<15,g2));
          py       :=skip_pix0.x;
          t        :=ONE_SHL_15-py;
          if skip_pix0.y then
            for x:=0 to pt_pix_cnt_arr_ptr^-1 do
              begin
                v1                            :=(scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16;
              //g1                            :=_scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left;
                skip_pix1                     :=MinSubMax1(v1<<15,_scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x); //(Min2(v1<<15+ONE_SHL_15,g1+_scl_mul_x)-Max2(v1<<15,g1));
                s0_                           :=(skip_pix1.x*py)>>14;
                                bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+v1+v2;
                    AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,      s0_);
                if (not skip_pix1.y) then
                  begin
                    Inc        (bmp_bkgnd_ptr2);
                    AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,py<<1-s0_);
                  end;
                Inc(pt_pix_sht_arr_ptr);
                Inc(pt_pix_ccl_arr_ptr);
              end
          else
            for x:=0 to pt_pix_cnt_arr_ptr^-1 do
              begin
                v1                        :=(scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16;
              //g1                        :=_scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left;
                px                        :=MinSubMax0(v1<<15,_scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x); //(Min2(v1<<15+ONE_SHL_15,g1+_scl_mul_x)-Max2(v1<<15,g1));
                s0_                       :=(px*py)>>14;
                            bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+v1+v2;
                AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,          s0_);
                Inc        (bmp_bkgnd_ptr2);
                AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,   py <<1-s0_);
                Inc        (bmp_bkgnd_ptr2,bmp_bkgnd_width-1);
                AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,   px <<1-s0_);
                Inc        (bmp_bkgnd_ptr2);
                AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,(t-px)<<1+s0_);
                Inc(pt_pix_sht_arr_ptr);
                Inc(pt_pix_ccl_arr_ptr);
              end;
          Inc      (pt_pix_cnt_arr_ptr);
          Inc(v3, scl_mul_y);
          Inc(g2,_scl_mul_y);
        end;
    end;
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTColorA02(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_cnt_arr_ptr : PWord;
  pt_pix_sht_arr_ptr : PWord;
  pt_pix_ccl_arr_ptr : PInteger;
       bmp_bkgnd_ptr2: PInteger;
   x, y,v1,v2,s0_,s1_: integer;
  px,py,s0,t         : integer;
  skip_pix0,skip_pix1: TPtPos4;
  b0,b1              : boolean;
begin
  with fast_image_data_,fip_scale_data_var0 do
    begin
      RegPTResVar0            (fast_image_data_ptr_,fast_image_data_);
      SclPTResVar0            (fast_image_data_ptr_,fast_image_data_);
      pt_pix_cnt_arr_ptr    :=@fast_image_data_ptr_^.pt_pix_cnt_arr[fast_image_data_ptr_^.pt_pix_arr_row_mrg_top];
      pt_pix_sht_arr_ptr    :=@fast_image_data_ptr_^.pt_pix_sht_arr[00000000000000000000000000000000000000000000];
      pt_pix_ccl_arr_ptr    :=                       pt_pix_arr_ptr;
      dh                    :=rct_src.top-fast_image_data_ptr_^.pt_pix_arr_row_mrg_top;
      if (dh>0) then
        begin
          v3                += scl_mul_y*dh;
          g2                +=_scl_mul_y*dh;
          pt_pix_cnt_arr_ptr+=           dh;
          pt_pix_sht_arr_ptr+=res_var1-fast_image_data_ptr_^.pt_cnt_ind_arr[fast_image_data_ptr_^.pt_pix_arr_row_mrg_top];
          pt_pix_ccl_arr_ptr+=res_var1-fast_image_data_ptr_^.pt_cnt_ind_arr[fast_image_data_ptr_^.pt_pix_arr_row_mrg_top];
        end;
      if (res_var2<0) then
        Exit;
      for y:=0 to res_var2+1 do
        begin
          if (PWord(pt_pix_sht_arr_ptr)-PWord(@fast_image_data_ptr_^.pt_pix_sht_arr[0])>Length(fast_image_data_ptr_^.pt_pix_sht_arr)-1) then
            Exit;
          v2       :=(v3>>16)*bmp_bkgnd_width;
          skip_pix0:=MinSubMax1((v3>>16)<<15,g2,ONE_SHL_15,_scl_mul_y); //(Min2((v3>>16)<<15+ONE_SHL_15,g2+_scl_mul_y)-Max2((v3>>16)<<15,g2));
          py       :=skip_pix0.x;
          t        :=ONE_SHL_15-py;
          if skip_pix0.y then
            begin
              b0:=((v3>>16)>=rct_clp_ptr^.top) and ((v3>>16)<rct_clp_ptr^.bottom);
              if b0 then
                for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                  begin
                    v1                            :=                  (scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16;
                  //g1                            :=                  _scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left;
                    skip_pix1                     :=MinSubMax1(v1<<15,_scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x); //(Min2(v1<<15+ONE_SHL_15,g1+_scl_mul_x)-Max2(v1<<15,g1));
                    s0_                           :=(skip_pix1.x*py)>>14;
                                    bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+v1+v2;
                        AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,      s0_);
                    if (not skip_pix1.y) then
                      begin
                        Inc        (bmp_bkgnd_ptr2);
                        AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,py<<1-s0_);
                      end;
                    Inc(pt_pix_sht_arr_ptr);
                    Inc(pt_pix_ccl_arr_ptr);
                  end
              else
                for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                  begin
                    Inc(pt_pix_sht_arr_ptr);
                    Inc(pt_pix_ccl_arr_ptr);
                  end;
            end
          else
            begin
              b0:=(0+(v3>>16)>=rct_clp_ptr^.top) and (0+(v3>>16)<rct_clp_ptr^.bottom);
              b1:=(1+(v3>>16)>=rct_clp_ptr^.top) and (1+(v3>>16)<rct_clp_ptr^.bottom);
              if b0 then
                begin
                  if b1 then
                    for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                      begin
                        v1                        :=                  (scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16;
                      //g1                        :=                  _scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left;
                        px                        :=MinSubMax0(v1<<15,_scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x); //(Min2(v1<<15+ONE_SHL_15,g1+_scl_mul_x)-Max2(v1<<15,g1));
                        s0_                       :=(px*py)>>14;
                                    bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+v1+v2;
                        AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,          s0_);
                        Inc        (bmp_bkgnd_ptr2);
                        AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,   py <<1-s0_);
                        Inc        (bmp_bkgnd_ptr2,bmp_bkgnd_width-1);
                        AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,   px <<1-s0_);
                        Inc        (bmp_bkgnd_ptr2);
                        AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,(t-px)<<1+s0_);
                        Inc(pt_pix_sht_arr_ptr);
                        Inc(pt_pix_ccl_arr_ptr);
                      end
                  else
                    for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                      begin
                        v1                        :=                  (scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16;
                      //g1                        :=                  _scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left;
                        px                        :=MinSubMax0(v1<<15,_scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x); //(Min2(v1<<15+ONE_SHL_15,g1+_scl_mul_x)-Max2(v1<<15,g1));
                        s0_                       :=(px*py)>>14;
                                    bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+v1+v2;
                        AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,      s0_);
                        Inc        (bmp_bkgnd_ptr2);
                        AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,py<<1-s0_);
                        Inc(pt_pix_sht_arr_ptr);
                        Inc(pt_pix_ccl_arr_ptr);
                      end;
                end
              else
                begin
                  if b1 then
                    for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                      begin
                        v1                        :=                  (scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16;
                      //g1                        :=                  _scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left;
                        px                        :=MinSubMax0(v1<<15,_scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x); //(Min2(v1<<15+ONE_SHL_15,g1+_scl_mul_x)-Max2(v1<<15,g1));
                        s0_                       :=(px*py)>>14;
                                    bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+v1+v2;
                        Inc        (bmp_bkgnd_ptr2, bmp_bkgnd_width);
                        AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,   px <<1-s0_);
                        Inc        (bmp_bkgnd_ptr2);
                        AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,(t-px)<<1+s0_);
                        Inc(pt_pix_sht_arr_ptr);
                        Inc(pt_pix_ccl_arr_ptr);
                      end
                  else
                    for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                      begin
                        Inc(pt_pix_sht_arr_ptr);
                        Inc(pt_pix_ccl_arr_ptr);
                      end;
                end;
            end;
          Inc(pt_pix_cnt_arr_ptr);
          Inc(v3, scl_mul_y);
          Inc(g2,_scl_mul_y);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTColorA04(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_cnt_arr_ptr : PWord;
  pt_pix_sht_arr_ptr : PWord;
  pt_pix_ccl_arr_ptr : PInteger;
       bmp_bkgnd_ptr2: PInteger;
   x, y,v1,v2,s0_,s1_: integer;
  px,py,s0,t         : integer;
  skip_pix0,skip_pix1: TPtPos4;
  b0,b1              : boolean;
  c0,c1              : boolean;
begin
  with fast_image_data_,fip_scale_data_var0 do
    begin
      RegPTResVar0            (fast_image_data_ptr_,fast_image_data_);
      SclPTResVar0            (fast_image_data_ptr_,fast_image_data_);
      pt_pix_cnt_arr_ptr    :=@fast_image_data_ptr_^.pt_pix_cnt_arr[fast_image_data_ptr_^.pt_pix_arr_row_mrg_top];
      pt_pix_sht_arr_ptr    :=@fast_image_data_ptr_^.pt_pix_sht_arr[00000000000000000000000000000000000000000000];
      pt_pix_ccl_arr_ptr    :=                       pt_pix_arr_ptr;
      dh                    :=rct_src.top-fast_image_data_ptr_^.pt_pix_arr_row_mrg_top;
      if (dh>0) then
        begin
          v3                += scl_mul_y*dh;
          g2                +=_scl_mul_y*dh;
          pt_pix_cnt_arr_ptr+=           dh;
          pt_pix_sht_arr_ptr+=res_var1-fast_image_data_ptr_^.pt_cnt_ind_arr[fast_image_data_ptr_^.pt_pix_arr_row_mrg_top];
          pt_pix_ccl_arr_ptr+=res_var1-fast_image_data_ptr_^.pt_cnt_ind_arr[fast_image_data_ptr_^.pt_pix_arr_row_mrg_top];
        end;
      if (res_var2<0) then
        Exit;
      for y:=0 to res_var2+1 do
        begin
          if (PWord(pt_pix_sht_arr_ptr)-PWord(@fast_image_data_ptr_^.pt_pix_sht_arr[0])>Length(fast_image_data_ptr_^.pt_pix_sht_arr)-1) then
            Exit;
          v2       :=(v3>>16)*bmp_bkgnd_width;
          skip_pix0:=MinSubMax1((v3>>16)<<15,g2,ONE_SHL_15,_scl_mul_y); //(Min2((v3>>16)<<15+ONE_SHL_15,g2+_scl_mul_y)-Max2((v3>>16)<<15,g2));
          py       :=skip_pix0.x;
          t        :=ONE_SHL_15-py;
          if skip_pix0.y then
            begin
              b0:=((v3>>16)>=rct_clp_ptr^.top) and ((v3>>16)<rct_clp_ptr^.bottom);
              if b0 then
                for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                  begin
                    v1                              :=                  (scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16;
                  //g1                              :=                  _scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left;
                    skip_pix1                       :=MinSubMax1(v1<<15,_scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x); //(Min2(v1<<15+ONE_SHL_15,g1+_scl_mul_x)-Max2(v1<<15,g1));
                    s0_                             :=(skip_pix1.x*py)>>14;
                                      bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+v1+v2;
                      if (v1+0>=rct_clp_ptr^.left) and (v1+0<rct_clp_ptr^.right) then
                          AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,      s0_);
                    if (not skip_pix1.y) then
                      if (v1+1>=rct_clp_ptr^.left) and (v1+1<rct_clp_ptr^.right) then
                        begin
                          Inc        (bmp_bkgnd_ptr2);
                          AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,py<<1-s0_);
                        end;
                    Inc(pt_pix_sht_arr_ptr);
                    Inc(pt_pix_ccl_arr_ptr);
                  end
              else
                for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                  begin
                    Inc(pt_pix_sht_arr_ptr);
                    Inc(pt_pix_ccl_arr_ptr);
                  end;
            end
          else
            begin
              b0:=(0+(v3>>16)>=rct_clp_ptr^.top) and (0+(v3>>16)<rct_clp_ptr^.bottom);
              b1:=(1+(v3>>16)>=rct_clp_ptr^.top) and (1+(v3>>16)<rct_clp_ptr^.bottom);
              if b0 then
                begin
                  if b1 then
                    for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                      begin
                        v1                            :=                  (scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16;
                      //g1                            :=                  _scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left;
                        px                            :=MinSubMax0(v1<<15,_scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x); //(Min2(v1<<15+ONE_SHL_15,g1+_scl_mul_x)-Max2(v1<<15,g1));
                        s0_                           :=(px*py)>>14;
                        c0                            :=(v1+0>=rct_clp_ptr^.left) and (v1+0<rct_clp_ptr^.right);
                        c1                            :=(v1+1>=rct_clp_ptr^.left) and (v1+1<rct_clp_ptr^.right);
                        if c0 then
                          begin
                                        bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+v1+v2;
                            AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,          s0_);
                            Inc        (bmp_bkgnd_ptr2,bmp_bkgnd_width);
                            AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,   px <<1-s0_);
                          end;
                        if c1 then
                          begin
                                        bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+v1+v2+1;
                            AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,   py <<1-s0_);
                            Inc        (bmp_bkgnd_ptr2,bmp_bkgnd_width);
                            AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,(t-px)<<1+s0_);
                          end;
                        Inc(pt_pix_sht_arr_ptr);
                        Inc(pt_pix_ccl_arr_ptr);
                      end
                  else
                    for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                      begin
                        v1                            :=                  (scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16;
                      //g1                            :=                  _scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left;
                        px                            :=MinSubMax0(v1<<15,_scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x); //(Min2(v1<<15+ONE_SHL_15,g1+_scl_mul_x)-Max2(v1<<15,g1));
                        s0_                           :=(px*py)>>14;
                                        bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+v1+v2;
                        if (v1+0>=rct_clp_ptr^.left) and (v1+0<rct_clp_ptr^.right) then
                            AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,      s0_);
                        if (v1+1>=rct_clp_ptr^.left) and (v1+1<rct_clp_ptr^.right) then
                          begin
                            Inc        (bmp_bkgnd_ptr2);
                            AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,py<<1-s0_);
                          end;
                        Inc(pt_pix_sht_arr_ptr);
                        Inc(pt_pix_ccl_arr_ptr);
                      end;
                end
              else
                begin
                  if b1 then
                    for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                      begin
                        v1                            :=                  (scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16;
                      //g1                            :=                  _scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left;
                        px                            :=MinSubMax0(v1<<15,_scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x); //(Min2(v1<<15+ONE_SHL_15,g1+_scl_mul_x)-Max2(v1<<15,g1));
                        s0_                           :=(px*py)>>14;
                        if (v1+0>=rct_clp_ptr^.left) and (v1+0<rct_clp_ptr^.right) then
                          begin
                                        bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+v1+v2+bmp_bkgnd_width;
                            AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,   px <<1-s0_);
                          end;
                        if (v1+1>=rct_clp_ptr^.left) and (v1+1<rct_clp_ptr^.right) then
                          begin
                                        bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+v1+v2+bmp_bkgnd_width+1;
                            AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,(t-px)<<1+s0_);
                          end;
                        Inc(pt_pix_sht_arr_ptr);
                        Inc(pt_pix_ccl_arr_ptr);
                      end
                  else
                    for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                      begin
                        Inc(pt_pix_sht_arr_ptr);
                        Inc(pt_pix_ccl_arr_ptr);
                      end;
                end;
            end;
          Inc(pt_pix_cnt_arr_ptr);
          Inc(v3, scl_mul_y);
          Inc(g2,_scl_mul_y);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome alpha channel:
procedure TFastImageProc.RSDPTColorA06(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

// (constant) not clipped:
procedure TFastImageProc.RSDPTColorA10(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_cnt_arr_ptr : PWord;
  pt_pix_sht_arr_ptr : PWord;
  pt_pix_ccl_arr_ptr : PInteger;
       bmp_bkgnd_ptr2: PInteger;
  pix_area           : TPtPosF;
  scl_mul_           : TPtPosF;
  d0,d1,d2,d3,d2_    : double;
  x,y,h0,h1          : integer;
  b0                 : boolean;
  //pow                : byte;
begin
  with fast_image_data_,fip_scale_data_var1 do
    begin
      SclPTResVar1        (fast_image_data_ptr_,fast_image_data_);
      RegPTResVar1        (fast_image_data_ptr_,fast_image_data_);
      RegPTResVar3        (fast_image_data_ptr_,fast_image_data_);
      if (res_var2<=0) then
        Exit;
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      d2_               :=scl_mul.y*ONE_SHL_16;
      scl_mul_          :=PtPosF(res_var8*scl_mul.x,res_var3*scl_mul.y);
      for y:=0 to res_var2 do
        begin
          d1        :=scl_mul_.y*(res_var0+y);
          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1        *=bmp_bkgnd_width;
          if (pix_area.y<scl_mul.y) then
            begin
              d2:=           pix_area.y *ONE_SHL_16;
              d3:=(scl_mul.y-pix_area.y)*ONE_SHL_16;
              for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                begin

                  //if PRGBA(pt_pix_ccl_arr_ptr)^.a>=128 then
                    //begin

                  //pow                                             :={Min(PRGBA(pt_pix_ccl_arr_ptr)^.a,}Trunc(PRGBA(pt_pix_ccl_arr_ptr)^.a*(1{1-}{sqr(scl_mul.x)})){)};
                  d0                                              :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                  h0                                              :=Trunc  (d0+m0);
                    pix_area.x                                    :=(h0+1)-(d0+m0);
                  b0                                              :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                                    :=scl_mul.x;
                                                    bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  {$ifdef win64}
                    ScalePix128D(MSK2_128,MSK3_128,(bmp_bkgnd_ptr2+0)^,pt_pix_ccl_arr_ptr^,Trunc(           pix_area.x *d2),Trunc(           pix_area.x *d3),{pow}PRGBA(pt_pix_ccl_arr_ptr)^.a,bmp_bkgnd_width);
                  if b0 then
                    ScalePix128D(MSK2_128,MSK3_128,(bmp_bkgnd_ptr2+1)^,pt_pix_ccl_arr_ptr^,Trunc((scl_mul.x-pix_area.x)*d2),Trunc((scl_mul.x-pix_area.x)*d3),{pow}PRGBA(pt_pix_ccl_arr_ptr)^.a,bmp_bkgnd_width);
                  {$else}
                    AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc(           pix_area.x *d2));
                  Inc          (bmp_bkgnd_ptr2);
                  if b0 then
                    AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc((scl_mul.x-pix_area.x)*d2));
                  Inc          (bmp_bkgnd_ptr2,bmp_bkgnd_width-1);
                    AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc(           pix_area.x *d3));
                  Inc          (bmp_bkgnd_ptr2);
                  if b0 then
                    AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc((scl_mul.x-pix_area.x)*d3));
                  {$endif}

                    //end;

                  Inc(pt_pix_sht_arr_ptr);
                  Inc(pt_pix_ccl_arr_ptr);
                end;
            end
          else
            begin
              //d2:=scl_mul.y*ONE_SHL_16;
              for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                begin

                  //if PRGBA(pt_pix_ccl_arr_ptr)^.a>=128 then
                    //begin

                  //pow                                          :={Min(PRGBA(pt_pix_ccl_arr_ptr)^.a,}Trunc(PRGBA(pt_pix_ccl_arr_ptr)^.a*(1{1-}{sqr(scl_mul.x)})){)};
                  d0                                           :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                  h0                                           :=Trunc  (d0+m0);
                    pix_area.x                                 :=(h0+1)-(d0+m0);
                  b0                                           :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                                 :=scl_mul.x;
                                                 bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  {$ifdef win64}
                  ScalePix128C(MSK2_128,MSK3_128,bmp_bkgnd_ptr2^,pt_pix_ccl_arr_ptr^,Trunc(pix_area.x*d2_),Trunc((scl_mul.x-pix_area.x)*d2_),{pow}PRGBA(pt_pix_ccl_arr_ptr)^.a,b0);
                  {$else}
                    AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc(           pix_area.x *d2_));
                  Inc          (bmp_bkgnd_ptr2);
                  if b0 then
                    AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc((scl_mul.x-pix_area.x)*d2_));
                  {$endif}

                    //end;

                  Inc(pt_pix_sht_arr_ptr);
                  Inc(pt_pix_ccl_arr_ptr);
                end;
            end;
          Inc        (pt_pix_cnt_arr_ptr);
        end;
    end;
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTColorA12(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_cnt_arr_ptr : PWord;
  pt_pix_sht_arr_ptr : PWord;
  pt_pix_ccl_arr_ptr : PInteger;
       bmp_bkgnd_ptr2: PInteger;
  pix_area           : TPtPosF;
  scl_mul_           : TPtPosF;
  d0,d1,d2,d3,d2_    : double;
  x,y,h0,h1,h1_      : integer;
  b0,p0,p1           : boolean;
begin
  with fast_image_data_,fip_scale_data_var1 do
    begin
      SclPTResVar1        (fast_image_data_ptr_,fast_image_data_);
      RegPTResVar2        (fast_image_data_ptr_,fast_image_data_);
      RegPTResVar3        (fast_image_data_ptr_,fast_image_data_);
      if (res_var2<=0) then
        Exit;
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      d2_               :=scl_mul.y*ONE_SHL_16;
      scl_mul_          :=PtPosF(res_var8*scl_mul.x,res_var3*scl_mul.y);

      {top border---} {$region -fold}
        begin
          d1        :=scl_mul_.y*(res_var0+0);
          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1_       := h1;
          h1        *=bmp_bkgnd_width;
          p0        :=(h1_+0>=rct_clp_ptr^.top   ) and
                      (h1_+0< rct_clp_ptr^.bottom);
          p1        :=(h1_+1>=rct_clp_ptr^.top   ) and
                      (h1_+1< rct_clp_ptr^.bottom);
          if (pix_area.y<scl_mul.y) then
            begin
              d2:=           pix_area.y *ONE_SHL_16;
              d3:=(scl_mul.y-pix_area.y)*ONE_SHL_16;
              for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                begin
                  d0                                              :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                  h0                                              :=Trunc  (d0+m0);
                    pix_area.x                                    :=(h0+1)-(d0+m0);
                  b0                                              :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                                    :=scl_mul.x;
                                                    bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  {$ifdef win64}
                  if p0 then
                    ScalePix128C(MSK2_128,MSK3_128,(bmp_bkgnd_ptr2+000000000000000)^,pt_pix_ccl_arr_ptr^,Trunc(pix_area.x*d2),Trunc((scl_mul.x-pix_area.x)*d2),PRGBA(pt_pix_ccl_arr_ptr)^.a,b0);
                  if p1 then
                    ScalePix128C(MSK2_128,MSK3_128,(bmp_bkgnd_ptr2+bmp_bkgnd_width)^,pt_pix_ccl_arr_ptr^,Trunc(pix_area.x*d2),Trunc((scl_mul.x-pix_area.x)*d2),PRGBA(pt_pix_ccl_arr_ptr)^.a,b0);
                  {$else}
                  if p0 then
                    begin
                        AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc(           pix_area.x *d2));
                      Inc          (bmp_bkgnd_ptr2);
                      if b0 then
                        AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc((scl_mul.x-pix_area.x)*d2));
                    end;
                  Inc          (bmp_bkgnd_ptr2,bmp_bkgnd_width-1);
                  if p1 then
                    begin
                        AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc(           pix_area.x *d3));
                      Inc          (bmp_bkgnd_ptr2);
                      if b0 then
                        AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc((scl_mul.x-pix_area.x)*d3));
                    end;
                  {$endif}
                  Inc(pt_pix_sht_arr_ptr);
                  Inc(pt_pix_ccl_arr_ptr);
                end;
            end
          else
            begin
              //d2:=scl_mul.y*ONE_SHL_16;
              for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                begin
                  d0                                             :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                  h0                                             :=Trunc  (d0+m0);
                    pix_area.x                                   :=(h0+1)-(d0+m0);
                  b0                                             :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                                   :=scl_mul.x;
                                                   bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  {$ifdef win64}
                  if p0 then
                    ScalePix128C(MSK2_128,MSK3_128,bmp_bkgnd_ptr2^,pt_pix_ccl_arr_ptr^,Trunc(pix_area.x*d2_),Trunc((scl_mul.x-pix_area.x)*d2_),PRGBA(pt_pix_ccl_arr_ptr)^.a,b0);
                  {$else}
                  if p0 then
                    begin
                        AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc(           pix_area.x *d2_));
                      Inc          (bmp_bkgnd_ptr2);
                      if b0 then
                        AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc((scl_mul.x-pix_area.x)*d2_));
                    end;
                  {$endif}
                  Inc(pt_pix_sht_arr_ptr);
                  Inc(pt_pix_ccl_arr_ptr);
                end;
            end;
          Inc        (pt_pix_cnt_arr_ptr);
        end; {$endregion}

      {main loop----} {$region -fold}
      if (res_var2>1) then
      for y:=1 to res_var2-1 do
        begin
          d1        :=scl_mul_.y*(res_var0+y);
          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1        *=bmp_bkgnd_width;
          if (pix_area.y<scl_mul.y) then
            begin
              d2:=           pix_area.y *ONE_SHL_16;
              d3:=(scl_mul.y-pix_area.y)*ONE_SHL_16;
              for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                begin
                  d0                                              :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                  h0                                              :=Trunc  (d0+m0);
                    pix_area.x                                    :=(h0+1)-(d0+m0);
                  b0                                              :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                                    :=scl_mul.x;
                                                    bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  {$ifdef win64}
                    ScalePix128D(MSK2_128,MSK3_128,(bmp_bkgnd_ptr2+0)^,pt_pix_ccl_arr_ptr^,Trunc(           pix_area.x *d2),Trunc(           pix_area.x *d3),PRGBA(pt_pix_ccl_arr_ptr)^.a,bmp_bkgnd_width);
                  if b0 then
                    ScalePix128D(MSK2_128,MSK3_128,(bmp_bkgnd_ptr2+1)^,pt_pix_ccl_arr_ptr^,Trunc((scl_mul.x-pix_area.x)*d2),Trunc((scl_mul.x-pix_area.x)*d3),PRGBA(pt_pix_ccl_arr_ptr)^.a,bmp_bkgnd_width);
                  {$else}
                    AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc(           pix_area.x *d2));
                  Inc          (bmp_bkgnd_ptr2);
                  if b0 then
                    AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc((scl_mul.x-pix_area.x)*d2));
                  Inc          (bmp_bkgnd_ptr2,bmp_bkgnd_width-1);
                    AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc(           pix_area.x *d3));
                  Inc          (bmp_bkgnd_ptr2);
                  if b0 then
                    AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc((scl_mul.x-pix_area.x)*d3));
                  {$endif}
                  Inc(pt_pix_sht_arr_ptr);
                  Inc(pt_pix_ccl_arr_ptr);
                end;
            end
          else
            begin
              //d2:=scl_mul.y*ONE_SHL_16;
              for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                begin
                  d0            :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                  h0            :=Trunc  (d0+m0);
                    pix_area.x  :=(h0+1)-(d0+m0);
                  b0            :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x  :=scl_mul.x;
                  bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  {$ifdef win64}
                  ScalePix128C(MSK2_128,MSK3_128,bmp_bkgnd_ptr2^,pt_pix_ccl_arr_ptr^,Trunc(pix_area.x*d2_),Trunc((scl_mul.x-pix_area.x)*d2_),PRGBA(pt_pix_ccl_arr_ptr)^.a,b0);
                  {$else}
                    AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc(           pix_area.x *d2_));
                  Inc          (bmp_bkgnd_ptr2);
                  if b0 then
                    AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc((scl_mul.x-pix_area.x)*d2_));
                  {$endif}
                  Inc(pt_pix_sht_arr_ptr);
                  Inc(pt_pix_ccl_arr_ptr);
                end;
            end;
          Inc        (pt_pix_cnt_arr_ptr);
        end; {$endregion}

      {bottom border} {$region -fold}

      {
      if (res_var2>0{1}) then
        begin
          d1        :=scl_mul_.y*(res_var0+res_var2);
          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1_       := h1;
          h1        *=bmp_bkgnd_width;
          p0        :=(h1_+0>=rct_clp_ptr^.top   ) and
                      (h1_+0< rct_clp_ptr^.bottom);
          if p0 then
            for x:=0 to pt_pix_cnt_arr_ptr^-1 do
              begin
                if (PDWord(                       pt_pix_ccl_arr_ptr)-
                    PDWord(@fast_image_data_ptr_^.pt_pix_ccl_arr[0])>
                    Length( fast_image_data_ptr_^.pt_pix_ccl_arr)-1) then
                  Exit;
                d0                                           :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                h0                                           :=Trunc  (d0+m0);
                  pix_area.x                                   :=(h0+1)-(d0+m0);
                b0                                           :=(pix_area.x<scl_mul.x);
                if (not b0) then
                  pix_area.x                                 :=scl_mul.x;
                                               bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                {$ifdef win64}
                ScalePix128C(MSK2_128,MSK3_128,bmp_bkgnd_ptr2^,pt_pix_ccl_arr_ptr^,Trunc(pix_area.x*d2_),Trunc((scl_mul.x-pix_area.x)*d2_),PRGBA(pt_pix_ccl_arr_ptr)^.a,b0);
                {$else}
                  AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc(           pix_area.x *d2_));
                Inc          (bmp_bkgnd_ptr2);
                if b0 then
                  AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc((scl_mul.x-pix_area.x)*d2_));
                {$endif}
                Inc(pt_pix_sht_arr_ptr);
                Inc(pt_pix_ccl_arr_ptr);
              end;
        end;
        }

      if (res_var2>0) and
         (PWord (                       pt_pix_cnt_arr_ptr)-
          PWord (@fast_image_data_ptr_^.pt_pix_cnt_arr[0])<
          Length( fast_image_data_ptr_^.pt_pix_cnt_arr)) then
        begin
          d1        :=scl_mul_.y*(res_var0+res_var2);
          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1_       := h1;
          h1        *=bmp_bkgnd_width;
          p0        :=(h1_+0>=rct_clp_ptr^.top   ) and
                      (h1_+0< rct_clp_ptr^.bottom);
          p1        :=(h1_+1>=rct_clp_ptr^.top   ) and
                      (h1_+1< rct_clp_ptr^.bottom);
          if (pix_area.y<scl_mul.y) then
            begin
              d2:=           pix_area.y *ONE_SHL_16;
              d3:=(scl_mul.y-pix_area.y)*ONE_SHL_16;
              for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                begin
                  d0                                              :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                  h0                                              :=Trunc  (d0+m0);
                    pix_area.x                                    :=(h0+1)-(d0+m0);
                  b0                                              :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                                    :=scl_mul.x;
                                                    bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  {$ifdef win64}
                  if p0 then
                    ScalePix128C(MSK2_128,MSK3_128,(bmp_bkgnd_ptr2+000000000000000)^,pt_pix_ccl_arr_ptr^,Trunc(pix_area.x*d2),Trunc((scl_mul.x-pix_area.x)*d2),PRGBA(pt_pix_ccl_arr_ptr)^.a,b0);
                  if p1 then
                    ScalePix128C(MSK2_128,MSK3_128,(bmp_bkgnd_ptr2+bmp_bkgnd_width)^,pt_pix_ccl_arr_ptr^,Trunc(pix_area.x*d2),Trunc((scl_mul.x-pix_area.x)*d2),PRGBA(pt_pix_ccl_arr_ptr)^.a,b0);
                  {$else}
                  if p0 then
                    begin
                        AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc(           pix_area.x *d2));
                      Inc          (bmp_bkgnd_ptr2);
                      if b0 then
                        AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc((scl_mul.x-pix_area.x)*d2));
                    end;
                  Inc          (bmp_bkgnd_ptr2,bmp_bkgnd_width-1);
                  if p1 then
                    begin
                        AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc(           pix_area.x *d3));
                      Inc          (bmp_bkgnd_ptr2);
                      if b0 then
                        AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc((scl_mul.x-pix_area.x)*d3));
                    end;
                  {$endif}
                  Inc(pt_pix_sht_arr_ptr);
                  Inc(pt_pix_ccl_arr_ptr);
                end;
            end
          else
            begin
              //d2:=scl_mul.y*ONE_SHL_16;
              for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                begin
                  d0                                             :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                  h0                                             :=Trunc  (d0+m0);
                    pix_area.x                                   :=(h0+1)-(d0+m0);
                  b0                                             :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                                   :=scl_mul.x;
                                                   bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  {$ifdef win64}
                  if p0 then
                    ScalePix128C(MSK2_128,MSK3_128,bmp_bkgnd_ptr2^,pt_pix_ccl_arr_ptr^,Trunc(pix_area.x*d2_),Trunc((scl_mul.x-pix_area.x)*d2_),PRGBA(pt_pix_ccl_arr_ptr)^.a,b0);
                  {$else}
                  if p0 then
                    begin
                        AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc(           pix_area.x *d2_));
                      Inc          (bmp_bkgnd_ptr2);
                      if b0 then
                        AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,PRGBA(pt_pix_ccl_arr_ptr)^.a,Trunc((scl_mul.x-pix_area.x)*d2_));
                    end;
                  {$endif}
                  Inc(pt_pix_sht_arr_ptr);
                  Inc(pt_pix_ccl_arr_ptr);
                end;
            end;
        end; {$endregion}

    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTColorA14(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome alpha channel:
procedure TFastImageProc.RSDPTColorA16(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

// (constant) not clipped:
procedure TFastImageProc.RSDPTColor000(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_cnt_arr_ptr : PWord;
  pt_pix_sht_arr_ptr : PWord;
  pt_pix_ccl_arr_ptr : PInteger;
       bmp_bkgnd_ptr2: PInteger;
  pix_area           : TPtPosF;
  scl_mul_           : TPtPosF;
  d0,d1,d2,d3,d4,d2_ : double;
  x,y,h0,h1,d4_      : integer;
  b0                 : boolean;
  pow                : byte;
begin
  with fast_image_data_,fip_scale_data_var1 do
    begin
      SclPTResVar1        (fast_image_data_ptr_,fast_image_data_);
      RegPTResVar1        (fast_image_data_ptr_,fast_image_data_);
      RegPTResVar3        (fast_image_data_ptr_,fast_image_data_);
      if (res_var2<=0) then
        Exit;
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      d4                :=sqrt((scl_mul.x*scl_mul.y)/2);
      d4_               :=FloatToFixed(d4);
      d2_               :=scl_mul.y*Length(sqrt_arr1);
      scl_mul_          :=PtPosF(res_var8*scl_mul.x,res_var3*scl_mul.y);

      {main loop-----} {$region -fold}
      for y:=0 to res_var2-1 do
        begin
          d1        :=scl_mul_.y*(res_var0+y);
          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1        *=bmp_bkgnd_width;
          if (pix_area.y<scl_mul.y) then
            begin
              d2:=(          pix_area.y)*Length(sqrt_arr1);
              d3:=(scl_mul.y-pix_area.y)*Length(sqrt_arr1);
              for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                begin
                  pow                                             :=(d4_*PRGBA(pt_pix_ccl_arr_ptr)^.a)>>16{Trunc(d4*PRGBA(pt_pix_ccl_arr_ptr)^.a)};
                  d0                                              :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                  h0                                              :=Trunc  (d0+m0);
                    pix_area.x                                    :=(h0+1)-(d0+m0);
                  b0                                              :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                                    :=scl_mul.x;
                                                    bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                    ScalePix128D(MSK2_128,MSK3_128,(bmp_bkgnd_ptr2+0)^,pt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc((          pix_area.x)*d2)],sqrt_arr1[Trunc((          pix_area.x)*d3)],pow,bmp_bkgnd_width);
                  if b0 then
                    ScalePix128D(MSK2_128,MSK3_128,(bmp_bkgnd_ptr2+1)^,pt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)],pow,bmp_bkgnd_width);
                  Inc(pt_pix_sht_arr_ptr);
                  Inc(pt_pix_ccl_arr_ptr);
                end;
            end
          else
            begin
              //d2:=scl_mul.y*Length(sqrt_arr1);
              for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                begin
                  pow                                          :=(d4_*PRGBA(pt_pix_ccl_arr_ptr)^.a)>>16{Trunc(d4*PRGBA(pt_pix_ccl_arr_ptr)^.a)};
                  d0                                           :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                  h0                                           :=Trunc  (d0+m0);
                    pix_area.x                                 :=(h0+1)-(d0+m0);
                  b0                                           :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                                 :=scl_mul.x;
                                                 bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  ScalePix128C(MSK2_128,MSK3_128,bmp_bkgnd_ptr2^,pt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d2_)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)],pow,b0);
                  Inc(pt_pix_sht_arr_ptr);
                  Inc(pt_pix_ccl_arr_ptr);
                end;
            end;
          Inc        (pt_pix_cnt_arr_ptr);
        end; {$endregion}

      {last pixel row} {$region -fold}
      if (PWord (                       pt_pix_cnt_arr_ptr)-
          PWord (@fast_image_data_ptr_^.pt_pix_cnt_arr[0])<
          Length( fast_image_data_ptr_^.pt_pix_cnt_arr)) then
        begin
          d1        :=scl_mul_.y*(res_var0+res_var2);
          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1        *=bmp_bkgnd_width;
          if (pix_area.y<scl_mul.y) then
            begin
              d2:=(          pix_area.y)*Length(sqrt_arr1);
              d3:=(scl_mul.y-pix_area.y)*Length(sqrt_arr1);
              for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                begin
                  pow                                             :=(d4_*PRGBA(pt_pix_ccl_arr_ptr)^.a)>>16{Trunc(d4*PRGBA(pt_pix_ccl_arr_ptr)^.a)};
                  d0                                              :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                  h0                                              :=Trunc  (d0+m0);
                    pix_area.x                                    :=(h0+1)-(d0+m0);
                  b0                                              :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                                    :=scl_mul.x;
                                                    bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                    ScalePix128D(MSK2_128,MSK3_128,(bmp_bkgnd_ptr2+0)^,pt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc((          pix_area.x)*d2)],sqrt_arr1[Trunc((          pix_area.x)*d3)],pow,bmp_bkgnd_width);
                  if b0 then
                    ScalePix128D(MSK2_128,MSK3_128,(bmp_bkgnd_ptr2+1)^,pt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)],pow,bmp_bkgnd_width);
                  Inc(pt_pix_sht_arr_ptr);
                  Inc(pt_pix_ccl_arr_ptr);
                end;
            end
          else
            begin
              //d2:=scl_mul.y*Length(sqrt_arr1);
              for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                begin
                  pow                                          :=(d4_*PRGBA(pt_pix_ccl_arr_ptr)^.a)>>16{Trunc(d4*PRGBA(pt_pix_ccl_arr_ptr)^.a)};
                  d0                                           :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                  h0                                           :=Trunc  (d0+m0);
                    pix_area.x                                 :=(h0+1)-(d0+m0);
                  b0                                           :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                                 :=scl_mul.x;
                                                 bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  ScalePix128C(MSK2_128,MSK3_128,bmp_bkgnd_ptr2^,pt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d2_)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)],pow,b0);
                  Inc(pt_pix_sht_arr_ptr);
                  Inc(pt_pix_ccl_arr_ptr);
                end;
            end;
          Inc        (pt_pix_cnt_arr_ptr);
        end; {$endregion}

    end;
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTColor002(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_cnt_arr_ptr : PWord;
  pt_pix_sht_arr_ptr : PWord;
  pt_pix_ccl_arr_ptr : PInteger;
       bmp_bkgnd_ptr2: PInteger;
  pix_area           : TPtPosF;
  scl_mul_           : TPtPosF;
  d0,d1,d2,d3,d4,d2_ : double;
  x,y,h0,h1,h1_,d4_  : integer;
  check_exit         : boolean=False;
  b0,p0,p1           : boolean;
  pow                : byte;
label
  l1;
begin
  with fast_image_data_,fip_scale_data_var1 do
    begin
      SclPTResVar1        (fast_image_data_ptr_,fast_image_data_);
      RegPTResVar2        (fast_image_data_ptr_,fast_image_data_);
      RegPTResVar3        (fast_image_data_ptr_,fast_image_data_);
      if (res_var2<=0) then
        Exit;
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      d4                :=sqrt((scl_mul.x*scl_mul.y)/2);
      d4_               :=FloatToFixed(d4);
      d2_               :=scl_mul.y*Length(sqrt_arr1);
      scl_mul_          :=PtPosF(res_var8*scl_mul.x,res_var3*scl_mul.y);

      {top border---} {$region -fold}
        begin
          d1        :=scl_mul_.y*(res_var0+0);

          l1:

          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1_       := h1;
          h1        *=bmp_bkgnd_width;
          p0        :=(h1_+0>=rct_clp_ptr^.top   ) and
                      (h1_+0< rct_clp_ptr^.bottom);
          p1        :=(h1_+1>=rct_clp_ptr^.top   ) and
                      (h1_+1< rct_clp_ptr^.bottom);
          if (pix_area.y<scl_mul.y) then
            begin
              d2:=(          pix_area.y)*Length(sqrt_arr1);
              d3:=(scl_mul.y-pix_area.y)*Length(sqrt_arr1);
              for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                begin
                  pow                                             :=(d4_*PRGBA(pt_pix_ccl_arr_ptr)^.a)>>16;
                  d0                                              :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                  h0                                              :=Trunc  (d0+m0);
                    pix_area.x                                    :=(h0+1)-(d0+m0);
                  b0                                              :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                                    :=scl_mul.x;
                                                    bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  if p0 then
                    ScalePix128C(MSK2_128,MSK3_128,(bmp_bkgnd_ptr2+000000000000000)^,pt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d2)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)],pow,b0);
                  if p1 then
                    ScalePix128C(MSK2_128,MSK3_128,(bmp_bkgnd_ptr2+bmp_bkgnd_width)^,pt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d3)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)],pow,b0);
                  Inc(pt_pix_sht_arr_ptr);
                  Inc(pt_pix_ccl_arr_ptr);
                end;
            end
          else
            begin
              //d2:=scl_mul.y*Length(sqrt_arr1);
              for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                begin
                  pow                                            :=(d4_*PRGBA(pt_pix_ccl_arr_ptr)^.a)>>16;
                  d0                                             :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                  h0                                             :=Trunc  (d0+m0);
                    pix_area.x                                   :=(h0+1)-(d0+m0);
                  b0                                             :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                                   :=scl_mul.x;
                                                   bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  if p0 then
                    ScalePix128C(MSK2_128,MSK3_128,bmp_bkgnd_ptr2^,pt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d2_)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)],pow,b0);
                  Inc(pt_pix_sht_arr_ptr);
                  Inc(pt_pix_ccl_arr_ptr);
                end;
            end;
          Inc        (pt_pix_cnt_arr_ptr);

          if check_exit then
            Exit;

        end; {$endregion}

      {main loop----} {$region -fold}
      if (res_var2>1) then
      for y:=1 to res_var2-1 do
        begin
          d1        :=scl_mul_.y*(res_var0+y);
          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1        *=bmp_bkgnd_width;
          if (pix_area.y<scl_mul.y) then
            begin
              d2:=(          pix_area.y)*Length(sqrt_arr1);
              d3:=(scl_mul.y-pix_area.y)*Length(sqrt_arr1);
              for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                begin
                  pow                                             :=(d4_*PRGBA(pt_pix_ccl_arr_ptr)^.a)>>16;
                  d0                                              :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                  h0                                              :=Trunc  (d0+m0);
                    pix_area.x                                    :=(h0+1)-(d0+m0);
                  b0                                              :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                                    :=scl_mul.x;
                                                    bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                    ScalePix128D(MSK2_128,MSK3_128,(bmp_bkgnd_ptr2+0)^,pt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc((          pix_area.x)*d2)],sqrt_arr1[Trunc((          pix_area.x)*d3)],pow,bmp_bkgnd_width);
                  if b0 then
                    ScalePix128D(MSK2_128,MSK3_128,(bmp_bkgnd_ptr2+1)^,pt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)],pow,bmp_bkgnd_width);
                  Inc(pt_pix_sht_arr_ptr);
                  Inc(pt_pix_ccl_arr_ptr);
                end;
            end
          else
            begin
              //d2:=scl_mul.y*Length(sqrt_arr1);
              for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                begin
                  pow                                          :=(d4_*PRGBA(pt_pix_ccl_arr_ptr)^.a)>>16;
                  d0                                           :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                  h0                                           :=Trunc  (d0+m0);
                    pix_area.x                                 :=(h0+1)-(d0+m0);
                  b0                                           :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x                                 :=scl_mul.x;
                                                 bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;
                  ScalePix128C(MSK2_128,MSK3_128,bmp_bkgnd_ptr2^,pt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d2_)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)],pow,b0);
                  Inc(pt_pix_sht_arr_ptr);
                  Inc(pt_pix_ccl_arr_ptr);
                end;
            end;
          Inc        (pt_pix_cnt_arr_ptr);
        end; {$endregion}

      {bottom border} {$region -fold}
      if (res_var2>0) and
         (PWord (                       pt_pix_cnt_arr_ptr)-
          PWord (@fast_image_data_ptr_^.pt_pix_cnt_arr[0])<
          Length( fast_image_data_ptr_^.pt_pix_cnt_arr)) then
        begin
          d1        :=scl_mul_.y*(res_var0+res_var2);
          check_exit:=True;
          goto l1;
        end; {$endregion}

    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTColor004(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_sht_pix_ptr : PWord;
  pt_pix_cnt_arr_ptr : PWord;
  pt_pix_sht_arr_ptr : PWord;
  pt_pix_ccl_arr_ptr : PInteger;
       bmp_bkgnd_ptr2: PInteger;
  pix_area           : TPtPosF;
  scl_mul_           : TPtPosF;
  pix_cnt_inc        : word;
  d0,d1,d2,d3,d4,d2_ : double;
  x,y,h0,h1,h1_,d4_  : integer;
  b0,p0,p1           : boolean;
  check_exit         : boolean=False;
  continue_          : boolean=False;
  c1,c2              : integer;
  pow                : byte;
label
  l0,l10,l11,l12,l20,l21,l22;
begin
  with fast_image_data_,fip_scale_data_var1 do
    begin
      SclPTResVar1        (fast_image_data_ptr_,fast_image_data_);
      RegPTResVar2        (fast_image_data_ptr_,fast_image_data_);
      RegPTResVar3        (fast_image_data_ptr_,fast_image_data_);
      if (res_var2<=0) then
        Exit;
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      d2_               :=scl_mul.y*Length(sqrt_arr1);
      d4                :=sqrt((scl_mul.x*scl_mul.y)/2);
      d4_               :=FloatToFixed(d4);
      scl_mul_          :=PtPosF(res_var8*scl_mul.x,res_var3*scl_mul.y);

      {top border---} {$region -fold}
        begin
          d1        :=scl_mul_.y*(res_var0+0);

          l0:

          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1_       := h1;
          h1        *=bmp_bkgnd_width;
          p0        :=(h1_+0>=rct_clp_ptr^.top   ) and
                      (h1_+0< rct_clp_ptr^.bottom);
          p1        :=(h1_+1>=rct_clp_ptr^.top   ) and
                      (h1_+1< rct_clp_ptr^.bottom);
          if (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=              pt_pix_sht_arr_ptr;
              c1               :=BinarySearch5(pt_pix_cnt_arr_ptr^,
                                               first_sht_pix_ptr,res_var9);
              c2               :=BinarySearch5(pt_pix_cnt_arr_ptr^,
                                               first_sht_pix_ptr,res_var10);
              if (c1<>pt_pix_cnt_arr_ptr^-1) or (c2<>-1) then
                begin

                  pix_cnt_inc:=0;
                  continue_  :=False;

                  if (c1<>-1) then
                    begin
                      Inc(pt_pix_sht_arr_ptr,c1);
                      Inc(pt_pix_ccl_arr_ptr,c1);
                      Inc(pix_cnt_inc,c1);
                    end;

                  if (pix_area.y<scl_mul.y) then
                    begin
                      d2:=(          pix_area.y)*Length(sqrt_arr1);
                      d3:=(scl_mul.y-pix_area.y)*Length(sqrt_arr1);

                      {left pixel-} {$region -fold}
                      if (pt_pix_sht_arr_ptr-first_sht_pix_ptr<pt_pix_cnt_arr_ptr^) and (c1<>-1) then
                        begin

                          l10:

                          pow                         :=(d4_*PRGBA(pt_pix_ccl_arr_ptr)^.a)>>16;
                          d0                          :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                          h0                          :=Trunc  (d0+m0);
                            pix_area.x                :=(h0+1)-(d0+m0);
                          b0                          :=(pix_area.x<scl_mul.x);
                          if (not b0) then
                            pix_area.x                :=scl_mul.x;
                                        bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                          {pixel processing} {$region -fold}
                          if (h0+0>=rct_clp_ptr^.left ) and
                             (h0+0< rct_clp_ptr^.right) then
                          if p0 then
                            AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,pow,sqrt_arr1[Trunc((          pix_area.x)*d2)]);

                          Inc       (bmp_bkgnd_ptr2);

                          if (h0+1>=rct_clp_ptr^.left ) and
                             (h0+1< rct_clp_ptr^.right) then
                          if p0 then
                          if b0 then
                            AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,pow,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)]);

                          Inc       (bmp_bkgnd_ptr2,bmp_bkgnd_width-1);

                          if (h0+0>=rct_clp_ptr^.left ) and
                             (h0+0< rct_clp_ptr^.right) then
                          if p1 then
                            AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,pow,sqrt_arr1[Trunc((          pix_area.x)*d3)]);

                          Inc       (bmp_bkgnd_ptr2);

                          if (h0+1>=rct_clp_ptr^.left ) and
                             (h0+1< rct_clp_ptr^.right) then
                          if p1 then
                          if b0 then
                            AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,pow,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)]); {$endregion}

                          Inc(pt_pix_sht_arr_ptr);
                          Inc(pt_pix_ccl_arr_ptr);
                          Inc(pix_cnt_inc);

                          if continue_ then
                            goto l12;

                        end; {$endregion}

                      {main loop--} {$region -fold}
                      if (pt_pix_sht_arr_ptr-first_sht_pix_ptr<pt_pix_cnt_arr_ptr^) then
                        for x:=0 to c2-c1-2 do
                          begin
                            pow                                             :=(d4_*PRGBA(pt_pix_ccl_arr_ptr)^.a)>>16;
                            d0                                              :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                            h0                                              :=Trunc  (d0+m0);
                              pix_area.x                                    :=(h0+1)-(d0+m0);
                            b0                                              :=(pix_area.x<scl_mul.x);
                            if (not b0) then
                              pix_area.x                                    :=scl_mul.x;
                                                              bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                            {pixel processing} {$region -fold}
                            if p0 then
                              ScalePix128C(MSK2_128,MSK3_128,(bmp_bkgnd_ptr2+000000000000000)^,pt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d2)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)],pow,b0);
                            if p1 then
                              ScalePix128C(MSK2_128,MSK3_128,(bmp_bkgnd_ptr2+bmp_bkgnd_width)^,pt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d3)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)],pow,b0); {$endregion}

                            Inc(pt_pix_sht_arr_ptr);
                            Inc(pt_pix_ccl_arr_ptr);
                            Inc(pix_cnt_inc);
                          end; {$endregion}

                      {right pixel} {$region -fold}
                      if (pt_pix_sht_arr_ptr-first_sht_pix_ptr<pt_pix_cnt_arr_ptr^) then
                        begin
                          continue_:=True;
                          goto l10;
                        end; {$endregion}

                    end
                  else
                    begin

                      {left pixel-} {$region -fold}
                      if (pt_pix_sht_arr_ptr-first_sht_pix_ptr<pt_pix_cnt_arr_ptr^) and (c1<>-1) then
                        begin

                          l11:

                          pow                         :=(d4_*PRGBA(pt_pix_ccl_arr_ptr)^.a)>>16;
                          d0                          :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                          h0                          :=Trunc  (d0+m0);
                            pix_area.x                :=(h0+1)-(d0+m0);
                          b0                          :=(pix_area.x<scl_mul.x);
                          if (not b0) then
                            pix_area.x                :=scl_mul.x;
                                        bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                          {pixel processing} {$region -fold}
                          if (h0+0>=rct_clp_ptr^.left ) and
                             (h0+0< rct_clp_ptr^.right) then
                          if p0 then
                            AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,pow,sqrt_arr1[Trunc((          pix_area.x)*d2_)]);

                          Inc          (bmp_bkgnd_ptr2);

                          if (h0+1>=rct_clp_ptr^.left ) and
                             (h0+1< rct_clp_ptr^.right) then
                          if p0 then
                          if b0 then
                            AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,pow,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)]); {$endregion}

                          Inc(pt_pix_sht_arr_ptr);
                          Inc(pt_pix_ccl_arr_ptr);
                          Inc(pix_cnt_inc);

                          if continue_ then
                            goto l12;

                        end; {$endregion}

                      {main loop--} {$region -fold}
                      if (pt_pix_sht_arr_ptr-first_sht_pix_ptr<pt_pix_cnt_arr_ptr^) then
                        for x:=0 to c2-c1-2 do
                          begin
                            pow                                            :=(d4_*PRGBA(pt_pix_ccl_arr_ptr)^.a)>>16;
                            d0                                             :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                            h0                                             :=Trunc  (d0+m0);
                              pix_area.x                                   :=(h0+1)-(d0+m0);
                            b0                                             :=(pix_area.x<scl_mul.x);
                            if (not b0) then
                              pix_area.x                                   :=scl_mul.x;
                                                             bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                            {pixel processing} {$region -fold}
                            if p0 then
                              ScalePix128C(MSK2_128,MSK3_128,bmp_bkgnd_ptr2^,pt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d2_)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)],pow,b0); {$endregion}

                            Inc(pt_pix_sht_arr_ptr);
                            Inc(pt_pix_ccl_arr_ptr);
                            Inc(pix_cnt_inc);
                          end; {$endregion}

                      {right pixel} {$region -fold}
                      if (pt_pix_sht_arr_ptr-first_sht_pix_ptr<pt_pix_cnt_arr_ptr^) then
                        begin
                          continue_:=True;
                          goto l11;
                        end; {$endregion}

                    end;

                  l12:

                  Inc(pt_pix_sht_arr_ptr,pt_pix_cnt_arr_ptr^-pix_cnt_inc);
                  Inc(pt_pix_ccl_arr_ptr,pt_pix_cnt_arr_ptr^-pix_cnt_inc);

                end
              else
                begin
                  Inc(pt_pix_sht_arr_ptr,pt_pix_cnt_arr_ptr^);
                  Inc(pt_pix_ccl_arr_ptr,pt_pix_cnt_arr_ptr^);
                end;
            end;
          Inc(pt_pix_cnt_arr_ptr);

          if check_exit then
            Exit;

        end; {$endregion}

      {main loop----} {$region -fold}
      if (res_var2>1) then
      for y:=1 to res_var2-1 do
        begin
          d1        :=scl_mul_.y*(res_var0+y);
          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1        *=bmp_bkgnd_width;
          if (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=              pt_pix_sht_arr_ptr;
              c1               :=BinarySearch5(pt_pix_cnt_arr_ptr^,
                                               first_sht_pix_ptr,res_var9);
              c2               :=BinarySearch5(pt_pix_cnt_arr_ptr^,
                                               first_sht_pix_ptr,res_var10);
              if (c1<>pt_pix_cnt_arr_ptr^-1) or (c2<>-1) then
                begin

                  pix_cnt_inc:=0;
                  continue_  :=False;

                  if (c1<>-1) then
                    begin
                      Inc(pt_pix_sht_arr_ptr,c1);
                      Inc(pt_pix_ccl_arr_ptr,c1);
                      Inc(pix_cnt_inc,c1);
                    end;

                  if (pix_area.y<scl_mul.y) then
                    begin
                      d2:=(          pix_area.y)*Length(sqrt_arr1);
                      d3:=(scl_mul.y-pix_area.y)*Length(sqrt_arr1);

                      {left pixel-} {$region -fold}
                      if (pt_pix_sht_arr_ptr-first_sht_pix_ptr<pt_pix_cnt_arr_ptr^) and (c1<>-1) then
                        begin

                          l20:

                          pow                                             :=(d4_*PRGBA(pt_pix_ccl_arr_ptr)^.a)>>16;
                          d0                                              :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                          h0                                              :=Trunc  (d0+m0);
                            pix_area.x                                    :=(h0+1)-(d0+m0);
                          b0                                              :=(pix_area.x<scl_mul.x);
                          if (not b0) then
                            pix_area.x                                    :=scl_mul.x;
                                                            bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                          {pixel processing} {$region -fold}
                          if (h0+0>=rct_clp_ptr^.left ) and
                             (h0+0< rct_clp_ptr^.right) then
                            ScalePix128D(MSK2_128,MSK3_128,(bmp_bkgnd_ptr2+0)^,pt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc((          pix_area.x)*d2)],sqrt_arr1[Trunc((          pix_area.x)*d3)],pow,bmp_bkgnd_width);
                          if  b0 then
                          if (h0+1>=rct_clp_ptr^.left ) and
                             (h0+1< rct_clp_ptr^.right) then
                            ScalePix128D(MSK2_128,MSK3_128,(bmp_bkgnd_ptr2+1)^,pt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)],pow,bmp_bkgnd_width); {$endregion}

                          Inc(pt_pix_sht_arr_ptr);
                          Inc(pt_pix_ccl_arr_ptr);
                          Inc(pix_cnt_inc);

                          if continue_ then
                            goto l22;

                        end; {$endregion}

                      {main loop--} {$region -fold}
                      if (pt_pix_sht_arr_ptr-first_sht_pix_ptr<pt_pix_cnt_arr_ptr^) then
                        for x:=0 to c2-c1-2 do
                          begin
                            pow                                             :=(d4_*PRGBA(pt_pix_ccl_arr_ptr)^.a)>>16;
                            d0                                              :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                            h0                                              :=Trunc  (d0+m0);
                              pix_area.x                                    :=(h0+1)-(d0+m0);
                            b0                                              :=(pix_area.x<scl_mul.x);
                            if (not b0) then
                              pix_area.x                                    :=scl_mul.x;
                                                              bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                            {pixel processing} {$region -fold}
                              ScalePix128D(MSK2_128,MSK3_128,(bmp_bkgnd_ptr2+0)^,pt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc((          pix_area.x)*d2)],sqrt_arr1[Trunc((          pix_area.x)*d3)],pow,bmp_bkgnd_width);
                            if b0 then
                              ScalePix128D(MSK2_128,MSK3_128,(bmp_bkgnd_ptr2+1)^,pt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)],pow,bmp_bkgnd_width); {$endregion}

                            Inc(pt_pix_sht_arr_ptr);
                            Inc(pt_pix_ccl_arr_ptr);
                            Inc(pix_cnt_inc);
                          end; {$endregion}

                      {right pixel} {$region -fold}
                      if (pt_pix_sht_arr_ptr-first_sht_pix_ptr<pt_pix_cnt_arr_ptr^) then
                        begin
                          continue_:=True;
                          goto l20;
                        end; {$endregion}

                    end
                  else
                    begin

                      {left pixel-} {$region -fold}
                      if (pt_pix_sht_arr_ptr-first_sht_pix_ptr<pt_pix_cnt_arr_ptr^) and (c1<>-1) then
                        begin

                          l21:

                          pow                      :=(d4_*PRGBA(pt_pix_ccl_arr_ptr)^.a)>>16;
                          d0                       :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                          h0                       :=Trunc  (d0+m0);
                            pix_area.x             :=(h0+1)-(d0+m0);
                          b0                       :=(pix_area.x<scl_mul.x);
                          if (not b0) then
                            pix_area.x             :=scl_mul.x;
                                     bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                          {pixel processing} {$region -fold}
                          if (h0+0>=rct_clp_ptr^.left ) and
                             (h0+0< rct_clp_ptr^.right) then
                            AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,pow,sqrt_arr1[Trunc((          pix_area.x)*d2_)]);
                          Inc       (bmp_bkgnd_ptr2);
                          if  b0 then
                          if (h0+1>=rct_clp_ptr^.left ) and
                             (h0+1< rct_clp_ptr^.right) then
                            AlphaBlend4(bmp_bkgnd_ptr2,pt_pix_ccl_arr_ptr,pow,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)]); {$endregion}

                          Inc(pt_pix_sht_arr_ptr);
                          Inc(pt_pix_ccl_arr_ptr);
                          Inc(pix_cnt_inc);

                          if continue_ then
                            goto l22;

                        end; {$endregion}

                      {main loop--} {$region -fold}
                      if (pt_pix_sht_arr_ptr-first_sht_pix_ptr<pt_pix_cnt_arr_ptr^) then
                        for x:=0 to c2-c1-2 do
                          begin
                            pow                                          :=(d4_*PRGBA(pt_pix_ccl_arr_ptr)^.a)>>16;
                            d0                                           :=scl_mul_.x*pt_pix_sht_arr_ptr^;
                            h0                                           :=Trunc  (d0+m0);
                              pix_area.x                                 :=(h0+1)-(d0+m0);
                            b0                                           :=(pix_area.x<scl_mul.x);
                            if (not b0) then
                              pix_area.x                                 :=scl_mul.x;
                                                           bmp_bkgnd_ptr2:=fast_image_data_ptr_^.bmp_bkgnd_ptr+h0+h1;

                            {pixel processing} {$region -fold}
                            ScalePix128C(MSK2_128,MSK3_128,bmp_bkgnd_ptr2^,pt_pix_ccl_arr_ptr^,sqrt_arr1[Trunc(pix_area.x*d2_)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2_)],pow,b0); {$endregion}

                            Inc(pt_pix_sht_arr_ptr);
                            Inc(pt_pix_ccl_arr_ptr);
                            Inc(pix_cnt_inc);
                          end; {$endregion}

                      {right pixel} {$region -fold}
                      if (pt_pix_sht_arr_ptr-first_sht_pix_ptr<pt_pix_cnt_arr_ptr^) then
                        begin
                          continue_:=True;
                          goto l21;
                        end; {$endregion}

                    end;

                  l22:

                  Inc(pt_pix_sht_arr_ptr,pt_pix_cnt_arr_ptr^-pix_cnt_inc);
                  Inc(pt_pix_ccl_arr_ptr,pt_pix_cnt_arr_ptr^-pix_cnt_inc);

                end
              else
                begin
                  Inc(pt_pix_sht_arr_ptr,pt_pix_cnt_arr_ptr^);
                  Inc(pt_pix_ccl_arr_ptr,pt_pix_cnt_arr_ptr^);
                end;
            end;
          Inc(pt_pix_cnt_arr_ptr);
        end; {$endregion}

      {bottom border} {$region -fold}
      if (res_var2>0) and
         (PWord (                       pt_pix_cnt_arr_ptr)-
          PWord (@fast_image_data_ptr_^.pt_pix_cnt_arr[0])<
          Length( fast_image_data_ptr_^.pt_pix_cnt_arr)) then
        begin
          d1        :=scl_mul_.y*(res_var0+res_var2);
          check_exit:=True;
          goto l0;
        end; {$endregion}

    end;
end; {$endregion}
// (constant) image has monochrome alpha channel:
procedure TFastImageProc.RSDPTColor006(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Color of Curent Layer(Additive)}
// (constant) not clipped:
procedure TFastImageProc.RSDPTColor010(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTColor012(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTColor014(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSDPTColor016(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTColor011(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTColor013(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTColor015(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
// same as (constant)

{Color of Curent Layer(Alphablend)}
// (constant) not clipped:
procedure TFastImageProc.RSDPTColor020(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTColor022(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTColor024(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{$endregion}

{||scl_mul||>1: (SU - Scale Up  )} {$region -fold}

{Empty}
procedure TFastImageProc.RSUPTColor009(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Color of Curent Layer}
// (constant) not clipped:
procedure TFastImageProc.RSUPTColor000(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTColor002(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTColor004(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome alpha channel:
procedure TFastImageProc.RSUPTColor006(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Color of Curent Layer(Additive)}
// (constant) not clipped:
procedure TFastImageProc.RSUPTColor010(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTColor012(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTColor014(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.RSUPTColor016(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUPTColor011(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTColor013(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTColor015(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) image has monochrome color channel:
// same as (constant)

{Color of Curent Layer(Alphablend)}
// (constant) not clipped:
procedure TFastImageProc.RSUPTColor020(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTColor022(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTColor024(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{$endregion}

{$endregion}

{Value} {$region -fold}

{||scl_mul||=1:                  } {$region -fold}

{Auxiliary procedures}
// (constant) not clipped and top-bottom clipped:
procedure TFastImageProc.RegPTProcA0  (Proc19:TProc19; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
              Proc19 (pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,bmp_bkgnd_width,
              MAXBYTE-pt_pix_acl_arr_ptr^);
              Inc    (pt_pix_sht_arr_ptr);
              Inc    (pt_pix_acl_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTProcB0  (Proc8 :TProc8;  const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
              Proc8  (pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,bmp_bkgnd_width);
              Inc    (pt_pix_sht_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTProcA4  (Proc19:TProc19; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc19        (pt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,
                      MAXBYTE-       pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Proc19        (pt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,
                      MAXBYTE-       pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Proc19        (pt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,
                      MAXBYTE-       pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      Proc19        (pt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,
                      MAXBYTE-       pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTProcB4  (Proc8 :TProc8;  const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc8         (pt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Proc8         (pt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Proc8         (pt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      Proc8         (pt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (fading) not clipped and top-bottom clipped:
procedure TFastImageProc.RegPTProcC0  (Proc19:TProc19; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to     pt_pix_cnt_arr_ptr^-1 do
            begin
              Proc19     (pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,bmp_bkgnd_width,
              MAXBYTE-Max(pt_pix_acl_arr_ptr^-cfx_pow0_,0));
              Inc        (pt_pix_sht_arr_ptr);
              Inc        (pt_pix_acl_arr_ptr);
            end;
          Inc            (pt_pix_cnt_arr_ptr);
          Inc     (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTProcD0  (Proc19:TProc19; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
              Proc19 (pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,bmp_bkgnd_width,cfx_pow0_);
              Inc    (pt_pix_sht_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTProcC4  (Proc19:TProc19; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc19        (pt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,
                      MAXBYTE-   Max(pt_pix_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Proc19        (pt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,
                      MAXBYTE-   Max(pt_pix_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Proc19        (pt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,
                      MAXBYTE-   Max(pt_pix_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      Proc19        (pt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,
                      MAXBYTE-   Max(pt_pix_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTProcD4  (Proc19:TProc19; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc19        (pt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Proc19        (pt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Proc19        (pt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      Proc19        (pt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) not clipped and top-bottom clipped:
procedure TFastImageProc.RegPTProcE0  (Proc18:TProc18; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
              Proc18 (pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
              MAXBYTE-pt_pix_acl_arr_ptr^,cfx_pow0);
              Inc    (pt_pix_sht_arr_ptr);
              Inc    (pt_pix_acl_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTProcE4  (Proc18:TProc18; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc18        (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-       pt_pix_acl_arr_ptr^,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Proc18        (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-       pt_pix_acl_arr_ptr^,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Proc18        (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-       pt_pix_acl_arr_ptr^,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      Proc18        (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-       pt_pix_acl_arr_ptr^,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}

{Empty}
procedure TFastImageProc.RegPTValue009(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Monochrome}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA00(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to     pt_pix_cnt_arr_ptr^-1 do
            begin
              AlphaBlend1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,monochrome_val,
              MAXBYTE-    pt_pix_acl_arr_ptr^);
              Inc        (pt_pix_sht_arr_ptr);
              Inc        (pt_pix_acl_arr_ptr);
            end;
          Inc            (pt_pix_cnt_arr_ptr);
          Inc     (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB00(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr)^:=monochrome_val;
              Inc    (pt_pix_sht_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.RegPTValue000(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA00(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB00(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA04(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AlphaBlend1   (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,
                      MAXBYTE-       pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AlphaBlend1   (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,
                      MAXBYTE-       pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AlphaBlend1   (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,
                      MAXBYTE-       pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      AlphaBlend1   (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,
                      MAXBYTE-       pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB04(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=monochrome_val;
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=monochrome_val;
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=monochrome_val;
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=monochrome_val;
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue004(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA04(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB04(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading):
// same;

{Additive}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA10(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to      pt_pix_cnt_arr_ptr^-1 do
            begin
              AdditiveDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,monochrome_val,
              MAXBYTE-     pt_pix_acl_arr_ptr^);
              Inc         (pt_pix_sht_arr_ptr);
              Inc         (pt_pix_acl_arr_ptr);
            end;
          Inc             (pt_pix_cnt_arr_ptr);
          Inc      (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB10(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to   pt_pix_cnt_arr_ptr^-1 do
            begin
              Additive1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,monochrome_val);
              Inc      (pt_pix_sht_arr_ptr);
            end;
          Inc          (pt_pix_cnt_arr_ptr);
          Inc   (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.RegPTValue010(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA10(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB10(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA14(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,
                      MAXBYTE-       pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,
                      MAXBYTE-       pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,
                      MAXBYTE-       pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,
                      MAXBYTE-       pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB14(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Additive1     (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Additive1     (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Additive1     (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      Additive1     (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue014(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA14(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB14(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTValueA11(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to      pt_pix_cnt_arr_ptr^-1 do
            begin
              AdditiveDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,monochrome_val,
              MAXBYTE- Max(pt_pix_acl_arr_ptr^-cfx_pow0_,0));
              Inc         (pt_pix_sht_arr_ptr);
              Inc         (pt_pix_acl_arr_ptr);
            end;
          Inc             (pt_pix_cnt_arr_ptr);
          Inc      (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB11(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to      pt_pix_cnt_arr_ptr^-1 do
            begin
              AdditiveDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,monochrome_val,cfx_pow0_);
              Inc         (pt_pix_sht_arr_ptr);
            end;
          Inc             (pt_pix_cnt_arr_ptr);
          Inc      (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegPTValue011(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA11(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB11(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTValueA15(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueA14   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,
                      MAXBYTE-   Max(pt_pix_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,
                      MAXBYTE-   Max(pt_pix_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,
                      MAXBYTE-   Max(pt_pix_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,
                      MAXBYTE-   Max(pt_pix_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB15(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueB14   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue015(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA15(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB15(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}

{Alphablend}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA20(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueA00   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
            begin
              AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,monochrome_val,
                            (pt_pix_acl_arr_ptr^),cfx_pow0_);
              Inc           (pt_pix_sht_arr_ptr);
              Inc           (pt_pix_acl_arr_ptr);
            end;
          Inc               (pt_pix_cnt_arr_ptr);
          Inc        (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB20(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueB00   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to     pt_pix_cnt_arr_ptr^-1 do
            begin
              AlphaBlend1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,monochrome_val,cfx_pow0_);
              Inc        (pt_pix_sht_arr_ptr);
            end;
          Inc            (pt_pix_cnt_arr_ptr);
          Inc     (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.RegPTValue020(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA20(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB20(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA24(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueA04   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,
                                     pt_pix_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,
                                     pt_pix_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,
                                     pt_pix_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,
                                     pt_pix_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB24(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueB04   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AlphaBlend1   (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AlphaBlend1   (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AlphaBlend1   (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      AlphaBlend1   (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue024(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA24(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB24(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading):
// same;

{Inverse}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA30(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to     pt_pix_cnt_arr_ptr^-1 do
            begin
              InverseDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
              MAXBYTE-    pt_pix_acl_arr_ptr^);
              Inc        (pt_pix_sht_arr_ptr);
              Inc        (pt_pix_acl_arr_ptr);
            end;
          Inc            (pt_pix_cnt_arr_ptr);
          Inc     (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB30(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to  pt_pix_cnt_arr_ptr^-1 do
            begin
              Inverse1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr);
              Inc     (pt_pix_sht_arr_ptr);
            end;
          Inc         (pt_pix_cnt_arr_ptr);
          Inc  (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.RegPTValue030(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA30(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB30(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA34(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      InverseDec1   (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-       pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      InverseDec1   (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-       pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      InverseDec1   (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-       pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      InverseDec1   (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-       pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB34(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Inverse1      (pt_pix_sht_arr_ptr^*res_var8+v);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Inverse1      (pt_pix_sht_arr_ptr^*res_var8+v);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Inverse1      (pt_pix_sht_arr_ptr^*res_var8+v);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      Inverse1      (pt_pix_sht_arr_ptr^*res_var8+v);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue034(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA34(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB34(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTValueA31(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueA30   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to     pt_pix_cnt_arr_ptr^-1 do
            begin
              InverseDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
              MAXBYTE-Max(pt_pix_acl_arr_ptr^-cfx_pow0_,0));
              Inc        (pt_pix_sht_arr_ptr);
              Inc        (pt_pix_acl_arr_ptr);
            end;
          Inc            (pt_pix_cnt_arr_ptr);
          Inc     (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB31(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueB30   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to     pt_pix_cnt_arr_ptr^-1 do
            begin
              InverseDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,cfx_pow0_);
              Inc        (pt_pix_sht_arr_ptr);
            end;
          Inc            (pt_pix_cnt_arr_ptr);
          Inc     (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegPTValue031(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA31(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB31(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTValueA35(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueA34   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      InverseDec1   (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-   Max(pt_pix_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      InverseDec1   (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-   Max(pt_pix_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      InverseDec1   (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-   Max(pt_pix_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      InverseDec1   (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-   Max(pt_pix_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB35(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueB34   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      InverseDec1   (pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      InverseDec1   (pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      InverseDec1   (pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      InverseDec1   (pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue035(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA35(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB35(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}

{Highlight}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegPTValueB40(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to    pt_pix_cnt_arr_ptr^-1 do
            begin
              Highlight1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,cfx_pow0);
              Inc       (pt_pix_sht_arr_ptr);
            end;
          Inc           (pt_pix_cnt_arr_ptr);
          Inc    (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.RegPTValue040(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTProcE0  (@HighlightDec1,fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB40(               fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) auxiliary procedure:
procedure TFastImageProc.RegPTValueB44(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Highlight1    (pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Highlight1    (pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Highlight1    (pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      Highlight1    (pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue044(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTProcE4  (@HighlightDec1,fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB44(               fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading):
// same;

{Darken}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA50(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to    pt_pix_cnt_arr_ptr^-1 do
            begin
              DarkenDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
              MAXBYTE-   pt_pix_acl_arr_ptr^,cfx_pow0);
              Inc       (pt_pix_sht_arr_ptr);
              Inc       (pt_pix_acl_arr_ptr);
            end;
          Inc           (pt_pix_cnt_arr_ptr);
          Inc    (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB50(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  d                 : byte;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
              Darken1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,cfx_pow0);
              Inc    (pt_pix_sht_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.RegPTValue050(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA50(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB50(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA54(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      DarkenDec1    (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-       pt_pix_acl_arr_ptr^,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      DarkenDec1    (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-       pt_pix_acl_arr_ptr^,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      DarkenDec1    (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-       pt_pix_acl_arr_ptr^,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      DarkenDec1    (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-       pt_pix_acl_arr_ptr^,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB54(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Darken1       (pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Darken1       (pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Darken1       (pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      Darken1       (pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue054(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA54(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB54(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading):
// same;

{GrayscaleR}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA60(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
            begin
              GrayscaleRDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
                             pt_pix_acl_arr_ptr^);
              Inc           (pt_pix_sht_arr_ptr);
              Inc           (pt_pix_acl_arr_ptr);
            end;
          Inc               (pt_pix_cnt_arr_ptr);
          Inc        (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB60(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to     pt_pix_cnt_arr_ptr^-1 do
            begin
              GrayscaleR1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr);
              Inc        (pt_pix_sht_arr_ptr);
            end;
          Inc            (pt_pix_cnt_arr_ptr);
          Inc     (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.RegPTValue060(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA60(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB60(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA64(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      GrayscaleRDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      GrayscaleRDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      GrayscaleRDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      GrayscaleRDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB64(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      GrayscaleR1   (pt_pix_sht_arr_ptr^*res_var8+v);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      GrayscaleR1   (pt_pix_sht_arr_ptr^*res_var8+v);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      GrayscaleR1   (pt_pix_sht_arr_ptr^*res_var8+v);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      GrayscaleR1   (pt_pix_sht_arr_ptr^*res_var8+v);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue064(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA64(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB64(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTValueA61(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueA60   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
            begin
              GrayscaleRDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
              Max           (pt_pix_acl_arr_ptr^-cfx_pow0_,0));
              Inc           (pt_pix_sht_arr_ptr);
              Inc           (pt_pix_acl_arr_ptr);
            end;
          Inc               (pt_pix_cnt_arr_ptr);
          Inc        (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB61(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueB60   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
            begin
              GrayscaleRDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,cfx_pow0);
              Inc           (pt_pix_sht_arr_ptr);
            end;
          Inc               (pt_pix_cnt_arr_ptr);
          Inc        (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegPTValue061(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA61(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB61(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTValueA65(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueA64   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      GrayscaleRDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                      Max           (pt_pix_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      GrayscaleRDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                      Max           (pt_pix_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      GrayscaleRDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                      Max           (pt_pix_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      GrayscaleRDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                      Max           (pt_pix_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB65(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueB64   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      GrayscaleRDec1(pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      GrayscaleRDec1(pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      GrayscaleRDec1(pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      GrayscaleRDec1(pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue065(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA65(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB65(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}

{GrayscaleG}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA70(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
            begin
              GrayscaleGDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
                             pt_pix_acl_arr_ptr^);
              Inc           (pt_pix_sht_arr_ptr);
              Inc           (pt_pix_acl_arr_ptr);
            end;
          Inc               (pt_pix_cnt_arr_ptr);
          Inc        (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB70(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to     pt_pix_cnt_arr_ptr^-1 do
            begin
              GrayscaleG1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr);
              Inc        (pt_pix_sht_arr_ptr);
            end;
          Inc            (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.RegPTValue070(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA70(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB70(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA74(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      GrayscaleGDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      GrayscaleGDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      GrayscaleGDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      GrayscaleGDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB74(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      GrayscaleG1   (pt_pix_sht_arr_ptr^*res_var8+v);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      GrayscaleG1   (pt_pix_sht_arr_ptr^*res_var8+v);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      GrayscaleG1   (pt_pix_sht_arr_ptr^*res_var8+v);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      GrayscaleG1   (pt_pix_sht_arr_ptr^*res_var8+v);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue074(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA74(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB74(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTValueA71(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueA70   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
            begin
              GrayscaleGDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
              Max           (pt_pix_acl_arr_ptr^-cfx_pow0_,0));
              Inc           (pt_pix_sht_arr_ptr);
              Inc           (pt_pix_acl_arr_ptr);
            end;
          Inc               (pt_pix_cnt_arr_ptr);
          Inc        (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB71(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueB70   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
            begin
              GrayscaleGDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,cfx_pow0);
              Inc           (pt_pix_sht_arr_ptr);
            end;
          Inc               (pt_pix_cnt_arr_ptr);
          Inc        (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegPTValue071(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA71(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB71(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTValueA75(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueA74   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      GrayscaleGDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                      Max           (pt_pix_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      GrayscaleGDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                      Max           (pt_pix_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      GrayscaleGDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                      Max           (pt_pix_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      GrayscaleGDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                      Max           (pt_pix_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB75(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueB74   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      GrayscaleGDec1(pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      GrayscaleGDec1(pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      GrayscaleGDec1(pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      GrayscaleGDec1(pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue075(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA75(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB75(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}

{GrayscaleB}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA80(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
            begin
              GrayscaleBDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
                             pt_pix_acl_arr_ptr^);
              Inc           (pt_pix_sht_arr_ptr);
              Inc           (pt_pix_acl_arr_ptr);
            end;
          Inc               (pt_pix_cnt_arr_ptr);
          Inc        (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB80(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to     pt_pix_cnt_arr_ptr^-1 do
            begin
              GrayscaleB1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr);
              Inc        (pt_pix_sht_arr_ptr);
            end;
          Inc            (pt_pix_cnt_arr_ptr);
          Inc     (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.RegPTValue080(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA80(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB80(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA84(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      GrayscaleBDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      GrayscaleBDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      GrayscaleBDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      GrayscaleBDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB84(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      GrayscaleB1   (pt_pix_sht_arr_ptr^*res_var8+v);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      GrayscaleB1   (pt_pix_sht_arr_ptr^*res_var8+v);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      GrayscaleB1   (pt_pix_sht_arr_ptr^*res_var8+v);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      GrayscaleB1   (pt_pix_sht_arr_ptr^*res_var8+v);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue084(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA84(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB84(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTValueA81(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueA80   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
            begin
              GrayscaleBDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
              Max           (pt_pix_acl_arr_ptr^-cfx_pow0_,0));
              Inc           (pt_pix_sht_arr_ptr);
              Inc           (pt_pix_acl_arr_ptr);
            end;
          Inc               (pt_pix_cnt_arr_ptr);
          Inc        (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB81(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueB80   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
            begin
              GrayscaleBDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,cfx_pow0);
              Inc           (pt_pix_sht_arr_ptr);
            end;
          Inc               (pt_pix_cnt_arr_ptr);
          Inc        (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegPTValue081(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA81(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB81(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTValueA85(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueA84   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      GrayscaleBDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                      Max           (pt_pix_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      GrayscaleBDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                      Max           (pt_pix_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      GrayscaleBDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                      Max           (pt_pix_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      GrayscaleBDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                      Max           (pt_pix_acl_arr_ptr^-cfx_pow0_,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB85(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          RegPTValueB84   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      GrayscaleBDec1(pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      GrayscaleBDec1(pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      GrayscaleBDec1(pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      GrayscaleBDec1(pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue085(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA85(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB85(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}

{Monochrome Noise}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA90(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to       pt_pix_cnt_arr_ptr^-1 do
            begin
              if Odd      ((pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr)^) then
                AlphaBlend1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,monochrome_val,
              MAXBYTE-      pt_pix_acl_arr_ptr^);
              Inc          (pt_pix_sht_arr_ptr);
              Inc          (pt_pix_acl_arr_ptr);
            end;
          Inc              (pt_pix_cnt_arr_ptr);
          Inc       (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB90(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
              if Odd((pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr)^) then
                     (pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr)^:=monochrome_val;
              Inc    (pt_pix_sht_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.RegPTValue090(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA90(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB90(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueA94(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      if Odd       ((pt_pix_sht_arr_ptr^*res_var8+v)^) then
                        AlphaBlend1 (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,
                      MAXBYTE-       pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      if Odd       ((pt_pix_sht_arr_ptr^*res_var8+v)^) then
                        AlphaBlend1 (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,
                      MAXBYTE-       pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      if Odd       ((pt_pix_sht_arr_ptr^*res_var8+v)^) then
                        AlphaBlend1 (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,
                      MAXBYTE-       pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      if Odd       ((pt_pix_sht_arr_ptr^*res_var8+v)^) then
                        AlphaBlend1 (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,
                      MAXBYTE-       pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB94(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ do
    begin
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      if Odd       ((pt_pix_sht_arr_ptr^*res_var8+v)^) then
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=monochrome_val;
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      if Odd       ((pt_pix_sht_arr_ptr^*res_var8+v)^) then
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=monochrome_val;
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      if Odd       ((pt_pix_sht_arr_ptr^*res_var8+v)^) then
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=monochrome_val;
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      if Odd       ((pt_pix_sht_arr_ptr^*res_var8+v)^) then
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=monochrome_val;
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue094(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA94(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB94(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTValueA91(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to           pt_pix_cnt_arr_ptr^-1 do
            begin
              if Odd          ((pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr)^) then
                AlphaBlendDec1((pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr),monochrome_val,
                               (pt_pix_acl_arr_ptr^),cfx_pow0_);
              Inc              (pt_pix_sht_arr_ptr);
              Inc              (pt_pix_acl_arr_ptr);
            end;
          Inc                  (pt_pix_cnt_arr_ptr);
          Inc           (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB91(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to       pt_pix_cnt_arr_ptr^-1 do
            begin
              if Odd      ((pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr)^) then
                AlphaBlend1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,monochrome_val,cfx_pow0_);
              Inc          (pt_pix_sht_arr_ptr);
            end;
          Inc              (pt_pix_cnt_arr_ptr);
          Inc       (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegPTValue091(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA91(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB91(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) auxiliary procedures:
procedure TFastImageProc.RegPTValueA95(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      if Odd       ((pt_pix_sht_arr_ptr^*res_var8+v)^) then
                      AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,
                                    (pt_pix_acl_arr_ptr^),cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      if Odd       ((pt_pix_sht_arr_ptr^*res_var8+v)^) then
                      AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,
                                    (pt_pix_acl_arr_ptr^),cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      if Odd       ((pt_pix_sht_arr_ptr^*res_var8+v)^) then
                      AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,
                                    (pt_pix_acl_arr_ptr^),cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      if Odd       ((pt_pix_sht_arr_ptr^*res_var8+v)^) then
                      AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,
                                    (pt_pix_acl_arr_ptr^),cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueB95(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      if Odd       ((pt_pix_sht_arr_ptr^*res_var8+v)^) then
                        AlphaBlend1 (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      if Odd       ((pt_pix_sht_arr_ptr^*res_var8+v)^) then
                        AlphaBlend1 (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      if Odd       ((pt_pix_sht_arr_ptr^*res_var8+v)^) then
                        AlphaBlend1 (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      if Odd       ((pt_pix_sht_arr_ptr^*res_var8+v)^) then
                        AlphaBlend1 (pt_pix_sht_arr_ptr^*res_var8+v,monochrome_val,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue095(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueA95(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueB95(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}

{ColorizeR}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueC00(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to       pt_pix_cnt_arr_ptr^-1 do
            begin
              ColorizeRDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
              MAXBYTE-      pt_pix_acl_arr_ptr^,cfx_pow0_);
              Inc          (pt_pix_sht_arr_ptr);
              Inc          (pt_pix_acl_arr_ptr);
            end;
          Inc              (pt_pix_cnt_arr_ptr);
          Inc       (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueD00(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to    pt_pix_cnt_arr_ptr^-1 do
            begin
              ColorizeR1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,cfx_pow0_);
              Inc       (pt_pix_sht_arr_ptr);
            end;
          Inc           (pt_pix_cnt_arr_ptr);
          Inc    (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.RegPTValue100(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueC00(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueD00(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueC04(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      ColorizeRDec1 (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-       pt_pix_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      ColorizeRDec1 (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-       pt_pix_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      ColorizeRDec1 (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-       pt_pix_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      ColorizeRDec1 (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-       pt_pix_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueD04(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      ColorizeR1    (pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      ColorizeR1    (pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      ColorizeR1    (pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      ColorizeR1    (pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue104(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueC04(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueD04(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading):
// same;

{ColorizeG}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueC10(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to       pt_pix_cnt_arr_ptr^-1 do
            begin
              ColorizeGDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
              MAXBYTE-      pt_pix_acl_arr_ptr^,cfx_pow0_);
              Inc          (pt_pix_sht_arr_ptr);
              Inc          (pt_pix_acl_arr_ptr);
            end;
          Inc              (pt_pix_cnt_arr_ptr);
          Inc       (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueD10(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to    pt_pix_cnt_arr_ptr^-1 do
            begin
              ColorizeG1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,cfx_pow0_);
              Inc       (pt_pix_sht_arr_ptr);
            end;
          Inc           (pt_pix_cnt_arr_ptr);
          Inc    (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.RegPTValue110(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueC10(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueD10(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueC14(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      ColorizeGDec1 (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-       pt_pix_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      ColorizeGDec1 (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-       pt_pix_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      ColorizeGDec1 (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-       pt_pix_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      ColorizeGDec1 (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-       pt_pix_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueD14(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      ColorizeG1    (pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      ColorizeG1    (pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      ColorizeG1    (pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      ColorizeG1    (pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue114(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueC14(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueD14(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading):
// same;

{ColorizeB}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueC20(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to       pt_pix_cnt_arr_ptr^-1 do
            begin
              ColorizeBDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
              MAXBYTE-      pt_pix_acl_arr_ptr^,cfx_pow0_);
              Inc          (pt_pix_sht_arr_ptr);
              Inc          (pt_pix_acl_arr_ptr);
            end;
          Inc              (pt_pix_cnt_arr_ptr);
          Inc       (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueD20(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  cfx_pow0_         : byte;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to    pt_pix_cnt_arr_ptr^-1 do
            begin
              ColorizeB1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,cfx_pow0_);
              Inc       (pt_pix_sht_arr_ptr);
            end;
          Inc           (pt_pix_cnt_arr_ptr);
          Inc    (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.RegPTValue120(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueC20(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueD20(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueC24(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      ColorizeBDec1 (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-       pt_pix_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      ColorizeBDec1 (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-       pt_pix_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      ColorizeBDec1 (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-       pt_pix_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      ColorizeBDec1 (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-       pt_pix_acl_arr_ptr^,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueD24(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  cfx_pow0_         : byte;
label
  label1;
begin
  with fast_image_data_ do
    begin
      cfx_pow0_         :=MAXBYTE-cfx_pow0;
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      ColorizeB1    (pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      ColorizeB1    (pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      ColorizeB1    (pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      ColorizeB1    (pt_pix_sht_arr_ptr^*res_var8+v,cfx_pow0_);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue124(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueC24(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueD24(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading):
// same;

{BlurRGB}
// (constant) not clipped:
procedure TFastImageProc.RegPTValue130(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTProcA0(@BlurRGB4Dec,fast_image_data_ptr_,fast_image_data_)
    else
      RegPTProcB0(@BlurRGB4   ,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue134(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTProcA4(@BlurRGB4Dec,fast_image_data_ptr_,fast_image_data_)
    else
      RegPTProcB4(@BlurRGB4   ,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegPTValue131(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcA0(@BlurRGB4Dec,fast_image_data_ptr_,fast_image_data_)
          else
            RegPTProcB0(@BlurRGB4   ,fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC0(@BlurRGB4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        RegPTProcD0(@BlurRGB4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue135(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcA4(@BlurRGB4Dec,fast_image_data_ptr_,fast_image_data_)
          else
            RegPTProcB4(@BlurRGB4   ,fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC4(@BlurRGB4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        RegPTProcD4(@BlurRGB4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}

{BlurRRB}
// (constant) not clipped:
procedure TFastImageProc.RegPTValue140(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTProcA0(@BlurRRB4Dec,fast_image_data_ptr_,fast_image_data_)
    else
      RegPTProcB0(@BlurRRB4   ,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue144(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTProcA4(@BlurRRB4Dec,fast_image_data_ptr_,fast_image_data_)
    else
      RegPTProcB4(@BlurRRB4   ,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegPTValue141(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcA0(@BlurRRB4Dec,fast_image_data_ptr_,fast_image_data_)
          else
            RegPTProcB0(@BlurRRB4   ,fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC0(@BlurRRB4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        RegPTProcD0(@BlurRRB4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue145(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcA4(@BlurRRB4Dec,fast_image_data_ptr_,fast_image_data_)
          else
            RegPTProcB4(@BlurRRB4   ,fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC4(@BlurRRB4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        RegPTProcD4(@BlurRRB4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}

{BlurRGR}
// (constant) not clipped:
procedure TFastImageProc.RegPTValue150(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTProcA0(@BlurRGR4Dec,fast_image_data_ptr_,fast_image_data_)
    else
      RegPTProcB0(@BlurRGR4   ,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue154(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTProcA4(@BlurRGR4Dec,fast_image_data_ptr_,fast_image_data_)
    else
      RegPTProcB4(@BlurRGR4   ,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegPTValue151(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcA0(@BlurRGR4Dec,fast_image_data_ptr_,fast_image_data_)
          else
            RegPTProcB0(@BlurRGR4   ,fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC0(@BlurRGR4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        RegPTProcD0(@BlurRGR4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue155(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcA4(@BlurRGR4Dec,fast_image_data_ptr_,fast_image_data_)
          else
            RegPTProcB4(@BlurRGR4   ,fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC4(@BlurRGR4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        RegPTProcD4(@BlurRGR4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}

{BlurGGB}
// (constant) not clipped:
procedure TFastImageProc.RegPTValue160(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTProcA0(@BlurGGB4Dec,fast_image_data_ptr_,fast_image_data_)
    else
      RegPTProcB0(@BlurGGB4   ,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue164(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTProcA4(@BlurGGB4Dec,fast_image_data_ptr_,fast_image_data_)
    else
      RegPTProcB4(@BlurGGB4   ,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegPTValue161(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcA0(@BlurGGB4Dec,fast_image_data_ptr_,fast_image_data_)
          else
            RegPTProcB0(@BlurGGB4   ,fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC0(@BlurGGB4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        RegPTProcD0(@BlurGGB4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue165(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcA4(@BlurGGB4Dec,fast_image_data_ptr_,fast_image_data_)
          else
            RegPTProcB4(@BlurGGB4   ,fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC4(@BlurGGB4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        RegPTProcD4(@BlurGGB4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}

{BlurRGG}
// (constant) not clipped:
procedure TFastImageProc.RegPTValue170(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTProcA0(@BlurRGG4Dec,fast_image_data_ptr_,fast_image_data_)
    else
      RegPTProcB0(@BlurRGG4   ,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue174(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTProcA4(@BlurRGG4Dec,fast_image_data_ptr_,fast_image_data_)
    else
      RegPTProcB4(@BlurRGG4   ,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegPTValue171(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcA0(@BlurRGG4Dec,fast_image_data_ptr_,fast_image_data_)
          else
            RegPTProcB0(@BlurRGG4   ,fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC0(@BlurRGG4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        RegPTProcD0(@BlurRGG4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue175(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcA4(@BlurRGG4Dec,fast_image_data_ptr_,fast_image_data_)
          else
            RegPTProcB4(@BlurRGG4   ,fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC4(@BlurRGG4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        RegPTProcD4(@BlurRGG4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}

{BlurBGB}
// (constant) not clipped:
procedure TFastImageProc.RegPTValue180(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTProcA0(@BlurBGB4Dec,fast_image_data_ptr_,fast_image_data_)
    else
      RegPTProcB0(@BlurBGB4   ,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue184(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTProcA4(@BlurBGB4Dec,fast_image_data_ptr_,fast_image_data_)
    else
      RegPTProcB4(@BlurBGB4   ,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegPTValue181(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcA0(@BlurBGB4Dec,fast_image_data_ptr_,fast_image_data_)
          else
            RegPTProcB0(@BlurBGB4   ,fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC0(@BlurBGB4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        RegPTProcD0(@BlurBGB4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue185(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcA4(@BlurBGB4Dec,fast_image_data_ptr_,fast_image_data_)
          else
            RegPTProcB4(@BlurBGB4   ,fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC4(@BlurBGB4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        RegPTProcD4(@BlurBGB4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}

{BlurRBB}
// (constant) not clipped:
procedure TFastImageProc.RegPTValue190(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTProcA0(@BlurRBB4Dec,fast_image_data_ptr_,fast_image_data_)
    else
      RegPTProcB0(@BlurRBB4   ,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue194(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTProcA4(@BlurRBB4Dec,fast_image_data_ptr_,fast_image_data_)
    else
      RegPTProcB4(@BlurRBB4   ,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegPTValue191(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcA0(@BlurRBB4Dec,fast_image_data_ptr_,fast_image_data_)
          else
            RegPTProcB0(@BlurRBB4   ,fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC0(@BlurRBB4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        RegPTProcD0(@BlurRBB4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue195(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcA4(@BlurRBB4Dec,fast_image_data_ptr_,fast_image_data_)
          else
            RegPTProcB4(@BlurRBB4   ,fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC4(@BlurRBB4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        RegPTProcD4(@BlurRBB4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}

{BlurRRR}
// (constant) not clipped:
procedure TFastImageProc.RegPTValue200(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTProcA0(@BlurRRR4Dec,fast_image_data_ptr_,fast_image_data_)
    else
      RegPTProcB0(@BlurRRR4   ,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue204(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTProcA4(@BlurRRR4Dec,fast_image_data_ptr_,fast_image_data_)
    else
      RegPTProcB4(@BlurRRR4   ,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegPTValue201(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcA0(@BlurRRR4Dec,fast_image_data_ptr_,fast_image_data_)
          else
            RegPTProcB0(@BlurRRR4   ,fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC0(@BlurRRR4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        RegPTProcD0(@BlurRRR4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue205(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcA4(@BlurRRR4Dec,fast_image_data_ptr_,fast_image_data_)
          else
            RegPTProcB4(@BlurRRR4   ,fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC4(@BlurRRR4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        RegPTProcD4(@BlurRRR4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}

{BlurGGG}
// (constant) not clipped:
procedure TFastImageProc.RegPTValue210(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTProcA0(@BlurGGG4Dec,fast_image_data_ptr_,fast_image_data_)
    else
      RegPTProcB0(@BlurGGG4   ,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue214(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTProcA4(@BlurGGG4Dec,fast_image_data_ptr_,fast_image_data_)
    else
      RegPTProcB4(@BlurGGG4   ,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegPTValue211(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcA0(@BlurGGG4Dec,fast_image_data_ptr_,fast_image_data_)
          else
            RegPTProcB0(@BlurGGG4   ,fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC0(@BlurGGG4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        RegPTProcD0(@BlurGGG4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue215(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcA4(@BlurGGG4Dec,fast_image_data_ptr_,fast_image_data_)
          else
            RegPTProcB4(@BlurGGG4   ,fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC4(@BlurGGG4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        RegPTProcD4(@BlurGGG4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}

{BlurBBB}
// (constant) not clipped:
procedure TFastImageProc.RegPTValue220(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTProcA0(@BlurBBB4Dec,fast_image_data_ptr_,fast_image_data_)
    else
      RegPTProcB0(@BlurBBB4   ,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue224(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTProcA4(@BlurBBB4Dec,fast_image_data_ptr_,fast_image_data_)
    else
      RegPTProcB4(@BlurBBB4   ,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RegPTValue221(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcA0(@BlurBBB4Dec,fast_image_data_ptr_,fast_image_data_)
          else
            RegPTProcB0(@BlurBBB4   ,fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC0(@BlurBBB4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        RegPTProcD0(@BlurBBB4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue225(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      if (cfx_pow0=MAXBYTE) then
        begin
          if (not pt_as_nt) then
            RegPTProcA4(@BlurBBB4Dec,fast_image_data_ptr_,fast_image_data_)
          else
            RegPTProcB4(@BlurBBB4   ,fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      if (not pt_as_nt) then
        RegPTProcC4(@BlurBBB4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        RegPTProcD4(@BlurBBB4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}

{Contrast}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueE30(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
  contrast_pow      : integer;
  r                 : byte=128;
  g                 : byte=128;
  b                 : byte=128;
begin
  with fast_image_data_ do
    begin
      contrast_pow      :=FloatToFixed(1+cfx_pow0/10);
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr)^:=ContrastDec0(
                      pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,r,g,b,
              MAXBYTE-pt_pix_acl_arr_ptr^,contrast_pow);
              Inc    (pt_pix_sht_arr_ptr);
              Inc    (pt_pix_acl_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueF30(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  contrast_pow      : integer;
  r                 : byte=128;
  g                 : byte=128;
  b                 : byte=128;
begin
  with fast_image_data_ do
    begin
      contrast_pow      :=FloatToFixed(1+cfx_pow0/10);
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          for x:=0 to   pt_pix_cnt_arr_ptr^-1 do
            begin
              Contrast2(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,r,g,b,contrast_pow);
              Inc      (pt_pix_sht_arr_ptr);
            end;
          Inc          (pt_pix_cnt_arr_ptr);
          Inc   (first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.RegPTValue230(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueE30(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueF30(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.RegPTValueE34(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  contrast_pow      : integer;
  r                 : byte=128;
  g                 : byte=128;
  b                 : byte=128;
label
  label1;
begin
  with fast_image_data_ do
    begin
      contrast_pow      :=FloatToFixed(1+cfx_pow0/10);
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=ContrastDec0(
                                     pt_pix_sht_arr_ptr^*res_var8+v,r,g,b,
                      MAXBYTE-       pt_pix_acl_arr_ptr^,contrast_pow);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=ContrastDec0(
                                     pt_pix_sht_arr_ptr^*res_var8+v,r,g,b,
                      MAXBYTE-       pt_pix_acl_arr_ptr^,contrast_pow);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=ContrastDec0(
                                     pt_pix_sht_arr_ptr^*res_var8+v,r,g,b,
                      MAXBYTE-       pt_pix_acl_arr_ptr^,contrast_pow);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=ContrastDec0(
                                     pt_pix_sht_arr_ptr^*res_var8+v,r,g,b,
                      MAXBYTE-       pt_pix_acl_arr_ptr^,contrast_pow);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.RegPTValueF34(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  contrast_pow      : integer;
  r                 : byte=128;
  g                 : byte=128;
  b                 : byte=128;
label
  label1;
begin
  with fast_image_data_ do
    begin
      contrast_pow      :=FloatToFixed(1+cfx_pow0/10);
      RegPTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Contrast2     (pt_pix_sht_arr_ptr^*res_var8+v,r,g,b,contrast_pow);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Contrast2     (pt_pix_sht_arr_ptr^*res_var8+v,r,g,b,contrast_pow);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Contrast2     (pt_pix_sht_arr_ptr^*res_var8+v,r,g,b,contrast_pow);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      Contrast2     (pt_pix_sht_arr_ptr^*res_var8+v,r,g,b,contrast_pow);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RegPTValue234(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    if (not pt_as_nt) then
      RegPTValueE34(fast_image_data_ptr_,fast_image_data_)
    else
      RegPTValueF34(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (fading):
// same;

{$endregion}

{||scl_mul||<1: (SD - Scale Down)} {$region -fold}

{Empty}
procedure TFastImageProc.RSDPTValue009(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Monochrome}
// (constant) not clipped:
procedure TFastImageProc.RSDPTValue000(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTValue002(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue004(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTValue001(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTValue003(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue005(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Additive}
// (constant) not clipped:
procedure TFastImageProc.RSDPTValue010(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTValue012(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue014(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTValue011(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTValue013(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue015(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Alphablend}
// (constant) not clipped:
procedure TFastImageProc.RSDPTValue020(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTValue022(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue024(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTValue021(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTValue023(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue025(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Inverse}
// (constant) not clipped:
procedure TFastImageProc.RSDPTValue030(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTValue032(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue034(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTValue031(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTValue033(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue035(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Highlight}
// (constant) not clipped:
procedure TFastImageProc.RSDPTValue040(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTValue042(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue044(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTValue041(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTValue043(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue045(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Darken}
// (constant) not clipped:
procedure TFastImageProc.RSDPTValue050(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTValue052(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue054(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTValue051(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTValue053(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue055(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{GrayscaleR}
// (constant) not clipped:
procedure TFastImageProc.RSDPTValue060(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTValue062(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue064(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTValue061(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTValue063(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue065(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{GrayscaleG}
// (constant) not clipped:
procedure TFastImageProc.RSDPTValue070(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTValue072(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue074(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTValue071(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTValue073(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue075(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{GrayscaleB}
// (constant) not clipped:
procedure TFastImageProc.RSDPTValue080(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTValue082(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue084(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTValue081(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTValue083(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue085(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Monochrome Noise}
// (constant) not clipped:
procedure TFastImageProc.RSDPTValue090(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTValue092(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue094(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTValue091(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTValue093(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue095(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{ColorizeR}
// (constant) not clipped:
procedure TFastImageProc.RSDPTValue100(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTValue102(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue104(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTValue101(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTValue103(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue105(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{ColorizeG}
// (constant) not clipped:
procedure TFastImageProc.RSDPTValue110(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTValue112(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue114(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTValue111(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTValue113(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue115(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{ColorizeB}
// (constant) not clipped:
procedure TFastImageProc.RSDPTValue120(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTValue122(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue124(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTValue121(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTValue123(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue125(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurRGB}
// (constant) not clipped:
procedure TFastImageProc.RSDPTValue130(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTValue132(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue134(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTValue131(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTValue133(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue135(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurRRB}
// (constant) not clipped:
procedure TFastImageProc.RSDPTValue140(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTValue142(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue144(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTValue141(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTValue143(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue145(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurRGR}
// (constant) not clipped:
procedure TFastImageProc.RSDPTValue150(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTValue152(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue154(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTValue151(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTValue153(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue155(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurGGB}
// (constant) not clipped:
procedure TFastImageProc.RSDPTValue160(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTValue162(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue164(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTValue161(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTValue163(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue165(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurRGG}
// (constant) not clipped:
procedure TFastImageProc.RSDPTValue170(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTValue172(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue174(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTValue171(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTValue173(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue175(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurBGB}
// (constant) not clipped:
procedure TFastImageProc.RSDPTValue180(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTValue182(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue184(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTValue181(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTValue183(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue185(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurRBB}
// (constant) not clipped:
procedure TFastImageProc.RSDPTValue190(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTValue192(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue194(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTValue191(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTValue193(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue195(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurRRR}
// (constant) not clipped:
procedure TFastImageProc.RSDPTValue200(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTValue202(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue204(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTValue201(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTValue203(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue205(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurGGG}
// (constant) not clipped:
procedure TFastImageProc.RSDPTValue210(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTValue212(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue214(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTValue211(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTValue213(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue215(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurBBB}
// (constant) not clipped:
procedure TFastImageProc.RSDPTValue220(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTValue222(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue224(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTValue221(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTValue223(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue225(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Contrast}
// (constant) not clipped:
procedure TFastImageProc.RSDPTValue230(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSDPTValue232(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue234(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSDPTValue231(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSDPTValue233(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSDPTValue235(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{$endregion}

{||scl_mul||>1: (SU - Scale Up  )} {$region -fold}

{Empty}
procedure TFastImageProc.RSUPTValue009(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Monochrome}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue000(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTValue002(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue004(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUPTValue001(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTValue003(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue005(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Additive}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue010(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTValue012(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue014(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUPTValue011(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTValue013(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue015(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Alphablend}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue020(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTValue022(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue024(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUPTValue021(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTValue023(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue025(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Inverse}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue030(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTValue032(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue034(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUPTValue031(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTValue033(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue035(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Highlight}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue040(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTValue042(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue044(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUPTValue041(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTValue043(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue045(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Darken}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue050(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTValue052(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue054(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUPTValue051(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTValue053(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue055(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{GrayscaleR}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue060(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTValue062(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue064(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUPTValue061(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTValue063(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue065(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{GrayscaleG}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue070(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTValue072(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue074(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUPTValue071(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTValue073(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue075(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{GrayscaleB}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue080(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTValue082(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue084(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUPTValue081(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTValue083(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue085(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Monochrome Noise}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue090(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTValue092(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue094(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUPTValue091(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTValue093(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue095(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{ColorizeR}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue100(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTValue102(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue104(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUPTValue101(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTValue103(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue105(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{ColorizeG}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue110(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTValue112(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue114(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUPTValue111(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTValue113(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue115(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{ColorizeB}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue120(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTValue122(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue124(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUPTValue121(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTValue123(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue125(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurRGB}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue130(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTValue132(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue134(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue131(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTValue133(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue135(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurRRB}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue140(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTValue142(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue144(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUPTValue141(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTValue143(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue145(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurRGR}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue150(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTValue152(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue154(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUPTValue151(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTValue153(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue155(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurGGB}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue160(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTValue162(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue164(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUPTValue161(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTValue163(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue165(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurRGG}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue170(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTValue172(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue174(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUPTValue171(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTValue173(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue175(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurBGB}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue180(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTValue182(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue184(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUPTValue181(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTValue183(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue185(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurRBB}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue190(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTValue192(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue194(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUPTValue191(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTValue193(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue195(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurRRR}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue200(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTValue202(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue204(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUPTValue201(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTValue203(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue205(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurGGG}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue210(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTValue212(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue214(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUPTValue211(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTValue213(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue215(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{BlurBBB}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue220(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTValue222(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue224(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUPTValue221(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTValue223(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue225(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Contrast}
// (constant) not clipped:
procedure TFastImageProc.RSUPTValue230(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.RSUPTValue232(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue234(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) not clipped:
procedure TFastImageProc.RSUPTValue231(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) top-bottom clipped:
procedure TFastImageProc.RSUPTValue233(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading) left-right-top-bottom clipped:
procedure TFastImageProc.RSUPTValue235(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{$endregion}

{$endregion}

{$endregion}

{Gradient floodFill------------------------------------} {$region -fold}

// NT - not transparent pixels:

{Auxiliary procedures}
procedure TFastImageProc.GrVNTResVar0 (                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  dx   : integer;
  b0,b1: byte;
begin
  with fast_image_data_,grad_prop do
    begin
          y_grad_rng_div_vec.r:=grad_col0.r<<16;
          y_grad_rng_div_vec.g:=grad_col0.g<<16;
          y_grad_rng_div_vec.b:=grad_col0.b<<16;
          y_grad_rng_div_vec.a:=grad_col0.a<<16;
          grad_vec2.y         :=Min2(Min2(rct_ent.height-fast_image_data_ptr_^.nt_pix_arr_row_mrg_btm,grad_vec.y),rct_src.bottom);
          grad_vec2.x         :=Max2(Max2(               fast_image_data_ptr_^.nt_pix_arr_row_mrg_top,grad_vec.x),rct_src.top   );
          dx                  :=grad_vec2.x-grad_vec.x{-3};
      if (dx<>0) then
        begin
          y_grad_rng_div_vec.r+=dx*grad_rng_div_vec.r;
          y_grad_rng_div_vec.g+=dx*grad_rng_div_vec.g;
          y_grad_rng_div_vec.b+=dx*grad_rng_div_vec.b;
          y_grad_rng_div_vec.a+=dx*grad_rng_div_vec.a;
        end;
      b0                      :=Byte(img_inv_type in [0,1]);
      b1                      :=Byte(img_inv_type in [1,3]);
        res_var0              :=grad_vec2.x;
      if                       (fast_image_data_ptr_^.nt_cnt_ind_arr<>Nil) then
        res_var1              :=fast_image_data_ptr_^.nt_cnt_ind_arr[res_var0];
        res_var2              :=grad_vec2.y-grad_vec2.x-1;
        res_var3              :=2*b0-1;
        res_var4              :=res_var3*res_var0+b0*rct_ent.top+(1-b0)*(rct_ent.bottom-1);
        res_var5              :=res_var3*bmp_bkgnd_width;
        res_var6              :=rct_dst.left+b1*(rct_src.width-1);
        res_var7              :=res_var4*bmp_bkgnd_width+res_var6;
        res_var8              :=1-2*b1;
    end;
end; {$endregion}

{Color} {$region -fold}

{||scl_mul||=1:                  } {$region -fold}

{Empty}
procedure TFastImageProc.GrVNTColor009(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Color of Curent Layer(Additive)}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVNTColor010(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  nt_pix_ccl_arr_ptr: PInteger;
  x,y               : integer;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      nt_pix_ccl_arr_ptr:=                       nt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          pow:=y_grad_rng_div_vec.a>>16;
          for x:=0 to      nt_pix_cnt_arr_ptr^-1 do
            begin
              AdditiveDec1(nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
                           nt_pix_ccl_arr_ptr^,pow);

              Inc         (nt_pix_sht_arr_ptr);
              Inc         (nt_pix_ccl_arr_ptr);
            end;
          Inc             (nt_pix_cnt_arr_ptr);
          Inc      (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTColor014(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  nt_pix_ccl_arr_ptr: PInteger;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      nt_pix_ccl_arr_ptr:=                       nt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;
              pow              :=y_grad_rng_div_vec.a>>16;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  Inc               (nt_pix_ccl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AdditiveDec1  (nt_pix_sht_arr_ptr^*res_var8+v,
                                     nt_pix_ccl_arr_ptr^,pow);
                      Inc           (nt_pix_sht_arr_ptr);
                      Inc           (nt_pix_ccl_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr,c+1);
                  Inc               (nt_pix_ccl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AdditiveDec1  (nt_pix_sht_arr_ptr^*res_var8+v,
                                     nt_pix_ccl_arr_ptr^,pow);
                      Inc           (nt_pix_sht_arr_ptr);
                      Inc           (nt_pix_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AdditiveDec1  (nt_pix_sht_arr_ptr^*res_var8+v,
                                     nt_pix_ccl_arr_ptr^,pow);
                      Inc           (nt_pix_sht_arr_ptr);
                      Inc           (nt_pix_ccl_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      AdditiveDec1  (nt_pix_sht_arr_ptr^*res_var8+v,
                                     nt_pix_ccl_arr_ptr^,pow);
                      Inc           (nt_pix_sht_arr_ptr);
                      Inc           (nt_pix_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTColor016(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      case img_inv_type of
        0: PPGrVAdditive  (fast_image_data_ptr_^.bmp_color_ptr,
                           fast_image_data_ptr_^.bmp_bkgnd_ptr,
                           bmp_ftimg_width_origin{bmp_ftimg_width},
                           bmp_bkgnd_width,
                           rct_src,
                           PtBounds(res_var6,
                                    res_var4,
                                    rct_dst.width,
                                    res_var2+1),
                           grad_prop);
        1: PPGrVAdditiveX (fast_image_data_ptr_^.bmp_color_ptr,
                           fast_image_data_ptr_^.bmp_bkgnd_ptr,
                           bmp_ftimg_width_origin{bmp_ftimg_width},
                           bmp_bkgnd_width,
                           rct_src,
                           PtBounds(res_var6,
                                    res_var4,
                                    rct_dst.width,
                                    res_var2+1),
                           grad_prop);
        2: PPGrVAdditiveY (fast_image_data_ptr_^.bmp_color_ptr,
                           fast_image_data_ptr_^.bmp_bkgnd_ptr,
                           bmp_ftimg_width_origin{bmp_ftimg_width},
                           bmp_bkgnd_width,
                           rct_src,
                           PtBounds(res_var6,
                                    res_var4,
                                    rct_dst.width,
                                    res_var2+1),
                           grad_prop);
        3: PPGrVAdditiveXY(fast_image_data_ptr_^.bmp_color_ptr,
                           fast_image_data_ptr_^.bmp_bkgnd_ptr,
                           bmp_ftimg_width_origin{bmp_ftimg_width},
                           bmp_bkgnd_width,
                           rct_src,
                           PtBounds(res_var6,
                                    res_var4,
                                    rct_dst.width,
                                    res_var2+1),
                           grad_prop);
      end;
    end;
end; {$endregion}
// (fading):
// same;

{Color of Curent Layer(Alphablend)}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVNTColor020(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  nt_pix_ccl_arr_ptr: PInteger;
  x,y               : integer;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      nt_pix_ccl_arr_ptr:=                       nt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          pow:=MAXBYTE-(y_grad_rng_div_vec.a>>16);
          for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
            begin
              AlphaBlendDec1(nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
                             nt_pix_ccl_arr_ptr^,pow,0);
              Inc           (nt_pix_sht_arr_ptr);
              Inc           (nt_pix_ccl_arr_ptr);
            end;
          Inc               (nt_pix_cnt_arr_ptr);
          Inc        (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTColor024(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  nt_pix_ccl_arr_ptr: PInteger;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      nt_pix_ccl_arr_ptr:=                       nt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;
              pow              :=MAXBYTE-(y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  Inc               (nt_pix_ccl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AlphaBlendDec1(nt_pix_sht_arr_ptr^*res_var8+v,
                                     nt_pix_ccl_arr_ptr^,pow,0);
                      Inc           (nt_pix_sht_arr_ptr);
                      Inc           (nt_pix_ccl_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr,c+1);
                  Inc               (nt_pix_ccl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AlphaBlendDec1(nt_pix_sht_arr_ptr^*res_var8+v,
                                     nt_pix_ccl_arr_ptr^,pow,0);
                      Inc           (nt_pix_sht_arr_ptr);
                      Inc           (nt_pix_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AlphaBlendDec1(nt_pix_sht_arr_ptr^*res_var8+v,
                                     nt_pix_ccl_arr_ptr^,pow,0);
                      Inc           (nt_pix_sht_arr_ptr);
                      Inc           (nt_pix_ccl_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (nt_pix_ccl_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      AlphaBlendDec1(nt_pix_sht_arr_ptr^*res_var8+v,
                                     nt_pix_ccl_arr_ptr^,pow,0);
                      Inc           (nt_pix_sht_arr_ptr);
                      Inc           (nt_pix_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTColor026(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      GrVNTResVar0    (fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      case img_inv_type of
        0: PPGrVAlphaBlend  (fast_image_data_ptr_^.bmp_color_ptr,
                             fast_image_data_ptr_^.bmp_bkgnd_ptr,
                             bmp_ftimg_width_origin{bmp_ftimg_width},
                             bmp_bkgnd_width,
                             rct_src,
                             PtBounds(res_var6,
                                      res_var4,
                                      rct_dst.width,
                                      res_var2+1),
                             grad_prop);
        1: PPGrVAlphaBlendX (fast_image_data_ptr_^.bmp_color_ptr,
                             fast_image_data_ptr_^.bmp_bkgnd_ptr,
                             bmp_ftimg_width_origin{bmp_ftimg_width},
                             bmp_bkgnd_width,
                             rct_src,
                             PtBounds(res_var6,
                                      res_var4,
                                      rct_dst.width,
                                      res_var2+1),
                             grad_prop);
        2: PPGrVAlphaBlendY (fast_image_data_ptr_^.bmp_color_ptr,
                             fast_image_data_ptr_^.bmp_bkgnd_ptr,
                             bmp_ftimg_width_origin{bmp_ftimg_width},
                             bmp_bkgnd_width,
                             rct_src,
                             PtBounds(res_var6,
                                      res_var4,
                                      rct_dst.width,
                                      res_var2+1),
                             grad_prop);
        3: PPGrVAlphaBlendXY(fast_image_data_ptr_^.bmp_color_ptr,
                             fast_image_data_ptr_^.bmp_bkgnd_ptr,
                             bmp_ftimg_width_origin{bmp_ftimg_width},
                             bmp_bkgnd_width,
                             rct_src,
                             PtBounds(res_var6,
                                      res_var4,
                                      rct_dst.width,
                                      res_var2+1),
                             grad_prop);
      end;
    end;
end; {$endregion}
// (fading):
// same;

{$endregion}

{||scl_mul||<1: (SD - Scale Down)} {$region -fold}

{Empty}
procedure TFastImageProc.GSDNTColor009(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Color of Curent Layer(Additive)}
// (constant) not clipped:
procedure TFastImageProc.GSDNTColor010(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTColor012(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTColor014(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTColor016(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Color of Curent Layer(Alphablend)}
// (constant) not clipped:
procedure TFastImageProc.GSDNTColor020(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTColor022(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTColor024(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTColor026(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{$endregion}

{||scl_mul||>1: (SU - Scale Up  )} {$region -fold}

{Empty}
procedure TFastImageProc.GSUNTColor009(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Color of Curent Layer(Additive)}
// (constant) not clipped:
procedure TFastImageProc.GSUNTColor010(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTColor012(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTColor014(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTColor016(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Color of Curent Layer(Alphablend)}
// (constant) not clipped:
procedure TFastImageProc.GSUNTColor020(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTColor022(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTColor024(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTColor026(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{$endregion}

{$endregion}

{Value} {$region -fold}

{||scl_mul||=1:                  } {$region -fold}

{Auxiliary procedures}
// (constant) not clipped and top-bottom clipped:
procedure TFastImageProc.GrVNTValueA0 (Proc16:TProc16; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pow:=MAXBYTE-(y_grad_rng_div_vec.a>>16);
          for x:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
              Proc16 (nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,0,pow);
              Inc    (nt_pix_sht_arr_ptr);
            end;
          Inc        (nt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValueA4 (Proc16:TProc16; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;
              pow              :=MAXBYTE-(y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc16        (nt_pix_sht_arr_ptr^*res_var8+v,0,pow);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr, c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Proc16        (nt_pix_sht_arr_ptr^*res_var8+v,0,pow);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Proc16        (nt_pix_sht_arr_ptr^*res_var8+v,0,pow);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      Proc16        (nt_pix_sht_arr_ptr^*res_var8+v,0,pow);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) not clipped and top-bottom clipped:
procedure TFastImageProc.GrVNTValueB0 (Proc17:TProc17; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pow        :=MAXBYTE-(y_grad_rng_div_vec.a>>16);
          for x:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
              Proc17 (nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,pow);
              Inc    (nt_pix_sht_arr_ptr);
            end;
          Inc        (nt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValueB4 (Proc17:TProc17; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;
              pow              :=MAXBYTE-(y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc17        (nt_pix_sht_arr_ptr^*res_var8+v,pow);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr, c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Proc17        (nt_pix_sht_arr_ptr^*res_var8+v,pow);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Proc17        (nt_pix_sht_arr_ptr^*res_var8+v,pow);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      Proc17        (nt_pix_sht_arr_ptr^*res_var8+v,pow);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) not clipped and top-bottom clipped:
procedure TFastImageProc.GrVNTValueC0 (Proc18:TProc18; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pow:=y_grad_rng_div_vec.a>>16;
          for x:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
              Proc18 (nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,pow,0);
              Inc    (nt_pix_sht_arr_ptr);
            end;
          Inc        (nt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
         Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValueC4 (Proc18:TProc18; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;
              pow              :=y_grad_rng_div_vec.a>>16;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc18        (nt_pix_sht_arr_ptr^*res_var8+v,pow,0);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr, c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Proc18        (nt_pix_sht_arr_ptr^*res_var8+v,pow,0);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Proc18        (nt_pix_sht_arr_ptr^*res_var8+v,pow,0);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      Proc18        (nt_pix_sht_arr_ptr^*res_var8+v,pow,0);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) not clipped and top-bottom clipped:
procedure TFastImageProc.GrVNTValueD0 (Proc19:TProc19; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pow:=y_grad_rng_div_vec.a>>16;
          for x:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
              Proc19 (nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,bmp_bkgnd_width,pow);
              Inc    (nt_pix_sht_arr_ptr);
            end;
          Inc        (nt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValueD4 (Proc19:TProc19; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;
              pow              :=y_grad_rng_div_vec.a>>16;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc19        (nt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,pow);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr, c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Proc19        (nt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,pow);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Proc19        (nt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,pow);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      Proc19        (nt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,pow);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}

{Empty}
procedure TFastImageProc.GrVNTValue009(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Monochrome}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVNTValueA00(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  pix_row_val       : TColor;
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pix_row_val:=RGB(y_grad_rng_div_vec.b>>16,
                           y_grad_rng_div_vec.g>>16,
                           y_grad_rng_div_vec.r>>16);
          if       not ((nt_pix_cnt_arr_ptr^-4>=0) and
                       ((nt_pix_sht_arr_ptr+
                         nt_pix_cnt_arr_ptr^-1)^-
                         nt_pix_sht_arr_ptr^=
                         nt_pix_cnt_arr_ptr^-1)) then
            for x:=0 to  nt_pix_cnt_arr_ptr^-1 do
              begin
                        (nt_pix_sht_arr_ptr^+first_row_pix_ptr)^:=pix_row_val;
                Inc     (nt_pix_sht_arr_ptr);
              end
          else
            begin
              FillDWord((nt_pix_sht_arr_ptr^+first_row_pix_ptr)^,
                         nt_pix_cnt_arr_ptr^,pix_row_val);
              Inc       (nt_pix_sht_arr_ptr,
                         nt_pix_cnt_arr_ptr^);
            end;
          Inc           (nt_pix_cnt_arr_ptr);
          Inc    (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVNTValue000(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  pix_row_val       : TColor;
begin
  with fast_image_data_,grad_prop do
    begin
      if (img_inv_type in [0,2]) then
        begin
          GrVNTValueA00   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pix_row_val:=RGB(y_grad_rng_div_vec.b>>16,
                           y_grad_rng_div_vec.g>>16,
                           y_grad_rng_div_vec.r>>16);
            for x:=0 to nt_pix_cnt_arr_ptr^-1 do
              begin
                      (-nt_pix_sht_arr_ptr^+first_row_pix_ptr)^:=pix_row_val;
                Inc    (nt_pix_sht_arr_ptr);
              end;
          Inc          (nt_pix_cnt_arr_ptr);
          Inc   (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValueA04(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pix_row_val       : TColor;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;
              pix_row_val      :=RGB(y_grad_rng_div_vec.b>>16,
                                     y_grad_rng_div_vec.g>>16,
                                     y_grad_rng_div_vec.r>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left;
                  if           not ((c2-c1-4>=0) and
                                   ((nt_pix_sht_arr_ptr+
                                     c2-c1-1)^-
                                     nt_pix_sht_arr_ptr^=
                                     c2-c1-1)) then
                    for x:=0 to      c2-c1-1 do
                      begin
                                    (nt_pix_sht_arr_ptr^+v)^:=pix_row_val;
                        Inc         (nt_pix_sht_arr_ptr);
                      end
                  else
                    begin
                      FillDWord    ((nt_pix_sht_arr_ptr^+v)^,c2-c1,pix_row_val);
                      Inc           (nt_pix_sht_arr_ptr     ,c2-c1);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^   -(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr, c+1);
                  v:=first_row_pix_ptr-rct_src.left;
                  if           not ((nt_pix_cnt_arr_ptr^-c-5>=0) and
                                   ((nt_pix_sht_arr_ptr+
                                     nt_pix_cnt_arr_ptr^-c-2)^-
                                     nt_pix_sht_arr_ptr^=
                                     nt_pix_cnt_arr_ptr^-c-2)) then
                    for x:=0 to      nt_pix_cnt_arr_ptr^-c-2 do
                      begin
                                    (nt_pix_sht_arr_ptr^+v)^:=pix_row_val;
                        Inc         (nt_pix_sht_arr_ptr);
                      end
                  else
                    begin
                      FillDWord    ((nt_pix_sht_arr_ptr^+v)^,
                                     nt_pix_cnt_arr_ptr^-c-1,pix_row_val);
                      Inc           (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-c-1);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left;
                  if           not ((c-3>=0) and
                                   ((nt_pix_sht_arr_ptr +c)^-
                                     nt_pix_sht_arr_ptr^=c)) then
                    for x:=0 to c do
                      begin
                                    (nt_pix_sht_arr_ptr^+v)^:=pix_row_val;
                        Inc         (nt_pix_sht_arr_ptr);
                      end
                  else
                    begin
                      FillDWord    ((nt_pix_sht_arr_ptr^+v)^,c+1,pix_row_val);
                      Inc           (nt_pix_sht_arr_ptr,     c+1);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left;
                  if           not ((nt_pix_cnt_arr_ptr^-4>=0) and
                                   ((nt_pix_sht_arr_ptr+
                                     nt_pix_cnt_arr_ptr^-1)^-
                                     nt_pix_sht_arr_ptr^=
                                     nt_pix_cnt_arr_ptr^-1)) then
                    for x:=0 to      nt_pix_cnt_arr_ptr^-1 do
                      begin
                                    (nt_pix_sht_arr_ptr^+v)^:=pix_row_val;
                        Inc         (nt_pix_sht_arr_ptr);
                      end
                  else
                    begin
                      FillDWord    ((nt_pix_sht_arr_ptr^+v)^,
                                     nt_pix_cnt_arr_ptr^,pix_row_val);
                      Inc           (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVNTValue004(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pix_row_val       : TColor;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
      if (img_inv_type in [0,2]) then
        begin
          GrVNTValueA04   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;
              pix_row_val      :=RGB(y_grad_rng_div_vec.b>>16,
                                     y_grad_rng_div_vec.g>>16,
                                     y_grad_rng_div_vec.r>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr+rct_src.left;
                  for x:=0 to      c2-c1-1 do
                    begin
                                   (-nt_pix_sht_arr_ptr^+v)^:=pix_row_val;
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr, c+1);
                  v:=first_row_pix_ptr+rct_src.left;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                                   (-nt_pix_sht_arr_ptr^+v)^:=pix_row_val;
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr+rct_src.left;
                  for x:=0 to c do
                    begin
                                   (-nt_pix_sht_arr_ptr^+v)^:=pix_row_val;
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr+rct_src.left;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                                   (-nt_pix_sht_arr_ptr^+v)^:=pix_row_val;
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue006(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0   (fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrVMonochrome(fast_image_data_ptr_^.bmp_bkgnd_ptr,
                      bmp_bkgnd_width,
                      PtBounds(rct_dst.left ,grad_vec2.x+rct_ent.top,
                               rct_dst.width,grad_vec2.y-
                                             grad_vec2.x),
                      grad_prop);
    end;
end; {$endregion}
// (fading):
// same;

{Additive}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVNTValue010(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  pix_row_val       : TColor;
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pix_row_val:=RGBA(y_grad_rng_div_vec.r>>16,
                            y_grad_rng_div_vec.g>>16,
                            y_grad_rng_div_vec.b>>16,
                            y_grad_rng_div_vec.a>>16);
          for x:=0 to       nt_pix_cnt_arr_ptr^-1 do
            begin
              AdditiveDec2(nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,pix_row_val);
              Inc         (nt_pix_sht_arr_ptr);
            end;
          Inc             (nt_pix_cnt_arr_ptr);
          Inc      (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValue014(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pix_row_val       : TColor;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AdditiveDec2  (nt_pix_sht_arr_ptr^*res_var8+v,pix_row_val);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr, c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AdditiveDec2  (nt_pix_sht_arr_ptr^*res_var8+v,pix_row_val);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AdditiveDec2  (nt_pix_sht_arr_ptr^*res_var8+v,pix_row_val);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      AdditiveDec2  (nt_pix_sht_arr_ptr^*res_var8+v,pix_row_val);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue016(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0 (fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrVAdditive(fast_image_data_ptr_^.bmp_bkgnd_ptr,
                    bmp_bkgnd_width,
                    PtBounds(rct_dst.left ,grad_vec2.x+rct_ent.top,
                             rct_dst.width,grad_vec2.y-
                                           grad_vec2.x),
                    grad_prop);
    end;
end; {$endregion}
// (fading):
// same;

{AlphaBlend}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVNTValue020(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  pix_row_val       : TColor;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
      if (TRGBA(grad_col.x).a=$FF) and
         (TRGBA(grad_col.x).a=
          TRGBA(grad_col.y).a) then
        begin
          GrVNTValue000   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pix_row_val:=RGBA(y_grad_rng_div_vec.b>>16,
                            y_grad_rng_div_vec.g>>16,
                            y_grad_rng_div_vec.r>>16,
                            y_grad_rng_div_vec.a>>16);
          pow        :=MAXBYTE-TRGBA(pix_row_val).a;
          for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
            begin
              AlphaBlendDec1(nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,pix_row_val,pow,0);
              Inc           (nt_pix_sht_arr_ptr);
            end;
          Inc               (nt_pix_cnt_arr_ptr);
          Inc        (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValue024(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pix_row_val       : TColor;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
      if (TRGBA(grad_col.x).a=$FF) and
         (TRGBA(grad_col.x).a=
          TRGBA(grad_col.y).a) then
        begin
          GrVNTValue004   (fast_image_data_ptr_,fast_image_data_);
          Exit;
        end;
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.a>>16);
              pow              :=MAXBYTE-TRGBA(pix_row_val).a;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AlphaBlendDec1(nt_pix_sht_arr_ptr^*res_var8+v,pix_row_val,pow,0);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr, c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AlphaBlendDec1(nt_pix_sht_arr_ptr^*res_var8+v,pix_row_val,pow,0);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AlphaBlendDec1(nt_pix_sht_arr_ptr^*res_var8+v,pix_row_val,pow,0);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      AlphaBlendDec1(nt_pix_sht_arr_ptr^*res_var8+v,pix_row_val,pow,0);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue026(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0   (fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrVAlphaBlend(fast_image_data_ptr_^.bmp_bkgnd_ptr,
                      bmp_bkgnd_width,
                      PtBounds(rct_dst.left ,grad_vec2.x+rct_ent.top,
                               rct_dst.width,grad_vec2.y-
                                             grad_vec2.x),
                      grad_prop);
    end;
end; {$endregion}
// (fading):
// same;

{Inverse}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVNTValue030(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pow:=y_grad_rng_div_vec.a>>16;
          for x:=0 to     nt_pix_cnt_arr_ptr^-1 do
            begin
              InverseDec1(nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,pow);
              Inc        (nt_pix_sht_arr_ptr);
            end;
          Inc            (nt_pix_cnt_arr_ptr);
          Inc     (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValue034(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;
              pow              :=y_grad_rng_div_vec.a>>16;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      InverseDec1   (nt_pix_sht_arr_ptr^*res_var8+v,pow);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr, c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      InverseDec1   (nt_pix_sht_arr_ptr^*res_var8+v,pow);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      InverseDec1   (nt_pix_sht_arr_ptr^*res_var8+v,pow);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      InverseDec1   (nt_pix_sht_arr_ptr^*res_var8+v,pow);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue036(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0(fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrVInverse(fast_image_data_ptr_^.bmp_bkgnd_ptr,
                   bmp_bkgnd_width,
                   PtBounds(rct_dst.left ,grad_vec2.x+rct_ent.top,
                            rct_dst.width,grad_vec2.y-
                                          grad_vec2.x),
                   grad_prop);
    end;
end; {$endregion}
// (fading):
// same;

{Highlight}
// (constant) not clipped:
procedure TFastImageProc.GrVNTValue040(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueA0(@HighlightDec1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValue044(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueA4(@HighlightDec1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue046(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0(fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV16     (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                   bmp_bkgnd_width,
                   PtBounds(rct_dst.left ,grad_vec2.x+rct_ent.top,
                            rct_dst.width,grad_vec2.y-
                                          grad_vec2.x),
                   grad_prop,
                   @HighlightDec1);
    end;
end; {$endregion}
// (fading):
// same;

{Darken}
// (constant) not clipped:
procedure TFastImageProc.GrVNTValue050(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueA0(@DarkenDec1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValue054(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueA4(@DarkenDec1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue056(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0(fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV16     (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                   bmp_bkgnd_width,
                   PtBounds(rct_dst.left ,grad_vec2.x+rct_ent.top,
                            rct_dst.width,grad_vec2.y-
                                          grad_vec2.x),
                   grad_prop,
                   @DarkenDec1);
    end;
end; {$endregion}
// (fading):
// same;

{GrayscaleR}
// (constant) not clipped:
procedure TFastImageProc.GrVNTValue060(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueB0(@GrayscaleRDec1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValue064(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueB4(@GrayscaleRDec1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue066(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0(fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV17     (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                   bmp_bkgnd_width,
                   PtBounds(rct_dst.left ,grad_vec2.x+rct_ent.top,
                            rct_dst.width,grad_vec2.y-
                                          grad_vec2.x),
                   grad_prop,
                   @GrayscaleRDec1);
    end;
end; {$endregion}
// (fading):
// same;

{GrayscaleG}
// (constant) not clipped:
procedure TFastImageProc.GrVNTValue070(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueB0(@GrayscaleGDec1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValue074(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueB4(@GrayscaleGDec1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue076(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0(fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV17     (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                   bmp_bkgnd_width,
                   PtBounds(rct_dst.left ,grad_vec2.x+rct_ent.top,
                            rct_dst.width,grad_vec2.y-
                                          grad_vec2.x),
                   grad_prop,
                   @GrayscaleGDec1);
    end;
end; {$endregion}
// (fading):
// same;

{GrayscaleB}
// (constant) not clipped:
procedure TFastImageProc.GrVNTValue080(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueB0(@GrayscaleBDec1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValue084(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueB4(@GrayscaleBDec1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue086(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0(fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV17     (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                   bmp_bkgnd_width,
                   PtBounds(rct_dst.left ,grad_vec2.x+rct_ent.top,
                            rct_dst.width,grad_vec2.y-
                                          grad_vec2.x),
                   grad_prop,
                   @GrayscaleBDec1);
    end;
end; {$endregion}
// (fading):
// same;

{Monochrome Noise}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVNTValue090(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  pix_row_val       : TColor;
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pix_row_val:=RGB(y_grad_rng_div_vec.b>>16,
                           y_grad_rng_div_vec.g>>16,
                           y_grad_rng_div_vec.r>>16);
          for x:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
              if Odd((nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr)^) then
                     (nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr)^:=pix_row_val;
              Inc    (nt_pix_sht_arr_ptr);
            end;
          Inc        (nt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValue094(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pix_row_val       : TColor;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;
              pix_row_val      :=RGB(y_grad_rng_div_vec.b>>16,
                                     y_grad_rng_div_vec.g>>16,
                                     y_grad_rng_div_vec.r>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to      c2-c1-1 do
                    begin
                      if Odd       ((nt_pix_sht_arr_ptr^*res_var8+v)^) then
                                    (nt_pix_sht_arr_ptr^*res_var8+v)^:=pix_row_val;
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^   -(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr, c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      if Odd       ((nt_pix_sht_arr_ptr^*res_var8+v)^) then
                                    (nt_pix_sht_arr_ptr^*res_var8+v)^:=pix_row_val;
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      if Odd       ((nt_pix_sht_arr_ptr^*res_var8+v)^) then
                                    (nt_pix_sht_arr_ptr^*res_var8+v)^:=pix_row_val;
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                      if Odd       ((nt_pix_sht_arr_ptr^*res_var8+v)^) then
                                    (nt_pix_sht_arr_ptr^*res_var8+v)^:=pix_row_val;
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue096(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0  (fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrVMonoNoise(fast_image_data_ptr_^.bmp_bkgnd_ptr,
                     bmp_bkgnd_width,
                     PtBounds(rct_dst.left ,grad_vec2.x+rct_ent.top,
                              rct_dst.width,grad_vec2.y-
                                            grad_vec2.x),
                     grad_prop);
    end;
end; {$endregion}
// (fading):
// same;

{ColorizeR}
// (constant) not clipped:
procedure TFastImageProc.GrVNTValue100(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueC0(@ColorizeRDec1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValue104(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueC4(@ColorizeRDec1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue106(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0(fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV18     (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                   bmp_bkgnd_width,
                   PtBounds(rct_dst.left ,grad_vec2.x+rct_ent.top,
                            rct_dst.width,grad_vec2.y-
                                          grad_vec2.x),
                   grad_prop,
                   @ColorizeRDec1);
    end;
end; {$endregion}
// (fading):
// same;

{ColorizeG}
// (constant) not clipped:
procedure TFastImageProc.GrVNTValue110(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueC0(@ColorizeGDec1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValue114(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueC4(@ColorizeGDec1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue116(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0(fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV18     (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                   bmp_bkgnd_width,
                   PtBounds(rct_dst.left ,grad_vec2.x+rct_ent.top,
                            rct_dst.width,grad_vec2.y-
                                          grad_vec2.x),
                   grad_prop,
                   @ColorizeGDec1);
    end;
end; {$endregion}
// (fading):
// same;

{ColorizeB}
// (constant) not clipped:
procedure TFastImageProc.GrVNTValue120(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueC0(@ColorizeBDec1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValue124(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueC4(@ColorizeBDec1,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue126(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0(fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV18     (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                   bmp_bkgnd_width,
                   PtBounds(rct_dst.left ,grad_vec2.x+rct_ent.top,
                            rct_dst.width,grad_vec2.y-
                                          grad_vec2.x),
                   grad_prop,
                   @ColorizeBDec1);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRGB}
// (constant) not clipped:
procedure TFastImageProc.GrVNTValue130(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueD0(@BlurRGB4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValue134(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueD4(@BlurRGB4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue136(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0(fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV19     (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                   bmp_bkgnd_width,
                   PtBounds(rct_dst.left ,grad_vec2.x+rct_ent.top,
                            rct_dst.width,grad_vec2.y-
                                          grad_vec2.x),
                   grad_prop,
                   @BlurRGB4Dec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRRB}
// (constant) not clipped:
procedure TFastImageProc.GrVNTValue140(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueD0(@BlurRRB4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValue144(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueD4(@BlurRRB4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue146(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0(fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV19     (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                   bmp_bkgnd_width,
                   PtBounds(rct_dst.left ,grad_vec2.x+rct_ent.top,
                            rct_dst.width,grad_vec2.y-
                                          grad_vec2.x),
                   grad_prop,
                   @BlurRRB4Dec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRGR}
// (constant) not clipped:
procedure TFastImageProc.GrVNTValue150(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueD0(@BlurRGR4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValue154(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueD4(@BlurRGR4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue156(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0(fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV19     (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                   bmp_bkgnd_width,
                   PtBounds(rct_dst.left ,grad_vec2.x+rct_ent.top,
                            rct_dst.width,grad_vec2.y-
                                          grad_vec2.x),
                   grad_prop,
                   @BlurRGR4Dec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurGGB}
// (constant) not clipped:
procedure TFastImageProc.GrVNTValue160(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueD0(@BlurGGB4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValue164(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueD4(@BlurGGB4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue166(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0(fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV19     (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                   bmp_bkgnd_width,
                   PtBounds(rct_dst.left ,grad_vec2.x+rct_ent.top,
                            rct_dst.width,grad_vec2.y-
                                          grad_vec2.x),
                   grad_prop,
                   @BlurGGB4Dec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRGG}
// (constant) not clipped:
procedure TFastImageProc.GrVNTValue170(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueD0(@BlurRGG4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValue174(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueD4(@BlurRGG4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue176(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0(fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV19     (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                   bmp_bkgnd_width,
                   PtBounds(rct_dst.left ,grad_vec2.x+rct_ent.top,
                            rct_dst.width,grad_vec2.y-
                                          grad_vec2.x),
                   grad_prop,
                   @BlurRGG4Dec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurBGB}
// (constant) not clipped:
procedure TFastImageProc.GrVNTValue180(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueD0(@BlurBGB4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValue184(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueD4(@BlurBGB4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue186(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0(fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV19     (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                   bmp_bkgnd_width,
                   PtBounds(rct_dst.left ,grad_vec2.x+rct_ent.top,
                            rct_dst.width,grad_vec2.y-
                                          grad_vec2.x),
                   grad_prop,
                   @BlurBGB4Dec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRBB}
// (constant) not clipped:
procedure TFastImageProc.GrVNTValue190(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueD0(@BlurRBB4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValue194(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueD4(@BlurRBB4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue196(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0(fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV19     (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                   bmp_bkgnd_width,
                   PtBounds(rct_dst.left ,grad_vec2.x+rct_ent.top,
                            rct_dst.width,grad_vec2.y-
                                          grad_vec2.x),
                   grad_prop,
                   @BlurRBB4Dec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRRR}
// (constant) not clipped:
procedure TFastImageProc.GrVNTValue200(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueD0(@BlurRRR4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValue204(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueD4(@BlurRRR4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue206(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0(fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV19     (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                   bmp_bkgnd_width,
                   PtBounds(rct_dst.left ,grad_vec2.x+rct_ent.top,
                            rct_dst.width,grad_vec2.y-
                                          grad_vec2.x),
                   grad_prop,
                   @BlurRRR4Dec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurGGG}
// (constant) not clipped:
procedure TFastImageProc.GrVNTValue210(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueD0(@BlurGGG4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValue214(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueD4(@BlurGGG4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue216(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0(fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV19     (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                   bmp_bkgnd_width,
                   PtBounds(rct_dst.left ,grad_vec2.x+rct_ent.top,
                            rct_dst.width,grad_vec2.y-
                                          grad_vec2.x),
                   grad_prop,
                   @BlurGGG4Dec);
    end;
end; {$endregion}
// (fading):
// same;

{BlurBBB}
// (constant) not clipped:
procedure TFastImageProc.GrVNTValue220(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueD0(@BlurBBB4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValue224(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GrVNTValueD4(@BlurBBB4Dec,fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue226(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0(fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrV19     (fast_image_data_ptr_^.bmp_bkgnd_ptr,
                   bmp_bkgnd_width,
                   PtBounds(rct_dst.left ,grad_vec2.x+rct_ent.top,
                            rct_dst.width,grad_vec2.y-
                                          grad_vec2.x),
                   grad_prop,
                   @BlurBBB4Dec);
    end;
end; {$endregion}
// (fading):
// same;

{Contrast}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVNTValue230(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  pix_const_val     : TColor;
  contrast_pow      : integer;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
      pix_const_val     :=RGB(128,128,128);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pow         :=y_grad_rng_div_vec.a>>16;
          contrast_pow:=FloatToFixed(1+(MAXBYTE-pow)/10);
          for x:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
                     (nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr)^:=ContrastDec1(
                     (nt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr)^,pix_const_val,pow,contrast_pow);
              Inc    (nt_pix_sht_arr_ptr);
            end;
          Inc        (nt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVNTValue234(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pix_const_val     : TColor;
  contrast_pow      : integer;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0        (fast_image_data_ptr_,fast_image_data_);
      pix_const_val     :=RGB(128,128,128);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      nt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.nt_pix_cnt_arr[res_var0];
      nt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.nt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (nt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;
              pow              :=y_grad_rng_div_vec.a>>16;
              contrast_pow     :=FloatToFixed(1+(MAXBYTE-pow)/10);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (nt_pix_sht_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (nt_pix_sht_arr_ptr^*res_var8+v)^:=ContrastDec1(
                                    (nt_pix_sht_arr_ptr^*res_var8+v)^,pix_const_val,pow,contrast_pow);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (nt_pix_sht_arr_ptr, c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-c-2 do
                    begin
                                    (nt_pix_sht_arr_ptr^*res_var8+v)^:=ContrastDec1(
                                    (nt_pix_sht_arr_ptr^*res_var8+v)^,pix_const_val,pow,contrast_pow);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                     nt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                                    (nt_pix_sht_arr_ptr^*res_var8+v)^:=ContrastDec1(
                                    (nt_pix_sht_arr_ptr^*res_var8+v)^,pix_const_val,pow,contrast_pow);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                  Inc               (nt_pix_sht_arr_ptr,
                                     nt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        nt_pix_cnt_arr_ptr^-1 do
                    begin
                                    (nt_pix_sht_arr_ptr^*res_var8+v)^:=ContrastDec1(
                                    (nt_pix_sht_arr_ptr^*res_var8+v)^,pix_const_val,pow,contrast_pow);
                      Inc           (nt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GrVNTValue236(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVNTResVar0 (fast_image_data_ptr_,fast_image_data_);
      if (grad_vec2.y<=grad_vec2.x) then
        Exit;
      PPGrVContrast(fast_image_data_ptr_^.bmp_bkgnd_ptr,
                    bmp_bkgnd_width,
                    PtBounds(rct_dst.left ,grad_vec2.x+rct_ent.top,
                             rct_dst.width,grad_vec2.y-
                                           grad_vec2.x),
                    grad_prop);
    end;
end; {$endregion}
// (fading):
// same;

{$endregion}

{||scl_mul||<1: (SD - Scale Down)} {$region -fold}

{Empty}
procedure TFastImageProc.GSDNTValue009(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Monochrome}
// (constant) not clipped:
procedure TFastImageProc.GSDNTValue000(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTValue002(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTValue004(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTValue006(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Additive}
// (constant) not clipped:
procedure TFastImageProc.GSDNTValue010(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTValue012(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTValue014(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTValue016(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Alphablend}
// (constant) not clipped:
procedure TFastImageProc.GSDNTValue020(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTValue022(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTValue024(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTValue026(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Inverse}
// (constant) not clipped:
procedure TFastImageProc.GSDNTValue030(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTValue032(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTValue034(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTValue036(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Highlight}
// (constant) not clipped:
procedure TFastImageProc.GSDNTValue040(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTValue042(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTValue044(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTValue046(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Darken}
// (constant) not clipped:
procedure TFastImageProc.GSDNTValue050(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTValue052(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTValue054(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTValue056(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{GrayscaleR}
// (constant) not clipped:
procedure TFastImageProc.GSDNTValue060(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTValue062(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTValue064(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTValue066(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{GrayscaleG}
// (constant) not clipped:
procedure TFastImageProc.GSDNTValue070(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTValue072(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTValue074(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTValue076(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{GrayscaleB}
// (constant) not clipped:
procedure TFastImageProc.GSDNTValue080(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTValue082(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTValue084(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTValue086(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Monochrome Noise}
// (constant) not clipped:
procedure TFastImageProc.GSDNTValue090(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTValue092(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTValue094(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTValue096(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{ColorizeR}
// (constant) not clipped:
procedure TFastImageProc.GSDNTValue100(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTValue102(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTValue104(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTValue106(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{ColorizeG}
// (constant) not clipped:
procedure TFastImageProc.GSDNTValue110(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTValue112(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTValue114(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTValue116(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{ColorizeB}
// (constant) not clipped:
procedure TFastImageProc.GSDNTValue120(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTValue122(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTValue124(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTValue126(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurRGB}
// (constant) not clipped:
procedure TFastImageProc.GSDNTValue130(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTValue132(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTValue134(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTValue136(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurRRB}
// (constant) not clipped:
procedure TFastImageProc.GSDNTValue140(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTValue142(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTValue144(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTValue146(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurRGR}
// (constant) not clipped:
procedure TFastImageProc.GSDNTValue150(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTValue152(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTValue154(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTValue156(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurGGB}
// (constant) not clipped:
procedure TFastImageProc.GSDNTValue160(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTValue162(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTValue164(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTValue166(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurRGG}
// (constant) not clipped:
procedure TFastImageProc.GSDNTValue170(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTValue172(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTValue174(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTValue176(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurBGB}
// (constant) not clipped:
procedure TFastImageProc.GSDNTValue180(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTValue182(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTValue184(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTValue186(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurRBB}
// (constant) not clipped:
procedure TFastImageProc.GSDNTValue190(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTValue192(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTValue194(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTValue196(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurRRR}
// (constant) not clipped:
procedure TFastImageProc.GSDNTValue200(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTValue202(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTValue204(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTValue206(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurGGG}
// (constant) not clipped:
procedure TFastImageProc.GSDNTValue210(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTValue212(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTValue214(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTValue216(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurBBB}
// (constant) not clipped:
procedure TFastImageProc.GSDNTValue220(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTValue222(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTValue224(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTValue226(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Contrast}
// (constant) not clipped:
procedure TFastImageProc.GSDNTValue230(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDNTValue232(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDNTValue234(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSDNTValue236(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{$endregion}

{||scl_mul||>1: (SU - Scale Up  )} {$region -fold}

{Empty}
procedure TFastImageProc.GSUNTValue009(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Monochrome}
// (constant) not clipped:
procedure TFastImageProc.GSUNTValue000(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTValue002(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTValue004(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTValue006(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Additive}
// (constant) not clipped:
procedure TFastImageProc.GSUNTValue010(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTValue012(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTValue014(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTValue016(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Alphablend}
// (constant) not clipped:
procedure TFastImageProc.GSUNTValue020(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTValue022(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTValue024(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTValue026(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Inverse}
// (constant) not clipped:
procedure TFastImageProc.GSUNTValue030(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTValue032(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTValue034(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTValue036(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Highlight}
// (constant) not clipped:
procedure TFastImageProc.GSUNTValue040(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTValue042(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTValue044(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTValue046(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Darken}
// (constant) not clipped:
procedure TFastImageProc.GSUNTValue050(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTValue052(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTValue054(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTValue056(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{GrayscaleR}
// (constant) not clipped:
procedure TFastImageProc.GSUNTValue060(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTValue062(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTValue064(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTValue066(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{GrayscaleG}
// (constant) not clipped:
procedure TFastImageProc.GSUNTValue070(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTValue072(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTValue074(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTValue076(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{GrayscaleB}
// (constant) not clipped:
procedure TFastImageProc.GSUNTValue080(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTValue082(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTValue084(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTValue086(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Monochrome Noise}
// (constant) not clipped:
procedure TFastImageProc.GSUNTValue090(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTValue092(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTValue094(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTValue096(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{ColorizeR}
// (constant) not clipped:
procedure TFastImageProc.GSUNTValue100(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTValue102(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTValue104(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTValue106(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{ColorizeG}
// (constant) not clipped:
procedure TFastImageProc.GSUNTValue110(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTValue112(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTValue114(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTValue116(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{ColorizeB}
// (constant) not clipped:
procedure TFastImageProc.GSUNTValue120(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTValue122(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTValue124(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTValue126(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurRGB}
// (constant) not clipped:
procedure TFastImageProc.GSUNTValue130(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTValue132(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTValue134(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTValue136(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurRRB}
// (constant) not clipped:
procedure TFastImageProc.GSUNTValue140(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTValue142(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTValue144(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTValue146(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurRGR}
// (constant) not clipped:
procedure TFastImageProc.GSUNTValue150(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTValue152(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTValue154(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTValue156(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurGGB}
// (constant) not clipped:
procedure TFastImageProc.GSUNTValue160(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTValue162(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTValue164(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTValue166(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurRGG}
// (constant) not clipped:
procedure TFastImageProc.GSUNTValue170(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTValue172(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTValue174(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTValue176(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurBGB}
// (constant) not clipped:
procedure TFastImageProc.GSUNTValue180(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTValue182(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTValue184(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTValue186(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurRBB}
// (constant) not clipped:
procedure TFastImageProc.GSUNTValue190(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTValue192(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTValue194(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTValue196(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurRRR}
// (constant) not clipped:
procedure TFastImageProc.GSUNTValue200(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTValue202(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTValue204(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTValue206(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurGGG}
// (constant) not clipped:
procedure TFastImageProc.GSUNTValue210(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTValue212(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTValue214(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTValue216(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurBBB}
// (constant) not clipped:
procedure TFastImageProc.GSUNTValue220(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTValue222(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTValue224(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTValue226(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Contrast}
// (constant) not clipped:
procedure TFastImageProc.GSUNTValue230(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUNTValue232(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUNTValue234(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) image has monochrome color channel:
procedure TFastImageProc.GSUNTValue236(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{$endregion}

{$endregion}

// PT - partly transparent pixels:

{Auxiliary procedures}
procedure TFastImageProc.GrVPTResVar0 (                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  dx   : integer;
  b0,b1: byte;
begin
  with fast_image_data_,grad_prop do
    begin
          y_grad_rng_div_vec.r:=grad_col0.r<<16;
          y_grad_rng_div_vec.g:=grad_col0.g<<16;
          y_grad_rng_div_vec.b:=grad_col0.b<<16;
          y_grad_rng_div_vec.a:=grad_col0.a<<16;
          grad_vec2.y         :=Min2(Min2(rct_ent.height-fast_image_data_ptr_^.pt_pix_arr_row_mrg_btm,grad_vec.y),rct_src.bottom);
          grad_vec2.x         :=Max2(Max2(               fast_image_data_ptr_^.pt_pix_arr_row_mrg_top,grad_vec.x),rct_src.top   );
          dx                  :=grad_vec2.x-grad_vec.x{-3};
      if (dx<>0) then
        begin
          y_grad_rng_div_vec.r+=dx*grad_rng_div_vec.r;
          y_grad_rng_div_vec.g+=dx*grad_rng_div_vec.g;
          y_grad_rng_div_vec.b+=dx*grad_rng_div_vec.b;
          y_grad_rng_div_vec.a+=dx*grad_rng_div_vec.a;
        end;
      b0                      :=Byte(img_inv_type in [0,1]);
      b1                      :=Byte(img_inv_type in [1,3]);
      res_var0                :=grad_vec2.x;
      res_var1                :=fast_image_data_ptr_^.pt_cnt_ind_arr[res_var0];
      res_var2                :=grad_vec2.y-grad_vec2.x-1;
      res_var3                :=2*b0-1;
      res_var4                :=res_var3*res_var0+b0*rct_ent.top+(1-b0)*(rct_ent.bottom-1);
      res_var5                :=res_var3*bmp_bkgnd_width;
      res_var6                :=rct_dst.left+b1*(rct_src.width-1);
      res_var7                :=res_var4*bmp_bkgnd_width+res_var6;
      res_var8                :=1-2*b1;
    end;
end; {$endregion}

{Color} {$region -fold}

{||scl_mul||=1:                  } {$region -fold}

{Empty}
procedure TFastImageProc.GrVPTColor009(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Color of Curent Layer(Additive)}
// (constant) auxiliary procedures:
procedure TFastImageProc.GrVPTColorA10(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  x,y               : integer;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          pow:=y_grad_rng_div_vec.a>>16;
          for x:=0 to            pt_pix_cnt_arr_ptr^-1 do
            begin
              AdditiveDec1      (pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
                                 pt_pix_ccl_arr_ptr^,
              MAXBYTE-Max2(TRGBA(pt_pix_ccl_arr_ptr^).a-pow,0));
              Inc               (pt_pix_sht_arr_ptr);
              Inc               (pt_pix_ccl_arr_ptr);
            end;
          Inc                   (pt_pix_cnt_arr_ptr);
          Inc            (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTColorB10(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  x,y               : integer;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          pow:=y_grad_rng_div_vec.a>>16;
          for x:=0 to      pt_pix_cnt_arr_ptr^-1 do
            begin
              AdditiveDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
                           pt_pix_ccl_arr_ptr^,pow);
              Inc         (pt_pix_sht_arr_ptr);
              Inc         (pt_pix_ccl_arr_ptr);
            end;
          Inc             (pt_pix_cnt_arr_ptr);
          Inc      (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.GrVPTColor010(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0 (fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTColorA10(fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTColorB10(fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.GrVPTColorA14(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;
              pow              :=y_grad_rng_div_vec.a>>16;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_ccl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,MAXBYTE-
                      Max2    (TRGBA(pt_pix_ccl_arr_ptr^).a-pow,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_ccl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,MAXBYTE-
                      Max2    (TRGBA(pt_pix_ccl_arr_ptr^).a-pow,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,MAXBYTE-
                      Max2    (TRGBA(pt_pix_ccl_arr_ptr^).a-pow,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,MAXBYTE-
                      Max2    (TRGBA(pt_pix_ccl_arr_ptr^).a-pow,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTColorB14(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;
              pow              :=y_grad_rng_div_vec.a>>16;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_ccl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,pow);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_ccl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,pow);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,pow);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,pow);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTColor014(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
        GrVPTResVar0 (fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTColorA14(fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTColorB14(fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{Color of Curent Layer(Alphablend)}
// (constant) auxiliary procedures:
procedure TFastImageProc.GrVPTColorA20(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  x,y               : integer;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          pow:=(y_grad_rng_div_vec.a>>16);
          for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
            begin
              AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
                             pt_pix_ccl_arr_ptr^,
              TRGBA         (pt_pix_ccl_arr_ptr^).a,pow);
              Inc           (pt_pix_sht_arr_ptr);
              Inc           (pt_pix_ccl_arr_ptr);
            end;
          Inc               (pt_pix_cnt_arr_ptr);
          Inc        (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTColorB20(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  x,y               : integer;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          pow:=MAXBYTE-(y_grad_rng_div_vec.a>>16);
          for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
            begin
              AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
                             pt_pix_ccl_arr_ptr^,pow,0);
              Inc           (pt_pix_sht_arr_ptr);
              Inc           (pt_pix_ccl_arr_ptr);
            end;
          Inc               (pt_pix_cnt_arr_ptr);
          Inc        (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.GrVPTColor020(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
        GrVPTResVar0 (fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTColorA20(fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTColorB20(fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) auxiliary procedures:
procedure TFastImageProc.GrVPTColorA24(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;
              pow              :=y_grad_rng_div_vec.a>>16;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_ccl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,
                      TRGBA         (pt_pix_ccl_arr_ptr^).a,pow);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_ccl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,
                      TRGBA         (pt_pix_ccl_arr_ptr^).a,pow);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,
                      TRGBA         (pt_pix_ccl_arr_ptr^).a,pow);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,
                      TRGBA         (pt_pix_ccl_arr_ptr^).a,pow);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTColorB24(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_ccl_arr_ptr: PInteger;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_ccl_arr_ptr:=                       pt_pix_arr_ptr+res_var1;
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;
              pow              :=MAXBYTE-(y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_ccl_arr_ptr,c1+1);
                  v :=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,pow,0);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_ccl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,pow,0);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,pow,0);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_ccl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+v,
                                     pt_pix_ccl_arr_ptr^,pow,0);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_ccl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTColor024(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
        GrVPTResVar0 (fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTColorA24(fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTColorB24(fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{$endregion}

{||scl_mul||<1: (SD - Scale Down)} {$region -fold}

{Empty}
procedure TFastImageProc.GSDPTColor009(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Color of Curent Layer(Additive)}
// (constant) not clipped:
procedure TFastImageProc.GSDPTColor010(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTColor012(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTColor014(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Color of Curent Layer(Alphablend)}
// (constant) not clipped:
procedure TFastImageProc.GSDPTColor020(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTColor022(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTColor024(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{$endregion}

{||scl_mul||>1: (SU - Scale Up  )} {$region -fold}

{Empty}
procedure TFastImageProc.GSUPTColor009(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Color of Curent Layer(Additive)}
// (constant) not clipped:
procedure TFastImageProc.GSUPTColor010(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTColor012(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTColor014(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Color of Curent Layer(Alphablend)}
// (constant) not clipped:
procedure TFastImageProc.GSUPTColor020(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTColor022(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTColor024(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{$endregion}

{$endregion}

{Value} {$region -fold}

{||scl_mul||=1:                  } {$region -fold}

{Auxiliary procedures}
// (constant) not clipped and top-bottom clipped:
procedure TFastImageProc.GrVPTValueA0 (Proc16:TProc16; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pow:=MAXBYTE-(y_grad_rng_div_vec.a>>16);
          for x:=0 to  pt_pix_cnt_arr_ptr^-1 do
            begin
              Proc16  (pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
              MAXBYTE-(pt_pix_acl_arr_ptr^),pow);
              Inc     (pt_pix_sht_arr_ptr);
              Inc     (pt_pix_acl_arr_ptr);
            end;
          Inc         (pt_pix_cnt_arr_ptr);
          Inc  (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueB0 (Proc16:TProc16; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pow:=MAXBYTE-(y_grad_rng_div_vec.a>>16);
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
              Proc16 (pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,0,pow);
              Inc    (pt_pix_sht_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValueA4 (Proc16:TProc16; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;
              pow              :=MAXBYTE-(y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc16        (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-      (pt_pix_acl_arr_ptr^),pow);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Proc16        (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-      (pt_pix_acl_arr_ptr^),pow);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Proc16        (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-      (pt_pix_acl_arr_ptr^),pow);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      Proc16        (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-      (pt_pix_acl_arr_ptr^),pow);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueB4 (Proc16:TProc16; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;
              pow              :=MAXBYTE-(y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc16        (pt_pix_sht_arr_ptr^*res_var8+v,0,pow);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Proc16        (pt_pix_sht_arr_ptr^*res_var8+v,0,pow);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Proc16        (pt_pix_sht_arr_ptr^*res_var8+v,0,pow);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      Proc16        (pt_pix_sht_arr_ptr^*res_var8+v,0,pow);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) not clipped and top-bottom clipped:
procedure TFastImageProc.GrVPTValueC0 (Proc17:TProc17; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pow:=y_grad_rng_div_vec.a>>16;
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
              Proc17 (pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
              Max2   (pt_pix_acl_arr_ptr^-pow,0));
              Inc    (pt_pix_sht_arr_ptr);
              Inc    (pt_pix_acl_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueD0 (Proc17:TProc17; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pow:=MAXBYTE-(y_grad_rng_div_vec.a>>16);
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
              Proc17 (pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,pow);
              Inc    (pt_pix_sht_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValueC4 (Proc17:TProc17; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;
              pow              :=y_grad_rng_div_vec.a>>16;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc17        (pt_pix_sht_arr_ptr^*res_var8+v,
                      Max2          (pt_pix_acl_arr_ptr^-pow,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Proc17        (pt_pix_sht_arr_ptr^*res_var8+v,
                      Max2          (pt_pix_acl_arr_ptr^-pow,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Proc17        (pt_pix_sht_arr_ptr^*res_var8+v,
                      Max2          (pt_pix_acl_arr_ptr^-pow,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      Proc17        (pt_pix_sht_arr_ptr^*res_var8+v,
                      Max2          (pt_pix_acl_arr_ptr^-pow,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueD4 (Proc17:TProc17; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;
              pow              :=MAXBYTE-(y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc17        (pt_pix_sht_arr_ptr^*res_var8+v,pow);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Proc17        (pt_pix_sht_arr_ptr^*res_var8+v,pow);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Proc17        (pt_pix_sht_arr_ptr^*res_var8+v,pow);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      Proc17        (pt_pix_sht_arr_ptr^*res_var8+v,pow);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) not clipped and top-bottom clipped:
procedure TFastImageProc.GrVPTValueE0 (Proc18:TProc18; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pow:=y_grad_rng_div_vec.a>>16;
          for x:=0 to      pt_pix_cnt_arr_ptr^-1 do
            begin
              Proc18      (pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
              MAXBYTE-Max2(pt_pix_acl_arr_ptr^-pow,0),0);
              Inc         (pt_pix_sht_arr_ptr);
              Inc         (pt_pix_acl_arr_ptr);
            end;
          Inc             (pt_pix_cnt_arr_ptr);
          Inc      (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueF0 (Proc18:TProc18; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pow:=y_grad_rng_div_vec.a>>16;
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
              Proc18 (pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,pow,0);
              Inc    (pt_pix_sht_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValueE4 (Proc18:TProc18; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;
              pow              :=y_grad_rng_div_vec.a>>16;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc18        (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-  Max2(pt_pix_acl_arr_ptr^-pow,0),0);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Proc18        (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-  Max2(pt_pix_acl_arr_ptr^-pow,0),0);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Proc18        (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-  Max2(pt_pix_acl_arr_ptr^-pow,0),0);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      Proc18        (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE-  Max2(pt_pix_acl_arr_ptr^-pow,0),0);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueF4 (Proc18:TProc18; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;
              pow              :=y_grad_rng_div_vec.a>>16;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc18        (pt_pix_sht_arr_ptr^*res_var8+v,pow,0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Proc18        (pt_pix_sht_arr_ptr^*res_var8+v,pow,0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Proc18        (pt_pix_sht_arr_ptr^*res_var8+v,pow,0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      Proc18        (pt_pix_sht_arr_ptr^*res_var8+v,pow,0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) not clipped and top-bottom clipped:
procedure TFastImageProc.GrVPTValueG0 (Proc19:TProc19; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pow:=y_grad_rng_div_vec.a>>16;
          for x:=0 to      pt_pix_cnt_arr_ptr^-1 do
            begin
              Proc19      (pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,bmp_bkgnd_width,
              MAXBYTE-Max2(pt_pix_acl_arr_ptr^-pow,0));
              Inc         (pt_pix_sht_arr_ptr);
              Inc         (pt_pix_acl_arr_ptr);
            end;
          Inc             (pt_pix_cnt_arr_ptr);
          Inc      (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueH0 (Proc19:TProc19; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pow:=y_grad_rng_div_vec.a>>16;
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
              Proc19 (pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,bmp_bkgnd_width,pow);
              Inc    (pt_pix_sht_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValueG4 (Proc19:TProc19; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;
              pow              :=y_grad_rng_div_vec.a>>16;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc19        (pt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,
                      MAXBYTE-  Max2(pt_pix_acl_arr_ptr^-pow,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Proc19        (pt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,
                      MAXBYTE-  Max2(pt_pix_acl_arr_ptr^-pow,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Proc19        (pt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,
                      MAXBYTE-  Max2(pt_pix_acl_arr_ptr^-pow,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      Proc19        (pt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,
                      MAXBYTE-  Max2(pt_pix_acl_arr_ptr^-pow,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueH4 (Proc19:TProc19; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;
              pow              :=y_grad_rng_div_vec.a>>16;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      Proc19        (pt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,pow);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      Proc19        (pt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,pow);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      Proc19        (pt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,pow);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      Proc19        (pt_pix_sht_arr_ptr^*res_var8+v,bmp_bkgnd_width,pow);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}

{Empty}
procedure TFastImageProc.GrVPTValue009(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Monochrome}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueA00(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
  pix_row_val       : TColor;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pix_row_val:=RGB(y_grad_rng_div_vec.b>>16,
                           y_grad_rng_div_vec.g>>16,
                           y_grad_rng_div_vec.r>>16);
          for x:=0 to     pt_pix_cnt_arr_ptr^-1 do
            begin
              AlphaBlend2(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,pix_row_val,
                          pt_pix_acl_arr_ptr^);
              Inc        (pt_pix_sht_arr_ptr);
              Inc        (pt_pix_acl_arr_ptr);
            end;
          Inc            (pt_pix_cnt_arr_ptr);
          Inc     (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueB00(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  pix_row_val       : TColor;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pix_row_val:=RGB(y_grad_rng_div_vec.b>>16,
                           y_grad_rng_div_vec.g>>16,
                           y_grad_rng_div_vec.r>>16);
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr)^:=pix_row_val;
              Inc    (pt_pix_sht_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.GrVPTValue000(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0 (fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueA00(fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueB00(fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueA04(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pix_row_val       : TColor;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;
              pix_row_val      :=RGB(y_grad_rng_div_vec.b>>16,
                                     y_grad_rng_div_vec.g>>16,
                                     y_grad_rng_div_vec.r>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AlphaBlend2   (pt_pix_sht_arr_ptr^*res_var8+v,pix_row_val,
                                     pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AlphaBlend2   (pt_pix_sht_arr_ptr^*res_var8+v,pix_row_val,
                                     pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AlphaBlend2   (pt_pix_sht_arr_ptr^*res_var8+v,pix_row_val,
                                     pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      AlphaBlend2   (pt_pix_sht_arr_ptr^*res_var8+v,pix_row_val,
                                     pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueB04(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pix_row_val       : TColor;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;
              pix_row_val      :=RGB(y_grad_rng_div_vec.b>>16,
                                     y_grad_rng_div_vec.g>>16,
                                     y_grad_rng_div_vec.r>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=pix_row_val;
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=pix_row_val;
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=pix_row_val;
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=pix_row_val;
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValue004(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0 (fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueA04(fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueB04(fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{Additive}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueA10(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
  pix_row_val       : TColor;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pix_row_val:=RGBA(y_grad_rng_div_vec.b>>16,
                            y_grad_rng_div_vec.g>>16,
                            y_grad_rng_div_vec.r>>16,
                            y_grad_rng_div_vec.a>>16);
          for x:=0 to      pt_pix_cnt_arr_ptr^-1 do
            begin
              AdditiveDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,(pix_row_val),
              MAXBYTE-Max2(pt_pix_acl_arr_ptr^-                      TRGBA(pix_row_val).a,0));
              Inc         (pt_pix_sht_arr_ptr);
              Inc         (pt_pix_acl_arr_ptr);
            end;
          Inc             (pt_pix_cnt_arr_ptr);
          Inc      (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueB10(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  pix_row_val       : TColor;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pix_row_val  :=RGBA(y_grad_rng_div_vec.r>>16,
                              y_grad_rng_div_vec.g>>16,
                              y_grad_rng_div_vec.b>>16,
                              y_grad_rng_div_vec.a>>16);
          for x:=0 to      pt_pix_cnt_arr_ptr^-1 do
            begin
              AdditiveDec2(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,pix_row_val);
              Inc         (pt_pix_sht_arr_ptr);
            end;
          Inc             (pt_pix_cnt_arr_ptr);
          Inc      (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.GrVPTValue010(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0 (fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueA10(fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueB10(fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueA14(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pix_row_val       : TColor;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,(pix_row_val),
                      MAXBYTE-  Max2(pt_pix_acl_arr_ptr^-      TRGBA(pix_row_val).a,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,(pix_row_val),
                      MAXBYTE-  Max2(pt_pix_acl_arr_ptr^-      TRGBA(pix_row_val).a,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,(pix_row_val),
                      MAXBYTE-  Max2(pt_pix_acl_arr_ptr^-      TRGBA(pix_row_val).a,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      AdditiveDec1  (pt_pix_sht_arr_ptr^*res_var8+v,(pix_row_val),
                      MAXBYTE-  Max2(pt_pix_acl_arr_ptr^-      TRGBA(pix_row_val).a,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueB14(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pix_row_val       : TColor;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AdditiveDec2  (pt_pix_sht_arr_ptr^*res_var8+v,pix_row_val);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AdditiveDec2  (pt_pix_sht_arr_ptr^*res_var8+v,pix_row_val);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AdditiveDec2  (pt_pix_sht_arr_ptr^*res_var8+v,pix_row_val);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      AdditiveDec2  (pt_pix_sht_arr_ptr^*res_var8+v,pix_row_val);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValue014(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0 (fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueA14(fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueB14(fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{AlphaBlend}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueA20(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
  pix_row_val       : TColor;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pix_row_val:=RGBA(y_grad_rng_div_vec.b>>16,
                            y_grad_rng_div_vec.g>>16,
                            y_grad_rng_div_vec.r>>16,
                            y_grad_rng_div_vec.a>>16);
          for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
            begin
              AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,(pix_row_val),
                             pt_pix_acl_arr_ptr^,                      TRGBA(pix_row_val).a);
              Inc           (pt_pix_sht_arr_ptr);
              Inc           (pt_pix_acl_arr_ptr);
            end;
          Inc               (pt_pix_cnt_arr_ptr);
          Inc        (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueB20(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  pix_row_val       : TColor;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pix_row_val:=RGBA(y_grad_rng_div_vec.b>>16,
                            y_grad_rng_div_vec.g>>16,
                            y_grad_rng_div_vec.r>>16,
                            y_grad_rng_div_vec.a>>16);
          for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
            begin
              AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,pix_row_val,MAXBYTE-TRGBA(pix_row_val).a,0);
              Inc           (pt_pix_sht_arr_ptr);
            end;
          Inc               (pt_pix_cnt_arr_ptr);
          Inc        (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.GrVPTValue020(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0 (fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueA20(fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueB20(fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueA24(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pix_row_val       : TColor;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+v,(pix_row_val),
                                     pt_pix_acl_arr_ptr^,      TRGBA(pix_row_val).a);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+v,(pix_row_val),
                                     pt_pix_acl_arr_ptr^,      TRGBA(pix_row_val).a);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+v,(pix_row_val),
                                     pt_pix_acl_arr_ptr^,      TRGBA(pix_row_val).a);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+v,(pix_row_val),
                                     pt_pix_acl_arr_ptr^,      TRGBA(pix_row_val).a);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueB24(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pix_row_val       : TColor;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;
              pix_row_val      :=RGBA(y_grad_rng_div_vec.b>>16,
                                      y_grad_rng_div_vec.g>>16,
                                      y_grad_rng_div_vec.r>>16,
                                      y_grad_rng_div_vec.a>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+v,pix_row_val,MAXBYTE-TRGBA(pix_row_val).a,0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+v,pix_row_val,MAXBYTE-TRGBA(pix_row_val).a,0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+v,pix_row_val,MAXBYTE-TRGBA(pix_row_val).a,0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      AlphaBlendDec1(pt_pix_sht_arr_ptr^*res_var8+v,pix_row_val,MAXBYTE-TRGBA(pix_row_val).a,0);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValue024(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0 (fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueA24(fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueB24(fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{Inverse}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueA30(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pow:=y_grad_rng_div_vec.a>>16;
          for x:=0 to     pt_pix_cnt_arr_ptr^-1 do
            begin
              InverseDec1(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,
              MAXBYTE-Max(pt_pix_acl_arr_ptr^-pow,0));
              Inc        (pt_pix_sht_arr_ptr);
              Inc        (pt_pix_acl_arr_ptr);
            end;
          Inc            (pt_pix_cnt_arr_ptr);
          Inc     (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueB30(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pow:=y_grad_rng_div_vec.a>>16;
          for x:=0 to     pt_pix_cnt_arr_ptr^-1 do
            begin
              InverseDec1(pt_pix_sht_arr_ptr^+first_row_pix_ptr,pow);
              Inc        (pt_pix_sht_arr_ptr);
            end;
          Inc            (pt_pix_cnt_arr_ptr);
          Inc     (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.GrVPTValue030(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0 (fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueA30(fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueB30(fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueA34(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;
              pow              :=y_grad_rng_div_vec.a>>16;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      InverseDec1   (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE   -Max(pt_pix_acl_arr_ptr^-pow,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      InverseDec1   (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE   -Max(pt_pix_acl_arr_ptr^-pow,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      InverseDec1   (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE   -Max(pt_pix_acl_arr_ptr^-pow,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      InverseDec1   (pt_pix_sht_arr_ptr^*res_var8+v,
                      MAXBYTE   -Max(pt_pix_acl_arr_ptr^-pow,0));
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueB34(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;
              pow              :=y_grad_rng_div_vec.a>>16;

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      InverseDec1   (pt_pix_sht_arr_ptr^*res_var8+v,pow);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      InverseDec1   (pt_pix_sht_arr_ptr^*res_var8+v,pow);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      InverseDec1   (pt_pix_sht_arr_ptr^*res_var8+v,pow);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      InverseDec1   (pt_pix_sht_arr_ptr^*res_var8+v,pow);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValue034(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0 (fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueA34(fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueB34(fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{Highlight}
// (constant) not clipped:
procedure TFastImageProc.GrVPTValue040(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(               fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueA0(@HighlightDec1,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueB0(@HighlightDec1,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValue044(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(               fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueA4(@HighlightDec1,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueB4(@HighlightDec1,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{Darken}
// (constant) not clipped:
procedure TFastImageProc.GrVPTValue050(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(            fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueA0(@DarkenDec1,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueA0(@DarkenDec1,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValue054(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(            fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueA4(@DarkenDec1,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueA4(@DarkenDec1,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{GrayscaleR}
// (constant) not clipped:
procedure TFastImageProc.GrVPTValue060(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(                fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueC0(@GrayscaleRDec1,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueD0(@GrayscaleRDec1,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValue064(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(                fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueC4(@GrayscaleRDec1,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueD4(@GrayscaleRDec1,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{GrayscaleG}
// (constant) not clipped:
procedure TFastImageProc.GrVPTValue070(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(                fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueC0(@GrayscaleGDec1,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueD0(@GrayscaleGDec1,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValue074(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(                fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueC4(@GrayscaleGDec1,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueD4(@GrayscaleGDec1,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{GrayscaleB}
// (constant) not clipped:
procedure TFastImageProc.GrVPTValue080(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(                fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueC0(@GrayscaleBDec1,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueD0(@GrayscaleBDec1,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValue084(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(                fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueC4(@GrayscaleBDec1,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueD4(@GrayscaleBDec1,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{Monochrome Noise}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueA90(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
  pix_row_val       : TColor;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pix_row_val:=RGB(y_grad_rng_div_vec.b>>16,
                           y_grad_rng_div_vec.g>>16,
                           y_grad_rng_div_vec.r>>16);
          for x:=0 to       pt_pix_cnt_arr_ptr^-1 do
            begin
              if Odd      ((pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr)^) then
                AlphaBlend2(pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr,pix_row_val,
                            pt_pix_acl_arr_ptr^);
              Inc          (pt_pix_sht_arr_ptr);
              Inc          (pt_pix_acl_arr_ptr);
            end;
          Inc              (pt_pix_cnt_arr_ptr);
          Inc       (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueB90(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  pix_row_val       : TColor;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pix_row_val:=RGB(y_grad_rng_div_vec.b>>16,
                           y_grad_rng_div_vec.g>>16,
                           y_grad_rng_div_vec.r>>16);
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
              if Odd((pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr)^) then
                     (pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr)^:=pix_row_val;
              Inc    (pt_pix_sht_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.GrVPTValue090(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0 (fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueA90(fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueB90(fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueA94(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pix_row_val       : TColor;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;
              pix_row_val      :=RGB(y_grad_rng_div_vec.b>>16,
                                     y_grad_rng_div_vec.g>>16,
                                     y_grad_rng_div_vec.r>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      if Odd       ((pt_pix_sht_arr_ptr^*res_var8+v)^) then
                        AlphaBlend2 (pt_pix_sht_arr_ptr^*res_var8+v,pix_row_val,
                                     pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      if Odd       ((pt_pix_sht_arr_ptr^*res_var8+v)^) then
                        AlphaBlend2 (pt_pix_sht_arr_ptr^*res_var8+v,pix_row_val,
                                     pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      if Odd       ((pt_pix_sht_arr_ptr^*res_var8+v)^) then
                        AlphaBlend2 (pt_pix_sht_arr_ptr^*res_var8+v,pix_row_val,
                                     pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      if Odd       ((pt_pix_sht_arr_ptr^*res_var8+v)^) then
                        AlphaBlend2 (pt_pix_sht_arr_ptr^*res_var8+v,pix_row_val,
                                     pt_pix_acl_arr_ptr^);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueB94(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pix_row_val       : TColor;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;
              pix_row_val      :=RGB(y_grad_rng_div_vec.b>>16,
                                     y_grad_rng_div_vec.g>>16,
                                     y_grad_rng_div_vec.r>>16);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                      if Odd       ((pt_pix_sht_arr_ptr^*res_var8+v)^) then
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=pix_row_val;
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                      if Odd       ((pt_pix_sht_arr_ptr^*res_var8+v)^) then
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=pix_row_val;
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                      if Odd       ((pt_pix_sht_arr_ptr^*res_var8+v)^) then
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=pix_row_val;
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                      if Odd       ((pt_pix_sht_arr_ptr^*res_var8+v)^) then
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=pix_row_val;
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValue094(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0 (fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueA94(fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueB94(fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{ColorizeR}
// (constant) not clipped:
procedure TFastImageProc.GrVPTValue100(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(               fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueE0(@ColorizeRDec1,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueF0(@ColorizeRDec1,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValue104(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(               fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueE4(@ColorizeRDec1,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueF4(@ColorizeRDec1,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{ColorizeG}
// (constant) not clipped:
procedure TFastImageProc.GrVPTValue110(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(               fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueE0(@ColorizeGDec1,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueF0(@ColorizeGDec1,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValue114(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(               fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueE4(@ColorizeGDec1,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueF4(@ColorizeGDec1,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{ColorizeB}
// (constant) not clipped:
procedure TFastImageProc.GrVPTValue120(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(               fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueE0(@ColorizeBDec1,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueF0(@ColorizeBDec1,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValue124(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(               fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueE4(@ColorizeBDec1,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueF4(@ColorizeBDec1,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRGB}
// (constant) not clipped:
procedure TFastImageProc.GrVPTValue130(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(             fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurRGB4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueH0(@BlurRGB4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValue134(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(             fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueG4(@BlurRGB4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueH4(@BlurRGB4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRRB}
// (constant) not clipped:
procedure TFastImageProc.GrVPTValue140(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(             fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurRRB4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueH0(@BlurRRB4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValue144(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(             fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueG4(@BlurRRB4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueH4(@BlurRRB4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRGR}
// (constant) not clipped:
procedure TFastImageProc.GrVPTValue150(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(             fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurRGR4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueH0(@BlurRGR4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValue154(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(             fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueG4(@BlurRGR4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueH4(@BlurRGR4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{BlurGGB}
// (constant) not clipped:
procedure TFastImageProc.GrVPTValue160(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(             fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurGGB4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueH0(@BlurGGB4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValue164(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(             fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueG4(@BlurGGB4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueH4(@BlurGGB4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRGG}
// (constant) not clipped:
procedure TFastImageProc.GrVPTValue170(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(             fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurRGG4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueH0(@BlurRGG4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValue174(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(             fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueG4(@BlurRGG4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueH4(@BlurRGG4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{BlurBGB}
// (constant) not clipped:
procedure TFastImageProc.GrVPTValue180(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(             fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurBGB4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueH0(@BlurBGB4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValue184(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(             fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueG4(@BlurBGB4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueH4(@BlurBGB4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRBB}
// (constant) not clipped:
procedure TFastImageProc.GrVPTValue190(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(             fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurRBB4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueH0(@BlurRBB4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValue194(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(             fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueG4(@BlurRBB4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueH4(@BlurRBB4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{BlurRRR}
// (constant) not clipped:
procedure TFastImageProc.GrVPTValue200(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(             fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurRRR4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueH0(@BlurRRR4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValue204(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(             fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueG4(@BlurRRR4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueH4(@BlurRRR4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{BlurGGG}
// (constant) not clipped:
procedure TFastImageProc.GrVPTValue210(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
        GrVPTResVar0(             fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurGGG4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueH0(@BlurGGG4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValue214(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVPTResVar0  (             fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueG4(@BlurGGG4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueH4(@BlurGGG4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{BlurBBB}
// (constant) not clipped:
procedure TFastImageProc.GrVPTValue220(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVPTResVar0  (             fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueG0(@BlurBBB4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueH0(@BlurBBB4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValue224(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVPTResVar0  (             fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueG4(@BlurBBB4Dec,fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueH4(@BlurBBB4Dec,fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{Contrast}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueI30(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  x,y               : integer;
  pix_const_val     : TColor;
  contrast_pow      : integer;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
      pix_const_val     :=RGB(128,128,128);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pow         :=y_grad_rng_div_vec.a>>16;
          contrast_pow:=FloatToFixed(1+(MAXBYTE-pow)/10);
          for x:=0 to      pt_pix_cnt_arr_ptr^-1 do
            begin
                          (pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr)^:=ContrastDec1(
                          (pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr)^,pix_const_val,
              MAXBYTE-Max2(pt_pix_acl_arr_ptr^-pow,0),contrast_pow);
              Inc         (pt_pix_sht_arr_ptr);
              Inc         (pt_pix_acl_arr_ptr);
            end;
          Inc             (pt_pix_cnt_arr_ptr);
          Inc      (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueJ30(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
  pix_const_val     : TColor;
  contrast_pow      : integer;
  pow               : byte;
begin
  with fast_image_data_,grad_prop do
    begin
      pix_const_val     :=RGB(128,128,128);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          pow         :=y_grad_rng_div_vec.a>>16;
          contrast_pow:=FloatToFixed(1+(MAXBYTE-pow)/10);
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr)^:=ContrastDec1(
                     (pt_pix_sht_arr_ptr^*res_var8+first_row_pix_ptr)^,pix_const_val,pow,contrast_pow);
              Inc    (pt_pix_sht_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc (first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) not clipped:
procedure TFastImageProc.GrVPTValue230(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVPTResVar0   (fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueI30(fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueJ30(fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (constant) auxiliary procedure:
procedure TFastImageProc.GrVPTValueI34(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_acl_arr_ptr: PByte;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pix_const_val     : TColor;
  contrast_pow      : integer;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
      pix_const_val     :=RGB(128,128,128);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      pt_pix_acl_arr_ptr:=@fast_image_data_ptr_^.pt_pix_acl_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;
              pow              :=y_grad_rng_div_vec.a>>16;
              contrast_pow     :=FloatToFixed(1+(MAXBYTE-pow)/10);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  Inc               (pt_pix_acl_arr_ptr,c1+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=ContrastDec1(
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^,pix_const_val,
                      MAXBYTE  -Max2(pt_pix_acl_arr_ptr^-pow,0),contrast_pow);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  Inc               (pt_pix_acl_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=ContrastDec1(
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^,pix_const_val,
                      MAXBYTE  -Max2(pt_pix_acl_arr_ptr^-pow,0),contrast_pow);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=ContrastDec1(
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^,pix_const_val,
                      MAXBYTE  -Max2(pt_pix_acl_arr_ptr^-pow,0),contrast_pow);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  Inc               (pt_pix_acl_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=ContrastDec1(
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^,pix_const_val,
                      MAXBYTE-  Max2(pt_pix_acl_arr_ptr^-pow,0),contrast_pow);
                      Inc           (pt_pix_sht_arr_ptr);
                      Inc           (pt_pix_acl_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.GrVPTValueJ34(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  v                 : PInteger;
  x,y               : integer;
  c,c1,c2           : integer;
  pix_const_val     : TColor;
  contrast_pow      : integer;
  pow               : byte;
label
  label1;
begin
  with fast_image_data_,grad_prop do
    begin
      pix_const_val     :=RGB(128,128,128);
       first_row_pix_ptr:=@fast_image_data_ptr_^.bmp_bkgnd_ptr [res_var7];
      pt_pix_cnt_arr_ptr:=@fast_image_data_ptr_^.pt_pix_cnt_arr[res_var0];
      pt_pix_sht_arr_ptr:=@fast_image_data_ptr_^.pt_pix_sht_arr[res_var1];
      for y:=0 to res_var2 do
        begin
          if                        (pt_pix_cnt_arr_ptr^<>0) then
            begin
              first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;
              pow              :=y_grad_rng_div_vec.a>>16;
              contrast_pow     :=FloatToFixed(1+(MAXBYTE-pow)/10);

              {left-right-clipped} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  Inc               (pt_pix_sht_arr_ptr,c1+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c2-c1-1 do
                    begin
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=ContrastDec1(
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^,pix_const_val,pow,contrast_pow);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c2+1));
                  goto label1;
                end; {$endregion}

              {left-clipped------} {$region -fold}
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if (first_sht_pix_ptr^<rct_src.left) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.left);
                  Inc               (pt_pix_sht_arr_ptr,c+1);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-c-2 do
                    begin
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=ContrastDec1(
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^,pix_const_val,pow,contrast_pow);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  goto label1;
                end; {$endregion}

              {right-clipped-----} {$region -fold}
              if (first_sht_pix_ptr^>=rct_src.right) then
                begin
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^);
                  goto label1;
                end
              else
              if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                begin
                  c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                     pt_pix_sht_arr_ptr,rct_src.right);
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to c do
                    begin
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=ContrastDec1(
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^,pix_const_val,pow,contrast_pow);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                  Inc               (pt_pix_sht_arr_ptr,
                                     pt_pix_cnt_arr_ptr^-(c+1));
                  goto label1;
                end; {$endregion}

              {not clipped-------} {$region -fold}
              if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                 ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                begin
                  v:=first_row_pix_ptr-rct_src.left*res_var8;
                  for x:=0 to        pt_pix_cnt_arr_ptr^-1 do
                    begin
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^:=ContrastDec1(
                                    (pt_pix_sht_arr_ptr^*res_var8+v)^,pix_const_val,pow,contrast_pow);
                      Inc           (pt_pix_sht_arr_ptr);
                    end;
                end; {$endregion}

            end;
          label1:
          Inc                       (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,res_var5);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GrVPTValue234(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,grad_prop do
    begin
      GrVPTResVar0   (fast_image_data_ptr_,fast_image_data_);
      if (not pt_as_nt) then
        GrVPTValueI34(fast_image_data_ptr_,fast_image_data_)
      else
        GrVPTValueJ34(fast_image_data_ptr_,fast_image_data_);
    end;
end; {$endregion}
// (fading):
// same;

{$endregion}

{||scl_mul||<1: (SD - Scale Down)} {$region -fold}

{Empty}
procedure TFastImageProc.GSDPTValue009(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Monochrome}
// (constant) not clipped:
procedure TFastImageProc.GSDPTValue000(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTValue002(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTValue004(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Additive}
// (constant) not clipped:
procedure TFastImageProc.GSDPTValue010(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTValue012(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTValue014(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Alphablend}
// (constant) not clipped:
procedure TFastImageProc.GSDPTValue020(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTValue022(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTValue024(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Inverse}
// (constant) not clipped:
procedure TFastImageProc.GSDPTValue030(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTValue032(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTValue034(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Highlight}
// (constant) not clipped:
procedure TFastImageProc.GSDPTValue040(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTValue042(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTValue044(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Darken}
// (constant) not clipped:
procedure TFastImageProc.GSDPTValue050(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTValue052(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTValue054(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{GrayscaleR}
// (constant) not clipped:
procedure TFastImageProc.GSDPTValue060(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTValue062(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTValue064(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{GrayscaleG}
// (constant) not clipped:
procedure TFastImageProc.GSDPTValue070(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTValue072(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTValue074(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{GrayscaleB}
// (constant) not clipped:
procedure TFastImageProc.GSDPTValue080(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTValue082(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTValue084(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Monochrome Noise}
// (constant) not clipped:
procedure TFastImageProc.GSDPTValue090(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTValue092(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTValue094(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{ColorizeR}
// (constant) not clipped:
procedure TFastImageProc.GSDPTValue100(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTValue102(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTValue104(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{ColorizeG}
// (constant) not clipped:
procedure TFastImageProc.GSDPTValue110(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTValue112(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTValue114(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{ColorizeB}
// (constant) not clipped:
procedure TFastImageProc.GSDPTValue120(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTValue122(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTValue124(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurRGB}
// (constant) not clipped:
procedure TFastImageProc.GSDPTValue130(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTValue132(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTValue134(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurRRB}
// (constant) not clipped:
procedure TFastImageProc.GSDPTValue140(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTValue142(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTValue144(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurRGR}
// (constant) not clipped:
procedure TFastImageProc.GSDPTValue150(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTValue152(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTValue154(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurGGB}
// (constant) not clipped:
procedure TFastImageProc.GSDPTValue160(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTValue162(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTValue164(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurRGG}
// (constant) not clipped:
procedure TFastImageProc.GSDPTValue170(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTValue172(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTValue174(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurBGB}
// (constant) not clipped:
procedure TFastImageProc.GSDPTValue180(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTValue182(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTValue184(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurRBB}
// (constant) not clipped:
procedure TFastImageProc.GSDPTValue190(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTValue192(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTValue194(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurRRR}
// (constant) not clipped:
procedure TFastImageProc.GSDPTValue200(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTValue202(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTValue204(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurGGG}
// (constant) not clipped:
procedure TFastImageProc.GSDPTValue210(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTValue212(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTValue214(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurBBB}
// (constant) not clipped:
procedure TFastImageProc.GSDPTValue220(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTValue222(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTValue224(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Contrast}
// (constant) not clipped:
procedure TFastImageProc.GSDPTValue230(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSDPTValue232(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSDPTValue234(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{$endregion}

{||scl_mul||>1: (SU - Scale Up  )} {$region -fold}

{Empty}
procedure TFastImageProc.GSUPTValue009(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Monochrome}
// (constant) not clipped:
procedure TFastImageProc.GSUPTValue000(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTValue002(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTValue004(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Additive}
// (constant) not clipped:
procedure TFastImageProc.GSUPTValue010(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTValue012(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTValue014(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Alphablend}
// (constant) not clipped:
procedure TFastImageProc.GSUPTValue020(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTValue022(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTValue024(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Inverse}
// (constant) not clipped:
procedure TFastImageProc.GSUPTValue030(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTValue032(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTValue034(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Highlight}
// (constant) not clipped:
procedure TFastImageProc.GSUPTValue040(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTValue042(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTValue044(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Darken}
// (constant) not clipped:
procedure TFastImageProc.GSUPTValue050(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTValue052(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTValue054(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{GrayscaleR}
// (constant) not clipped:
procedure TFastImageProc.GSUPTValue060(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTValue062(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTValue064(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{GrayscaleG}
// (constant) not clipped:
procedure TFastImageProc.GSUPTValue070(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTValue072(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTValue074(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{GrayscaleB}
// (constant) not clipped:
procedure TFastImageProc.GSUPTValue080(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTValue082(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTValue084(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Monochrome Noise}
// (constant) not clipped:
procedure TFastImageProc.GSUPTValue090(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTValue092(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTValue094(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{ColorizeR}
// (constant) not clipped:
procedure TFastImageProc.GSUPTValue100(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTValue102(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTValue104(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{ColorizeG}
// (constant) not clipped:
procedure TFastImageProc.GSUPTValue110(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTValue112(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTValue114(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{ColorizeB}
// (constant) not clipped:
procedure TFastImageProc.GSUPTValue120(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTValue122(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTValue124(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurRGB}
// (constant) not clipped:
procedure TFastImageProc.GSUPTValue130(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTValue132(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTValue134(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurRRB}
// (constant) not clipped:
procedure TFastImageProc.GSUPTValue140(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTValue142(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTValue144(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurRGR}
// (constant) not clipped:
procedure TFastImageProc.GSUPTValue150(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTValue152(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTValue154(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurGGB}
// (constant) not clipped:
procedure TFastImageProc.GSUPTValue160(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTValue162(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTValue164(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurRGG}
// (constant) not clipped:
procedure TFastImageProc.GSUPTValue170(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTValue172(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTValue174(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurBGB}
// (constant) not clipped:
procedure TFastImageProc.GSUPTValue180(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTValue182(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTValue184(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurRBB}
// (constant) not clipped:
procedure TFastImageProc.GSUPTValue190(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTValue192(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTValue194(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurRRR}
// (constant) not clipped:
procedure TFastImageProc.GSUPTValue200(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTValue202(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTValue204(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurGGG}
// (constant) not clipped:
procedure TFastImageProc.GSUPTValue210(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTValue212(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTValue214(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{BlurBBB}
// (constant) not clipped:
procedure TFastImageProc.GSUPTValue220(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTValue222(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTValue224(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{Contrast}
// (constant) not clipped:
procedure TFastImageProc.GSUPTValue230(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) top-bottom clipped:
procedure TFastImageProc.GSUPTValue232(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (constant) left-right-top-bottom clipped:
procedure TFastImageProc.GSUPTValue234(                const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// (fading):
// same;

{$endregion}

{$endregion}

{$endregion}

{Fill array at specified rectangle with specified value} {$region -fold}
// NT - not transparent pixels:
procedure TFastImageProc.FilNTValueArrA(var arr_src:TColorArr ; const bmp_ftimg_width_:TColor; const val:TColor=0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (nt_pix_cnt=0) then
        Exit;
       first_row_pix_ptr:=Unaligned(@arr_src       [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width_+bmp_src_rct_clp.left]);
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000000]);
      nt_pix_sht_arr_ptr:=Unaligned(@nt_pix_sht_arr[ 000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          for x:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
                     (nt_pix_sht_arr_ptr^+first_row_pix_ptr)^:=val;
              Inc    (nt_pix_sht_arr_ptr);
            end;
          Inc        (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_ftimg_width_);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.FilNTValueArrB(var arr_src:T1Byte1Arr; const bmp_ftimg_width_:TColor; const val:byte  =0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PByte;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (nt_pix_cnt=0) then
        Exit;
       first_row_pix_ptr:=Unaligned(@arr_src       [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width_+bmp_src_rct_clp.left]);
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000000]);
      nt_pix_sht_arr_ptr:=Unaligned(@nt_pix_sht_arr[ 000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          for x:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
                     (nt_pix_sht_arr_ptr^+first_row_pix_ptr)^:=val;
              Inc    (nt_pix_sht_arr_ptr);
            end;
          Inc        (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_ftimg_width_);
        end;
    end;
end; {$endregion}
// PT - partly transparent pixels:
procedure TFastImageProc.FilPTValueArrA(var arr_src:TColorArr ; const bmp_ftimg_width_:TColor; const val:TColor=0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (pt_pix_cnt=0) then
        Exit;
       first_row_pix_ptr:=Unaligned(@arr_src       [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width_+bmp_src_rct_clp.left]);
      pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr[ pt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000000]);
      pt_pix_sht_arr_ptr:=Unaligned(@pt_pix_sht_arr[ 000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_sht_arr_ptr^+first_row_pix_ptr)^:=val;
              Inc    (pt_pix_sht_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_ftimg_width_);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.FilPTValueArrB(var arr_src:T1Byte1Arr; const bmp_ftimg_width_:TColor; const val:byte  =0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PByte;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  x,y               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (pt_pix_cnt=0) then
        Exit;
       first_row_pix_ptr:=Unaligned(@arr_src       [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width_+bmp_src_rct_clp.left]);
      pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr[ pt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000000]);
      pt_pix_sht_arr_ptr:=Unaligned(@pt_pix_sht_arr[ 000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_sht_arr_ptr^+first_row_pix_ptr)^:=val;
              Inc    (pt_pix_sht_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_ftimg_width_);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.FilPTValueArrC;                                                                            {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_cnt_arr_ptr : PWord;
  pt_pix_sht_arr_ptr : PWord;
       bmp_bkgnd_ptr2: PInteger;
  x, y,v1,v2         : integer;
begin
  with fast_image_data_ptr0^,fip_scale_data_var0 do
    begin
      SclPTResVar0(fast_image_data_ptr0,fast_image_data_ptr0^);
      pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr   [pt_pix_arr_row_mrg_top]);
      pt_pix_sht_arr_ptr:=Unaligned(@pt_pix_sht_arr   [0000000000000000000000]);
      for y:=0 to rct_ent.height-    pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          v2:=(v3>>16)*bmp_bkgnd_width;
          if MinSubMax2((v3>>16)<<15,g2,ONE_SHL_15,_scl_mul_y) then
            for x:=0 to pt_pix_cnt_arr_ptr^-1 do
              begin
                v1                          :=(scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16;
                          bmp_bkgnd_ptr2    :=bmp_bkgnd_ptr+v1+v2;
                    PRGBA(bmp_bkgnd_ptr2)^.a:=1;
                if (not MinSubMax2(v1<<15,_scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x)) then
                  begin
                    Inc  (bmp_bkgnd_ptr2);
                    PRGBA(bmp_bkgnd_ptr2)^.a:=1;
                  end;
                Inc    (pt_pix_sht_arr_ptr);
              end
          else
            for x:=0 to pt_pix_cnt_arr_ptr^-1 do
              begin
                       bmp_bkgnd_ptr2                  :=bmp_bkgnd_ptr+(scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16+v2;
                PQWord(bmp_bkgnd_ptr2                )^:=
                PQWord(bmp_bkgnd_ptr2                )^ or ONE_SHL_24_56;
                PQWord(bmp_bkgnd_ptr2+bmp_bkgnd_width)^:=
                PQWord(bmp_bkgnd_ptr2+bmp_bkgnd_width)^ or ONE_SHL_24_56;
                Inc    (pt_pix_sht_arr_ptr);
              end;
          Inc          (pt_pix_cnt_arr_ptr);
          Inc(v3, scl_mul_y);
          Inc(g2,_scl_mul_y);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.FilPTValueArrD;                                                                            {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_cnt_arr_ptr : PWord;
  pt_pix_sht_arr_ptr : PWord;
       bmp_bkgnd_ptr2: PInteger;
  x, y,v1,v2         : integer;
begin
  with fast_image_data_ptr0^,fip_scale_data_var0 do
    begin
      SclPTResVar0(fast_image_data_ptr0,fast_image_data_ptr0^);
      pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr   [pt_pix_arr_row_mrg_top]);
      pt_pix_sht_arr_ptr:=Unaligned(@pt_pix_sht_arr   [0000000000000000000000]);
      for y:=0 to rct_ent.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          v2:=(v3>>16)*bmp_bkgnd_width;
          if MinSubMax2((v3>>16)<<15,g2,ONE_SHL_15,_scl_mul_y) then
            for x:=0 to pt_pix_cnt_arr_ptr^-1 do
              begin
                v1                          :=(scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16;
                          bmp_bkgnd_ptr2    :=bmp_bkgnd_ptr+v1+v2;
                    PRGBA(bmp_bkgnd_ptr2)^.a:=0;
                if (not MinSubMax2(v1<<15,_scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x)) then
                  begin
                    Inc  (bmp_bkgnd_ptr2);
                    PRGBA(bmp_bkgnd_ptr2)^.a:=0;
                  end;
                Inc    (pt_pix_sht_arr_ptr);
              end
          else
            for x:=0 to pt_pix_cnt_arr_ptr^-1 do
              begin
                       bmp_bkgnd_ptr2                  :=bmp_bkgnd_ptr+(scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16+v2;
                PQWord(bmp_bkgnd_ptr2                )^:=
                PQWord(bmp_bkgnd_ptr2                )^ and ONE_SHL_24_56_SUB_1;
                PQWord(bmp_bkgnd_ptr2+bmp_bkgnd_width)^:=
                PQWord(bmp_bkgnd_ptr2+bmp_bkgnd_width)^ and ONE_SHL_24_56_SUB_1;
                Inc    (pt_pix_sht_arr_ptr);
              end;
          Inc          (pt_pix_cnt_arr_ptr);
          Inc(v3, scl_mul_y);
          Inc(g2,_scl_mul_y);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.FilPTValueArrE;                                                                            {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_cnt_arr_ptr : PWord;
  pt_pix_sht_arr_ptr : PWord;
       bmp_bkgnd_ptr2: PInteger;
  x, y,v1,v2         : integer;
  skip_pix0,skip_pix1: TPtPos4;
  b0,b1              : boolean;
begin
  with fast_image_data_ptr0^,fip_scale_data_var0 do
    begin
      SclPTResVar0(fast_image_data_ptr0,fast_image_data_ptr0^);
      pt_pix_cnt_arr_ptr    :=Unaligned(@pt_pix_cnt_arr[pt_pix_arr_row_mrg_top]);
      pt_pix_sht_arr_ptr    :=Unaligned(@pt_pix_sht_arr[0000000000000000000000]);
      dh                    :=rct_src.top-              pt_pix_arr_row_mrg_top;
      if (dh>0) then
        begin
          v3                += scl_mul_y*dh;
          g2                +=_scl_mul_y*dh;
          pt_pix_cnt_arr_ptr+=           dh;
          pt_pix_sht_arr_ptr+=res_var1-pt_cnt_ind_arr  [pt_pix_arr_row_mrg_top];
        end;
      if (res_var2<0) then
        Exit;
      for y:=0 to res_var2+1 do
        begin
          if (PWord(pt_pix_sht_arr_ptr)-PWord(@pt_pix_sht_arr[0])>Length(pt_pix_sht_arr)-1) then
            Exit;
          v2       :=(v3>>16)*bmp_bkgnd_width;
          skip_pix0:=MinSubMax1((v3>>16)<<15,g2,ONE_SHL_15,_scl_mul_y);
          if skip_pix0.y then
            begin
              b0:=((v3>>16)>=rct_clp_ptr^.top) and ((v3>>16)<rct_clp_ptr^.bottom);
              if b0 then
                for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                  begin
                    v1                          :=                  (scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16;
                    skip_pix1                   :=MinSubMax1(v1<<15,_scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x);
                              bmp_bkgnd_ptr2    :=bmp_bkgnd_ptr+v1+v2;
                    PRGBA    (bmp_bkgnd_ptr2)^.a:=1;
                    if (not skip_pix1.y) then
                      begin
                        Inc  (bmp_bkgnd_ptr2);
                        PRGBA(bmp_bkgnd_ptr2)^.a:=1;
                      end;
                    Inc(pt_pix_sht_arr_ptr);
                  end
              else
                for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                  Inc(pt_pix_sht_arr_ptr);
            end
          else
            begin
              b0:=(0+(v3>>16)>=rct_clp_ptr^.top) and (0+(v3>>16)<rct_clp_ptr^.bottom);
              b1:=(1+(v3>>16)>=rct_clp_ptr^.top) and (1+(v3>>16)<rct_clp_ptr^.bottom);
              if b0 then
                begin
                  if b1 then
                    for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                      begin
                               bmp_bkgnd_ptr2                  :=bmp_bkgnd_ptr+(scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16+v2;
                        PQWord(bmp_bkgnd_ptr2                )^:=
                        PQWord(bmp_bkgnd_ptr2                )^ or ONE_SHL_24_56;
                        PQWord(bmp_bkgnd_ptr2+bmp_bkgnd_width)^:=
                        PQWord(bmp_bkgnd_ptr2+bmp_bkgnd_width)^ or ONE_SHL_24_56;
                        Inc(pt_pix_sht_arr_ptr);
                      end
                  else
                    for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                      begin
                               bmp_bkgnd_ptr2                  :=bmp_bkgnd_ptr+(scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16+v2;
                        PQWord(bmp_bkgnd_ptr2                )^:=
                        PQWord(bmp_bkgnd_ptr2                )^ or ONE_SHL_24_56;
                        Inc(pt_pix_sht_arr_ptr);
                      end;
                end
              else
                begin
                  if b1 then
                    for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                      begin
                               bmp_bkgnd_ptr2                  :=bmp_bkgnd_ptr+(scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16+v2;
                        PQWord(bmp_bkgnd_ptr2+bmp_bkgnd_width)^:=
                        PQWord(bmp_bkgnd_ptr2+bmp_bkgnd_width)^ or ONE_SHL_24_56;
                        Inc(pt_pix_sht_arr_ptr);
                      end
                  else
                    for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                      Inc(pt_pix_sht_arr_ptr);
                end;
            end;
          Inc(pt_pix_cnt_arr_ptr);
          Inc(v3, scl_mul_y);
          Inc(g2,_scl_mul_y);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.FilPTValueArrF;                                                                            {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_cnt_arr_ptr : PWord;
  pt_pix_sht_arr_ptr : PWord;
       bmp_bkgnd_ptr2: PInteger;
  x, y,v1,v2         : integer;
  skip_pix0,skip_pix1: TPtPos4;
  b0,b1              : boolean;
begin
  with fast_image_data_ptr0^,fip_scale_data_var0 do
    begin
      SclPTResVar0(fast_image_data_ptr0,fast_image_data_ptr0^);
      pt_pix_cnt_arr_ptr    :=Unaligned(@pt_pix_cnt_arr[pt_pix_arr_row_mrg_top]);
      pt_pix_sht_arr_ptr    :=Unaligned(@pt_pix_sht_arr[0000000000000000000000]);
      dh                    :=rct_src.top-              pt_pix_arr_row_mrg_top;
      if (dh>0) then
        begin
          v3                += scl_mul_y*dh;
          g2                +=_scl_mul_y*dh;
          pt_pix_cnt_arr_ptr+=           dh;
          pt_pix_sht_arr_ptr+=res_var1-pt_cnt_ind_arr  [pt_pix_arr_row_mrg_top];
        end;
      if (res_var2<0) then
        Exit;
      for y:=0 to res_var2+1 do
        begin
          if (PWord(pt_pix_sht_arr_ptr)-PWord(@pt_pix_sht_arr[0])>Length(pt_pix_sht_arr)-1) then
            Exit;
          v2       :=(v3>>16)*bmp_bkgnd_width;
          skip_pix0:=MinSubMax1((v3>>16)<<15,g2,ONE_SHL_15,_scl_mul_y);
          if skip_pix0.y then
            begin
              b0:=((v3>>16)>=rct_clp_ptr^.top) and ((v3>>16)<rct_clp_ptr^.bottom);
              if b0 then
                for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                  begin
                    v1                          :=                  (scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16;
                    skip_pix1                   :=MinSubMax1(v1<<15,_scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x);
                              bmp_bkgnd_ptr2    :=bmp_bkgnd_ptr+v1+v2;
                    PRGBA    (bmp_bkgnd_ptr2)^.a:=0;
                    if (not skip_pix1.y) then
                      begin
                        Inc  (bmp_bkgnd_ptr2);
                        PRGBA(bmp_bkgnd_ptr2)^.a:=0;
                      end;
                    Inc(pt_pix_sht_arr_ptr);
                  end
              else
                for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                  Inc(pt_pix_sht_arr_ptr);
            end
          else
            begin
              b0:=(0+(v3>>16)>=rct_clp_ptr^.top) and (0+(v3>>16)<rct_clp_ptr^.bottom);
              b1:=(1+(v3>>16)>=rct_clp_ptr^.top) and (1+(v3>>16)<rct_clp_ptr^.bottom);
              if b0 then
                begin
                  if b1 then
                    for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                      begin
                               bmp_bkgnd_ptr2                  :=bmp_bkgnd_ptr+(scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16+v2;
                        PQWord(bmp_bkgnd_ptr2                )^:=
                        PQWord(bmp_bkgnd_ptr2                )^ and ONE_SHL_24_56_SUB_1;
                        PQWord(bmp_bkgnd_ptr2+bmp_bkgnd_width)^:=
                        PQWord(bmp_bkgnd_ptr2+bmp_bkgnd_width)^ and ONE_SHL_24_56_SUB_1;
                        Inc(pt_pix_sht_arr_ptr);
                      end
                  else
                    for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                      begin
                               bmp_bkgnd_ptr2                  :=bmp_bkgnd_ptr+(scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16+v2;
                        PQWord(bmp_bkgnd_ptr2                )^:=
                        PQWord(bmp_bkgnd_ptr2                )^ and ONE_SHL_24_56_SUB_1;
                        Inc(pt_pix_sht_arr_ptr);
                      end;
                end
              else
                begin
                  if b1 then
                    for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                      begin
                               bmp_bkgnd_ptr2                  :=bmp_bkgnd_ptr+(scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16+v2;
                        PQWord(bmp_bkgnd_ptr2+bmp_bkgnd_width)^:=
                        PQWord(bmp_bkgnd_ptr2+bmp_bkgnd_width)^ and ONE_SHL_24_56_SUB_1;
                        Inc(pt_pix_sht_arr_ptr);
                      end
                  else
                    for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                      Inc(pt_pix_sht_arr_ptr);
                end;
            end;
          Inc(pt_pix_cnt_arr_ptr);
          Inc(v3, scl_mul_y);
          Inc(g2,_scl_mul_y);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.FilPTValueArrG;                                                                            {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_cnt_arr_ptr : PWord;
  pt_pix_sht_arr_ptr : PWord;
       bmp_bkgnd_ptr2: PInteger;
  x, y,v1,v2         : integer;
  skip_pix0,skip_pix1: TPtPos4;
  b0,b1              : boolean;
  c0,c1              : boolean;
begin
  with fast_image_data_ptr0^,fip_scale_data_var0 do
    begin
      SclPTResVar0(fast_image_data_ptr0,fast_image_data_ptr0^);
      pt_pix_cnt_arr_ptr    :=Unaligned(@pt_pix_cnt_arr[pt_pix_arr_row_mrg_top]);
      pt_pix_sht_arr_ptr    :=Unaligned(@pt_pix_sht_arr[0000000000000000000000]);
      dh                    :=rct_src.top-              pt_pix_arr_row_mrg_top;
      if (dh>0) then
        begin
          v3                += scl_mul_y*dh;
          g2                +=_scl_mul_y*dh;
          pt_pix_cnt_arr_ptr+=           dh;
          pt_pix_sht_arr_ptr+=res_var1-pt_cnt_ind_arr  [pt_pix_arr_row_mrg_top];
        end;
      if (res_var2<0) then
        Exit;
      for y:=0 to res_var2+1 do
        begin
          if (PWord(pt_pix_sht_arr_ptr)-PWord(@pt_pix_sht_arr[0])>Length(pt_pix_sht_arr)-1) then
            Exit;
          v2       :=(v3>>16)*bmp_bkgnd_width;
          skip_pix0:=MinSubMax1((v3>>16)<<15,g2,ONE_SHL_15,_scl_mul_y);
          if skip_pix0.y then
            begin
              b0:=((v3>>16)>=rct_clp_ptr^.top) and ((v3>>16)<rct_clp_ptr^.bottom);
              if b0 then
                for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                  begin
                    v1                            :=                  (scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16;
                    skip_pix1                     :=MinSubMax1(v1<<15,_scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x);
                                bmp_bkgnd_ptr2    :=bmp_bkgnd_ptr+v1+v2;
                    if   (v1+0>=rct_clp_ptr^.left) and (v1+0<rct_clp_ptr^.right) then
                          PRGBA(bmp_bkgnd_ptr2)^.a:=1;
                    if (not skip_pix1.y) then
                      if (v1+1>=rct_clp_ptr^.left) and (v1+1<rct_clp_ptr^.right) then
                        begin
                          Inc  (bmp_bkgnd_ptr2);
                          PRGBA(bmp_bkgnd_ptr2)^.a:=1;
                        end;
                    Inc(pt_pix_sht_arr_ptr);
                  end
              else
                for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                  Inc(pt_pix_sht_arr_ptr);
            end
          else
            begin
              b0:=(0+(v3>>16)>=rct_clp_ptr^.top) and (0+(v3>>16)<rct_clp_ptr^.bottom);
              b1:=(1+(v3>>16)>=rct_clp_ptr^.top) and (1+(v3>>16)<rct_clp_ptr^.bottom);
              if b0 then
                begin
                  if b1 then
                    for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                      begin
                        v1                                          :=(scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16;
                        c0                                          :=(v1+0>=rct_clp_ptr^.left) and (v1+0<rct_clp_ptr^.right);
                        c1                                          :=(v1+1>=rct_clp_ptr^.left) and (v1+1<rct_clp_ptr^.right);
                        if c0 then
                          begin
                                  bmp_bkgnd_ptr2                    :=bmp_bkgnd_ptr+v1+v2;
                            PRGBA(bmp_bkgnd_ptr2+000000000000000)^.a:=1;
                            PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width)^.a:=1;
                          end;
                        if c1 then
                          begin
                                  bmp_bkgnd_ptr2                    :=bmp_bkgnd_ptr+v1+v2+1;
                            PRGBA(bmp_bkgnd_ptr2+000000000000000)^.a:=1;
                            PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width)^.a:=1;
                          end;
                        Inc(pt_pix_sht_arr_ptr);
                      end
                  else
                    for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                      begin
                        v1                          :=(scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16;
                                bmp_bkgnd_ptr2      :=bmp_bkgnd_ptr+v1+v2;
                        if (v1+0>=rct_clp_ptr^.left) and (v1+0<rct_clp_ptr^.right) then
                          PRGBA(bmp_bkgnd_ptr2+0)^.a:=1;
                        if (v1+1>=rct_clp_ptr^.left) and (v1+1<rct_clp_ptr^.right) then
                          PRGBA(bmp_bkgnd_ptr2+1)^.a:=1;
                        Inc(pt_pix_sht_arr_ptr);
                      end;
                end
              else
                begin
                  if b1 then
                    for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                      begin
                        v1                          :=(scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16;
                                bmp_bkgnd_ptr2      :=bmp_bkgnd_ptr+v1+v2+bmp_bkgnd_width;
                        if (v1+0>=rct_clp_ptr^.left) and (v1+0<rct_clp_ptr^.right) then
                          PRGBA(bmp_bkgnd_ptr2+0)^.a:=1;
                        if (v1+1>=rct_clp_ptr^.left) and (v1+1<rct_clp_ptr^.right) then
                          PRGBA(bmp_bkgnd_ptr2+1)^.a:=1;
                        Inc(pt_pix_sht_arr_ptr);
                      end
                  else
                    for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                      Inc(pt_pix_sht_arr_ptr);
                end;
            end;
          Inc(pt_pix_cnt_arr_ptr);
          Inc(v3, scl_mul_y);
          Inc(g2,_scl_mul_y);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.FilPTValueArrH;                                                                            {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt_pix_cnt_arr_ptr : PWord;
  pt_pix_sht_arr_ptr : PWord;
       bmp_bkgnd_ptr2: PInteger;
  x, y,v1,v2         : integer;
  skip_pix0,skip_pix1: TPtPos4;
  b0,b1              : boolean;
  c0,c1              : boolean;
begin
  with fast_image_data_ptr0^,fip_scale_data_var0 do
    begin
      SclPTResVar0(fast_image_data_ptr0,fast_image_data_ptr0^);
      pt_pix_cnt_arr_ptr    :=Unaligned(@pt_pix_cnt_arr[pt_pix_arr_row_mrg_top]);
      pt_pix_sht_arr_ptr    :=Unaligned(@pt_pix_sht_arr[0000000000000000000000]);
      dh                    :=rct_src.top-              pt_pix_arr_row_mrg_top;
      if (dh>0) then
        begin
          v3                += scl_mul_y*dh;
          g2                +=_scl_mul_y*dh;
          pt_pix_cnt_arr_ptr+=           dh;
          pt_pix_sht_arr_ptr+=res_var1-pt_cnt_ind_arr  [pt_pix_arr_row_mrg_top];
        end;
      if (res_var2<0) then
        Exit;
      for y:=0 to res_var2+1 do
        begin
          if (PWord(pt_pix_sht_arr_ptr)-PWord(@pt_pix_sht_arr[0])>Length(pt_pix_sht_arr)-1) then
            Exit;
          v2       :=(v3>>16)*bmp_bkgnd_width;
          skip_pix0:=MinSubMax1((v3>>16)<<15,g2,ONE_SHL_15,_scl_mul_y);
          if skip_pix0.y then
            begin
              b0:=((v3>>16)>=rct_clp_ptr^.top) and ((v3>>16)<rct_clp_ptr^.bottom);
              if b0 then
                for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                  begin
                    v1                            :=                  (scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16;
                    skip_pix1                     :=MinSubMax1(v1<<15,_scl_mul_x*pt_pix_sht_arr_ptr^+rct_ent_left,ONE_SHL_15,_scl_mul_x);
                                bmp_bkgnd_ptr2    :=bmp_bkgnd_ptr+v1+v2;
                    if   (v1+0>=rct_clp_ptr^.left) and (v1+0<rct_clp_ptr^.right) then
                          PRGBA(bmp_bkgnd_ptr2)^.a:=0;
                    if (not skip_pix1.y) then
                      if (v1+1>=rct_clp_ptr^.left) and (v1+1<rct_clp_ptr^.right) then
                        begin
                          Inc  (bmp_bkgnd_ptr2);
                          PRGBA(bmp_bkgnd_ptr2)^.a:=0;
                        end;
                    Inc(pt_pix_sht_arr_ptr);
                  end
              else
                for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                  Inc(pt_pix_sht_arr_ptr);
            end
          else
            begin
              b0:=(0+(v3>>16)>=rct_clp_ptr^.top) and (0+(v3>>16)<rct_clp_ptr^.bottom);
              b1:=(1+(v3>>16)>=rct_clp_ptr^.top) and (1+(v3>>16)<rct_clp_ptr^.bottom);
              if b0 then
                begin
                  if b1 then
                    for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                      begin
                        v1                                          :=(scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16;
                        c0                                          :=(v1+0>=rct_clp_ptr^.left) and (v1+0<rct_clp_ptr^.right);
                        c1                                          :=(v1+1>=rct_clp_ptr^.left) and (v1+1<rct_clp_ptr^.right);
                        if c0 then
                          begin
                                  bmp_bkgnd_ptr2                    :=bmp_bkgnd_ptr+v1+v2;
                            PRGBA(bmp_bkgnd_ptr2+000000000000000)^.a:=0;
                            PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width)^.a:=0;
                          end;
                        if c1 then
                          begin
                                  bmp_bkgnd_ptr2                    :=bmp_bkgnd_ptr+v1+v2+1;
                            PRGBA(bmp_bkgnd_ptr2+000000000000000)^.a:=0;
                            PRGBA(bmp_bkgnd_ptr2+bmp_bkgnd_width)^.a:=0;
                          end;
                        Inc(pt_pix_sht_arr_ptr);
                      end
                  else
                    for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                      begin
                        v1                          :=(scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16;
                                bmp_bkgnd_ptr2      :=bmp_bkgnd_ptr+v1+v2;
                        if (v1+0>=rct_clp_ptr^.left) and (v1+0<rct_clp_ptr^.right) then
                          PRGBA(bmp_bkgnd_ptr2+0)^.a:=0;
                        if (v1+1>=rct_clp_ptr^.left) and (v1+1<rct_clp_ptr^.right) then
                          PRGBA(bmp_bkgnd_ptr2+1)^.a:=0;
                        Inc(pt_pix_sht_arr_ptr);
                      end;
                end
              else
                begin
                  if b1 then
                    for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                      begin
                        v1                          :=(scl_mul_x*pt_pix_sht_arr_ptr^+r1)>>16;
                                bmp_bkgnd_ptr2      :=bmp_bkgnd_ptr+v1+v2+bmp_bkgnd_width;
                        if (v1+0>=rct_clp_ptr^.left) and (v1+0<rct_clp_ptr^.right) then
                          PRGBA(bmp_bkgnd_ptr2+0)^.a:=0;
                        if (v1+1>=rct_clp_ptr^.left) and (v1+1<rct_clp_ptr^.right) then
                          PRGBA(bmp_bkgnd_ptr2+1)^.a:=0;
                        Inc(pt_pix_sht_arr_ptr);
                      end
                  else
                    for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                      Inc(pt_pix_sht_arr_ptr);
                end;
            end;
          Inc(pt_pix_cnt_arr_ptr);
          Inc(v3, scl_mul_y);
          Inc(g2,_scl_mul_y);
        end;
    end;
end; {$endregion}
procedure TFastImageProc.FilPTValueArrI;                                                                            {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TFastImageProc.FilPTValueArrJ;                                                                            {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TFastImageProc.FilPTValueArrK;                                                                            {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TFastImageProc.FilPTValueArrL;                                                                            {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TFastImageProc.FilPTValueArrM;                                                                            {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TFastImageProc.FilPTValueArrN;                                                                            {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{$endregion}

{Restore source image from compressed image------------} {$region -fold}
// NT - not transparent pixels:
procedure TFastImageProc.ResNTValueArr(var arr_src:TColorArr; const bmp_ftimg_width_:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  nt_pix_val_arr_ptr: PInteger;
  x,y               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (nt_pix_cnt=0) then
        Exit;
       first_row_pix_ptr:=Unaligned(@arr_src       [(nt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width_+bmp_src_rct_clp.left]);
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[ nt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000000]);
      nt_pix_sht_arr_ptr:=Unaligned(@nt_pix_sht_arr[ 000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      nt_pix_val_arr_ptr:=Unaligned(@nt_pix_val_arr[ 000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          for x:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
                     (nt_pix_sht_arr_ptr^+first_row_pix_ptr)^:=
                      nt_pix_val_arr_ptr^;
              Inc    (nt_pix_sht_arr_ptr);
              Inc    (nt_pix_val_arr_ptr);
            end;
          Inc        (nt_pix_cnt_arr_ptr);
          Inc( first_row_pix_ptr,bmp_ftimg_width_);
        end;
    end;
end; {$endregion}
// PT - partly transparent pixels:
procedure TFastImageProc.ResPTValueArr(var arr_src:TColorArr; const bmp_ftimg_width_:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_pix_val_arr_ptr: PInteger;
  x,y               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (nt_pix_cnt=0) then
        Exit;
       first_row_pix_ptr:=Unaligned(@arr_src       [(pt_pix_arr_row_mrg_top+bmp_src_rct_clp.top)*bmp_ftimg_width_+bmp_src_rct_clp.left]);
      pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr[ pt_pix_arr_row_mrg_top+0000000000000000000000000000000000000000000000000000000000]);
      pt_pix_sht_arr_ptr:=Unaligned(@pt_pix_sht_arr[ 000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      pt_pix_val_arr_ptr:=Unaligned(@pt_pix_val_arr[ 000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to bmp_src_rct_clp.height- pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
        begin
          for x:=0 to pt_pix_cnt_arr_ptr^-1 do
            begin
                     (pt_pix_sht_arr_ptr^+first_row_pix_ptr)^:=
                      pt_pix_val_arr_ptr^;
              Inc    (pt_pix_sht_arr_ptr);
              Inc    (pt_pix_val_arr_ptr);
            end;
          Inc        (pt_pix_cnt_arr_ptr);
          Inc( first_row_pix_ptr,bmp_ftimg_width_);
        end;
    end;
end; {$endregion}
{$endregion}

{Misc. init. proc.-------------------------------------} {$region -fold}

// Check NTValueArr:
function  TFastImageProc.ChkNTValueArr: boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    Result:=({@}nt_pix_val_arr{[0]}=Nil);
end; {$endregion}

// NT - not transparent pixels:
procedure TFastImageProc.SetNTNilToPtr(const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TFastImageProc.SetNTCCLToPtr(const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
   fast_image_data_     .nt_pix_arr_ptr:=
  @fast_image_data_ptr_^.nt_pix_ccl_arr[0];
end; {$endregion}
procedure TFastImageProc.SetNTCLLToPtr(const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
   fast_image_data_     .nt_pix_arr_ptr:=
  @fast_image_data_ptr_^.nt_pix_cll_arr[0];
end; {$endregion}

// PT - partly transparent pixels:
procedure TFastImageProc.SetPTNilToPtr(const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TFastImageProc.SetPTCCLToPtr(const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
   fast_image_data_     .pt_pix_arr_ptr:=
  @fast_image_data_ptr_^.pt_pix_ccl_arr[0];
end; {$endregion}
procedure TFastImageProc.SetPTCLLToPtr(const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
   fast_image_data_     .pt_pix_arr_ptr:=
  @fast_image_data_ptr_^.pt_pix_cll_arr[0];
end; {$endregion}

// Procedures table init.:
procedure TFastimageProc.FilProcInit; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  // NT - not transparent pixels:
  GenNTBeginProc[000]:=Unaligned(@SetNTNilToPtr);
  GenNTBeginProc[001]:=Unaligned(@SetNTCCLToPtr);
  GenNTBeginProc[002]:=Unaligned(@SetNTCLLToPtr);

  // PT - partly transparent pixels:
  GenPTBeginProc[000]:=Unaligned(@SetPTNilToPtr);
  GenPTBeginProc[001]:=Unaligned(@SetPTCCLToPtr);
  GenPTBeginProc[002]:=Unaligned(@SetPTCLLToPtr);

  {Regular  floodFill} {$region -fold}

  // NT - not transparent pixels:

  {Color} {$region -fold}

  {||scl_mul||=1:                  } {$region -fold}

  {Empty}
  RegNTColorProc[009]:=Unaligned(@RegNTColor009);

  {Color of Curent Layer}
  // (constant) not clipped
  RegNTColorProc[000]:=Unaligned(@RegNTColor000);
  // (constant) top-bottom clipped
  RegNTColorProc[002]:=Unaligned(@RegNTColor000);
  // (constant) left-right-top-bottom clipped
  RegNTColorProc[004]:=Unaligned(@RegNTColor004);
  // (constant) image has monochrome color channel
  RegNTColorProc[006]:=Unaligned(@RegNTColor006);
  // (fading) not clipped
  RegNTColorProc[001]:=Unaligned(@RegNTColor020);
  // (fading) top-bottom clipped
  RegNTColorProc[003]:=Unaligned(@RegNTColor020);
  // (fading) left-right-top-bottom clipped
  RegNTColorProc[005]:=Unaligned(@RegNTColor024);
  // (fading) image has monochrome color channel
  RegNTColorProc[007]:=Unaligned(@RegNTColor026);

  {Color of Curent Layer(Additive)}
  // (constant) not clipped
  RegNTColorProc[010]:=Unaligned(@RegNTColor010);
  // (constant) top-bottom clipped
  RegNTColorProc[012]:=Unaligned(@RegNTColor010);
  // (constant) left-right-top-bottom clipped
  RegNTColorProc[014]:=Unaligned(@RegNTColor014);
  // (constant) image has monochrome color channel
  RegNTColorProc[016]:=Unaligned(@RegNTColor016);
  // (fading) not clipped
  RegNTColorProc[011]:=Unaligned(@RegNTColor011);
  // (fading) top-bottom clipped
  RegNTColorProc[013]:=Unaligned(@RegNTColor011);
  // (fading) left-right-top-bottom clipped
  RegNTColorProc[015]:=Unaligned(@RegNTColor015);
  // (fading) image has monochrome color channel
  RegNTColorProc[017]:=Unaligned(@RegNTColor017);

  {Color of Curent Layer(Alphablend)}
  // (constant) not clipped
  RegNTColorProc[020]:=Unaligned(@RegNTColor020);
  // (constant) top-bottom clipped
  RegNTColorProc[022]:=Unaligned(@RegNTColor020);
  // (constant) left-right-top-bottom clipped
  RegNTColorProc[024]:=Unaligned(@RegNTColor024);
  // (constant) image has monochrome color channel
  RegNTColorProc[026]:=Unaligned(@RegNTColor026);
  // (fading) not clipped
  RegNTColorProc[021]:=Unaligned(@RegNTColor020);
  // (fading) top-bottom clipped
  RegNTColorProc[023]:=Unaligned(@RegNTColor020);
  // (fading) left-right-top-bottom clipped
  RegNTColorProc[025]:=Unaligned(@RegNTColor024);
  // (fading) image has monochrome color channel
  RegNTColorProc[027]:=Unaligned(@RegNTColor026);

  {$endregion}

  {||scl_mul||<1: (SD - Scale Down)} {$region -fold}

  {Empty}
  RSDNTColorProc[009]:=Unaligned(@RSDNTColor009);

  {Color of Curent Layer}
  // (constant) not clipped
  RSDNTColorProc[000]:=Unaligned(@RSDNTColor000);
  // (constant) top-bottom clipped
  RSDNTColorProc[002]:=Unaligned(@RSDNTColor002);
  // (constant) left-right-top-bottom clipped
  RSDNTColorProc[004]:=Unaligned(@RSDNTColor004);
  // (constant) image has monochrome color channel
  RSDNTColorProc[006]:=Unaligned(@RSDNTColor006);
  // (fading) not clipped
  RSDNTColorProc[001]:=Unaligned(@RSDNTColor020);
  // (fading) top-bottom clipped
  RSDNTColorProc[003]:=Unaligned(@RSDNTColor022);
  // (fading) left-right-top-bottom clipped
  RSDNTColorProc[005]:=Unaligned(@RSDNTColor024);
  // (fading) image has monochrome color channel
  RSDNTColorProc[007]:=Unaligned(@RSDNTColor026);

  {Color of Curent Layer(Additive)}
  // (constant) not clipped
  RSDNTColorProc[010]:=Unaligned(@RSDNTColor010);
  // (constant) top-bottom clipped
  RSDNTColorProc[012]:=Unaligned(@RSDNTColor012);
  // (constant) left-right-top-bottom clipped
  RSDNTColorProc[014]:=Unaligned(@RSDNTColor014);
  // (constant) image has monochrome color channel
  RSDNTColorProc[016]:=Unaligned(@RSDNTColor016);
  // (fading) not clipped
  RSDNTColorProc[011]:=Unaligned(@RSDNTColor011);
  // (fading) top-bottom clipped
  RSDNTColorProc[013]:=Unaligned(@RSDNTColor013);
  // (fading) left-right-top-bottom clipped
  RSDNTColorProc[015]:=Unaligned(@RSDNTColor015);
  // (fading) image has monochrome color channel
  RSDNTColorProc[017]:=Unaligned(@RSDNTColor017);

  {Color of Curent Layer(Alphablend)}
  // (constant) not clipped
  RSDNTColorProc[020]:=Unaligned(@RSDNTColor020);
  // (constant) top-bottom clipped
  RSDNTColorProc[022]:=Unaligned(@RSDNTColor022);
  // (constant) left-right-top-bottom clipped
  RSDNTColorProc[024]:=Unaligned(@RSDNTColor024);
  // (constant) image has monochrome color channel
  RSDNTColorProc[026]:=Unaligned(@RSDNTColor026);
  // (fading) not clipped
  RSDNTColorProc[021]:=Unaligned(@RSDNTColor020);
  // (fading) top-bottom clipped
  RegNTColorProc[023]:=Unaligned(@RSDNTColor022);
  // (fading) left-right-top-bottom clipped
  RSDNTColorProc[025]:=Unaligned(@RSDNTColor024);
  // (fading) image has monochrome color channel
  RSDNTColorProc[027]:=Unaligned(@RSDNTColor026);

  {$endregion}

  {||scl_mul||>1: (SU - Scale Up  )} {$region -fold}

  {Empty}
  RSUNTColorProc[009]:=Unaligned(@RSUNTColor009);

  {Color of Curent Layer}
  // (constant) not clipped
  RSUNTColorProc[000]:=Unaligned(@RSUNTColor000);
  // (constant) top-bottom clipped
  RSUNTColorProc[002]:=Unaligned(@RSUNTColor002);
  // (constant) left-right-top-bottom clipped
  RSUNTColorProc[004]:=Unaligned(@RSUNTColor004);
  // (constant) image has monochrome color channel
  RSUNTColorProc[006]:=Unaligned(@RSUNTColor006);
  // (fading) not clipped
  RSUNTColorProc[001]:=Unaligned(@RSUNTColor020);
  // (fading) top-bottom clipped
  RSUNTColorProc[003]:=Unaligned(@RSUNTColor022);
  // (fading) left-right-top-bottom clipped
  RSUNTColorProc[005]:=Unaligned(@RSUNTColor024);
  // (fading) image has monochrome color channel
  RSUNTColorProc[007]:=Unaligned(@RSUNTColor026);

  {Color of Curent Layer(Additive)}
  // (constant) not clipped
  RSUNTColorProc[010]:=Unaligned(@RSUNTColor010);
  // (constant) top-bottom clipped
  RSUNTColorProc[012]:=Unaligned(@RSUNTColor012);
  // (constant) left-right-top-bottom clipped
  RSUNTColorProc[014]:=Unaligned(@RSUNTColor014);
  // (constant) image has monochrome color channel
  RSUNTColorProc[016]:=Unaligned(@RSUNTColor016);
  // (fading) not clipped
  RSUNTColorProc[011]:=Unaligned(@RSUNTColor011);
  // (fading) top-bottom clipped
  RSUNTColorProc[013]:=Unaligned(@RSUNTColor013);
  // (fading) left-right-top-bottom clipped
  RSUNTColorProc[015]:=Unaligned(@RSUNTColor015);
  // (fading) image has monochrome color channel
  RSUNTColorProc[017]:=Unaligned(@RSUNTColor017);

  {Color of Curent Layer(Alphablend)}
  // (constant) not clipped
  RSUNTColorProc[020]:=Unaligned(@RSUNTColor020);
  // (constant) top-bottom clipped
  RSUNTColorProc[022]:=Unaligned(@RSUNTColor022);
  // (constant) left-right-top-bottom clipped
  RSUNTColorProc[024]:=Unaligned(@RSUNTColor024);
  // (constant) image has monochrome color channel
  RSUNTColorProc[026]:=Unaligned(@RSUNTColor026);
  // (fading) not clipped
  RSUNTColorProc[021]:=Unaligned(@RSUNTColor020);
  // (fading) top-bottom clipped
  RSUNTColorProc[023]:=Unaligned(@RSUNTColor022);
  // (fading) left-right-top-bottom clipped
  RSUNTColorProc[025]:=Unaligned(@RSUNTColor024);
  // (fading) image has monochrome color channel
  RSUNTColorProc[027]:=Unaligned(@RSUNTColor026);

  {$endregion}

  {$endregion}

  {Value} {$region -fold}

  {||scl_mul||=1:                  } {$region -fold}

  {Empty}
  RegNTValueProc[009]:=Unaligned(@RegNTValue009);

  {Monochrome}
  // (constant) not clipped
  RegNTValueProc[000]:=Unaligned(@RegNTValue000);
  // (constant) top-bottom clipped
  RegNTValueProc[002]:=Unaligned(@RegNTValue000);
  // (constant) left-right-top-bottom clipped
  RegNTValueProc[004]:=Unaligned(@RegNTValue004);
  // (constant) image has monochrome color channel
  RegNTValueProc[006]:=Unaligned(@RegNTValue006);
  // (fading) not clipped
  RegNTValueProc[001]:=Unaligned(@RegNTValue020);
  // (fading) top-bottom clipped
  RegNTValueProc[003]:=Unaligned(@RegNTValue020);
  // (fading) left-right-top-bottom clipped
  RegNTValueProc[005]:=Unaligned(@RegNTValue024);
  // (fading) image has monochrome color channel
  RegNTValueProc[007]:=Unaligned(@RegNTValue026);

  {Additive}
  // (constant) not clipped
  RegNTValueProc[010]:=Unaligned(@RegNTValue010);
  // (constant) top-bottom clipped
  RegNTValueProc[012]:=Unaligned(@RegNTValue010);
  // (constant) left-right-top-bottom clipped
  RegNTValueProc[014]:=Unaligned(@RegNTValue014);
  // (constant) image has monochrome color channel
  RegNTValueProc[016]:=Unaligned(@RegNTValue016);
  // (fading) not clipped
  RegNTValueProc[011]:=Unaligned(@RegNTValue011);
  // (fading) top-bottom clipped
  RegNTValueProc[013]:=Unaligned(@RegNTValue011);
  // (fading) left-right-top-bottom clipped
  RegNTValueProc[015]:=Unaligned(@RegNTValue015);
  // (fading) image has monochrome color channel
  RegNTValueProc[017]:=Unaligned(@RegNTValue017);

  {Alphablend}
  // (constant) not clipped
  RegNTValueProc[020]:=Unaligned(@RegNTValue020);
  // (constant) top-bottom clipped
  RegNTValueProc[022]:=Unaligned(@RegNTValue020);
  // (constant) left-right-top-bottom clipped
  RegNTValueProc[024]:=Unaligned(@RegNTValue024);
  // (constant) image has monochrome color channel
  RegNTValueProc[026]:=Unaligned(@RegNTValue026);
  // (fading) not clipped
  RegNTValueProc[021]:=Unaligned(@RegNTValue020);
  // (fading) top-bottom clipped
  RegNTValueProc[023]:=Unaligned(@RegNTValue020);
  // (fading) left-right-top-bottom clipped
  RegNTValueProc[025]:=Unaligned(@RegNTValue024);
  // (fading) image has monochrome color channel
  RegNTValueProc[027]:=Unaligned(@RegNTValue026);

  {Inverse}
  // (constant) not clipped
  RegNTValueProc[030]:=Unaligned(@RegNTValue030);
  // (constant) top-bottom clipped
  RegNTValueProc[032]:=Unaligned(@RegNTValue030);
  // (constant) left-right-top-bottom clipped
  RegNTValueProc[034]:=Unaligned(@RegNTValue034);
  // (constant) image has monochrome color channel
  RegNTValueProc[036]:=Unaligned(@RegNTValue036);
  // (fading) not clipped
  RegNTValueProc[031]:=Unaligned(@RegNTValue031);
  // (fading) top-bottom clipped
  RegNTValueProc[033]:=Unaligned(@RegNTValue031);
  // (fading) left-right-top-bottom clipped
  RegNTValueProc[035]:=Unaligned(@RegNTValue035);
  // (fading) image has monochrome color channel
  RegNTValueProc[037]:=Unaligned(@RegNTValue037);

  {Highlight}
  // (constant) not clipped
  RegNTValueProc[040]:=Unaligned(@RegNTValue040);
  // (constant) top-bottom clipped
  RegNTValueProc[042]:=Unaligned(@RegNTValue040);
  // (constant) left-right-top-bottom clipped
  RegNTValueProc[044]:=Unaligned(@RegNTValue044);
  // (constant) image has monochrome color channel
  RegNTValueProc[046]:=Unaligned(@RegNTValue046);
  // (fading) not clipped
  RegNTValueProc[041]:=Unaligned(@RegNTValue040);
  // (fading) top-bottom clipped
  RegNTValueProc[043]:=Unaligned(@RegNTValue040);
  // (fading) left-right-top-bottom clipped
  RegNTValueProc[045]:=Unaligned(@RegNTValue044);
  // (fading) image has monochrome color channel
  RegNTValueProc[047]:=Unaligned(@RegNTValue046);

  {Darken}
  // (constant) not clipped
  RegNTValueProc[050]:=Unaligned(@RegNTValue050);
  // (constant) top-bottom clipped
  RegNTValueProc[052]:=Unaligned(@RegNTValue050);
  // (constant) left-right-top-bottom clipped
  RegNTValueProc[054]:=Unaligned(@RegNTValue054);
  // (constant) image has monochrome color channel
  RegNTValueProc[056]:=Unaligned(@RegNTValue056);
  // (fading) not clipped
  RegNTValueProc[051]:=Unaligned(@RegNTValue050);
  // (fading) top-bottom clipped
  RegNTValueProc[053]:=Unaligned(@RegNTValue050);
  // (fading) left-right-top-bottom clipped
  RegNTValueProc[055]:=Unaligned(@RegNTValue054);
  // (fading) image has monochrome color channel
  RegNTValueProc[057]:=Unaligned(@RegNTValue056);

  {GrayscaleR}
  // (constant) not clipped
  RegNTValueProc[060]:=Unaligned(@RegNTValue060);
  // (constant) top-bottom clipped
  RegNTValueProc[062]:=Unaligned(@RegNTValue060);
  // (constant) left-right-top-bottom clipped
  RegNTValueProc[064]:=Unaligned(@RegNTValue064);
  // (constant) image has monochrome color channel
  RegNTValueProc[066]:=Unaligned(@RegNTValue066);
  // (fading) not clipped
  RegNTValueProc[061]:=Unaligned(@RegNTValue061);
  // (fading) top-bottom clipped
  RegNTValueProc[063]:=Unaligned(@RegNTValue061);
  // (fading) left-right-top-bottom clipped
  RegNTValueProc[065]:=Unaligned(@RegNTValue065);
  // (fading) image has monochrome color channel
  RegNTValueProc[067]:=Unaligned(@RegNTValue067);

  {GrayscaleG}
  // (constant) not clipped
  RegNTValueProc[070]:=Unaligned(@RegNTValue070);
  // (constant) top-bottom clipped
  RegNTValueProc[072]:=Unaligned(@RegNTValue070);
  // (constant) left-right-top-bottom clipped
  RegNTValueProc[074]:=Unaligned(@RegNTValue074);
  // (constant) image has monochrome color channel
  RegNTValueProc[076]:=Unaligned(@RegNTValue076);
  // (fading) not clipped
  RegNTValueProc[071]:=Unaligned(@RegNTValue071);
  // (fading) top-bottom clipped
  RegNTValueProc[073]:=Unaligned(@RegNTValue071);
  // (fading) left-right-top-bottom clipped
  RegNTValueProc[075]:=Unaligned(@RegNTValue075);
  // (fading) image has monochrome color channel
  RegNTValueProc[077]:=Unaligned(@RegNTValue077);

  {GrayscaleB}
  // (constant) not clipped
  RegNTValueProc[080]:=Unaligned(@RegNTValue080);
  // (constant) top-bottom clipped
  RegNTValueProc[082]:=Unaligned(@RegNTValue080);
  // (constant) left-right-top-bottom clipped
  RegNTValueProc[084]:=Unaligned(@RegNTValue084);
  // (constant) image has monochrome color channel
  RegNTValueProc[086]:=Unaligned(@RegNTValue086);
  // (fading) not clipped
  RegNTValueProc[081]:=Unaligned(@RegNTValue081);
  // (fading) top-bottom clipped
  RegNTValueProc[083]:=Unaligned(@RegNTValue081);
  // (fading) left-right-top-bottom clipped
  RegNTValueProc[085]:=Unaligned(@RegNTValue085);
  // (fading) image has monochrome color channel
  RegNTValueProc[087]:=Unaligned(@RegNTValue087);

  {Monochrome Noise}
  // (constant) not clipped
  RegNTValueProc[090]:=Unaligned(@RegNTValue090);
  // (constant) top-bottom clipped
  RegNTValueProc[092]:=Unaligned(@RegNTValue090);
  // (constant) left-right-top-bottom clipped
  RegNTValueProc[094]:=Unaligned(@RegNTValue094);
  // (constant) image has monochrome color channel
  RegNTValueProc[096]:=Unaligned(@RegNTValue096);
  // (fading) not clipped
  RegNTValueProc[091]:=Unaligned(@RegNTValue091);
  // (fading) top-bottom clipped
  RegNTValueProc[093]:=Unaligned(@RegNTValue091);
  // (fading) left-right-top-bottom clipped
  RegNTValueProc[095]:=Unaligned(@RegNTValue095);
  // (fading) image has monochrome color channel
  RegNTValueProc[097]:=Unaligned(@RegNTValue097);

  {ColorizeR}
  // (constant) not clipped
  RegNTValueProc[100]:=Unaligned(@RegNTValue100);
  // (constant) top-bottom clipped
  RegNTValueProc[102]:=Unaligned(@RegNTValue100);
  // (constant) left-right-top-bottom clipped
  RegNTValueProc[104]:=Unaligned(@RegNTValue104);
  // (constant) image has monochrome color channel
  RegNTValueProc[106]:=Unaligned(@RegNTValue106);
  // (fading) not clipped
  RegNTValueProc[101]:=Unaligned(@RegNTValue100);
  // (fading) top-bottom clipped
  RegNTValueProc[103]:=Unaligned(@RegNTValue100);
  // (fading) left-right-top-bottom clipped
  RegNTValueProc[105]:=Unaligned(@RegNTValue104);
  // (fading) image has monochrome color channel
  RegNTValueProc[107]:=Unaligned(@RegNTValue106);

  {ColorizeG}
  // (constant) not clipped
  RegNTValueProc[110]:=Unaligned(@RegNTValue110);
  // (constant) top-bottom clipped
  RegNTValueProc[112]:=Unaligned(@RegNTValue110);
  // (constant) left-right-top-bottom clipped
  RegNTValueProc[114]:=Unaligned(@RegNTValue114);
  // (constant) image has monochrome color channel
  RegNTValueProc[116]:=Unaligned(@RegNTValue116);
  // (fading) not clipped
  RegNTValueProc[111]:=Unaligned(@RegNTValue110);
  // (fading) top-bottom clipped
  RegNTValueProc[113]:=Unaligned(@RegNTValue110);
  // (fading) left-right-top-bottom clipped
  RegNTValueProc[115]:=Unaligned(@RegNTValue114);
  // (fading) image has monochrome color channel
  RegNTValueProc[117]:=Unaligned(@RegNTValue116);

  {ColorizeB}
  // (constant) not clipped
  RegNTValueProc[120]:=Unaligned(@RegNTValue120);
  // (constant) top-bottom clipped
  RegNTValueProc[122]:=Unaligned(@RegNTValue120);
  // (constant) left-right-top-bottom clipped
  RegNTValueProc[124]:=Unaligned(@RegNTValue124);
  // (constant) image has monochrome color channel
  RegNTValueProc[126]:=Unaligned(@RegNTValue126);
  // (fading) not clipped
  RegNTValueProc[121]:=Unaligned(@RegNTValue120);
  // (fading) top-bottom clipped
  RegNTValueProc[123]:=Unaligned(@RegNTValue120);
  // (fading) left-right-top-bottom clipped
  RegNTValueProc[125]:=Unaligned(@RegNTValue124);
  // (fading) image has monochrome color channel
  RegNTValueProc[127]:=Unaligned(@RegNTValue126);

  {BlurRGB}
  // (constant) not clipped
  RegNTValueProc[130]:=Unaligned(@RegNTValue130);
  // (constant) top-bottom clipped
  RegNTValueProc[132]:=Unaligned(@RegNTValue130);
  // (constant) left-right-top-bottom clipped
  RegNTValueProc[134]:=Unaligned(@RegNTValue134);
  // (constant) image has monochrome color channel
  RegNTValueProc[136]:=Unaligned(@RegNTValue136);
  // (fading) not clipped
  RegNTValueProc[131]:=Unaligned(@RegNTValue131);
  // (fading) top-bottom clipped
  RegNTValueProc[133]:=Unaligned(@RegNTValue131);
  // (fading) left-right-top-bottom clipped
  RegNTValueProc[135]:=Unaligned(@RegNTValue135);
  // (fading) image has monochrome color channel
  RegNTValueProc[137]:=Unaligned(@RegNTValue137);

  {BlurRRB}
  // (constant) not clipped
  RegNTValueProc[140]:=Unaligned(@RegNTValue140);
  // (constant) top-bottom clipped
  RegNTValueProc[142]:=Unaligned(@RegNTValue140);
  // (constant) left-right-top-bottom clipped
  RegNTValueProc[144]:=Unaligned(@RegNTValue144);
  // (constant) image has monochrome color channel
  RegNTValueProc[146]:=Unaligned(@RegNTValue146);
  // (fading) not clipped
  RegNTValueProc[141]:=Unaligned(@RegNTValue141);
  // (fading) top-bottom clipped
  RegNTValueProc[143]:=Unaligned(@RegNTValue141);
  // (fading) left-right-top-bottom clipped
  RegNTValueProc[145]:=Unaligned(@RegNTValue145);
  // (fading) image has monochrome color channel
  RegNTValueProc[147]:=Unaligned(@RegNTValue147);

  {BlurRGR}
  // (constant) not clipped
  RegNTValueProc[150]:=Unaligned(@RegNTValue150);
  // (constant) top-bottom clipped
  RegNTValueProc[152]:=Unaligned(@RegNTValue150);
  // (constant) left-right-top-bottom clipped
  RegNTValueProc[154]:=Unaligned(@RegNTValue154);
  // (constant) image has monochrome color channel
  RegNTValueProc[156]:=Unaligned(@RegNTValue156);
  // (fading) not clipped
  RegNTValueProc[151]:=Unaligned(@RegNTValue151);
  // (fading) top-bottom clipped
  RegNTValueProc[153]:=Unaligned(@RegNTValue151);
  // (fading) left-right-top-bottom clipped
  RegNTValueProc[155]:=Unaligned(@RegNTValue155);
  // (fading) image has monochrome color channel
  RegNTValueProc[157]:=Unaligned(@RegNTValue157);

  {BlurGGB}
  // (constant) not clipped
  RegNTValueProc[160]:=Unaligned(@RegNTValue160);
  // (constant) top-bottom clipped
  RegNTValueProc[162]:=Unaligned(@RegNTValue160);
  // (constant) left-right-top-bottom clipped
  RegNTValueProc[164]:=Unaligned(@RegNTValue164);
  // (constant) image has monochrome color channel
  RegNTValueProc[166]:=Unaligned(@RegNTValue166);
  // (fading) not clipped
  RegNTValueProc[161]:=Unaligned(@RegNTValue161);
  // (fading) top-bottom clipped
  RegNTValueProc[163]:=Unaligned(@RegNTValue161);
  // (fading) left-right-top-bottom clipped
  RegNTValueProc[165]:=Unaligned(@RegNTValue165);
  // (fading) image has monochrome color channel
  RegNTValueProc[167]:=Unaligned(@RegNTValue167);

  {BlurRGG}
  // (constant) not clipped
  RegNTValueProc[170]:=Unaligned(@RegNTValue170);
  // (constant) top-bottom clipped
  RegNTValueProc[172]:=Unaligned(@RegNTValue170);
  // (constant) left-right-top-bottom clipped
  RegNTValueProc[174]:=Unaligned(@RegNTValue174);
  // (constant) image has monochrome color channel
  RegNTValueProc[176]:=Unaligned(@RegNTValue176);
  // (fading) not clipped
  RegNTValueProc[171]:=Unaligned(@RegNTValue171);
  // (fading) top-bottom clipped
  RegNTValueProc[173]:=Unaligned(@RegNTValue171);
  // (fading) left-right-top-bottom clipped
  RegNTValueProc[175]:=Unaligned(@RegNTValue175);
  // (fading) image has monochrome color channel
  RegNTValueProc[177]:=Unaligned(@RegNTValue177);

  {BlurBGB}
  // (constant) not clipped
  RegNTValueProc[180]:=Unaligned(@RegNTValue180);
  // (constant) top-bottom clipped
  RegNTValueProc[182]:=Unaligned(@RegNTValue180);
  // (constant) left-right-top-bottom clipped
  RegNTValueProc[184]:=Unaligned(@RegNTValue184);
  // (constant) image has monochrome color channel
  RegNTValueProc[186]:=Unaligned(@RegNTValue186);
  // (fading) not clipped
  RegNTValueProc[181]:=Unaligned(@RegNTValue181);
  // (fading) top-bottom clipped
  RegNTValueProc[183]:=Unaligned(@RegNTValue181);
  // (fading) left-right-top-bottom clipped
  RegNTValueProc[185]:=Unaligned(@RegNTValue185);
  // (fading) image has monochrome color channel
  RegNTValueProc[187]:=Unaligned(@RegNTValue187);

  {BlurRBB}
  // (constant) not clipped
  RegNTValueProc[190]:=Unaligned(@RegNTValue190);
  // (constant) top-bottom clipped
  RegNTValueProc[192]:=Unaligned(@RegNTValue190);
  // (constant) left-right-top-bottom clipped
  RegNTValueProc[194]:=Unaligned(@RegNTValue194);
  // (constant) image has monochrome color channel
  RegNTValueProc[196]:=Unaligned(@RegNTValue196);
  // (fading) not clipped
  RegNTValueProc[191]:=Unaligned(@RegNTValue191);
  // (fading) top-bottom clipped
  RegNTValueProc[193]:=Unaligned(@RegNTValue191);
  // (fading) left-right-top-bottom clipped
  RegNTValueProc[195]:=Unaligned(@RegNTValue195);
  // (fading) image has monochrome color channel
  RegNTValueProc[197]:=Unaligned(@RegNTValue197);

  {BlurRRR}
  // (constant) not clipped
  RegNTValueProc[200]:=Unaligned(@RegNTValue200);
  // (constant) top-bottom clipped
  RegNTValueProc[202]:=Unaligned(@RegNTValue200);
  // (constant) left-right-top-bottom clipped
  RegNTValueProc[204]:=Unaligned(@RegNTValue204);
  // (constant) image has monochrome color channel
  RegNTValueProc[206]:=Unaligned(@RegNTValue206);
  // (fading) not clipped
  RegNTValueProc[201]:=Unaligned(@RegNTValue201);
  // (fading) top-bottom clipped
  RegNTValueProc[203]:=Unaligned(@RegNTValue201);
  // (fading) left-right-top-bottom clipped
  RegNTValueProc[205]:=Unaligned(@RegNTValue205);
  // (fading) image has monochrome color channel
  RegNTValueProc[207]:=Unaligned(@RegNTValue207);

  {BlurGGG}
  // (constant) not clipped
  RegNTValueProc[210]:=Unaligned(@RegNTValue210);
  // (constant) top-bottom clipped
  RegNTValueProc[212]:=Unaligned(@RegNTValue210);
  // (constant) left-right-top-bottom clipped
  RegNTValueProc[214]:=Unaligned(@RegNTValue214);
  // (constant) image has monochrome color channel
  RegNTValueProc[216]:=Unaligned(@RegNTValue216);
  // (fading) not clipped
  RegNTValueProc[211]:=Unaligned(@RegNTValue211);
  // (fading) top-bottom clipped
  RegNTValueProc[213]:=Unaligned(@RegNTValue211);
  // (fading) left-right-top-bottom clipped
  RegNTValueProc[215]:=Unaligned(@RegNTValue215);
  // (fading) image has monochrome color channel
  RegNTValueProc[217]:=Unaligned(@RegNTValue217);

  {BlurBBB}
  // (constant) not clipped
  RegNTValueProc[220]:=Unaligned(@RegNTValue220);
  // (constant) top-bottom clipped
  RegNTValueProc[222]:=Unaligned(@RegNTValue220);
  // (constant) left-right-top-bottom clipped
  RegNTValueProc[224]:=Unaligned(@RegNTValue224);
  // (constant) image has monochrome color channel
  RegNTValueProc[226]:=Unaligned(@RegNTValue226);
  // (fading) not clipped
  RegNTValueProc[221]:=Unaligned(@RegNTValue221);
  // (fading) top-bottom clipped
  RegNTValueProc[223]:=Unaligned(@RegNTValue221);
  // (fading) left-right-top-bottom clipped
  RegNTValueProc[225]:=Unaligned(@RegNTValue225);
  // (fading) image has monochrome color channel
  RegNTValueProc[227]:=Unaligned(@RegNTValue227);

  {Contrast}
  // (constant) not clipped
  RegNTValueProc[230]:=Unaligned(@RegNTValue230);
  // (constant) top-bottom clipped
  RegNTValueProc[232]:=Unaligned(@RegNTValue230);
  // (constant) left-right-top-bottom clipped
  RegNTValueProc[234]:=Unaligned(@RegNTValue234);
  // (constant) image has monochrome color channel
  RegNTValueProc[236]:=Unaligned(@RegNTValue236);
  // (fading) not clipped
  RegNTValueProc[231]:=Unaligned(@RegNTValue230);
  // (fading) top-bottom clipped
  RegNTValueProc[233]:=Unaligned(@RegNTValue230);
  // (fading) left-right-top-bottom clipped
  RegNTValueProc[235]:=Unaligned(@RegNTValue234);
  // (fading) image has monochrome color channel
  RegNTValueProc[237]:=Unaligned(@RegNTValue236);

  {$endregion}

  {||scl_mul||<1: (SD - Scale Down)} {$region -fold}

  {Empty}
  RSDNTValueProc[009]:=Unaligned(@RSDNTValue009);

  {Monochrome}
  // (constant) not clipped
  RSDNTValueProc[000]:=Unaligned(@RSDNTValue000);
  // (constant) top-bottom clipped
  RSDNTValueProc[002]:=Unaligned(@RSDNTValue002);
  // (constant) left-right-top-bottom clipped
  RSDNTValueProc[004]:=Unaligned(@RSDNTValue004);
  // (constant) image has monochrome color channel
  RSDNTValueProc[006]:=Unaligned(@RSDNTValue006);
  // (fading) not clipped
  RSDNTValueProc[001]:=Unaligned(@RSDNTValue001);
  // (fading) top-bottom clipped
  RSDNTValueProc[003]:=Unaligned(@RSDNTValue003);
  // (fading) left-right-top-bottom clipped
  RSDNTValueProc[005]:=Unaligned(@RSDNTValue005);
  // (fading) image has monochrome color channel
  RSDNTValueProc[007]:=Unaligned(@RSDNTValue007);

  {Additive}
  // (constant) not clipped
  RSDNTValueProc[010]:=Unaligned(@RSDNTValue010);
  // (constant) top-bottom clipped
  RSDNTValueProc[012]:=Unaligned(@RSDNTValue012);
  // (constant) left-right-top-bottom clipped
  RSDNTValueProc[014]:=Unaligned(@RSDNTValue014);
  // (constant) image has monochrome color channel
  RSDNTValueProc[016]:=Unaligned(@RSDNTValue016);
  // (fading) not clipped
  RSDNTValueProc[011]:=Unaligned(@RSDNTValue011);
  // (fading) top-bottom clipped
  RSDNTValueProc[013]:=Unaligned(@RSDNTValue013);
  // (fading) left-right-top-bottom clipped
  RSDNTValueProc[015]:=Unaligned(@RSDNTValue015);
  // (fading) image has monochrome color channel
  RSDNTValueProc[017]:=Unaligned(@RSDNTValue017);

  {Alphablend}
  // (constant) not clipped
  RSDNTValueProc[020]:=Unaligned(@RSDNTValue020);
  // (constant) top-bottom clipped
  RSDNTValueProc[022]:=Unaligned(@RSDNTValue022);
  // (constant) left-right-top-bottom clipped
  RSDNTValueProc[024]:=Unaligned(@RSDNTValue024);
  // (constant) image has monochrome color channel
  RSDNTValueProc[026]:=Unaligned(@RSDNTValue026);
  // (fading) not clipped
  RSDNTValueProc[021]:=Unaligned(@RSDNTValue021);
  // (fading) top-bottom clipped
  RSDNTValueProc[023]:=Unaligned(@RSDNTValue023);
  // (fading) left-right-top-bottom clipped
  RSDNTValueProc[025]:=Unaligned(@RSDNTValue025);
  // (fading) image has monochrome color channel
  RSDNTValueProc[027]:=Unaligned(@RSDNTValue027);

  {Inverse}
  // (constant) not clipped
  RSDNTValueProc[030]:=Unaligned(@RSDNTValue030);
  // (constant) top-bottom clipped
  RSDNTValueProc[032]:=Unaligned(@RSDNTValue032);
  // (constant) left-right-top-bottom clipped
  RSDNTValueProc[034]:=Unaligned(@RSDNTValue034);
  // (constant) image has monochrome color channel
  RSDNTValueProc[036]:=Unaligned(@RSDNTValue036);
  // (fading) not clipped
  RSDNTValueProc[031]:=Unaligned(@RSDNTValue031);
  // (fading) top-bottom clipped
  RSDNTValueProc[033]:=Unaligned(@RSDNTValue033);
  // (fading) left-right-top-bottom clipped
  RSDNTValueProc[035]:=Unaligned(@RSDNTValue035);
  // (fading) image has monochrome color channel
  RSDNTValueProc[037]:=Unaligned(@RSDNTValue037);

  {Highlight}
  // (constant) not clipped
  RSDNTValueProc[040]:=Unaligned(@RSDNTValue040);
  // (constant) top-bottom clipped
  RSDNTValueProc[042]:=Unaligned(@RSDNTValue042);
  // (constant) left-right-top-bottom clipped
  RSDNTValueProc[044]:=Unaligned(@RSDNTValue044);
  // (constant) image has monochrome color channel
  RSDNTValueProc[046]:=Unaligned(@RSDNTValue046);
  // (fading) not clipped
  RSDNTValueProc[041]:=Unaligned(@RSDNTValue041);
  // (fading) top-bottom clipped
  RSDNTValueProc[043]:=Unaligned(@RSDNTValue043);
  // (fading) left-right-top-bottom clipped
  RSDNTValueProc[045]:=Unaligned(@RSDNTValue045);
  // (fading) image has monochrome color channel
  RSDNTValueProc[047]:=Unaligned(@RSDNTValue047);

  {Darken}
  // (constant) not clipped
  RSDNTValueProc[050]:=Unaligned(@RSDNTValue050);
  // (constant) top-bottom clipped
  RSDNTValueProc[052]:=Unaligned(@RSDNTValue052);
  // (constant) left-right-top-bottom clipped
  RSDNTValueProc[054]:=Unaligned(@RSDNTValue054);
  // (constant) image has monochrome color channel
  RSDNTValueProc[056]:=Unaligned(@RSDNTValue056);
  // (fading) not clipped
  RSDNTValueProc[051]:=Unaligned(@RSDNTValue051);
  // (fading) top-bottom clipped
  RSDNTValueProc[053]:=Unaligned(@RSDNTValue053);
  // (fading) left-right-top-bottom clipped
  RSDNTValueProc[055]:=Unaligned(@RSDNTValue055);
  // (fading) image has monochrome color channel
  RSDNTValueProc[057]:=Unaligned(@RSDNTValue057);

  {GrayscaleR}
  // (constant) not clipped
  RSDNTValueProc[060]:=Unaligned(@RSDNTValue060);
  // (constant) top-bottom clipped
  RSDNTValueProc[062]:=Unaligned(@RSDNTValue062);
  // (constant) left-right-top-bottom clipped
  RSDNTValueProc[064]:=Unaligned(@RSDNTValue064);
  // (constant) image has monochrome color channel
  RSDNTValueProc[066]:=Unaligned(@RSDNTValue066);
  // (fading) not clipped
  RSDNTValueProc[061]:=Unaligned(@RSDNTValue061);
  // (fading) top-bottom clipped
  RSDNTValueProc[063]:=Unaligned(@RSDNTValue063);
  // (fading) left-right-top-bottom clipped
  RSDNTValueProc[065]:=Unaligned(@RSDNTValue065);
  // (fading) image has monochrome color channel
  RSDNTValueProc[067]:=Unaligned(@RSDNTValue067);

  {GrayscaleG}
  // (constant) not clipped
  RSDNTValueProc[070]:=Unaligned(@RSDNTValue070);
  // (constant) top-bottom clipped
  RSDNTValueProc[072]:=Unaligned(@RSDNTValue072);
  // (constant) left-right-top-bottom clipped
  RSDNTValueProc[074]:=Unaligned(@RSDNTValue074);
  // (constant) image has monochrome color channel
  RSDNTValueProc[076]:=Unaligned(@RSDNTValue076);
  // (fading) not clipped
  RSDNTValueProc[071]:=Unaligned(@RSDNTValue071);
  // (fading) top-bottom clipped
  RSDNTValueProc[073]:=Unaligned(@RSDNTValue073);
  // (fading) left-right-top-bottom clipped
  RSDNTValueProc[075]:=Unaligned(@RSDNTValue075);
  // (fading) image has monochrome color channel
  RSDNTValueProc[077]:=Unaligned(@RSDNTValue077);

  {GrayscaleB}
  // (constant) not clipped
  RSDNTValueProc[080]:=Unaligned(@RSDNTValue080);
  // (constant) top-bottom clipped
  RSDNTValueProc[082]:=Unaligned(@RSDNTValue082);
  // (constant) left-right-top-bottom clipped
  RSDNTValueProc[084]:=Unaligned(@RSDNTValue084);
  // (constant) image has monochrome color channel
  RSDNTValueProc[086]:=Unaligned(@RSDNTValue086);
  // (fading) not clipped
  RSDNTValueProc[081]:=Unaligned(@RSDNTValue081);
  // (fading) top-bottom clipped
  RSDNTValueProc[083]:=Unaligned(@RSDNTValue083);
  // (fading) left-right-top-bottom clipped
  RSDNTValueProc[085]:=Unaligned(@RSDNTValue085);
  // (fading) image has monochrome color channel
  RSDNTValueProc[087]:=Unaligned(@RSDNTValue087);

  {Monochrome Noise}
  // (constant) not clipped
  RSDNTValueProc[090]:=Unaligned(@RSDNTValue090);
  // (constant) top-bottom clipped
  RSDNTValueProc[092]:=Unaligned(@RSDNTValue092);
  // (constant) left-right-top-bottom clipped
  RSDNTValueProc[094]:=Unaligned(@RSDNTValue094);
  // (constant) image has monochrome color channel
  RSDNTValueProc[096]:=Unaligned(@RSDNTValue096);
  // (fading) not clipped
  RSDNTValueProc[091]:=Unaligned(@RSDNTValue091);
  // (fading) top-bottom clipped
  RSDNTValueProc[093]:=Unaligned(@RSDNTValue093);
  // (fading) left-right-top-bottom clipped
  RSDNTValueProc[095]:=Unaligned(@RSDNTValue095);
  // (fading) image has monochrome color channel
  RSDNTValueProc[097]:=Unaligned(@RSDNTValue097);

  {ColorizeR}
  // (constant) not clipped
  RSDNTValueProc[100]:=Unaligned(@RSDNTValue100);
  // (constant) top-bottom clipped
  RSDNTValueProc[102]:=Unaligned(@RSDNTValue102);
  // (constant) left-right-top-bottom clipped
  RSDNTValueProc[104]:=Unaligned(@RSDNTValue104);
  // (constant) image has monochrome color channel
  RSDNTValueProc[106]:=Unaligned(@RSDNTValue106);
  // (fading) not clipped
  RSDNTValueProc[101]:=Unaligned(@RSDNTValue101);
  // (fading) top-bottom clipped
  RSDNTValueProc[103]:=Unaligned(@RSDNTValue103);
  // (fading) left-right-top-bottom clipped
  RSDNTValueProc[105]:=Unaligned(@RSDNTValue105);
  // (fading) image has monochrome color channel
  RSDNTValueProc[107]:=Unaligned(@RSDNTValue107);

  {ColorizeG}
  // (constant) not clipped
  RSDNTValueProc[110]:=Unaligned(@RSDNTValue110);
  // (constant) top-bottom clipped
  RSDNTValueProc[112]:=Unaligned(@RSDNTValue112);
  // (constant) left-right-top-bottom clipped
  RSDNTValueProc[114]:=Unaligned(@RSDNTValue114);
  // (constant) image has monochrome color channel
  RSDNTValueProc[116]:=Unaligned(@RSDNTValue116);
  // (fading) not clipped
  RSDNTValueProc[111]:=Unaligned(@RSDNTValue111);
  // (fading) top-bottom clipped
  RSDNTValueProc[113]:=Unaligned(@RSDNTValue113);
  // (fading) left-right-top-bottom clipped
  RSDNTValueProc[115]:=Unaligned(@RSDNTValue115);
  // (fading) image has monochrome color channel
  RSDNTValueProc[117]:=Unaligned(@RSDNTValue117);

  {ColorizeB}
  // (constant) not clipped
  RSDNTValueProc[120]:=Unaligned(@RSDNTValue120);
  // (constant) top-bottom clipped
  RSDNTValueProc[122]:=Unaligned(@RSDNTValue122);
  // (constant) left-right-top-bottom clipped
  RSDNTValueProc[124]:=Unaligned(@RSDNTValue124);
  // (constant) image has monochrome color channel
  RSDNTValueProc[126]:=Unaligned(@RSDNTValue126);
  // (fading) not clipped
  RSDNTValueProc[121]:=Unaligned(@RSDNTValue121);
  // (fading) top-bottom clipped
  RSDNTValueProc[123]:=Unaligned(@RSDNTValue123);
  // (fading) left-right-top-bottom clipped
  RSDNTValueProc[125]:=Unaligned(@RSDNTValue125);
  // (fading) image has monochrome color channel
  RSDNTValueProc[127]:=Unaligned(@RSDNTValue127);

  {BlurRGB}
  // (constant) not clipped
  RSDNTValueProc[130]:=Unaligned(@RSDNTValue130);
  // (constant) top-bottom clipped
  RSDNTValueProc[132]:=Unaligned(@RSDNTValue132);
  // (constant) left-right-top-bottom clipped
  RSDNTValueProc[134]:=Unaligned(@RSDNTValue134);
  // (constant) image has monochrome color channel
  RSDNTValueProc[136]:=Unaligned(@RSDNTValue136);
  // (fading) not clipped
  RSDNTValueProc[131]:=Unaligned(@RSDNTValue131);
  // (fading) top-bottom clipped
  RSDNTValueProc[133]:=Unaligned(@RSDNTValue133);
  // (fading) left-right-top-bottom clipped
  RSDNTValueProc[135]:=Unaligned(@RSDNTValue135);
  // (fading) image has monochrome color channel
  RSDNTValueProc[137]:=Unaligned(@RSDNTValue137);

  {BlurRRB}
  // (constant) not clipped
  RSDNTValueProc[140]:=Unaligned(@RSDNTValue140);
  // (constant) top-bottom clipped
  RSDNTValueProc[142]:=Unaligned(@RSDNTValue142);
  // (constant) left-right-top-bottom clipped
  RSDNTValueProc[144]:=Unaligned(@RSDNTValue144);
  // (constant) image has monochrome color channel
  RSDNTValueProc[146]:=Unaligned(@RSDNTValue146);
  // (fading) not clipped
  RSDNTValueProc[141]:=Unaligned(@RSDNTValue141);
  // (fading) top-bottom clipped
  RSDNTValueProc[143]:=Unaligned(@RSDNTValue143);
  // (fading) left-right-top-bottom clipped
  RSDNTValueProc[145]:=Unaligned(@RSDNTValue145);
  // (fading) image has monochrome color channel
  RSDNTValueProc[147]:=Unaligned(@RSDNTValue147);

  {BlurRGR}
  // (constant) not clipped
  RSDNTValueProc[150]:=Unaligned(@RSDNTValue150);
  // (constant) top-bottom clipped
  RSDNTValueProc[152]:=Unaligned(@RSDNTValue152);
  // (constant) left-right-top-bottom clipped
  RSDNTValueProc[154]:=Unaligned(@RSDNTValue154);
  // (constant) image has monochrome color channel
  RSDNTValueProc[156]:=Unaligned(@RSDNTValue156);
  // (fading) not clipped
  RSDNTValueProc[151]:=Unaligned(@RSDNTValue151);
  // (fading) top-bottom clipped
  RSDNTValueProc[153]:=Unaligned(@RSDNTValue153);
  // (fading) left-right-top-bottom clipped
  RSDNTValueProc[155]:=Unaligned(@RSDNTValue155);
  // (fading) image has monochrome color channel
  RSDNTValueProc[157]:=Unaligned(@RSDNTValue157);

  {BlurGGB}
  // (constant) not clipped
  RSDNTValueProc[160]:=Unaligned(@RSDNTValue160);
  // (constant) top-bottom clipped
  RSDNTValueProc[162]:=Unaligned(@RSDNTValue162);
  // (constant) left-right-top-bottom clipped
  RSDNTValueProc[164]:=Unaligned(@RSDNTValue164);
  // (constant) image has monochrome color channel
  RSDNTValueProc[166]:=Unaligned(@RSDNTValue166);
  // (fading) not clipped
  RSDNTValueProc[161]:=Unaligned(@RSDNTValue161);
  // (fading) top-bottom clipped
  RSDNTValueProc[163]:=Unaligned(@RSDNTValue163);
  // (fading) left-right-top-bottom clipped
  RSDNTValueProc[165]:=Unaligned(@RSDNTValue165);
  // (fading) image has monochrome color channel
  RSDNTValueProc[167]:=Unaligned(@RSDNTValue167);

  {BlurRGG}
  // (constant) not clipped
  RSDNTValueProc[170]:=Unaligned(@RSDNTValue170);
  // (constant) top-bottom clipped
  RSDNTValueProc[172]:=Unaligned(@RSDNTValue172);
  // (constant) left-right-top-bottom clipped
  RSDNTValueProc[174]:=Unaligned(@RSDNTValue174);
  // (constant) image has monochrome color channel
  RSDNTValueProc[176]:=Unaligned(@RSDNTValue176);
  // (fading) not clipped
  RSDNTValueProc[171]:=Unaligned(@RSDNTValue171);
  // (fading) top-bottom clipped
  RSDNTValueProc[173]:=Unaligned(@RSDNTValue173);
  // (fading) left-right-top-bottom clipped
  RSDNTValueProc[175]:=Unaligned(@RSDNTValue175);
  // (fading) image has monochrome color channel
  RSDNTValueProc[177]:=Unaligned(@RSDNTValue177);

  {BlurBGB}
  // (constant) not clipped
  RSDNTValueProc[180]:=Unaligned(@RSDNTValue180);
  // (constant) top-bottom clipped
  RSDNTValueProc[182]:=Unaligned(@RSDNTValue182);
  // (constant) left-right-top-bottom clipped
  RSDNTValueProc[184]:=Unaligned(@RSDNTValue184);
  // (constant) image has monochrome color channel
  RSDNTValueProc[186]:=Unaligned(@RSDNTValue186);
  // (fading) not clipped
  RSDNTValueProc[181]:=Unaligned(@RSDNTValue181);
  // (fading) top-bottom clipped
  RSDNTValueProc[183]:=Unaligned(@RSDNTValue183);
  // (fading) left-right-top-bottom clipped
  RSDNTValueProc[185]:=Unaligned(@RSDNTValue185);
  // (fading) image has monochrome color channel
  RSDNTValueProc[187]:=Unaligned(@RSDNTValue187);

  {BlurRBB}
  // (constant) not clipped
  RSDNTValueProc[190]:=Unaligned(@RSDNTValue190);
  // (constant) top-bottom clipped
  RSDNTValueProc[192]:=Unaligned(@RSDNTValue192);
  // (constant) left-right-top-bottom clipped
  RSDNTValueProc[194]:=Unaligned(@RSDNTValue194);
  // (constant) image has monochrome color channel
  RSDNTValueProc[196]:=Unaligned(@RSDNTValue196);
  // (fading) not clipped
  RSDNTValueProc[191]:=Unaligned(@RSDNTValue191);
  // (fading) top-bottom clipped
  RSDNTValueProc[193]:=Unaligned(@RSDNTValue193);
  // (fading) left-right-top-bottom clipped
  RSDNTValueProc[195]:=Unaligned(@RSDNTValue195);
  // (fading) image has monochrome color channel
  RSDNTValueProc[197]:=Unaligned(@RSDNTValue197);

  {BlurRRR}
  // (constant) not clipped
  RSDNTValueProc[200]:=Unaligned(@RSDNTValue200);
  // (constant) top-bottom clipped
  RSDNTValueProc[202]:=Unaligned(@RSDNTValue202);
  // (constant) left-right-top-bottom clipped
  RSDNTValueProc[204]:=Unaligned(@RSDNTValue204);
  // (constant) image has monochrome color channel
  RSDNTValueProc[206]:=Unaligned(@RSDNTValue206);
  // (fading) not clipped
  RSDNTValueProc[201]:=Unaligned(@RSDNTValue201);
  // (fading) top-bottom clipped
  RSDNTValueProc[203]:=Unaligned(@RSDNTValue203);
  // (fading) left-right-top-bottom clipped
  RSDNTValueProc[205]:=Unaligned(@RSDNTValue205);
  // (fading) image has monochrome color channel
  RSDNTValueProc[207]:=Unaligned(@RSDNTValue207);

  {BlurGGG}
  // (constant) not clipped
  RSDNTValueProc[210]:=Unaligned(@RSDNTValue210);
  // (constant) top-bottom clipped
  RSDNTValueProc[212]:=Unaligned(@RSDNTValue212);
  // (constant) left-right-top-bottom clipped
  RSDNTValueProc[214]:=Unaligned(@RSDNTValue214);
  // (constant) image has monochrome color channel
  RSDNTValueProc[216]:=Unaligned(@RSDNTValue216);
  // (fading) not clipped
  RSDNTValueProc[211]:=Unaligned(@RSDNTValue211);
  // (fading) top-bottom clipped
  RSDNTValueProc[213]:=Unaligned(@RSDNTValue213);
  // (fading) left-right-top-bottom clipped
  RSDNTValueProc[215]:=Unaligned(@RSDNTValue215);
  // (fading) image has monochrome color channel
  RSDNTValueProc[217]:=Unaligned(@RSDNTValue217);

  {BlurBBB}
  // (constant) not clipped
  RSDNTValueProc[220]:=Unaligned(@RSDNTValue220);
  // (constant) top-bottom clipped
  RSDNTValueProc[222]:=Unaligned(@RSDNTValue222);
  // (constant) left-right-top-bottom clipped
  RSDNTValueProc[224]:=Unaligned(@RSDNTValue224);
  // (constant) image has monochrome color channel
  RSDNTValueProc[226]:=Unaligned(@RSDNTValue226);
  // (fading) not clipped
  RSDNTValueProc[221]:=Unaligned(@RSDNTValue221);
  // (fading) top-bottom clipped
  RSDNTValueProc[223]:=Unaligned(@RSDNTValue223);
  // (fading) left-right-top-bottom clipped
  RSDNTValueProc[225]:=Unaligned(@RSDNTValue225);
  // (fading) image has monochrome color channel
  RSDNTValueProc[227]:=Unaligned(@RSDNTValue227);

  {Contrast}
  // (constant) not clipped
  RSDNTValueProc[230]:=Unaligned(@RSDNTValue230);
  // (constant) top-bottom clipped
  RSDNTValueProc[232]:=Unaligned(@RSDNTValue232);
  // (constant) left-right-top-bottom clipped
  RSDNTValueProc[234]:=Unaligned(@RSDNTValue234);
  // (constant) image has monochrome color channel
  RSDNTValueProc[236]:=Unaligned(@RSDNTValue236);
  // (fading) not clipped
  RSDNTValueProc[231]:=Unaligned(@RSDNTValue231);
  // (fading) top-bottom clipped
  RSDNTValueProc[233]:=Unaligned(@RSDNTValue233);
  // (fading) left-right-top-bottom clipped
  RSDNTValueProc[235]:=Unaligned(@RSDNTValue235);
  // (fading) image has monochrome color channel
  RSDNTValueProc[237]:=Unaligned(@RSDNTValue237);

  {$endregion}

  {||scl_mul||>1: (SU - Scale Up  )} {$region -fold}

  {Empty}
  RSUNTValueProc[009]:=Unaligned(@RSUNTValue009);

  {Monochrome}
  // (constant) not clipped
  RSUNTValueProc[000]:=Unaligned(@RSUNTValue000);
  // (constant) top-bottom clipped
  RSUNTValueProc[002]:=Unaligned(@RSUNTValue002);
  // (constant) left-right-top-bottom clipped
  RSUNTValueProc[004]:=Unaligned(@RSUNTValue004);
  // (constant) image has monochrome color channel
  RSUNTValueProc[006]:=Unaligned(@RSUNTValue006);
  // (fading) not clipped
  RSUNTValueProc[001]:=Unaligned(@RSUNTValue001);
  // (fading) top-bottom clipped
  RSUNTValueProc[003]:=Unaligned(@RSUNTValue003);
  // (fading) left-right-top-bottom clipped
  RSUNTValueProc[005]:=Unaligned(@RSUNTValue005);
  // (fading) image has monochrome color channel
  RSUNTValueProc[007]:=Unaligned(@RSUNTValue007);

  {Additive}
  // (constant) not clipped
  RSUNTValueProc[010]:=Unaligned(@RSUNTValue010);
  // (constant) top-bottom clipped
  RSUNTValueProc[012]:=Unaligned(@RSUNTValue012);
  // (constant) left-right-top-bottom clipped
  RSUNTValueProc[014]:=Unaligned(@RSUNTValue014);
  // (constant) image has monochrome color channel
  RSUNTValueProc[016]:=Unaligned(@RSUNTValue016);
  // (fading) not clipped
  RSUNTValueProc[011]:=Unaligned(@RSUNTValue011);
  // (fading) top-bottom clipped
  RSUNTValueProc[013]:=Unaligned(@RSUNTValue013);
  // (fading) left-right-top-bottom clipped
  RSUNTValueProc[015]:=Unaligned(@RSUNTValue015);
  // (fading) image has monochrome color channel
  RSUNTValueProc[017]:=Unaligned(@RSUNTValue017);

  {Alphablend}
  // (constant) not clipped
  RSUNTValueProc[020]:=Unaligned(@RSUNTValue020);
  // (constant) top-bottom clipped
  RSUNTValueProc[022]:=Unaligned(@RSUNTValue022);
  // (constant) left-right-top-bottom clipped
  RSUNTValueProc[024]:=Unaligned(@RSUNTValue024);
  // (constant) image has monochrome color channel
  RSUNTValueProc[026]:=Unaligned(@RSUNTValue026);
  // (fading) not clipped
  RSUNTValueProc[021]:=Unaligned(@RSUNTValue021);
  // (fading) top-bottom clipped
  RSUNTValueProc[023]:=Unaligned(@RSUNTValue023);
  // (fading) left-right-top-bottom clipped
  RSUNTValueProc[025]:=Unaligned(@RSUNTValue025);
  // (fading) image has monochrome color channel
  RSUNTValueProc[027]:=Unaligned(@RSUNTValue027);

  {Inverse}
  // (constant) not clipped
  RSUNTValueProc[030]:=Unaligned(@RSUNTValue030);
  // (constant) top-bottom clipped
  RSUNTValueProc[032]:=Unaligned(@RSUNTValue032);
  // (constant) left-right-top-bottom clipped
  RSUNTValueProc[034]:=Unaligned(@RSUNTValue034);
  // (constant) image has monochrome color channel
  RSUNTValueProc[036]:=Unaligned(@RSUNTValue036);
  // (fading) not clipped
  RSUNTValueProc[031]:=Unaligned(@RSUNTValue031);
  // (fading) top-bottom clipped
  RSUNTValueProc[033]:=Unaligned(@RSUNTValue033);
  // (fading) left-right-top-bottom clipped
  RSUNTValueProc[035]:=Unaligned(@RSUNTValue035);
  // (fading) image has monochrome color channel
  RSUNTValueProc[037]:=Unaligned(@RSUNTValue037);

  {Highlight}
  // (constant) not clipped
  RSUNTValueProc[040]:=Unaligned(@RSUNTValue040);
  // (constant) top-bottom clipped
  RSUNTValueProc[042]:=Unaligned(@RSUNTValue042);
  // (constant) left-right-top-bottom clipped
  RSUNTValueProc[044]:=Unaligned(@RSUNTValue044);
  // (constant) image has monochrome color channel
  RSUNTValueProc[046]:=Unaligned(@RSUNTValue046);
  // (fading) not clipped
  RSUNTValueProc[041]:=Unaligned(@RSUNTValue041);
  // (fading) top-bottom clipped
  RSUNTValueProc[043]:=Unaligned(@RSUNTValue043);
  // (fading) left-right-top-bottom clipped
  RSUNTValueProc[045]:=Unaligned(@RSUNTValue045);
  // (fading) image has monochrome color channel
  RSUNTValueProc[047]:=Unaligned(@RSUNTValue047);

  {Darken}
  // (constant) not clipped
  RSUNTValueProc[050]:=Unaligned(@RSUNTValue050);
  // (constant) top-bottom clipped
  RSUNTValueProc[052]:=Unaligned(@RSUNTValue052);
  // (constant) left-right-top-bottom clipped
  RSUNTValueProc[054]:=Unaligned(@RSUNTValue054);
  // (constant) image has monochrome color channel
  RSUNTValueProc[056]:=Unaligned(@RSUNTValue056);
  // (fading) not clipped
  RSUNTValueProc[051]:=Unaligned(@RSUNTValue051);
  // (fading) top-bottom clipped
  RSUNTValueProc[053]:=Unaligned(@RSUNTValue053);
  // (fading) left-right-top-bottom clipped
  RSUNTValueProc[055]:=Unaligned(@RSUNTValue055);
  // (fading) image has monochrome color channel
  RSUNTValueProc[057]:=Unaligned(@RSUNTValue057);

  {GrayscaleR}
  // (constant) not clipped
  RSUNTValueProc[060]:=Unaligned(@RSUNTValue060);
  // (constant) top-bottom clipped
  RSUNTValueProc[062]:=Unaligned(@RSUNTValue062);
  // (constant) left-right-top-bottom clipped
  RSUNTValueProc[064]:=Unaligned(@RSUNTValue064);
  // (constant) image has monochrome color channel
  RSUNTValueProc[066]:=Unaligned(@RSUNTValue066);
  // (fading) not clipped
  RSUNTValueProc[061]:=Unaligned(@RSUNTValue061);
  // (fading) top-bottom clipped
  RSUNTValueProc[063]:=Unaligned(@RSUNTValue063);
  // (fading) left-right-top-bottom clipped
  RSUNTValueProc[065]:=Unaligned(@RSUNTValue065);
  // (fading) image has monochrome color channel
  RSUNTValueProc[067]:=Unaligned(@RSUNTValue067);

  {GrayscaleG}
  // (constant) not clipped
  RSUNTValueProc[070]:=Unaligned(@RSUNTValue070);
  // (constant) top-bottom clipped
  RSUNTValueProc[072]:=Unaligned(@RSUNTValue072);
  // (constant) left-right-top-bottom clipped
  RSUNTValueProc[074]:=Unaligned(@RSUNTValue074);
  // (constant) image has monochrome color channel
  RSUNTValueProc[076]:=Unaligned(@RSUNTValue076);
  // (fading) not clipped
  RSUNTValueProc[071]:=Unaligned(@RSUNTValue071);
  // (fading) top-bottom clipped
  RSUNTValueProc[073]:=Unaligned(@RSUNTValue073);
  // (fading) left-right-top-bottom clipped
  RSUNTValueProc[075]:=Unaligned(@RSUNTValue075);
  // (fading) image has monochrome color channel
  RSUNTValueProc[077]:=Unaligned(@RSUNTValue077);

  {GrayscaleB}
  // (constant) not clipped
  RSUNTValueProc[080]:=Unaligned(@RSUNTValue080);
  // (constant) top-bottom clipped
  RSUNTValueProc[082]:=Unaligned(@RSUNTValue082);
  // (constant) left-right-top-bottom clipped
  RSUNTValueProc[084]:=Unaligned(@RSUNTValue084);
  // (constant) image has monochrome color channel
  RSUNTValueProc[086]:=Unaligned(@RSUNTValue086);
  // (fading) not clipped
  RSUNTValueProc[081]:=Unaligned(@RSUNTValue081);
  // (fading) top-bottom clipped
  RSUNTValueProc[083]:=Unaligned(@RSUNTValue083);
  // (fading) left-right-top-bottom clipped
  RSUNTValueProc[085]:=Unaligned(@RSUNTValue085);
  // (fading) image has monochrome color channel
  RSUNTValueProc[087]:=Unaligned(@RSUNTValue087);

  {Monochrome Noise}
  // (constant) not clipped
  RSUNTValueProc[090]:=Unaligned(@RSUNTValue090);
  // (constant) top-bottom clipped
  RSUNTValueProc[092]:=Unaligned(@RSUNTValue092);
  // (constant) left-right-top-bottom clipped
  RSUNTValueProc[094]:=Unaligned(@RSUNTValue094);
  // (constant) image has monochrome color channel
  RSUNTValueProc[096]:=Unaligned(@RSUNTValue096);
  // (fading) not clipped
  RSUNTValueProc[091]:=Unaligned(@RSUNTValue091);
  // (fading) top-bottom clipped
  RSUNTValueProc[093]:=Unaligned(@RSUNTValue093);
  // (fading) left-right-top-bottom clipped
  RSUNTValueProc[095]:=Unaligned(@RSUNTValue095);
  // (fading) image has monochrome color channel
  RSUNTValueProc[097]:=Unaligned(@RSUNTValue097);

  {ColorizeR}
  // (constant) not clipped
  RSUNTValueProc[100]:=Unaligned(@RSUNTValue100);
  // (constant) top-bottom clipped
  RSUNTValueProc[102]:=Unaligned(@RSUNTValue102);
  // (constant) left-right-top-bottom clipped
  RSUNTValueProc[104]:=Unaligned(@RSUNTValue104);
  // (constant) image has monochrome color channel
  RSUNTValueProc[106]:=Unaligned(@RSUNTValue106);
  // (fading) not clipped
  RSUNTValueProc[101]:=Unaligned(@RSUNTValue101);
  // (fading) top-bottom clipped
  RSUNTValueProc[103]:=Unaligned(@RSUNTValue103);
  // (fading) left-right-top-bottom clipped
  RSUNTValueProc[105]:=Unaligned(@RSUNTValue105);
  // (fading) image has monochrome color channel
  RSUNTValueProc[107]:=Unaligned(@RSUNTValue107);

  {ColorizeG}
  // (constant) not clipped
  RSUNTValueProc[110]:=Unaligned(@RSUNTValue110);
  // (constant) top-bottom clipped
  RSUNTValueProc[112]:=Unaligned(@RSUNTValue112);
  // (constant) left-right-top-bottom clipped
  RSUNTValueProc[114]:=Unaligned(@RSUNTValue114);
  // (constant) image has monochrome color channel
  RSUNTValueProc[116]:=Unaligned(@RSUNTValue116);
  // (fading) not clipped
  RSUNTValueProc[111]:=Unaligned(@RSUNTValue111);
  // (fading) top-bottom clipped
  RSUNTValueProc[113]:=Unaligned(@RSUNTValue113);
  // (fading) left-right-top-bottom clipped
  RSUNTValueProc[115]:=Unaligned(@RSUNTValue115);
  // (fading) image has monochrome color channel
  RSUNTValueProc[117]:=Unaligned(@RSUNTValue117);

  {ColorizeB}
  // (constant) not clipped
  RSUNTValueProc[120]:=Unaligned(@RSUNTValue120);
  // (constant) top-bottom clipped
  RSUNTValueProc[122]:=Unaligned(@RSUNTValue122);
  // (constant) left-right-top-bottom clipped
  RSUNTValueProc[124]:=Unaligned(@RSUNTValue124);
  // (constant) image has monochrome color channel
  RSUNTValueProc[126]:=Unaligned(@RSUNTValue126);
  // (fading) not clipped
  RSUNTValueProc[121]:=Unaligned(@RSUNTValue121);
  // (fading) top-bottom clipped
  RSUNTValueProc[123]:=Unaligned(@RSUNTValue123);
  // (fading) left-right-top-bottom clipped
  RSUNTValueProc[125]:=Unaligned(@RSUNTValue125);
  // (fading) image has monochrome color channel
  RSUNTValueProc[127]:=Unaligned(@RSUNTValue127);

  {BlurRGB}
  // (constant) not clipped
  RSUNTValueProc[130]:=Unaligned(@RSUNTValue130);
  // (constant) top-bottom clipped
  RSUNTValueProc[132]:=Unaligned(@RSUNTValue132);
  // (constant) left-right-top-bottom clipped
  RSUNTValueProc[134]:=Unaligned(@RSUNTValue134);
  // (constant) image has monochrome color channel
  RSUNTValueProc[136]:=Unaligned(@RSUNTValue136);
  // (fading) not clipped
  RSUNTValueProc[131]:=Unaligned(@RSUNTValue131);
  // (fading) top-bottom clipped
  RSUNTValueProc[133]:=Unaligned(@RSUNTValue133);
  // (fading) left-right-top-bottom clipped
  RSUNTValueProc[135]:=Unaligned(@RSUNTValue135);
  // (fading) image has monochrome color channel
  RSUNTValueProc[137]:=Unaligned(@RSUNTValue137);

  {BlurRRB}
  // (constant) not clipped
  RSUNTValueProc[140]:=Unaligned(@RSUNTValue140);
  // (constant) top-bottom clipped
  RSUNTValueProc[142]:=Unaligned(@RSUNTValue142);
  // (constant) left-right-top-bottom clipped
  RSUNTValueProc[144]:=Unaligned(@RSUNTValue144);
  // (constant) image has monochrome color channel
  RSUNTValueProc[146]:=Unaligned(@RSUNTValue146);
  // (fading) not clipped
  RSUNTValueProc[141]:=Unaligned(@RSUNTValue141);
  // (fading) top-bottom clipped
  RSUNTValueProc[143]:=Unaligned(@RSUNTValue143);
  // (fading) left-right-top-bottom clipped
  RSUNTValueProc[145]:=Unaligned(@RSUNTValue145);
  // (fading) image has monochrome color channel
  RSUNTValueProc[147]:=Unaligned(@RSUNTValue147);

  {BlurRGR}
  // (constant) not clipped
  RSUNTValueProc[150]:=Unaligned(@RSUNTValue150);
  // (constant) top-bottom clipped
  RSUNTValueProc[152]:=Unaligned(@RSUNTValue152);
  // (constant) left-right-top-bottom clipped
  RSUNTValueProc[154]:=Unaligned(@RSUNTValue154);
  // (constant) image has monochrome color channel
  RSUNTValueProc[156]:=Unaligned(@RSUNTValue156);
  // (fading) not clipped
  RSUNTValueProc[151]:=Unaligned(@RSUNTValue151);
  // (fading) top-bottom clipped
  RSUNTValueProc[153]:=Unaligned(@RSUNTValue153);
  // (fading) left-right-top-bottom clipped
  RSUNTValueProc[155]:=Unaligned(@RSUNTValue155);
  // (fading) image has monochrome color channel
  RSUNTValueProc[157]:=Unaligned(@RSUNTValue157);

  {BlurGGB}
  // (constant) not clipped
  RSUNTValueProc[160]:=Unaligned(@RSUNTValue160);
  // (constant) top-bottom clipped
  RSUNTValueProc[162]:=Unaligned(@RSUNTValue162);
  // (constant) left-right-top-bottom clipped
  RSUNTValueProc[164]:=Unaligned(@RSUNTValue164);
  // (constant) image has monochrome color channel
  RSUNTValueProc[166]:=Unaligned(@RSUNTValue166);
  // (fading) not clipped
  RSUNTValueProc[161]:=Unaligned(@RSUNTValue161);
  // (fading) top-bottom clipped
  RSUNTValueProc[163]:=Unaligned(@RSUNTValue163);
  // (fading) left-right-top-bottom clipped
  RSUNTValueProc[165]:=Unaligned(@RSUNTValue165);
  // (fading) image has monochrome color channel
  RSUNTValueProc[167]:=Unaligned(@RSUNTValue167);

  {BlurRGG}
  // (constant) not clipped
  RSUNTValueProc[170]:=Unaligned(@RSUNTValue170);
  // (constant) top-bottom clipped
  RSUNTValueProc[172]:=Unaligned(@RSUNTValue172);
  // (constant) left-right-top-bottom clipped
  RSUNTValueProc[174]:=Unaligned(@RSUNTValue174);
  // (constant) image has monochrome color channel
  RSUNTValueProc[176]:=Unaligned(@RSUNTValue176);
  // (fading) not clipped
  RSUNTValueProc[171]:=Unaligned(@RSUNTValue171);
  // (fading) top-bottom clipped
  RSUNTValueProc[173]:=Unaligned(@RSUNTValue173);
  // (fading) left-right-top-bottom clipped
  RSUNTValueProc[175]:=Unaligned(@RSUNTValue175);
  // (fading) image has monochrome color channel
  RSUNTValueProc[177]:=Unaligned(@RSUNTValue177);

  {BlurBGB}
  // (constant) not clipped
  RSUNTValueProc[180]:=Unaligned(@RSUNTValue180);
  // (constant) top-bottom clipped
  RSUNTValueProc[182]:=Unaligned(@RSUNTValue182);
  // (constant) left-right-top-bottom clipped
  RSUNTValueProc[184]:=Unaligned(@RSUNTValue184);
  // (constant) image has monochrome color channel
  RSUNTValueProc[186]:=Unaligned(@RSUNTValue186);
  // (fading) not clipped
  RSUNTValueProc[181]:=Unaligned(@RSUNTValue181);
  // (fading) top-bottom clipped
  RSUNTValueProc[183]:=Unaligned(@RSUNTValue183);
  // (fading) left-right-top-bottom clipped
  RSUNTValueProc[185]:=Unaligned(@RSUNTValue185);
  // (fading) image has monochrome color channel
  RSUNTValueProc[187]:=Unaligned(@RSUNTValue187);

  {BlurRBB}
  // (constant) not clipped
  RSUNTValueProc[190]:=Unaligned(@RSUNTValue190);
  // (constant) top-bottom clipped
  RSUNTValueProc[192]:=Unaligned(@RSUNTValue192);
  // (constant) left-right-top-bottom clipped
  RSUNTValueProc[194]:=Unaligned(@RSUNTValue194);
  // (constant) image has monochrome color channel
  RSUNTValueProc[196]:=Unaligned(@RSUNTValue196);
  // (fading) not clipped
  RSUNTValueProc[191]:=Unaligned(@RSUNTValue191);
  // (fading) top-bottom clipped
  RSUNTValueProc[193]:=Unaligned(@RSUNTValue193);
  // (fading) left-right-top-bottom clipped
  RSUNTValueProc[195]:=Unaligned(@RSUNTValue195);
  // (fading) image has monochrome color channel
  RSUNTValueProc[197]:=Unaligned(@RSUNTValue197);

  {BlurRRR}
  // (constant) not clipped
  RSUNTValueProc[200]:=Unaligned(@RSUNTValue200);
  // (constant) top-bottom clipped
  RSUNTValueProc[202]:=Unaligned(@RSUNTValue202);
  // (constant) left-right-top-bottom clipped
  RSUNTValueProc[204]:=Unaligned(@RSUNTValue204);
  // (constant) image has monochrome color channel
  RSUNTValueProc[206]:=Unaligned(@RSUNTValue206);
  // (fading) not clipped
  RSUNTValueProc[201]:=Unaligned(@RSUNTValue201);
  // (fading) top-bottom clipped
  RSUNTValueProc[203]:=Unaligned(@RSUNTValue203);
  // (fading) left-right-top-bottom clipped
  RSUNTValueProc[205]:=Unaligned(@RSUNTValue205);
  // (fading) image has monochrome color channel
  RSUNTValueProc[207]:=Unaligned(@RSUNTValue207);

  {BlurGGG}
  // (constant) not clipped
  RSUNTValueProc[210]:=Unaligned(@RSUNTValue210);
  // (constant) top-bottom clipped
  RSUNTValueProc[212]:=Unaligned(@RSUNTValue212);
  // (constant) left-right-top-bottom clipped
  RSUNTValueProc[214]:=Unaligned(@RSUNTValue214);
  // (constant) image has monochrome color channel
  RSUNTValueProc[216]:=Unaligned(@RSUNTValue216);
  // (fading) not clipped
  RSUNTValueProc[211]:=Unaligned(@RSUNTValue211);
  // (fading) top-bottom clipped
  RSUNTValueProc[213]:=Unaligned(@RSUNTValue213);
  // (fading) left-right-top-bottom clipped
  RSUNTValueProc[215]:=Unaligned(@RSUNTValue215);
  // (fading) image has monochrome color channel
  RSUNTValueProc[217]:=Unaligned(@RSUNTValue217);

  {BlurBBB}
  // (constant) not clipped
  RSUNTValueProc[220]:=Unaligned(@RSUNTValue220);
  // (constant) top-bottom clipped
  RSUNTValueProc[222]:=Unaligned(@RSUNTValue222);
  // (constant) left-right-top-bottom clipped
  RSUNTValueProc[224]:=Unaligned(@RSUNTValue224);
  // (constant) image has monochrome color channel
  RSUNTValueProc[226]:=Unaligned(@RSUNTValue226);
  // (fading) not clipped
  RSUNTValueProc[221]:=Unaligned(@RSUNTValue221);
  // (fading) top-bottom clipped
  RSUNTValueProc[223]:=Unaligned(@RSUNTValue223);
  // (fading) left-right-top-bottom clipped
  RSUNTValueProc[225]:=Unaligned(@RSUNTValue225);
  // (fading) image has monochrome color channel
  RSUNTValueProc[227]:=Unaligned(@RSUNTValue227);

  {Contrast}
  // (constant) not clipped
  RSUNTValueProc[230]:=Unaligned(@RSUNTValue230);
  // (constant) top-bottom clipped
  RSUNTValueProc[232]:=Unaligned(@RSUNTValue232);
  // (constant) left-right-top-bottom clipped
  RSUNTValueProc[234]:=Unaligned(@RSUNTValue234);
  // (constant) image has monochrome color channel
  RSUNTValueProc[236]:=Unaligned(@RSUNTValue236);
  // (fading) not clipped
  RSUNTValueProc[231]:=Unaligned(@RSUNTValue231);
  // (fading) top-bottom clipped
  RSUNTValueProc[233]:=Unaligned(@RSUNTValue233);
  // (fading) left-right-top-bottom clipped
  RSUNTValueProc[235]:=Unaligned(@RSUNTValue235);
  // (fading) image has monochrome color channel
  RSUNTValueProc[237]:=Unaligned(@RSUNTValue237);

  {$endregion}

  {$endregion}

  // PT - partly transparent pixels:

  {Color} {$region -fold}

  {||scl_mul||=1:                  } {$region -fold}

  {Empty}
  RegPTColorProc[009]:=Unaligned(@RegPTColor009);

  {Color of Curent Layer}
  // (constant) not clipped
  RegPTColorProc[000]:=Unaligned(@RegPTColor000);
  // (constant) top-bottom clipped
  RegPTColorProc[002]:=Unaligned(@RegPTColor000);
  // (constant) left-right-top-bottom clipped
  RegPTColorProc[004]:=Unaligned(@RegPTColor004);
  // (constant) image has transparent alpha channel
  RegPTColorProc[006]:=Unaligned(@RegPTColor006);
  // (fading) not clipped
  RegPTColorProc[001]:=Unaligned(@RegPTColor020);
  // (fading) top-bottom clipped
  RegPTColorProc[003]:=Unaligned(@RegPTColor020);
  // (fading) left-right-top-bottom clipped
  RegPTColorProc[005]:=Unaligned(@RegPTColor024);
  // (fading) image has transparent alpha channel
  RegPTColorProc[007]:=Unaligned(@RegPTColor006);

  {Color of Curent Layer(Additive)}
  // (constant) not clipped
  RegPTColorProc[010]:=Unaligned(@RegPTColor010);
  // (constant) top-bottom clipped
  RegPTColorProc[012]:=Unaligned(@RegPTColor010);
  // (constant) left-right-top-bottom clipped
  RegPTColorProc[014]:=Unaligned(@RegPTColor014);
  // (constant) image has monochrome color channel
  RegPTColorProc[016]:=Unaligned(@RegPTColor016);
  // (fading) not clipped
  RegPTColorProc[011]:=Unaligned(@RegPTColor011);
  // (fading) top-bottom clipped
  RegPTColorProc[013]:=Unaligned(@RegPTColor011);
  // (fading) left-right-top-bottom clipped
  RegPTColorProc[015]:=Unaligned(@RegPTColor015);
  // (fading) image has monochrome color channel
  RegPTColorProc[017]:=Unaligned(@RegPTColor016);

  {Color of Curent Layer(Alphablend)}
  // (constant) not clipped
  RegPTColorProc[020]:=Unaligned(@RegPTColor020);
  // (constant) top-bottom clipped
  RegPTColorProc[022]:=Unaligned(@RegPTColor020);
  // (constant) left-right-top-bottom clipped
  RegPTColorProc[024]:=Unaligned(@RegPTColor024);
  // (constant) image has transparent alpha channel
  RegPTColorProc[026]:=Unaligned(@RegPTColor006);
  // (fading) not clipped
  RegPTColorProc[021]:=Unaligned(@RegPTColor020);
  // (fading) top-bottom clipped
  RegPTColorProc[023]:=Unaligned(@RegPTColor020);
  // (fading) left-right-top-bottom clipped
  RegPTColorProc[025]:=Unaligned(@RegPTColor024);
  // (fading) image has transparent alpha channel
  RegPTColorProc[027]:=Unaligned(@RegPTColor006);

  {$endregion}

  {||scl_mul||<1: (SD - Scale Down)} {$region -fold}

  {Empty}
  RSDPTColorProc[009]:=Unaligned(@RSDPTColor009);

  {Color of Curent Layer}
  // (constant) not clipped
  RSDPTColorProc[000]:=Unaligned(@RSDPTColor000);
  // (constant) top-bottom clipped
  RSDPTColorProc[002]:=Unaligned(@RSDPTColor002);
  // (constant) left-right-top-bottom clipped
  RSDPTColorProc[004]:=Unaligned(@RSDPTColor004);
  // (constant) image has transparent alpha channel
  RSDPTColorProc[006]:=Unaligned(@RSDPTColor006);
  // (fading) not clipped
  RSDPTColorProc[001]:=Unaligned(@RSDPTColor020);
  // (fading) top-bottom clipped
  RSDPTColorProc[003]:=Unaligned(@RSDPTColor022);
  // (fading) left-right-top-bottom clipped
  RSDPTColorProc[005]:=Unaligned(@RSDPTColor024);
  // (fading) image has transparent alpha channel
  RSDPTColorProc[007]:=Unaligned(@RSDPTColor006);

  {Color of Curent Layer(Additive)}
  // (constant) not clipped
  RSDPTColorProc[010]:=Unaligned(@RSDPTColor010);
  // (constant) top-bottom clipped
  RSDPTColorProc[012]:=Unaligned(@RSDPTColor012);
  // (constant) left-right-top-bottom clipped
  RSDPTColorProc[014]:=Unaligned(@RSDPTColor014);
  // (constant) image has monochrome color channel
  RSDPTColorProc[016]:=Unaligned(@RSDPTColor016);
  // (fading) not clipped
  RSDPTColorProc[011]:=Unaligned(@RSDPTColor011);
  // (fading) top-bottom clipped
  RSDPTColorProc[013]:=Unaligned(@RSDPTColor013);
  // (fading) left-right-top-bottom clipped
  RSDPTColorProc[015]:=Unaligned(@RSDPTColor015);
  // (fading) image has monochrome color channel
  RSDPTColorProc[017]:=Unaligned(@RSDPTColor016);

  {Color of Curent Layer(Alphablend)}
  // (constant) not clipped
  RSDPTColorProc[020]:=Unaligned(@RSDPTColor020);
  // (constant) top-bottom clipped
  RSDPTColorProc[022]:=Unaligned(@RSDPTColor022);
  // (constant) left-right-top-bottom clipped
  RSDPTColorProc[024]:=Unaligned(@RSDPTColor024);
  // (constant) image has transparent alpha channel
  RSDPTColorProc[026]:=Unaligned(@RSDPTColor006);
  // (fading) not clipped
  RSDPTColorProc[021]:=Unaligned(@RSDPTColor020);
  // (fading) top-bottom clipped
  RSDPTColorProc[023]:=Unaligned(@RSDPTColor022);
  // (fading) left-right-top-bottom clipped
  RSDPTColorProc[025]:=Unaligned(@RSDPTColor024);
  // (fading) image has transparent alpha channel
  RSDPTColorProc[027]:=Unaligned(@RSDPTColor006);

  {$endregion}

  {||scl_mul||>1: (SU - Scale Up  )} {$region -fold}

  {Empty}
  RSUPTColorProc[009]:=Unaligned(@RSUPTColor009);

  {Color of Curent Layer}
  // (constant) not clipped
  RSUPTColorProc[000]:=Unaligned(@RSUPTColor000);
  // (constant) top-bottom clipped
  RSUPTColorProc[002]:=Unaligned(@RSUPTColor002);
  // (constant) left-right-top-bottom clipped
  RSUPTColorProc[004]:=Unaligned(@RSUPTColor004);
  // (constant) image has transparent alpha channel
  RSUPTColorProc[006]:=Unaligned(@RSUPTColor006);
  // (fading) not clipped
  RSUPTColorProc[001]:=Unaligned(@RSUPTColor020);
  // (fading) top-bottom clipped
  RSUPTColorProc[003]:=Unaligned(@RSUPTColor022);
  // (fading) left-right-top-bottom clipped
  RSUPTColorProc[005]:=Unaligned(@RSUPTColor024);
  // (fading) image has transparent alpha channel
  RSUPTColorProc[007]:=Unaligned(@RSUPTColor006);

  {Color of Curent Layer(Additive)}
  // (constant) not clipped
  RSUPTColorProc[010]:=Unaligned(@RSUPTColor010);
  // (constant) top-bottom clipped
  RSUPTColorProc[012]:=Unaligned(@RSUPTColor012);
  // (constant) left-right-top-bottom clipped
  RSUPTColorProc[014]:=Unaligned(@RSUPTColor014);
  // (constant) image has monochrome color channel
  RSUPTColorProc[016]:=Unaligned(@RSUPTColor016);
  // (fading) not clipped
  RSUPTColorProc[011]:=Unaligned(@RSUPTColor011);
  // (fading) top-bottom clipped
  RSUPTColorProc[013]:=Unaligned(@RSUPTColor013);
  // (fading) left-right-top-bottom clipped
  RSUPTColorProc[015]:=Unaligned(@RSUPTColor015);
  // (fading) image has monochrome color channel
  RSUPTColorProc[017]:=Unaligned(@RSUPTColor016);

  {Color of Curent Layer(Alphablend)}
  // (constant) not clipped
  RSUPTColorProc[020]:=Unaligned(@RSUPTColor020);
  // (constant) top-bottom clipped
  RSUPTColorProc[022]:=Unaligned(@RSUPTColor022);
  // (constant) left-right-top-bottom clipped
  RSUPTColorProc[024]:=Unaligned(@RSUPTColor024);
  // (constant) image has transparent alpha channel
  RSUPTColorProc[026]:=Unaligned(@RSUPTColor006);
  // (fading) not clipped
  RSUPTColorProc[021]:=Unaligned(@RSUPTColor020);
  // (fading) top-bottom clipped
  RSUPTColorProc[023]:=Unaligned(@RSUPTColor022);
  // (fading) left-right-top-bottom clipped
  RSUPTColorProc[025]:=Unaligned(@RSUPTColor024);
  // (fading) image has transparent alpha channel
  RSUPTColorProc[027]:=Unaligned(@RSUPTColor006);

  {$endregion}

  {$endregion}

  {Value} {$region -fold}

  {||scl_mul||=1:                  } {$region -fold}

  {Empty}
  RegPTValueProc[009]:=Unaligned(@RegPTValue009);

  {Monochrome}
  // (constant) not clipped
  RegPTValueProc[000]:=Unaligned(@RegPTValue000);
  // (constant) top-bottom clipped
  RegPTValueProc[002]:=Unaligned(@RegPTValue000);
  // (constant) left-right-top-bottom clipped
  RegPTValueProc[004]:=Unaligned(@RegPTValue004);
  // (fading) not clipped
  RegPTValueProc[001]:=Unaligned(@RegPTValue020);
  // (fading) top-bottom clipped
  RegPTValueProc[003]:=Unaligned(@RegPTValue020);
  // (fading) left-right-top-bottom clipped
  RegPTValueProc[005]:=Unaligned(@RegPTValue024);

  {Additive}
  // (constant) not clipped
  RegPTValueProc[010]:=Unaligned(@RegPTValue010);
  // (constant) top-bottom clipped
  RegPTValueProc[012]:=Unaligned(@RegPTValue010);
  // (constant) left-right-top-bottom clipped
  RegPTValueProc[014]:=Unaligned(@RegPTValue014);
  // (fading) not clipped
  RegPTValueProc[011]:=Unaligned(@RegPTValue011);
  // (fading) top-bottom clipped
  RegPTValueProc[013]:=Unaligned(@RegPTValue011);
  // (fading) left-right-top-bottom clipped
  RegPTValueProc[015]:=Unaligned(@RegPTValue015);

  {Alphablend}
  // (constant) not clipped
  RegPTValueProc[020]:=Unaligned(@RegPTValue020);
  // (constant) top-bottom clipped
  RegPTValueProc[022]:=Unaligned(@RegPTValue020);
  // (constant) left-right-top-bottom clipped
  RegPTValueProc[024]:=Unaligned(@RegPTValue024);
  // (fading) not clipped
  RegPTValueProc[021]:=Unaligned(@RegPTValue020);
  // (fading) top-bottom clipped
  RegPTValueProc[023]:=Unaligned(@RegPTValue020);
  // (fading) left-right-top-bottom clipped
  RegPTValueProc[025]:=Unaligned(@RegPTValue024);

  {Inverse}
  // (constant) not clipped
  RegPTValueProc[030]:=Unaligned(@RegPTValue030);
  // (constant) top-bottom clipped
  RegPTValueProc[032]:=Unaligned(@RegPTValue030);
  // (constant) left-right-top-bottom clipped
  RegPTValueProc[034]:=Unaligned(@RegPTValue034);
  // (fading) not clipped
  RegPTValueProc[031]:=Unaligned(@RegPTValue031);
  // (fading) top-bottom clipped
  RegPTValueProc[033]:=Unaligned(@RegPTValue031);
  // (fading) left-right-top-bottom clipped
  RegPTValueProc[035]:=Unaligned(@RegPTValue035);

  {Highlighted}
  // (constant) not clipped
  RegPTValueProc[040]:=Unaligned(@RegPTValue040);
  // (constant) top-bottom clipped
  RegPTValueProc[042]:=Unaligned(@RegPTValue040);
  // (constant) left-right-top-bottom clipped
  RegPTValueProc[044]:=Unaligned(@RegPTValue044);
  // (fading) not clipped
  RegPTValueProc[041]:=Unaligned(@RegPTValue040);
  // (fading) top-bottom clipped
  RegPTValueProc[043]:=Unaligned(@RegPTValue040);
  // (fading) left-right-top-bottom clipped
  RegPTValueProc[045]:=Unaligned(@RegPTValue044);

  {Darkened}
  // (constant) not clipped
  RegPTValueProc[050]:=Unaligned(@RegPTValue050);
  // (constant) top-bottom clipped
  RegPTValueProc[052]:=Unaligned(@RegPTValue050);
  // (constant) left-right-top-bottom clipped
  RegPTValueProc[054]:=Unaligned(@RegPTValue054);
  // (fading) not clipped
  RegPTValueProc[051]:=Unaligned(@RegPTValue050);
  // (fading) top-bottom clipped
  RegPTValueProc[053]:=Unaligned(@RegPTValue050);
  // (fading) left-right-top-bottom clipped
  RegPTValueProc[055]:=Unaligned(@RegPTValue054);

  {GrayscaleR}
  // (constant) not clipped
  RegPTValueProc[060]:=Unaligned(@RegPTValue060);
  // (constant) top-bottom clipped
  RegPTValueProc[062]:=Unaligned(@RegPTValue060);
  // (constant) left-right-top-bottom clipped
  RegPTValueProc[064]:=Unaligned(@RegPTValue064);
  // (fading) not clipped
  RegPTValueProc[061]:=Unaligned(@RegPTValue061);
  // (fading) top-bottom clipped
  RegPTValueProc[063]:=Unaligned(@RegPTValue061);
  // (fading) left-right-top-bottom clipped
  RegPTValueProc[065]:=Unaligned(@RegPTValue065);

  {GrayscaleG}
  // (constant) not clipped
  RegPTValueProc[070]:=Unaligned(@RegPTValue070);
  // (constant) top-bottom clipped
  RegPTValueProc[072]:=Unaligned(@RegPTValue070);
  // (constant) left-right-top-bottom clipped
  RegPTValueProc[074]:=Unaligned(@RegPTValue074);
  // (fading) not clipped
  RegPTValueProc[071]:=Unaligned(@RegPTValue071);
  // (fading) top-bottom clipped
  RegPTValueProc[073]:=Unaligned(@RegPTValue071);
  // (fading) left-right-top-bottom clipped
  RegPTValueProc[075]:=Unaligned(@RegPTValue075);

  {GrayscaleB}
  // (constant) not clipped
  RegPTValueProc[080]:=Unaligned(@RegPTValue080);
  // (constant) top-bottom clipped
  RegPTValueProc[082]:=Unaligned(@RegPTValue080);
  // (constant) left-right-top-bottom clipped
  RegPTValueProc[084]:=Unaligned(@RegPTValue084);
  // (fading) not clipped
  RegPTValueProc[081]:=Unaligned(@RegPTValue081);
  // (fading) top-bottom clipped
  RegPTValueProc[083]:=Unaligned(@RegPTValue081);
  // (fading) left-right-top-bottom clipped
  RegPTValueProc[085]:=Unaligned(@RegPTValue085);

  {Monochrome Noise}
  // (constant) not clipped
  RegPTValueProc[090]:=Unaligned(@RegPTValue090);
  // (constant) top-bottom clipped
  RegPTValueProc[092]:=Unaligned(@RegPTValue090);
  // (constant) left-right-top-bottom clipped
  RegPTValueProc[094]:=Unaligned(@RegPTValue094);
  // (fading) not clipped
  RegPTValueProc[091]:=Unaligned(@RegPTValue091);
  // (fading) top-bottom clipped
  RegPTValueProc[093]:=Unaligned(@RegPTValue091);
  // (fading) left-right-top-bottom clipped
  RegPTValueProc[095]:=Unaligned(@RegPTValue095);

  {ColorizeR}
  // (constant) not clipped
  RegPTValueProc[100]:=Unaligned(@RegPTValue100);
  // (constant) top-bottom clipped
  RegPTValueProc[102]:=Unaligned(@RegPTValue100);
  // (constant) left-right-top-bottom clipped
  RegPTValueProc[104]:=Unaligned(@RegPTValue104);
  // (fading) not clipped
  RegPTValueProc[101]:=Unaligned(@RegPTValue100);
  // (fading) top-bottom clipped
  RegPTValueProc[103]:=Unaligned(@RegPTValue100);
  // (fading) left-right-top-bottom clipped
  RegPTValueProc[105]:=Unaligned(@RegPTValue104);

  {ColorizeG}
  // (constant) not clipped
  RegPTValueProc[110]:=Unaligned(@RegPTValue110);
  // (constant) top-bottom clipped
  RegPTValueProc[112]:=Unaligned(@RegPTValue110);
  // (constant) left-right-top-bottom clipped
  RegPTValueProc[114]:=Unaligned(@RegPTValue114);
  // (fading) not clipped
  RegPTValueProc[111]:=Unaligned(@RegPTValue110);
  // (fading) top-bottom clipped
  RegPTValueProc[113]:=Unaligned(@RegPTValue110);
  // (fading) left-right-top-bottom clipped
  RegPTValueProc[115]:=Unaligned(@RegPTValue114);

  {ColorizeB}
  // (constant) not clipped
  RegPTValueProc[120]:=Unaligned(@RegPTValue120);
  // (constant) top-bottom clipped
  RegPTValueProc[122]:=Unaligned(@RegPTValue120);
  // (constant) left-right-top-bottom clipped
  RegPTValueProc[124]:=Unaligned(@RegPTValue124);
  // (fading) not clipped
  RegPTValueProc[121]:=Unaligned(@RegPTValue120);
  // (fading) top-bottom clipped
  RegPTValueProc[123]:=Unaligned(@RegPTValue120);
  // (fading) left-right-top-bottom clipped
  RegPTValueProc[125]:=Unaligned(@RegPTValue124);

  {BlurRGB}
  // (constant) not clipped
  RegPTValueProc[130]:=Unaligned(@RegPTValue130);
  // (constant) top-bottom clipped
  RegPTValueProc[132]:=Unaligned(@RegPTValue130);
  // (constant) left-right-top-bottom clipped
  RegPTValueProc[134]:=Unaligned(@RegPTValue134);
  // (fading) not clipped
  RegPTValueProc[131]:=Unaligned(@RegPTValue131);
  // (fading) top-bottom clipped
  RegPTValueProc[133]:=Unaligned(@RegPTValue131);
  // (fading) left-right-top-bottom clipped
  RegPTValueProc[135]:=Unaligned(@RegPTValue135);

  {BlurRRB}
  // (constant) not clipped
  RegPTValueProc[140]:=Unaligned(@RegPTValue140);
  // (constant) top-bottom clipped
  RegPTValueProc[142]:=Unaligned(@RegPTValue140);
  // (constant) left-right-top-bottom clipped
  RegPTValueProc[144]:=Unaligned(@RegPTValue144);
  // (fading) not clipped
  RegPTValueProc[141]:=Unaligned(@RegPTValue141);
  // (fading) top-bottom clipped
  RegPTValueProc[143]:=Unaligned(@RegPTValue141);
  // (fading) left-right-top-bottom clipped
  RegPTValueProc[145]:=Unaligned(@RegPTValue145);

  {BlurRGR}
  // (constant) not clipped
  RegPTValueProc[150]:=Unaligned(@RegPTValue150);
  // (constant) top-bottom clipped
  RegPTValueProc[152]:=Unaligned(@RegPTValue150);
  // (constant) left-right-top-bottom clipped
  RegPTValueProc[154]:=Unaligned(@RegPTValue154);
  // (fading) not clipped
  RegPTValueProc[151]:=Unaligned(@RegPTValue151);
  // (fading) top-bottom clipped
  RegPTValueProc[153]:=Unaligned(@RegPTValue151);
  // (fading) left-right-top-bottom clipped
  RegPTValueProc[155]:=Unaligned(@RegPTValue155);

  {BlurGGB}
  // (constant) not clipped
  RegPTValueProc[160]:=Unaligned(@RegPTValue160);
  // (constant) top-bottom clipped
  RegPTValueProc[162]:=Unaligned(@RegPTValue160);
  // (constant) left-right-top-bottom clipped
  RegPTValueProc[164]:=Unaligned(@RegPTValue164);
  // (fading) not clipped
  RegPTValueProc[161]:=Unaligned(@RegPTValue161);
  // (fading) top-bottom clipped
  RegPTValueProc[163]:=Unaligned(@RegPTValue161);
  // (fading) left-right-top-bottom clipped
  RegPTValueProc[165]:=Unaligned(@RegPTValue165);

  {BlurRGG}
  // (constant) not clipped
  RegPTValueProc[170]:=Unaligned(@RegPTValue170);
  // (constant) top-bottom clipped
  RegPTValueProc[172]:=Unaligned(@RegPTValue170);
  // (constant) left-right-top-bottom clipped
  RegPTValueProc[174]:=Unaligned(@RegPTValue174);
  // (fading) not clipped
  RegPTValueProc[171]:=Unaligned(@RegPTValue171);
  // (fading) top-bottom clipped
  RegPTValueProc[173]:=Unaligned(@RegPTValue171);
  // (fading) left-right-top-bottom clipped
  RegPTValueProc[175]:=Unaligned(@RegPTValue175);

  {BlurBGB}
  // (constant) not clipped
  RegPTValueProc[180]:=Unaligned(@RegPTValue180);
  // (constant) top-bottom clipped
  RegPTValueProc[182]:=Unaligned(@RegPTValue180);
  // (constant) left-right-top-bottom clipped
  RegPTValueProc[184]:=Unaligned(@RegPTValue184);
  // (fading) not clipped
  RegPTValueProc[181]:=Unaligned(@RegPTValue181);
  // (fading) top-bottom clipped
  RegPTValueProc[183]:=Unaligned(@RegPTValue181);
  // (fading) left-right-top-bottom clipped
  RegPTValueProc[185]:=Unaligned(@RegPTValue185);

  {BlurRBB}
  // (constant) not clipped
  RegPTValueProc[190]:=Unaligned(@RegPTValue190);
  // (constant) top-bottom clipped
  RegPTValueProc[192]:=Unaligned(@RegPTValue190);
  // (constant) left-right-top-bottom clipped
  RegPTValueProc[194]:=Unaligned(@RegPTValue194);
  // (fading) not clipped
  RegPTValueProc[191]:=Unaligned(@RegPTValue191);
  // (fading) top-bottom clipped
  RegPTValueProc[193]:=Unaligned(@RegPTValue191);
  // (fading) left-right-top-bottom clipped
  RegPTValueProc[195]:=Unaligned(@RegPTValue195);

  {BlurRRR}
  // (constant) not clipped
  RegPTValueProc[200]:=Unaligned(@RegPTValue200);
  // (constant) top-bottom clipped
  RegPTValueProc[202]:=Unaligned(@RegPTValue200);
  // (constant) left-right-top-bottom clipped
  RegPTValueProc[204]:=Unaligned(@RegPTValue204);
  // (fading) not clipped
  RegPTValueProc[201]:=Unaligned(@RegPTValue201);
  // (fading) top-bottom clipped
  RegPTValueProc[203]:=Unaligned(@RegPTValue201);
  // (fading) left-right-top-bottom clipped
  RegPTValueProc[205]:=Unaligned(@RegPTValue205);

  {BlurGGG}
  // (constant) not clipped
  RegPTValueProc[210]:=Unaligned(@RegPTValue210);
  // (constant) top-bottom clipped
  RegPTValueProc[212]:=Unaligned(@RegPTValue210);
  // (constant) left-right-top-bottom clipped
  RegPTValueProc[214]:=Unaligned(@RegPTValue214);
  // (fading) not clipped
  RegPTValueProc[211]:=Unaligned(@RegPTValue211);
  // (fading) top-bottom clipped
  RegPTValueProc[213]:=Unaligned(@RegPTValue211);
  // (fading) left-right-top-bottom clipped
  RegPTValueProc[215]:=Unaligned(@RegPTValue215);

  {BlurBBB}
  // (constant) not clipped
  RegPTValueProc[220]:=Unaligned(@RegPTValue220);
  // (constant) top-bottom clipped
  RegPTValueProc[222]:=Unaligned(@RegPTValue220);
  // (constant) left-right-top-bottom clipped
  RegPTValueProc[224]:=Unaligned(@RegPTValue224);
  // (fading) not clipped
  RegPTValueProc[221]:=Unaligned(@RegPTValue221);
  // (fading) top-bottom clipped
  RegPTValueProc[223]:=Unaligned(@RegPTValue221);
  // (fading) left-right-top-bottom clipped
  RegPTValueProc[225]:=Unaligned(@RegPTValue225);

  {Contrast}
  // (constant) not clipped
  RegPTValueProc[230]:=Unaligned(@RegPTValue230);
  // (constant) top-bottom clipped
  RegPTValueProc[232]:=Unaligned(@RegPTValue230);
  // (constant) left-right-top-bottom clipped
  RegPTValueProc[234]:=Unaligned(@RegPTValue234);
  // (fading) not clipped
  RegPTValueProc[231]:=Unaligned(@RegPTValue230);
  // (fading) top-bottom clipped
  RegPTValueProc[233]:=Unaligned(@RegPTValue230);
  // (fading) left-right-top-bottom clipped
  RegPTValueProc[235]:=Unaligned(@RegPTValue234);

  {$endregion}

  {||scl_mul||<1: (SD - Scale Down)} {$region -fold}

  {Empty}
  RSDPTValueProc[009]:=Unaligned(@RSDPTValue009);

  {Monochrome}
  // (constant) not clipped
  RSDPTValueProc[000]:=Unaligned(@RSDPTValue000);
  // (constant) top-bottom clipped
  RSDPTValueProc[002]:=Unaligned(@RSDPTValue002);
  // (constant) left-right-top-bottom clipped
  RSDPTValueProc[004]:=Unaligned(@RSDPTValue004);
  // (fading) not clipped
  RSDPTValueProc[001]:=Unaligned(@RSDPTValue001);
  // (fading) top-bottom clipped
  RSDPTValueProc[003]:=Unaligned(@RSDPTValue003);
  // (fading) left-right-top-bottom clipped
  RSDPTValueProc[005]:=Unaligned(@RSDPTValue005);

  {Additive}
  // (constant) not clipped
  RSDPTValueProc[010]:=Unaligned(@RSDPTValue010);
  // (constant) top-bottom clipped
  RSDPTValueProc[012]:=Unaligned(@RSDPTValue012);
  // (constant) left-right-top-bottom clipped
  RSDPTValueProc[014]:=Unaligned(@RSDPTValue014);
  // (fading) not clipped
  RSDPTValueProc[011]:=Unaligned(@RSDPTValue011);
  // (fading) top-bottom clipped
  RSDPTValueProc[013]:=Unaligned(@RSDPTValue013);
  // (fading) left-right-top-bottom clipped
  RSDPTValueProc[015]:=Unaligned(@RSDPTValue015);

  {Alphablend}
  // (constant) not clipped
  RSDPTValueProc[020]:=Unaligned(@RSDPTValue020);
  // (constant) top-bottom clipped
  RSDPTValueProc[022]:=Unaligned(@RSDPTValue022);
  // (constant) left-right-top-bottom clipped
  RSDPTValueProc[024]:=Unaligned(@RSDPTValue024);
  // (fading) not clipped
  RSDPTValueProc[021]:=Unaligned(@RSDPTValue021);
  // (fading) top-bottom clipped
  RSDPTValueProc[023]:=Unaligned(@RSDPTValue023);
  // (fading) left-right-top-bottom clipped
  RSDPTValueProc[025]:=Unaligned(@RSDPTValue025);

  {Inverse}
  // (constant) not clipped
  RSDPTValueProc[030]:=Unaligned(@RSDPTValue030);
  // (constant) top-bottom clipped
  RSDPTValueProc[032]:=Unaligned(@RSDPTValue032);
  // (constant) left-right-top-bottom clipped
  RSDPTValueProc[034]:=Unaligned(@RSDPTValue034);
  // (fading) not clipped
  RSDPTValueProc[031]:=Unaligned(@RSDPTValue031);
  // (fading) top-bottom clipped
  RSDPTValueProc[033]:=Unaligned(@RSDPTValue033);
  // (fading) left-right-top-bottom clipped
  RSDPTValueProc[035]:=Unaligned(@RSDPTValue035);

  {Highlight}
  // (constant) not clipped
  RSDPTValueProc[040]:=Unaligned(@RSDPTValue040);
  // (constant) top-bottom clipped
  RSDPTValueProc[042]:=Unaligned(@RSDPTValue042);
  // (constant) left-right-top-bottom clipped
  RSDPTValueProc[044]:=Unaligned(@RSDPTValue044);
  // (fading) not clipped
  RSDPTValueProc[041]:=Unaligned(@RSDPTValue041);
  // (fading) top-bottom clipped
  RSDPTValueProc[043]:=Unaligned(@RSDPTValue043);
  // (fading) left-right-top-bottom clipped
  RSDPTValueProc[045]:=Unaligned(@RSDPTValue045);

  {Darken}
  // (constant) not clipped
  RSDPTValueProc[050]:=Unaligned(@RSDPTValue050);
  // (constant) top-bottom clipped
  RSDPTValueProc[052]:=Unaligned(@RSDPTValue052);
  // (constant) left-right-top-bottom clipped
  RSDPTValueProc[054]:=Unaligned(@RSDPTValue054);
  // (fading) not clipped
  RSDPTValueProc[051]:=Unaligned(@RSDPTValue051);
  // (fading) top-bottom clipped
  RSDPTValueProc[053]:=Unaligned(@RSDPTValue053);
  // (fading) left-right-top-bottom clipped
  RSDPTValueProc[055]:=Unaligned(@RSDPTValue055);

  {GrayscaleR}
  // (constant) not clipped
  RSDPTValueProc[060]:=Unaligned(@RSDPTValue060);
  // (constant) top-bottom clipped
  RSDPTValueProc[062]:=Unaligned(@RSDPTValue062);
  // (constant) left-right-top-bottom clipped
  RSDPTValueProc[064]:=Unaligned(@RSDPTValue064);
  // (fading) not clipped
  RSDPTValueProc[061]:=Unaligned(@RSDPTValue061);
  // (fading) top-bottom clipped
  RSDPTValueProc[063]:=Unaligned(@RSDPTValue063);
  // (fading) left-right-top-bottom clipped
  RSDPTValueProc[065]:=Unaligned(@RSDPTValue065);

  {GrayscaleG}
  // (constant) not clipped
  RSDPTValueProc[070]:=Unaligned(@RSDPTValue070);
  // (constant) top-bottom clipped
  RSDPTValueProc[072]:=Unaligned(@RSDPTValue072);
  // (constant) left-right-top-bottom clipped
  RSDPTValueProc[074]:=Unaligned(@RSDPTValue074);
  // (fading) not clipped
  RSDPTValueProc[071]:=Unaligned(@RSDPTValue071);
  // (fading) top-bottom clipped
  RSDPTValueProc[073]:=Unaligned(@RSDPTValue073);
  // (fading) left-right-top-bottom clipped
  RSDPTValueProc[075]:=Unaligned(@RSDPTValue075);

  {GrayscaleB}
  // (constant) not clipped
  RSDPTValueProc[080]:=Unaligned(@RSDPTValue080);
  // (constant) top-bottom clipped
  RSDPTValueProc[082]:=Unaligned(@RSDPTValue082);
  // (constant) left-right-top-bottom clipped
  RSDPTValueProc[084]:=Unaligned(@RSDPTValue084);
  // (fading) not clipped
  RSDPTValueProc[081]:=Unaligned(@RSDPTValue081);
  // (fading) top-bottom clipped
  RSDPTValueProc[083]:=Unaligned(@RSDPTValue083);
  // (fading) left-right-top-bottom clipped
  RSDPTValueProc[085]:=Unaligned(@RSDPTValue085);

  {Monochrome Noise}
  // (constant) not clipped
  RSDPTValueProc[090]:=Unaligned(@RSDPTValue090);
  // (constant) top-bottom clipped
  RSDPTValueProc[092]:=Unaligned(@RSDPTValue092);
  // (constant) left-right-top-bottom clipped
  RSDPTValueProc[094]:=Unaligned(@RSDPTValue094);
  // (fading) not clipped
  RSDPTValueProc[091]:=Unaligned(@RSDPTValue091);
  // (fading) top-bottom clipped
  RSDPTValueProc[093]:=Unaligned(@RSDPTValue093);
  // (fading) left-right-top-bottom clipped
  RSDPTValueProc[095]:=Unaligned(@RSDPTValue095);

  {ColorizeR}
  // (constant) not clipped
  RSDPTValueProc[100]:=Unaligned(@RSDPTValue100);
  // (constant) top-bottom clipped
  RSDPTValueProc[102]:=Unaligned(@RSDPTValue102);
  // (constant) left-right-top-bottom clipped
  RSDPTValueProc[104]:=Unaligned(@RSDPTValue104);
  // (fading) not clipped
  RSDPTValueProc[101]:=Unaligned(@RSDPTValue101);
  // (fading) top-bottom clipped
  RSDPTValueProc[103]:=Unaligned(@RSDPTValue103);
  // (fading) left-right-top-bottom clipped
  RSDPTValueProc[105]:=Unaligned(@RSDPTValue105);

  {ColorizeG}
  // (constant) not clipped
  RSDPTValueProc[110]:=Unaligned(@RSDPTValue110);
  // (constant) top-bottom clipped
  RSDPTValueProc[112]:=Unaligned(@RSDPTValue112);
  // (constant) left-right-top-bottom clipped
  RSDPTValueProc[114]:=Unaligned(@RSDPTValue114);
  // (fading) not clipped
  RSDPTValueProc[111]:=Unaligned(@RSDPTValue111);
  // (fading) top-bottom clipped
  RSDPTValueProc[113]:=Unaligned(@RSDPTValue113);
  // (fading) left-right-top-bottom clipped
  RSDPTValueProc[115]:=Unaligned(@RSDPTValue115);

  {ColorizeB}
  // (constant) not clipped
  RSDPTValueProc[120]:=Unaligned(@RSDPTValue120);
  // (constant) top-bottom clipped
  RSDPTValueProc[122]:=Unaligned(@RSDPTValue122);
  // (constant) left-right-top-bottom clipped
  RSDPTValueProc[124]:=Unaligned(@RSDPTValue124);
  // (fading) not clipped
  RSDPTValueProc[121]:=Unaligned(@RSDPTValue121);
  // (fading) top-bottom clipped
  RSDPTValueProc[123]:=Unaligned(@RSDPTValue123);
  // (fading) left-right-top-bottom clipped
  RSDPTValueProc[125]:=Unaligned(@RSDPTValue125);

  {BlurRGB}
  // (constant) not clipped
  RSDPTValueProc[130]:=Unaligned(@RSDPTValue130);
  // (constant) top-bottom clipped
  RSDPTValueProc[132]:=Unaligned(@RSDPTValue132);
  // (constant) left-right-top-bottom clipped
  RSDPTValueProc[134]:=Unaligned(@RSDPTValue134);
  // (fading) top-bottom clipped
  RSDPTValueProc[133]:=Unaligned(@RSDPTValue133);
  // (fading) left-right-top-bottom clipped
  RSDPTValueProc[135]:=Unaligned(@RSDPTValue135);

  {BlurRRB}
  // (constant) not clipped
  RSDPTValueProc[140]:=Unaligned(@RSDPTValue140);
  // (constant) top-bottom clipped
  RSDPTValueProc[142]:=Unaligned(@RSDPTValue142);
  // (constant) left-right-top-bottom clipped
  RSDPTValueProc[144]:=Unaligned(@RSDPTValue144);
  // (fading) not clipped
  RSDPTValueProc[141]:=Unaligned(@RSDPTValue141);
  // (fading) top-bottom clipped
  RSDPTValueProc[143]:=Unaligned(@RSDPTValue143);
  // (fading) left-right-top-bottom clipped
  RSDPTValueProc[145]:=Unaligned(@RSDPTValue145);

  {BlurRGR}
  // (constant) not clipped
  RSDPTValueProc[150]:=Unaligned(@RSDPTValue150);
  // (constant) top-bottom clipped
  RSDPTValueProc[152]:=Unaligned(@RSDPTValue152);
  // (constant) left-right-top-bottom clipped
  RSDPTValueProc[154]:=Unaligned(@RSDPTValue154);
  // (fading) not clipped
  RSDPTValueProc[151]:=Unaligned(@RSDPTValue151);
  // (fading) top-bottom clipped
  RSDPTValueProc[153]:=Unaligned(@RSDPTValue153);
  // (fading) left-right-top-bottom clipped
  RSDPTValueProc[155]:=Unaligned(@RSDPTValue155);

  {BlurGGB}
  // (constant) not clipped
  RSDPTValueProc[160]:=Unaligned(@RSDPTValue160);
  // (constant) top-bottom clipped
  RSDPTValueProc[162]:=Unaligned(@RSDPTValue162);
  // (constant) left-right-top-bottom clipped
  RSDPTValueProc[164]:=Unaligned(@RSDPTValue164);
  // (fading) not clipped
  RSDPTValueProc[161]:=Unaligned(@RSDPTValue161);
  // (fading) top-bottom clipped
  RSDPTValueProc[163]:=Unaligned(@RSDPTValue163);
  // (fading) left-right-top-bottom clipped
  RSDPTValueProc[165]:=Unaligned(@RSDPTValue165);

  {BlurRGG}
  // (constant) not clipped
  RSDPTValueProc[170]:=Unaligned(@RSDPTValue170);
  // (constant) top-bottom clipped
  RSDPTValueProc[172]:=Unaligned(@RSDPTValue172);
  // (constant) left-right-top-bottom clipped
  RSDPTValueProc[174]:=Unaligned(@RSDPTValue174);
  // (fading) not clipped
  RSDPTValueProc[171]:=Unaligned(@RSDPTValue171);
  // (fading) top-bottom clipped
  RSDPTValueProc[173]:=Unaligned(@RSDPTValue173);
  // (fading) left-right-top-bottom clipped
  RSDPTValueProc[175]:=Unaligned(@RSDPTValue175);

  {BlurBGB}
  // (constant) not clipped
  RSDPTValueProc[180]:=Unaligned(@RSDPTValue180);
  // (constant) top-bottom clipped
  RSDPTValueProc[182]:=Unaligned(@RSDPTValue182);
  // (constant) left-right-top-bottom clipped
  RSDPTValueProc[184]:=Unaligned(@RSDPTValue184);
  // (fading) not clipped
  RSDPTValueProc[181]:=Unaligned(@RSDPTValue181);
  // (fading) top-bottom clipped
  RSDPTValueProc[183]:=Unaligned(@RSDPTValue183);
  // (fading) left-right-top-bottom clipped
  RSDPTValueProc[185]:=Unaligned(@RSDPTValue185);

  {BlurRBB}
  // (constant) not clipped
  RSDPTValueProc[190]:=Unaligned(@RSDPTValue190);
  // (constant) top-bottom clipped
  RSDPTValueProc[192]:=Unaligned(@RSDPTValue192);
  // (constant) left-right-top-bottom clipped
  RSDPTValueProc[194]:=Unaligned(@RSDPTValue194);
  // (fading) not clipped
  RSDPTValueProc[191]:=Unaligned(@RSDPTValue191);
  // (fading) top-bottom clipped
  RSDPTValueProc[193]:=Unaligned(@RSDPTValue193);
  // (fading) left-right-top-bottom clipped
  RSDPTValueProc[195]:=Unaligned(@RSDPTValue195);

  {BlurRRR}
  // (constant) not clipped
  RSDPTValueProc[200]:=Unaligned(@RSDPTValue200);
  // (constant) top-bottom clipped
  RSDPTValueProc[202]:=Unaligned(@RSDPTValue202);
  // (constant) left-right-top-bottom clipped
  RSDPTValueProc[204]:=Unaligned(@RSDPTValue204);
  // (fading) top-bottom clipped
  RSDPTValueProc[203]:=Unaligned(@RSDPTValue203);
  // (fading) left-right-top-bottom clipped
  RSDPTValueProc[205]:=Unaligned(@RSDPTValue205);

  {BlurGGG}
  // (constant) not clipped
  RSDPTValueProc[210]:=Unaligned(@RSDPTValue210);
  // (constant) top-bottom clipped
  RSDPTValueProc[212]:=Unaligned(@RSDPTValue212);
  // (constant) left-right-top-bottom clipped
  RSDPTValueProc[214]:=Unaligned(@RSDPTValue214);
  // (fading) not clipped
  RSDPTValueProc[211]:=Unaligned(@RSDPTValue211);
  // (fading) top-bottom clipped
  RSDPTValueProc[213]:=Unaligned(@RSDPTValue213);
  // (fading) left-right-top-bottom clipped
  RSDPTValueProc[215]:=Unaligned(@RSDPTValue215);

  {BlurBBB}
  // (constant) not clipped
  RSDPTValueProc[220]:=Unaligned(@RSDPTValue220);
  // (constant) top-bottom clipped
  RSDPTValueProc[222]:=Unaligned(@RSDPTValue222);
  // (constant) left-right-top-bottom clipped
  RSDPTValueProc[224]:=Unaligned(@RSDPTValue224);
  // (fading) not clipped
  RSDPTValueProc[221]:=Unaligned(@RSDPTValue221);
  // (fading) top-bottom clipped
  RSDPTValueProc[223]:=Unaligned(@RSDPTValue223);
  // (fading) left-right-top-bottom clipped
  RSDPTValueProc[225]:=Unaligned(@RSDPTValue225);

  {Contrast}
  // (constant) not clipped
  RSDPTValueProc[230]:=Unaligned(@RSDPTValue230);
  // (constant) top-bottom clipped
  RSDPTValueProc[232]:=Unaligned(@RSDPTValue232);
  // (constant) left-right-top-bottom clipped
  RSDPTValueProc[234]:=Unaligned(@RSDPTValue234);
  // (fading) not clipped
  RSDPTValueProc[231]:=Unaligned(@RSDPTValue231);
  // (fading) top-bottom clipped
  RSDPTValueProc[233]:=Unaligned(@RSDPTValue233);
  // (fading) left-right-top-bottom clipped
  RSDPTValueProc[235]:=Unaligned(@RSDPTValue235);

  {$endregion}

  {||scl_mul||>1: (SU - Scale Up  )} {$region -fold}

  {Empty}
  RSUPTValueProc[009]:=Unaligned(@RSUPTValue009);

  {Monochrome}
  // (constant) not clipped
  RSUPTValueProc[000]:=Unaligned(@RSUPTValue000);
  // (constant) top-bottom clipped
  RSUPTValueProc[002]:=Unaligned(@RSUPTValue002);
  // (constant) left-right-top-bottom clipped
  RSUPTValueProc[004]:=Unaligned(@RSUPTValue004);
  // (fading) not clipped
  RSUPTValueProc[001]:=Unaligned(@RSUPTValue001);
  // (fading) top-bottom clipped
  RSUPTValueProc[003]:=Unaligned(@RSUPTValue003);
  // (fading) left-right-top-bottom clipped
  RSUPTValueProc[005]:=Unaligned(@RSUPTValue005);

  {Additive}
  // (constant) not clipped
  RSUPTValueProc[010]:=Unaligned(@RSUPTValue010);
  // (constant) top-bottom clipped
  RSUPTValueProc[012]:=Unaligned(@RSUPTValue012);
  // (constant) left-right-top-bottom clipped
  RSUPTValueProc[014]:=Unaligned(@RSUPTValue014);
  // (fading) not clipped
  RSUPTValueProc[011]:=Unaligned(@RSUPTValue011);
  // (fading) top-bottom clipped
  RSUPTValueProc[013]:=Unaligned(@RSUPTValue013);
  // (fading) left-right-top-bottom clipped
  RSUPTValueProc[015]:=Unaligned(@RSUPTValue015);

  {Alphablend}
  // (constant) not clipped
  RSUPTValueProc[020]:=Unaligned(@RSUPTValue020);
  // (constant) top-bottom clipped
  RSUPTValueProc[022]:=Unaligned(@RSUPTValue022);
  // (constant) left-right-top-bottom clipped
  RSUPTValueProc[024]:=Unaligned(@RSUPTValue024);
  // (fading) not clipped
  RSUPTValueProc[021]:=Unaligned(@RSUPTValue021);
  // (fading) top-bottom clipped
  RSUPTValueProc[023]:=Unaligned(@RSUPTValue023);
  // (fading) left-right-top-bottom clipped
  RSUPTValueProc[025]:=Unaligned(@RSUPTValue025);

  {Inverse}
  // (constant) not clipped
  RSUPTValueProc[030]:=Unaligned(@RSUPTValue030);
  // (constant) top-bottom clipped
  RSUPTValueProc[032]:=Unaligned(@RSUPTValue032);
  // (constant) left-right-top-bottom clipped
  RSUPTValueProc[034]:=Unaligned(@RSUPTValue034);
  // (fading) not clipped
  RSUPTValueProc[031]:=Unaligned(@RSUPTValue031);
  // (fading) top-bottom clipped
  RSUPTValueProc[033]:=Unaligned(@RSUPTValue033);
  // (fading) left-right-top-bottom clipped
  RSUPTValueProc[035]:=Unaligned(@RSUPTValue035);

  {Highlight}
  // (constant) not clipped
  RSUPTValueProc[040]:=Unaligned(@RSUPTValue040);
  // (constant) top-bottom clipped
  RSUPTValueProc[042]:=Unaligned(@RSUPTValue042);
  // (constant) left-right-top-bottom clipped
  RSUPTValueProc[044]:=Unaligned(@RSUPTValue044);
  // (fading) not clipped
  RSUPTValueProc[041]:=Unaligned(@RSUPTValue041);
  // (fading) top-bottom clipped
  RSUPTValueProc[043]:=Unaligned(@RSUPTValue043);
  // (fading) left-right-top-bottom clipped
  RSUPTValueProc[045]:=Unaligned(@RSUPTValue045);

  {Darken}
  // (constant) not clipped
  RSUPTValueProc[050]:=Unaligned(@RSUPTValue050);
  // (constant) top-bottom clipped
  RSUPTValueProc[052]:=Unaligned(@RSUPTValue052);
  // (constant) left-right-top-bottom clipped
  RSUPTValueProc[054]:=Unaligned(@RSUPTValue054);
  // (fading) not clipped
  RSUPTValueProc[051]:=Unaligned(@RSUPTValue051);
  // (fading) top-bottom clipped
  RSUPTValueProc[053]:=Unaligned(@RSUPTValue053);
  // (fading) left-right-top-bottom clipped
  RSUPTValueProc[055]:=Unaligned(@RSUPTValue055);

  {GrayscaleR}
  // (constant) not clipped
  RSUPTValueProc[060]:=Unaligned(@RSUPTValue060);
  // (constant) top-bottom clipped
  RSUPTValueProc[062]:=Unaligned(@RSUPTValue062);
  // (constant) left-right-top-bottom clipped
  RSUPTValueProc[064]:=Unaligned(@RSUPTValue064);
  // (fading) not clipped
  RSUPTValueProc[061]:=Unaligned(@RSUPTValue061);
  // (fading) top-bottom clipped
  RSUPTValueProc[063]:=Unaligned(@RSUPTValue063);
  // (fading) left-right-top-bottom clipped
  RSUPTValueProc[065]:=Unaligned(@RSUPTValue065);

  {GrayscaleG}
  // (constant) not clipped
  RSUPTValueProc[070]:=Unaligned(@RSUPTValue070);
  // (constant) top-bottom clipped
  RSUPTValueProc[072]:=Unaligned(@RSUPTValue072);
  // (constant) left-right-top-bottom clipped
  RSUPTValueProc[074]:=Unaligned(@RSUPTValue074);
  // (fading) not clipped
  RSUPTValueProc[071]:=Unaligned(@RSUPTValue071);
  // (fading) top-bottom clipped
  RSUPTValueProc[073]:=Unaligned(@RSUPTValue073);
  // (fading) left-right-top-bottom clipped
  RSUPTValueProc[075]:=Unaligned(@RSUPTValue075);

  {GrayscaleB}
  // (constant) not clipped
  RSUPTValueProc[080]:=Unaligned(@RSUPTValue080);
  // (constant) top-bottom clipped
  RSUPTValueProc[082]:=Unaligned(@RSUPTValue082);
  // (constant) left-right-top-bottom clipped
  RSUPTValueProc[084]:=Unaligned(@RSUPTValue084);
  // (fading) not clipped
  RSUPTValueProc[081]:=Unaligned(@RSUPTValue081);
  // (fading) top-bottom clipped
  RSUPTValueProc[083]:=Unaligned(@RSUPTValue083);
  // (fading) left-right-top-bottom clipped
  RSUPTValueProc[085]:=Unaligned(@RSUPTValue085);

  {Monochrome Noise}
  // (constant) not clipped
  RSUPTValueProc[090]:=Unaligned(@RSUPTValue090);
  // (constant) top-bottom clipped
  RSUPTValueProc[092]:=Unaligned(@RSUPTValue092);
  // (constant) left-right-top-bottom clipped
  RSUPTValueProc[094]:=Unaligned(@RSUPTValue094);
  // (fading) not clipped
  RSUPTValueProc[091]:=Unaligned(@RSUPTValue091);
  // (fading) top-bottom clipped
  RSUPTValueProc[093]:=Unaligned(@RSUPTValue093);
  // (fading) left-right-top-bottom clipped
  RSUPTValueProc[095]:=Unaligned(@RSUPTValue095);

  {ColorizeR}
  // (constant) not clipped
  RSUPTValueProc[100]:=Unaligned(@RSUPTValue100);
  // (constant) top-bottom clipped
  RSUPTValueProc[102]:=Unaligned(@RSUPTValue102);
  // (constant) left-right-top-bottom clipped
  RSUPTValueProc[104]:=Unaligned(@RSUPTValue104);
  // (fading) not clipped
  RSUPTValueProc[101]:=Unaligned(@RSUPTValue101);
  // (fading) top-bottom clipped
  RSUPTValueProc[103]:=Unaligned(@RSUPTValue103);
  // (fading) left-right-top-bottom clipped
  RSUPTValueProc[105]:=Unaligned(@RSUPTValue105);

  {ColorizeG}
  // (constant) not clipped
  RSUPTValueProc[110]:=Unaligned(@RSUPTValue110);
  // (constant) top-bottom clipped
  RSUPTValueProc[112]:=Unaligned(@RSUPTValue112);
  // (constant) left-right-top-bottom clipped
  RSUPTValueProc[114]:=Unaligned(@RSUPTValue114);
  // (fading) not clipped
  RSUPTValueProc[111]:=Unaligned(@RSUPTValue111);
  // (fading) top-bottom clipped
  RSUPTValueProc[113]:=Unaligned(@RSUPTValue113);
  // (fading) left-right-top-bottom clipped
  RSUPTValueProc[115]:=Unaligned(@RSUPTValue115);

  {ColorizeB}
  // (constant) not clipped
  RSUPTValueProc[120]:=Unaligned(@RSUPTValue120);
  // (constant) top-bottom clipped
  RSUPTValueProc[122]:=Unaligned(@RSUPTValue122);
  // (constant) left-right-top-bottom clipped
  RSUPTValueProc[124]:=Unaligned(@RSUPTValue124);
  // (fading) not clipped
  RSUPTValueProc[121]:=Unaligned(@RSUPTValue121);
  // (fading) top-bottom clipped
  RSUPTValueProc[123]:=Unaligned(@RSUPTValue123);
  // (fading) left-right-top-bottom clipped
  RSUPTValueProc[125]:=Unaligned(@RSUPTValue125);

  {BlurRGB}
  // (constant) not clipped
  RSUPTValueProc[130]:=Unaligned(@RSUPTValue130);
  // (constant) top-bottom clipped
  RSUPTValueProc[132]:=Unaligned(@RSUPTValue132);
  // (constant) left-right-top-bottom clipped
  RSUPTValueProc[134]:=Unaligned(@RSUPTValue134);
  // (fading) not clipped
  RSUPTValueProc[131]:=Unaligned(@RSUPTValue131);
  // (fading) top-bottom clipped
  RSUPTValueProc[133]:=Unaligned(@RSUPTValue133);
  // (fading) left-right-top-bottom clipped
  RSUPTValueProc[135]:=Unaligned(@RSUPTValue135);

  {BlurRRB}
  // (constant) not clipped
  RSUPTValueProc[140]:=Unaligned(@RSUPTValue140);
  // (constant) top-bottom clipped
  RSUPTValueProc[142]:=Unaligned(@RSUPTValue142);
  // (constant) left-right-top-bottom clipped
  RSUPTValueProc[144]:=Unaligned(@RSUPTValue144);
  // (fading) not clipped
  RSUPTValueProc[141]:=Unaligned(@RSUPTValue141);
  // (fading) top-bottom clipped
  RSUPTValueProc[143]:=Unaligned(@RSUPTValue143);
  // (fading) left-right-top-bottom clipped
  RSUPTValueProc[145]:=Unaligned(@RSUPTValue145);

  {BlurRGR}
  // (constant) not clipped
  RSUPTValueProc[150]:=Unaligned(@RSUPTValue150);
  // (constant) top-bottom clipped
  RSUPTValueProc[152]:=Unaligned(@RSUPTValue152);
  // (constant) left-right-top-bottom clipped
  RSUPTValueProc[154]:=Unaligned(@RSUPTValue154);
  // (fading) not clipped
  RSUPTValueProc[151]:=Unaligned(@RSUPTValue151);
  // (fading) top-bottom clipped
  RSUPTValueProc[153]:=Unaligned(@RSUPTValue153);
  // (fading) left-right-top-bottom clipped
  RSUPTValueProc[155]:=Unaligned(@RSUPTValue155);

  {BlurGGB}
  // (constant) not clipped
  RSUPTValueProc[160]:=Unaligned(@RSUPTValue160);
  // (constant) top-bottom clipped
  RSUPTValueProc[162]:=Unaligned(@RSUPTValue162);
  // (constant) left-right-top-bottom clipped
  RSUPTValueProc[164]:=Unaligned(@RSUPTValue164);
  // (fading) not clipped
  RSUPTValueProc[161]:=Unaligned(@RSUPTValue161);
  // (fading) top-bottom clipped
  RSUPTValueProc[163]:=Unaligned(@RSUPTValue163);
  // (fading) left-right-top-bottom clipped
  RSUPTValueProc[165]:=Unaligned(@RSUPTValue165);

  {BlurRGG}
  // (constant) not clipped
  RSUPTValueProc[170]:=Unaligned(@RSUPTValue170);
  // (constant) top-bottom clipped
  RSUPTValueProc[172]:=Unaligned(@RSUPTValue172);
  // (constant) left-right-top-bottom clipped
  RSUPTValueProc[174]:=Unaligned(@RSUPTValue174);
  // (fading) not clipped
  RSUPTValueProc[171]:=Unaligned(@RSUPTValue171);
  // (fading) top-bottom clipped
  RSUPTValueProc[173]:=Unaligned(@RSUPTValue173);
  // (fading) left-right-top-bottom clipped
  RSUPTValueProc[175]:=Unaligned(@RSUPTValue175);

  {BlurBGB}
  // (constant) not clipped
  RSUPTValueProc[180]:=Unaligned(@RSUPTValue180);
  // (constant) top-bottom clipped
  RSUPTValueProc[182]:=Unaligned(@RSUPTValue182);
  // (constant) left-right-top-bottom clipped
  RSUPTValueProc[184]:=Unaligned(@RSUPTValue184);
  // (fading) not clipped
  RSUPTValueProc[181]:=Unaligned(@RSUPTValue181);
  // (fading) top-bottom clipped
  RSUPTValueProc[183]:=Unaligned(@RSUPTValue183);
  // (fading) left-right-top-bottom clipped
  RSUPTValueProc[185]:=Unaligned(@RSUPTValue185);

  {BlurRBB}
  // (constant) not clipped
  RSUPTValueProc[190]:=Unaligned(@RSUPTValue190);
  // (constant) top-bottom clipped
  RSUPTValueProc[192]:=Unaligned(@RSUPTValue192);
  // (constant) left-right-top-bottom clipped
  RSUPTValueProc[194]:=Unaligned(@RSUPTValue194);
  // (fading) not clipped
  RSUPTValueProc[191]:=Unaligned(@RSUPTValue191);
  // (fading) top-bottom clipped
  RSUPTValueProc[193]:=Unaligned(@RSUPTValue193);
  // (fading) left-right-top-bottom clipped
  RSUPTValueProc[195]:=Unaligned(@RSUPTValue195);

  {BlurRRR}
  // (constant) not clipped
  RSUPTValueProc[200]:=Unaligned(@RSUPTValue200);
  // (constant) top-bottom clipped
  RSUPTValueProc[202]:=Unaligned(@RSUPTValue202);
  // (constant) left-right-top-bottom clipped
  RSUPTValueProc[204]:=Unaligned(@RSUPTValue204);
  // (fading) not clipped
  RSUPTValueProc[201]:=Unaligned(@RSUPTValue201);
  // (fading) top-bottom clipped
  RSUPTValueProc[203]:=Unaligned(@RSUPTValue203);
  // (fading) left-right-top-bottom clipped
  RSUPTValueProc[205]:=Unaligned(@RSUPTValue205);

  {BlurGGG}
  // (constant) not clipped
  RSUPTValueProc[210]:=Unaligned(@RSUPTValue210);
  // (constant) top-bottom clipped
  RSUPTValueProc[212]:=Unaligned(@RSUPTValue212);
  // (constant) left-right-top-bottom clipped
  RSUPTValueProc[214]:=Unaligned(@RSUPTValue214);
  // (fading) not clipped
  RSUPTValueProc[211]:=Unaligned(@RSUPTValue211);
  // (fading) top-bottom clipped
  RSUPTValueProc[213]:=Unaligned(@RSUPTValue213);
  // (fading) left-right-top-bottom clipped
  RSUPTValueProc[215]:=Unaligned(@RSUPTValue215);

  {BlurBBB}
  // (constant) not clipped
  RSUPTValueProc[220]:=Unaligned(@RSUPTValue220);
  // (constant) top-bottom clipped
  RSUPTValueProc[222]:=Unaligned(@RSUPTValue222);
  // (constant) left-right-top-bottom clipped
  RSUPTValueProc[224]:=Unaligned(@RSUPTValue224);
  // (fading) not clipped
  RSUPTValueProc[221]:=Unaligned(@RSUPTValue221);
  // (fading) top-bottom clipped
  RSUPTValueProc[223]:=Unaligned(@RSUPTValue223);
  // (fading) left-right-top-bottom clipped
  RSUPTValueProc[225]:=Unaligned(@RSUPTValue225);

  {Contrast}
  // (constant) not clipped
  RSUPTValueProc[230]:=Unaligned(@RSUPTValue230);
  // (constant) top-bottom clipped
  RSUPTValueProc[232]:=Unaligned(@RSUPTValue232);
  // (constant) left-right-top-bottom clipped
  RSUPTValueProc[234]:=Unaligned(@RSUPTValue234);
  // (fading) not clipped
  RSUPTValueProc[231]:=Unaligned(@RSUPTValue231);
  // (fading) top-bottom clipped
  RSUPTValueProc[233]:=Unaligned(@RSUPTValue233);
  // (fading) left-right-top-bottom clipped
  RSUPTValueProc[235]:=Unaligned(@RSUPTValue235);

  {$endregion}

  {$endregion}

  {$endregion}

  {Gradient floodFill} {$region -fold}

  // NT - not transparent pixels:

  {Color} {$region -fold}

  {||scl_mul||=1:                  } {$region -fold}

  {Empty}
  GrVNTColorProc[009]:=Unaligned(@GrVNTColor009);

  {Color of Curent Layer}
  // (constant) not clipped
  GrVNTColorProc[000]:=Unaligned(@GrVNTColor020);
  // (constant) top-bottom clipped
  GrVNTColorProc[002]:=Unaligned(@GrVNTColor020);
  // (constant) left-right-top-bottom clipped
  GrVNTColorProc[004]:=Unaligned(@GrVNTColor024);
  // (constant) image has monochrome color channel
  GrVNTColorProc[006]:=Unaligned(@GrVNTColor026);
  // (fading) not clipped
  GrVNTColorProc[001]:=Unaligned(@GrVNTColor020);
  // (fading) top-bottom clipped
  GrVNTColorProc[003]:=Unaligned(@GrVNTColor020);
  // (fading) left-right-top-bottom clipped
  GrVNTColorProc[005]:=Unaligned(@GrVNTColor024);
  // (fading) image has monochrome color channel
  GrVNTColorProc[007]:=Unaligned(@GrVNTColor026);

  {Color of Curent Layer(Additive)}
  // (constant) not clipped
  GrVNTColorProc[010]:=Unaligned(@GrVNTColor010);
  // (constant) top-bottom clipped
  GrVNTColorProc[012]:=Unaligned(@GrVNTColor010);
  // (constant) left-right-top-bottom clipped
  GrVNTColorProc[014]:=Unaligned(@GrVNTColor014);
  // (constant) image has monochrome color channel
  GrVNTColorProc[016]:=Unaligned(@GrVNTColor016);
  // (fading) not clipped
  GrVNTColorProc[011]:=Unaligned(@GrVNTColor010);
  // (fading) top-bottom clipped
  GrVNTColorProc[013]:=Unaligned(@GrVNTColor010);
  // (fading) left-right-top-bottom clipped
  GrVNTColorProc[015]:=Unaligned(@GrVNTColor014);
  // (fading) image has monochrome color channel
  GrVNTColorProc[017]:=Unaligned(@GrVNTColor016);

  {Color of Curent Layer(Alphablend)}
  // (constant) not clipped
  GrVNTColorProc[020]:=Unaligned(@GrVNTColor020);
  // (constant) top-bottom clipped
  GrVNTColorProc[022]:=Unaligned(@GrVNTColor020);
  // (constant) left-right-top-bottom clipped
  GrVNTColorProc[024]:=Unaligned(@GrVNTColor024);
  // (constant) image has monochrome color channel
  GrVNTColorProc[026]:=Unaligned(@GrVNTColor026);
  // (fading) not clipped
  GrVNTColorProc[021]:=Unaligned(@GrVNTColor020);
  // (fading) top-bottom clipped
  GrVNTColorProc[023]:=Unaligned(@GrVNTColor020);
  // (fading) left-right-top-bottom clipped
  GrVNTColorProc[025]:=Unaligned(@GrVNTColor024);
  // (fading) image has monochrome color channel
  GrVNTColorProc[027]:=Unaligned(@GrVNTColor026);

  {$endregion}

  {||scl_mul||<1: (SD - Scale Down)} {$region -fold}

  {Empty}
  GSDNTColorProc[009]:=Unaligned(@GSDNTColor009);

  {Color of Curent Layer}
  // (constant) not clipped
  GSDNTColorProc[000]:=Unaligned(@GSDNTColor020);
  // (constant) top-bottom clipped
  GSDNTColorProc[002]:=Unaligned(@GSDNTColor022);
  // (constant) left-right-top-bottom clipped
  GSDNTColorProc[004]:=Unaligned(@GSDNTColor024);
  // (constant) image has monochrome color channel
  GSDNTColorProc[006]:=Unaligned(@GSDNTColor026);
  // (fading) not clipped
  GSDNTColorProc[001]:=Unaligned(@GSDNTColor020);
  // (fading) top-bottom clipped
  GSDNTColorProc[003]:=Unaligned(@GSDNTColor022);
  // (fading) left-right-top-bottom clipped
  GSDNTColorProc[005]:=Unaligned(@GSDNTColor024);
  // (fading) image has monochrome color channel
  GSDNTColorProc[007]:=Unaligned(@GSDNTColor026);

  {Color of Curent Layer(Additive)}
  // (constant) not clipped
  GSDNTColorProc[010]:=Unaligned(@GSDNTColor010);
  // (constant) top-bottom clipped
  GSDNTColorProc[012]:=Unaligned(@GSDNTColor012);
  // (constant) left-right-top-bottom clipped
  GSDNTColorProc[014]:=Unaligned(@GSDNTColor014);
  // (constant) image has monochrome color channel
  GSDNTColorProc[016]:=Unaligned(@GSDNTColor016);
  // (fading) not clipped
  GSDNTColorProc[011]:=Unaligned(@GSDNTColor010);
  // (fading) top-bottom clipped
  GSDNTColorProc[013]:=Unaligned(@GSDNTColor012);
  // (fading) left-right-top-bottom clipped
  GSDNTColorProc[015]:=Unaligned(@GSDNTColor014);
  // (fading) image has monochrome color channel
  GSDNTColorProc[017]:=Unaligned(@GSDNTColor016);

  {Color of Curent Layer(Alphablend)}
  // (constant) not clipped
  GSDNTColorProc[020]:=Unaligned(@GSDNTColor020);
  // (constant) top-bottom clipped
  GSDNTColorProc[022]:=Unaligned(@GSDNTColor022);
  // (constant) left-right-top-bottom clipped
  GSDNTColorProc[024]:=Unaligned(@GSDNTColor024);
  // (constant) image has monochrome color channel
  GSDNTColorProc[026]:=Unaligned(@GSDNTColor026);
  // (fading) not clipped
  GSDNTColorProc[021]:=Unaligned(@GSDNTColor020);
  // (fading) top-bottom clipped
  GSDNTColorProc[023]:=Unaligned(@GSDNTColor022);
  // (fading) left-right-top-bottom clipped
  GSDNTColorProc[025]:=Unaligned(@GSDNTColor024);
  // (fading) image has monochrome color channel
  GSDNTColorProc[027]:=Unaligned(@GSDNTColor026);

  {$endregion}

  {||scl_mul||>1: (SU - Scale Up  )} {$region -fold}

  {Empty}
  GSUNTColorProc[009]:=Unaligned(@GSUNTColor009);

  {Color of Curent Layer}
  // (constant) not clipped
  GSUNTColorProc[000]:=Unaligned(@GSUNTColor020);
  // (constant) top-bottom clipped
  GSUNTColorProc[002]:=Unaligned(@GSUNTColor022);
  // (constant) left-right-top-bottom clipped
  GSUNTColorProc[004]:=Unaligned(@GSUNTColor024);
  // (constant) image has monochrome color channel
  GSUNTColorProc[006]:=Unaligned(@GSUNTColor026);
  // (fading) not clipped
  GSUNTColorProc[001]:=Unaligned(@GSUNTColor020);
  // (fading) top-bottom clipped
  GSUNTColorProc[003]:=Unaligned(@GSUNTColor022);
  // (fading) left-right-top-bottom clipped
  GSUNTColorProc[005]:=Unaligned(@GSUNTColor024);
  // (fading) image has monochrome color channel
  GSUNTColorProc[007]:=Unaligned(@GSUNTColor026);

  {Color of Curent Layer(Additive)}
  // (constant) not clipped
  GSUNTColorProc[010]:=Unaligned(@GSUNTColor010);
  // (constant) top-bottom clipped
  GSUNTColorProc[012]:=Unaligned(@GSUNTColor012);
  // (constant) left-right-top-bottom clipped
  GSUNTColorProc[014]:=Unaligned(@GSUNTColor014);
  // (constant) image has monochrome color channel
  GSUNTColorProc[016]:=Unaligned(@GSUNTColor016);
  // (fading) not clipped
  GSUNTColorProc[011]:=Unaligned(@GSUNTColor010);
  // (fading) top-bottom clipped
  GSUNTColorProc[013]:=Unaligned(@GSUNTColor012);
  // (fading) left-right-top-bottom clipped
  GSUNTColorProc[015]:=Unaligned(@GSUNTColor014);
  // (fading) image has monochrome color channel
  GSUNTColorProc[017]:=Unaligned(@GSUNTColor016);

  {Color of Curent Layer(Alphablend)}
  // (constant) not clipped
  GSUNTColorProc[020]:=Unaligned(@GSUNTColor020);
  // (constant) top-bottom clipped
  GSUNTColorProc[022]:=Unaligned(@GSUNTColor022);
  // (constant) left-right-top-bottom clipped
  GSUNTColorProc[024]:=Unaligned(@GSUNTColor024);
  // (constant) image has monochrome color channel
  GSUNTColorProc[026]:=Unaligned(@GSUNTColor026);
  // (fading) not clipped
  GSUNTColorProc[021]:=Unaligned(@GSUNTColor020);
  // (fading) top-bottom clipped
  GSUNTColorProc[023]:=Unaligned(@GSUNTColor022);
  // (fading) left-right-top-bottom clipped
  GSUNTColorProc[025]:=Unaligned(@GSUNTColor024);
  // (fading) image has monochrome color channel
  GSUNTColorProc[027]:=Unaligned(@GSUNTColor026);

  {$endregion}

  {$endregion}

  {Value} {$region -fold}

  {||scl_mul||=1:                  } {$region -fold}

  {Empty}
  GrVNTValueProc[009]:=Unaligned(@GrVNTValue009);

  {Monochrome}
  // (constant) not clipped
  GrVNTValueProc[000]:=Unaligned(@GrVNTValue000);
  // (constant) top-bottom clipped
  GrVNTValueProc[002]:=Unaligned(@GrVNTValue000);
  // (constant) left-right-top-bottom clipped
  GrVNTValueProc[004]:=Unaligned(@GrVNTValue004);
  // (constant) image has monochrome color channel
  GrVNTValueProc[006]:=Unaligned(@GrVNTValue006);
  // (fading) not clipped
  GrVNTValueProc[001]:=Unaligned(@GrVNTValue020);
  // (fading) top-bottom clipped
  GrVNTValueProc[003]:=Unaligned(@GrVNTValue020);
  // (fading) left-right-top-bottom clipped
  GrVNTValueProc[005]:=Unaligned(@GrVNTValue024);
  // (fading) image has monochrome color channel
  GrVNTValueProc[007]:=Unaligned(@GrVNTValue026);

  {Additive}
  // (constant) not clipped
  GrVNTValueProc[010]:=Unaligned(@GrVNTValue010);
  // (constant) top-bottom clipped
  GrVNTValueProc[012]:=Unaligned(@GrVNTValue010);
  // (constant) left-right-top-bottom clipped
  GrVNTValueProc[014]:=Unaligned(@GrVNTValue014);
  // (constant) image has monochrome color channel
  GrVNTValueProc[016]:=Unaligned(@GrVNTValue016);
  // (fading) not clipped
  GrVNTValueProc[011]:=Unaligned(@GrVNTValue010);
  // (fading) top-bottom clipped
  GrVNTValueProc[013]:=Unaligned(@GrVNTValue010);
  // (fading) left-right-top-bottom clipped
  GrVNTValueProc[015]:=Unaligned(@GrVNTValue014);
  // (fading) image has monochrome color channel
  GrVNTValueProc[017]:=Unaligned(@GrVNTValue016);

  {Alphablend}
  // (constant) not clipped
  GrVNTValueProc[020]:=Unaligned(@GrVNTValue020);
  // (constant) top-bottom clipped
  GrVNTValueProc[022]:=Unaligned(@GrVNTValue020);
  // (constant) left-right-top-bottom clipped
  GrVNTValueProc[024]:=Unaligned(@GrVNTValue024);
  // (constant) image has monochrome color channel
  GrVNTValueProc[026]:=Unaligned(@GrVNTValue026);
  // (fading) not clipped
  GrVNTValueProc[021]:=Unaligned(@GrVNTValue020);
  // (fading) top-bottom clipped
  GrVNTValueProc[023]:=Unaligned(@GrVNTValue020);
  // (fading) left-right-top-bottom clipped
  GrVNTValueProc[025]:=Unaligned(@GrVNTValue024);
  // (fading) image has monochrome color channel
  GrVNTValueProc[027]:=Unaligned(@GrVNTValue026);

  {Inverse}
  // (constant) not clipped
  GrVNTValueProc[030]:=Unaligned(@GrVNTValue030);
  // (constant) top-bottom clipped
  GrVNTValueProc[032]:=Unaligned(@GrVNTValue030);
  // (constant) left-right-top-bottom clipped
  GrVNTValueProc[034]:=Unaligned(@GrVNTValue034);
  // (constant) image has monochrome color channel
  GrVNTValueProc[036]:=Unaligned(@GrVNTValue036);
  // (fading) not clipped
  GrVNTValueProc[031]:=Unaligned(@GrVNTValue030);
  // (fading) top-bottom clipped
  GrVNTValueProc[033]:=Unaligned(@GrVNTValue030);
  // (fading) left-right-top-bottom clipped
  GrVNTValueProc[035]:=Unaligned(@GrVNTValue034);
  // (fading) image has monochrome color channel
  GrVNTValueProc[037]:=Unaligned(@GrVNTValue036);

  {Highlight}
  // (constant) not clipped
  GrVNTValueProc[040]:=Unaligned(@GrVNTValue040);
  // (constant) top-bottom clipped
  GrVNTValueProc[042]:=Unaligned(@GrVNTValue040);
  // (constant) left-right-top-bottom clipped
  GrVNTValueProc[044]:=Unaligned(@GrVNTValue044);
  // (constant) image has monochrome color channel
  GrVNTValueProc[046]:=Unaligned(@GrVNTValue046);
  // (fading) not clipped
  GrVNTValueProc[041]:=Unaligned(@GrVNTValue040);
  // (fading) top-bottom clipped
  GrVNTValueProc[043]:=Unaligned(@GrVNTValue040);
  // (fading) left-right-top-bottom clipped
  GrVNTValueProc[045]:=Unaligned(@GrVNTValue044);
  // (fading) image has monochrome color channel
  GrVNTValueProc[047]:=Unaligned(@GrVNTValue046);

  {Darken}
  // (constant) not clipped
  GrVNTValueProc[050]:=Unaligned(@GrVNTValue050);
  // (constant) top-bottom clipped
  GrVNTValueProc[052]:=Unaligned(@GrVNTValue050);
  // (constant) left-right-top-bottom clipped
  GrVNTValueProc[054]:=Unaligned(@GrVNTValue054);
  // (constant) image has monochrome color channel
  GrVNTValueProc[056]:=Unaligned(@GrVNTValue056);
  // (fading) not clipped
  GrVNTValueProc[051]:=Unaligned(@GrVNTValue050);
  // (fading) top-bottom clipped
  GrVNTValueProc[053]:=Unaligned(@GrVNTValue050);
  // (fading) left-right-top-bottom clipped
  GrVNTValueProc[055]:=Unaligned(@GrVNTValue054);
  // (fading) image has monochrome color channel
  GrVNTValueProc[057]:=Unaligned(@GrVNTValue056);

  {GrayscaleR}
  // (constant) not clipped
  GrVNTValueProc[060]:=Unaligned(@GrVNTValue060);
  // (constant) top-bottom clipped
  GrVNTValueProc[062]:=Unaligned(@GrVNTValue060);
  // (constant) left-right-top-bottom clipped
  GrVNTValueProc[064]:=Unaligned(@GrVNTValue064);
  // (constant) image has monochrome color channel
  GrVNTValueProc[066]:=Unaligned(@GrVNTValue066);
  // (fading) not clipped
  GrVNTValueProc[061]:=Unaligned(@GrVNTValue060);
  // (fading) top-bottom clipped
  GrVNTValueProc[063]:=Unaligned(@GrVNTValue060);
  // (fading) left-right-top-bottom clipped
  GrVNTValueProc[065]:=Unaligned(@GrVNTValue064);
  // (fading) image has monochrome color channel
  GrVNTValueProc[067]:=Unaligned(@GrVNTValue066);

  {GrayscaleG}
  // (constant) not clipped
  GrVNTValueProc[070]:=Unaligned(@GrVNTValue070);
  // (constant) top-bottom clipped
  GrVNTValueProc[072]:=Unaligned(@GrVNTValue070);
  // (constant) left-right-top-bottom clipped
  GrVNTValueProc[074]:=Unaligned(@GrVNTValue074);
  // (constant) image has monochrome color channel
  GrVNTValueProc[076]:=Unaligned(@GrVNTValue076);
  // (fading) not clipped
  GrVNTValueProc[071]:=Unaligned(@GrVNTValue070);
  // (fading) top-bottom clipped
  GrVNTValueProc[073]:=Unaligned(@GrVNTValue070);
  // (fading) left-right-top-bottom clipped
  GrVNTValueProc[075]:=Unaligned(@GrVNTValue074);
  // (fading) image has monochrome color channel
  GrVNTValueProc[077]:=Unaligned(@GrVNTValue076);

  {GrayscaleB}
  // (constant) not clipped
  GrVNTValueProc[080]:=Unaligned(@GrVNTValue080);
  // (constant) top-bottom clipped
  GrVNTValueProc[082]:=Unaligned(@GrVNTValue080);
  // (constant) left-right-top-bottom clipped
  GrVNTValueProc[084]:=Unaligned(@GrVNTValue084);
  // (constant) image has monochrome color channel
  GrVNTValueProc[086]:=Unaligned(@GrVNTValue086);
  // (fading) not clipped
  GrVNTValueProc[081]:=Unaligned(@GrVNTValue080);
  // (fading) top-bottom clipped
  GrVNTValueProc[083]:=Unaligned(@GrVNTValue080);
  // (fading) left-right-top-bottom clipped
  GrVNTValueProc[085]:=Unaligned(@GrVNTValue084);
  // (fading) image has monochrome color channel
  GrVNTValueProc[087]:=Unaligned(@GrVNTValue086);

  {Monochrome Noise}
  // (constant) not clipped
  GrVNTValueProc[090]:=Unaligned(@GrVNTValue090);
  // (constant) top-bottom clipped
  GrVNTValueProc[092]:=Unaligned(@GrVNTValue090);
  // (constant) left-right-top-bottom clipped
  GrVNTValueProc[094]:=Unaligned(@GrVNTValue094);
  // (constant) image has monochrome color channel
  GrVNTValueProc[096]:=Unaligned(@GrVNTValue096);
  // (fading) not clipped
  GrVNTValueProc[091]:=Unaligned(@GrVNTValue090);
  // (fading) top-bottom clipped
  GrVNTValueProc[093]:=Unaligned(@GrVNTValue090);
  // (fading) left-right-top-bottom clipped
  GrVNTValueProc[095]:=Unaligned(@GrVNTValue094);
  // (fading) image has monochrome color channel
  GrVNTValueProc[097]:=Unaligned(@GrVNTValue096);

  {ColorizeR}
  // (constant) not clipped
  GrVNTValueProc[100]:=Unaligned(@GrVNTValue100);
  // (constant) top-bottom clipped
  GrVNTValueProc[102]:=Unaligned(@GrVNTValue100);
  // (constant) left-right-top-bottom clipped
  GrVNTValueProc[104]:=Unaligned(@GrVNTValue104);
  // (constant) image has monochrome color channel
  GrVNTValueProc[106]:=Unaligned(@GrVNTValue106);
  // (fading) not clipped
  GrVNTValueProc[101]:=Unaligned(@GrVNTValue100);
  // (fading) top-bottom clipped
  GrVNTValueProc[103]:=Unaligned(@GrVNTValue100);
  // (fading) left-right-top-bottom clipped
  GrVNTValueProc[105]:=Unaligned(@GrVNTValue104);
  // (fading) image has monochrome color channel
  GrVNTValueProc[107]:=Unaligned(@GrVNTValue106);

  {ColorizeG}
  // (constant) not clipped
  GrVNTValueProc[110]:=Unaligned(@GrVNTValue110);
  // (constant) top-bottom clipped
  GrVNTValueProc[112]:=Unaligned(@GrVNTValue110);
  // (constant) left-right-top-bottom clipped
  GrVNTValueProc[114]:=Unaligned(@GrVNTValue114);
  // (constant) image has monochrome color channel
  GrVNTValueProc[116]:=Unaligned(@GrVNTValue116);
  // (fading) not clipped
  GrVNTValueProc[111]:=Unaligned(@GrVNTValue110);
  // (fading) top-bottom clipped
  GrVNTValueProc[113]:=Unaligned(@GrVNTValue110);
  // (fading) left-right-top-bottom clipped
  GrVNTValueProc[115]:=Unaligned(@GrVNTValue114);
  // (fading) image has monochrome color channel
  GrVNTValueProc[117]:=Unaligned(@GrVNTValue116);

  {ColorizeB}
  // (constant) not clipped
  GrVNTValueProc[120]:=Unaligned(@GrVNTValue120);
  // (constant) top-bottom clipped
  GrVNTValueProc[122]:=Unaligned(@GrVNTValue120);
  // (constant) left-right-top-bottom clipped
  GrVNTValueProc[124]:=Unaligned(@GrVNTValue124);
  // (constant) image has monochrome color channel
  GrVNTValueProc[126]:=Unaligned(@GrVNTValue126);
  // (fading) not clipped
  GrVNTValueProc[121]:=Unaligned(@GrVNTValue120);
  // (fading) top-bottom clipped
  GrVNTValueProc[123]:=Unaligned(@GrVNTValue120);
  // (fading) left-right-top-bottom clipped
  GrVNTValueProc[125]:=Unaligned(@GrVNTValue124);
  // (fading) image has monochrome color channel
  GrVNTValueProc[127]:=Unaligned(@GrVNTValue126);

  {BlurRGB}
  // (constant) not clipped
  GrVNTValueProc[130]:=Unaligned(@GrVNTValue130);
  // (constant) top-bottom clipped
  GrVNTValueProc[132]:=Unaligned(@GrVNTValue130);
  // (constant) left-right-top-bottom clipped
  GrVNTValueProc[134]:=Unaligned(@GrVNTValue134);
  // (constant) image has monochrome color channel
  GrVNTValueProc[136]:=Unaligned(@GrVNTValue136);
  // (fading) not clipped
  GrVNTValueProc[131]:=Unaligned(@GrVNTValue130);
  // (fading) top-bottom clipped
  GrVNTValueProc[133]:=Unaligned(@GrVNTValue130);
  // (fading) left-right-top-bottom clipped
  GrVNTValueProc[135]:=Unaligned(@GrVNTValue134);
  // (fading) image has monochrome color channel
  GrVNTValueProc[137]:=Unaligned(@GrVNTValue136);

  {BlurRRB}
  // (constant) not clipped
  GrVNTValueProc[140]:=Unaligned(@GrVNTValue140);
  // (constant) top-bottom clipped
  GrVNTValueProc[142]:=Unaligned(@GrVNTValue140);
  // (constant) left-right-top-bottom clipped
  GrVNTValueProc[144]:=Unaligned(@GrVNTValue144);
  // (constant) image has monochrome color channel
  GrVNTValueProc[146]:=Unaligned(@GrVNTValue146);
  // (fading) not clipped
  GrVNTValueProc[141]:=Unaligned(@GrVNTValue140);
  // (fading) top-bottom clipped
  GrVNTValueProc[143]:=Unaligned(@GrVNTValue140);
  // (fading) left-right-top-bottom clipped
  GrVNTValueProc[145]:=Unaligned(@GrVNTValue144);
  // (fading) image has monochrome color channel
  GrVNTValueProc[147]:=Unaligned(@GrVNTValue146);

  {BlurRGR}
  // (constant) not clipped
  GrVNTValueProc[150]:=Unaligned(@GrVNTValue150);
  // (constant) top-bottom clipped
  GrVNTValueProc[152]:=Unaligned(@GrVNTValue150);
  // (constant) left-right-top-bottom clipped
  GrVNTValueProc[154]:=Unaligned(@GrVNTValue154);
  // (constant) image has monochrome color channel
  GrVNTValueProc[156]:=Unaligned(@GrVNTValue156);
  // (fading) not clipped
  GrVNTValueProc[151]:=Unaligned(@GrVNTValue150);
  // (fading) top-bottom clipped
  GrVNTValueProc[153]:=Unaligned(@GrVNTValue150);
  // (fading) left-right-top-bottom clipped
  GrVNTValueProc[155]:=Unaligned(@GrVNTValue154);
  // (fading) image has monochrome color channel
  GrVNTValueProc[157]:=Unaligned(@GrVNTValue156);

  {BlurGGB}
  // (constant) not clipped
  GrVNTValueProc[160]:=Unaligned(@GrVNTValue160);
  // (constant) top-bottom clipped
  GrVNTValueProc[162]:=Unaligned(@GrVNTValue160);
  // (constant) left-right-top-bottom clipped
  GrVNTValueProc[164]:=Unaligned(@GrVNTValue164);
  // (constant) image has monochrome color channel
  GrVNTValueProc[166]:=Unaligned(@GrVNTValue166);
  // (fading) not clipped
  GrVNTValueProc[161]:=Unaligned(@GrVNTValue160);
  // (fading) top-bottom clipped
  GrVNTValueProc[163]:=Unaligned(@GrVNTValue160);
  // (fading) left-right-top-bottom clipped
  GrVNTValueProc[165]:=Unaligned(@GrVNTValue164);
  // (fading) image has monochrome color channel
  GrVNTValueProc[167]:=Unaligned(@GrVNTValue166);

  {BlurRGG}
  // (constant) not clipped
  GrVNTValueProc[170]:=Unaligned(@GrVNTValue170);
  // (constant) top-bottom clipped
  GrVNTValueProc[172]:=Unaligned(@GrVNTValue170);
  // (constant) left-right-top-bottom clipped
  GrVNTValueProc[174]:=Unaligned(@GrVNTValue174);
  // (constant) image has monochrome color channel
  GrVNTValueProc[176]:=Unaligned(@GrVNTValue176);
  // (fading) not clipped
  GrVNTValueProc[171]:=Unaligned(@GrVNTValue170);
  // (fading) top-bottom clipped
  GrVNTValueProc[173]:=Unaligned(@GrVNTValue170);
  // (fading) left-right-top-bottom clipped
  GrVNTValueProc[175]:=Unaligned(@GrVNTValue174);
  // (fading) image has monochrome color channel
  GrVNTValueProc[177]:=Unaligned(@GrVNTValue176);

  {BlurBGB}
  // (constant) not clipped
  GrVNTValueProc[180]:=Unaligned(@GrVNTValue180);
  // (constant) top-bottom clipped
  GrVNTValueProc[182]:=Unaligned(@GrVNTValue180);
  // (constant) left-right-top-bottom clipped
  GrVNTValueProc[184]:=Unaligned(@GrVNTValue184);
  // (constant) image has monochrome color channel
  GrVNTValueProc[186]:=Unaligned(@GrVNTValue186);
  // (fading) not clipped
  GrVNTValueProc[181]:=Unaligned(@GrVNTValue180);
  // (fading) top-bottom clipped
  GrVNTValueProc[183]:=Unaligned(@GrVNTValue180);
  // (fading) left-right-top-bottom clipped
  GrVNTValueProc[185]:=Unaligned(@GrVNTValue184);
  // (fading) image has monochrome color channel
  GrVNTValueProc[187]:=Unaligned(@GrVNTValue186);

  {BlurRBB}
  // (constant) not clipped
  GrVNTValueProc[190]:=Unaligned(@GrVNTValue190);
  // (constant) top-bottom clipped
  GrVNTValueProc[192]:=Unaligned(@GrVNTValue190);
  // (constant) left-right-top-bottom clipped
  GrVNTValueProc[194]:=Unaligned(@GrVNTValue194);
  // (constant) image has monochrome color channel
  GrVNTValueProc[196]:=Unaligned(@GrVNTValue196);
  // (fading) not clipped
  GrVNTValueProc[191]:=Unaligned(@GrVNTValue190);
  // (fading) top-bottom clipped
  GrVNTValueProc[193]:=Unaligned(@GrVNTValue190);
  // (fading) left-right-top-bottom clipped
  GrVNTValueProc[195]:=Unaligned(@GrVNTValue194);
  // (fading) image has monochrome color channel
  GrVNTValueProc[197]:=Unaligned(@GrVNTValue196);

  {BlurRRR}
  // (constant) not clipped
  GrVNTValueProc[200]:=Unaligned(@GrVNTValue200);
  // (constant) top-bottom clipped
  GrVNTValueProc[202]:=Unaligned(@GrVNTValue200);
  // (constant) left-right-top-bottom clipped
  GrVNTValueProc[204]:=Unaligned(@GrVNTValue204);
  // (constant) image has monochrome color channel
  GrVNTValueProc[206]:=Unaligned(@GrVNTValue206);
  // (fading) not clipped
  GrVNTValueProc[201]:=Unaligned(@GrVNTValue200);
  // (fading) top-bottom clipped
  GrVNTValueProc[203]:=Unaligned(@GrVNTValue200);
  // (fading) left-right-top-bottom clipped
  GrVNTValueProc[205]:=Unaligned(@GrVNTValue204);
  // (fading) image has monochrome color channel
  GrVNTValueProc[207]:=Unaligned(@GrVNTValue206);

  {BlurGGG}
  // (constant) not clipped
  GrVNTValueProc[210]:=Unaligned(@GrVNTValue210);
  // (constant) top-bottom clipped
  GrVNTValueProc[212]:=Unaligned(@GrVNTValue210);
  // (constant) left-right-top-bottom clipped
  GrVNTValueProc[214]:=Unaligned(@GrVNTValue214);
  // (constant) image has monochrome color channel
  GrVNTValueProc[216]:=Unaligned(@GrVNTValue216);
  // (fading) not clipped
  GrVNTValueProc[211]:=Unaligned(@GrVNTValue210);
  // (fading) top-bottom clipped
  GrVNTValueProc[213]:=Unaligned(@GrVNTValue210);
  // (fading) left-right-top-bottom clipped
  GrVNTValueProc[215]:=Unaligned(@GrVNTValue214);
  // (fading) image has monochrome color channel
  GrVNTValueProc[217]:=Unaligned(@GrVNTValue216);

  {BlurBBB}
  // (constant) not clipped
  GrVNTValueProc[220]:=Unaligned(@GrVNTValue220);
  // (constant) top-bottom clipped
  GrVNTValueProc[222]:=Unaligned(@GrVNTValue220);
  // (constant) left-right-top-bottom clipped
  GrVNTValueProc[224]:=Unaligned(@GrVNTValue224);
  // (constant) image has monochrome color channel
  GrVNTValueProc[226]:=Unaligned(@GrVNTValue226);
  // (fading) not clipped
  GrVNTValueProc[221]:=Unaligned(@GrVNTValue220);
  // (fading) top-bottom clipped
  GrVNTValueProc[223]:=Unaligned(@GrVNTValue220);
  // (fading) left-right-top-bottom clipped
  GrVNTValueProc[225]:=Unaligned(@GrVNTValue224);
  // (fading) image has monochrome color channel
  GrVNTValueProc[227]:=Unaligned(@GrVNTValue226);

  {Contrast}
  // (constant) not clipped
  GrVNTValueProc[230]:=Unaligned(@GrVNTValue230);
  // (constant) top-bottom clipped
  GrVNTValueProc[232]:=Unaligned(@GrVNTValue230);
  // (constant) left-right-top-bottom clipped
  GrVNTValueProc[234]:=Unaligned(@GrVNTValue234);
  // (constant) image has monochrome color channel
  GrVNTValueProc[236]:=Unaligned(@GrVNTValue236);
  // (fading) not clipped
  GrVNTValueProc[231]:=Unaligned(@GrVNTValue230);
  // (fading) top-bottom clipped
  GrVNTValueProc[233]:=Unaligned(@GrVNTValue230);
  // (fading) left-right-top-bottom clipped
  GrVNTValueProc[235]:=Unaligned(@GrVNTValue234);
  // (fading) image has monochrome color channel
  GrVNTValueProc[237]:=Unaligned(@GrVNTValue236);

  {$endregion}

  {||scl_mul||<1: (SD - Scale Down)} {$region -fold}

  {Empty}
  GSDNTValueProc[009]:=Unaligned(@GSDNTValue009);

  {Monochrome}
  // (constant) not clipped
  GSDNTValueProc[000]:=Unaligned(@GSDNTValue000);
  // (constant) top-bottom clipped
  GSDNTValueProc[002]:=Unaligned(@GSDNTValue002);
  // (constant) left-right-top-bottom clipped
  GSDNTValueProc[004]:=Unaligned(@GSDNTValue004);
  // (constant) image has monochrome color channel
  GSDNTValueProc[006]:=Unaligned(@GSDNTValue006);
  // (fading) not clipped
  GSDNTValueProc[001]:=Unaligned(@GSDNTValue020);
  // (fading) top-bottom clipped
  GSDNTValueProc[003]:=Unaligned(@GSDNTValue022);
  // (fading) left-right-top-bottom clipped
  GSDNTValueProc[005]:=Unaligned(@GSDNTValue024);
  // (fading) image has monochrome color channel
  GSDNTValueProc[007]:=Unaligned(@GSDNTValue026);

  {Additive}
  // (constant) not clipped
  GSDNTValueProc[010]:=Unaligned(@GSDNTValue010);
  // (constant) top-bottom clipped
  GSDNTValueProc[012]:=Unaligned(@GSDNTValue012);
  // (constant) left-right-top-bottom clipped
  GSDNTValueProc[014]:=Unaligned(@GSDNTValue014);
  // (constant) image has monochrome color channel
  GSDNTValueProc[016]:=Unaligned(@GSDNTValue016);
  // (fading) not clipped
  GSDNTValueProc[011]:=Unaligned(@GSDNTValue010);
  // (fading) top-bottom clipped
  GSDNTValueProc[013]:=Unaligned(@GSDNTValue012);
  // (fading) left-right-top-bottom clipped
  GSDNTValueProc[015]:=Unaligned(@GSDNTValue014);
  // (fading) image has monochrome color channel
  GSDNTValueProc[017]:=Unaligned(@GSDNTValue016);

  {Alphablend}
  // (constant) not clipped
  GSDNTValueProc[020]:=Unaligned(@GSDNTValue020);
  // (constant) top-bottom clipped
  GSDNTValueProc[022]:=Unaligned(@GSDNTValue022);
  // (constant) left-right-top-bottom clipped
  GSDNTValueProc[024]:=Unaligned(@GSDNTValue024);
  // (constant) image has monochrome color channel
  GSDNTValueProc[026]:=Unaligned(@GSDNTValue026);
  // (fading) not clipped
  GSDNTValueProc[021]:=Unaligned(@GSDNTValue020);
  // (fading) top-bottom clipped
  GSDNTValueProc[023]:=Unaligned(@GSDNTValue022);
  // (fading) left-right-top-bottom clipped
  GSDNTValueProc[025]:=Unaligned(@GSDNTValue024);
  // (fading) image has monochrome color channel
  GSDNTValueProc[027]:=Unaligned(@GSDNTValue026);

  {Inverse}
  // (constant) not clipped
  GSDNTValueProc[030]:=Unaligned(@GSDNTValue030);
  // (constant) top-bottom clipped
  GSDNTValueProc[032]:=Unaligned(@GSDNTValue032);
  // (constant) left-right-top-bottom clipped
  GSDNTValueProc[034]:=Unaligned(@GSDNTValue034);
  // (constant) image has monochrome color channel
  GSDNTValueProc[036]:=Unaligned(@GSDNTValue036);
  // (fading) not clipped
  GSDNTValueProc[031]:=Unaligned(@GSDNTValue030);
  // (fading) top-bottom clipped
  GSDNTValueProc[033]:=Unaligned(@GSDNTValue032);
  // (fading) left-right-top-bottom clipped
  GSDNTValueProc[035]:=Unaligned(@GSDNTValue034);
  // (fading) image has monochrome color channel
  GSDNTValueProc[037]:=Unaligned(@GSDNTValue036);

  {Highlight}
  // (constant) not clipped
  GSDNTValueProc[040]:=Unaligned(@GSDNTValue040);
  // (constant) top-bottom clipped
  GSDNTValueProc[042]:=Unaligned(@GSDNTValue042);
  // (constant) left-right-top-bottom clipped
  GSDNTValueProc[044]:=Unaligned(@GSDNTValue044);
  // (constant) image has monochrome color channel
  GSDNTValueProc[046]:=Unaligned(@GSDNTValue046);
  // (fading) not clipped
  GSDNTValueProc[041]:=Unaligned(@GSDNTValue040);
  // (fading) top-bottom clipped
  GSDNTValueProc[043]:=Unaligned(@GSDNTValue042);
  // (fading) left-right-top-bottom clipped
  GSDNTValueProc[045]:=Unaligned(@GSDNTValue044);
  // (fading) image has monochrome color channel
  GSDNTValueProc[047]:=Unaligned(@GSDNTValue046);

  {Darken}
  // (constant) not clipped
  GSDNTValueProc[050]:=Unaligned(@GSDNTValue050);
  // (constant) top-bottom clipped
  GSDNTValueProc[052]:=Unaligned(@GSDNTValue052);
  // (constant) left-right-top-bottom clipped
  GSDNTValueProc[054]:=Unaligned(@GSDNTValue054);
  // (constant) image has monochrome color channel
  GSDNTValueProc[056]:=Unaligned(@GSDNTValue056);
  // (fading) not clipped
  GSDNTValueProc[051]:=Unaligned(@GSDNTValue050);
  // (fading) top-bottom clipped
  GSDNTValueProc[053]:=Unaligned(@GSDNTValue052);
  // (fading) left-right-top-bottom clipped
  GSDNTValueProc[055]:=Unaligned(@GSDNTValue054);
  // (fading) image has monochrome color channel
  GSDNTValueProc[057]:=Unaligned(@GSDNTValue056);

  {GrayscaleR}
  // (constant) not clipped
  GSDNTValueProc[060]:=Unaligned(@GSDNTValue060);
  // (constant) top-bottom clipped
  GSDNTValueProc[062]:=Unaligned(@GSDNTValue062);
  // (constant) left-right-top-bottom clipped
  GSDNTValueProc[064]:=Unaligned(@GSDNTValue064);
  // (constant) image has monochrome color channel
  GSDNTValueProc[066]:=Unaligned(@GSDNTValue066);
  // (fading) not clipped
  GSDNTValueProc[061]:=Unaligned(@GSDNTValue060);
  // (fading) top-bottom clipped
  GSDNTValueProc[063]:=Unaligned(@GSDNTValue062);
  // (fading) left-right-top-bottom clipped
  GSDNTValueProc[065]:=Unaligned(@GSDNTValue064);
  // (fading) image has monochrome color channel
  GSDNTValueProc[067]:=Unaligned(@GSDNTValue066);

  {GrayscaleG}
  // (constant) not clipped
  GSDNTValueProc[070]:=Unaligned(@GSDNTValue070);
  // (constant) top-bottom clipped
  GSDNTValueProc[072]:=Unaligned(@GSDNTValue072);
  // (constant) left-right-top-bottom clipped
  GSDNTValueProc[074]:=Unaligned(@GSDNTValue074);
  // (constant) image has monochrome color channel
  GSDNTValueProc[076]:=Unaligned(@GSDNTValue076);
  // (fading) not clipped
  GSDNTValueProc[071]:=Unaligned(@GSDNTValue070);
  // (fading) top-bottom clipped
  GSDNTValueProc[073]:=Unaligned(@GSDNTValue072);
  // (fading) left-right-top-bottom clipped
  GSDNTValueProc[075]:=Unaligned(@GSDNTValue074);
  // (fading) image has monochrome color channel
  GSDNTValueProc[077]:=Unaligned(@GSDNTValue076);

  {GrayscaleB}
  // (constant) not clipped
  GSDNTValueProc[080]:=Unaligned(@GSDNTValue080);
  // (constant) top-bottom clipped
  GSDNTValueProc[082]:=Unaligned(@GSDNTValue082);
  // (constant) left-right-top-bottom clipped
  GSDNTValueProc[084]:=Unaligned(@GSDNTValue084);
  // (constant) image has monochrome color channel
  GSDNTValueProc[086]:=Unaligned(@GSDNTValue086);
  // (fading) not clipped
  GSDNTValueProc[081]:=Unaligned(@GSDNTValue080);
  // (fading) top-bottom clipped
  GSDNTValueProc[083]:=Unaligned(@GSDNTValue082);
  // (fading) left-right-top-bottom clipped
  GSDNTValueProc[085]:=Unaligned(@GSDNTValue084);
  // (fading) image has monochrome color channel
  GSDNTValueProc[087]:=Unaligned(@GSDNTValue086);

  {Monochrome Noise}
  // (constant) not clipped
  GSDNTValueProc[090]:=Unaligned(@GSDNTValue090);
  // (constant) top-bottom clipped
  GSDNTValueProc[092]:=Unaligned(@GSDNTValue092);
  // (constant) left-right-top-bottom clipped
  GSDNTValueProc[094]:=Unaligned(@GSDNTValue094);
  // (constant) image has monochrome color channel
  GSDNTValueProc[096]:=Unaligned(@GSDNTValue096);
  // (fading) not clipped
  GSDNTValueProc[091]:=Unaligned(@GSDNTValue090);
  // (fading) top-bottom clipped
  GSDNTValueProc[093]:=Unaligned(@GSDNTValue092);
  // (fading) left-right-top-bottom clipped
  GSDNTValueProc[095]:=Unaligned(@GSDNTValue094);
  // (fading) image has monochrome color channel
  GSDNTValueProc[097]:=Unaligned(@GSDNTValue096);

  {ColorizeR}
  // (constant) not clipped
  GSDNTValueProc[100]:=Unaligned(@GSDNTValue100);
  // (constant) top-bottom clipped
  GSDNTValueProc[102]:=Unaligned(@GSDNTValue102);
  // (constant) left-right-top-bottom clipped
  GSDNTValueProc[104]:=Unaligned(@GSDNTValue104);
  // (constant) image has monochrome color channel
  GSDNTValueProc[106]:=Unaligned(@GSDNTValue106);
  // (fading) not clipped
  GSDNTValueProc[101]:=Unaligned(@GSDNTValue100);
  // (fading) top-bottom clipped
  GSDNTValueProc[103]:=Unaligned(@GSDNTValue102);
  // (fading) left-right-top-bottom clipped
  GSDNTValueProc[105]:=Unaligned(@GSDNTValue104);
  // (fading) image has monochrome color channel
  GSDNTValueProc[107]:=Unaligned(@GSDNTValue106);

  {ColorizeG}
  // (constant) not clipped
  GSDNTValueProc[110]:=Unaligned(@GSDNTValue110);
  // (constant) top-bottom clipped
  GSDNTValueProc[112]:=Unaligned(@GSDNTValue112);
  // (constant) left-right-top-bottom clipped
  GSDNTValueProc[114]:=Unaligned(@GSDNTValue114);
  // (constant) image has monochrome color channel
  GSDNTValueProc[116]:=Unaligned(@GSDNTValue116);
  // (fading) not clipped
  GSDNTValueProc[111]:=Unaligned(@GSDNTValue110);
  // (fading) top-bottom clipped
  GSDNTValueProc[113]:=Unaligned(@GSDNTValue112);
  // (fading) left-right-top-bottom clipped
  GSDNTValueProc[115]:=Unaligned(@GSDNTValue114);
  // (fading) image has monochrome color channel
  GSDNTValueProc[117]:=Unaligned(@GSDNTValue116);

  {ColorizeB}
  // (constant) not clipped
  GSDNTValueProc[120]:=Unaligned(@GSDNTValue120);
  // (constant) top-bottom clipped
  GSDNTValueProc[122]:=Unaligned(@GSDNTValue122);
  // (constant) left-right-top-bottom clipped
  GSDNTValueProc[124]:=Unaligned(@GSDNTValue124);
  // (constant) image has monochrome color channel
  GSDNTValueProc[126]:=Unaligned(@GSDNTValue126);
  // (fading) not clipped
  GSDNTValueProc[121]:=Unaligned(@GSDNTValue120);
  // (fading) top-bottom clipped
  GSDNTValueProc[123]:=Unaligned(@GSDNTValue122);
  // (fading) left-right-top-bottom clipped
  GSDNTValueProc[125]:=Unaligned(@GSDNTValue124);
  // (fading) image has monochrome color channel
  GSDNTValueProc[127]:=Unaligned(@GSDNTValue126);

  {BlurRGB}
  // (constant) not clipped
  GSDNTValueProc[130]:=Unaligned(@GSDNTValue130);
  // (constant) top-bottom clipped
  GSDNTValueProc[132]:=Unaligned(@GSDNTValue132);
  // (constant) left-right-top-bottom clipped
  GSDNTValueProc[134]:=Unaligned(@GSDNTValue134);
  // (constant) image has monochrome color channel
  GSDNTValueProc[136]:=Unaligned(@GSDNTValue136);
  // (fading) not clipped
  GSDNTValueProc[131]:=Unaligned(@GSDNTValue130);
  // (fading) top-bottom clipped
  GSDNTValueProc[133]:=Unaligned(@GSDNTValue132);
  // (fading) left-right-top-bottom clipped
  GSDNTValueProc[135]:=Unaligned(@GSDNTValue134);
  // (fading) image has monochrome color channel
  GSDNTValueProc[137]:=Unaligned(@GSDNTValue136);

  {BlurRRB}
  // (constant) not clipped
  GSDNTValueProc[140]:=Unaligned(@GSDNTValue140);
  // (constant) top-bottom clipped
  GSDNTValueProc[142]:=Unaligned(@GSDNTValue142);
  // (constant) left-right-top-bottom clipped
  GSDNTValueProc[144]:=Unaligned(@GSDNTValue144);
  // (constant) image has monochrome color channel
  GSDNTValueProc[146]:=Unaligned(@GSDNTValue146);
  // (fading) not clipped
  GSDNTValueProc[141]:=Unaligned(@GSDNTValue140);
  // (fading) top-bottom clipped
  GSDNTValueProc[143]:=Unaligned(@GSDNTValue142);
  // (fading) left-right-top-bottom clipped
  GSDNTValueProc[145]:=Unaligned(@GSDNTValue144);
  // (fading) image has monochrome color channel
  GSDNTValueProc[147]:=Unaligned(@GSDNTValue146);

  {BlurRGR}
  // (constant) not clipped
  GSDNTValueProc[150]:=Unaligned(@GSDNTValue150);
  // (constant) top-bottom clipped
  GSDNTValueProc[152]:=Unaligned(@GSDNTValue152);
  // (constant) left-right-top-bottom clipped
  GSDNTValueProc[154]:=Unaligned(@GSDNTValue154);
  // (constant) image has monochrome color channel
  GSDNTValueProc[156]:=Unaligned(@GSDNTValue156);
  // (fading) not clipped
  GSDNTValueProc[151]:=Unaligned(@GSDNTValue150);
  // (fading) top-bottom clipped
  GSDNTValueProc[153]:=Unaligned(@GSDNTValue152);
  // (fading) left-right-top-bottom clipped
  GSDNTValueProc[155]:=Unaligned(@GSDNTValue154);
  // (fading) image has monochrome color channel
  GSDNTValueProc[157]:=Unaligned(@GSDNTValue156);

  {BlurGGB}
  // (constant) not clipped
  GSDNTValueProc[160]:=Unaligned(@GSDNTValue160);
  // (constant) top-bottom clipped
  GSDNTValueProc[162]:=Unaligned(@GSDNTValue162);
  // (constant) left-right-top-bottom clipped
  GSDNTValueProc[164]:=Unaligned(@GSDNTValue164);
  // (constant) image has monochrome color channel
  GSDNTValueProc[166]:=Unaligned(@GSDNTValue166);
  // (fading) not clipped
  GSDNTValueProc[161]:=Unaligned(@GSDNTValue160);
  // (fading) top-bottom clipped
  GSDNTValueProc[163]:=Unaligned(@GSDNTValue162);
  // (fading) left-right-top-bottom clipped
  GSDNTValueProc[165]:=Unaligned(@GSDNTValue164);
  // (fading) image has monochrome color channel
  GSDNTValueProc[167]:=Unaligned(@GSDNTValue166);

  {BlurRGG}
  // (constant) not clipped
  GSDNTValueProc[170]:=Unaligned(@GSDNTValue170);
  // (constant) top-bottom clipped
  GSDNTValueProc[172]:=Unaligned(@GSDNTValue172);
  // (constant) left-right-top-bottom clipped
  GSDNTValueProc[174]:=Unaligned(@GSDNTValue174);
  // (constant) image has monochrome color channel
  GSDNTValueProc[176]:=Unaligned(@GSDNTValue176);
  // (fading) not clipped
  GSDNTValueProc[171]:=Unaligned(@GSDNTValue170);
  // (fading) top-bottom clipped
  GSDNTValueProc[173]:=Unaligned(@GSDNTValue172);
  // (fading) left-right-top-bottom clipped
  GSDNTValueProc[175]:=Unaligned(@GSDNTValue174);
  // (fading) image has monochrome color channel
  GSDNTValueProc[177]:=Unaligned(@GSDNTValue176);

  {BlurBGB}
  // (constant) not clipped
  GSDNTValueProc[180]:=Unaligned(@GSDNTValue180);
  // (constant) top-bottom clipped
  GSDNTValueProc[182]:=Unaligned(@GSDNTValue182);
  // (constant) left-right-top-bottom clipped
  GSDNTValueProc[184]:=Unaligned(@GSDNTValue184);
  // (constant) image has monochrome color channel
  GSDNTValueProc[186]:=Unaligned(@GSDNTValue186);
  // (fading) not clipped
  GSDNTValueProc[181]:=Unaligned(@GSDNTValue180);
  // (fading) top-bottom clipped
  GSDNTValueProc[183]:=Unaligned(@GSDNTValue182);
  // (fading) left-right-top-bottom clipped
  GSDNTValueProc[185]:=Unaligned(@GSDNTValue184);
  // (fading) image has monochrome color channel
  GSDNTValueProc[187]:=Unaligned(@GSDNTValue186);

  {BlurRBB}
  // (constant) not clipped
  GSDNTValueProc[190]:=Unaligned(@GSDNTValue190);
  // (constant) top-bottom clipped
  GSDNTValueProc[192]:=Unaligned(@GSDNTValue192);
  // (constant) left-right-top-bottom clipped
  GSDNTValueProc[194]:=Unaligned(@GSDNTValue194);
  // (constant) image has monochrome color channel
  GSDNTValueProc[196]:=Unaligned(@GSDNTValue196);
  // (fading) not clipped
  GSDNTValueProc[191]:=Unaligned(@GSDNTValue190);
  // (fading) top-bottom clipped
  GSDNTValueProc[193]:=Unaligned(@GSDNTValue192);
  // (fading) left-right-top-bottom clipped
  GSDNTValueProc[195]:=Unaligned(@GSDNTValue194);
  // (fading) image has monochrome color channel
  GSDNTValueProc[197]:=Unaligned(@GSDNTValue196);

  {BlurRRR}
  // (constant) not clipped
  GSDNTValueProc[200]:=Unaligned(@GSDNTValue200);
  // (constant) top-bottom clipped
  GSDNTValueProc[202]:=Unaligned(@GSDNTValue202);
  // (constant) left-right-top-bottom clipped
  GSDNTValueProc[204]:=Unaligned(@GSDNTValue204);
  // (constant) image has monochrome color channel
  GSDNTValueProc[206]:=Unaligned(@GSDNTValue206);
  // (fading) not clipped
  GSDNTValueProc[201]:=Unaligned(@GSDNTValue200);
  // (fading) top-bottom clipped
  GSDNTValueProc[203]:=Unaligned(@GSDNTValue202);
  // (fading) left-right-top-bottom clipped
  GSDNTValueProc[205]:=Unaligned(@GSDNTValue204);
  // (fading) image has monochrome color channel
  GSDNTValueProc[207]:=Unaligned(@GSDNTValue206);

  {BlurGGG}
  // (constant) not clipped
  GSDNTValueProc[210]:=Unaligned(@GSDNTValue210);
  // (constant) top-bottom clipped
  GSDNTValueProc[212]:=Unaligned(@GSDNTValue212);
  // (constant) left-right-top-bottom clipped
  GSDNTValueProc[214]:=Unaligned(@GSDNTValue214);
  // (constant) image has monochrome color channel
  GSDNTValueProc[216]:=Unaligned(@GSDNTValue216);
  // (fading) not clipped
  GSDNTValueProc[211]:=Unaligned(@GSDNTValue210);
  // (fading) top-bottom clipped
  GSDNTValueProc[213]:=Unaligned(@GSDNTValue212);
  // (fading) left-right-top-bottom clipped
  GSDNTValueProc[215]:=Unaligned(@GSDNTValue214);
  // (fading) image has monochrome color channel
  GSDNTValueProc[217]:=Unaligned(@GSDNTValue216);

  {BlurBBB}
  // (constant) not clipped
  GSDNTValueProc[220]:=Unaligned(@GSDNTValue220);
  // (constant) top-bottom clipped
  GSDNTValueProc[222]:=Unaligned(@GSDNTValue222);
  // (constant) left-right-top-bottom clipped
  GSDNTValueProc[224]:=Unaligned(@GSDNTValue224);
  // (constant) image has monochrome color channel
  GSDNTValueProc[226]:=Unaligned(@GSDNTValue226);
  // (fading) not clipped
  GSDNTValueProc[221]:=Unaligned(@GSDNTValue220);
  // (fading) top-bottom clipped
  GSDNTValueProc[223]:=Unaligned(@GSDNTValue222);
  // (fading) left-right-top-bottom clipped
  GSDNTValueProc[225]:=Unaligned(@GSDNTValue224);
  // (fading) image has monochrome color channel
  GSDNTValueProc[227]:=Unaligned(@GSDNTValue226);

  {Contrast}
  // (constant) not clipped
  GSDNTValueProc[230]:=Unaligned(@GSDNTValue230);
  // (constant) top-bottom clipped
  GSDNTValueProc[232]:=Unaligned(@GSDNTValue232);
  // (constant) left-right-top-bottom clipped
  GSDNTValueProc[234]:=Unaligned(@GSDNTValue234);
  // (constant) image has monochrome color channel
  GSDNTValueProc[236]:=Unaligned(@GSDNTValue236);
  // (fading) not clipped
  GSDNTValueProc[231]:=Unaligned(@GSDNTValue230);
  // (fading) top-bottom clipped
  GSDNTValueProc[233]:=Unaligned(@GSDNTValue232);
  // (fading) left-right-top-bottom clipped
  GSDNTValueProc[235]:=Unaligned(@GSDNTValue234);
  // (fading) image has monochrome color channel
  GSDNTValueProc[237]:=Unaligned(@GSDNTValue236);

  {$endregion}

  {||scl_mul||>1: (SU - Scale Up  )} {$region -fold}

  {Empty}
  GSUNTValueProc[009]:=Unaligned(@GSUNTValue009);

  {Monochrome}
  // (constant) not clipped
  GSUNTValueProc[000]:=Unaligned(@GSUNTValue000);
  // (constant) top-bottom clipped
  GSUNTValueProc[002]:=Unaligned(@GSUNTValue002);
  // (constant) left-right-top-bottom clipped
  GSUNTValueProc[004]:=Unaligned(@GSUNTValue004);
  // (constant) image has monochrome color channel
  GSUNTValueProc[006]:=Unaligned(@GSUNTValue006);
  // (fading) not clipped
  GSUNTValueProc[001]:=Unaligned(@GSUNTValue020);
  // (fading) top-bottom clipped
  GSUNTValueProc[003]:=Unaligned(@GSUNTValue022);
  // (fading) left-right-top-bottom clipped
  GSUNTValueProc[005]:=Unaligned(@GSUNTValue024);
  // (fading) image has monochrome color channel
  GSUNTValueProc[007]:=Unaligned(@GSUNTValue026);

  {Additive}
  // (constant) not clipped
  GSUNTValueProc[010]:=Unaligned(@GSUNTValue010);
  // (constant) top-bottom clipped
  GSUNTValueProc[012]:=Unaligned(@GSUNTValue012);
  // (constant) left-right-top-bottom clipped
  GSUNTValueProc[014]:=Unaligned(@GSUNTValue014);
  // (constant) image has monochrome color channel
  GSUNTValueProc[016]:=Unaligned(@GSUNTValue016);
  // (fading) not clipped
  GSUNTValueProc[011]:=Unaligned(@GSUNTValue010);
  // (fading) top-bottom clipped
  GSUNTValueProc[013]:=Unaligned(@GSUNTValue012);
  // (fading) left-right-top-bottom clipped
  GSUNTValueProc[015]:=Unaligned(@GSUNTValue014);
  // (fading) image has monochrome color channel
  GSUNTValueProc[017]:=Unaligned(@GSUNTValue016);

  {Alphablend}
  // (constant) not clipped
  GSUNTValueProc[020]:=Unaligned(@GSUNTValue020);
  // (constant) top-bottom clipped
  GSUNTValueProc[022]:=Unaligned(@GSUNTValue022);
  // (constant) left-right-top-bottom clipped
  GSUNTValueProc[024]:=Unaligned(@GSUNTValue024);
  // (constant) image has monochrome color channel
  GSUNTValueProc[026]:=Unaligned(@GSUNTValue026);
  // (fading) not clipped
  GSUNTValueProc[021]:=Unaligned(@GSUNTValue020);
  // (fading) top-bottom clipped
  GSUNTValueProc[023]:=Unaligned(@GSUNTValue022);
  // (fading) left-right-top-bottom clipped
  GSUNTValueProc[025]:=Unaligned(@GSUNTValue024);
  // (fading) image has monochrome color channel
  GSUNTValueProc[027]:=Unaligned(@GSUNTValue026);

  {Inverse}
  // (constant) not clipped
  GSUNTValueProc[030]:=Unaligned(@GSUNTValue030);
  // (constant) top-bottom clipped
  GSUNTValueProc[032]:=Unaligned(@GSUNTValue032);
  // (constant) left-right-top-bottom clipped
  GSUNTValueProc[034]:=Unaligned(@GSUNTValue034);
  // (constant) image has monochrome color channel
  GSUNTValueProc[036]:=Unaligned(@GSUNTValue036);
  // (fading) not clipped
  GSUNTValueProc[031]:=Unaligned(@GSUNTValue030);
  // (fading) top-bottom clipped
  GSUNTValueProc[033]:=Unaligned(@GSUNTValue032);
  // (fading) left-right-top-bottom clipped
  GSUNTValueProc[035]:=Unaligned(@GSUNTValue034);
  // (fading) image has monochrome color channel
  GSUNTValueProc[037]:=Unaligned(@GSUNTValue036);

  {Highlight}
  // (constant) not clipped
  GSUNTValueProc[040]:=Unaligned(@GSUNTValue040);
  // (constant) top-bottom clipped
  GSUNTValueProc[042]:=Unaligned(@GSUNTValue042);
  // (constant) left-right-top-bottom clipped
  GSUNTValueProc[044]:=Unaligned(@GSUNTValue044);
  // (constant) image has monochrome color channel
  GSUNTValueProc[046]:=Unaligned(@GSUNTValue046);
  // (fading) not clipped
  GSUNTValueProc[041]:=Unaligned(@GSUNTValue040);
  // (fading) top-bottom clipped
  GSUNTValueProc[043]:=Unaligned(@GSUNTValue042);
  // (fading) left-right-top-bottom clipped
  GSUNTValueProc[045]:=Unaligned(@GSUNTValue044);
  // (fading) image has monochrome color channel
  GSUNTValueProc[047]:=Unaligned(@GSUNTValue046);

  {Darken}
  // (constant) not clipped
  GSUNTValueProc[050]:=Unaligned(@GSUNTValue050);
  // (constant) top-bottom clipped
  GSUNTValueProc[052]:=Unaligned(@GSUNTValue052);
  // (constant) left-right-top-bottom clipped
  GSUNTValueProc[054]:=Unaligned(@GSUNTValue054);
  // (constant) image has monochrome color channel
  GSUNTValueProc[056]:=Unaligned(@GSUNTValue056);
  // (fading) not clipped
  GSUNTValueProc[051]:=Unaligned(@GSUNTValue050);
  // (fading) top-bottom clipped
  GSUNTValueProc[053]:=Unaligned(@GSUNTValue052);
  // (fading) left-right-top-bottom clipped
  GSUNTValueProc[055]:=Unaligned(@GSUNTValue054);
  // (fading) image has monochrome color channel
  GSUNTValueProc[057]:=Unaligned(@GSUNTValue056);

  {GrayscaleR}
  // (constant) not clipped
  GSUNTValueProc[060]:=Unaligned(@GSUNTValue060);
  // (constant) top-bottom clipped
  GSUNTValueProc[062]:=Unaligned(@GSUNTValue062);
  // (constant) left-right-top-bottom clipped
  GSUNTValueProc[064]:=Unaligned(@GSUNTValue064);
  // (constant) image has monochrome color channel
  GSUNTValueProc[066]:=Unaligned(@GSUNTValue066);
  // (fading) not clipped
  GSUNTValueProc[061]:=Unaligned(@GSUNTValue060);
  // (fading) top-bottom clipped
  GSUNTValueProc[063]:=Unaligned(@GSUNTValue062);
  // (fading) left-right-top-bottom clipped
  GSUNTValueProc[065]:=Unaligned(@GSUNTValue064);
  // (fading) image has monochrome color channel
  GSUNTValueProc[067]:=Unaligned(@GSUNTValue066);

  {GrayscaleG}
  // (constant) not clipped
  GSUNTValueProc[070]:=Unaligned(@GSUNTValue070);
  // (constant) top-bottom clipped
  GSUNTValueProc[072]:=Unaligned(@GSUNTValue072);
  // (constant) left-right-top-bottom clipped
  GSUNTValueProc[074]:=Unaligned(@GSUNTValue074);
  // (constant) image has monochrome color channel
  GSUNTValueProc[076]:=Unaligned(@GSUNTValue076);
  // (fading) not clipped
  GSUNTValueProc[071]:=Unaligned(@GSUNTValue070);
  // (fading) top-bottom clipped
  GSUNTValueProc[073]:=Unaligned(@GSUNTValue072);
  // (fading) left-right-top-bottom clipped
  GSUNTValueProc[075]:=Unaligned(@GSUNTValue074);
  // (fading) image has monochrome color channel
  GSUNTValueProc[077]:=Unaligned(@GSUNTValue076);

  {GrayscaleB}
  // (constant) not clipped
  GSUNTValueProc[080]:=Unaligned(@GSUNTValue080);
  // (constant) top-bottom clipped
  GSUNTValueProc[082]:=Unaligned(@GSUNTValue082);
  // (constant) left-right-top-bottom clipped
  GSUNTValueProc[084]:=Unaligned(@GSUNTValue084);
  // (constant) image has monochrome color channel
  GSUNTValueProc[086]:=Unaligned(@GSUNTValue086);
  // (fading) not clipped
  GSUNTValueProc[081]:=Unaligned(@GSUNTValue080);
  // (fading) top-bottom clipped
  GSUNTValueProc[083]:=Unaligned(@GSUNTValue082);
  // (fading) left-right-top-bottom clipped
  GSUNTValueProc[085]:=Unaligned(@GSUNTValue084);
  // (fading) image has monochrome color channel
  GSUNTValueProc[087]:=Unaligned(@GSUNTValue086);

  {Monochrome Noise}
  // (constant) not clipped
  GSUNTValueProc[090]:=Unaligned(@GSUNTValue090);
  // (constant) top-bottom clipped
  GSUNTValueProc[092]:=Unaligned(@GSUNTValue092);
  // (constant) left-right-top-bottom clipped
  GSUNTValueProc[094]:=Unaligned(@GSUNTValue094);
  // (constant) image has monochrome color channel
  GSUNTValueProc[096]:=Unaligned(@GSUNTValue096);
  // (fading) not clipped
  GSUNTValueProc[091]:=Unaligned(@GSUNTValue090);
  // (fading) top-bottom clipped
  GSUNTValueProc[093]:=Unaligned(@GSUNTValue092);
  // (fading) left-right-top-bottom clipped
  GSUNTValueProc[095]:=Unaligned(@GSUNTValue094);
  // (fading) image has monochrome color channel
  GSUNTValueProc[097]:=Unaligned(@GSUNTValue096);

  {ColorizeR}
  // (constant) not clipped
  GSUNTValueProc[100]:=Unaligned(@GSUNTValue100);
  // (constant) top-bottom clipped
  GSUNTValueProc[102]:=Unaligned(@GSUNTValue102);
  // (constant) left-right-top-bottom clipped
  GSUNTValueProc[104]:=Unaligned(@GSUNTValue104);
  // (constant) image has monochrome color channel
  GSUNTValueProc[106]:=Unaligned(@GSUNTValue106);
  // (fading) not clipped
  GSUNTValueProc[101]:=Unaligned(@GSUNTValue100);
  // (fading) top-bottom clipped
  GSUNTValueProc[103]:=Unaligned(@GSUNTValue102);
  // (fading) left-right-top-bottom clipped
  GSUNTValueProc[105]:=Unaligned(@GSUNTValue104);
  // (fading) image has monochrome color channel
  GSUNTValueProc[107]:=Unaligned(@GSUNTValue106);

  {ColorizeG}
  // (constant) not clipped
  GSUNTValueProc[110]:=Unaligned(@GSUNTValue110);
  // (constant) top-bottom clipped
  GSUNTValueProc[112]:=Unaligned(@GSUNTValue112);
  // (constant) left-right-top-bottom clipped
  GSUNTValueProc[114]:=Unaligned(@GSUNTValue114);
  // (constant) image has monochrome color channel
  GSUNTValueProc[116]:=Unaligned(@GSUNTValue116);
  // (fading) not clipped
  GSUNTValueProc[111]:=Unaligned(@GSUNTValue110);
  // (fading) top-bottom clipped
  GSUNTValueProc[113]:=Unaligned(@GSUNTValue112);
  // (fading) left-right-top-bottom clipped
  GSUNTValueProc[115]:=Unaligned(@GSUNTValue114);
  // (fading) image has monochrome color channel
  GSUNTValueProc[117]:=Unaligned(@GSUNTValue116);

  {ColorizeB}
  // (constant) not clipped
  GSUNTValueProc[120]:=Unaligned(@GSUNTValue120);
  // (constant) top-bottom clipped
  GSUNTValueProc[122]:=Unaligned(@GSUNTValue122);
  // (constant) left-right-top-bottom clipped
  GSUNTValueProc[124]:=Unaligned(@GSUNTValue124);
  // (constant) image has monochrome color channel
  GSUNTValueProc[126]:=Unaligned(@GSUNTValue126);
  // (fading) not clipped
  GSUNTValueProc[121]:=Unaligned(@GSUNTValue120);
  // (fading) top-bottom clipped
  GSUNTValueProc[123]:=Unaligned(@GSUNTValue122);
  // (fading) left-right-top-bottom clipped
  GSUNTValueProc[125]:=Unaligned(@GSUNTValue124);
  // (fading) image has monochrome color channel
  GSUNTValueProc[127]:=Unaligned(@GSUNTValue126);

  {BlurRGB}
  // (constant) not clipped
  GSUNTValueProc[130]:=Unaligned(@GSUNTValue130);
  // (constant) top-bottom clipped
  GSUNTValueProc[132]:=Unaligned(@GSUNTValue132);
  // (constant) left-right-top-bottom clipped
  GSUNTValueProc[134]:=Unaligned(@GSUNTValue134);
  // (constant) image has monochrome color channel
  GSUNTValueProc[136]:=Unaligned(@GSUNTValue136);
  // (fading) not clipped
  GSUNTValueProc[131]:=Unaligned(@GSUNTValue130);
  // (fading) top-bottom clipped
  GSUNTValueProc[133]:=Unaligned(@GSUNTValue132);
  // (fading) left-right-top-bottom clipped
  GSUNTValueProc[135]:=Unaligned(@GSUNTValue134);
  // (fading) image has monochrome color channel
  GSUNTValueProc[137]:=Unaligned(@GSUNTValue136);

  {BlurRRB}
  // (constant) not clipped
  GSUNTValueProc[140]:=Unaligned(@GSUNTValue140);
  // (constant) top-bottom clipped
  GSUNTValueProc[142]:=Unaligned(@GSUNTValue142);
  // (constant) left-right-top-bottom clipped
  GSUNTValueProc[144]:=Unaligned(@GSUNTValue144);
  // (constant) image has monochrome color channel
  GSUNTValueProc[146]:=Unaligned(@GSUNTValue146);
  // (fading) not clipped
  GSUNTValueProc[141]:=Unaligned(@GSUNTValue140);
  // (fading) top-bottom clipped
  GSUNTValueProc[143]:=Unaligned(@GSUNTValue142);
  // (fading) left-right-top-bottom clipped
  GSUNTValueProc[145]:=Unaligned(@GSUNTValue144);
  // (fading) image has monochrome color channel
  GSUNTValueProc[147]:=Unaligned(@GSUNTValue146);

  {BlurRGR}
  // (constant) not clipped
  GSUNTValueProc[150]:=Unaligned(@GSUNTValue150);
  // (constant) top-bottom clipped
  GSUNTValueProc[152]:=Unaligned(@GSUNTValue152);
  // (constant) left-right-top-bottom clipped
  GSUNTValueProc[154]:=Unaligned(@GSUNTValue154);
  // (constant) image has monochrome color channel
  GSUNTValueProc[156]:=Unaligned(@GSUNTValue156);
  // (fading) not clipped
  GSUNTValueProc[151]:=Unaligned(@GSUNTValue150);
  // (fading) top-bottom clipped
  GSUNTValueProc[153]:=Unaligned(@GSUNTValue152);
  // (fading) left-right-top-bottom clipped
  GSUNTValueProc[155]:=Unaligned(@GSUNTValue154);
  // (fading) image has monochrome color channel
  GSUNTValueProc[157]:=Unaligned(@GSUNTValue156);

  {BlurGGB}
  // (constant) not clipped
  GSUNTValueProc[160]:=Unaligned(@GSUNTValue160);
  // (constant) top-bottom clipped
  GSUNTValueProc[162]:=Unaligned(@GSUNTValue162);
  // (constant) left-right-top-bottom clipped
  GSUNTValueProc[164]:=Unaligned(@GSUNTValue164);
  // (constant) image has monochrome color channel
  GSUNTValueProc[166]:=Unaligned(@GSUNTValue166);
  // (fading) not clipped
  GSUNTValueProc[161]:=Unaligned(@GSUNTValue160);
  // (fading) top-bottom clipped
  GSUNTValueProc[163]:=Unaligned(@GSUNTValue162);
  // (fading) left-right-top-bottom clipped
  GSUNTValueProc[165]:=Unaligned(@GSUNTValue164);
  // (fading) image has monochrome color channel
  GSUNTValueProc[167]:=Unaligned(@GSUNTValue166);

  {BlurRGG}
  // (constant) not clipped
  GSUNTValueProc[170]:=Unaligned(@GSUNTValue170);
  // (constant) top-bottom clipped
  GSUNTValueProc[172]:=Unaligned(@GSUNTValue172);
  // (constant) left-right-top-bottom clipped
  GSUNTValueProc[174]:=Unaligned(@GSUNTValue174);
  // (constant) image has monochrome color channel
  GSUNTValueProc[176]:=Unaligned(@GSUNTValue176);
  // (fading) not clipped
  GSUNTValueProc[171]:=Unaligned(@GSUNTValue170);
  // (fading) top-bottom clipped
  GSUNTValueProc[173]:=Unaligned(@GSUNTValue172);
  // (fading) left-right-top-bottom clipped
  GSUNTValueProc[175]:=Unaligned(@GSUNTValue174);
  // (fading) image has monochrome color channel
  GSUNTValueProc[177]:=Unaligned(@GSUNTValue176);

  {BlurBGB}
  // (constant) not clipped
  GSUNTValueProc[180]:=Unaligned(@GSUNTValue180);
  // (constant) top-bottom clipped
  GSUNTValueProc[182]:=Unaligned(@GSUNTValue182);
  // (constant) left-right-top-bottom clipped
  GSUNTValueProc[184]:=Unaligned(@GSUNTValue184);
  // (constant) image has monochrome color channel
  GSUNTValueProc[186]:=Unaligned(@GSUNTValue186);
  // (fading) not clipped
  GSUNTValueProc[181]:=Unaligned(@GSUNTValue180);
  // (fading) top-bottom clipped
  GSUNTValueProc[183]:=Unaligned(@GSUNTValue182);
  // (fading) left-right-top-bottom clipped
  GSUNTValueProc[185]:=Unaligned(@GSUNTValue184);
  // (fading) image has monochrome color channel
  GSUNTValueProc[187]:=Unaligned(@GSUNTValue186);

  {BlurRBB}
  // (constant) not clipped
  GSUNTValueProc[190]:=Unaligned(@GSUNTValue190);
  // (constant) top-bottom clipped
  GSUNTValueProc[192]:=Unaligned(@GSUNTValue192);
  // (constant) left-right-top-bottom clipped
  GSUNTValueProc[194]:=Unaligned(@GSUNTValue194);
  // (constant) image has monochrome color channel
  GSUNTValueProc[196]:=Unaligned(@GSUNTValue196);
  // (fading) not clipped
  GSUNTValueProc[191]:=Unaligned(@GSUNTValue190);
  // (fading) top-bottom clipped
  GSUNTValueProc[193]:=Unaligned(@GSUNTValue192);
  // (fading) left-right-top-bottom clipped
  GSUNTValueProc[195]:=Unaligned(@GSUNTValue194);
  // (fading) image has monochrome color channel
  GSUNTValueProc[197]:=Unaligned(@GSUNTValue196);

  {BlurRRR}
  // (constant) not clipped
  GSUNTValueProc[200]:=Unaligned(@GSUNTValue200);
  // (constant) top-bottom clipped
  GSUNTValueProc[202]:=Unaligned(@GSUNTValue202);
  // (constant) left-right-top-bottom clipped
  GSUNTValueProc[204]:=Unaligned(@GSUNTValue204);
  // (constant) image has monochrome color channel
  GSUNTValueProc[206]:=Unaligned(@GSUNTValue206);
  // (fading) not clipped
  GSUNTValueProc[201]:=Unaligned(@GSUNTValue200);
  // (fading) top-bottom clipped
  GSUNTValueProc[203]:=Unaligned(@GSUNTValue202);
  // (fading) left-right-top-bottom clipped
  GSUNTValueProc[205]:=Unaligned(@GSUNTValue204);
  // (fading) image has monochrome color channel
  GSUNTValueProc[207]:=Unaligned(@GSUNTValue206);

  {BlurGGG}
  // (constant) not clipped
  GSUNTValueProc[210]:=Unaligned(@GSUNTValue210);
  // (constant) top-bottom clipped
  GSUNTValueProc[212]:=Unaligned(@GSUNTValue212);
  // (constant) left-right-top-bottom clipped
  GSUNTValueProc[214]:=Unaligned(@GSUNTValue214);
  // (constant) image has monochrome color channel
  GSUNTValueProc[216]:=Unaligned(@GSUNTValue216);
  // (fading) not clipped
  GSUNTValueProc[211]:=Unaligned(@GSUNTValue210);
  // (fading) top-bottom clipped
  GSUNTValueProc[213]:=Unaligned(@GSUNTValue212);
  // (fading) left-right-top-bottom clipped
  GSUNTValueProc[215]:=Unaligned(@GSUNTValue214);
  // (fading) image has monochrome color channel
  GSUNTValueProc[217]:=Unaligned(@GSUNTValue216);

  {BlurBBB}
  // (constant) not clipped
  GSUNTValueProc[220]:=Unaligned(@GSUNTValue220);
  // (constant) top-bottom clipped
  GSUNTValueProc[222]:=Unaligned(@GSUNTValue222);
  // (constant) left-right-top-bottom clipped
  GSUNTValueProc[224]:=Unaligned(@GSUNTValue224);
  // (constant) image has monochrome color channel
  GSUNTValueProc[226]:=Unaligned(@GSUNTValue226);
  // (fading) not clipped
  GSUNTValueProc[221]:=Unaligned(@GSUNTValue220);
  // (fading) top-bottom clipped
  GSUNTValueProc[223]:=Unaligned(@GSUNTValue222);
  // (fading) left-right-top-bottom clipped
  GSUNTValueProc[225]:=Unaligned(@GSUNTValue224);
  // (fading) image has monochrome color channel
  GSUNTValueProc[227]:=Unaligned(@GSUNTValue226);

  {Contrast}
  // (constant) not clipped
  GSUNTValueProc[230]:=Unaligned(@GSUNTValue230);
  // (constant) top-bottom clipped
  GSUNTValueProc[232]:=Unaligned(@GSUNTValue232);
  // (constant) left-right-top-bottom clipped
  GSUNTValueProc[234]:=Unaligned(@GSUNTValue234);
  // (constant) image has monochrome color channel
  GSUNTValueProc[236]:=Unaligned(@GSUNTValue236);
  // (fading) not clipped
  GSUNTValueProc[231]:=Unaligned(@GSUNTValue230);
  // (fading) top-bottom clipped
  GSUNTValueProc[233]:=Unaligned(@GSUNTValue232);
  // (fading) left-right-top-bottom clipped
  GSUNTValueProc[235]:=Unaligned(@GSUNTValue234);
  // (fading) image has monochrome color channel
  GSUNTValueProc[237]:=Unaligned(@GSUNTValue236);

  {$endregion}

  {$endregion}

  // PT - partly transparent pixels:

  {Color} {$region -fold}

  {||scl_mul||=1:                  } {$region -fold}

  {Empty}
  GrVPTColorProc[009]:=Unaligned(@GrVPTColor009);

  {Color of Curent Layer}
  // (constant) not clipped
  GrVPTColorProc[000]:=Unaligned(@GrVPTColor020);
  // (constant) top-bottom clipped
  GrVPTColorProc[002]:=Unaligned(@GrVPTColor020);
  // (constant) left-right-top-bottom clipped
  GrVPTColorProc[004]:=Unaligned(@GrVPTColor024);
  // (fading) not clipped
  GrVPTColorProc[001]:=Unaligned(@GrVPTColor020);
  // (fading) top-bottom clipped
  GrVPTColorProc[003]:=Unaligned(@GrVPTColor020);
  // (fading) left-right-top-bottom clipped
  GrVPTColorProc[005]:=Unaligned(@GrVPTColor024);

  {Color of Curent Layer(Additive)}
  // (constant) not clipped
  GrVPTColorProc[010]:=Unaligned(@GrVPTColor010);
  // (constant) top-bottom clipped
  GrVPTColorProc[012]:=Unaligned(@GrVPTColor010);
  // (constant) left-right-top-bottom clipped
  GrVPTColorProc[014]:=Unaligned(@GrVPTColor014);
  // (fading) not clipped
  GrVPTColorProc[011]:=Unaligned(@GrVPTColor010);
  // (fading) top-bottom clipped
  GrVPTColorProc[013]:=Unaligned(@GrVPTColor010);
  // (fading) left-right-top-bottom clipped
  GrVPTColorProc[015]:=Unaligned(@GrVPTColor014);

  {Color of Curent Layer(Alphablend)}
  // (constant) not clipped
  GrVPTColorProc[020]:=Unaligned(@GrVPTColor020);
  // (constant) top-bottom clipped
  GrVPTColorProc[022]:=Unaligned(@GrVPTColor020);
  // (constant) left-right-top-bottom clipped
  GrVPTColorProc[024]:=Unaligned(@GrVPTColor024);
  // (fading) not clipped
  GrVPTColorProc[021]:=Unaligned(@GrVPTColor020);
  // (fading) top-bottom clipped
  GrVPTColorProc[023]:=Unaligned(@GrVPTColor020);
  // (fading) left-right-top-bottom clipped
  GrVPTColorProc[025]:=Unaligned(@GrVPTColor024);

  {$endregion}

  {||scl_mul||<1: (SD - Scale Down)} {$region -fold}

  {Empty}
  GSDPTColorProc[009]:=Unaligned(@GSDPTColor009);

  {Color of Curent Layer}
  // (constant) not clipped
  GSDPTColorProc[000]:=Unaligned(@GSDPTColor020);
  // (constant) top-bottom clipped
  GSDPTColorProc[002]:=Unaligned(@GSDPTColor022);
  // (constant) left-right-top-bottom clipped
  GSDPTColorProc[004]:=Unaligned(@GSDPTColor024);
  // (fading) not clipped
  GSDPTColorProc[001]:=Unaligned(@GSDPTColor020);
  // (fading) top-bottom clipped
  GSDPTColorProc[003]:=Unaligned(@GSDPTColor022);
  // (fading) left-right-top-bottom clipped
  GSDPTColorProc[005]:=Unaligned(@GSDPTColor024);

  {Color of Curent Layer(Additive)}
  // (constant) not clipped
  GSDPTColorProc[010]:=Unaligned(@GSDPTColor010);
  // (constant) top-bottom clipped
  GSDPTColorProc[012]:=Unaligned(@GSDPTColor012);
  // (constant) left-right-top-bottom clipped
  GSDPTColorProc[014]:=Unaligned(@GSDPTColor014);
  // (fading) not clipped
  GSDPTColorProc[011]:=Unaligned(@GSDPTColor010);
  // (fading) top-bottom clipped
  GSDPTColorProc[013]:=Unaligned(@GSDPTColor012);
  // (fading) left-right-top-bottom clipped
  GSDPTColorProc[015]:=Unaligned(@GSDPTColor014);

  {Color of Curent Layer(Alphablend)}
  // (constant) not clipped
  GSDPTColorProc[020]:=Unaligned(@GSDPTColor020);
  // (constant) top-bottom clipped
  GSDPTColorProc[022]:=Unaligned(@GSDPTColor022);
  // (constant) left-right-top-bottom clipped
  GSDPTColorProc[024]:=Unaligned(@GSDPTColor024);
  // (fading) not clipped
  GSDPTColorProc[021]:=Unaligned(@GSDPTColor020);
  // (fading) top-bottom clipped
  GSDPTColorProc[023]:=Unaligned(@GSDPTColor022);
  // (fading) left-right-top-bottom clipped
  GSDPTColorProc[025]:=Unaligned(@GSDPTColor024);

  {$endregion}

  {||scl_mul||>1: (SU - Scale Up  )} {$region -fold}

  {Empty}
  GSUPTColorProc[009]:=Unaligned(@GSUPTColor009);

  {Color of Curent Layer}
  // (constant) not clipped
  GSUPTColorProc[000]:=Unaligned(@GSUPTColor020);
  // (constant) top-bottom clipped
  GSUPTColorProc[002]:=Unaligned(@GSUPTColor022);
  // (constant) left-right-top-bottom clipped
  GSUPTColorProc[004]:=Unaligned(@GSUPTColor024);
  // (fading) not clipped
  GSUPTColorProc[001]:=Unaligned(@GSUPTColor020);
  // (fading) top-bottom clipped
  GSUPTColorProc[003]:=Unaligned(@GSUPTColor022);
  // (fading) left-right-top-bottom clipped
  GSUPTColorProc[005]:=Unaligned(@GSUPTColor024);

  {Color of Curent Layer(Additive)}
  // (constant) not clipped
  GSUPTColorProc[010]:=Unaligned(@GSUPTColor010);
  // (constant) top-bottom clipped
  GSUPTColorProc[012]:=Unaligned(@GSUPTColor012);
  // (constant) left-right-top-bottom clipped
  GSUPTColorProc[014]:=Unaligned(@GSUPTColor014);
  // (fading) not clipped
  GSUPTColorProc[011]:=Unaligned(@GSUPTColor010);
  // (fading) top-bottom clipped
  GSUPTColorProc[013]:=Unaligned(@GSUPTColor012);
  // (fading) left-right-top-bottom clipped
  GSUPTColorProc[015]:=Unaligned(@GSUPTColor014);

  {Color of Curent Layer(Alphablend)}
  // (constant) not clipped
  GSUPTColorProc[020]:=Unaligned(@GSUPTColor020);
  // (constant) top-bottom clipped
  GSUPTColorProc[022]:=Unaligned(@GSUPTColor022);
  // (constant) left-right-top-bottom clipped
  GSUPTColorProc[024]:=Unaligned(@GSUPTColor024);
  // (fading) not clipped
  GSUPTColorProc[021]:=Unaligned(@GSUPTColor020);
  // (fading) top-bottom clipped
  GSUPTColorProc[023]:=Unaligned(@GSUPTColor022);
  // (fading) left-right-top-bottom clipped
  GSUPTColorProc[025]:=Unaligned(@GSUPTColor024);

  {$endregion}

  {$endregion}

  {Value} {$region -fold}

  {||scl_mul||=1:                  } {$region -fold}

  {Empty}
  GrVPTValueProc[009]:=Unaligned(@GrVPTValue009);

  {Monochrome}
  // (constant) not clipped
  GrVPTValueProc[000]:=Unaligned(@GrVPTValue000);
  // (constant) top-bottom clipped
  GrVPTValueProc[002]:=Unaligned(@GrVPTValue000);
  // (constant) left-right-top-bottom clipped
  GrVPTValueProc[004]:=Unaligned(@GrVPTValue004);
  // (fading) not clipped
  GrVPTValueProc[001]:=Unaligned(@GrVPTValue020);
  // (fading) top-bottom clipped
  GrVPTValueProc[003]:=Unaligned(@GrVPTValue020);
  // (fading) left-right-top-bottom clipped
  GrVPTValueProc[005]:=Unaligned(@GrVPTValue024);

  {Additive}
  // (constant) not clipped
  GrVPTValueProc[010]:=Unaligned(@GrVPTValue010);
  // (constant) top-bottom clipped
  GrVPTValueProc[012]:=Unaligned(@GrVPTValue010);
  // (constant) left-right-top-bottom clipped
  GrVPTValueProc[014]:=Unaligned(@GrVPTValue014);
  // (fading) not clipped
  GrVPTValueProc[011]:=Unaligned(@GrVPTValue010);
  // (fading) top-bottom clipped
  GrVPTValueProc[013]:=Unaligned(@GrVPTValue010);
  // (fading) left-right-top-bottom clipped
  GrVPTValueProc[015]:=Unaligned(@GrVPTValue014);

  {Alphablend}
  // (constant) not clipped
  GrVPTValueProc[020]:=Unaligned(@GrVPTValue020);
  // (constant) top-bottom clipped
  GrVPTValueProc[022]:=Unaligned(@GrVPTValue020);
  // (constant) left-right-top-bottom clipped
  GrVPTValueProc[024]:=Unaligned(@GrVPTValue024);
  // (fading) not clipped
  GrVPTValueProc[021]:=Unaligned(@GrVPTValue020);
  // (fading) top-bottom clipped
  GrVPTValueProc[023]:=Unaligned(@GrVPTValue020);
  // (fading) left-right-top-bottom clipped
  GrVPTValueProc[025]:=Unaligned(@GrVPTValue024);

  {Inverse}
  // (constant) not clipped
  GrVPTValueProc[030]:=Unaligned(@GrVPTValue030);
  // (constant) top-bottom clipped
  GrVPTValueProc[032]:=Unaligned(@GrVPTValue030);
  // (constant) left-right-top-bottom clipped
  GrVPTValueProc[034]:=Unaligned(@GrVPTValue034);
  // (fading) not clipped
  GrVPTValueProc[031]:=Unaligned(@GrVPTValue030);
  // (fading) top-bottom clipped
  GrVPTValueProc[033]:=Unaligned(@GrVPTValue030);
  // (fading) left-right-top-bottom clipped
  GrVPTValueProc[035]:=Unaligned(@GrVPTValue034);

  {Highlighted}
  // (constant) not clipped
  GrVPTValueProc[040]:=Unaligned(@GrVPTValue040);
  // (constant) top-bottom clipped
  GrVPTValueProc[042]:=Unaligned(@GrVPTValue040);
  // (constant) left-right-top-bottom clipped
  GrVPTValueProc[044]:=Unaligned(@GrVPTValue044);
  // (fading) not clipped
  GrVPTValueProc[041]:=Unaligned(@GrVPTValue040);
  // (fading) top-bottom clipped
  GrVPTValueProc[043]:=Unaligned(@GrVPTValue040);
  // (fading) left-right-top-bottom clipped
  GrVPTValueProc[045]:=Unaligned(@GrVPTValue044);

  {Darkened}
  // (constant) not clipped
  GrVPTValueProc[050]:=Unaligned(@GrVPTValue050);
  // (constant) top-bottom clipped
  GrVPTValueProc[052]:=Unaligned(@GrVPTValue050);
  // (constant) left-right-top-bottom clipped
  GrVPTValueProc[054]:=Unaligned(@GrVPTValue054);
  // (fading) not clipped
  GrVPTValueProc[051]:=Unaligned(@GrVPTValue050);
  // (fading) top-bottom clipped
  GrVPTValueProc[053]:=Unaligned(@GrVPTValue050);
  // (fading) left-right-top-bottom clipped
  GrVPTValueProc[055]:=Unaligned(@GrVPTValue054);

  {GrayscaleR}
  // (constant) not clipped
  GrVPTValueProc[060]:=Unaligned(@GrVPTValue060);
  // (constant) top-bottom clipped
  GrVPTValueProc[062]:=Unaligned(@GrVPTValue060);
  // (constant) left-right-top-bottom clipped
  GrVPTValueProc[064]:=Unaligned(@GrVPTValue064);
  // (fading) not clipped
  GrVPTValueProc[061]:=Unaligned(@GrVPTValue060);
  // (fading) top-bottom clipped
  GrVPTValueProc[063]:=Unaligned(@GrVPTValue060);
  // (fading) left-right-top-bottom clipped
  GrVPTValueProc[065]:=Unaligned(@GrVPTValue064);

  {GrayscaleG}
  // (constant) not clipped
  GrVPTValueProc[070]:=Unaligned(@GrVPTValue070);
  // (constant) top-bottom clipped
  GrVPTValueProc[072]:=Unaligned(@GrVPTValue070);
  // (constant) left-right-top-bottom clipped
  GrVPTValueProc[074]:=Unaligned(@GrVPTValue074);
  // (fading) not clipped
  GrVPTValueProc[071]:=Unaligned(@GrVPTValue070);
  // (fading) top-bottom clipped
  GrVPTValueProc[073]:=Unaligned(@GrVPTValue070);
  // (fading) left-right-top-bottom clipped
  GrVPTValueProc[075]:=Unaligned(@GrVPTValue074);

  {GrayscaleB}
  // (constant) not clipped
  GrVPTValueProc[080]:=Unaligned(@GrVPTValue080);
  // (constant) top-bottom clipped
  GrVPTValueProc[082]:=Unaligned(@GrVPTValue080);
  // (constant) left-right-top-bottom clipped
  GrVPTValueProc[084]:=Unaligned(@GrVPTValue084);
  // (fading) not clipped
  GrVPTValueProc[081]:=Unaligned(@GrVPTValue080);
  // (fading) top-bottom clipped
  GrVPTValueProc[083]:=Unaligned(@GrVPTValue080);
  // (fading) left-right-top-bottom clipped
  GrVPTValueProc[085]:=Unaligned(@GrVPTValue084);

  {Monochrome Noise}
  // (constant) not clipped
  GrVPTValueProc[090]:=Unaligned(@GrVPTValue090);
  // (constant) top-bottom clipped
  GrVPTValueProc[092]:=Unaligned(@GrVPTValue090);
  // (constant) left-right-top-bottom clipped
  GrVPTValueProc[094]:=Unaligned(@GrVPTValue094);
  // (fading) not clipped
  GrVPTValueProc[091]:=Unaligned(@GrVPTValue090);
  // (fading) top-bottom clipped
  GrVPTValueProc[093]:=Unaligned(@GrVPTValue090);
  // (fading) left-right-top-bottom clipped
  GrVPTValueProc[095]:=Unaligned(@GrVPTValue094);

  {ColorizeR}
  // (constant) not clipped
  GrVPTValueProc[100]:=Unaligned(@GrVPTValue100);
  // (constant) top-bottom clipped
  GrVPTValueProc[102]:=Unaligned(@GrVPTValue100);
  // (constant) left-right-top-bottom clipped
  GrVPTValueProc[104]:=Unaligned(@GrVPTValue104);
  // (fading) not clipped
  GrVPTValueProc[101]:=Unaligned(@GrVPTValue100);
  // (fading) top-bottom clipped
  GrVPTValueProc[103]:=Unaligned(@GrVPTValue100);
  // (fading) left-right-top-bottom clipped
  GrVPTValueProc[105]:=Unaligned(@GrVPTValue104);

  {ColorizeG}
  // (constant) not clipped
  GrVPTValueProc[110]:=Unaligned(@GrVPTValue110);
  // (constant) top-bottom clipped
  GrVPTValueProc[112]:=Unaligned(@GrVPTValue110);
  // (constant) left-right-top-bottom clipped
  GrVPTValueProc[114]:=Unaligned(@GrVPTValue114);
  // (fading) not clipped
  GrVPTValueProc[111]:=Unaligned(@GrVPTValue110);
  // (fading) top-bottom clipped
  GrVPTValueProc[113]:=Unaligned(@GrVPTValue110);
  // (fading) left-right-top-bottom clipped
  GrVPTValueProc[115]:=Unaligned(@GrVPTValue114);

  {ColorizeB}
  // (constant) not clipped
  GrVPTValueProc[120]:=Unaligned(@GrVPTValue120);
  // (constant) top-bottom clipped
  GrVPTValueProc[122]:=Unaligned(@GrVPTValue120);
  // (constant) left-right-top-bottom clipped
  GrVPTValueProc[124]:=Unaligned(@GrVPTValue124);
  // (fading) not clipped
  GrVPTValueProc[121]:=Unaligned(@GrVPTValue120);
  // (fading) top-bottom clipped
  GrVPTValueProc[123]:=Unaligned(@GrVPTValue120);
  // (fading) left-right-top-bottom clipped
  GrVPTValueProc[125]:=Unaligned(@GrVPTValue124);

  {BlurRGB}
  // (constant) not clipped
  GrVPTValueProc[130]:=Unaligned(@GrVPTValue130);
  // (constant) top-bottom clipped
  GrVPTValueProc[132]:=Unaligned(@GrVPTValue130);
  // (constant) left-right-top-bottom clipped
  GrVPTValueProc[134]:=Unaligned(@GrVPTValue134);
  // (fading) not clipped
  GrVPTValueProc[131]:=Unaligned(@GrVPTValue130);
  // (fading) top-bottom clipped
  GrVPTValueProc[133]:=Unaligned(@GrVPTValue130);
  // (fading) left-right-top-bottom clipped
  GrVPTValueProc[135]:=Unaligned(@GrVPTValue134);

  {BlurRRB}
  // (constant) not clipped
  GrVPTValueProc[140]:=Unaligned(@GrVPTValue140);
  // (constant) top-bottom clipped
  GrVPTValueProc[142]:=Unaligned(@GrVPTValue140);
  // (constant) left-right-top-bottom clipped
  GrVPTValueProc[144]:=Unaligned(@GrVPTValue144);
  // (fading) not clipped
  GrVPTValueProc[141]:=Unaligned(@GrVPTValue140);
  // (fading) top-bottom clipped
  GrVPTValueProc[143]:=Unaligned(@GrVPTValue140);
  // (fading) left-right-top-bottom clipped
  GrVPTValueProc[145]:=Unaligned(@GrVPTValue144);

  {BlurRGR}
  // (constant) not clipped
  GrVPTValueProc[150]:=Unaligned(@GrVPTValue150);
  // (constant) top-bottom clipped
  GrVPTValueProc[152]:=Unaligned(@GrVPTValue150);
  // (constant) left-right-top-bottom clipped
  GrVPTValueProc[154]:=Unaligned(@GrVPTValue154);
  // (fading) not clipped
  GrVPTValueProc[151]:=Unaligned(@GrVPTValue150);
  // (fading) top-bottom clipped
  GrVPTValueProc[153]:=Unaligned(@GrVPTValue150);
  // (fading) left-right-top-bottom clipped
  GrVPTValueProc[155]:=Unaligned(@GrVPTValue154);

  {BlurGGB}
  // (constant) not clipped
  GrVPTValueProc[160]:=Unaligned(@GrVPTValue160);
  // (constant) top-bottom clipped
  GrVPTValueProc[162]:=Unaligned(@GrVPTValue160);
  // (constant) left-right-top-bottom clipped
  GrVPTValueProc[164]:=Unaligned(@GrVPTValue164);
  // (fading) not clipped
  GrVPTValueProc[161]:=Unaligned(@GrVPTValue160);
  // (fading) top-bottom clipped
  GrVPTValueProc[163]:=Unaligned(@GrVPTValue160);
  // (fading) left-right-top-bottom clipped
  GrVPTValueProc[165]:=Unaligned(@GrVPTValue164);

  {BlurRGG}
  // (constant) not clipped
  GrVPTValueProc[170]:=Unaligned(@GrVPTValue170);
  // (constant) top-bottom clipped
  GrVPTValueProc[172]:=Unaligned(@GrVPTValue170);
  // (constant) left-right-top-bottom clipped
  GrVPTValueProc[174]:=Unaligned(@GrVPTValue174);
  // (fading) not clipped
  GrVPTValueProc[171]:=Unaligned(@GrVPTValue170);
  // (fading) top-bottom clipped
  GrVPTValueProc[173]:=Unaligned(@GrVPTValue170);
  // (fading) left-right-top-bottom clipped
  GrVPTValueProc[175]:=Unaligned(@GrVPTValue174);

  {BlurBGB}
  // (constant) not clipped
  GrVPTValueProc[180]:=Unaligned(@GrVPTValue180);
  // (constant) top-bottom clipped
  GrVPTValueProc[182]:=Unaligned(@GrVPTValue180);
  // (constant) left-right-top-bottom clipped
  GrVPTValueProc[184]:=Unaligned(@GrVPTValue184);
  // (fading) not clipped
  GrVPTValueProc[181]:=Unaligned(@GrVPTValue180);
  // (fading) top-bottom clipped
  GrVPTValueProc[183]:=Unaligned(@GrVPTValue180);
  // (fading) left-right-top-bottom clipped
  GrVPTValueProc[185]:=Unaligned(@GrVPTValue184);

  {BlurRBB}
  // (constant) not clipped
  GrVPTValueProc[190]:=Unaligned(@GrVPTValue190);
  // (constant) top-bottom clipped
  GrVPTValueProc[192]:=Unaligned(@GrVPTValue190);
  // (constant) left-right-top-bottom clipped
  GrVPTValueProc[194]:=Unaligned(@GrVPTValue194);
  // (fading) not clipped
  GrVPTValueProc[191]:=Unaligned(@GrVPTValue190);
  // (fading) top-bottom clipped
  GrVPTValueProc[193]:=Unaligned(@GrVPTValue190);
  // (fading) left-right-top-bottom clipped
  GrVPTValueProc[195]:=Unaligned(@GrVPTValue194);

  {BlurRRR}
  // (constant) not clipped
  GrVPTValueProc[200]:=Unaligned(@GrVPTValue200);
  // (constant) top-bottom clipped
  GrVPTValueProc[202]:=Unaligned(@GrVPTValue200);
  // (constant) left-right-top-bottom clipped
  GrVPTValueProc[204]:=Unaligned(@GrVPTValue204);
  // (fading) not clipped
  GrVPTValueProc[201]:=Unaligned(@GrVPTValue200);
  // (fading) top-bottom clipped
  GrVPTValueProc[203]:=Unaligned(@GrVPTValue200);
  // (fading) left-right-top-bottom clipped
  GrVPTValueProc[205]:=Unaligned(@GrVPTValue204);

  {BlurGGG}
  // (constant) not clipped
  GrVPTValueProc[210]:=Unaligned(@GrVPTValue210);
  // (constant) top-bottom clipped
  GrVPTValueProc[212]:=Unaligned(@GrVPTValue210);
  // (constant) left-right-top-bottom clipped
  GrVPTValueProc[214]:=Unaligned(@GrVPTValue214);
  // (fading) not clipped
  GrVPTValueProc[211]:=Unaligned(@GrVPTValue210);
  // (fading) top-bottom clipped
  GrVPTValueProc[213]:=Unaligned(@GrVPTValue210);
  // (fading) left-right-top-bottom clipped
  GrVPTValueProc[215]:=Unaligned(@GrVPTValue214);

  {BlurBBB}
  // (constant) not clipped
  GrVPTValueProc[220]:=Unaligned(@GrVPTValue220);
  // (constant) top-bottom clipped
  GrVPTValueProc[222]:=Unaligned(@GrVPTValue220);
  // (constant) left-right-top-bottom clipped
  GrVPTValueProc[224]:=Unaligned(@GrVPTValue224);
  // (fading) not clipped
  GrVPTValueProc[221]:=Unaligned(@GrVPTValue220);
  // (fading) top-bottom clipped
  GrVPTValueProc[223]:=Unaligned(@GrVPTValue220);
  // (fading) left-right-top-bottom clipped
  GrVPTValueProc[225]:=Unaligned(@GrVPTValue224);

  {Contrast}
  // (constant) not clipped
  GrVPTValueProc[230]:=Unaligned(@GrVPTValue230);
  // (constant) top-bottom clipped
  GrVPTValueProc[232]:=Unaligned(@GrVPTValue230);
  // (constant) left-right-top-bottom clipped
  GrVPTValueProc[234]:=Unaligned(@GrVPTValue234);
  // (fading) not clipped
  GrVPTValueProc[231]:=Unaligned(@GrVPTValue230);
  // (fading) top-bottom clipped
  GrVPTValueProc[233]:=Unaligned(@GrVPTValue230);
  // (fading) left-right-top-bottom clipped
  GrVPTValueProc[235]:=Unaligned(@GrVPTValue234);

  {$endregion}

  {||scl_mul||<1: (SD - Scale Down)} {$region -fold}

  {Empty}
  GSDPTValueProc[009]:=Unaligned(@GSDPTValue009);

  {Monochrome}
  // (constant) not clipped
  GSDPTValueProc[000]:=Unaligned(@GSDPTValue000);
  // (constant) top-bottom clipped
  GSDPTValueProc[002]:=Unaligned(@GSDPTValue002);
  // (constant) left-right-top-bottom clipped
  GSDPTValueProc[004]:=Unaligned(@GSDPTValue004);
  // (fading) not clipped
  GSDPTValueProc[001]:=Unaligned(@GSDPTValue020);
  // (fading) top-bottom clipped
  GSDPTValueProc[003]:=Unaligned(@GSDPTValue022);
  // (fading) left-right-top-bottom clipped
  GSDPTValueProc[005]:=Unaligned(@GSDPTValue024);

  {Additive}
  // (constant) not clipped
  GSDPTValueProc[010]:=Unaligned(@GSDPTValue010);
  // (constant) top-bottom clipped
  GSDPTValueProc[012]:=Unaligned(@GSDPTValue012);
  // (constant) left-right-top-bottom clipped
  GSDPTValueProc[014]:=Unaligned(@GSDPTValue014);
  // (fading) not clipped
  GSDPTValueProc[011]:=Unaligned(@GSDPTValue010);
  // (fading) top-bottom clipped
  GSDPTValueProc[013]:=Unaligned(@GSDPTValue012);
  // (fading) left-right-top-bottom clipped
  GSDPTValueProc[015]:=Unaligned(@GSDPTValue014);

  {Alphablend}
  // (constant) not clipped
  GSDPTValueProc[020]:=Unaligned(@GSDPTValue020);
  // (constant) top-bottom clipped
  GSDPTValueProc[022]:=Unaligned(@GSDPTValue022);
  // (constant) left-right-top-bottom clipped
  GSDPTValueProc[024]:=Unaligned(@GSDPTValue024);
  // (fading) not clipped
  GSDPTValueProc[021]:=Unaligned(@GSDPTValue020);
  // (fading) top-bottom clipped
  GSDPTValueProc[023]:=Unaligned(@GSDPTValue022);
  // (fading) left-right-top-bottom clipped
  GSDPTValueProc[025]:=Unaligned(@GSDPTValue024);

  {Inverse}
  // (constant) not clipped
  GSDPTValueProc[030]:=Unaligned(@GSDPTValue030);
  // (constant) top-bottom clipped
  GSDPTValueProc[032]:=Unaligned(@GSDPTValue032);
  // (constant) left-right-top-bottom clipped
  GSDPTValueProc[034]:=Unaligned(@GSDPTValue034);
  // (fading) not clipped
  GSDPTValueProc[031]:=Unaligned(@GSDPTValue030);
  // (fading) top-bottom clipped
  GSDPTValueProc[033]:=Unaligned(@GSDPTValue032);
  // (fading) left-right-top-bottom clipped
  GSDPTValueProc[035]:=Unaligned(@GSDPTValue034);

  {Highlighted}
  // (constant) not clipped
  GSDPTValueProc[040]:=Unaligned(@GSDPTValue040);
  // (constant) top-bottom clipped
  GSDPTValueProc[042]:=Unaligned(@GSDPTValue042);
  // (constant) left-right-top-bottom clipped
  GSDPTValueProc[044]:=Unaligned(@GSDPTValue044);
  // (fading) not clipped
  GSDPTValueProc[041]:=Unaligned(@GSDPTValue040);
  // (fading) top-bottom clipped
  GSDPTValueProc[043]:=Unaligned(@GSDPTValue042);
  // (fading) left-right-top-bottom clipped
  GSDPTValueProc[045]:=Unaligned(@GSDPTValue044);

  {Darkened}
  // (constant) not clipped
  GSDPTValueProc[050]:=Unaligned(@GSDPTValue050);
  // (constant) top-bottom clipped
  GSDPTValueProc[052]:=Unaligned(@GSDPTValue052);
  // (constant) left-right-top-bottom clipped
  GSDPTValueProc[054]:=Unaligned(@GSDPTValue054);
  // (fading) not clipped
  GSDPTValueProc[051]:=Unaligned(@GSDPTValue050);
  // (fading) top-bottom clipped
  GSDPTValueProc[053]:=Unaligned(@GSDPTValue052);
  // (fading) left-right-top-bottom clipped
  GSDPTValueProc[055]:=Unaligned(@GSDPTValue054);

  {GrayscaleR}
  // (constant) not clipped
  GSDPTValueProc[060]:=Unaligned(@GSDPTValue060);
  // (constant) top-bottom clipped
  GSDPTValueProc[062]:=Unaligned(@GSDPTValue062);
  // (constant) left-right-top-bottom clipped
  GSDPTValueProc[064]:=Unaligned(@GSDPTValue064);
  // (fading) not clipped
  GSDPTValueProc[061]:=Unaligned(@GSDPTValue060);
  // (fading) top-bottom clipped
  GSDPTValueProc[063]:=Unaligned(@GSDPTValue062);
  // (fading) left-right-top-bottom clipped
  GSDPTValueProc[065]:=Unaligned(@GSDPTValue064);

  {GrayscaleG}
  // (constant) not clipped
  GSDPTValueProc[070]:=Unaligned(@GSDPTValue070);
  // (constant) top-bottom clipped
  GSDPTValueProc[072]:=Unaligned(@GSDPTValue072);
  // (constant) left-right-top-bottom clipped
  GSDPTValueProc[074]:=Unaligned(@GSDPTValue074);
  // (fading) not clipped
  GSDPTValueProc[071]:=Unaligned(@GSDPTValue070);
  // (fading) top-bottom clipped
  GSDPTValueProc[073]:=Unaligned(@GSDPTValue072);
  // (fading) left-right-top-bottom clipped
  GSDPTValueProc[075]:=Unaligned(@GSDPTValue074);

  {GrayscaleB}
  // (constant) not clipped
  GSDPTValueProc[080]:=Unaligned(@GSDPTValue080);
  // (constant) top-bottom clipped
  GSDPTValueProc[082]:=Unaligned(@GSDPTValue082);
  // (constant) left-right-top-bottom clipped
  GSDPTValueProc[084]:=Unaligned(@GSDPTValue084);
  // (fading) not clipped
  GSDPTValueProc[081]:=Unaligned(@GSDPTValue080);
  // (fading) top-bottom clipped
  GSDPTValueProc[083]:=Unaligned(@GSDPTValue082);
  // (fading) left-right-top-bottom clipped
  GSDPTValueProc[085]:=Unaligned(@GSDPTValue084);

  {Monochrome Noise}
  // (constant) not clipped
  GSDPTValueProc[090]:=Unaligned(@GSDPTValue090);
  // (constant) top-bottom clipped
  GSDPTValueProc[092]:=Unaligned(@GSDPTValue092);
  // (constant) left-right-top-bottom clipped
  GSDPTValueProc[094]:=Unaligned(@GSDPTValue094);
  // (fading) not clipped
  GSDPTValueProc[091]:=Unaligned(@GSDPTValue090);
  // (fading) top-bottom clipped
  GSDPTValueProc[093]:=Unaligned(@GSDPTValue092);
  // (fading) left-right-top-bottom clipped
  GSDPTValueProc[095]:=Unaligned(@GSDPTValue094);

  {ColorizeR}
  // (constant) not clipped
  GSDPTValueProc[100]:=Unaligned(@GSDPTValue100);
  // (constant) top-bottom clipped
  GSDPTValueProc[102]:=Unaligned(@GSDPTValue102);
  // (constant) left-right-top-bottom clipped
  GSDPTValueProc[104]:=Unaligned(@GSDPTValue104);
  // (fading) not clipped
  GSDPTValueProc[101]:=Unaligned(@GSDPTValue100);
  // (fading) top-bottom clipped
  GSDPTValueProc[103]:=Unaligned(@GSDPTValue102);
  // (fading) left-right-top-bottom clipped
  GSDPTValueProc[105]:=Unaligned(@GSDPTValue104);

  {ColorizeG}
  // (constant) not clipped
  GSDPTValueProc[110]:=Unaligned(@GSDPTValue110);
  // (constant) top-bottom clipped
  GSDPTValueProc[112]:=Unaligned(@GSDPTValue112);
  // (constant) left-right-top-bottom clipped
  GSDPTValueProc[114]:=Unaligned(@GSDPTValue114);
  // (fading) not clipped
  GSDPTValueProc[111]:=Unaligned(@GSDPTValue110);
  // (fading) top-bottom clipped
  GSDPTValueProc[113]:=Unaligned(@GSDPTValue112);
  // (fading) left-right-top-bottom clipped
  GSDPTValueProc[115]:=Unaligned(@GSDPTValue114);

  {ColorizeB}
  // (constant) not clipped
  GSDPTValueProc[120]:=Unaligned(@GSDPTValue120);
  // (constant) top-bottom clipped
  GSDPTValueProc[122]:=Unaligned(@GSDPTValue122);
  // (constant) left-right-top-bottom clipped
  GSDPTValueProc[124]:=Unaligned(@GSDPTValue124);
  // (fading) not clipped
  GSDPTValueProc[121]:=Unaligned(@GSDPTValue120);
  // (fading) top-bottom clipped
  GSDPTValueProc[123]:=Unaligned(@GSDPTValue122);
  // (fading) left-right-top-bottom clipped
  GSDPTValueProc[125]:=Unaligned(@GSDPTValue124);

  {BlurRGB}
  // (constant) not clipped
  GSDPTValueProc[130]:=Unaligned(@GSDPTValue130);
  // (constant) top-bottom clipped
  GSDPTValueProc[132]:=Unaligned(@GSDPTValue132);
  // (constant) left-right-top-bottom clipped
  GSDPTValueProc[134]:=Unaligned(@GSDPTValue134);
  // (fading) not clipped
  GSDPTValueProc[131]:=Unaligned(@GSDPTValue130);
  // (fading) top-bottom clipped
  GSDPTValueProc[133]:=Unaligned(@GSDPTValue132);
  // (fading) left-right-top-bottom clipped
  GSDPTValueProc[135]:=Unaligned(@GSDPTValue134);

  {BlurRRB}
  // (constant) not clipped
  GSDPTValueProc[140]:=Unaligned(@GSDPTValue140);
  // (constant) top-bottom clipped
  GSDPTValueProc[142]:=Unaligned(@GSDPTValue142);
  // (constant) left-right-top-bottom clipped
  GSDPTValueProc[144]:=Unaligned(@GSDPTValue144);
  // (fading) not clipped
  GSDPTValueProc[141]:=Unaligned(@GSDPTValue140);
  // (fading) top-bottom clipped
  GSDPTValueProc[143]:=Unaligned(@GSDPTValue142);
  // (fading) left-right-top-bottom clipped
  GSDPTValueProc[145]:=Unaligned(@GSDPTValue144);

  {BlurRGR}
  // (constant) not clipped
  GSDPTValueProc[150]:=Unaligned(@GSDPTValue150);
  // (constant) top-bottom clipped
  GSDPTValueProc[152]:=Unaligned(@GSDPTValue152);
  // (constant) left-right-top-bottom clipped
  GSDPTValueProc[154]:=Unaligned(@GSDPTValue154);
  // (fading) not clipped
  GSDPTValueProc[151]:=Unaligned(@GSDPTValue150);
  // (fading) top-bottom clipped
  GSDPTValueProc[153]:=Unaligned(@GSDPTValue152);
  // (fading) left-right-top-bottom clipped
  GSDPTValueProc[155]:=Unaligned(@GSDPTValue154);

  {BlurGGB}
  // (constant) not clipped
  GSDPTValueProc[160]:=Unaligned(@GSDPTValue160);
  // (constant) top-bottom clipped
  GSDPTValueProc[162]:=Unaligned(@GSDPTValue162);
  // (constant) left-right-top-bottom clipped
  GSDPTValueProc[164]:=Unaligned(@GSDPTValue164);
  // (fading) not clipped
  GSDPTValueProc[161]:=Unaligned(@GSDPTValue160);
  // (fading) top-bottom clipped
  GSDPTValueProc[163]:=Unaligned(@GSDPTValue162);
  // (fading) left-right-top-bottom clipped
  GSDPTValueProc[165]:=Unaligned(@GSDPTValue164);

  {BlurRGG}
  // (constant) not clipped
  GSDPTValueProc[170]:=Unaligned(@GSDPTValue170);
  // (constant) top-bottom clipped
  GSDPTValueProc[172]:=Unaligned(@GSDPTValue172);
  // (constant) left-right-top-bottom clipped
  GSDPTValueProc[174]:=Unaligned(@GSDPTValue174);
  // (fading) not clipped
  GSDPTValueProc[171]:=Unaligned(@GSDPTValue170);
  // (fading) top-bottom clipped
  GSDPTValueProc[173]:=Unaligned(@GSDPTValue172);
  // (fading) left-right-top-bottom clipped
  GSDPTValueProc[175]:=Unaligned(@GSDPTValue174);

  {BlurBGB}
  // (constant) not clipped
  GSDPTValueProc[180]:=Unaligned(@GSDPTValue180);
  // (constant) top-bottom clipped
  GSDPTValueProc[182]:=Unaligned(@GSDPTValue182);
  // (constant) left-right-top-bottom clipped
  GSDPTValueProc[184]:=Unaligned(@GSDPTValue184);
  // (fading) not clipped
  GSDPTValueProc[181]:=Unaligned(@GSDPTValue180);
  // (fading) top-bottom clipped
  GSDPTValueProc[183]:=Unaligned(@GSDPTValue182);
  // (fading) left-right-top-bottom clipped
  GSDPTValueProc[185]:=Unaligned(@GSDPTValue184);

  {BlurRBB}
  // (constant) not clipped
  GSDPTValueProc[190]:=Unaligned(@GSDPTValue190);
  // (constant) top-bottom clipped
  GSDPTValueProc[192]:=Unaligned(@GSDPTValue192);
  // (constant) left-right-top-bottom clipped
  GSDPTValueProc[194]:=Unaligned(@GSDPTValue194);
  // (fading) not clipped
  GSDPTValueProc[191]:=Unaligned(@GSDPTValue190);
  // (fading) top-bottom clipped
  GSDPTValueProc[193]:=Unaligned(@GSDPTValue192);
  // (fading) left-right-top-bottom clipped
  GSDPTValueProc[195]:=Unaligned(@GSDPTValue194);

  {BlurRRR}
  // (constant) not clipped
  GSDPTValueProc[200]:=Unaligned(@GSDPTValue200);
  // (constant) top-bottom clipped
  GSDPTValueProc[202]:=Unaligned(@GSDPTValue202);
  // (constant) left-right-top-bottom clipped
  GSDPTValueProc[204]:=Unaligned(@GSDPTValue204);
  // (fading) not clipped
  GSDPTValueProc[201]:=Unaligned(@GSDPTValue200);
  // (fading) top-bottom clipped
  GSDPTValueProc[203]:=Unaligned(@GSDPTValue202);
  // (fading) left-right-top-bottom clipped
  GSDPTValueProc[205]:=Unaligned(@GSDPTValue204);

  {BlurGGG}
  // (constant) not clipped
  GSDPTValueProc[210]:=Unaligned(@GSDPTValue210);
  // (constant) top-bottom clipped
  GSDPTValueProc[212]:=Unaligned(@GSDPTValue212);
  // (constant) left-right-top-bottom clipped
  GSDPTValueProc[214]:=Unaligned(@GSDPTValue214);
  // (fading) not clipped
  GSDPTValueProc[211]:=Unaligned(@GSDPTValue210);
  // (fading) top-bottom clipped
  GSDPTValueProc[213]:=Unaligned(@GSDPTValue212);
  // (fading) left-right-top-bottom clipped
  GSDPTValueProc[215]:=Unaligned(@GSDPTValue214);

  {BlurBBB}
  // (constant) not clipped
  GSDPTValueProc[220]:=Unaligned(@GSDPTValue220);
  // (constant) top-bottom clipped
  GSDPTValueProc[222]:=Unaligned(@GSDPTValue222);
  // (constant) left-right-top-bottom clipped
  GSDPTValueProc[224]:=Unaligned(@GSDPTValue224);
  // (fading) not clipped
  GSDPTValueProc[221]:=Unaligned(@GSDPTValue220);
  // (fading) top-bottom clipped
  GSDPTValueProc[223]:=Unaligned(@GSDPTValue222);
  // (fading) left-right-top-bottom clipped
  GSDPTValueProc[225]:=Unaligned(@GSDPTValue224);

  {Contrast}
  // (constant) not clipped
  GSDPTValueProc[230]:=Unaligned(@GSDPTValue230);
  // (constant) top-bottom clipped
  GSDPTValueProc[232]:=Unaligned(@GSDPTValue232);
  // (constant) left-right-top-bottom clipped
  GSDPTValueProc[234]:=Unaligned(@GSDPTValue234);
  // (fading) not clipped
  GSDPTValueProc[231]:=Unaligned(@GSDPTValue230);
  // (fading) top-bottom clipped
  GSDPTValueProc[233]:=Unaligned(@GSDPTValue232);
  // (fading) left-right-top-bottom clipped
  GSDPTValueProc[235]:=Unaligned(@GSDPTValue234);

  {$endregion}

  {||scl_mul||>1: (SU - Scale Up  )} {$region -fold}

  {Empty}
  GSUPTValueProc[009]:=Unaligned(@GSUPTValue009);

  {Monochrome}
  // (constant) not clipped
  GSUPTValueProc[000]:=Unaligned(@GSUPTValue000);
  // (constant) top-bottom clipped
  GSUPTValueProc[002]:=Unaligned(@GSUPTValue002);
  // (constant) left-right-top-bottom clipped
  GSUPTValueProc[004]:=Unaligned(@GSUPTValue004);
  // (fading) not clipped
  GSUPTValueProc[001]:=Unaligned(@GSUPTValue020);
  // (fading) top-bottom clipped
  GSUPTValueProc[003]:=Unaligned(@GSUPTValue022);
  // (fading) left-right-top-bottom clipped
  GSUPTValueProc[005]:=Unaligned(@GSUPTValue024);

  {Additive}
  // (constant) not clipped
  GSUPTValueProc[010]:=Unaligned(@GSUPTValue010);
  // (constant) top-bottom clipped
  GSUPTValueProc[012]:=Unaligned(@GSUPTValue012);
  // (constant) left-right-top-bottom clipped
  GSUPTValueProc[014]:=Unaligned(@GSUPTValue014);
  // (fading) not clipped
  GSUPTValueProc[011]:=Unaligned(@GSUPTValue010);
  // (fading) top-bottom clipped
  GSUPTValueProc[013]:=Unaligned(@GSUPTValue012);
  // (fading) left-right-top-bottom clipped
  GSUPTValueProc[015]:=Unaligned(@GSUPTValue014);

  {Alphablend}
  // (constant) not clipped
  GSUPTValueProc[020]:=Unaligned(@GSUPTValue020);
  // (constant) top-bottom clipped
  GSUPTValueProc[022]:=Unaligned(@GSUPTValue022);
  // (constant) left-right-top-bottom clipped
  GSUPTValueProc[024]:=Unaligned(@GSUPTValue024);
  // (fading) not clipped
  GSUPTValueProc[021]:=Unaligned(@GSUPTValue020);
  // (fading) top-bottom clipped
  GSUPTValueProc[023]:=Unaligned(@GSUPTValue022);
  // (fading) left-right-top-bottom clipped
  GSUPTValueProc[025]:=Unaligned(@GSUPTValue024);

  {Inverse}
  // (constant) not clipped
  GSUPTValueProc[030]:=Unaligned(@GSUPTValue030);
  // (constant) top-bottom clipped
  GSUPTValueProc[032]:=Unaligned(@GSUPTValue032);
  // (constant) left-right-top-bottom clipped
  GSUPTValueProc[034]:=Unaligned(@GSUPTValue034);
  // (fading) not clipped
  GSUPTValueProc[031]:=Unaligned(@GSUPTValue030);
  // (fading) top-bottom clipped
  GSUPTValueProc[033]:=Unaligned(@GSUPTValue032);
  // (fading) left-right-top-bottom clipped
  GSUPTValueProc[035]:=Unaligned(@GSUPTValue034);

  {Highlighted}
  // (constant) not clipped
  GSUPTValueProc[040]:=Unaligned(@GSUPTValue040);
  // (constant) top-bottom clipped
  GSUPTValueProc[042]:=Unaligned(@GSUPTValue042);
  // (constant) left-right-top-bottom clipped
  GSUPTValueProc[044]:=Unaligned(@GSUPTValue044);
  // (fading) not clipped
  GSUPTValueProc[041]:=Unaligned(@GSUPTValue040);
  // (fading) top-bottom clipped
  GSUPTValueProc[043]:=Unaligned(@GSUPTValue042);
  // (fading) left-right-top-bottom clipped
  GSUPTValueProc[045]:=Unaligned(@GSUPTValue044);

  {Darkened}
  // (constant) not clipped
  GSUPTValueProc[050]:=Unaligned(@GSUPTValue050);
  // (constant) top-bottom clipped
  GSUPTValueProc[052]:=Unaligned(@GSUPTValue052);
  // (constant) left-right-top-bottom clipped
  GSUPTValueProc[054]:=Unaligned(@GSUPTValue054);
  // (fading) not clipped
  GSUPTValueProc[051]:=Unaligned(@GSUPTValue050);
  // (fading) top-bottom clipped
  GSUPTValueProc[053]:=Unaligned(@GSUPTValue052);
  // (fading) left-right-top-bottom clipped
  GSUPTValueProc[055]:=Unaligned(@GSUPTValue054);

  {GrayscaleR}
  // (constant) not clipped
  GSUPTValueProc[060]:=Unaligned(@GSUPTValue060);
  // (constant) top-bottom clipped
  GSUPTValueProc[062]:=Unaligned(@GSUPTValue062);
  // (constant) left-right-top-bottom clipped
  GSUPTValueProc[064]:=Unaligned(@GSUPTValue064);
  // (fading) not clipped
  GSUPTValueProc[061]:=Unaligned(@GSUPTValue060);
  // (fading) top-bottom clipped
  GSUPTValueProc[063]:=Unaligned(@GSUPTValue062);
  // (fading) left-right-top-bottom clipped
  GSUPTValueProc[065]:=Unaligned(@GSUPTValue064);

  {GrayscaleG}
  // (constant) not clipped
  GSUPTValueProc[070]:=Unaligned(@GSUPTValue070);
  // (constant) top-bottom clipped
  GSUPTValueProc[072]:=Unaligned(@GSUPTValue072);
  // (constant) left-right-top-bottom clipped
  GSUPTValueProc[074]:=Unaligned(@GSUPTValue074);
  // (fading) not clipped
  GSUPTValueProc[071]:=Unaligned(@GSUPTValue070);
  // (fading) top-bottom clipped
  GSUPTValueProc[073]:=Unaligned(@GSUPTValue072);
  // (fading) left-right-top-bottom clipped
  GSUPTValueProc[075]:=Unaligned(@GSUPTValue074);

  {GrayscaleB}
  // (constant) not clipped
  GSUPTValueProc[080]:=Unaligned(@GSUPTValue080);
  // (constant) top-bottom clipped
  GSUPTValueProc[082]:=Unaligned(@GSUPTValue082);
  // (constant) left-right-top-bottom clipped
  GSUPTValueProc[084]:=Unaligned(@GSUPTValue084);
  // (fading) not clipped
  GSUPTValueProc[081]:=Unaligned(@GSUPTValue080);
  // (fading) top-bottom clipped
  GSUPTValueProc[083]:=Unaligned(@GSUPTValue082);
  // (fading) left-right-top-bottom clipped
  GSUPTValueProc[085]:=Unaligned(@GSUPTValue084);

  {Monochrome Noise}
  // (constant) not clipped
  GSUPTValueProc[090]:=Unaligned(@GSUPTValue090);
  // (constant) top-bottom clipped
  GSUPTValueProc[092]:=Unaligned(@GSUPTValue092);
  // (constant) left-right-top-bottom clipped
  GSUPTValueProc[094]:=Unaligned(@GSUPTValue094);
  // (fading) not clipped
  GSUPTValueProc[091]:=Unaligned(@GSUPTValue090);
  // (fading) top-bottom clipped
  GSUPTValueProc[093]:=Unaligned(@GSUPTValue092);
  // (fading) left-right-top-bottom clipped
  GSUPTValueProc[095]:=Unaligned(@GSUPTValue094);

  {ColorizeR}
  // (constant) not clipped
  GSUPTValueProc[100]:=Unaligned(@GSUPTValue100);
  // (constant) top-bottom clipped
  GSUPTValueProc[102]:=Unaligned(@GSUPTValue102);
  // (constant) left-right-top-bottom clipped
  GSUPTValueProc[104]:=Unaligned(@GSUPTValue104);
  // (fading) not clipped
  GSUPTValueProc[101]:=Unaligned(@GSUPTValue100);
  // (fading) top-bottom clipped
  GSUPTValueProc[103]:=Unaligned(@GSUPTValue102);
  // (fading) left-right-top-bottom clipped
  GSUPTValueProc[105]:=Unaligned(@GSUPTValue104);

  {ColorizeG}
  // (constant) not clipped
  GSUPTValueProc[110]:=Unaligned(@GSUPTValue110);
  // (constant) top-bottom clipped
  GSUPTValueProc[112]:=Unaligned(@GSUPTValue112);
  // (constant) left-right-top-bottom clipped
  GSUPTValueProc[114]:=Unaligned(@GSUPTValue114);
  // (fading) not clipped
  GSUPTValueProc[111]:=Unaligned(@GSUPTValue110);
  // (fading) top-bottom clipped
  GSUPTValueProc[113]:=Unaligned(@GSUPTValue112);
  // (fading) left-right-top-bottom clipped
  GSUPTValueProc[115]:=Unaligned(@GSUPTValue114);

  {ColorizeB}
  // (constant) not clipped
  GSUPTValueProc[120]:=Unaligned(@GSUPTValue120);
  // (constant) top-bottom clipped
  GSUPTValueProc[122]:=Unaligned(@GSUPTValue122);
  // (constant) left-right-top-bottom clipped
  GSUPTValueProc[124]:=Unaligned(@GSUPTValue124);
  // (fading) not clipped
  GSUPTValueProc[121]:=Unaligned(@GSUPTValue120);
  // (fading) top-bottom clipped
  GSUPTValueProc[123]:=Unaligned(@GSUPTValue122);
  // (fading) left-right-top-bottom clipped
  GSUPTValueProc[125]:=Unaligned(@GSUPTValue124);

  {BlurRGB}
  // (constant) not clipped
  GSUPTValueProc[130]:=Unaligned(@GSUPTValue130);
  // (constant) top-bottom clipped
  GSUPTValueProc[132]:=Unaligned(@GSUPTValue132);
  // (constant) left-right-top-bottom clipped
  GSUPTValueProc[134]:=Unaligned(@GSUPTValue134);
  // (fading) not clipped
  GSUPTValueProc[131]:=Unaligned(@GSUPTValue130);
  // (fading) top-bottom clipped
  GSUPTValueProc[133]:=Unaligned(@GSUPTValue132);
  // (fading) left-right-top-bottom clipped
  GSUPTValueProc[135]:=Unaligned(@GSUPTValue134);

  {BlurRRB}
  // (constant) not clipped
  GSUPTValueProc[140]:=Unaligned(@GSUPTValue140);
  // (constant) top-bottom clipped
  GSUPTValueProc[142]:=Unaligned(@GSUPTValue142);
  // (constant) left-right-top-bottom clipped
  GSUPTValueProc[144]:=Unaligned(@GSUPTValue144);
  // (fading) not clipped
  GSUPTValueProc[141]:=Unaligned(@GSUPTValue140);
  // (fading) top-bottom clipped
  GSUPTValueProc[143]:=Unaligned(@GSUPTValue142);
  // (fading) left-right-top-bottom clipped
  GSUPTValueProc[145]:=Unaligned(@GSUPTValue144);

  {BlurRGR}
  // (constant) not clipped
  GSUPTValueProc[150]:=Unaligned(@GSUPTValue150);
  // (constant) top-bottom clipped
  GSUPTValueProc[152]:=Unaligned(@GSUPTValue152);
  // (constant) left-right-top-bottom clipped
  GSUPTValueProc[154]:=Unaligned(@GSUPTValue154);
  // (fading) not clipped
  GSUPTValueProc[151]:=Unaligned(@GSUPTValue150);
  // (fading) top-bottom clipped
  GSUPTValueProc[153]:=Unaligned(@GSUPTValue152);
  // (fading) left-right-top-bottom clipped
  GSUPTValueProc[155]:=Unaligned(@GSUPTValue154);

  {BlurGGB}
  // (constant) not clipped
  GSUPTValueProc[160]:=Unaligned(@GSUPTValue160);
  // (constant) top-bottom clipped
  GSUPTValueProc[162]:=Unaligned(@GSUPTValue162);
  // (constant) left-right-top-bottom clipped
  GSUPTValueProc[164]:=Unaligned(@GSUPTValue164);
  // (fading) not clipped
  GSUPTValueProc[161]:=Unaligned(@GSUPTValue160);
  // (fading) top-bottom clipped
  GSUPTValueProc[163]:=Unaligned(@GSUPTValue162);
  // (fading) left-right-top-bottom clipped
  GSUPTValueProc[165]:=Unaligned(@GSUPTValue164);

  {BlurRGG}
  // (constant) not clipped
  GSUPTValueProc[170]:=Unaligned(@GSUPTValue170);
  // (constant) top-bottom clipped
  GSUPTValueProc[172]:=Unaligned(@GSUPTValue172);
  // (constant) left-right-top-bottom clipped
  GSUPTValueProc[174]:=Unaligned(@GSUPTValue174);
  // (fading) not clipped
  GSUPTValueProc[171]:=Unaligned(@GSUPTValue170);
  // (fading) top-bottom clipped
  GSUPTValueProc[173]:=Unaligned(@GSUPTValue172);
  // (fading) left-right-top-bottom clipped
  GSUPTValueProc[175]:=Unaligned(@GSUPTValue174);

  {BlurBGB}
  // (constant) not clipped
  GSUPTValueProc[180]:=Unaligned(@GSUPTValue180);
  // (constant) top-bottom clipped
  GSUPTValueProc[182]:=Unaligned(@GSUPTValue182);
  // (constant) left-right-top-bottom clipped
  GSUPTValueProc[184]:=Unaligned(@GSUPTValue184);
  // (fading) not clipped
  GSUPTValueProc[181]:=Unaligned(@GSUPTValue180);
  // (fading) top-bottom clipped
  GSUPTValueProc[183]:=Unaligned(@GSUPTValue182);
  // (fading) left-right-top-bottom clipped
  GSUPTValueProc[185]:=Unaligned(@GSUPTValue184);

  {BlurRBB}
  // (constant) not clipped
  GSUPTValueProc[190]:=Unaligned(@GSUPTValue190);
  // (constant) top-bottom clipped
  GSUPTValueProc[192]:=Unaligned(@GSUPTValue192);
  // (constant) left-right-top-bottom clipped
  GSUPTValueProc[194]:=Unaligned(@GSUPTValue194);
  // (fading) not clipped
  GSUPTValueProc[191]:=Unaligned(@GSUPTValue190);
  // (fading) top-bottom clipped
  GSUPTValueProc[193]:=Unaligned(@GSUPTValue192);
  // (fading) left-right-top-bottom clipped
  GSUPTValueProc[195]:=Unaligned(@GSUPTValue194);

  {BlurRRR}
  // (constant) not clipped
  GSUPTValueProc[200]:=Unaligned(@GSUPTValue200);
  // (constant) top-bottom clipped
  GSUPTValueProc[202]:=Unaligned(@GSUPTValue202);
  // (constant) left-right-top-bottom clipped
  GSUPTValueProc[204]:=Unaligned(@GSUPTValue204);
  // (fading) not clipped
  GSUPTValueProc[201]:=Unaligned(@GSUPTValue200);
  // (fading) top-bottom clipped
  GSUPTValueProc[203]:=Unaligned(@GSUPTValue202);
  // (fading) left-right-top-bottom clipped
  GSUPTValueProc[205]:=Unaligned(@GSUPTValue204);

  {BlurGGG}
  // (constant) not clipped
  GSUPTValueProc[210]:=Unaligned(@GSUPTValue210);
  // (constant) top-bottom clipped
  GSUPTValueProc[212]:=Unaligned(@GSUPTValue212);
  // (constant) left-right-top-bottom clipped
  GSUPTValueProc[214]:=Unaligned(@GSUPTValue214);
  // (fading) not clipped
  GSUPTValueProc[211]:=Unaligned(@GSUPTValue210);
  // (fading) top-bottom clipped
  GSUPTValueProc[213]:=Unaligned(@GSUPTValue212);
  // (fading) left-right-top-bottom clipped
  GSUPTValueProc[215]:=Unaligned(@GSUPTValue214);

  {BlurBBB}
  // (constant) not clipped
  GSUPTValueProc[220]:=Unaligned(@GSUPTValue220);
  // (constant) top-bottom clipped
  GSUPTValueProc[222]:=Unaligned(@GSUPTValue222);
  // (constant) left-right-top-bottom clipped
  GSUPTValueProc[224]:=Unaligned(@GSUPTValue224);
  // (fading) not clipped
  GSUPTValueProc[221]:=Unaligned(@GSUPTValue220);
  // (fading) top-bottom clipped
  GSUPTValueProc[223]:=Unaligned(@GSUPTValue222);
  // (fading) left-right-top-bottom clipped
  GSUPTValueProc[225]:=Unaligned(@GSUPTValue224);

  {Contrast}
  // (constant) not clipped
  GSUPTValueProc[230]:=Unaligned(@GSUPTValue230);
  // (constant) top-bottom clipped
  GSUPTValueProc[232]:=Unaligned(@GSUPTValue232);
  // (constant) left-right-top-bottom clipped
  GSUPTValueProc[234]:=Unaligned(@GSUPTValue234);
  // (fading) not clipped
  GSUPTValueProc[231]:=Unaligned(@GSUPTValue230);
  // (fading) top-bottom clipped
  GSUPTValueProc[233]:=Unaligned(@GSUPTValue232);
  // (fading) left-right-top-bottom clipped
  GSUPTValueProc[235]:=Unaligned(@GSUPTValue234);

  {$endregion}

  {$endregion}

  {$endregion}

end; {$endregion}

{$endregion}

{Tile map drawing--------------------------------------} {$region -fold}

// ...
function TFastImageProc.GetArrCellInd(const x,y:double ): TPtPos; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      Result.x:=Trunc((x-rct_ent_f.left)/tilemap_sprite_w_h.x);
      Result.y:=Trunc((y-rct_ent_f.top )/tilemap_sprite_w_h.y);
    end;
end; {$endregion}
function TFastImageProc.GetArrCellInd(const x,y:integer): TPtPos; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      Result.x:=(x-rct_ent.left) div tilemap_sprite_w_h.x;
      Result.y:=(y-rct_ent.top ) div tilemap_sprite_w_h.y;
    end;
end; {$endregion}
// Fill tile map with random color:
procedure TFastImageProc.FilTileMap0; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst_0,rct_dst_1,rct_dst_2: TPtRect;
       bmp_bckgd_ptr2          : PInteger;
  nt_pix_cnt_arr_ptr           : PWord;
  nt_pix_sht_arr_ptr           : PWord;
  nt_pix_sht_arr_ptr_mul       : integer;
  i,j                          : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      rct_dst_0         :=PtBounds(rct_ent.left,rct_ent.top+nt_pix_arr_row_mrg_top*tilemap_sprite_w_h.y,tilemap_sprite_w_h.x,tilemap_sprite_w_h.y);
      rct_dst_1         :=rct_dst_0;
      bmp_bckgd_ptr2    :=Unaligned(@bmp_bkgnd_ptr [0000000000000000000000]);
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[nt_pix_arr_row_mrg_top]);
      nt_pix_sht_arr_ptr:=Unaligned(@nt_pix_sht_arr[0000000000000000000000]);
      for j:=0 to rct_ent.height    -nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          rct_dst_1:=rct_dst_0;
          for i:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
              nt_pix_sht_arr_ptr_mul:=tilemap_sprite_w_h.x*nt_pix_sht_arr_ptr^;
              rct_dst_1.left        :=rct_dst_0.left      +nt_pix_sht_arr_ptr_mul;
              rct_dst_1.right       :=rct_dst_0.right     +nt_pix_sht_arr_ptr_mul;
              rct_dst_2             :=ClippedRct(rct_clp_ptr^,rct_dst_1);
              PPFloodFill(bmp_bckgd_ptr2,bmp_bkgnd_width,rct_dst_2,Random($FFFFFF));
              Inc(nt_pix_sht_arr_ptr);
            end;
          Inc    (nt_pix_cnt_arr_ptr);
          Inc(rct_dst_0.top   ,tilemap_sprite_w_h.y);
          Inc(rct_dst_0.bottom,tilemap_sprite_w_h.y);
        end;
    end;
end; {$endregion}
// Fill tile map with specified sprite:
procedure TFastImageProc.FilTileMap1; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst_0,rct_dst_1   : TPtRect;
  nt_pix_cnt_arr_ptr    : PWord;
  nt_pix_sht_arr_ptr    : PWord;
  nt_pix_sht_arr_ptr_mul: integer;
  i,j                   : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      with tilemap_sprite_w_h do
        begin
          fast_image_data_ptr0:=fast_image_data_ptr1;
          rct_dst_0           :=PtBounds(rct_ent.left,rct_ent.top+nt_pix_arr_row_mrg_top*y,x,y);
          rct_dst_1           :=rct_dst_0;
          nt_pix_cnt_arr_ptr  :=Unaligned(@nt_pix_cnt_arr[nt_pix_arr_row_mrg_top]);
          nt_pix_sht_arr_ptr  :=Unaligned(@nt_pix_sht_arr[0000000000000000000000]);
          for j:=0 to rct_ent.height-      nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
            begin
              rct_dst_1:=rct_dst_0;
              for i:=0 to nt_pix_cnt_arr_ptr^-1 do
                begin
                  nt_pix_sht_arr_ptr_mul:=x              *nt_pix_sht_arr_ptr^;
                  rct_dst_1.left        :=rct_dst_0.left +nt_pix_sht_arr_ptr_mul;
                  rct_dst_1.right       :=rct_dst_0.right+nt_pix_sht_arr_ptr_mul;
                  fast_image_data_ptr0  :=fast_image_data_ptr2;
                  SdrProc                [fast_image_data_ptr0^.sdr_proc_ind](rct_dst_1.left,
                                                                              rct_dst_1.top,
                                                                              fast_image_data_ptr0);
                  fast_image_data_ptr0  :=fast_image_data_ptr1;
                  Inc(nt_pix_sht_arr_ptr);
                end;
              Inc    (nt_pix_cnt_arr_ptr);
              Inc(rct_dst_0.top   ,y);
              Inc(rct_dst_0.bottom,y);
            end;
        end;
    end;
end; {$endregion}
// Fill tile map with rectangles(empty):
procedure TFastImageProc.FilTileMap2; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst_0,rct_dst_1,rct_dst_2: TPtRect;
       bmp_bckgd_ptr2          : PInteger;
  nt_pix_cnt_arr_ptr           : PWord;
  nt_pix_sht_arr_ptr           : PWord;
  nt_pix_sht_arr_ptr_mul       : integer;
  i,j                          : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      rct_dst_0         :=PtBounds(rct_ent.left,rct_ent.top+nt_pix_arr_row_mrg_top*tilemap_sprite_w_h.y,tilemap_sprite_w_h.x,tilemap_sprite_w_h.y);
      rct_dst_1         :=rct_dst_0;
      bmp_bckgd_ptr2    :=Unaligned(@bmp_bkgnd_ptr [0000000000000000000000]);
      nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[nt_pix_arr_row_mrg_top]);
      nt_pix_sht_arr_ptr:=Unaligned(@nt_pix_sht_arr[0000000000000000000000]);
      for j:=0 to rct_ent.height-    nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          rct_dst_1:=rct_dst_0;
          for i:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
              nt_pix_sht_arr_ptr_mul:=tilemap_sprite_w_h.x*nt_pix_sht_arr_ptr^;
              rct_dst_1.left        :=rct_dst_0.left      +nt_pix_sht_arr_ptr_mul;
              rct_dst_1.right       :=rct_dst_0.right     +nt_pix_sht_arr_ptr_mul;
              rct_dst_2             :=ClippedRct(rct_clp_ptr^,rct_dst_1);
              Rectangle
              (
                rct_dst_2.left+sln_prop_var.pts_rct_width__half-sln_prop_var.pts_rct_width__odd,
                rct_dst_2.top +sln_prop_var.pts_rct_height_half-sln_prop_var.pts_rct_height_odd,
                bmp_bckgd_ptr2,
                bmp_bkgnd_width,
                bmp_bkgnd_height,
                rct_dst_2,
                sln_prop_var);
              Inc(nt_pix_sht_arr_ptr);
            end;
          Inc    (nt_pix_cnt_arr_ptr);
          Inc(rct_dst_0.top   ,tilemap_sprite_w_h.y);
          Inc(rct_dst_0.bottom,tilemap_sprite_w_h.y);
        end;
    end;
end; {$endregion}
// Fill tile map with rectangles(floodfill):
procedure TFastImageProc.FilTileMap3; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst_0,rct_dst_1,rct_dst_2: TPtRect;
       bmp_bckgd_ptr2          : PInteger;
   first_row_pix_ptr           : PInteger;
  nt_pix_cnt_arr_ptr           : PWord;
  nt_pix_sht_arr_ptr           : PWord;
  nt_pix_sht_arr_ptr_mul       : integer;
  x,y,bmp_bckgd_width_mul_y    : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      rct_dst_0            :=PtBounds(rct_ent.left,rct_ent.top+nt_pix_arr_row_mrg_top*tilemap_sprite_w_h.y,tilemap_sprite_w_h.x,tilemap_sprite_w_h.y);
      rct_dst_1            :=rct_dst_0;
      bmp_bckgd_width_mul_y:=bmp_bkgnd_width*tilemap_sprite_w_h.y;
      bmp_bckgd_ptr2       :=Unaligned(@bmp_bkgnd_ptr [00000000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
       first_row_pix_ptr   :=Unaligned(@bmp_bkgnd_ptr [(nt_pix_arr_row_mrg_top*tilemap_sprite_w_h.y+rct_ent.top)*bmp_bkgnd_width+rct_ent.left]);
      nt_pix_cnt_arr_ptr   :=Unaligned(@nt_pix_cnt_arr[ nt_pix_arr_row_mrg_top+00000000000000000000000000000000000000000000000000000000000000]);
      nt_pix_sht_arr_ptr   :=Unaligned(@nt_pix_sht_arr[00000000000000000000000000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to rct_ent.height-       nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          rct_dst_1:=rct_dst_0;
          for x:=0 to nt_pix_cnt_arr_ptr^-1 do
            begin
              nt_pix_sht_arr_ptr_mul:=tilemap_sprite_w_h.x*nt_pix_sht_arr_ptr^;
              rct_dst_1.left        :=rct_dst_0.left      +nt_pix_sht_arr_ptr_mul;
              rct_dst_1.right       :=rct_dst_0.right     +nt_pix_sht_arr_ptr_mul;
              rct_dst_2             :=ClippedRct(rct_clp_ptr^,rct_dst_1);
              PPFloodFill(bmp_bckgd_ptr2,bmp_bkgnd_width,rct_dst_2,(nt_pix_sht_arr_ptr^+first_row_pix_ptr)^);
              Inc(nt_pix_sht_arr_ptr);
            end;
          Inc    (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr,bmp_bckgd_width_mul_y);
          Inc(rct_dst_0.top    ,tilemap_sprite_w_h .y);
          Inc(rct_dst_0.bottom ,tilemap_sprite_w_h .y);
        end;
    end;
end; {$endregion}

{$endregion}

{Full CSR-image drawing--------------------------------} {$region -fold}
procedure TFastimageProc.SetPartVal(fx:TFXInfo);                                                                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fx do
    begin
      begin_proc_ind.clip_part:=0;
      color_proc_ind.clip_part:=0;
      begin_proc_ind.main_part:=0;
      color_proc_ind.main_part:=9;
    end;
end; {$endregion}
procedure TFastimageProc.SdrAnimCng(nt,pt:boolean;                                                 var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  with fast_image_data_ do
    for i:=0 to fx_cnt-1 do
      begin
        fx_arr[i].nt_fx_prop.is_fx_animate:=nt;
        fx_arr[i].pt_fx_prop.is_fx_animate:=pt;
      end;
end; {$endregion}
procedure TFastimageProc.SdrTypeCng(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      SdrAnimCng(True,True,    fast_image_data_);
      SetSdrType              (fast_image_data_);
         SdrType[sdr_type_ind](fast_image_data_ptr_,
                               fast_image_data_);
      SdrAnimCng(False,False,  fast_image_data_);
    end;
end; {$endregion}
procedure TFastimageProc.ShaderInfo;                                                                                                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin

      fx_cnt      :=1; //must be in range of [0..255]
      pix_drw_type:=0; //must be in range of [0..002]

      with fx_arr[0] do
        begin
          with nt_fx_prop do
            begin
              rep_cnt     :=1; //must be in range of [0..255]
              pix_srf_type:=1; //must be in range of [0..002]
              pix_cfx_type:=0; //must be in range of [0..002]
              pix_cng_type:=0; //must be in range of [0..001]
              img_inv_type:=0; //must be in range of [0..003]
            end;
          with pt_fx_prop do
            begin
              rep_cnt     :=1; //must be in range of [0..255]
              pix_srf_type:=1; //must be in range of [0..002]
              pix_cfx_type:=0; //must be in range of [0..002]
              pix_cng_type:=0; //must be in range of [0..001]
              img_inv_type:=0; //must be in range of [0..003]
            end;
        end;

      with fx_arr[1] do
        begin
          with nt_fx_prop do
            begin
              rep_cnt     :=1; //must be in range of [0..255]
              pix_srf_type:=1; //must be in range of [0..001]
              pix_cfx_type:=0; //must be in range of [0..255]
              pix_cng_type:=0; //must be in range of [0..001]
              img_inv_type:=0; //must be in range of [0..003]
            end;
          with pt_fx_prop do
            begin
              rep_cnt     :=1; //must be in range of [0..255]
              pix_srf_type:=1; //must be in range of [0..001]
              pix_cfx_type:=0; //must be in range of [0..255]
              pix_cng_type:=0; //must be in range of [0..001]
              img_inv_type:=0; //must be in range of [0..003]
            end;
        end;

      with fx_arr[2] do
        begin
          with nt_fx_prop do
            begin
              rep_cnt     :=1; //must be in range of [0..255]
              pix_srf_type:=1; //must be in range of [0..001]
              pix_cfx_type:=0; //must be in range of [0..255]
              pix_cng_type:=0; //must be in range of [0..001]
              img_inv_type:=0; //must be in range of [0..003]
            end;
          with pt_fx_prop do
            begin
              rep_cnt     :=1; //must be in range of [0..255]
              pix_srf_type:=1; //must be in range of [0..001]
              pix_cfx_type:=0; //must be in range of [0..255]
              pix_cng_type:=0; //must be in range of [0..001]
              img_inv_type:=0; //must be in range of [0..003]
            end;
        end;

      SdrTypeCng(fast_image_data_ptr0,
                 fast_image_data_ptr0^);

    end;
end; {$endregion}
procedure TFastimageProc.SetSdrType(                                                               var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    sdr_type_ind:=3*img_kind+pix_drw_type;
end; {$endregion}
procedure TFastimageProc.SdrTypeInit;                                                                                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType[000]:=Unaligned(@SdrType000);
  SdrType[001]:=Unaligned(@SdrType001);
  SdrType[002]:=Unaligned(@SdrType002);
  SdrType[003]:=Unaligned(@SdrType003);
  SdrType[004]:=Unaligned(@SdrType004);
  SdrType[005]:=Unaligned(@SdrType005);
  SdrType[006]:=Unaligned(@SdrType006);
  SdrType[007]:=Unaligned(@SdrType007);
  SdrType[008]:=Unaligned(@SdrType008);
  SdrType[009]:=Unaligned(@SdrType009);
  SdrType[010]:=Unaligned(@SdrType010);
  SdrType[011]:=Unaligned(@SdrType011);
  SdrType[012]:=Unaligned(@SdrType012);
  SdrType[013]:=Unaligned(@SdrType013);
  SdrType[014]:=Unaligned(@SdrType014);
  SdrType[015]:=Unaligned(@SdrType015);
  SdrType[016]:=Unaligned(@SdrType016);
  SdrType[017]:=Unaligned(@SdrType016);
  SdrType[018]:=Unaligned(@SdrType015);
  SdrType[019]:=Unaligned(@SdrType004);
  SdrType[020]:=Unaligned(@SdrType004);
  SdrType[021]:=Unaligned(@SdrType015);
  SdrType[022]:=Unaligned(@SdrType007);
  SdrType[023]:=Unaligned(@SdrType007);
  SdrType[024]:=Unaligned(@SdrType024);
  SdrType[025]:=Unaligned(@SdrType010);
  SdrType[026]:=Unaligned(@SdrType010);
  SdrType[027]:=Unaligned(@SdrType027);
  SdrType[028]:=Unaligned(@SdrType010);
  SdrType[029]:=Unaligned(@SdrType010);
  SdrType[030]:=Unaligned(@SdrType015);
  SdrType[031]:=Unaligned(@SdrType015);
  SdrType[032]:=Unaligned(@SdrType015);
  SdrType[033]:=Unaligned(@SdrType015);
  SdrType[034]:=Unaligned(@SdrType015);
  SdrType[035]:=Unaligned(@SdrType015);
  SdrType[036]:=Unaligned(@SdrType009);
  SdrType[037]:=Unaligned(@SdrType010);
  SdrType[038]:=Unaligned(@SdrType011);
end; {$endregion}
procedure TFastimageProc.SdrType000(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    with fx_arr[0] do
      begin
        with nt_fx_prop do
          begin
                pix_srf_type                :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
                pix_srf_type;
            if (pix_srf_type<>0) then
              begin
                begin_proc_ind.clip_part    :=0;
                color_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(   pix_clp_type<<1);
                   is_fx_animate            :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
                   is_fx_animate;
                if is_fx_animate then
                  begin
                    pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
                    pix_cfx_type;
                    pix_cng_type            :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
                    pix_cng_type;
                    begin_proc_ind.main_part:=((pix_srf_type+0)>>0);
                    color_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                  end;
              end
            else
              SetPartVal(nt_fx_prop);
          end;
        with pt_fx_prop do
          begin
                pix_srf_type                :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
                pix_srf_type;
            if (pix_srf_type<>0) then
              begin
                begin_proc_ind.clip_part    :=0;
                color_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(   pix_clp_type<<1);
                   is_fx_animate            :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
                   is_fx_animate;
                if is_fx_animate then
                  begin
                    pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
                    pix_cfx_type;
                    pix_cng_type            :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
                    pix_cng_type;
                    begin_proc_ind.main_part:=((pix_srf_type+0)>>0);
                    color_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                  end;
              end
            else
              SetPartVal(pt_fx_prop);
          end;
        fx_cnt:=1;
      end;
end; {$endregion}
procedure TFastimageProc.SdrType001(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  with fast_image_data_ do
    begin
      with fx_arr[0] do
        begin
          SetPartVal(nt_fx_prop);
          SetPartVal(pt_fx_prop);
        end;
      for i:=1 to fx_cnt-1 do
        with fx_arr[i] do
          begin
            with nt_fx_prop do
              begin
                pix_srf_type                :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                pix_srf_type;
                value_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(   pix_clp_type<<1);
                   is_fx_animate            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                   is_fx_animate;
                if is_fx_animate then
                  begin
                    pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                    pix_cfx_type;
                    pix_cng_type            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                    pix_cng_type;
                    value_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                  end;
              end;
            with pt_fx_prop do
              begin
                pix_srf_type                :=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
                pix_srf_type;
                value_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(   pix_clp_type<<1);
                   is_fx_animate            :=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
                   is_fx_animate;
                if is_fx_animate then
                  begin
                    pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
                    pix_cfx_type;
                    pix_cng_type            :=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
                    pix_cng_type;
                    value_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                  end;
              end;
          end;
    end;
end; {$endregion}
procedure TFastimageProc.SdrType002(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  with fast_image_data_ do
    begin
      with fx_arr[0] do
        begin
          with nt_fx_prop do
            begin
                  pix_srf_type                :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
                  pix_srf_type;
              if (pix_srf_type<>0) then
                begin
                  begin_proc_ind.clip_part    :=0;
                  color_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(pix_clp_type<<1);
                     is_fx_animate            :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
                     is_fx_animate;
                  if is_fx_animate then
                    begin
                      pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
                      pix_cfx_type;
                      pix_cng_type            :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
                      pix_cng_type;
                      begin_proc_ind.main_part:=((pix_srf_type+0)>>0);
                      color_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                    end;
                end
              else
                SetPartVal(nt_fx_prop);
            end;
          with pt_fx_prop do
            begin
                  pix_srf_type                :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
                  pix_srf_type;
              if (pix_srf_type<>0) then
                begin
                  begin_proc_ind.clip_part    :=0;
                  color_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(pix_clp_type<<1);
                     is_fx_animate            :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
                     is_fx_animate;
                  if is_fx_animate then
                    begin
                      pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
                      pix_cfx_type;
                      pix_cng_type            :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
                      pix_cng_type;
                      begin_proc_ind.main_part:=((pix_srf_type+0)>>0);
                      color_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                    end;
                end
              else
                SetPartVal(pt_fx_prop);
            end;
        end;
      for i:=1 to fx_cnt-1 do
        with fx_arr[i] do
          begin
            with nt_fx_prop do
              begin
                pix_srf_type                :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                pix_srf_type;
                value_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(pix_clp_type<<1);
                   is_fx_animate            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                   is_fx_animate;
                if is_fx_animate then
                  begin
                    pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                    pix_cfx_type;
                    pix_cng_type            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                    pix_cng_type;
                    value_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                  end;
              end;
            with pt_fx_prop do
              begin
                pix_srf_type                :=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
                pix_srf_type;
                value_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(pix_clp_type<<1);
                   is_fx_animate            :=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
                   is_fx_animate;
                if is_fx_animate then
                  begin
                    pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
                    pix_cfx_type;
                    pix_cng_type            :=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
                    pix_cng_type;
                    value_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                  end;
              end;
          end;
    end;
end; {$endregion}
procedure TFastimageProc.SdrType003(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    with fx_arr[0] do
      begin
        SetPartVal(pt_fx_prop);
        with nt_fx_prop do
          begin
                pix_srf_type                :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
                pix_srf_type;
            if (pix_srf_type<>0) then
              begin
                begin_proc_ind.clip_part    :=0;
                color_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(pix_clp_type<<1);
                   is_fx_animate            :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
                   is_fx_animate;
                if is_fx_animate then
                  begin
                    pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
                    pix_cfx_type;
                    pix_cng_type            :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
                    pix_cng_type;
                    begin_proc_ind.main_part:=((pix_srf_type+0)>>0);
                    color_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                  end;
              end
            else
              SetPartVal(nt_fx_prop);
          end;
        fx_cnt:=1;
      end;
end; {$endregion}
procedure TFastimageProc.SdrType004(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  with fast_image_data_ do
    begin
      with fx_arr[0] do
        begin
          SetPartVal(nt_fx_prop);
          SetPartVal(pt_fx_prop);
        end;
      for i:=1 to fx_cnt-1 do
        with fx_arr[i] do
          begin
            with nt_fx_prop do
              begin
                pix_srf_type                :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                pix_srf_type;
                value_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(pix_clp_type<<1);
                   is_fx_animate            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                   is_fx_animate;
                if is_fx_animate then
                  begin
                    pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                    pix_cfx_type;
                    pix_cng_type            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                    pix_cng_type;
                    value_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                  end;
              end;
            with pt_fx_prop do
              begin
                value_proc_ind.clip_part:=0;
                value_proc_ind.main_part:=9;
              end;
          end;
    end;
end; {$endregion}
procedure TFastimageProc.SdrType005(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  with fast_image_data_ do
    begin
      with fx_arr[0] do
        begin
          SetPartVal(pt_fx_prop);
          with nt_fx_prop do
            begin
                  pix_srf_type                :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
                  pix_srf_type;
              if (pix_srf_type<>0) then
                begin
                  begin_proc_ind.clip_part    :=0;
                  color_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(pix_clp_type<<1);
                     is_fx_animate            :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
                     is_fx_animate;
                  if is_fx_animate then
                    begin
                      pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
                      pix_cfx_type;
                      pix_cng_type            :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
                      pix_cng_type;
                      begin_proc_ind.main_part:=((pix_srf_type+0)>>0);
                      color_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                    end;
                end
              else
                SetPartVal(nt_fx_prop);
            end;
        end;
      for i:=1 to fx_cnt-1 do
        with fx_arr[i] do
          begin
            with nt_fx_prop do
              begin
                pix_srf_type                :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                pix_srf_type;
                value_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(pix_clp_type<<1);
                   is_fx_animate            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                   is_fx_animate;
                if is_fx_animate then
                  begin
                    pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                    pix_cfx_type;
                    pix_cng_type            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                    pix_cng_type;
                    value_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                  end;
              end;
            with pt_fx_prop do
              begin
                value_proc_ind.clip_part:=0;
                value_proc_ind.main_part:=9;
              end;
          end;
    end;
end; {$endregion}
procedure TFastimageProc.SdrType006(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    with fx_arr[0] do
      begin
        SetPartVal(nt_fx_prop);
        with pt_fx_prop do
          begin
                pix_srf_type                :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
                pix_srf_type;
            if (pix_srf_type<>0) then
              begin
                begin_proc_ind.clip_part    :=0;
                color_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(pix_clp_type<<1);
                   is_fx_animate            :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
                   is_fx_animate;
                if is_fx_animate then
                  begin
                    pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
                    pix_cfx_type;
                    pix_cng_type            :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
                    pix_cng_type;
                    begin_proc_ind.main_part:=((pix_srf_type+0)>>0);
                    color_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                  end;
              end
            else
              SetPartVal(pt_fx_prop);
          end;
        fx_cnt:=1;
      end;
end; {$endregion}
procedure TFastimageProc.SdrType007(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  with fast_image_data_ do
    begin
      with fx_arr[0] do
        begin
          SetPartVal(nt_fx_prop);
          SetPartVal(pt_fx_prop);
        end;
      for i:=1 to fx_cnt-1 do
        with fx_arr[i] do
          begin
            with nt_fx_prop do
              begin
                value_proc_ind.clip_part:=0;
                value_proc_ind.main_part:=9;
              end;
            with pt_fx_prop do
              begin
                pix_srf_type                :=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
                pix_srf_type;
                value_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(pix_clp_type<<1);
                   is_fx_animate            :=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
                   is_fx_animate;
                if is_fx_animate then
                  begin
                    pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
                    pix_cfx_type;
                    pix_cng_type            :=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
                    pix_cng_type;
                    value_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                  end;
              end;
          end;
    end;
end; {$endregion}
procedure TFastimageProc.SdrType008(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  with fast_image_data_ do
    begin
      with fx_arr[0] do
        begin
          SetPartVal(nt_fx_prop);
          with pt_fx_prop do
            begin
                  pix_srf_type                :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
                  pix_srf_type;
              if (pix_srf_type<>0) then
                begin
                  begin_proc_ind.clip_part    :=0;
                  color_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(pix_clp_type<<1);
                     is_fx_animate            :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
                     is_fx_animate;
                  if is_fx_animate then
                    begin
                      pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
                      pix_cfx_type;
                      pix_cng_type            :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
                      pix_cng_type;
                      begin_proc_ind.main_part:=((pix_srf_type+0)>>0);
                      color_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                    end;
                end
              else
                SetPartVal(pt_fx_prop);
            end;
        end;
      for i:=1 to fx_cnt-1 do
        with fx_arr[i] do
          begin
            with nt_fx_prop do
              begin
                value_proc_ind.clip_part:=0;
                value_proc_ind.main_part:=9;
              end;
            with pt_fx_prop do
              begin
                pix_srf_type                :=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
                pix_srf_type;
                value_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(pix_clp_type<<1);
                   is_fx_animate            :=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
                   is_fx_animate;
                if is_fx_animate then
                  begin
                    pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
                    pix_cfx_type;
                    pix_cng_type            :=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
                    pix_cng_type;
                    value_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                  end;
              end;
          end;
    end;
end; {$endregion}
procedure TFastimageProc.SdrType009(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    with fx_arr[0] do
      begin
        pix_clp_type:=3;
        with nt_fx_prop do
          begin
            begin_proc_ind.clip_part:=0;
            begin_proc_ind.main_part:=0;
          end;
        SetPartVal(pt_fx_prop);
        with nt_fx_prop do
          begin
                pix_srf_type                :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
                pix_srf_type;
            if (pix_srf_type<>0) then
              begin
                color_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(pix_clp_type<<1);
                   is_fx_animate            :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
                   is_fx_animate;
                if is_fx_animate then
                  begin
                    pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
                    pix_cfx_type;
                    pix_cng_type            :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
                    pix_cng_type;
                    color_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                  end;
              end
            else
              begin
                color_proc_ind.clip_part:=0;
                color_proc_ind.main_part:=9;
              end;
          end;
        fx_cnt:=1;
      end;
end; {$endregion}
procedure TFastimageProc.SdrType010(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  with fast_image_data_ do
    begin
      with fx_arr[0] do
        begin
          pix_clp_type:=3;
          SetPartVal(nt_fx_prop);
          SetPartVal(pt_fx_prop);
        end;
      for i:=1 to fx_cnt-1 do
        with fx_arr[i] do
          begin
            with nt_fx_prop do
              begin
                pix_srf_type                :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                pix_srf_type;
                value_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(pix_clp_type<<1);
                   is_fx_animate            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                   is_fx_animate;
                if is_fx_animate then
                  begin
                    pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                    pix_cfx_type;
                    pix_cng_type            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                    pix_cng_type;
                    value_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                  end;
              end;
            with pt_fx_prop do
              begin
                value_proc_ind.clip_part:=0;
                value_proc_ind.main_part:=9;
              end;
          end;
    end;
end; {$endregion}
procedure TFastimageProc.SdrType011(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  with fast_image_data_ do
    begin
      with fx_arr[0] do
        begin
          pix_clp_type:=3;
          with nt_fx_prop do
            begin
              begin_proc_ind.clip_part:=0;
              begin_proc_ind.main_part:=0;
            end;
          SetPartVal(pt_fx_prop);
          with nt_fx_prop do
            begin
                  pix_srf_type                :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
                  pix_srf_type;
              if (pix_srf_type<>0) then
                begin
                  color_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(pix_clp_type<<1);
                     is_fx_animate            :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
                     is_fx_animate;
                  if is_fx_animate then
                    begin
                      pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
                      pix_cfx_type;
                      pix_cng_type            :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
                      pix_cng_type;
                      color_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                    end;
                end
              else
                begin
                  color_proc_ind.clip_part:=0;
                  color_proc_ind.main_part:=9;
                end;
            end;
        end;
      for i:=1 to fx_cnt-1 do
        with fx_arr[i] do
          begin
            with nt_fx_prop do
              begin
                pix_srf_type                :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                pix_srf_type;
                value_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(pix_clp_type<<1);
                   is_fx_animate            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                   is_fx_animate;
                if is_fx_animate then
                  begin
                    pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                    pix_cfx_type;
                    pix_cng_type            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                    pix_cng_type;
                    value_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                  end;
              end;
            with pt_fx_prop do
              begin
                value_proc_ind.clip_part:=0;
                value_proc_ind.main_part:=9;
              end;
          end;
    end;
end; {$endregion}
procedure TFastimageProc.SdrType012(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    with fx_arr[0] do
      begin
        pix_clp_type:=3;
        SetPartVal(nt_fx_prop);
        with pt_fx_prop do
          begin
            begin_proc_ind.clip_part:=0;
            begin_proc_ind.main_part:=0;
                pix_srf_type                :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
                pix_srf_type;
            if (pix_srf_type<>0) then
              begin
                color_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(pix_clp_type<<1);
                   is_fx_animate            :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
                   is_fx_animate;
                if is_fx_animate then
                  begin
                    pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
                    pix_cfx_type;
                    pix_cng_type            :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
                    pix_cng_type;
                    color_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                  end;
              end
            else
              begin
                color_proc_ind.clip_part:=0;
                color_proc_ind.main_part:=9;
              end;
          end;
        fx_cnt:=1;
      end;
end; {$endregion}
procedure TFastimageProc.SdrType013(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  with fast_image_data_ do
    begin
      with fx_arr[0] do
        begin
          pix_clp_type:=3;
          SetPartVal(nt_fx_prop);
          SetPartVal(pt_fx_prop);
        end;
      for i:=1 to fx_cnt-1 do
        with fx_arr[i] do
          begin
            with nt_fx_prop do
              begin
                pix_srf_type                :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                pix_srf_type;
                value_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(pix_clp_type<<1);
                   is_fx_animate            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                   is_fx_animate;
                if is_fx_animate then
                  begin
                    pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                    pix_cfx_type;
                    pix_cng_type            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                    pix_cng_type;
                    value_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                  end;
              end;
            with pt_fx_prop do
              begin
                value_proc_ind.clip_part:=0;
                value_proc_ind.main_part:=9;
              end;
          end;
    end;
end; {$endregion}
procedure TFastimageProc.SdrType014(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  with fast_image_data_ do
    begin
      with fx_arr[0] do
        begin
          pix_clp_type:=3;
          SetPartVal(nt_fx_prop);
          with pt_fx_prop do
            begin
              begin_proc_ind.clip_part:=0;
              begin_proc_ind.main_part:=0;
                  pix_srf_type                :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
                  pix_srf_type;
              if (pix_srf_type<>0) then
                begin
                  color_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(pix_clp_type<<1);
                     is_fx_animate            :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
                     is_fx_animate;
                  if is_fx_animate then
                    begin
                      pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
                      pix_cfx_type;
                      pix_cng_type            :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
                      pix_cng_type;
                      color_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                    end;
                end
              else
                begin
                  color_proc_ind.clip_part:=0;
                  color_proc_ind.main_part:=9;
                end;
            end;
        end;
      for i:=1 to fx_cnt-1 do
        with fx_arr[i] do
          begin
            with nt_fx_prop do
              begin
                pix_srf_type                :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                pix_srf_type;
                value_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(pix_clp_type<<1);
                   is_fx_animate            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                   is_fx_animate;
                if is_fx_animate then
                  begin
                    pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                    pix_cfx_type;
                    pix_cng_type            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                    pix_cng_type;
                    value_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                  end;
              end;
            with pt_fx_prop do
              begin
                value_proc_ind.clip_part:=0;
                value_proc_ind.main_part:=9;
              end;
          end;
    end;
end; {$endregion}
procedure TFastimageProc.SdrType015(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    with fx_arr[0] do
      begin
        SetPartVal(nt_fx_prop);
        SetPartVal(pt_fx_prop);
        fx_cnt:=1;
      end;
end; {$endregion}
procedure TFastimageProc.SdrType016(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: shortint;
begin
  with fast_image_data_ do
    begin
      with fx_arr[0] do
        begin
          SetPartVal(nt_fx_prop);
          SetPartVal(pt_fx_prop);
        end;
      for i:=1 to fx_cnt-1 do
        with fx_arr[i] do
          begin
            with nt_fx_prop do
              begin
                pix_srf_type                :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                pix_srf_type;
                value_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(pix_clp_type<<1);
                   is_fx_animate            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                   is_fx_animate;
                if is_fx_animate then
                  begin
                    pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                    pix_cfx_type;
                    pix_cng_type            :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                    pix_cng_type;
                    value_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                  end;
              end;
            with pt_fx_prop do
              begin
                pix_srf_type                :=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
                pix_srf_type;
                value_proc_ind.clip_part    :=((pix_srf_type+1)>>1)*(pix_clp_type<<1);
                   is_fx_animate            :=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
                   is_fx_animate;
                if is_fx_animate then
                  begin
                    pix_cfx_type            :=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
                    pix_cfx_type;
                    pix_cng_type            :=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
                    pix_cng_type;
                    value_proc_ind.main_part:=((pix_srf_type+1)>>1)*(10*pix_cfx_type+pix_cng_type)+(1-(pix_srf_type+1)>>1)*9;
                  end;
              end;
          end;
    end;
end; {$endregion}
procedure TFastimageProc.SdrType017(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType016(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
procedure TFastimageProc.SdrType018(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType015(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
procedure TFastimageProc.SdrType019(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType004(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
procedure TFastimageProc.SdrType020(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType004(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
procedure TFastimageProc.SdrType021(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType015(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
procedure TFastimageProc.SdrType022(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType007(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
procedure TFastimageProc.SdrType023(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType007(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
procedure TFastimageProc.SdrType024(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  fast_image_data_.pix_clp_type:=3;
  SdrType015(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
procedure TFastimageProc.SdrType025(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType010(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
procedure TFastimageProc.SdrType026(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType010(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
procedure TFastimageProc.SdrType027(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  fast_image_data_.pix_clp_type:=3;
  SdrType015(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
procedure TFastimageProc.SdrType028(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType010(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
procedure TFastimageProc.SdrType029(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType010(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
procedure TFastimageProc.SdrType030(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrType015(fast_image_data_ptr_,fast_image_data_);
end; {$endregion}
procedure TFastimageProc.SdrType031(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {empty}
end; {$endregion}
procedure TFastimageProc.ShaderType(                    const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  {Image Description} {$region -fold}
  {
    ----------------Image Has Alpha Channel And Color Channel---------------
    0:
    image has:  not monochrome alpha channel,
                not monochrome color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels>0;

    1:
    image has:  not monochrome alpha channel,
                not monochrome color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;

    2:
    image has:  not monochrome alpha channel,
                not monochrome color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels>0;

    3:
    image has:      monochrome alpha channel(white, not transparent),
                not monochrome color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;

    4:
    image has:      monochrome alpha channel(transparent),
                not monochrome color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels>0;


    ----------------------Image Has Only Alpha Channel----------------------
    5:
    image has:  not monochrome alpha channel,
                            no color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels>0;

    6:
    image has:  not monochrome alpha channel,
                            no color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;

    7:
    image has:  not monochrome alpha channel,
                            no color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels>0;

    8:
    image has:      monochrome alpha channel(white, not transparent),
                            no color channel,
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;

    9:
    image has:      monochrome alpha channel(transparent),
                            no color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels>0;


    --------------Image Has No Alpha Channel And Color Channel--------------
    10:
    image has:      no alpha channel(black, invisible),
                    no color channel,
    count of    not transparent pixels=0;
    count of partly transparent pixels=0;

    --------------------------Image is Value Array--------------------------
    11:
    count of    not transparent pixels>0;
    count of partly transparent pixels>0;

    --------------------------Image is Mask--------------------------
    12:
    count of    not transparent pixels>0;
    count of partly transparent pixels=0;
  } {$endregion}

  case fast_image_data_.sdr_type_ind of
    000: SdrType000(fast_image_data_ptr_,fast_image_data_);
    001: SdrType001(fast_image_data_ptr_,fast_image_data_);
    002: SdrType002(fast_image_data_ptr_,fast_image_data_);
    003: SdrType003(fast_image_data_ptr_,fast_image_data_);
    004: SdrType004(fast_image_data_ptr_,fast_image_data_);
    005: SdrType005(fast_image_data_ptr_,fast_image_data_);
    006: SdrType006(fast_image_data_ptr_,fast_image_data_);
    007: SdrType007(fast_image_data_ptr_,fast_image_data_);
    008: SdrType008(fast_image_data_ptr_,fast_image_data_);
    009: SdrType009(fast_image_data_ptr_,fast_image_data_);
    010: SdrType010(fast_image_data_ptr_,fast_image_data_);
    011: SdrType011(fast_image_data_ptr_,fast_image_data_);
    012: SdrType012(fast_image_data_ptr_,fast_image_data_);
    013: SdrType013(fast_image_data_ptr_,fast_image_data_);
    014: SdrType014(fast_image_data_ptr_,fast_image_data_);
    015: SdrType015(fast_image_data_ptr_,fast_image_data_);
    016: SdrType016(fast_image_data_ptr_,fast_image_data_);
    017: SdrType017(fast_image_data_ptr_,fast_image_data_);
    018: SdrType018(fast_image_data_ptr_,fast_image_data_);
    019: SdrType019(fast_image_data_ptr_,fast_image_data_);
    020: SdrType020(fast_image_data_ptr_,fast_image_data_);
    021: SdrType021(fast_image_data_ptr_,fast_image_data_);
    022: SdrType022(fast_image_data_ptr_,fast_image_data_);
    023: SdrType023(fast_image_data_ptr_,fast_image_data_);
    024: SdrType024(fast_image_data_ptr_,fast_image_data_);
    025: SdrType025(fast_image_data_ptr_,fast_image_data_);
    026: SdrType026(fast_image_data_ptr_,fast_image_data_);
    027: SdrType027(fast_image_data_ptr_,fast_image_data_);
    028: SdrType028(fast_image_data_ptr_,fast_image_data_);
    029: SdrType029(fast_image_data_ptr_,fast_image_data_);
    030: SdrType030(fast_image_data_ptr_,fast_image_data_);
    031: SdrType030(fast_image_data_ptr_,fast_image_data_);
    032: SdrType030(fast_image_data_ptr_,fast_image_data_);
    033: SdrType030(fast_image_data_ptr_,fast_image_data_);
    034: SdrType030(fast_image_data_ptr_,fast_image_data_);
    035: SdrType030(fast_image_data_ptr_,fast_image_data_);
    036: SdrType009(fast_image_data_ptr_,fast_image_data_);
    037: SdrType010(fast_image_data_ptr_,fast_image_data_);
    038: SdrType011(fast_image_data_ptr_,fast_image_data_);
  end;

end; {$endregion}
// Set Sprite Bounding Rectangle:
procedure TFastimageProc.SRIProcInit;                                                                                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SRIProc[0]:=@SetRctInv0;
  SRIProc[1]:=@SetRctInv1;
  SRIProc[2]:=@SetRctInv2;
  SRIProc[3]:=@SetRctInv3;
end; {$endregion}
procedure TFastimageProc.SetRctInv0(                                                               var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TFastimageProc.SetRctInv1(                                                               var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,rct_src do
    begin
      rct_src_res.left :=left;
      rct_src_res.right:=right;
                  left :=bmp_ftimg_width_origin{rct_ent.width}-rct_src_res.right;
                  right:=bmp_ftimg_width_origin{rct_ent.width}-rct_src_res.left;
    end;
end; {$endregion}
procedure TFastimageProc.SetRctInv2(                                                               var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,rct_src do
    begin
      rct_src_res.top   :=top;
      rct_src_res.bottom:=bottom;
                  top   :=bmp_ftimg_height_origin{rct_ent.height}-rct_src_res.bottom;
                  bottom:=bmp_ftimg_height_origin{rct_ent.height}-rct_src_res.top;
    end;
end; {$endregion}
procedure TFastimageProc.SetRctInv3(                                                               var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,rct_src do
    begin
      rct_src_res.left  :=left;
      rct_src_res.right :=right;
      rct_src_res.top   :=top;
      rct_src_res.bottom:=bottom;
                  left  :=bmp_ftimg_width_origin {rct_ent.width }-rct_src_res.right;
                  right :=bmp_ftimg_width_origin {rct_ent.width }-rct_src_res.left;
                  top   :=bmp_ftimg_height_origin{rct_ent.height}-rct_src_res.bottom;
                  bottom:=bmp_ftimg_height_origin{rct_ent.height}-rct_src_res.top;
    end;
end; {$endregion}
// Reset Sprite Bounding Rectangle:
procedure TFastimageProc.RRIProcInit;                                                                                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RRIProc[0]:=@ResRctInv0;
  RRIProc[1]:=@ResRctInv1;
  RRIProc[2]:=@ResRctInv2;
  RRIProc[3]:=@ResRctInv3;
end; {$endregion}
procedure TFastimageProc.ResRctInv0(                                                               var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TFastimageProc.ResRctInv1(                                                               var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,rct_src do
    begin
      left :=rct_src_res.left;
      right:=rct_src_res.right;
    end;
end; {$endregion}
procedure TFastimageProc.ResRctInv2(                                                               var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,rct_src do
    begin
      top   :=rct_src_res.top;
      bottom:=rct_src_res.bottom;
    end;
end; {$endregion}
procedure TFastimageProc.ResRctInv3(                                                               var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,rct_src do
    begin
      left  :=rct_src_res.left;
      right :=rct_src_res.right;
      top   :=rct_src_res.top;
      bottom:=rct_src_res.bottom;
    end;
end; {$endregion}
// CPU Shader Proc.:
procedure TFastimageProc.SdrProcInit;                                                                                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SdrProc[0]:=@UberShader0;
  SdrProc[1]:=@UberShader1;
  SdrProc[2]:=@UberShader2;
  SdrProc[3]:=@UberShader3;
  SdrProc[4]:=@UberShader4;
  SdrProc[5]:=@UberShader5;
  SdrProc[6]:=@UberShader6;
  SdrProc[7]:=@UberShader7;
end; {$endregion}
procedure TFastimageProc.SdrProcInd (                                                              var fast_image_data_:TFastImageData);       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      if (nt_pix_cnt<>0) then
        begin
          if (pt_pix_cnt<>0) then
            sdr_proc_ind:=3
          else
            sdr_proc_ind:=1;
        end
      else
        begin
          if (pt_pix_cnt<>0) then
            sdr_proc_ind:=2
          else
            begin
              if (ft_pix_cnt<>0) then
                begin
                  sdr_proc_ind:=1;
                  Exit;
                end;
              sdr_proc_ind:=0;
            end;
        end;
    end;
end; {$endregion}
procedure TFastimageProc.UberShader0(const x,y:integer; const fast_image_data_ptr_:PFastImageData; const index:PtrInt=0; const block_count:integer=1); {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TFastimageProc.UberShader1(const x,y:integer; const fast_image_data_ptr_:PFastImageData; const index:PtrInt=0; const block_count:integer=1); {$ifdef Linux}[local];{$endif} {$region -fold}
var
//fast_image_data_arr    : TFastImageData;
  fast_image_data_arr_ptr: PFastImageData;
  rct_clp_               : TPtRect;
  i,j                    : shortint;
begin

  {
  with fast_image_data_ptr0^ do
    begin

      {Set Bounding Rect. Pos.}
      SetRctPos(x,y,fast_image_data_ptr0^);

      {Sprite Bounding Rect.}
      SetRctDst0(fast_image_data_ptr0^);
      if (pix_clp_type=3) then
        Exit;
      SetRctSrc(fast_image_data_ptr0^);
      SRIProc[img_inv_type](fast_image_data_ptr0^);

      {Sprite Shader Type}
      SetSdrType(fast_image_data_ptr0^);
         SdrType[sdr_type_ind](fast_image_data_ptr0,fast_image_data_ptr0^); {ShaderType;}

      {Sprite Drawing}
      if (pix_drw_type<>1) then
        begin
          cfx_pow0:=      fx_arr[0].nt_fx_prop.cfx_pow0;
          if (cfx_pow0<>0) then
            with          fx_arr[0].nt_fx_prop do
              begin
                pt_as_nt:=fx_arr[0].pt_as_nt;
                GenNTBeginProc  [begin_proc_ind.main_part+begin_proc_ind.clip_part](fast_image_data_ptr0,fast_image_data_ptr0^);
                if (not is_fx_gradvec) then
                  RegNTColorProc[color_proc_ind.main_part+color_proc_ind.clip_part](fast_image_data_ptr0,fast_image_data_ptr0^)
                else
                if (grad_vec.y>grad_vec.x) then
                  GrVNTColorProc[color_proc_ind.main_part+color_proc_ind.clip_part](fast_image_data_ptr0,fast_image_data_ptr0^);
              end;
        end;

      {Sprite Post-Processing}
      if (pix_drw_type<>0) then
        for i:=1 to fx_cnt-1 do
          begin
            cfx_pow0:=         fx_arr[i].nt_fx_prop.cfx_pow0;
            if (cfx_pow0<>0) then
              for j:=0 to      fx_arr[i].nt_fx_prop.rep_cnt-1 do
                begin
                  pt_as_nt   :=fx_arr[i].pt_as_nt;
                  with         fx_arr[i].nt_fx_prop do
                    if (not is_fx_gradvec) then
                      RegNTValueProc[value_proc_ind.main_part+value_proc_ind.clip_part](fast_image_data_ptr0,fast_image_data_ptr0^)
                    else
                    if (grad_vec.y>grad_vec.x) then
                      GrVNTValueProc[value_proc_ind.main_part+value_proc_ind.clip_part](fast_image_data_ptr0,fast_image_data_ptr0^);
                end;
          end;

      {Reset Sprite Bounding Rect.}
      RRIProc[img_inv_type](fast_image_data_ptr0^);

    end;
  }

  fast_image_data_arr_ptr:=@fast_image_data_arr[index];

  with fast_image_data_arr_ptr^ do
    begin

      {Check Scale Multiplayer---} {$region -fold}
      SclMulCheck(fast_image_data_arr_ptr^);
      if (scl_mul_check=3) then
        Exit; {$endregion}

      {Set Bounding Rect. Pos.---} {$region -fold}
      bmp_src_rct_clp                        :=fast_image_data_ptr_^.bmp_src_rct_clp;
      rct_ent.width                          :=fast_image_data_ptr_^.rct_ent.width {bmp_src_rct_clp.width };
      rct_ent.height                         :=fast_image_data_ptr_^.rct_ent.height{bmp_src_rct_clp.height};
      SetRctPos(x,y,                           fast_image_data_arr_ptr^); {$endregion}

      {Sprite Bounding Rct.------} {$region -fold}
      rct_clp_                               :=SetRct(index,fast_image_data_ptr_^.rct_clp_ptr^,block_count);
      rct_clp_ptr                            :=@rct_clp_; // fast_image_data_ptr_^.rct_clp_ptr;
    //rct_clp_ptr^                           :=fast_image_data_ptr_^.rct_clp_ptr^;
      is_frame_animate                       :=fast_image_data_ptr_^.is_frame_animate;
      rct_src_mrg                            :=fast_image_data_ptr_^.rct_src_mrg;

      {with fast_image_data_ptr_^ do
        if (scl_mul_check=0) then
          begin
            SetRctDst0(fast_image_data_ptr_^);
            if (pix_clp_type=3) then
              Exit;
            SetRctSrc (fast_image_data_ptr_^);
          end;}

      if (scl_mul_check=0) then
        begin
          SetRctDst0                          (fast_image_data_arr_ptr^);
          if (pix_clp_type=3) then
            Exit;
          SetRctSrc                           (fast_image_data_arr_ptr^);
          bmp_ftimg_width_origin             :=fast_image_data_ptr_^.bmp_ftimg_width_origin;
          bmp_ftimg_height_origin            :=fast_image_data_ptr_^.bmp_ftimg_height_origin;
                     img_inv_type            :=fast_image_data_ptr_^.img_inv_type;
          SRIProc   [img_inv_type]            (fast_image_data_arr_ptr^);
        end
      else
        begin
          bmp_ftimg_width_origin             :=fast_image_data_ptr_^.bmp_ftimg_width_origin;
          bmp_ftimg_height_origin            :=fast_image_data_ptr_^.bmp_ftimg_height_origin;
                     img_inv_type            :=fast_image_data_ptr_^.img_inv_type;

          pvt0.x                             :=rct_ent.left+bmp_ftimg_width_origin >>1;
          pvt0.y                             :=rct_ent.top +bmp_ftimg_height_origin>>1;

          SetRctDst1                          (fast_image_data_arr_ptr^);
          if (pix_clp_type=3) then
            Exit;
        end; {$endregion}

      {Sprite Shader Type--------} {$region -fold}
      fx_cnt                                 :=fast_image_data_ptr_^.fx_cnt;
      img_kind                               :=fast_image_data_ptr_^.img_kind;
      pix_drw_type                           :=fast_image_data_ptr_^.pix_drw_type;
      sdr_proc_ind                           :=fast_image_data_ptr_^.sdr_proc_ind;
      SetSdrType                              (fast_image_data_arr_ptr^);
         SdrType[sdr_type_ind]                (fast_image_data_ptr_, // ShaderType;
                                               fast_image_data_arr_ptr^); {$endregion}

      {--------------------------} {$region -fold}
      bmp_bkgnd_width                        :=fast_image_data_ptr_^.bmp_bkgnd_width; {$endregion}

      {Sprite Drawing------------} {$region -fold}
      if (pix_drw_type<>1) then
        begin
                                                                     fx_arr[0].nt_fx_prop.
          cfx_pow0                           :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
          cfx_pow0;
          cfx_pow0                           :=                      fx_arr[0].nt_fx_prop.cfx_pow0;
          if (cfx_pow0<>0) then
            with                                                     fx_arr[0].nt_fx_prop do
              begin
                                                                     fx_arr[0].pt_as_nt:=
                                               fast_image_data_ptr_^.fx_arr[0].pt_as_nt;
                pt_as_nt                     :=                      fx_arr[0].pt_as_nt;
                GenNTBeginProc  [              fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.begin_proc_ind.main_part+
                                                                                          begin_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                              is_fx_gradvec  :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.is_fx_gradvec;
                case scl_mul_check of
                  0:
                    begin
                      if (not is_fx_gradvec) then
                        RegNTColorProc[        fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                      else
                      if (grad_prop.grad_vec_dif>0) then
                        GrVNTColorProc[        fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                    end;
                  1:
                    begin
                      if (not is_fx_gradvec) then
                        RSDNTColorProc[        fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                      else
                      if (grad_prop.grad_vec_dif>0) then
                        GSDNTColorProc[        fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                    end;
                  2:
                    begin
                      if (not is_fx_gradvec) then
                        RSUNTColorProc[        fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                      else
                      if (grad_prop.grad_vec_dif>0) then
                        GSUNTColorProc[        fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                    end;
                end;
              end;
        end; {$endregion}

      {Sprite Post-Process.------} {$region -fold}
      if (pix_drw_type<>0) then
        for i:=1 to fx_cnt-1 do
          begin
                                                                     fx_arr[i].nt_fx_prop.
            cfx_pow0                         :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
            cfx_pow0;
            cfx_pow0                         :=                      fx_arr[i].nt_fx_prop.cfx_pow0;
            if (cfx_pow0<>0) then
              begin
                                                                     fx_arr[i].nt_fx_prop.rep_cnt:=
                                               fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.rep_cnt;
                for j:=0 to                                          fx_arr[i].nt_fx_prop.rep_cnt-1 do
                  begin
                                                                     fx_arr[i].pt_as_nt:=
                                               fast_image_data_ptr_^.fx_arr[i].pt_as_nt;
                    pt_as_nt                 :=                      fx_arr[i].pt_as_nt;
                    with                                             fx_arr[i].nt_fx_prop do
                      begin
                                is_fx_gradvec:=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                                is_fx_gradvec;
                        case scl_mul_check of
                          0:
                            begin
                              if (not is_fx_gradvec) then
                                RegNTValueProc[fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                              else
                              if (grad_prop.grad_vec_dif>0) then
                                GrVNTValueProc[fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                            end;
                          1:
                            begin
                              if (not is_fx_gradvec) then
                                RSDNTValueProc[fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                              else
                              if (grad_prop.grad_vec_dif>0) then
                                GSDNTValueProc[fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                            end;
                          2:
                            begin
                              if (not is_fx_gradvec) then
                                RSUNTValueProc[fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                              else
                              if (grad_prop.grad_vec_dif>0) then
                                GSUNTValueProc[fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                            end;
                        end;
                      end;
                  end;
              end;
          end; {$endregion}

      {Reset Sprite Bounding Rct.} {$region -fold}
      if (scl_mul_check=0) then
        RRIProc[img_inv_type]                 (fast_image_data_arr_ptr^); {$endregion}

    end;
end; {$endregion}
procedure TFastimageProc.UberShader2(const x,y:integer; const fast_image_data_ptr_:PFastImageData; const index:PtrInt=0; const block_count:integer=1); {$ifdef Linux}[local];{$endif} {$region -fold}
var
//fast_image_data_arr    : TFastImageData;
  fast_image_data_arr_ptr: PFastImageData;
  rct_clp_               : TPtRect;
  i,j                    : shortint;
begin
  fast_image_data_arr_ptr:=@fast_image_data_arr[index];

  with fast_image_data_arr_ptr^ do
    begin

      {Check Scale Multiplayer---} {$region -fold}
      SclMulCheck(fast_image_data_arr_ptr^);
      if (scl_mul_check=3) then
        Exit; {$endregion}

      {Set Bounding Rect. Pos.---} {$region -fold}
      bmp_src_rct_clp                        :=fast_image_data_ptr_^.bmp_src_rct_clp;
      rct_ent.width                          :=fast_image_data_ptr_^.rct_ent.width {bmp_src_rct_clp.width };
      rct_ent.height                         :=fast_image_data_ptr_^.rct_ent.height{bmp_src_rct_clp.height};
      SetRctPos(x,y,                           fast_image_data_arr_ptr^); {$endregion}

      {Sprite Bounding Rct.------} {$region -fold}
      rct_clp_                               :=SetRct(index,fast_image_data_ptr_^.rct_clp_ptr^,block_count);
      rct_clp_ptr                            :=@rct_clp_; // fast_image_data_ptr_^.rct_clp_ptr;
    //rct_clp_ptr^                           :=fast_image_data_ptr_^.rct_clp_ptr^;
      is_frame_animate                       :=fast_image_data_ptr_^.is_frame_animate;
      rct_src_mrg                            :=fast_image_data_ptr_^.rct_src_mrg;

      {with fast_image_data_ptr_^ do
        begin
          SetRctDst0(fast_image_data_ptr_^);
          if (pix_clp_type=3) then
            Exit;
          SetRctSrc (fast_image_data_ptr_^);
        end;}

      if (scl_mul_check=0) then
        begin
          SetRctDst0                          (fast_image_data_arr_ptr^);
          if (pix_clp_type=3) then
            Exit;
          SetRctSrc                           (fast_image_data_arr_ptr^);
          bmp_ftimg_width_origin             :=fast_image_data_ptr_^.bmp_ftimg_width_origin;
          bmp_ftimg_height_origin            :=fast_image_data_ptr_^.bmp_ftimg_height_origin;
                     img_inv_type            :=fast_image_data_ptr_^.img_inv_type;
          SRIProc   [img_inv_type]            (fast_image_data_arr_ptr^);
        end
      else
        begin
          bmp_ftimg_width_origin             :=fast_image_data_ptr_^.bmp_ftimg_width_origin;
          bmp_ftimg_height_origin            :=fast_image_data_ptr_^.bmp_ftimg_height_origin;
                     img_inv_type            :=fast_image_data_ptr_^.img_inv_type;

          pvt0.x                             :=rct_ent.left+bmp_ftimg_width_origin >>1;
          pvt0.y                             :=rct_ent.top +bmp_ftimg_height_origin>>1;

          SetRctDst1                          (fast_image_data_arr_ptr^);
          if (pix_clp_type=3) then
            Exit;
        end; {$endregion}

      {Sprite Shader Type--------} {$region -fold}
      fx_cnt                                 :=fast_image_data_ptr_^.fx_cnt;
      img_kind                               :=fast_image_data_ptr_^.img_kind;
      pix_drw_type                           :=fast_image_data_ptr_^.pix_drw_type;
      sdr_proc_ind                           :=fast_image_data_ptr_^.sdr_proc_ind;
      SetSdrType                              (fast_image_data_arr_ptr^);
         SdrType[sdr_type_ind]                (fast_image_data_ptr_, // ShaderType;
                                               fast_image_data_arr_ptr^); {$endregion}

      {--------------------------} {$region -fold}
      bmp_bkgnd_width                        :=fast_image_data_ptr_^.bmp_bkgnd_width; {$endregion}

      {Sprite Drawing------------} {$region -fold}
      if (pix_drw_type<>1) then
        begin
                                                                     fx_arr[0].pt_fx_prop.
          cfx_pow0                           :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
          cfx_pow0;
          cfx_pow0                           :=                      fx_arr[0].pt_fx_prop.cfx_pow0;
          if (cfx_pow0<>0) then
            with                                                     fx_arr[0].pt_fx_prop do
              begin
                                                                     fx_arr[0].pt_as_nt:=
                                               fast_image_data_ptr_^.fx_arr[0].pt_as_nt;
                pt_as_nt                     :=                      fx_arr[0].pt_as_nt;
                GenPTBeginProc  [              fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.begin_proc_ind.main_part+
                                                                                          begin_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                              is_fx_gradvec  :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.is_fx_gradvec;
                case scl_mul_check of
                  0:
                    begin
                      if (not is_fx_gradvec) then
                        RegPTColorProc[        fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                      else
                      if (grad_prop.grad_vec_dif>0) then
                        GrVPTColorProc[        fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                    end;
                  1:
                    begin
                      if (not is_fx_gradvec) then
                        RSDPTColorProc[        fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                      else
                      if (grad_prop.grad_vec_dif>0) then
                        GSDPTColorProc[        fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                    end;
                  2:
                    begin
                      if (not is_fx_gradvec) then
                        RSUPTColorProc[        fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                      else
                      if (grad_prop.grad_vec_dif>0) then
                        GSUPTColorProc[        fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                    end;
                end;
              end;
        end; {$endregion}

      {Sprite Post-Process.------} {$region -fold}
      if (pix_drw_type<>0) then
        for i:=1 to fx_cnt-1 do
          begin
                                                                     fx_arr[i].pt_fx_prop.
            cfx_pow0                         :=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
            cfx_pow0;
            cfx_pow0                         :=                      fx_arr[i].pt_fx_prop.cfx_pow0;
            if (cfx_pow0<>0) then
              begin
                                                                     fx_arr[i].pt_fx_prop.rep_cnt:=
                                               fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.rep_cnt;
                for j:=0 to                                          fx_arr[i].pt_fx_prop.rep_cnt-1 do
                  begin
                                                                     fx_arr[i].pt_as_nt:=
                                               fast_image_data_ptr_^.fx_arr[i].pt_as_nt;
                    pt_as_nt                 :=                      fx_arr[i].pt_as_nt;
                    with                                             fx_arr[i].pt_fx_prop do
                      begin
                                is_fx_gradvec:=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
                                is_fx_gradvec;
                        case scl_mul_check of
                          0:
                            begin
                              if (not is_fx_gradvec) then
                                RegPTValueProc[fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                              else
                              if (grad_prop.grad_vec_dif>0) then
                                GrVPTValueProc[fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                            end;
                          1:
                            begin
                              if (not is_fx_gradvec) then
                                RSDPTValueProc[fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                              else
                              if (grad_prop.grad_vec_dif>0) then
                                GSDPTValueProc[fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                            end;
                          2:
                            begin
                              if (not is_fx_gradvec) then
                                RSUPTValueProc[fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                              else
                              if (grad_prop.grad_vec_dif>0) then
                                GSUPTValueProc[fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                            end;
                        end;
                      end;
                  end;
              end;
          end; {$endregion}

      {Reset Sprite Bounding Rct.} {$region -fold}
      if (scl_mul_check=0) then
        RRIProc[img_inv_type]                 (fast_image_data_arr_ptr^); {$endregion}

    end;
end; {$endregion}
procedure TFastimageProc.UberShader3(const x,y:integer; const fast_image_data_ptr_:PFastImageData; const index:PtrInt=0; const block_count:integer=1); {$ifdef Linux}[local];{$endif} {$region -fold}
var
//fast_image_data_arr    : TFastImageData;
  fast_image_data_arr_ptr: PFastImageData;
  rct_clp_               : TPtRect;
  i,j                    : shortint;
begin
  fast_image_data_arr_ptr:=@fast_image_data_arr[index];

  with fast_image_data_arr_ptr^ do
    begin

      {Check Scale Multiplayer---} {$region -fold}
      SclMulCheck(fast_image_data_arr_ptr^);
      if (scl_mul_check=3) then
        Exit; {$endregion}

      {Set Bounding Rect. Pos.---} {$region -fold}
      bmp_src_rct_clp                        :=fast_image_data_ptr_^.bmp_src_rct_clp;
      rct_ent.width                          :=fast_image_data_ptr_^.rct_ent.width {bmp_src_rct_clp.width };
      rct_ent.height                         :=fast_image_data_ptr_^.rct_ent.height{bmp_src_rct_clp.height};
      SetRctPos(x,y,                           fast_image_data_arr_ptr^); {$endregion}

      {Sprite Bounding Rct.------} {$region -fold}
      rct_clp_                               :=SetRct(index,fast_image_data_ptr_^.rct_clp_ptr^,block_count);
      rct_clp_ptr                            :=@rct_clp_; // fast_image_data_ptr_^.rct_clp_ptr;
    //rct_clp_ptr^                           :=fast_image_data_ptr_^.rct_clp_ptr^;
      is_frame_animate                       :=fast_image_data_ptr_^.is_frame_animate;
      rct_src_mrg                            :=fast_image_data_ptr_^.rct_src_mrg;

      {with fast_image_data_ptr_^ do
        begin
          SetRctDst0(fast_image_data_ptr_^);
          if (pix_clp_type=3) then
            Exit;
          SetRctSrc (fast_image_data_ptr_^);
        end;}

      if (scl_mul_check=0) then
        begin
          SetRctDst0                          (fast_image_data_arr_ptr^);
          if (pix_clp_type=3) then
            Exit;
          SetRctSrc                           (fast_image_data_arr_ptr^);
          bmp_ftimg_width_origin             :=fast_image_data_ptr_^.bmp_ftimg_width_origin;
          bmp_ftimg_height_origin            :=fast_image_data_ptr_^.bmp_ftimg_height_origin;
                     img_inv_type            :=fast_image_data_ptr_^.img_inv_type;
          SRIProc   [img_inv_type]            (fast_image_data_arr_ptr^);
        end
      else
        begin
          bmp_ftimg_width_origin             :=fast_image_data_ptr_^.bmp_ftimg_width_origin;
          bmp_ftimg_height_origin            :=fast_image_data_ptr_^.bmp_ftimg_height_origin;
                     img_inv_type            :=fast_image_data_ptr_^.img_inv_type;

          pvt0.x                             :=rct_ent.left+bmp_ftimg_width_origin >>1;
          pvt0.y                             :=rct_ent.top +bmp_ftimg_height_origin>>1;

          SetRctDst1                          (fast_image_data_arr_ptr^);

          //F_MainForm.M_Test_Log.Lines.Text   :=IntToStr(pix_clp_type);

          if (pix_clp_type=3) then
            Exit;
        end; {$endregion}

      {Sprite Shader Type--------} {$region -fold}
      fx_cnt                                 :=fast_image_data_ptr_^.fx_cnt;
      img_kind                               :=fast_image_data_ptr_^.img_kind;
      pix_drw_type                           :=fast_image_data_ptr_^.pix_drw_type;
      sdr_proc_ind                           :=fast_image_data_ptr_^.sdr_proc_ind;
      SetSdrType                              (fast_image_data_arr_ptr^);
         SdrType[sdr_type_ind]                (fast_image_data_ptr_, // ShaderType;
                                               fast_image_data_arr_ptr^); {$endregion}

      {--------------------------} {$region -fold}
      bmp_bkgnd_width                        :=fast_image_data_ptr_^.bmp_bkgnd_width; {$endregion}

      {Sprite Drawing------------} {$region -fold}
      if (pix_drw_type<>1) then
        begin
                                                                     fx_arr[0].nt_fx_prop.
          cfx_pow0                           :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.
          cfx_pow0;
          cfx_pow0                           :=                      fx_arr[0].nt_fx_prop.cfx_pow0;
          if (cfx_pow0<>0) then
            with                                                     fx_arr[0].nt_fx_prop do
              begin
                                                                     fx_arr[0].pt_as_nt:=
                                               fast_image_data_ptr_^.fx_arr[0].pt_as_nt;
                pt_as_nt                     :=                      fx_arr[0].pt_as_nt;
                GenNTBeginProc  [              fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.begin_proc_ind.main_part+
                                                                                          begin_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                              is_fx_gradvec  :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.is_fx_gradvec;
                case scl_mul_check of
                  0:
                    begin
                      if (not is_fx_gradvec) then
                        RegNTColorProc[        fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                      else
                      if (grad_prop.grad_vec_dif>0) then
                        GrVNTColorProc[        fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                    end;
                  1:
                    begin
                      if (not is_fx_gradvec) then
                        RSDNTColorProc[        fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                      else
                      if (grad_prop.grad_vec_dif>0) then
                        GSDNTColorProc[        fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                    end;
                  2:
                    begin
                      if (not is_fx_gradvec) then
                        RSUNTColorProc[        fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                      else
                      if (grad_prop.grad_vec_dif>0) then
                        GSUNTColorProc[        fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                    end;
                end;
              end;
          //{
                                                                     fx_arr[0].pt_fx_prop.
          cfx_pow0                           :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.
          cfx_pow0;
          cfx_pow0                           :=                      fx_arr[0].pt_fx_prop.cfx_pow0;
          if (cfx_pow0<>0) then
            with                                                     fx_arr[0].pt_fx_prop do
              begin
                                                                     fx_arr[0].pt_as_nt:=
                                               fast_image_data_ptr_^.fx_arr[0].pt_as_nt;
                pt_as_nt                     :=                      fx_arr[0].pt_as_nt;
                GenPTBeginProc  [              fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.begin_proc_ind.main_part+
                                                                                          begin_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                              is_fx_gradvec  :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.is_fx_gradvec;
                case scl_mul_check of
                  0:
                    begin
                      if (not is_fx_gradvec) then
                        RegPTColorProc[        fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                      else
                      if (grad_prop.grad_vec_dif>0) then
                        GrVPTColorProc[        fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                    end;
                  1:
                    begin
                      if (not is_fx_gradvec) then
                        RSDPTColorProc[        fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                      else
                      if (grad_prop.grad_vec_dif>0) then
                        GSDPTColorProc[        fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                    end;
                  2:
                    begin
                      if (not is_fx_gradvec) then
                        RSUPTColorProc[        fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                      else
                      if (grad_prop.grad_vec_dif>0) then
                        GSUPTColorProc[        fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                    end;
                end;
              end;
          //}
        end; {$endregion}

      {Sprite Post-Process.------} {$region -fold}
      if (pix_drw_type<>0) then
        for i:=1 to fx_cnt-1 do
          begin
                                                                     fx_arr[i].nt_fx_prop.
            cfx_pow0                         :=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
            cfx_pow0;
            cfx_pow0                         :=                      fx_arr[i].nt_fx_prop.cfx_pow0;
            if (cfx_pow0<>0) then
              begin
                                                                     fx_arr[i].nt_fx_prop.rep_cnt:=
                                               fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.rep_cnt;
                for j:=0 to                                          fx_arr[i].nt_fx_prop.rep_cnt-1 do
                  begin
                                                                     fx_arr[i].pt_as_nt:=
                                               fast_image_data_ptr_^.fx_arr[i].pt_as_nt;
                    pt_as_nt                 :=                      fx_arr[i].pt_as_nt;
                    with                                             fx_arr[i].nt_fx_prop do
                      begin
                                is_fx_gradvec:=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                                is_fx_gradvec;
                        case scl_mul_check of
                          0:
                            begin
                              if (not is_fx_gradvec) then
                                RegNTValueProc[fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                              else
                              if (grad_prop.grad_vec_dif>0) then
                                GrVNTValueProc[fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                            end;
                          1:
                            begin
                              if (not is_fx_gradvec) then
                                RSDNTValueProc[fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                              else
                              if (grad_prop.grad_vec_dif>0) then
                                GSDNTValueProc[fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                            end;
                          2:
                            begin
                              if (not is_fx_gradvec) then
                                RSUNTValueProc[fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                              else
                              if (grad_prop.grad_vec_dif>0) then
                                GSUNTValueProc[fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                            end;
                        end;
                      end;
                  end;
              end;
            //{
                                                                     fx_arr[i].pt_fx_prop.
            cfx_pow0                         :=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
            cfx_pow0;
            cfx_pow0                         :=                      fx_arr[i].pt_fx_prop.cfx_pow0;
            if (cfx_pow0<>0) then
              begin
                                                                     fx_arr[i].pt_fx_prop.rep_cnt:=
                                               fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.rep_cnt;
                for j:=0 to                                          fx_arr[i].pt_fx_prop.rep_cnt-1 do
                  begin
                                                                     fx_arr[i].pt_as_nt:=
                                               fast_image_data_ptr_^.fx_arr[i].pt_as_nt;
                    pt_as_nt                 :=                      fx_arr[i].pt_as_nt;
                    with                                             fx_arr[i].pt_fx_prop do
                      begin
                                is_fx_gradvec:=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
                                is_fx_gradvec;
                        case scl_mul_check of
                          0:
                            begin
                              if (not is_fx_gradvec) then
                                RegPTValueProc[fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                              else
                              if (grad_prop.grad_vec_dif>0) then
                                GrVPTValueProc[fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                            end;
                          1:
                            begin
                              if (not is_fx_gradvec) then
                                RSDPTValueProc[fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                              else
                              if (grad_prop.grad_vec_dif>0) then
                                GSDPTValueProc[fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                            end;
                          2:
                            begin
                              if (not is_fx_gradvec) then
                                RSUPTValueProc[fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                              else
                              if (grad_prop.grad_vec_dif>0) then
                                GSUPTValueProc[fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                            end;
                        end;
                      end;
                  end;
              end;
            //}
          end; {$endregion}

      {Reset Sprite Bounding Rct.} {$region -fold}
      if (scl_mul_check=0) then
        RRIProc[img_inv_type]                 (fast_image_data_arr_ptr^); {$endregion}

    end;
end; {$endregion}
procedure TFastimageProc.UberShader4(const x,y:integer; const fast_image_data_ptr_:PFastImageData; const index:PtrInt=0; const block_count:integer=1); {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TFastimageProc.UberShader5(const x,y:integer; const fast_image_data_ptr_:PFastImageData; const index:PtrInt=0; const block_count:integer=1); {$ifdef Linux}[local];{$endif} {$region -fold}
var
//fast_image_data_arr    : TFastImageData;
  fast_image_data_arr_ptr: PFastImageData;
  rct_clp_               : TPtRect;
  i,j                    : shortint;
begin

  fast_image_data_arr_ptr:=@fast_image_data_arr[index];

  with fast_image_data_arr_ptr^ do
    begin

      {Check Scale Multiplayer---} {$region -fold}
      SclMulCheck(fast_image_data_arr_ptr^);
      if (scl_mul_check=3) then
        Exit; {$endregion}

      {Set Bounding Rect. Pos.---} {$region -fold}
      bmp_src_rct_clp                        :=fast_image_data_ptr_^.bmp_src_rct_clp;
      rct_ent.width                          :=fast_image_data_ptr_^.rct_ent.width {bmp_src_rct_clp.width };
      rct_ent.height                         :=fast_image_data_ptr_^.rct_ent.height{bmp_src_rct_clp.height};
      SetRctPos(x,y,                           fast_image_data_arr_ptr^); {$endregion}

      {Sprite Bounding Rct.------} {$region -fold}
      rct_clp_                               :=SetRct(index,fast_image_data_ptr_^.rct_clp_ptr^,block_count);
      rct_clp_ptr                            :=@rct_clp_; // fast_image_data_ptr_^.rct_clp_ptr;
    //rct_clp_ptr^                           :=fast_image_data_ptr_^.rct_clp_ptr^;
      is_frame_animate                       :=fast_image_data_ptr_^.is_frame_animate;
      rct_src_mrg                            :=fast_image_data_ptr_^.rct_src_mrg;

      {with fast_image_data_ptr_^ do
        begin
          SetRctDst0(fast_image_data_ptr_^);
          if (pix_clp_type=3) then
            Exit;
          SetRctSrc (fast_image_data_ptr_^);
        end;}

      if (scl_mul_check=0) then
        begin
          SetRctDst0                          (fast_image_data_arr_ptr^);
          if (pix_clp_type=3) then
            Exit;
          SetRctSrc                           (fast_image_data_arr_ptr^);
          bmp_ftimg_width_origin             :=fast_image_data_ptr_^.bmp_ftimg_width_origin;
          bmp_ftimg_height_origin            :=fast_image_data_ptr_^.bmp_ftimg_height_origin;
                     img_inv_type            :=fast_image_data_ptr_^.img_inv_type;
          SRIProc   [img_inv_type]            (fast_image_data_arr_ptr^);
        end
      else
        begin
          bmp_ftimg_width_origin             :=fast_image_data_ptr_^.bmp_ftimg_width_origin;
          bmp_ftimg_height_origin            :=fast_image_data_ptr_^.bmp_ftimg_height_origin;
                     img_inv_type            :=fast_image_data_ptr_^.img_inv_type;

          pvt0.x                             :=rct_ent.left+bmp_ftimg_width_origin >>1;
          pvt0.y                             :=rct_ent.top +bmp_ftimg_height_origin>>1;

          SetRctDst1                          (fast_image_data_arr_ptr^);
          if (pix_clp_type=3) then
            Exit;
        end; {$endregion}

      {Sprite Shader Type--------} {$region -fold}
      fx_cnt                                 :=fast_image_data_ptr_^.fx_cnt;
      img_kind                               :=fast_image_data_ptr_^.img_kind;
      pix_drw_type                           :=fast_image_data_ptr_^.pix_drw_type;
      sdr_proc_ind                           :=fast_image_data_ptr_^.sdr_proc_ind;
      SetSdrType                              (fast_image_data_arr_ptr^);
         SdrType[sdr_type_ind]                (fast_image_data_ptr_, // ShaderType;
                                               fast_image_data_arr_ptr^); {$endregion}

      {--------------------------} {$region -fold}
      bmp_bkgnd_width                        :=fast_image_data_ptr_^.bmp_bkgnd_width; {$endregion}

      {Sprite Drawing------------} {$region -fold}
      if (pix_drw_type<>1) then
        begin
          cfx_pow0                           :=                      fx_arr[0].nt_fx_prop.cfx_pow0;
          if (cfx_pow0<>0) then
            with                                                     fx_arr[0].nt_fx_prop do
              begin
                                                                     fx_arr[0].pt_as_nt:=
                                               fast_image_data_ptr_^.fx_arr[0].pt_as_nt;
                pt_as_nt                     :=                      fx_arr[0].pt_as_nt;
                GenNTBeginProc  [              fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.begin_proc_ind.main_part+
                                                                                          begin_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                              is_fx_gradvec  :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.is_fx_gradvec;
                case scl_mul_check of
                  0:
                    begin
                      if (not is_fx_gradvec) then
                        RegNTColorProc[        fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                      else
                      if (grad_prop.grad_vec_dif>0) then
                        GrVNTColorProc[        fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                    end;
                  1:
                    begin
                      if (not is_fx_gradvec) then
                        RSDNTColorProc[        fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                      else
                      if (grad_prop.grad_vec_dif>0) then
                        GSDNTColorProc[        fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                    end;
                  2:
                    begin
                      if (not is_fx_gradvec) then
                        RSUNTColorProc[        fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                      else
                      if (grad_prop.grad_vec_dif>0) then
                        GSUNTColorProc[        fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                    end;
                end;
              end;
        end; {$endregion}

      {Sprite Post-Process.------} {$region -fold}
      if (pix_drw_type<>0) then
        for i:=1 to fx_cnt-1 do
          begin
            cfx_pow0                         :=                      fx_arr[i].nt_fx_prop.cfx_pow0;
            if (cfx_pow0<>0) then
              begin
                                                                     fx_arr[i].nt_fx_prop.rep_cnt:=
                                               fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.rep_cnt;
                for j:=0 to                                          fx_arr[i].nt_fx_prop.rep_cnt-1 do
                  begin
                                                                     fx_arr[i].pt_as_nt:=
                                               fast_image_data_ptr_^.fx_arr[i].pt_as_nt;
                    pt_as_nt                 :=                      fx_arr[i].pt_as_nt;
                    with                                             fx_arr[i].nt_fx_prop do
                      begin
                                is_fx_gradvec:=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                                is_fx_gradvec;
                        case scl_mul_check of
                          0:
                            begin
                              if (not is_fx_gradvec) then
                                RegNTValueProc[fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                              else
                              if (grad_prop.grad_vec_dif>0) then
                                GrVNTValueProc[fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                            end;
                          1:
                            begin
                              if (not is_fx_gradvec) then
                                RSDNTValueProc[fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                              else
                              if (grad_prop.grad_vec_dif>0) then
                                GSDNTValueProc[fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                            end;
                          2:
                            begin
                              if (not is_fx_gradvec) then
                                RSUNTValueProc[fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                              else
                              if (grad_prop.grad_vec_dif>0) then
                                GSUNTValueProc[fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                            end;
                        end;
                      end;
                  end;
              end;
          end; {$endregion}

      {Reset Sprite Bounding Rct.} {$region -fold}
      if (scl_mul_check=0) then
        RRIProc[img_inv_type]                 (fast_image_data_arr_ptr^); {$endregion}

    end;
end; {$endregion}
procedure TFastimageProc.UberShader6(const x,y:integer; const fast_image_data_ptr_:PFastImageData; const index:PtrInt=0; const block_count:integer=1); {$ifdef Linux}[local];{$endif} {$region -fold}
var
//fast_image_data_arr    : TFastImageData;
  fast_image_data_arr_ptr: PFastImageData;
  rct_clp_               : TPtRect;
  i,j                    : shortint;
begin
  fast_image_data_arr_ptr:=@fast_image_data_arr[index];

  with fast_image_data_arr_ptr^ do
    begin

      {Check Scale Multiplayer---} {$region -fold}
      SclMulCheck(fast_image_data_arr_ptr^);
      if (scl_mul_check=3) then
        Exit; {$endregion}

      {Set Bounding Rect. Pos.---} {$region -fold}
      bmp_src_rct_clp                        :=fast_image_data_ptr_^.bmp_src_rct_clp;
      rct_ent.width                          :=fast_image_data_ptr_^.rct_ent.width {bmp_src_rct_clp.width };
      rct_ent.height                         :=fast_image_data_ptr_^.rct_ent.height{bmp_src_rct_clp.height};
      SetRctPos(x,y,                           fast_image_data_arr_ptr^); {$endregion}

      {Sprite Bounding Rct.------} {$region -fold}
      rct_clp_                               :=SetRct(index,fast_image_data_ptr_^.rct_clp_ptr^,block_count);
      rct_clp_ptr                            :=@rct_clp_; // fast_image_data_ptr_^.rct_clp_ptr;
    //rct_clp_ptr^                           :=fast_image_data_ptr_^.rct_clp_ptr^;
      is_frame_animate                       :=fast_image_data_ptr_^.is_frame_animate;
      rct_src_mrg                            :=fast_image_data_ptr_^.rct_src_mrg;

      {with fast_image_data_ptr_^ do
        begin
          SetRctDst0(fast_image_data_ptr_^);
          if (pix_clp_type=3) then
            Exit;
          SetRctSrc (fast_image_data_ptr_^);
        end;}

      if (scl_mul_check=0) then
        begin
          SetRctDst0                          (fast_image_data_arr_ptr^);
          if (pix_clp_type=3) then
            Exit;
          SetRctSrc                           (fast_image_data_arr_ptr^);
          bmp_ftimg_width_origin             :=fast_image_data_ptr_^.bmp_ftimg_width_origin;
          bmp_ftimg_height_origin            :=fast_image_data_ptr_^.bmp_ftimg_height_origin;
                     img_inv_type            :=fast_image_data_ptr_^.img_inv_type;
          SRIProc   [img_inv_type]            (fast_image_data_arr_ptr^);
        end
      else
        begin
          bmp_ftimg_width_origin             :=fast_image_data_ptr_^.bmp_ftimg_width_origin;
          bmp_ftimg_height_origin            :=fast_image_data_ptr_^.bmp_ftimg_height_origin;
                     img_inv_type            :=fast_image_data_ptr_^.img_inv_type;

          pvt0.x                             :=rct_ent.left+bmp_ftimg_width_origin >>1;
          pvt0.y                             :=rct_ent.top +bmp_ftimg_height_origin>>1;

          SetRctDst1                          (fast_image_data_arr_ptr^);
          if (pix_clp_type=3) then
            Exit;
        end; {$endregion}

      {Sprite Shader Type--------} {$region -fold}
      fx_cnt                                 :=fast_image_data_ptr_^.fx_cnt;
      img_kind                               :=fast_image_data_ptr_^.img_kind;
      pix_drw_type                           :=fast_image_data_ptr_^.pix_drw_type;
      sdr_proc_ind                           :=fast_image_data_ptr_^.sdr_proc_ind;
      SetSdrType                              (fast_image_data_arr_ptr^);
         SdrType[sdr_type_ind]                (fast_image_data_ptr_, // ShaderType;
                                               fast_image_data_arr_ptr^); {$endregion}

      {--------------------------} {$region -fold}
      bmp_bkgnd_width                        :=fast_image_data_ptr_^.bmp_bkgnd_width; {$endregion}

      {Sprite Drawing------------} {$region -fold}
      if (pix_drw_type<>1) then
        begin
          cfx_pow0                           :=                      fx_arr[0].pt_fx_prop.cfx_pow0;
          if (cfx_pow0<>0) then
            with                                                     fx_arr[0].pt_fx_prop do
              begin
                                                                     fx_arr[0].pt_as_nt:=
                                               fast_image_data_ptr_^.fx_arr[0].pt_as_nt;
                pt_as_nt                     :=                      fx_arr[0].pt_as_nt;
                GenPTBeginProc  [              fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.begin_proc_ind.main_part+
                                                                                          begin_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                              is_fx_gradvec  :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.is_fx_gradvec;
                case scl_mul_check of
                  0:
                    begin
                      if (not is_fx_gradvec) then
                        RegPTColorProc[        fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                      else
                      if (grad_prop.grad_vec_dif>0) then
                        GrVPTColorProc[        fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                    end;
                  1:
                    begin
                      if (not is_fx_gradvec) then
                        RSDPTColorProc[        fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                      else
                      if (grad_prop.grad_vec_dif>0) then
                        GSDPTColorProc[        fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                    end;
                  2:
                    begin
                      if (not is_fx_gradvec) then
                        RSUPTColorProc[        fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                      else
                      if (grad_prop.grad_vec_dif>0) then
                        GSUPTColorProc[        fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                    end;
                end;
              end;
        end; {$endregion}

      {Sprite Post-Process.------} {$region -fold}
      if (pix_drw_type<>0) then
        for i:=1 to fx_cnt-1 do
          begin
            cfx_pow0                         :=                      fx_arr[i].pt_fx_prop.cfx_pow0;
            if (cfx_pow0<>0) then
              begin
                                                                     fx_arr[i].pt_fx_prop.rep_cnt:=
                                               fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.rep_cnt;
                for j:=0 to                                          fx_arr[i].pt_fx_prop.rep_cnt-1 do
                  begin
                                                                     fx_arr[i].pt_as_nt:=
                                               fast_image_data_ptr_^.fx_arr[i].pt_as_nt;
                    pt_as_nt                 :=                      fx_arr[i].pt_as_nt;
                    with                                             fx_arr[i].pt_fx_prop do
                      begin
                                is_fx_gradvec:=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
                                is_fx_gradvec;
                        case scl_mul_check of
                          0:
                            begin
                              if (not is_fx_gradvec) then
                                RegPTValueProc[fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                              else
                              if (grad_prop.grad_vec_dif>0) then
                                GrVPTValueProc[fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                            end;
                          1:
                            begin
                              if (not is_fx_gradvec) then
                                RSDPTValueProc[fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                              else
                              if (grad_prop.grad_vec_dif>0) then
                                GSDPTValueProc[fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                            end;
                          2:
                            begin
                              if (not is_fx_gradvec) then
                                RSUPTValueProc[fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                              else
                              if (grad_prop.grad_vec_dif>0) then
                                GSUPTValueProc[fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                            end;
                        end;
                      end;
                  end;
              end;
          end; {$endregion}

      {Reset Sprite Bounding Rct.} {$region -fold}
      if (scl_mul_check=0) then
        RRIProc[img_inv_type]                 (fast_image_data_arr_ptr^); {$endregion}

    end;
end; {$endregion}
procedure TFastimageProc.UberShader7(const x,y:integer; const fast_image_data_ptr_:PFastImageData; const index:PtrInt=0; const block_count:integer=1); {$ifdef Linux}[local];{$endif} {$region -fold}
var
//fast_image_data_arr    : TFastImageData;
  fast_image_data_arr_ptr: PFastImageData;
  rct_clp_               : TPtRect;
  i,j                    : shortint;
begin
  fast_image_data_arr_ptr:=@fast_image_data_arr[index];

  with fast_image_data_arr_ptr^ do
    begin

      {Check Scale Multiplayer---} {$region -fold}
      SclMulCheck(fast_image_data_arr_ptr^);
      if (scl_mul_check=3) then
        Exit; {$endregion}

      {Set Bounding Rect. Pos.---} {$region -fold}
      bmp_src_rct_clp                        :=fast_image_data_ptr_^.bmp_src_rct_clp;
      rct_ent.width                          :=fast_image_data_ptr_^.rct_ent.width {bmp_src_rct_clp.width };
      rct_ent.height                         :=fast_image_data_ptr_^.rct_ent.height{bmp_src_rct_clp.height};
      SetRctPos(x,y,                           fast_image_data_arr_ptr^); {$endregion}

      {Sprite Bounding Rct.------} {$region -fold}
      rct_clp_                               :=SetRct(index,fast_image_data_ptr_^.rct_clp_ptr^,block_count);
      rct_clp_ptr                            :=@rct_clp_; // fast_image_data_ptr_^.rct_clp_ptr;
    //rct_clp_ptr^                           :=fast_image_data_ptr_^.rct_clp_ptr^;
      is_frame_animate                       :=fast_image_data_ptr_^.is_frame_animate;
      rct_src_mrg                            :=fast_image_data_ptr_^.rct_src_mrg;

      {with fast_image_data_ptr_^ do
        begin
          SetRctDst0(fast_image_data_ptr_^);
          if (pix_clp_type=3) then
            Exit;
          SetRctSrc (fast_image_data_ptr_^);
        end;}

      if (scl_mul_check=0) then
        begin
          SetRctDst0                          (fast_image_data_arr_ptr^);
          if (pix_clp_type=3) then
            Exit;
          SetRctSrc                           (fast_image_data_arr_ptr^);
          bmp_ftimg_width_origin             :=fast_image_data_ptr_^.bmp_ftimg_width_origin;
          bmp_ftimg_height_origin            :=fast_image_data_ptr_^.bmp_ftimg_height_origin;
                     img_inv_type            :=fast_image_data_ptr_^.img_inv_type;
          SRIProc   [img_inv_type]            (fast_image_data_arr_ptr^);
        end
      else
        begin
          bmp_ftimg_width_origin             :=fast_image_data_ptr_^.bmp_ftimg_width_origin;
          bmp_ftimg_height_origin            :=fast_image_data_ptr_^.bmp_ftimg_height_origin;
                     img_inv_type            :=fast_image_data_ptr_^.img_inv_type;

          pvt0.x                             :=rct_ent.left+bmp_ftimg_width_origin >>1;
          pvt0.y                             :=rct_ent.top +bmp_ftimg_height_origin>>1;

          SetRctDst1                          (fast_image_data_arr_ptr^);
          if (pix_clp_type=3) then
            Exit;
        end; {$endregion}

      {Sprite Shader Type--------} {$region -fold}
      fx_cnt                                 :=fast_image_data_ptr_^.fx_cnt;
      img_kind                               :=fast_image_data_ptr_^.img_kind;
      pix_drw_type                           :=fast_image_data_ptr_^.pix_drw_type;
      sdr_proc_ind                           :=fast_image_data_ptr_^.sdr_proc_ind;
      SetSdrType                              (fast_image_data_arr_ptr^);
         SdrType[sdr_type_ind]                (fast_image_data_ptr_, // ShaderType;
                                               fast_image_data_arr_ptr^); {$endregion}

      {--------------------------} {$region -fold}
      bmp_bkgnd_width                        :=fast_image_data_ptr_^.bmp_bkgnd_width; {$endregion}

      {Sprite Drawing------------} {$region -fold}
      if (pix_drw_type<>1) then
        begin
          cfx_pow0                           :=                      fx_arr[0].nt_fx_prop.cfx_pow0;
          if (cfx_pow0<>0) then
            with                                                     fx_arr[0].nt_fx_prop do
              begin
                                                                     fx_arr[0].pt_as_nt:=
                                               fast_image_data_ptr_^.fx_arr[0].pt_as_nt;
                pt_as_nt                     :=                      fx_arr[0].pt_as_nt;
                GenNTBeginProc  [              fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.begin_proc_ind.main_part+
                                                                                          begin_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                              is_fx_gradvec  :=fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.is_fx_gradvec;
                case scl_mul_check of
                  0:
                    begin
                      if (not is_fx_gradvec) then
                        RegNTColorProc[        fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                      else
                      if (grad_prop.grad_vec_dif>0) then
                        GrVNTColorProc[        fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                    end;
                  1:
                    begin
                      if (not is_fx_gradvec) then
                        RSDNTColorProc[        fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                      else
                      if (grad_prop.grad_vec_dif>0) then
                        GSDNTColorProc[        fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                    end;
                  2:
                    begin
                      if (not is_fx_gradvec) then
                        RSUNTColorProc[        fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                      else
                      if (grad_prop.grad_vec_dif>0) then
                        GSUNTColorProc[        fast_image_data_ptr_^.fx_arr[0].nt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                    end;
                end;
              end;
          //{
          cfx_pow0                           :=                      fx_arr[0].pt_fx_prop.cfx_pow0;
          if (cfx_pow0<>0) then
            with                                                     fx_arr[0].pt_fx_prop do
              begin
                                                                     fx_arr[0].pt_as_nt:=
                                               fast_image_data_ptr_^.fx_arr[0].pt_as_nt;
                pt_as_nt                     :=                      fx_arr[0].pt_as_nt;
                GenPTBeginProc  [              fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.begin_proc_ind.main_part+
                                                                                          begin_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                              is_fx_gradvec  :=fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.is_fx_gradvec;
                case scl_mul_check of
                  0:
                    begin
                      if (not is_fx_gradvec) then
                        RegPTColorProc[        fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                      else
                      if (grad_prop.grad_vec_dif>0) then
                        GrVPTColorProc[        fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                    end;
                  1:
                    begin
                      if (not is_fx_gradvec) then
                        RSDPTColorProc[        fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                      else
                      if (grad_prop.grad_vec_dif>0) then
                        GSDPTColorProc[        fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                    end;
                  2:
                    begin
                      if (not is_fx_gradvec) then
                        RSUPTColorProc[        fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                      else
                      if (grad_prop.grad_vec_dif>0) then
                        GSUPTColorProc[        fast_image_data_ptr_^.fx_arr[0].pt_fx_prop.color_proc_ind.main_part+
                                                                                          color_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                    end;
                end;
              end;
          //}
        end; {$endregion}

      {Sprite Post-Process.------} {$region -fold}
      if (pix_drw_type<>0) then
        for i:=1 to fx_cnt-1 do
          begin
            cfx_pow0                         :=                      fx_arr[i].nt_fx_prop.cfx_pow0;
            if (cfx_pow0<>0) then
              begin
                                                                     fx_arr[i].nt_fx_prop.rep_cnt:=
                                               fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.rep_cnt;
                for j:=0 to                                          fx_arr[i].nt_fx_prop.rep_cnt-1 do
                  begin
                                                                     fx_arr[i].pt_as_nt:=
                                               fast_image_data_ptr_^.fx_arr[i].pt_as_nt;
                    pt_as_nt                 :=                      fx_arr[i].pt_as_nt;
                    with                                             fx_arr[i].nt_fx_prop do
                      begin
                                is_fx_gradvec:=fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.
                                is_fx_gradvec;
                        case scl_mul_check of
                          0:
                            begin
                              if (not is_fx_gradvec) then
                                RegNTValueProc[fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                              else
                              if (grad_prop.grad_vec_dif>0) then
                                GrVNTValueProc[fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                            end;
                          1:
                            begin
                              if (not is_fx_gradvec) then
                                RSDNTValueProc[fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                              else
                              if (grad_prop.grad_vec_dif>0) then
                                GSDNTValueProc[fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                            end;
                          2:
                            begin
                              if (not is_fx_gradvec) then
                                RSUNTValueProc[fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                              else
                              if (grad_prop.grad_vec_dif>0) then
                                GSUNTValueProc[fast_image_data_ptr_^.fx_arr[i].nt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                            end;
                        end;
                      end;
                  end;
              end;
            //{
            cfx_pow0                         :=                      fx_arr[i].pt_fx_prop.cfx_pow0;
            if (cfx_pow0<>0) then
              begin
                                                                     fx_arr[i].pt_fx_prop.rep_cnt:=
                                               fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.rep_cnt;
                for j:=0 to                                          fx_arr[i].pt_fx_prop.rep_cnt-1 do
                  begin
                                                                     fx_arr[i].pt_as_nt:=
                                               fast_image_data_ptr_^.fx_arr[i].pt_as_nt;
                    pt_as_nt                 :=                      fx_arr[i].pt_as_nt;
                    with                                             fx_arr[i].pt_fx_prop do
                      begin
                                is_fx_gradvec:=fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.
                                is_fx_gradvec;
                        case scl_mul_check of
                          0:
                            begin
                              if (not is_fx_gradvec) then
                                RegPTValueProc[fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                              else
                              if (grad_prop.grad_vec_dif>0) then
                                GrVPTValueProc[fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                            end;
                          1:
                            begin
                              if (not is_fx_gradvec) then
                                RSDPTValueProc[fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                              else
                              if (grad_prop.grad_vec_dif>0) then
                                GSDPTValueProc[fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                            end;
                          2:
                            begin
                              if (not is_fx_gradvec) then
                                RSUPTValueProc[fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^)
                              else
                              if (grad_prop.grad_vec_dif>0) then
                                GSUPTValueProc[fast_image_data_ptr_^.fx_arr[i].pt_fx_prop.value_proc_ind.main_part+
                                                                                          value_proc_ind.clip_part](fast_image_data_ptr_,
                                                                                                                    fast_image_data_arr_ptr^);
                            end;
                        end;
                      end;
                  end;
              end;
            //}
          end; {$endregion}

      {Reset Sprite Bounding Rct.} {$region -fold}
      if (scl_mul_check=0) then
        RRIProc[img_inv_type]                 (fast_image_data_arr_ptr^); {$endregion}

    end;
end; {$endregion}

// Clear Background from Image:
procedure TFastimageProc.ClrBkgnd; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  GenNTBeginProc[2](fast_image_data_ptr0,fast_image_data_ptr0^);
  RegNTColorProc[0](fast_image_data_ptr0,fast_image_data_ptr0^);
end; {$endregion}

{$endregion}

{$endregion}

{CSR-image anti-aliasing-------------------------------} {$region -fold}
procedure TFastImageProc.CrtBorderBmp(const arr_src:TColorArr; var arr_dst:TObjSelArr;                         const arr_src_width,arr_dst_width:TColor; const rect_left,rect_top,rect_width,rect_height:TColor; var brdr_pix_cnt:TColor; const obj_kind,obj_id:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_src_ptr      : PInteger;
  arr_dst_ptr      : PObjSel;
  d_width1,d_width2: integer;
  x_,y_            : integer;
begin
  brdr_pix_cnt     :=0;
  d_width1         :=                   arr_src_width- rect_width;
  d_width2         :=                   arr_dst_width- rect_width;
  arr_src_ptr      :=@arr_src[rect_left+arr_src_width*(rect_top+1)];
  arr_dst_ptr      :=@arr_dst[rect_left+arr_dst_width*(rect_top+1)];
  for y_:=0 to rect_height-3 do
    begin
      for x_:=0 to rect_width-1 do
        begin
          if (arr_src_ptr^<>0) then
            begin
              if ((arr_src_ptr-arr_src_width)^=0) then
                if ((arr_dst_ptr-arr_dst_width)^.obj_kind<>obj_kind) then
                  begin
                    (arr_dst_ptr-arr_dst_width)^.obj_kind:=obj_kind;
                    (arr_dst_ptr-arr_dst_width)^.obj_id  :=obj_id  ;
                    Inc(brdr_pix_cnt);
                  end;
              if ((arr_src_ptr+arr_src_width)^=0) then
                if ((arr_dst_ptr+arr_dst_width)^.obj_kind<>obj_kind) then
                  begin
                    (arr_dst_ptr+arr_dst_width)^.obj_kind:=obj_kind;
                    (arr_dst_ptr+arr_dst_width)^.obj_id  :=obj_id  ;
                    Inc(brdr_pix_cnt);
                  end;
            end;
          Inc(arr_src_ptr);
          Inc(arr_dst_ptr);
        end;
      Inc(arr_src_ptr,d_width1);
      Inc(arr_dst_ptr,d_width2);
    end;
end; {$endregion}
procedure TFastImageProc.BorderCalc1 (const arr_src:TColorArr; var arr_dst:T1Byte1Arr;                         const arr_src_width,arr_dst_width:TColor; const rct_dst_:TPtRect                                                                                       ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr1: PInteger;
   first_row_pix_ptr2: PByte;
  nt_pix_cnt_arr_ptr : PWord;
  nt_pix_sht_arr_ptr : PWord;
         arr_src_ptr1: PInteger;
         arr_dst_ptr1: PByte;
         arr_src_ptr2: PInteger;
         arr_dst_ptr2: PByte;
  x,y                : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (nt_pix_cnt=0) or (rct_dst_.height<3) then
        Exit;
       first_row_pix_ptr1:=Unaligned(@arr_src       [(nt_pix_arr_row_mrg_top+rct_dst_.top)*arr_src_width+rct_dst_.left]);
       first_row_pix_ptr2:=Unaligned(@arr_dst       [(nt_pix_arr_row_mrg_top+rct_dst_.top)*arr_dst_width+rct_dst_.left]);
      nt_pix_cnt_arr_ptr :=Unaligned(@nt_pix_cnt_arr[ nt_pix_arr_row_mrg_top+00000000000000000000000000000000000000000]);
      nt_pix_sht_arr_ptr :=Unaligned(@nt_pix_sht_arr[00000000000000000000000000000000000000000000000000000000000000000]);
      for y:=0 to rct_dst_.height-nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
        begin
          arr_src_ptr1:=first_row_pix_ptr1;
          arr_dst_ptr1:=first_row_pix_ptr2;
          for x:=0 to       nt_pix_cnt_arr_ptr^-1 do
            begin
              arr_src_ptr2:=nt_pix_sht_arr_ptr^+arr_src_ptr1;
              arr_dst_ptr2:=nt_pix_sht_arr_ptr^+arr_dst_ptr1;
              if (arr_src_ptr2^<>0) then
                begin
                  if ((arr_src_ptr2-arr_src_width)^ =0) then
                      (arr_dst_ptr2-arr_dst_width)^:=1;
                  if ((arr_src_ptr2+arr_src_width)^ =0) then
                      (arr_dst_ptr2+arr_dst_width)^:=1;
                  if ((arr_src_ptr2-0000000000001)^ =0) then
                      (arr_dst_ptr2-0000000000001)^:=1;
                  if ((arr_src_ptr2+0000000000001)^ =0) then
                      (arr_dst_ptr2+0000000000001)^:=1;
                end;
              Inc          (nt_pix_sht_arr_ptr);
            end;
          Inc              (nt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr1,arr_src_width);
          Inc(first_row_pix_ptr2,arr_dst_width);
        end;
    end;
end; {$endregion}
{TODO}
procedure TFastImageProc.BorderCalc2 (const arr_src:TColorArr; var arr_dst:T1Byte1Arr; var arr_alpha:TAALnArr; const arr_src_width,arr_dst_width:TColor; const rct_dst_:TPtRect; out line_cnt:TColor                                                                  ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr1: PInteger;
   first_row_pix_ptr2: PByte;
  pt_pix_cnt_dec     : integer;
  pt_pix_cnt_arr_ptr : PWord;
  pt_pix_sht_arr_ptr : PWord;
  arr_src_ptr2       : PInteger;
  arr_dst_ptr2       : PByte;
  line_kind_arr      : array[0..7] of boolean;
  line_kind          : qword absolute line_kind_arr;
  arr_alpha_ptr      : PFastAALine;
  arr_dst_left_ptr   : PByte;
  arr_dst_right_ptr  : PByte;
  line_first_pt_ptr  : PByte;
  y_,x_,i,d0,d1,d2   : integer;
  a,b,c,d            : boolean;
label
  label1,label2;
begin
  with fast_image_data_ptr0^ do
    begin
      if (pt_pix_cnt=0) or (rct_dst_.height<3) then
        Exit;
      d0                 :=                          (pt_pix_arr_row_mrg_top+rct_dst_.top)*arr_src_width;
       first_row_pix_ptr1:=Unaligned(@arr_src       [(pt_pix_arr_row_mrg_top+rct_dst_.top)*arr_src_width+rct_dst_.left]);
       first_row_pix_ptr2:=Unaligned(@arr_dst       [(pt_pix_arr_row_mrg_top+rct_dst_.top)*arr_dst_width+rct_dst_.left]);
        arr_dst_left_ptr :=Unaligned(@arr_dst       [(pt_pix_arr_row_mrg_top+rct_dst_.top)*arr_dst_width+rct_dst_.left]);
      pt_pix_cnt_arr_ptr :=Unaligned(@pt_pix_cnt_arr[ pt_pix_arr_row_mrg_top+00000000000000000000000000000000000000000]);
      pt_pix_sht_arr_ptr :=Unaligned(@pt_pix_sht_arr[00000000000000000000000000000000000000000000000000000000000000000]);
      arr_alpha_ptr      :=Unaligned(@arr_alpha     [00000000000000000000000000000000000000000000000000000000000000000]);
      for y_:=0 to 6{rct_dst_.height-pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1} do
        begin
          arr_dst_right_ptr:=arr_dst_left_ptr+rct_dst_.left+rct_dst_.width-1;
          pt_pix_cnt_dec   :=pt_pix_cnt_arr_ptr^-1;
          for x_:=0 to       pt_pix_cnt_arr_ptr^-1 do
            begin
              if            (pt_pix_cnt_dec=0) then
                begin
                  Inc       (pt_pix_sht_arr_ptr);
                  goto label1;
                end;
              arr_src_ptr2:=pt_pix_sht_arr_ptr^+first_row_pix_ptr1;
              arr_dst_ptr2:=pt_pix_sht_arr_ptr^+first_row_pix_ptr2;
              if (arr_dst_ptr2^=1) then                                                          //  -01234----5678
                begin                                                                            //  01234500006789
                  {Fill Horizontal Line} {$region -fold}                                         //   87654    3210
                  if ((arr_dst_ptr2+1)^=1) then
                    begin
                      line_first_pt_ptr:=arr_dst_ptr2;
                      while (arr_dst_ptr2^=1) and (pt_pix_cnt_dec<>0) do
                        begin
                          arr_dst_ptr2^:=2;
                          Inc(arr_dst_ptr2);

                          Dec(pt_pix_cnt_dec);
                        end;
                      if     (pt_pix_cnt_dec=0) then
                        begin
                          arr_dst_ptr2^:=2;
                        end;
                      //Dec(pt_pix_intr_sht_arr_ptr);
                      {arr_alpha_ptr^.line_shift:=arr_dst_ptr2-line_first_pt_ptr;
                      d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                      d2                       :=arr_dst_ptr2     -arr_dst_left_ptr+d0;
                      line_kind_arr[3]         :=((arr_src_ptr2+d1-1)^<>0);
                      line_kind_arr[4]         :=((arr_src_ptr2+d2  )^<>0);
                      {line_kind=2----} {$region -fold}
                      if (line_kind_arr[3] and line_kind_arr[4]) then
                        begin
                          arr_alpha_ptr^.line_kind :=2;
                          arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                          arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                          Inc(arr_alpha_ptr);
                        end {$endregion}
                      else
                      {line_kind=0,1,3} {$region -fold}
                        begin
                          line_kind_arr[0]:=((arr_src_ptr2+d1-1-arr_src_width)^<>0);
                          line_kind_arr[1]:=((arr_src_ptr2+d1  -arr_src_width)^<>0);
                          line_kind_arr[2]:=((arr_src_ptr2+d2  -arr_src_width)^<>0);
                          line_kind_arr[5]:=((arr_src_ptr2+d1-1+arr_src_width)^<>0);
                          line_kind_arr[6]:=((arr_src_ptr2+d1  +arr_src_width)^<>0);
                          line_kind_arr[7]:=((arr_src_ptr2+d2  +arr_src_width)^<>0);
                          case line_kind of
                            {line_kind=0} {$region -fold}
                            {can be rolled to line_kind=1}
                            {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                            {00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001,
                            {00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000,
                            {00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000,
                            {00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001,
                            {00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000,
                            {00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001,
                            {01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000,
                            {01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001,
                            {01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001,
                            {01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000,
                            {01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000,
                            {01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001,
                            {01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000,
                            {01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001,
                            {01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000,
                            {11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000,
                            {10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000,
                            {11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000,
                            {10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001:
                              begin
                                arr_alpha_ptr^.line_kind :=0;
                                arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                                arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                                Inc(arr_alpha_ptr);
                              end; {$endregion}
                            {line_kind=1} {$region -fold}
                            {can be rolled to line_kind=0}
                            {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                            {11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000,
                            {01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000,
                            {01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000,
                            {11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000,
                            {01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000,
                            {11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000,
                            {01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000,
                            {11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000,
                            {10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000,
                            {00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000,
                            {00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000,
                            {10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000,
                            {00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000,
                            {10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000,
                            {01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000,
                            {00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001,
                            {01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001,
                            {00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001,
                            {11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001:
                              begin
                                arr_alpha_ptr^.line_kind :=1;
                                arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                                arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                                Inc(arr_alpha_ptr);
                              end; {$endregion}
                            {line_kind=3} {$region -fold}
                            {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                            {00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000:
                            if ((arr_src_ptr2+d2-arr_src_width-1)^<>0) then
                              begin
                                arr_alpha_ptr^.line_kind :=3;
                                arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                                arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                                Inc(arr_alpha_ptr);
                              end;
                            {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                            {01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000:
                            if ((arr_src_ptr2+d2+arr_src_width-1)^<>0) then
                              begin
                                arr_alpha_ptr^.line_kind :=3;
                                arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                                arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                                Inc(arr_alpha_ptr);
                              end; {$endregion}
                          end;
                        end; {$endregion}
                    }end; {$endregion}
                  {
                  {Fill Vertical Line--} {$region -fold}
                  else
                  if ((arr_dst_ptr2+arr_dst_width)^=1) then
                    begin
                      line_first_pt_ptr:=arr_dst_ptr2;
                      while (arr_dst_ptr2^=1) do
                        begin
                          arr_dst_ptr2^:=2;
                          Inc(arr_dst_ptr2,arr_dst_width);
                        end;
                      arr_alpha_ptr^.line_shift:=Trunc((arr_dst_ptr2-line_first_pt_ptr)/arr_dst_width);
                      Dec(arr_dst_ptr2,arr_dst_ptr2-line_first_pt_ptr);
                      d1                       :=line_first_pt_ptr-arr_dst_left_ptr+d0;
                      d2                       :=d1+arr_src_width *arr_alpha_ptr^.line_shift;
                      line_kind_arr[3]         :=((arr_src_ptr2+d1-arr_src_width)^<>0);
                      line_kind_arr[4]         :=((arr_src_ptr2+d2              )^<>0);
                      {line_kind=7----} {$region -fold}
                      if (line_kind_arr[3] and line_kind_arr[4]) then
                        begin
                          arr_alpha_ptr^.line_kind :=7;
                          arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                          arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                          Inc(arr_alpha_ptr);
                        end {$endregion}
                      else
                      {line_kind=5,6,8} {$region -fold}
                        begin
                          line_kind_arr[0]:=((arr_src_ptr2+d1+1-arr_src_width)^<>0);
                          line_kind_arr[1]:=((arr_src_ptr2+d1+1              )^<>0);
                          line_kind_arr[2]:=((arr_src_ptr2+d2+1              )^<>0);
                          line_kind_arr[5]:=((arr_src_ptr2+d1-1-arr_src_width)^<>0);
                          line_kind_arr[6]:=((arr_src_ptr2+d1-1              )^<>0);
                          line_kind_arr[7]:=((arr_src_ptr2+d2-1              )^<>0);
                          case line_kind of
                            {line_kind=5} {$region -fold}
                            {can be rolled to line_kind=6}
                            {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                            {00000011}{257              }%0000000000000000000000000000000000000000000000000000000100000001,
                            {00001110}{16843008         }%0000000000000000000000000000000000000001000000010000000100000000,
                            {00001010}{16777472         }%0000000000000000000000000000000000000001000000000000000100000000,
                            {00001011}{16777473         }%0000000000000000000000000000000000000001000000000000000100000001,
                            {00101010}{1099528405248    }%0000000000000000000000010000000000000001000000000000000100000000,
                            {00101011}{1099528405249    }%0000000000000000000000010000000000000001000000000000000100000001,
                            {01001010}{281474993488128  }%0000000000000001000000000000000000000001000000000000000100000000,
                            {01001011}{281474993488129  }%0000000000000001000000000000000000000001000000000000000100000001,
                            {01001101}{281474993553409  }%0000000000000001000000000000000000000001000000010000000000000001,
                            {01100000}{282574488338432  }%0000000000000001000000010000000000000000000000000000000000000000,
                            {01101000}{282574505115648  }%0000000000000001000000010000000000000001000000000000000000000000,
                            {01101001}{282574505115649  }%0000000000000001000000010000000000000001000000000000000000000001,
                            {01001000}{281474993487872  }%0000000000000001000000000000000000000001000000000000000000000000,
                            {01001001}{281474993487873  }%0000000000000001000000000000000000000001000000000000000000000001,
                            {01101010}{282574505115904  }%0000000000000001000000010000000000000001000000000000000100000000,
                            {11101100}{72340168543109120}%0000000100000001000000010000000000000001000000010000000000000000,
                            {10101010}{72058693566333184}%0000000100000000000000010000000000000001000000000000000100000000,
                            {11001000}{72339069031415808}%0000000100000001000000000000000000000001000000000000000000000000,
                            {10001111}{72057594054770945}%0000000100000000000000000000000000000001000000010000000100000001:
                              begin
                                arr_alpha_ptr^.line_kind :=5;
                                arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                                arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                                Inc(arr_alpha_ptr);
                              end; {$endregion}
                            {line_kind=6} {$region -fold}
                            {can be rolled to line_kind=5}
                            {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                            {11000000}{72339069014638592}%0000000100000001000000000000000000000000000000000000000000000000,
                            {01110000}{282578783305728  }%0000000000000001000000010000000100000000000000000000000000000000,
                            {01010000}{281479271677952  }%0000000000000001000000000000000100000000000000000000000000000000,
                            {11010000}{72339073309605888}%0000000100000001000000000000000100000000000000000000000000000000,
                            {01010100}{281479271743488  }%0000000000000001000000000000000100000000000000010000000000000000,
                            {11010100}{72339073309671424}%0000000100000001000000000000000100000000000000010000000000000000,
                            {01010010}{281479271678208  }%0000000000000001000000000000000100000000000000000000000100000000,
                            {11010010}{72339073309606144}%0000000100000001000000000000000100000000000000000000000100000000,
                            {10110010}{72058697844523264}%0000000100000000000000010000000100000000000000000000000100000000,
                            {00000110}{65792            }%0000000000000000000000000000000000000000000000010000000100000000,
                            {00010110}{4295033088       }%0000000000000000000000000000000100000000000000010000000100000000,
                            {10010110}{72057598332961024}%0000000100000000000000000000000100000000000000010000000100000000,
                            {00010010}{4294967552       }%0000000000000000000000000000000100000000000000000000000100000000,
                            {10010010}{72057598332895488}%0000000100000000000000000000000100000000000000000000000100000000,
                            {01010110}{281479271743744  }%0000000000000001000000000000000100000000000000010000000100000000,
                            {00110111}{1103806660865    }%0000000000000000000000010000000100000000000000010000000100000001,
                            {01010101}{281479271743489  }%0000000000000001000000000000000100000000000000010000000000000001,
                            {00010011}{4294967553       }%0000000000000000000000000000000100000000000000000000000100000001,
                            {11110001}{72340172821233665}%0000000100000001000000010000000100000000000000000000000000000001:
                              begin
                                arr_alpha_ptr^.line_kind :=6;
                                arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                                arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                                Inc(arr_alpha_ptr);
                              end; {$endregion}
                            {line_kind=8} {$region -fold}
                            {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                            {00000010}{256              }%0000000000000000000000000000000000000000000000000000000100000000:
                            if ((arr_src_ptr2+d2+1)^<>0) then
                              begin
                                arr_alpha_ptr^.line_kind :=8;
                                arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                                arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                                Inc(arr_alpha_ptr);
                              end;
                            {l.b - last bit:              l.b     l.b     l.b     l.b     l.b     l.b     l.b     l.b    }
                            {01000000}{281474976710656  }%0000000000000001000000000000000000000000000000000000000000000000:
                            if ((arr_src_ptr2+d2-1-arr_src_width)^<>0) then
                              begin
                                arr_alpha_ptr^.line_kind :=8;
                                arr_alpha_ptr^.first_pt_x:=line_first_pt_ptr-arr_dst_left_ptr;
                                arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                                Inc(arr_alpha_ptr);
                              end; {$endregion}
                          end;
                        end; {$endregion}
                    end {$endregion}
                  }
                  {
                  {Fill One Pixel------} {$region -fold}
                  else
                    begin
                      if (PInteger(pt_pix_intr_cnt_arr_ptr)-PInteger(@pt_pix_intr_cnt_arr[0])=0) then
                        a:=True
                      else
                        a:=((arr_dst_ptr2-arr_dst_width)^<>1);

                      if (arr_dst_ptr2=arr_dst_left_ptr) then
                        b:=True
                      else
                        b:=((arr_dst_ptr2-1)^<>1);

                      if (PInteger(pt_pix_intr_cnt_arr_ptr)-PInteger(@pt_pix_intr_cnt_arr[0])=rct_dst_.height) then
                        c:=True
                      else
                        c:=((arr_dst_ptr2+arr_dst_width)^<>1);

                      if (arr_dst_ptr2=arr_dst_right_ptr) then
                        d:=True
                      else
                        d:=((arr_dst_ptr2+1)^<>1);

                      if (a and b) or (c and d) then
                        begin
                          arr_dst_ptr2^             :=2;
                          arr_alpha_ptr^.line_kind :=10;
                          arr_alpha_ptr^.first_pt_x:=arr_dst_ptr2-arr_dst_left_ptr;
                          arr_alpha_ptr^.first_pt_y:=rct_dst_.top+y_;
                          Inc(arr_alpha_ptr);
                        end;
                    end; {$endregion}
                  }
                  //goto label2;
                end;
              //Inc(pt_pix_sht_arr_ptr);
              //label2:
            end;
          label1:
          //Inc(pt_pix_sht_arr_ptr);
          Inc  (pt_pix_cnt_arr_ptr);
          Inc(first_row_pix_ptr1,arr_src_width);
          Inc(first_row_pix_ptr2,arr_dst_width);
          Inc(arr_dst_left_ptr  ,arr_dst_width);
        end;
      line_cnt:=PFastAALine(arr_alpha_ptr)-PFastAALine(@arr_alpha[0]);
    end;
end; {$endregion}
{$endregion}

{CSR-image clipping------------------------------------} {$region -fold}
procedure TFastImageProc.UlsProcInit;                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  NTUselessProc[0]:=Unaligned(@NTUseless0);
  NTUselessProc[1]:=Unaligned(@NTUseless1);
  NTUselessProc[2]:=Unaligned(@NTUseless2);
  PTUselessProc[0]:=Unaligned(@PTUseless0);
  PTUselessProc[1]:=Unaligned(@PTUseless1);
  PTUselessProc[2]:=Unaligned(@PTUseless2);
end; {$endregion}
procedure TFastImageProc.NTUseless0    (var arr_dst:TColorArr; const arr_dst_width:TColor; const val:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
         arr_dst_ptr: PInteger;
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  nt_z_item_cnt     : TColor=0;
  x,y               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (nt_pix_cnt<>0) then
        begin
          nt_z_item_cnt     :=0;
           first_row_pix_ptr:=Unaligned(@arr_dst       [(nt_pix_arr_row_mrg_top+rct_ent.top)*arr_dst_width+rct_ent.left]);
          nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[ nt_pix_arr_row_mrg_top+000000000000000000000000000000000000000]);
          nt_pix_sht_arr_ptr:=Unaligned(@nt_pix_sht_arr[000000000000000000000000000000000000000000000000000000000000000]);
          for y:=0 to rct_ent.height-    nt_pix_arr_row_mrg_top-nt_pix_arr_row_mrg_btm-1 do
            begin
              arr_dst_ptr:=first_row_pix_ptr;
              for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                begin
                  if    ((nt_pix_sht_arr_ptr^+arr_dst_ptr)^=0) then
                    begin
                         (nt_pix_sht_arr_ptr^+arr_dst_ptr)^:=val;
                      Inc(nt_z_item_cnt);
                    end;
                  Inc    (nt_pix_sht_arr_ptr);
                end;
              Inc        (nt_pix_cnt_arr_ptr);
              Inc(first_row_pix_ptr,arr_dst_width);
            end;
        end;
      if (nt_z_item_cnt=0) then
        nt_useless:=0
      else
        nt_useless:=1;
    end;
end; {$endregion}
procedure TFastImageProc.NTUseless1    (var arr_dst:TColorArr; const arr_dst_width:TColor; const val:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
         arr_dst_ptr: PInteger;
   first_row_pix_ptr: PInteger;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  nt_z_item_cnt     : TColor=0;
  x,y               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr=Nil) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        begin
          nt_useless:=0;
          Exit;
        end;
      if (nt_pix_cnt<>0) then
        begin
          nt_z_item_cnt     :=0;
           first_row_pix_ptr:=Unaligned(@arr_dst       [(rct_ent.top   +rct_src.top)*arr_dst_width+rct_ent.left]);
          nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[ 00000000000000+rct_src.top +00000000000000000000000000]);
          nt_pix_sht_arr_ptr:=Unaligned(@nt_pix_sht_arr[ nt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
          for y:=0 to rct_src.height-1 do
            begin
              arr_dst_ptr:=first_row_pix_ptr;
              for x:=0 to nt_pix_cnt_arr_ptr^-1 do
                begin
                  if    ((nt_pix_sht_arr_ptr^+arr_dst_ptr)^=0) then
                    begin
                         (nt_pix_sht_arr_ptr^+arr_dst_ptr)^:=val;
                      Inc(nt_z_item_cnt);
                    end;
                  Inc    (nt_pix_sht_arr_ptr);
                end;
              Inc        (nt_pix_cnt_arr_ptr);
              Inc(first_row_pix_ptr,arr_dst_width);
            end;
        end;
      if (nt_z_item_cnt=0) then
        nt_useless:=0
      else
        nt_useless:=1;
    end;
end; {$endregion}
procedure TFastImageProc.NTUseless2    (var arr_dst:TColorArr; const arr_dst_width:TColor; const val:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  nt_pix_cnt_arr_ptr: PWord;
  nt_pix_sht_arr_ptr: PWord;
  nt_z_item_cnt     : TColor=0;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (nt_cnt_ind_arr=Nil) then
        Exit;
      if (nt_cnt_ind_arr[rct_src.top]>nt_pix_cnt-1) then
        begin
          nt_useless:=0;
          Exit;
        end;
      if (nt_pix_cnt<>0) then
        begin
          nt_z_item_cnt     :=0;
           first_row_pix_ptr:=Unaligned(@arr_dst       [arr_dst_width *rct_dst.top +rct_dst.left]);
          nt_pix_cnt_arr_ptr:=Unaligned(@nt_pix_cnt_arr[00000000000000+rct_src.top +000000000000]);
          nt_pix_sht_arr_ptr:=Unaligned(@nt_pix_sht_arr[nt_cnt_ind_arr[rct_src.top]+000000000000]);
          for y:=0 to rct_src.height-1 do
            begin
              if                        (nt_pix_cnt_arr_ptr^<>0) then
                begin
                  first_sht_pix_ptr:=    nt_pix_sht_arr_ptr;

                  {left-right-clipped} {$region -fold}
                  if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                     ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                    begin
                      c1:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                         nt_pix_sht_arr_ptr,rct_src.left);
                      c2:=BinarySearch1 (nt_pix_cnt_arr_ptr^,
                                         nt_pix_sht_arr_ptr,rct_src.right);
                      Inc               (nt_pix_sht_arr_ptr,c1+1);
                      for x:=0 to (c2+1)-(c1+1)-1 do
                        begin
                          if           ((nt_pix_sht_arr_ptr^+first_row_pix_ptr)^=0) then
                            begin
                                        (nt_pix_sht_arr_ptr^+first_row_pix_ptr)^:=val;
                              Inc(nt_z_item_cnt);
                            end;
                          Inc           (nt_pix_sht_arr_ptr);
                        end;
                      Inc               (nt_pix_sht_arr_ptr,
                                         nt_pix_cnt_arr_ptr^-(c2+1));
                      goto label1;
                    end; {$endregion}

                  {left-clipped------} {$region -fold}
                  if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                    begin
                      Inc               (nt_pix_sht_arr_ptr,
                                         nt_pix_cnt_arr_ptr^);
                      goto label1;
                    end
                  else
                  if (first_sht_pix_ptr^<rct_src.left) then
                    begin
                      c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                         nt_pix_sht_arr_ptr,rct_src.left);
                      Inc               (nt_pix_sht_arr_ptr,c+1);
                      for x:=0 to        nt_pix_cnt_arr_ptr^-(c+1)-1 do
                        begin
                          if           ((nt_pix_sht_arr_ptr^+first_row_pix_ptr)^=0) then
                            begin
                                        (nt_pix_sht_arr_ptr^+first_row_pix_ptr)^:=val;
                              Inc(nt_z_item_cnt);
                            end;
                          Inc           (nt_pix_sht_arr_ptr);
                        end;
                      goto label1;
                    end; {$endregion}

                  {right-clipped-----} {$region -fold}
                  if (first_sht_pix_ptr^>=rct_src.right) then
                    begin
                      Inc               (nt_pix_sht_arr_ptr,
                                         nt_pix_cnt_arr_ptr^);
                      goto label1;
                    end
                  else
                  if ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                    begin
                      c:=BinarySearch1  (nt_pix_cnt_arr_ptr^,
                                         nt_pix_sht_arr_ptr,rct_src.right);
                      for x:=0 to c do
                        begin
                          if           ((nt_pix_sht_arr_ptr^+first_row_pix_ptr)^=0) then
                            begin
                                        (nt_pix_sht_arr_ptr^+first_row_pix_ptr)^:=val;
                              Inc(nt_z_item_cnt);
                            end;
                          Inc           (nt_pix_sht_arr_ptr);
                        end;
                      Inc               (nt_pix_sht_arr_ptr,
                                         nt_pix_cnt_arr_ptr^-(c+1));
                      goto label1;
                    end; {$endregion}

                  {not clipped-------} {$region -fold}
                  if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                     ((first_sht_pix_ptr+nt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                    for x:=0 to          nt_pix_cnt_arr_ptr^-1 do
                      begin
                        if             ((nt_pix_sht_arr_ptr^+first_row_pix_ptr)^=0) then
                          begin
                                        (nt_pix_sht_arr_ptr^+first_row_pix_ptr)^:=val;
                            Inc(nt_z_item_cnt);
                          end;
                        Inc             (nt_pix_sht_arr_ptr);
                      end; {$endregion}

                end;
              label1:
              Inc                       (nt_pix_cnt_arr_ptr);
              Inc(first_row_pix_ptr,arr_dst_width);
            end;
        end;
      if (nt_z_item_cnt=0) then
        nt_useless:=0
      else
        nt_useless:=1;
    end;
end; {$endregion}
procedure TFastImageProc.PTUseless0    (var arr_dst:TColorArr; const arr_dst_width:TColor; const val:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
         arr_dst_ptr: PInteger;
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_z_item_cnt     : TColor=0;
  x,y               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (pt_pix_cnt<>0) then
        begin
          pt_z_item_cnt     :=0;
           first_row_pix_ptr:=Unaligned(@arr_dst       [(pt_pix_arr_row_mrg_top+rct_ent.top)*arr_dst_width+rct_ent.left]);
          pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr[ pt_pix_arr_row_mrg_top+000000000000000000000000000000000000000]);
          pt_pix_sht_arr_ptr:=Unaligned(@pt_pix_sht_arr[000000000000000000000000000000000000000000000000000000000000000]);
          for y:=0 to rct_ent.height-    pt_pix_arr_row_mrg_top-pt_pix_arr_row_mrg_btm-1 do
            begin
              arr_dst_ptr:=first_row_pix_ptr;
              for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                begin
                  if    ((pt_pix_sht_arr_ptr^+arr_dst_ptr)^=0) then
                    begin
                         (pt_pix_sht_arr_ptr^+arr_dst_ptr)^:=val;
                      Inc(pt_z_item_cnt);
                    end;
                  Inc    (pt_pix_sht_arr_ptr);
                end;
              Inc        (pt_pix_cnt_arr_ptr);
              Inc(first_row_pix_ptr,arr_dst_width);
            end;
        end;
      if (pt_z_item_cnt=0) then
        pt_useless:=0
      else
        pt_useless:=1;
    end;
end; {$endregion}
procedure TFastImageProc.PTUseless1    (var arr_dst:TColorArr; const arr_dst_width:TColor; const val:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
         arr_dst_ptr: PInteger;
   first_row_pix_ptr: PInteger;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_z_item_cnt     : TColor=0;
  x,y               : integer;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr=Nil) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        begin
          pt_useless:=0;
          Exit;
        end;
      if (pt_pix_cnt<>0) then
        begin
          pt_z_item_cnt     :=0;
           first_row_pix_ptr:=Unaligned(@arr_dst       [(rct_ent.top   +rct_src.top)*arr_dst_width+rct_ent.left]);
          pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr[ 00000000000000+rct_src.top +00000000000000000000000000]);
          pt_pix_sht_arr_ptr:=Unaligned(@pt_pix_sht_arr[ pt_cnt_ind_arr[rct_src.top]+00000000000000000000000000]);
          for y:=0 to rct_src.height-1 do
            begin
              arr_dst_ptr:=first_row_pix_ptr;
              for x:=0 to pt_pix_cnt_arr_ptr^-1 do
                begin
                  if    ((pt_pix_sht_arr_ptr^+arr_dst_ptr)^=0) then
                    begin
                         (pt_pix_sht_arr_ptr^+arr_dst_ptr)^:=val;
                      Inc(pt_z_item_cnt);
                    end;
                  Inc    (pt_pix_sht_arr_ptr);
                end;
              Inc        (pt_pix_cnt_arr_ptr);
              Inc(first_row_pix_ptr,arr_dst_width);
            end;
        end;
      if (pt_z_item_cnt=0) then
        pt_useless:=0
      else
        pt_useless:=1;
    end;
end; {$endregion}
procedure TFastImageProc.PTUseless2    (var arr_dst:TColorArr; const arr_dst_width:TColor; const val:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
   first_row_pix_ptr: PInteger;
   first_sht_pix_ptr: PWord;
  pt_pix_cnt_arr_ptr: PWord;
  pt_pix_sht_arr_ptr: PWord;
  pt_z_item_cnt     : TColor=0;
  x,y               : integer;
  c,c1,c2           : integer;
label
  label1;
begin
  with fast_image_data_ptr0^ do
    begin
      if (rct_src.width <=0) then
        Exit;
      if (rct_src.height<=0) then
        Exit;
      if (pt_cnt_ind_arr=Nil) then
        Exit;
      if (pt_cnt_ind_arr[rct_src.top]>pt_pix_cnt-1) then
        begin
          pt_useless:=0;
          Exit;
        end;
      if (pt_pix_cnt<>0) then
        begin
          pt_z_item_cnt     :=0;
           first_row_pix_ptr:=Unaligned(@arr_dst       [arr_dst_width *rct_dst.top +rct_dst.left]);
          pt_pix_cnt_arr_ptr:=Unaligned(@pt_pix_cnt_arr[00000000000000+rct_src.top +000000000000]);
          pt_pix_sht_arr_ptr:=Unaligned(@pt_pix_sht_arr[pt_cnt_ind_arr[rct_src.top]+000000000000]);
          for y:=0 to rct_src.height-1 do
            begin
              if                        (pt_pix_cnt_arr_ptr^<>0) then
                begin
                  first_sht_pix_ptr:=    pt_pix_sht_arr_ptr;

                  {left-right-clipped} {$region -fold}
                  if ((first_sht_pix_ptr+000000000000000000000)^< rct_src.left ) and
                     ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                    begin
                      c1:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                         pt_pix_sht_arr_ptr,rct_src.left);
                      c2:=BinarySearch1 (pt_pix_cnt_arr_ptr^,
                                         pt_pix_sht_arr_ptr,rct_src.right);
                      Inc               (pt_pix_sht_arr_ptr,c1+1);
                      for x:=0 to (c2+1)-(c1+1)-1 do
                        begin
                          if           ((pt_pix_sht_arr_ptr^+first_row_pix_ptr)^=0) then
                            begin
                                        (pt_pix_sht_arr_ptr^+first_row_pix_ptr)^:=val;
                              Inc       (pt_z_item_cnt);
                            end;
                          Inc           (pt_pix_sht_arr_ptr);
                        end;
                      Inc               (pt_pix_sht_arr_ptr,
                                         pt_pix_cnt_arr_ptr^-(c2+1));
                      goto label1;
                    end; {$endregion}

                  {left-clipped------} {$region -fold}
                  if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^<rct_src.left) then
                    begin
                      Inc               (pt_pix_sht_arr_ptr,
                                         pt_pix_cnt_arr_ptr^);
                      goto label1;
                    end
                  else
                  if (first_sht_pix_ptr^<rct_src.left) then
                    begin
                      c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                         pt_pix_sht_arr_ptr,rct_src.left);
                      Inc               (pt_pix_sht_arr_ptr,c+1);
                      for x:=0 to        pt_pix_cnt_arr_ptr^-(c+1)-1 do
                        begin
                          if           ((pt_pix_sht_arr_ptr^+first_row_pix_ptr)^=0) then
                            begin
                                        (pt_pix_sht_arr_ptr^+first_row_pix_ptr)^:=val;
                              Inc       (pt_z_item_cnt);
                            end;
                          Inc           (pt_pix_sht_arr_ptr);
                        end;
                      goto label1;
                    end; {$endregion}

                  {right-clipped-----} {$region -fold}
                  if (first_sht_pix_ptr^>=rct_src.right) then
                    begin
                      Inc               (pt_pix_sht_arr_ptr,
                                         pt_pix_cnt_arr_ptr^);
                      goto label1;
                    end
                  else
                  if ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^>=rct_src.right) then
                    begin
                      c:=BinarySearch1  (pt_pix_cnt_arr_ptr^,
                                         pt_pix_sht_arr_ptr,rct_src.right);
                      for x:=0 to c do
                        begin
                          if           ((pt_pix_sht_arr_ptr^+first_row_pix_ptr)^=0) then
                            begin
                                        (pt_pix_sht_arr_ptr^+first_row_pix_ptr)^:=val;
                              Inc       (pt_z_item_cnt);
                            end;
                          Inc           (pt_pix_sht_arr_ptr);
                        end;
                      Inc               (pt_pix_sht_arr_ptr,
                                         pt_pix_cnt_arr_ptr^-(c+1));
                      goto label1;
                    end; {$endregion}

                  {not clipped-------} {$region -fold}
                  if ((first_sht_pix_ptr+000000000000000000000)^>=rct_src.left ) and
                     ((first_sht_pix_ptr+pt_pix_cnt_arr_ptr^-1)^< rct_src.right) then
                    for x:=0 to          pt_pix_cnt_arr_ptr^-1 do
                      begin
                        if             ((pt_pix_sht_arr_ptr^+first_row_pix_ptr)^=0) then
                          begin
                                        (pt_pix_sht_arr_ptr^+first_row_pix_ptr)^:=val;
                            Inc         (pt_z_item_cnt);
                          end;
                        Inc             (pt_pix_sht_arr_ptr);
                      end; {$endregion}

                end;
              label1:
              Inc                       (pt_pix_cnt_arr_ptr);
              Inc(first_row_pix_ptr,arr_dst_width);
            end;
        end;
      if (pt_z_item_cnt=0) then
        pt_useless:=0
      else
        pt_useless:=1;
    end;
end; {$endregion}
function  TFastImageProc.Useless: byte;                                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      if (nt_useless=0) and (pt_useless=0) then
        Result:=0;
      if (nt_useless=1) and (pt_useless=0) then
        Result:=1;
      if (nt_useless=0) and (pt_useless=1) then
        Result:=2;
      if (nt_useless=1) and (pt_useless=1) then
        Result:=3;
    end;
end; {$endregion}
procedure TFastImageProc.SclMulCheck   (                 var fast_image_data_:TFastImageData);        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin

      // scl_mul_check:
      // 0 -  (scl_mul.x =1.0) and (scl_mul.y =1.0);
      // 1 - ((scl_mul.x<=1.0) and (scl_mul.y< 1.0)) or
      //     ((scl_mul.x< 1.0) and (scl_mul.y<=1.0))
      // 2 - ((scl_mul.x>=1.0) and (scl_mul.y> 1.0)) or
      //     ((scl_mul.x> 1.0) and (scl_mul.y>=1.0))
      // 3 - ((scl_mul.x< 1.0) and (scl_mul.y> 1.0)) or
      //     ((scl_mul.x> 1.0) and (scl_mul.y< 1.0));

      if (scl_mul.x=1.0) and (scl_mul.y=1.0) then
        begin
          scl_mul_check:=0;
          Exit;
        end;
      if (scl_mul.x<1.0) then
        begin
          if (scl_mul.y<1.0) then
            begin
              scl_mul_check:=1;
              Exit;
            end
          else
            begin
              scl_mul_check:=3;
              Exit;
            end;
        end
      else
      if (scl_mul.x=1.0) then
        begin
          if (scl_mul.y<1.0) then
            begin
              scl_mul_check:=1;
              Exit;
            end
          else
            begin
              scl_mul_check:=2;
              Exit;
            end;
        end
      else
        begin
          if (scl_mul.y<1.0) then
            begin
              scl_mul_check:=3;
              Exit;
            end
          else
            begin
              scl_mul_check:=2;
              Exit;
            end;
        end;
    end;
end; {$endregion}
procedure TFastImageProc.SetRctPos     (rct:TPtRect);                                                 inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    rct_ent:=rct;
end; {$endregion}
procedure TFastImageProc.SetRctPos     (x,y,w,h:integer);                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,rct_ent do
    begin
      left  :=x;
      top   :=y;
      width :=w;
      height:=h;
      right :=left+width ;
      bottom:=top +height;
    end;
end; {$endregion}
procedure TFastImageProc.SetRctPos     (x,y    :integer);                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,rct_ent do
    begin
      left  :=x;
      top   :=y;
      right :=left+width ;
      bottom:=top +height;
    end;
end; {$endregion}
procedure TFastImageProc.SetRctPos     (x,y    :integer; var fast_image_data_:TFastImageData);        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,rct_ent do
    begin
      left  :=x;
      top   :=y;
      right :=left+width ;
      bottom:=top +height;
    end;
end; {$endregion}
procedure TFastImageProc.SetRctPosF    (x,y    :double);                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^,rct_ent_f do
    begin
      left  :=x;
      top   :=y;
      right :=left+width ;
      bottom:=top +height;
    end;
end; {$endregion}
procedure TFastImageProc.SetRctPosF    (x,y    :double;  var fast_image_data_:TFastImageData);        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_,rct_ent_f do
    begin
      left  :=x;
      top   :=y;
      right :=left+width ;
      bottom:=top +height;
    end;
end; {$endregion}
procedure TFastImageProc.SetRctDst0;                                                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    rct_dst:=ClippedRct(      rct_clp_ptr^,
                              rct_src_mrg,
                        PtRct(rct_ent.left  +rct_src_mrg.left,
                              rct_ent.top   +rct_src_mrg.top,
                              rct_ent.right -rct_src_mrg.right,
                              rct_ent.bottom-rct_src_mrg.bottom),
                              pix_clp_type);
end; {$endregion}
procedure TFastImageProc.SetRctDst0    (                 var fast_image_data_:TFastImageData);        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    rct_dst:=ClippedRct(      rct_clp_ptr^,
                              rct_src_mrg,
                        PtRct(rct_ent.left  +rct_src_mrg.left,
                              rct_ent.top   +rct_src_mrg.top,
                              rct_ent.right -rct_src_mrg.right,
                              rct_ent.bottom-rct_src_mrg.bottom),
                              pix_clp_type);
end; {$endregion}
procedure TFastImageProc.SetRctDst1;                                                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin

      pix_clp_type:=0;
      rct_dst     :=PtRct    (rct_ent.left  +rct_src_mrg.left,
                              rct_ent.top   +rct_src_mrg.top,
                              rct_ent.right -rct_src_mrg.right,
                              rct_ent.bottom-rct_src_mrg.bottom);
      PtsScl       (PtPosF   (pvt0.x,
                              pvt0.y),
                    rct_dst,
                    rct_scl,
                    scl_mul,
                    sdUp);

      if (rct_scl.top       < rct_clp_ptr^.top) then
        begin
          if (rct_scl.bottom< rct_clp_ptr^.top) then
            begin
              pix_clp_type:=3;
              Exit;
            end
          else
            begin
              pix_clp_type:=1;
            end
        end
      else
      if (rct_scl.top       < rct_clp_ptr^.bottom) then
        begin
          if (rct_scl.bottom< rct_clp_ptr^.bottom) then
            begin
              pix_clp_type:=0;
            end
          else
            begin
              pix_clp_type:=1;
            end
        end
      else
        begin
          pix_clp_type:=3;
          Exit;
        end;

      if (rct_scl.left      < rct_clp_ptr^.left) then
        begin
          if (rct_scl.right < rct_clp_ptr^.left) then
            begin
              pix_clp_type:=3;
              Exit;
            end
          else
            begin
              pix_clp_type:=2;
            end;
        end
      else
      if (rct_scl.left      < rct_clp_ptr^.right) then
        begin
          if (rct_scl.right < rct_clp_ptr^.right) then
            begin
              if (pix_clp_type<>1) then
                  pix_clp_type:=0;
            end
          else
            begin
              pix_clp_type:=2;
            end
        end
      else
        begin
          pix_clp_type:=3;
          Exit;
        end;

    end;
end; {$endregion}
procedure TFastImageProc.SetRctDst1    (                 var fast_image_data_:TFastImageData);        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin

      pix_clp_type:=0;
      rct_dst     :=PtRct    (rct_ent.left  +rct_src_mrg.left,
                              rct_ent.top   +rct_src_mrg.top,
                              rct_ent.right -rct_src_mrg.right,
                              rct_ent.bottom-rct_src_mrg.bottom);
      PtsScl       (PtPosF   (pvt0.x,
                              pvt0.y),
                    rct_dst,
                    rct_scl,
                    scl_mul,
                    sdUp);

      if (rct_scl.top       < rct_clp_ptr^.top) then
        begin
          if (rct_scl.bottom< rct_clp_ptr^.top) then
            begin
              pix_clp_type:=3;
              Exit;
            end
          else
            begin
              pix_clp_type:=1;
            end;
        end
      else
      if (rct_scl.top       < rct_clp_ptr^.bottom) then
        begin
          if (rct_scl.bottom< rct_clp_ptr^.bottom) then
            begin
              pix_clp_type:=0;
            end
          else
            begin
              pix_clp_type:=1;
            end
        end
      else
        begin
          pix_clp_type:=3;
          Exit;
        end;

      if (rct_scl.left      < rct_clp_ptr^.left) then
        begin
          if (rct_scl.right < rct_clp_ptr^.left) then
            begin
              pix_clp_type:=3;
              Exit;
            end
          else
            begin
              pix_clp_type:=2;
            end;
        end
      else
      if (rct_scl.left      < rct_clp_ptr^.right) then
        begin
          if (rct_scl.right < rct_clp_ptr^.right) then
            begin
              if (pix_clp_type<>1) then
                  pix_clp_type:=0;
            end
          else
            begin
              pix_clp_type:=2;
            end
        end
      else
        begin
          pix_clp_type:=3;
          Exit;
        end;

    end;
end; {$endregion}
procedure TFastImageProc.SetRctDst2;                                                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst_   : TPtRect;
  d1,d2      : double;
  b0,b1,b2,b3: integer;
begin
  with fast_image_data_ptr0^ do
    begin
      pix_clp_type:=0;
      rct_dst     :=PtRct          (rct_ent.left  +rct_src_mrg.left  ,
                                    rct_ent.top   +rct_src_mrg.top   ,
                                    rct_ent.right -rct_src_mrg.right ,
                                    rct_ent.bottom-rct_src_mrg.bottom);
     {rct_dst_    :=PtRct          (rct_ent.left  +rct_src_mrg.left  +pvt1.x,
                                    rct_ent.top   +rct_src_mrg.top   +pvt1.y,
                                    rct_ent.right -rct_src_mrg.right +pvt1.x,
                                    rct_ent.bottom-rct_src_mrg.bottom+pvt1.y);}
      PtsScl       (PtPosF         (pvt1.x,
                                    pvt1.y),
                    rct_dst,
                    rct_scl,
                    scl_mul,
                    sdUp);
      d1          :=               (rct_ent.left+pvt1.x)*(1-scl_mul.x);
      d2          :=               (rct_ent.top +pvt1.y)*(1-scl_mul.y);

      if (rct_scl.top       <       rct_clp_ptr^.top) then
        begin
          if (rct_scl.bottom<       rct_clp_ptr^.top) then
            begin
              pix_clp_type :=3;
              Exit;
            end
          else
          if (rct_scl.bottom<       rct_clp_ptr^.bottom) then
            begin
              b1           :=Trunc((rct_clp_ptr^.top   -d2)/scl_mul.y);
              b3           :=       rct_dst     .bottom;
              pix_clp_type :=1;
            end
          else
            begin
              b1           :=Trunc((rct_clp_ptr^.top   -d2)/scl_mul.y);
              b3           :=Trunc((rct_clp_ptr^.bottom-d2)/scl_mul.y);
              pix_clp_type :=1;
            end
        end
      else
      if (rct_scl.top       <       rct_clp_ptr^.bottom) then
        begin
          if (rct_scl.bottom<       rct_clp_ptr^.bottom) then
            begin
              b1           :=       rct_dst     .top;
              b3           :=       rct_dst     .bottom;
              pix_clp_type :=0;
            end
          else
            begin
              b1           :=       rct_dst     .top;
              b3           :=Trunc((rct_clp_ptr^.bottom-d2)/scl_mul.y);
              pix_clp_type :=1;
            end
        end
      else
        begin
          pix_clp_type:=3;
          Exit;
        end;

      if (rct_scl.left      <       rct_clp_ptr^.left) then
        begin
          if (rct_scl.right <       rct_clp_ptr^.left) then
            begin
              pix_clp_type:=3;
              Exit;
            end
          else
          if (rct_scl.right <       rct_clp_ptr^.right) then
            begin
              b0           :=Trunc((rct_clp_ptr^.left  -d1)/scl_mul.x);
              b2           :=       rct_dst     .right;
              pix_clp_type :=2;
            end
          else
            begin
              b0           :=Trunc((rct_clp_ptr^.left  -d1)/scl_mul.x);
              b2           :=Trunc((rct_clp_ptr^.right -d1)/scl_mul.x);
              pix_clp_type :=2;
            end
        end
      else
      if (rct_scl.left      <       rct_clp_ptr^.right) then
        begin
          if (rct_scl.right <       rct_clp_ptr^.right) then
            begin
              b0           :=       rct_dst     .left;
              b2           :=       rct_dst     .right;
              if (pix_clp_type<>1) then
                  pix_clp_type:=0;
            end
          else
            begin
              b0           :=       rct_dst     .left;
              b2           :=Trunc((rct_clp_ptr^.right -d1)/scl_mul.x);
              pix_clp_type :=2;
            end
        end
      else
        begin
          pix_clp_type:=3;
          Exit;
        end;

      rct_dst:=PtRct(b0,b1,b2,b3);
    end;
end; {$endregion}
procedure TFastImageProc.SetRctDst2    (                 var fast_image_data_:TFastImageData);        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  d1,d2      : double;
  b0,b1,b2,b3: integer;
begin
  with fast_image_data_ do
    begin
      pix_clp_type:=0;
      rct_dst     :=PtRct          (rct_ent.left  +rct_src_mrg.left  ,
                                    rct_ent.top   +rct_src_mrg.top   ,
                                    rct_ent.right -rct_src_mrg.right ,
                                    rct_ent.bottom-rct_src_mrg.bottom);
      PtsScl       (PtPosF         (pvt0.x,
                                    pvt0.y),
                    rct_dst,
                    rct_scl,
                    scl_mul,
                    sdUp);
      d1          :=               (rct_ent.left+pvt1.x)*(1-scl_mul.x);
      d2          :=               (rct_ent.top +pvt1.y)*(1-scl_mul.y);

      if (rct_scl.top       <       rct_clp_ptr^.top) then
        begin
          if (rct_scl.bottom<       rct_clp_ptr^.top) then
            begin
              pix_clp_type :=3;
              Exit;
            end
          else
          if (rct_scl.bottom<       rct_clp_ptr^.bottom) then
            begin
              b1           :=Trunc((rct_clp_ptr^.top   -d2)/scl_mul.y);
              b3           :=       rct_dst     .bottom;
              pix_clp_type :=1;
            end
          else
            begin
              b1           :=Trunc((rct_clp_ptr^.top   -d2)/scl_mul.y);
              b3           :=Trunc((rct_clp_ptr^.bottom-d2)/scl_mul.y);
              pix_clp_type :=1;
            end
        end
      else
      if (rct_scl.top       <       rct_clp_ptr^.bottom) then
        begin
          if (rct_scl.bottom<       rct_clp_ptr^.bottom) then
            begin
              b1           :=       rct_dst     .top;
              b3           :=       rct_dst     .bottom;
              pix_clp_type :=0;
            end
          else
            begin
              b1           :=       rct_dst     .top;
              b3           :=Trunc((rct_clp_ptr^.bottom-d2)/scl_mul.y);
              pix_clp_type :=1;
            end
        end
      else
        begin
          pix_clp_type:=3;
          Exit;
        end;

      if (rct_scl.left      <       rct_clp_ptr^.left) then
        begin
          if (rct_scl.right <       rct_clp_ptr^.left) then
            begin
              pix_clp_type:=3;
              Exit;
            end
          else
          if (rct_scl.right <       rct_clp_ptr^.right) then
            begin
              b0           :=Trunc((rct_clp_ptr^.left  -d1)/scl_mul.x);
              b2           :=       rct_dst     .right;
              pix_clp_type :=2;
            end
          else
            begin
              b0           :=Trunc((rct_clp_ptr^.left  -d1)/scl_mul.x);
              b2           :=Trunc((rct_clp_ptr^.right -d1)/scl_mul.x);
              pix_clp_type :=2;
            end
        end
      else
      if (rct_scl.left      <       rct_clp_ptr^.right) then
        begin
          if (rct_scl.right <       rct_clp_ptr^.right) then
            begin
              b0           :=       rct_dst     .left;
              b2           :=       rct_dst     .right;
              if (pix_clp_type<>1) then
                  pix_clp_type:=0;
            end
          else
            begin
              b0           :=       rct_dst     .left;
              b2           :=Trunc((rct_clp_ptr^.right -d1)/scl_mul.x);
              pix_clp_type :=2;
            end
        end
      else
        begin
          pix_clp_type:=3;
          Exit;
        end;

      rct_dst:=PtRct(b0,b1,b2,b3);
    end;
end; {$endregion}
procedure TFastImageProc.SetRctDst3;                                                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  d1,d2      : double;
  b0,b1,b2,b3: double;
begin
  with fast_image_data_ptr0^ do
    begin
      pix_clp_type:=0;
      rct_dst_f   :=PtRctF   (rct_ent_f.left  +rct_src_mrg.left  ,
                              rct_ent_f.top   +rct_src_mrg.top   ,
                              rct_ent_f.right -rct_src_mrg.right ,
                              rct_ent_f.bottom-rct_src_mrg.bottom);
      PtsScl       (PtPosF   (pvt0.x,
                              pvt0.y),
                    rct_dst_f,
                    rct_scl,
                    scl_mul,
                    sdUp);
      d1          :=          pvt0.x*(1-scl_mul.x);
      d2          :=          pvt0.y*(1-scl_mul.y);

      if (rct_scl.top       < rct_clp_ptr^.top) then
        begin
          if (rct_scl.bottom< rct_clp_ptr^.top) then
            begin
              pix_clp_type :=3;
              Exit;
            end
          else
          if (rct_scl.bottom< rct_clp_ptr^.bottom) then
            begin
              b1           :=(rct_clp_ptr^.top   -d2)/scl_mul.y;
              b3           := rct_dst_f   .bottom;
              pix_clp_type :=1;
            end
          else
            begin
              b1           :=(rct_clp_ptr^.top   -d2)/scl_mul.y;
              b3           :=(rct_clp_ptr^.bottom-d2)/scl_mul.y;
              pix_clp_type :=1;
            end
        end
      else
      if (rct_scl.top       < rct_clp_ptr^.bottom) then
        begin
          if (rct_scl.bottom< rct_clp_ptr^.bottom) then
            begin
              b1           := rct_dst_f   .top;
              b3           := rct_dst_f   .bottom;
              pix_clp_type :=0;
            end
          else
            begin
              b1           := rct_dst_f   .top;
              b3           :=(rct_clp_ptr^.bottom-d2)/scl_mul.y;
              pix_clp_type :=1;
            end
        end
      else
        begin
          pix_clp_type:=3;
          Exit;
        end;

      if (rct_scl.left      < rct_clp_ptr^.left) then
        begin
          if (rct_scl.right < rct_clp_ptr^.left) then
            begin
              pix_clp_type:=3;
              Exit;
            end
          else
          if (rct_scl.right < rct_clp_ptr^.right) then
            begin
              b0           :=(rct_clp_ptr^.left  -d1)/scl_mul.x;
              b2           := rct_dst_f   .right;
              pix_clp_type :=2;
            end
          else
            begin
              b0           :=(rct_clp_ptr^.left  -d1)/scl_mul.x;
              b2           :=(rct_clp_ptr^.right -d1)/scl_mul.x;
              pix_clp_type :=2;
            end
        end
      else
      if (rct_scl.left      < rct_clp_ptr^.right) then
        begin
          if (rct_scl.right < rct_clp_ptr^.right) then
            begin
              b0           := rct_dst_f   .left;
              b2           := rct_dst_f   .right;
              if (pix_clp_type<>1) then
                  pix_clp_type:=0;
            end
          else
            begin
              b0           := rct_dst_f   .left;
              b2           :=(rct_clp_ptr^.right -d1)/scl_mul.x;
              pix_clp_type :=2;
            end
        end
      else
        begin
          pix_clp_type:=3;
          Exit;
        end;

      rct_dst_f:=PtRctF(b0,b1,b2,b3);
    end;
end; {$endregion}
procedure TFastImageProc.SetRctDst3    (                 var fast_image_data_:TFastImageData);        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  d1,d2      : double;
  b0,b1,b2,b3: double;
begin
  with fast_image_data_ do
    begin
      pix_clp_type:=0;
      rct_dst_f   :=PtRctF   (rct_ent_f.left  +rct_src_mrg.left  ,
                              rct_ent_f.top   +rct_src_mrg.top   ,
                              rct_ent_f.right -rct_src_mrg.right ,
                              rct_ent_f.bottom-rct_src_mrg.bottom);
      PtsScl       (PtPosF   (pvt0.x,
                              pvt0.y),
                    rct_dst_f,
                    rct_scl,
                    scl_mul,
                    sdUp);
      d1          :=          pvt0.x*(1-scl_mul.x);
      d2          :=          pvt0.y*(1-scl_mul.y);

      if (rct_scl.top       < rct_clp_ptr^.top) then
        begin
          if (rct_scl.bottom< rct_clp_ptr^.top) then
            begin
              pix_clp_type :=3;
              Exit;
            end
          else
          if (rct_scl.bottom< rct_clp_ptr^.bottom) then
            begin
              b1           :=(rct_clp_ptr^.top   -d2)/scl_mul.y;
              b3           := rct_dst_f   .bottom;
              pix_clp_type :=1;
            end
          else
            begin
              b1           :=(rct_clp_ptr^.top   -d2)/scl_mul.y;
              b3           :=(rct_clp_ptr^.bottom-d2)/scl_mul.y;
              pix_clp_type :=1;
            end
        end
      else
      if (rct_scl.top       < rct_clp_ptr^.bottom) then
        begin
          if (rct_scl.bottom< rct_clp_ptr^.bottom) then
            begin
              b1           := rct_dst_f   .top;
              b3           := rct_dst_f   .bottom;
              pix_clp_type :=0;
            end
          else
            begin
              b1           := rct_dst_f   .top;
              b3           :=(rct_clp_ptr^.bottom-d2)/scl_mul.y;
              pix_clp_type :=1;
            end
        end
      else
        begin
          pix_clp_type:=3;
          Exit;
        end;

      if (rct_scl.left      < rct_clp_ptr^.left) then
        begin
          if (rct_scl.right < rct_clp_ptr^.left) then
            begin
              pix_clp_type:=3;
              Exit;
            end
          else
          if (rct_scl.right < rct_clp_ptr^.right) then
            begin
              b0           :=(rct_clp_ptr^.left  -d1)/scl_mul.x;
              b2           := rct_dst_f   .right;
              pix_clp_type :=2;
            end
          else
            begin
              b0           :=(rct_clp_ptr^.left  -d1)/scl_mul.x;
              b2           :=(rct_clp_ptr^.right -d1)/scl_mul.x;
              pix_clp_type :=2;
            end
        end
      else
      if (rct_scl.left      < rct_clp_ptr^.right) then
        begin
          if (rct_scl.right < rct_clp_ptr^.right) then
            begin
              b0           := rct_dst_f   .left;
              b2           := rct_dst_f   .right;
              if (pix_clp_type<>1) then
                  pix_clp_type:=0;
            end
          else
            begin
              b0           := rct_dst_f   .left;
              b2           :=(rct_clp_ptr^.right -d1)/scl_mul.x;
              pix_clp_type :=2;
            end
        end
      else
        begin
          pix_clp_type:=3;
          Exit;
        end;

      rct_dst_f:=PtRctF(b0,b1,b2,b3);
    end;
end; {$endregion}
procedure TFastImageProc.SetRctSrc;                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    rct_src:=PtBounds(rct_dst.left  -rct_ent.left,
                      rct_dst.top   -rct_ent.top,
                      rct_dst.right -rct_dst.left,
                      rct_dst.bottom-rct_dst.top);
end; {$endregion}
procedure TFastImageProc.SetRctSrc     (                 var fast_image_data_:TFastImageData);        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    rct_src:=PtBounds(rct_dst.left  -rct_ent.left,
                      rct_dst.top   -rct_ent.top,
                      rct_dst.right -rct_dst.left,
                      rct_dst.bottom-rct_dst.top);
end; {$endregion}
procedure TFastImageProc.SetRctSrcF;                                                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    rct_src_f:=PtBoundsF(rct_dst_f.left  -rct_ent_f.left,
                         rct_dst_f.top   -rct_ent_f.top ,
                         rct_dst_f.right -rct_ent_f.left,
                         rct_dst_f.bottom-rct_ent_f.top );
end; {$endregion}
procedure TFastImageProc.SetRctSrcF    (                 var fast_image_data_:TFastImageData);        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    rct_src_f:=PtBoundsF(rct_dst_f.left  -rct_ent_f.left,
                         rct_dst_f.top   -rct_ent_f.top ,
                         rct_dst_f.right -rct_ent_f.left,
                         rct_dst_f.bottom-rct_ent_f.top );
end; {$endregion}
procedure TFastImageProc.GetFrameHeight(frame_cnt:word);                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      frame_cnt_v     :=frame_cnt;
      frame_height    :=rct_ent.height/{div} frame_cnt;
      frame_height_int:=Trunc(frame_height);
    end;
end; {$endregion} {$endregion}

{Init. part--------------------------------------------} {$region -fold}
constructor TFastImageProc.Create;                                                                                                                 {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  //FastImageDataMTInit;
  CmpProcInit;
  FilProcInit;
  SdrProcInit;
  UlsProcInit;
  SdrTypeInit;
  SRIProcInit;
  RRIProcInit;
end; {$endregion}
destructor  TFastImageProc.Destroy;                                                                                                                {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  self.Free;
  inherited Destroy;
end; {$endregion}
procedure   TFastImageProc.SetBkgnd  (const bkgnd_ptr:PInteger; const bkgnd_width,bkgnd_height:TColor; const rct_clp:TPtRect);             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      bmp_bkgnd_ptr   :=bkgnd_ptr   ;
      bmp_bkgnd_width :=bkgnd_width ;
      bmp_bkgnd_height:=bkgnd_height;
      rct_clp_ptr     :=@rct_clp;
    end;
end; {$endregion}
procedure   TFastImageProc.SetClpRct (const rct_clp:TPtRect);                                                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    rct_clp_ptr:=@rct_clp;
end; {$endregion}
procedure   TFastImageProc.SetValInfo(const bmp_color_ptr_,bmp_alpha_ptr_,bmp_value_ptr_:PInteger; const ftimg_width,ftimg_height:TColor); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      bmp_color_ptr          :=bmp_color_ptr_;
      bmp_alpha_ptr          :=bmp_alpha_ptr_;
      bmp_value_ptr          :=bmp_value_ptr_;
      rct_ent  .width        :=ftimg_width ;
      rct_ent  .height       :=ftimg_height;
      bmp_ftimg_width_origin :=ftimg_width ;
      bmp_ftimg_height_origin:=ftimg_height;
    end;
end; {$endregion}
procedure   TFastImageProc.SetPPInfo (const val:TColor=$00434D3E);                                                                         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    monochrome_val:=RGB(TRGBA(val).b,
                        TRGBA(val).g,
                        TRGBA(val).r);
end; {$endregion}
procedure   TFastImageProc.SetPPInfo (const val:TColor;                                       var fast_image_data_:TFastImageData);        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    monochrome_val:=RGB(TRGBA(val).b,
                        TRGBA(val).g,
                        TRGBA(val).r);
end; {$endregion}
procedure   TFastImageProc.FXInit;                                                                                                         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {TODO}
end; {$endregion}
procedure   TFastImageProc.SetGradVec(x,y:integer);                                                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      grad_vec:=PtPos(x,y);
      with grad_prop do
        begin
          if set_grad_to_vis_area then
            grad_vec_dif:=grad_vec.y-grad_vec.x
          else
            grad_vec_dif:=rct_ent.height;
        end;
    end;
end; {$endregion}
procedure   TFastImageProc.SetGradVec(x,y:integer; const fast_image_data_ptr_:PFastImageData; var fast_image_data_:TFastImageData);        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      grad_vec:=PtPos(x,y);
      with grad_prop do
        begin
          if set_grad_to_vis_area then
            grad_vec_dif:=grad_vec.y-grad_vec.x
          else
            grad_vec_dif:=fast_image_data_ptr_^.rct_ent.height;
        end;
    end;
end; {$endregion}
procedure   TFastImageProc.SetGradCol(x,y:TColor);                                                                                         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ptr0^ do
    begin
      grad_col:=PtPos2(x,y);
      with grad_prop do
        begin
          grad_col0         := TRGBA(grad_col.x);
          grad_col0.a       :=-TRGBA(grad_col.x).a+MAXBYTE;
          grad_col1         := TRGBA(grad_col.y);
          grad_col1.a       :=-TRGBA(grad_col.y).a+MAXBYTE;
          grad_col_dif    .r:=grad_col1.r-grad_col0.r;
          grad_col_dif    .g:=grad_col1.g-grad_col0.g;
          grad_col_dif    .b:=grad_col1.b-grad_col0.b;
          grad_col_dif    .a:=grad_col1.a-grad_col0.a;
          grad_rng_div_vec.r:=FloatToFixed(grad_col_dif.r/grad_vec_dif);
          grad_rng_div_vec.g:=FloatToFixed(grad_col_dif.g/grad_vec_dif);
          grad_rng_div_vec.b:=FloatToFixed(grad_col_dif.b/grad_vec_dif);
          grad_rng_div_vec.a:=FloatToFixed(grad_col_dif.a/grad_vec_dif);
          if (not set_grad_to_vis_area) then
            begin
              grad_col0   .r+=(grad_rng_div_vec.r*grad_vec.x)>>16;
              grad_col0   .g+=(grad_rng_div_vec.g*grad_vec.x)>>16;
              grad_col0   .b+=(grad_rng_div_vec.b*grad_vec.x)>>16;
              grad_col0   .a+=(grad_rng_div_vec.a*grad_vec.x)>>16;
              grad_col1   .r+=(grad_rng_div_vec.r*grad_vec.y)>>16;
              grad_col1   .g+=(grad_rng_div_vec.g*grad_vec.y)>>16;
              grad_col1   .b+=(grad_rng_div_vec.b*grad_vec.y)>>16;
              grad_col1   .a+=(grad_rng_div_vec.a*grad_vec.y)>>16;
            end;
        end;
    end;
end; {$endregion}
procedure   TFastImageProc.SetGradCol(x,y:TColor;                                             var fast_image_data_:TFastImageData);        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data_ do
    begin
      grad_col:=PtPos2(x,y);
      with grad_prop do
        begin
          grad_col0         := TRGBA(grad_col.x);
          grad_col0.a       :=-TRGBA(grad_col.x).a+MAXBYTE;
          grad_col1         := TRGBA(grad_col.y);
          grad_col1.a       :=-TRGBA(grad_col.y).a+MAXBYTE;
          grad_col_dif    .r:=grad_col1.r-grad_col0.r;
          grad_col_dif    .g:=grad_col1.g-grad_col0.g;
          grad_col_dif    .b:=grad_col1.b-grad_col0.b;
          grad_col_dif    .a:=grad_col1.a-grad_col0.a;
          grad_rng_div_vec.r:=FloatToFixed(grad_col_dif.r/grad_vec_dif);
          grad_rng_div_vec.g:=FloatToFixed(grad_col_dif.g/grad_vec_dif);
          grad_rng_div_vec.b:=FloatToFixed(grad_col_dif.b/grad_vec_dif);
          grad_rng_div_vec.a:=FloatToFixed(grad_col_dif.a/grad_vec_dif);
          if (not set_grad_to_vis_area) then
            begin
              grad_col0   .r+=(grad_rng_div_vec.r*grad_vec.x)>>16;
              grad_col0   .g+=(grad_rng_div_vec.g*grad_vec.x)>>16;
              grad_col0   .b+=(grad_rng_div_vec.b*grad_vec.x)>>16;
              grad_col0   .a+=(grad_rng_div_vec.a*grad_vec.x)>>16;
              grad_col1   .r+=(grad_rng_div_vec.r*grad_vec.y)>>16;
              grad_col1   .g+=(grad_rng_div_vec.g*grad_vec.y)>>16;
              grad_col1   .b+=(grad_rng_div_vec.b*grad_vec.y)>>16;
              grad_col1   .a+=(grad_rng_div_vec.a*grad_vec.y)>>16;
            end;
        end;
    end;
end; {$endregion}
procedure   TFastImageProc.SrcDestroy(bmp_src:TPicture  );                                                                                 inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  bmp_src.Free;
end; {$endregion}
procedure   TFastImageProc.SrcDestroy(bmp_src:TBitmap   );                                                                                 inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  bmp_src.Free;
end; {$endregion}
procedure   TFastImageProc.SrcDestroy(arr_src:TColorArr );                                                                                 inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(arr_src,0);
  Finalize (arr_src);
end; {$endregion}
procedure   TFastImageProc.SrcDestroy(arr_src:TWordArr  );                                                                                 inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(arr_src,0);
  Finalize (arr_src);
end; {$endregion}
procedure   TFastImageProc.SrcDestroy(arr_src:T1Byte1Arr);                                                                                 inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(arr_src,0);
  Finalize (arr_src);
end; {$endregion}
constructor TFastImageItem.Create    (const bkgnd_ptr:PInteger; const bkgnd_width,bkgnd_height:TColor; var rct_clp:TPtRect; const bmp_src_rct:TPtRect; const empty:TColor=0);                                                                                                                                                            {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_image_data,fast_image_proc_var do
    begin

      fast_image_data_ptr0:=@fast_image_data;

      {Set Scale Multiplayer----------} {$region -fold}
      scl_mul             :=PtPosF(1.0,1.0); {$endregion}

      {Set Drawing Surface(Background)} {$region -fold}
      SetBkgnd(bkgnd_ptr,bkgnd_width,bkgnd_height,rct_clp); {$endregion}

      {Misc. Precalc. Settings--------} {$region -fold}
      ShaderInfo();
      SetPPInfo; {$endregion}

    end;
end; {$endregion}
constructor TFastImageItem.Create    (const bkgnd_ptr:PInteger; const bkgnd_width,bkgnd_height:TColor; var rct_clp:TPtRect; const bmp_src_rct:TPtRect; const location:string=''; const ImgLstGetBmp:TProc1=Nil; const img_ind:TColor=0; const tile_map_calc_:boolean=False; const pic_src:TPicture=Nil; const is_gpu_tex:boolean=False); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  icn_src_pic       : TPicture=Nil;
  icn_src0          : TBitmap =Nil;
  icn_src           : TBitmap =Nil;
  icn_src_ptr       : PInteger=Nil;
  icn_src_pic_is_nil: boolean =True;
  icn_src0_is_nil   : boolean =True;
  n_b,p_b           : boolean;
  w_mul_h           : integer;
  i,j               : integer;
begin

  with fast_image_data,fast_image_proc_var do
    begin

      fast_image_data_ptr0:=@fast_image_data;

      {Set Scale Multiplayer-----------} {$region -fold}
      scl_mul             :=PtPosF(1.0,1.0); {$endregion}

      {Is Spite a Tile Map-------------} {$region -fold}
      tile_map_calc:=tile_map_calc_;
      if tile_map_calc then
        begin
          sln_prop_var   :=curve_default_prop;
          grid_visible   :=False;
          grid_draw_after:=False;
          SetColorInfo(clBlack,grid_color_info);
        end; {$endregion}

      {Set Drawing Surface(Background)-} {$region -fold}
      SetBkgnd(bkgnd_ptr,bkgnd_width,bkgnd_height,rct_clp); {$endregion}

      {Misc. Precalc. Settings---------} {$region -fold}
      ShaderInfo;
      SetPPInfo; {$endregion}

      {Load Sprite---------------------} {$region -fold}
      if (pic_src<>Nil) then
        begin
          icn_src        :=CrtTBmpInst(pic_src.Bitmap,icn_src_ptr);
          icn_src0_is_nil:=False;
        end
      else
      if FileExists(location) then
        begin
          icn_src_pic       :=CrtTPicInstFromHDDSrc(location);
          icn_src           :=CrtTBmpInst(icn_src_pic.Bitmap,icn_src_ptr);
          icn_src_pic_is_nil:=False;

          if is_gpu_tex then
            begin
              texture_test_width := icn_src.width;
              texture_test_height:= icn_src.height;
              texture_test_ptr   := icn_src_ptr;
              texture_test_ptr2  :=@icn_src;
            end;

        end
      else
      if (ImgLstGetBmp<>Nil) then
        begin
          icn_src0       :=CrtTBmpInstFromImgLst(ImgLstGetBmp,img_ind);
          icn_src        :=CrtTBmpInst(icn_src0,icn_src_ptr);
          icn_src0_is_nil:=False;
        end;
      if (icn_src_ptr=Nil) then
        Exit; {$endregion}

      {Compress Sprite-----------------} {$region -fold}
      SetValInfo(icn_src_ptr,icn_src_ptr,icn_src_ptr,icn_src.width,icn_src.height);
      bmp_src_rct_clp:=      ClippedRct(PtBounds(0,0,icn_src.width,icn_src.height),bmp_src_rct);
      ImgToCImg;
      rct_ent.width :=bmp_src_rct_clp.width;
      rct_ent.height:=bmp_src_rct_clp.height; {$endregion}

      {Create a Tile Map Collision Grid} {$region -fold}
      if tile_map_calc then
        begin
          SetLength   (tilemap_coll_grid0,icn_src.width*icn_src.height);
          BorderCalc00(icn_src_ptr,tilemap_coll_grid0,ft_pix_cnt,icn_src.width,icn_src.height,icn_src.width,PtBounds(0,0,icn_src.width,icn_src.height),clBlack);

         {SetLength   (tilemap_coll_grid1,icn_src.width*icn_src.height);
          BorderCalc01(icn_src_ptr,tilemap_coll_grid1,ft_pix_cnt,icn_src.width,icn_src.height,icn_src.width,PtBounds(0,0,icn_src.width,icn_src.height),clBlack);}

          {F_MainForm.M_Test_Log.Lines.Text:='';
          F_MainForm.M_Test_Log.Lines.Add(IntToStr(ft_pix_cnt)+'; '+IntToStr(zr_pix_cnt)+'; '+IntToStr(nt_pix_cnt)+'; '+IntToStr(pt_pix_cnt)+'; ');
          for j:=0 to icn_src.height-1 do
            begin
              for i:=0 to icn_src.width-1 do
                F_MainForm.M_Test_Log.Lines.Add(IntToStr(tilemap_coll_grid1[i+j*icn_src.width])+'; ');
              F_MainForm.M_Test_Log.Lines.Add(#13);
            end;}

        end; {$endregion}

      {Clear Resources-----------------} {$region -fold}
      DeleteObject(icn_src.Canvas.Handle);
      w_mul_h:=bmp_ftimg_width_origin*bmp_ftimg_height_origin;
      n_b    :=(nt_pix_cnt>0) and (nt_pix_cnt<w_mul_h);
      p_b    :=(pt_pix_cnt>0) and (pt_pix_cnt<w_mul_h);
      if ((img_kind=0) and n_b
                       and p_b) or
         ((img_kind=1) and n_b) or
         ((img_kind=2) and p_b) or
         ((img_kind=3) and n_b) or
         ((img_kind=4) and p_b) then
        if (not is_gpu_tex) then
          begin
            DeleteObject(icn_src.Handle);
            SrcDestroy  (icn_src);
          end;
      if (not icn_src_pic_is_nil) then
        SrcDestroy(icn_src_pic);
      if (not icn_src0_is_nil) then
        SrcDestroy(icn_src0);
      icn_src_ptr:=Nil; {$endregion}

    end;

end; {$endregion}
destructor  TFastImageItem.Destroy;                                                                                                                {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  self.Free;
  inherited Destroy;
end; {$endregion}
{$endregion}

{$endregion}



(**************************** Fast actor container ****************************) {$region -fold}

constructor TFastActorSet.Create(const bkgnd_ptr:PInteger; const bkgnd_width,bkgnd_height:TColor; var rct_clp:TPtRect; const bmp_src_rct:TPtRect; const location:string=''; const ImgLstGetBmp:TProc1=Nil; const d_icon_img_lst_ind:TColor=0); {$region -fold}
begin

  {Default Icon---} {$region -fold}
  d_icon:=TFastImageItem.Create(bkgnd_ptr,
                                bkgnd_width,
                                bkgnd_height,
                                rct_clp,
                                bmp_src_rct,
                                location,
                                ImgLstGetBmp,
                                d_icon_img_lst_ind); {$endregion}

  {Selection Field} {$region -fold}
  SetLength(sel_fld,bkgnd_width*bkgnd_height);
  sel_fld_ptr:=@sel_fld[0]; {$endregion}

end; {$endregion}
destructor TFastActorSet.Destroy; {$region -fold}
begin
  self.Free;
  inherited Destroy;
end; {$endregion}
procedure TFastActorSet.AddActor(x,y:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with d_icon,fast_image_proc_var,fast_image_data_ptr0^ do
    begin
      fast_image_data_ptr0:=@d_icon.fast_image_data;
      Inc        (act_cnt);
      SetLength  (act_arr,
                  act_cnt);
      SetLength  (act_pos_arr,
                  act_cnt);
      act_arr    [act_cnt-1]  :=TFastActor.Create;
      act_pos_arr[act_cnt-1].x:=x-rct_ent.width >>1;
      act_pos_arr[act_cnt-1].y:=y-rct_ent.height>>1;
      with d_icon do
        SdrProc[sdr_proc_ind](x,y,fast_image_data_ptr0);
    end;
end; {$endregion}

{$endregion}



(********************************* Fast actor *********************************) {$region -fold}

constructor TFastActor.Create; {$region -fold}
begin
  SetLength(frm_arr,frm_cnt);
end; {$endregion}
destructor TFastActor.Destroy; {$region -fold}
begin
  self.Free;
  inherited Destroy;
end; {$endregion}

{$endregion}



(***************************** Fast line routines *****************************) {$region -fold}

{Init. part--} {$region -fold}
constructor TFastLine.Create;                                                                                                                {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  LineSInit;
end; {$endregion}
destructor TFastLine.Destroy;                                                                                                                {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  self.Free;
  inherited Destroy;
end; {$endregion}
procedure TFastLine.GCCArrInit;                                                                                                      inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  gcd_arr:=Nil;
  SetLength  (gcd_arr,ln_arr_width*ln_arr_height);
  LinePrecalc(        ln_arr_width,ln_arr_height);
end; {$endregion}
procedure TFastLine.GetLineBuffHndl;                                                                                                 inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if ((ln_arr_width=0) or (ln_arr_height=0)) then
    Exit;
  ln_arr0_ptr:=Unaligned(@ln_arr0[0]);
  ln_arr1_ptr:=Unaligned(@ln_arr1[0]);
end; {$endregion}
procedure TFastLine.BuffersInit(w,h:TColor; ln_arr0_init:boolean; ln_arr1_init:boolean; ln_arr2_init:boolean; aa_buff_init:boolean); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  if ((w=0) or (h=0)) then
    Exit;
  ln_arr_width :=w;
  ln_arr_height:=h;
  if ln_arr0_init then
    begin
      SetLength(ln_arr0,w*h);
      ln_arr0_ptr:=Unaligned(@ln_arr0[0]);
    end;
  if ln_arr1_init then
    begin
      SetLength(ln_arr1,w*h);
      ln_arr1_ptr:=Unaligned(@ln_arr1[0]);
    end;
  if ln_arr2_init then
    begin
      SetLength(ln_arr2,w);
      for i:=0 to w-1 do
        SetLength(ln_arr2[i],h);
    end;
  if aa_buff_init then
    begin
      SetLength(aa_arr1,w*h);
      SetLength(aa_arr2,w*h);
    end;
  {if (ln_arr0<>Nil) then
    ArrClr(ln_arr0,PtRct(0,0,ln_arr_width,ln_arr_height),ln_arr_width);
  if (ln_arr1<>Nil) then
    ArrClr(ln_arr1,PtRct(0,0,ln_arr_width,ln_arr_height),ln_arr_width);
  if (ln_arr2<>Nil) then
    ArrClr(ln_arr2,PtRct(0,0,ln_arr_width,ln_arr_height),ln_arr_width);}
end; {$endregion}
procedure TFastLine.SetBkgnd(const bmp_dst_ptr_:PInteger; const bmp_dst_width_,bmp_dst_height_:TColor; const rct_clp_ptr_:PPtRect);  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  bmp_dst_ptr   :=bmp_dst_ptr_;
  bmp_dst_width :=bmp_dst_width_;
  bmp_dst_height:=bmp_dst_height_;
  rct_clp_ptr   :=rct_clp_ptr_;
end; {$endregion}
procedure TFastLine.MinimizeArrs(aa_buff_clear:boolean);                                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Setlength(ln_arr0,0);
  Setlength(ln_arr1,0);
  Setlength(ln_arr2,0);
  if (not aa_buff_clear) then
    Exit;
  Setlength(aa_arr1,0);
  Setlength(aa_arr2,0);
end; {$endregion} {$endregion}

{Line drawing} {$region -fold}
// (Fast line grid precalculation) Предрасчет сетки для быстрой линии:
{class} procedure TFastLine.LinePrecalc(w,h:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  gcd_arr_ptr            : PGCDGrid; //^TFastLine.TGCDGrid;
  i,j,k,t1,t2,s1,s2,v1,v2: integer;

  {(Binary Stein Algorithm, which finds Greatest Common Divisor of two integer numbers) Бинарный алгоритм Стейна нахождения НСД двух целых чисел}
  function SteinGCD(a_,b_:integer): integer; {$region -fold}
  var
    k_: integer;
  begin
    k_:=1;
    while (a_<>0) and (a_<>0) do
      begin
        while (a_ and 1=0) and (b_ and 1=0) do
          begin
            a_:=a_>>1;
            b_:=b_>>1;
            k_:=k_<<1;
          end;
        while (a_ and 1=0) do
          a_:=a_>>1;
        while (b_ and 1=0) do
          b_:=b_>>1;
        if (a_>=b_) then
          a_:=a_-b_
        else
          b_:=b_-a_;
      end;
    Result:=b_*k_;
  end; {$endregion}

begin
  grid_pt_rad:=2;
  k:=2*grid_pt_rad;

  {Loop 1} {$region -fold}
  for j:=0 to h-1 do
    for i:=0 to w-1 do
      if (i>=j) then
        begin
          gcd_arr[i+j*w].a:=SteinGCD(i+1,j+1);
          if (gcd_arr[i+j*w].a<>1) then
            begin

              // Line1 Precalc.:
             {dx+1:=a*c;
              dy+1:=a;}
              if (gcd_arr[i+j*w].a=j+1) then {$region -fold}
                begin
                  gcd_arr[i+j*w].f_ln_kind:=1;
                  gcd_arr[i+j*w].b        :=0;
                  gcd_arr[i+j*w].c        :=Trunc((i+1)/(j+1));
                  Continue;
                end; {$endregion}

              // Line2 Precalc.:
             {dx+1:=c*(dy+1)+a:=a*b*c+a*(c+1):=a((b+1)*c+1);
              dy+1:=a*(b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-1) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) then {$region -fold}
                begin
                  gcd_arr[i+j*w].f_ln_kind:=2;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1));
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-1)/(gcd_arr[i+j*w].b+1));
                  Continue;
                end; {$endregion}

              // Line3 Precalc.:
             {dx+1:=c*(dy+1)+a*b:=a*c+a*b*(c+1):=a((b+1)*c+b);
              dy+1:=a*(b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-((j+1)/gcd_arr[i+j*w].a-1)) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) then {$region -fold}
                begin
                  gcd_arr[i+j*w].f_ln_kind:=3;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1));
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-gcd_arr[i+j*w].b)/(gcd_arr[i+j*w].b+1));
                  Continue;
                end; {$endregion}

              // Line4 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*b*c+a*(b+1)*(c+1):=a((2*b+1)*c+b+1);
              dy+1:=a*(2*b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-(((j+1)/gcd_arr[i+j*w].a-1)/2)-1) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) and {$region -fold}
                 (Trunc((j+1)/gcd_arr[i+j*w].a) mod 2=1) then
                begin
                  gcd_arr[i+j*w].f_ln_kind:=4;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1)/2);
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-gcd_arr[i+j*w].b-1)/((2*gcd_arr[i+j*w].b)+1));
                  Continue;
                end; {$endregion}

              // Line5 Precalc.:
             {dx+1:=c*(dy+1)+a*b:=a*(b+1)*c+a*b*(c+1):=a((2*b+1)*c+b);
              dy+1:=a*(2*b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-(((j+1)/gcd_arr[i+j*w].a-1)/2)) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) and {$region -fold}
                 (Trunc((j+1)/gcd_arr[i+j*w].a) mod 2=1) then
                begin
                  gcd_arr[i+j*w].f_ln_kind:=5;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1)/2);
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-gcd_arr[i+j*w].b)/((2*gcd_arr[i+j*w].b)+1));
                  Continue;
                end; {$endregion}

              // Line6 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*2*b*c+a*(b+1)*(c+1):=a((3*b+1)*c+b+1);
              dy+1:=a*(3*b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-(((j+1)/gcd_arr[i+j*w].a-1)/3)-1) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) and {$region -fold}
                 (Trunc((j+1)/gcd_arr[i+j*w].a) mod 3=1) then
                begin
                  gcd_arr[i+j*w].f_ln_kind:=6;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1)/3);
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-gcd_arr[i+j*w].b-1)/((3*gcd_arr[i+j*w].b)+1));
                  Continue;
                end; {$endregion}

              // Line7 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*(2*b+1)*c+a*b*(c+1):=a((3*b+1)*c+b);
              dy+1:=a*(3*b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-(((j+1)/gcd_arr[i+j*w].a-1)/3)) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) and {$region -fold}
                 (Trunc((j+1)/gcd_arr[i+j*w].a) mod 3=1) then
                begin
                  gcd_arr[i+j*w].f_ln_kind:=7;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1)/3);
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-gcd_arr[i+j*w].b)/((3*gcd_arr[i+j*w].b)+1));
                  Continue;
                end; {$endregion}

              // Line8 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*b*c+a*(2*b+1)*(c+1):=a((3*b+1)*c+2*b+1);
              dy+1:=a*(3*b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-2*(((j+1)/gcd_arr[i+j*w].a-1)/3)-1) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) and {$region -fold}
                 (Trunc((j+1)/gcd_arr[i+j*w].a) mod 3=1) then
                begin
                  gcd_arr[i+j*w].f_ln_kind:=8;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1)/3);
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-2*gcd_arr[i+j*w].b-1)/((3*gcd_arr[i+j*w].b)+1));
                  Continue;
                end; {$endregion}

              // Line9 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*(b+1)*c+a*2*b*(c+1):=a((3*b+1)*c+2*b);
              dy+1:=a*(3*b+1);}
              if (Trunc((i+1)/gcd_arr[i+j*w].a-2*(((j+1)/gcd_arr[i+j*w].a-1)/3)) mod Trunc((j+1)/gcd_arr[i+j*w].a)=0) and {$region -fold}
                 (Trunc((j+1)/gcd_arr[i+j*w].a) mod 3=1) then
                begin
                  gcd_arr[i+j*w].f_ln_kind:=9;
                  gcd_arr[i+j*w].b        :=Trunc(((j+1)/gcd_arr[i+j*w].a-1)/3);
                  gcd_arr[i+j*w].c        :=Trunc(((i+1)/gcd_arr[i+j*w].a-2*gcd_arr[i+j*w].b)/((3*gcd_arr[i+j*w].b)+1));
                  Continue;
                end; {$endregion}

            end;
        end; {$endregion}

  {Loop 2} {$region -fold}
  for j:=0 to h-1 do
    for i:=0 to w-1 do
      if (i>j)                        then
        if (gcd_arr[i+j*w].f_ln_kind=0) then
          begin
            v1:=grid_pt_rad;
            v2:=grid_pt_rad;
            for t1:=0 to k do
              for t2:=0 to k do
                begin
                  s1:=t1-grid_pt_rad;
                  s2:=t2-grid_pt_rad;
                  if (i+s1>=0) and (i+s1<=w-1) and
                     (j+s2>=0) and (j+s2<=h-1) and
                     (gcd_arr[(i+s1)+(j+s2)*w].d<>-1) and
                     (gcd_arr[(i+s1)+(j+s2)*w].f_ln_kind<>0) and
                     (Max2(Abs(s1),Abs(s2))<Max2(Abs(v1),Abs(v2))) then
                    begin
                      v1:=s1;
                      v2:=s2;
                    end;
                end;
            if (i+v1>=0) and (i+v1<=w-1) and
               (j+v2>=0) and (j+v2<=h-1) then
              begin
                gcd_arr[i+j*w]  :=gcd_arr[(i+v1)+(j+v2)*w];
                gcd_arr[i+j*w].d:=-1;
              end;
          end; {$endregion}

  {Loop 3} {$region -fold}
  {2 alternative records of the same code block}
  {1.} {$region -fold}
  {for j:=0 to h-1 do
    for i:=0 to w-1 do
      if (i<j) then
        begin
          gcd_arr[i+j*w]          :=gcd_arr[j+i*w];
          gcd_arr[i+j*w].f_ln_kind:=gcd_arr[j+i*w].f_ln_kind+10;
        end;} {$endregion}
  {2.} {$region -fold}
  gcd_arr_ptr:=Unaligned(@gcd_arr[0]);
  for j:=0 to h-1 do
    for i:=0 to w-1 do
      begin
        if (i<j) then
          begin
            gcd_arr_ptr^          :=gcd_arr[j+i*w];
            gcd_arr_ptr^.f_ln_kind:=gcd_arr[j+i*w].f_ln_kind+10;
          end;
        Inc(gcd_arr_ptr);
      end; {$endregion} {$endregion}

end;
{var
  gcd_arr_ptr            : PGCDGrid; //^TFastLine.TGCDGrid;
  i,j,k,n,m,t1,t2,s1,s2,v1,v2: integer;

  {(Binary Stein Algorithm, which finds Greatest Common Divisor of two integer numbers) Бинарный алгоритм Стейна нахождения НСД двух целых чисел}
  function SteinGCD(a_,b_:integer): integer; {$region -fold}
  var
    k_: integer;
  begin
    k_:=1;
    while (a_<>0) and (a_<>0) do
      begin
        while (a_ and 1=0) and (b_ and 1=0) do
          begin
            a_:=a_>>1;
            b_:=b_>>1;
            k_:=k_<<1;
          end;
        while (a_ and 1=0) do
          a_:=a_>>1;
        while (b_ and 1=0) do
          b_:=b_>>1;
        if (a_>=b_) then
          a_:=a_-b_
        else
          b_:=b_-a_;
      end;
    Result:=b_*k_;
  end; {$endregion}

begin
  grid_pt_rad:=2;
  k:=2*grid_pt_rad;

  {Loop 1} {$region -fold}
  for j:=0 to h-1 do
    for i:=0 to w-1 do
      if (i>=j) then
        begin
          n:=i+j*w;
          gcd_arr[n].a:=SteinGCD(i+1,j+1);
          if (gcd_arr[n].a<>1) then
            begin

              // Line1 Precalc.:
             {dx+1:=a*c;
              dy+1:=a;}
              if (gcd_arr[n].a=j+1) then {$region -fold}
                begin
                  gcd_arr[n].f_ln_kind:=1;
                  gcd_arr[n].b        :=0;
                  gcd_arr[n].c        :=Trunc((i+1)/(j+1));
                  Continue;
                end; {$endregion}

              // Line2 Precalc.:
             {dx+1:=c*(dy+1)+a:=a*b*c+a*(c+1):=a((b+1)*c+1);
              dy+1:=a*(b+1);}
              if (Trunc((i+1)/gcd_arr[n].a-1) mod Trunc((j+1)/gcd_arr[n].a)=0) then {$region -fold}
                begin
                  gcd_arr[n].f_ln_kind:=2;
                  gcd_arr[n].b        :=Trunc(((j+1)/gcd_arr[n].a-1));
                  gcd_arr[n].c        :=Trunc(((i+1)/gcd_arr[n].a-1)/(gcd_arr[n].b+1));
                  Continue;
                end; {$endregion}

              // Line3 Precalc.:
             {dx+1:=c*(dy+1)+a*b:=a*c+a*b*(c+1):=a((b+1)*c+b);
              dy+1:=a*(b+1);}
              if (Trunc((i+1)/gcd_arr[n].a-((j+1)/gcd_arr[n].a-1)) mod Trunc((j+1)/gcd_arr[n].a)=0) then {$region -fold}
                begin
                  gcd_arr[n].f_ln_kind:=3;
                  gcd_arr[n].b        :=Trunc(((j+1)/gcd_arr[n].a-1));
                  gcd_arr[n].c        :=Trunc(((i+1)/gcd_arr[n].a-gcd_arr[n].b)/(gcd_arr[n].b+1));
                  Continue;
                end; {$endregion}

              // Line4 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*b*c+a*(b+1)*(c+1):=a((2*b+1)*c+b+1);
              dy+1:=a*(2*b+1);}
              if (Trunc((i+1)/gcd_arr[n].a-(((j+1)/gcd_arr[n].a-1)/2)-1) mod Trunc((j+1)/gcd_arr[n].a)=0) and {$region -fold}
                 (Trunc((j+1)/gcd_arr[n].a) mod 2=1) then
                begin
                  gcd_arr[n].f_ln_kind:=4;
                  gcd_arr[n].b        :=Trunc(((j+1)/gcd_arr[n].a-1)/2);
                  gcd_arr[n].c        :=Trunc(((i+1)/gcd_arr[n].a-gcd_arr[n].b-1)/((2*gcd_arr[n].b)+1));
                  Continue;
                end; {$endregion}

              // Line5 Precalc.:
             {dx+1:=c*(dy+1)+a*b:=a*(b+1)*c+a*b*(c+1):=a((2*b+1)*c+b);
              dy+1:=a*(2*b+1);}
              if (Trunc((i+1)/gcd_arr[n].a-(((j+1)/gcd_arr[n].a-1)/2)) mod Trunc((j+1)/gcd_arr[n].a)=0) and {$region -fold}
                 (Trunc((j+1)/gcd_arr[n].a) mod 2=1) then
                begin
                  gcd_arr[n].f_ln_kind:=5;
                  gcd_arr[n].b        :=Trunc(((j+1)/gcd_arr[n].a-1)/2);
                  gcd_arr[n].c        :=Trunc(((i+1)/gcd_arr[n].a-gcd_arr[n].b)/((2*gcd_arr[n].b)+1));
                  Continue;
                end; {$endregion}

              // Line6 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*2*b*c+a*(b+1)*(c+1):=a((3*b+1)*c+b+1);
              dy+1:=a*(3*b+1);}
              if (Trunc((i+1)/gcd_arr[n].a-(((j+1)/gcd_arr[n].a-1)/3)-1) mod Trunc((j+1)/gcd_arr[n].a)=0) and {$region -fold}
                 (Trunc((j+1)/gcd_arr[n].a) mod 3=1) then
                begin
                  gcd_arr[n].f_ln_kind:=6;
                  gcd_arr[n].b        :=Trunc(((j+1)/gcd_arr[n].a-1)/3);
                  gcd_arr[n].c        :=Trunc(((i+1)/gcd_arr[n].a-gcd_arr[n].b-1)/((3*gcd_arr[n].b)+1));
                  Continue;
                end; {$endregion}

              // Line7 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*(2*b+1)*c+a*b*(c+1):=a((3*b+1)*c+b);
              dy+1:=a*(3*b+1);}
              if (Trunc((i+1)/gcd_arr[n].a-(((j+1)/gcd_arr[n].a-1)/3)) mod Trunc((j+1)/gcd_arr[n].a)=0) and {$region -fold}
                 (Trunc((j+1)/gcd_arr[n].a) mod 3=1) then
                begin
                  gcd_arr[n].f_ln_kind:=7;
                  gcd_arr[n].b        :=Trunc(((j+1)/gcd_arr[n].a-1)/3);
                  gcd_arr[n].c        :=Trunc(((i+1)/gcd_arr[n].a-gcd_arr[n].b)/((3*gcd_arr[n].b)+1));
                  Continue;
                end; {$endregion}

              // Line8 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*b*c+a*(2*b+1)*(c+1):=a((3*b+1)*c+2*b+1);
              dy+1:=a*(3*b+1);}
              if (Trunc((i+1)/gcd_arr[n].a-2*(((j+1)/gcd_arr[n].a-1)/3)-1) mod Trunc((j+1)/gcd_arr[n].a)=0) and {$region -fold}
                 (Trunc((j+1)/gcd_arr[n].a) mod 3=1) then
                begin
                  gcd_arr[n].f_ln_kind:=8;
                  gcd_arr[n].b        :=Trunc(((j+1)/gcd_arr[n].a-1)/3);
                  gcd_arr[n].c        :=Trunc(((i+1)/gcd_arr[n].a-2*gcd_arr[n].b-1)/((3*gcd_arr[n].b)+1));
                  Continue;
                end; {$endregion}

              // Line9 Precalc.:
             {dx+1:=c*(dy+1)+a*(b+1):=a*(b+1)*c+a*2*b*(c+1):=a((3*b+1)*c+2*b);
              dy+1:=a*(3*b+1);}
              if (Trunc((i+1)/gcd_arr[n].a-2*(((j+1)/gcd_arr[n].a-1)/3)) mod Trunc((j+1)/gcd_arr[n].a)=0) and {$region -fold}
                 (Trunc((j+1)/gcd_arr[n].a) mod 3=1) then
                begin
                  gcd_arr[n].f_ln_kind:=9;
                  gcd_arr[n].b        :=Trunc(((j+1)/gcd_arr[n].a-1)/3);
                  gcd_arr[n].c        :=Trunc(((i+1)/gcd_arr[n].a-2*gcd_arr[n].b)/((3*gcd_arr[n].b)+1));
                  Continue;
                end; {$endregion}

            end;
        end; {$endregion}

  {Loop 2} {$region -fold}
  for j:=0 to h-1 do
    for i:=0 to w-1 do
      if (i>j) then
        begin
          n:=i+j*w;
          if (gcd_arr[n].f_ln_kind=0) then
            begin
              v1:=grid_pt_rad;
              v2:=grid_pt_rad;
              for t1:=0 to k do
                for t2:=0 to k do
                  begin
                    s1:=t1-grid_pt_rad;
                    s2:=t2-grid_pt_rad;
                    m :=n+s1+s2*w;
                    if (i+s1>=0) and (i+s1<=w-1) and
                       (j+s2>=0) and (j+s2<=h-1) and
                       (gcd_arr[m].d<>-1) and
                       (gcd_arr[m].f_ln_kind<>0) and
                       (Max2(Abs(s1),Abs(s2))<Max2(Abs(v1),Abs(v2))) then
                      begin
                        v1:=s1;
                        v2:=s2;
                      end;
                  end;
              if (i+v1>=0) and (i+v1<=w-1) and
                 (j+v2>=0) and (j+v2<=h-1) then
                begin
                  gcd_arr[n]  :=gcd_arr[(i+v1)+(j+v2)*w];
                  gcd_arr[n].d:=-1;
                end;
            end;
        end; {$endregion}

  {Loop 3} {$region -fold}
  {2 alternative records of the same code block}
  {1.} {$region -fold}
  {for j:=0 to h-1 do
    for i:=0 to w-1 do
      if (i<j) then
        begin
          gcd_arr[i+j*w]          :=gcd_arr[j+i*w];
          gcd_arr[i+j*w].f_ln_kind:=gcd_arr[j+i*w].f_ln_kind+10;
        end;} {$endregion}
  {2.} {$region -fold}
  gcd_arr_ptr:=Unaligned(@gcd_arr[0]);
  for j:=0 to h-1 do
    for i:=0 to w-1 do
      begin
        if (i<j) then
          begin
            n                     :=j+i*w;
            gcd_arr_ptr^          :=gcd_arr[n];
            gcd_arr_ptr^.f_ln_kind:=gcd_arr[n].f_ln_kind+10;
          end;
        Inc(gcd_arr_ptr);
      end; {$endregion} {$endregion}

end;} {$endregion}

{Fast line solid (width - 1 pixel)}

// (Solid line initialization) Инициализация сплошной линии:
procedure TFastLine.LineSInit;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  {Right Bottom Corner}
  {0°..-45°}
  LineProc[00]:=Unaligned(@LineS00   );
  LineProc[01]:=Unaligned(@LineS01RBC);
  LineProc[02]:=Unaligned(@LineS02RBC);
  LineProc[03]:=Unaligned(@LineS03RBC);
  LineProc[04]:=Unaligned(@LineS04RBC);
  LineProc[05]:=Unaligned(@LineS05RBC);
  LineProc[06]:=Unaligned(@LineS06RBC);
  LineProc[07]:=Unaligned(@LineS07RBC);
  LineProc[08]:=Unaligned(@LineS08RBC);
  LineProc[09]:=Unaligned(@LineS09RBC);
  {-45°..-90°}
  LineProc[10]:=Unaligned(@LineS10   );
  LineProc[11]:=Unaligned(@LineS11RBC);
  LineProc[12]:=Unaligned(@LineS12RBC);
  LineProc[13]:=Unaligned(@LineS13RBC);
  LineProc[14]:=Unaligned(@LineS14RBC);
  LineProc[15]:=Unaligned(@LineS15RBC);
  LineProc[16]:=Unaligned(@LineS16RBC);
  LineProc[17]:=Unaligned(@LineS17RBC);
  LineProc[18]:=Unaligned(@LineS18RBC);
  LineProc[19]:=Unaligned(@LineS19RBC);

  {Left Bottom Corner}
  {-135°..-180°}
  LineProc[20]:=Unaligned(@LineS20   );
  LineProc[21]:=Unaligned(@LineS21LBC);
  LineProc[22]:=Unaligned(@LineS22LBC);
  LineProc[23]:=Unaligned(@LineS23LBC);
  LineProc[24]:=Unaligned(@LineS24LBC);
  LineProc[25]:=Unaligned(@LineS25LBC);
  LineProc[26]:=Unaligned(@LineS26LBC);
  LineProc[27]:=Unaligned(@LineS27LBC);
  LineProc[28]:=Unaligned(@LineS28LBC);
  LineProc[29]:=Unaligned(@LineS29LBC);
  {-90°..-135°}
  LineProc[30]:=Unaligned(@LineS30   );
  LineProc[31]:=Unaligned(@LineS31LBC);
  LineProc[32]:=Unaligned(@LineS32LBC);
  LineProc[33]:=Unaligned(@LineS33LBC);
  LineProc[34]:=Unaligned(@LineS34LBC);
  LineProc[35]:=Unaligned(@LineS35LBC);
  LineProc[36]:=Unaligned(@LineS36LBC);
  LineProc[37]:=Unaligned(@LineS37LBC);
  LineProc[38]:=Unaligned(@LineS38LBC);
  LineProc[39]:=Unaligned(@LineS39LBC);

end; {$endregion}

// Fast line solid horizontal(width - 1 pixel):
procedure TFastLine.LineSHL00;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FillByte(ln_arr0[r0+p0*ln_arr_width],r1-r0+1,1);
end; {$endregion}
procedure TFastLine.LineSHL10;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PInteger;
  i       : integer;
begin
  f_ln_ptr:=Unaligned(@ln_arr1_ptr[r0+p0*ln_arr_width]);
  for i:=0 to r1-r0 do
    (f_ln_ptr+i)^-=1;
end; {$endregion}
procedure TFastLine.LineSHL20;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PInteger;
  i       : integer;
begin
  f_ln_ptr:=Unaligned(@ln_arr1_ptr[r0+p0*ln_arr_width]);
  for i:=0 to r1-r0 do
    (f_ln_ptr+i)^+=1;
end; {$endregion}
procedure TFastLine.LineSHL30;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FillDWord((bmp_dst_ptr+r0+p0*bmp_dst_width)^,r1-r0+1,local_prop.eds_col_inv);
end; {$endregion}
procedure TFastLine.LineSHL40;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PByte;
  i       : integer;
begin
  f_ln_ptr:=Unaligned(@ln_arr0[r0+p0*ln_arr_width]);
  for i:=0 to r1-r0 do
    (f_ln_ptr+i)^+=3{1};
end; {$endregion}

// Fast line solid vertical(width - 1 pixel):
procedure TFastLine.LineSVL00;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PByte;
  i       : integer;
begin
  f_ln_ptr:=Unaligned(@ln_arr0[r0+p0*ln_arr_width]);
  for i:=0 to p1-p0 do
    begin
      f_ln_ptr^:=1;
      Inc(f_ln_ptr,ln_arr_width);
    end;
end; {$endregion}
procedure TFastLine.LineSVL10;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PInteger;
  i       : integer;
begin
  f_ln_ptr:=Unaligned(@ln_arr1_ptr[r0+p0*ln_arr_width]);
  for i:=0 to p1-p0 do
    begin
      f_ln_ptr^-=1;
      Inc(f_ln_ptr,ln_arr_width);
    end;
end; {$endregion}
procedure TFastLine.LineSVL20;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PInteger;
  i       : integer;
begin
  f_ln_ptr:=Unaligned(@ln_arr1_ptr[r0+p0*ln_arr_width]);
  for i:=0 to p1-p0 do
    begin
      f_ln_ptr^+=1;
      Inc(f_ln_ptr,ln_arr_width);
    end;
end; {$endregion}
procedure TFastLine.LineSVL30;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PInteger;
  i       : integer;
begin
  f_ln_ptr:=bmp_dst_ptr+r0+p0*bmp_dst_width;
  for i:=0 to p1-p0 do
    begin
      f_ln_ptr^:=local_prop.eds_col_inv;
      Inc(f_ln_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure TFastLine.LineSVL40;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  f_ln_ptr: PByte;
  i       : integer;
begin
  f_ln_ptr:=Unaligned(@ln_arr0[r0+p0*ln_arr_width]);
  for i:=0 to p1-p0 do
    begin
      f_ln_ptr^+=3{1};
      Inc(f_ln_ptr,ln_arr_width);
    end;
end; {$endregion}

//
procedure TFastLine.SwapArgs (x0,y0,x1,y1:double); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Swap1(r0,r1);
  Swap1(p0,p1);
  Swap3(x0,x1);
  Swap3(y0,y1);
end; {$endregion}

//
procedure TFastLine.GetLCoef0(x0,y0,x1,y1:double); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  dx_:=x1-x0;
  dy_:=y1-y0;
  k_ :=dy_/dx_;
  b_ :=y0-x0*k_;
end; {$endregion}
procedure TFastLine.GetLCoef1;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
 {t0:=Trunc(x0_);
  t1:=Trunc(x1_);
  n_:=k_*t0+b_;}
  tk:=FloatToFixed(k_);
  tb:=FloatToFixed(b_)+$111;
  th:=tk*{t0}r0+tb;
end; {$endregion}
procedure TFastLine.GetLCoef2;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
 {t0:=Trunc(y0_);
  t1:=Trunc(y1_);
  n_:=(t0-b_)/k_;
  m_:=bmp_dst_width*t0;}
  tk:=FloatToFixed(1 /k_);
  tb:=FloatToFixed(b_/k_)-$111;
  th:=tk*{t0}p0-tb;
end; {$endregion}

// (Move points) Перемещение точек:
procedure TFastLine.LinePHL00(x0,y0,x1,y1:double); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  GetLCoef0(x0,y0,x1,y1);

  {Nearly Horizontal Line} {$region -fold}
  if (Abs(dx_)>=Abs(dy_)) then
    begin
      r0:=Trunc(x0);
      r1:=Trunc(x1);
      if (x1<x0) then
        SwapArgs(x0,y0,x1,y1);
      p0:=Trunc (y0);
      if (y1>=p0) and (y1<p0+1) then
        begin
          LineSHL00;
          Exit;
        end;
      GetLCoef1;
      LinePHL01;
    end {$endregion}

  {Nearly Vertical   Line} {$region -fold}
  else
    begin
      p0:=Trunc(y0);
      p1:=Trunc(y1);
      if (y1<y0) then
        SwapArgs(x0,y0,x1,y1);
      r0:=Trunc (x0);
      if (x1>=r0) and (x1<r0+1) then
        begin
          LineSVL00;
          Exit;
        end;
      GetLCoef2;
      LinePHL02;
    end; {$endregion}

end; {$endregion}
procedure TFastLine.LinePHL01;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_arr0_ptr2: PByte;
  i           : integer;
begin
  i           :=r0;
  ln_arr0_ptr2:=ln_arr0_ptr+r0;
  while (i<=r1) do
    begin
     (ln_arr0_ptr2+bmp_dst_width*(th>>16))^:=1;
      ln_arr0_ptr2                         +=1;
      th                                   +=tk;
      i                                    +=1;
    end;
end; {$endregion}
procedure TFastLine.LinePHL02;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_arr0_ptr2: PByte;
  i           : integer;
begin
  i           :=p0;
  ln_arr0_ptr2:=ln_arr0_ptr+bmp_dst_width*p0;
  while (i<=p1) do
    begin
     (ln_arr0_ptr2+(th>>16))^:=1;
      ln_arr0_ptr2           +=bmp_dst_width;
      th                     +=tk;
      i                      +=1;
    end;
end; {$endregion}

// (Select points) Выделение точек:
procedure TFastLine.LinePHL10(x0,y0,x1,y1:double); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  // Some explanations:
  // case val-=1 will be some faster then assignment val:=-1,
  // thus i was forced to create separate procedures/functions for such cases,
  // instead of creating a single procedure with an assignment val:=...:

  GetLCoef0(x0,y0,x1,y1);

  {Nearly Horizontal Line} {$region -fold}
  if (Abs(dx_)>=Abs(dy_)) then
    begin
      r0:=Trunc(x0);
      r1:=Trunc(x1);
      if (x1<x0) then
        SwapArgs(x0,y0,x1,y1);
      p0:=Trunc (y0);
      if (y1>=p0) and (y1<p0+1) then
        begin
          LineSHL10;
          Exit;
        end;
      GetLCoef1;
      LinePHL11;
    end {$endregion}

  {Nearly Vertical   Line} {$region -fold}
  else
    begin
      p0:=Trunc(y0);
      p1:=Trunc(y1);
      if (y1<y0) then
        SwapArgs(x0,y0,x1,y1);
      r0:=Trunc (x0);
      if (x1>=r0) and (x1<r0+1) then
        begin
          LineSVL10;
          Exit;
        end;
      GetLCoef2;
      LinePHL12;
    end; {$endregion}

end; {$endregion}
procedure TFastLine.LinePHL11;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_arr1_ptr2: PInteger;
  i           :  integer;
begin
  i           :=r0;
  ln_arr1_ptr2:=ln_arr1_ptr+r0;
  while (i<=r1) do
    begin
     (ln_arr1_ptr2+bmp_dst_width*(th>>16))^-=1;
      ln_arr1_ptr2                         +=1;
      th                                   +=tk;
      i                                    +=1;
    end;
end; {$endregion}
procedure TFastLine.LinePHL12;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_arr1_ptr2: PInteger;
  i           :  integer;
begin
  i           :=p0;
  ln_arr1_ptr2:=ln_arr1_ptr+bmp_dst_width*p0;
  while (i<=p1) do
    begin
     (ln_arr1_ptr2+(th>>16))^-=1;
      ln_arr1_ptr2           +=bmp_dst_width;
      th                     +=tk;
      i                      +=1;
    end;
end; {$endregion}

// (Unselect points) Снятие выделения точек:
procedure TFastLine.LinePHL20(x0,y0,x1,y1:double); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  GetLCoef0(x0,y0,x1,y1);

  {Nearly Horizontal Line} {$region -fold}
  if (Abs(dx_)>=Abs(dy_)) then
    begin
      r0:=Trunc(x0);
      r1:=Trunc(x1);
      if (x1<x0) then
        SwapArgs(x0,y0,x1,y1);
      p0:=Trunc (y0);
      if (y1>=p0) and (y1<p0+1) then
        begin
          LineSHL20;
          Exit;
        end;
      GetLCoef1;
      LinePHL21;
    end {$endregion}

  {Nearly Vertical   Line} {$region -fold}
  else
    begin
      p0:=Trunc(y0);
      p1:=Trunc(y1);
      if (y1<y0) then
        SwapArgs(x0,y0,x1,y1);
      r0:=Trunc (x0);
      if (x1>=r0) and (x1<r0+1) then
        begin
          LineSVL20;
          Exit;
        end;
      GetLCoef2;
      LinePHL22;
    end; {$endregion}

end; {$endregion}
procedure TFastLine.LinePHL21;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_arr1_ptr2: PInteger;
  i           :  integer;
begin
  i           :=r0;
  ln_arr1_ptr2:=ln_arr1_ptr+r0;
  while (i<=r1) do
    begin
     (ln_arr1_ptr2+bmp_dst_width*(th>>16))^+=1;
      ln_arr1_ptr2                         +=1;
      th                                   +=tk;
      i                                    +=1;
    end;
end; {$endregion}
procedure TFastLine.LinePHL22;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_arr1_ptr2: PInteger;
  i           :  integer;
begin
  i           :=p0;
  ln_arr1_ptr2:=ln_arr1_ptr+bmp_dst_width*p0;
  while (i<=p1) do
    begin
     (ln_arr1_ptr2+(th>>16))^+=1;
      ln_arr1_ptr2           +=bmp_dst_width;
      th                     +=tk;
      i                      +=1;
    end;
end; {$endregion}

// (Direct pixel write) Непосредственная запись в битовую карту:
procedure TFastLine.LinePHL30(x0,y0,x1,y1:double); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  GetLCoef0(x0,y0,x1,y1);

  {Nearly Horizontal Line} {$region -fold}
  if (Abs(dx_)>=Abs(dy_)) then
    begin
      r0:=Trunc(x0);
      r1:=Trunc(x1);
      if (x1<x0) then
        SwapArgs(x0,y0,x1,y1);
      p0:=Trunc (y0);
      if (y1>=p0) and (y1<p0+1) then
        begin
          LineSHL30;
          Exit;
        end;
      GetLCoef1;
      LinePHL31;
    end {$endregion}

  {Nearly Vertical   Line} {$region -fold}
  else
    begin
      p0:=Trunc(y0);
      p1:=Trunc(y1);
      if (y1<y0) then
        SwapArgs(x0,y0,x1,y1);
      r0:=Trunc (x0);
      if (x1>=r0) and (x1<r0+1) then
        begin
          LineSVL30;
          Exit;
        end;
      GetLCoef2;
      LinePHL32;
    end; {$endregion}

end; {$endregion}
procedure TFastLine.LinePHL31;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  bmp_dst_ptr2: PInteger;
  i           :  integer;
begin
  i           :=r0;
  bmp_dst_ptr2:=bmp_dst_ptr+{t0}r0;
  while (i<={t1}r1) do
    begin
     (bmp_dst_ptr2+bmp_dst_width*(th>>16))^:=local_prop.eds_col_inv;
      bmp_dst_ptr2                         +=1;
      th                                   +=tk;
      i                                    +=1;
    end;
 {n_:=k_*t0+b_;
  for i:=t0 to t1 do
    begin
      (bmp_dst_ptr+i+bmp_dst_width*Trunc(n_))^:=local_prop.eds_col_inv;
      n_+=k_;
    end;}
end; {$endregion}
procedure TFastLine.LinePHL32;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  bmp_dst_ptr2: PInteger;
  i           :  integer;
begin
  i           :=p0;
  bmp_dst_ptr2:=bmp_dst_ptr+bmp_dst_width*{t0}p0;
  while (i<={t1}p1) do
    begin
     (bmp_dst_ptr2+(th>>16))^:=local_prop.eds_col_inv;
      bmp_dst_ptr2           +=bmp_dst_width;
      th                     +=tk;
      i                      +=1;
    end;
 {for i:=t0 to t1 do
    begin
      (bmp_dst_ptr+Trunc(n_)+m_)^:=local_prop.eds_col_inv;
      n_+=1/k_;
      m_+=bmp_dst_width;
    end;}
end; {$endregion}

// (Advanced byte mode) Продвинутый байт-режим:
procedure TFastLine.LinePHL40(x0,y0,x1,y1:double); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  GetLCoef0(x0,y0,x1,y1);

  {Nearly Horizontal Line} {$region -fold}
  if (Abs(dx_)>=Abs(dy_)) then
    begin
      r0:=Trunc(x0);
      r1:=Trunc(x1);
      if (x1<x0) then
        SwapArgs(x0,y0,x1,y1);
      p0:=Trunc (y0);
      if (y1>=p0) and (y1<p0+1) then
        begin
          LineSHL40;
          Exit;
        end;
      GetLCoef1;
      LinePHL41;
    end {$endregion}

  {Nearly Vertical   Line} {$region -fold}
  else
    begin
      p0:=Trunc(y0);
      p1:=Trunc(y1);
      if (y1<y0) then
        SwapArgs(x0,y0,x1,y1);
      r0:=Trunc (x0);
      if (x1>=r0) and (x1<r0+1) then
        begin
          LineSVL40;
          Exit;
        end;
      GetLCoef2;
      LinePHL42;
    end; {$endregion}

end; {$endregion}
procedure TFastLine.LinePHL41;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_arr0_ptr2: PByte;
  i           : integer;
begin
  i           :=r0;
  ln_arr0_ptr2:=ln_arr0_ptr+r0;
  while (i<=r1) do
    begin
     (ln_arr0_ptr2+bmp_dst_width*(th>>16))^+=3{1};
      ln_arr0_ptr2                         +=1;
      th                                   +=tk;
      i                                    +=1;
    end;
end; {$endregion}
procedure TFastLine.LinePHL42;                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_arr0_ptr2: PByte;
  i           : integer;
begin
  i           :=p0;
  ln_arr0_ptr2:=ln_arr0_ptr+bmp_dst_width*p0;
  while (i<=p1) do
    begin
     (ln_arr0_ptr2+(th>>16))^+=3{1};
      ln_arr0_ptr2           +=bmp_dst_width;
      th                     +=tk;
      i                      +=1;
    end;
end; {$endregion}

{Right bottom corner}

{0°..-45°}
// 0: out of grid
procedure TFastLine.LineS00;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// 1: (c_n)
procedure TFastLine.LineS01RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
 {dx+1:=a*c;
  dy+1:=a;}
  for i:=0 to a-2 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 2: (c_n,c+1)
procedure TFastLine.LineS02RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a:=a*b*c+a*(c+1):=a((b+1)*c+1);
  dy+1:=a*(b+1);
  Если система имет натуральные решения (a,b,c), то a - GCD(dx+1,dy+1), что легко доказать.
  "Пусть a<>НСД(dx+1,dy+1), тогда dy+1:=a*r*v1, dx+1:=a*r*v2=a*(r*v1*c+1), что невозможно."
  Последующие доказательства в остальных процедурах проводятся аналогичным образом.}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 3: ((c+1)_n,c)
procedure TFastLine.LineS03RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*b:=a*c+a*b*(c+1):=a((b+1)*c+b);
  dy+1:=a*(b+1);}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 4: ((c,c+1)_n,c+1)
procedure TFastLine.LineS04RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*(b+1):=a*b*c+a*(b+1)*(c+1):=a((2*b+1)*c+b+1);
  dy+1:=a*(2*b+1);}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 5: ((c,c+1)_n,c)
procedure TFastLine.LineS05RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*b:=a*(b+1)*c+a*b*(c+1):=a((2*b+1)*c+b);
  dy+1:=a*(2*b+1);}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 6: ((c,c+1,c)_n,c+1)
procedure TFastLine.LineS06RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*(b+1):=a*2*b*c+a*(b+1)*(c+1):=a((3*b+1)*c+b+1);
  dy+1:=a*(3*b+1);}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 7: ((c,c+1,c)_n,c)
procedure TFastLine.LineS07RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*(b+1):=a*(2*b+1)*c+a*b*(c+1):=a((3*b+1)*c+b);
  dy+1:=a*(3*b+1);}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 8: ((c,c+1,c+1)_n,c+1)
procedure TFastLine.LineS08RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*(b+1):=a*b*c+a*(2*b+1)*(c+1):=a((3*b+1)*c+2*b+1);
  dy+1:=a*(3*b+1);}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 9: ((c+1,c,c+1)_n,c)
procedure TFastLine.LineS09RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
 {dx+1:=c*(dy+1)+a*(b+1):=a*(b+1)*c+a*2*b*(c+1):=a((3*b+1)*c+2*b);
  dy+1:=a*(3*b+1);}
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
{-45°..-90°}
// 10: out of grid
procedure TFastLine.LineS10;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// 11: (c_n)
procedure TFastLine.LineS11RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i : integer;
  a0: integer=0;
begin
  {for i:=0 to a-1 do
    FillByte(ln_arr2[p0+i+g,r0+i*c-g],c,1);}
  for i:=0 to a-1 do
    begin
      FillByte(ln_arr2[p0+i+g,r0+a0-g],c,1);
      Inc(a0,c);
    end;
end; {$endregion}
// 12: (c_n,c+1)
procedure TFastLine.LineS12RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
  a0 : integer=0;
  a1 : integer=0;
  a2 : integer=0;
  b0 : integer;
  b1 : integer;
  b2 : integer;
begin
  {for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        FillByte(ln_arr2[p0+i*(b+1)+j+g,r0+i*((b+1)*c+1)+c*j-g],c+0,1);
        FillByte(ln_arr2[p0+i*(b+1)+b+g,r0+i*((b+1)*c+1)+c*b-g],c+1,1);
    end;}
  b0:=(b+1);
  b1:=(b+1)*c+1;
  b2:=(b+0)*c;
  for i:=0 to a-1 do
    begin
      a2:=0;
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+a0+j+g,r0+a1+a2-g],c+0,1);
          FillByte(ln_arr2[p0+a0+b+g,r0+a1+b2-g],c+1,1);
          Inc(a2,c);
        end;
      Inc(a0,b0);
      Inc(a1,b1);
    end;
end; {$endregion}
// 13: ((c+1)_n,c)
procedure TFastLine.LineS13RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
  a0 : integer=0;
  a1 : integer=0;
  a2 : integer=0;
  b0 : integer;
  b1 : integer;
  b2 : integer;
begin
  {for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        FillByte(ln_arr2[p0+i*(b+1)+j+g,r0+i*((b+1)*(c+1)-1)+(c+1)*j-g],c+1,1);
        FillByte(ln_arr2[p0+i*(b+1)+b+g,r0+i*((b+1)*(c+1)-1)+(c+1)*b-g],c+0,1);
    end;}
  b0:=(b+1);
  b1:=(b+1)*(c+1)-1;
  b2:=(b+0)*(c+1);
  for i:=0 to a-1 do
    begin
      a2:=0;
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+a0+j+g,r0+a1+a2-g],c+1,1);
          FillByte(ln_arr2[p0+a0+b+g,r0+a1+b2-g],c+0,1);
          Inc(a2,c+1);
        end;
      Inc(a0,b0);
      Inc(a1,b1);
    end;
end; {$endregion}
// 14: ((c,c+1)_n,c+1)
procedure TFastLine.LineS14RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
  a0 : integer=0;
  a1 : integer=0;
  a2 : integer=0;
  b0 : integer;
  b1 : integer;
  b2 : integer;
begin
  {for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+(2*b+1)*i+2*j+0+g,r0+(b*(2*c+1)+c+1)*i+(2*c+1)*j+0-g],c+0,1);
          FillByte(ln_arr2[p0+(2*b+1)*i+2*j+1+g,r0+(b*(2*c+1)+c+1)*i+(2*c+1)*j+c-g],c+1,1);
        end;
      FillByte(ln_arr2[p0+(2*b+1)*i+2*b+g,r0+(b*(2*c+1)+c+1)*i+(2*c+1)*b-g],c+1,1);
    end;}
  b0:=b* 2  +1;
  b1:=b*(2*c+1)+c+1;
  b2:=b*(2*c+1);
  for i:=0 to a-1 do
    begin
      a2:=0;
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+a0+2*j+0+g,r0+a1+a2+0-g],c+0,1);
          FillByte(ln_arr2[p0+a0+2*j+1+g,r0+a1+a2+c-g],c+1,1);
          Inc(a2,2*c+1);
        end;
      FillByte(ln_arr2[p0+a0+2*b+g,r0+a1+b2-g],c+1,1);
      Inc(a0,b0);
      Inc(a1,b1);
    end;
end; {$endregion}
// 15: ((c,c+1)_n,c)
procedure TFastLine.LineS15RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
  a0 : integer=0;
  a1 : integer=0;
  a2 : integer=0;
  b0 : integer;
  b1 : integer;
  b2 : integer;
begin
  {for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+(2*b+1)*i+2*j+0+g,r0+(b*(2*c+1)+c)*i+(2*c+1)*j+0-g],c+0,1);
          FillByte(ln_arr2[p0+(2*b+1)*i+2*j+1+g,r0+(b*(2*c+1)+c)*i+(2*c+1)*j+c-g],c+1,1);
        end;
      FillByte(ln_arr2[p0+(2*b+1)*i+2*b+g,r0+(b*(2*c+1)+c)*i+(2*c+1)*b-g],c,1);
    end;}
  b0:=b* 2  +1;
  b1:=b*(2*c+1)+c;
  b2:=b*(2*c+1);
  for i:=0 to a-1 do
    begin
      a2:=0;
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+a0+2*j+0+g,r0+a1+a2+0-g],c+0,1);
          FillByte(ln_arr2[p0+a0+2*j+1+g,r0+a1+a2+c-g],c+1,1);
          Inc(a2,2*c+1);
        end;
      FillByte(ln_arr2[p0+a0+2*b+g,r0+a1+b2-g],c+1,1);
      Inc(a0,b0);
      Inc(a1,b1);
    end;
end; {$endregion}
// 16: ((c,c+1,c)_n,c+1)
procedure TFastLine.LineS16RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
  a0 : integer=0;
  a1 : integer=0;
  a2 : integer=0;
  b0 : integer;
  b1 : integer;
  b2 : integer;
begin
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+0+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*j+0  +0-g],c+0,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+1+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*j+c  +0-g],c+1,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+2+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*j+c*2+1-g],c+0,1);
        end;
      FillByte(ln_arr2[p0+(3*b+1)*i+3*b+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*b-g],c+1,1);
    end;
  {b0:=b* 2  +1;
  b1:=b*(2*c+1)+c;
  b2:=b*(2*c+1);
  for i:=0 to a-1 do
    begin
      a2:=0;
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+a0+2*j+0+g,r0+a1+a2+0-g],c+0,1);
          FillByte(ln_arr2[p0+a0+2*j+1+g,r0+a1+a2+c-g],c+1,1);
          Inc(a2,2*c+1);
        end;
      FillByte(ln_arr2[p0+a0+2*b+g,r0+a1+b2-g],c+1,1);
      Inc(a0,b0);
      Inc(a1,b1);
    end;}
end; {$endregion}
// 17: ((c,c+1,c)_n,c)
procedure TFastLine.LineS17RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+0+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*j+00000-g],c+0,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+1+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*j+c+000-g],c+1,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+2+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*j+c*2+1-g],c+0,1);
        end;
      FillByte(ln_arr2[p0+(3*b+1)*i+3*b+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*b-g],c,1);
    end;
end; {$endregion}
// 18: ((c,c+1,c+1)_n,c+1)
procedure TFastLine.LineS18RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+0+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*j+00000-g],c+0,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+1+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*j+c+000-g],c+1,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+2+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*j+c*2+1-g],c+1,1);
        end;
      FillByte(ln_arr2[p0+(3*b+1)*i+3*b+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*b-g],c+1,1);
    end;
end; {$endregion}
// 19: ((c+1,c,c+1)_n,c)
procedure TFastLine.LineS19RBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+0+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*j+00000-g],c+1,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+1+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*j+c+001-g],c+0,1);
          FillByte(ln_arr2[p0+(3*b+1)*i+3*j+2+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*j+c*2+1-g],c+1,1);
        end;
      FillByte(ln_arr2[p0+(3*b+1)*i+3*b+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*b-g],c,1);
    end;
end; {$endregion}

{Left bottom corner}

{-135°..-180°}
// 20: out of grid
procedure TFastLine.LineS20;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// 21: (c_n)
procedure TFastLine.LineS21LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 22: (c_n,c+1)
procedure TFastLine.LineS22LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-2 do
        begin
          FillByte(ln_arr0_ptr^,c,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-2 do
    begin
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c+0,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 23: ((c+1)_n,c)
procedure TFastLine.LineS23LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-2 do
        begin
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  for j:=0 to b-2 do
    begin
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m1);
  FillByte(ln_arr0_ptr^,c+0,1);
end; {$endregion}
// 24: ((c,c+1)_n,c+1)
procedure TFastLine.LineS24LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-2 do
        begin
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-2 do
    begin
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c+0,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 25: ((c,c+1)_n,c)
procedure TFastLine.LineS25LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 26: ((c,c+1,c)_n,c+1)
procedure TFastLine.LineS26LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-2 do
        begin
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-2 do
    begin
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c+0,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m1);
  FillByte(ln_arr0_ptr^,c+0,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 27: ((c,c+1,c)_n,c)
procedure TFastLine.LineS27LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-1 do
    begin
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c,1);
end; {$endregion}
// 28: ((c,c+1,c+1)_n,c+1)
procedure TFastLine.LineS28LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c-1);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-2 do
        begin
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m1);
        end;
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  for j:=0 to b-2 do
    begin
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
    end;
  FillByte(ln_arr0_ptr^,c+0,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
end; {$endregion}
// 29: ((c+1,c,c+1)_n,c)
procedure TFastLine.LineS29LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  Dec(ln_arr0_ptr,c);
  for i:=0 to a-2 do
    begin
      for j:=0 to b-2 do
        begin
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m1);
          FillByte(ln_arr0_ptr^,c+0,1);
          Inc     (ln_arr0_ptr,m2);
          FillByte(ln_arr0_ptr^,c+1,1);
          Inc     (ln_arr0_ptr,m2);
        end;
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  for j:=0 to b-2 do
    begin
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m1);
      FillByte(ln_arr0_ptr^,c+0,1);
      Inc     (ln_arr0_ptr,m2);
      FillByte(ln_arr0_ptr^,c+1,1);
      Inc     (ln_arr0_ptr,m2);
    end;
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m1);
  FillByte(ln_arr0_ptr^,c+0,1);
  Inc     (ln_arr0_ptr,m2);
  FillByte(ln_arr0_ptr^,c+1,1);
  Inc     (ln_arr0_ptr,m1);
  FillByte(ln_arr0_ptr^,c+0,1);
end; {$endregion}
{-90°..-135°}
// 30: out of grid
procedure TFastLine.LineS30;    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
// 31: (c_n)
procedure TFastLine.LineS31LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    FillByte(ln_arr2[p0-i+g,r0+i*c-g],c,1);
end; {$endregion}
// 32: (c_n,c+1)
procedure TFastLine.LineS32LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        FillByte(ln_arr2[p0-i*(b+1)-j+g,r0+i*((b+1)*c+1)+c*j-g],c+0,1);
        FillByte(ln_arr2[p0-i*(b+1)-b+g,r0+i*((b+1)*c+1)+c*b-g],c+1,1);
    end;
end; {$endregion}
// 33: ((c+1)_n,c)
procedure TFastLine.LineS33LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        FillByte(ln_arr2[p0-i*(b+1)-j+g,r0+i*((b+1)*(c+1)-1)+(c+1)*j-g],c+1,1);
        FillByte(ln_arr2[p0-i*(b+1)-b+g,r0+i*((b+1)*(c+1)-1)+(c+1)*b-g],c+0,1);
    end;
end; {$endregion}
// 34: ((c,c+1)_n,c+1)
procedure TFastLine.LineS34LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0-(2*b+1)*i-2*j+0+g,r0+(b*(2*c+1)+c+1)*i+(2*c+1)*j+0-g],c+0,1);
          FillByte(ln_arr2[p0-(2*b+1)*i-2*j-1+g,r0+(b*(2*c+1)+c+1)*i+(2*c+1)*j+c-g],c+1,1);
        end;
      FillByte(ln_arr2[p0-(2*b+1)*i-2*b+g,r0+(b*(2*c+1)+c+1)*i+(2*c+1)*b-g],c+1,1);
    end;
end; {$endregion}
// 35: ((c,c+1)_n,c)
procedure TFastLine.LineS35LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0-(2*b+1)*i-2*j+0+g,r0+(b*(2*c+1)+c)*i+(2*c+1)*j+0-g],c+0,1);
          FillByte(ln_arr2[p0-(2*b+1)*i-2*j-1+g,r0+(b*(2*c+1)+c)*i+(2*c+1)*j+c-g],c+1,1);
        end;
      FillByte(ln_arr2[p0-(2*b+1)*i-2*b+g,r0+(b*(2*c+1)+c)*i+(2*c+1)*b-g],c,1);
    end;
end; {$endregion}
// 36: ((c,c+1,c)_n,c+1)
procedure TFastLine.LineS36LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j+0+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*j+00000-g],c+0,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-1+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*j+c+000-g],c+1,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-2+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*j+c*2+1-g],c+0,1);
        end;
      FillByte(ln_arr2[p0-(3*b+1)*i-3*b+g,r0+(b*(3*c+1)+c+1)*i+(3*c+1)*b-g],c+1,1);
    end;
end; {$endregion}
// 37: ((c,c+1,c)_n,c)
procedure TFastLine.LineS37LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j+0+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*j+00000-g],c+0,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-1+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*j+c+000-g],c+1,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-2+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*j+c*2+1-g],c+0,1);
        end;
      FillByte(ln_arr2[p0-(3*b+1)*i-3*b+g,r0+(b*(3*c+1)+c)*i+(3*c+1)*b-g],c,1);
    end;
end; {$endregion}
// 38: ((c,c+1,c+1)_n,c+1)
procedure TFastLine.LineS38LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j+0+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*j+00000-g],c+0,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-1+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*j+c+000-g],c+1,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-2+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*j+c*2+1-g],c+1,1);
        end;
      FillByte(ln_arr2[p0-(3*b+1)*i-3*b+g,r0+(b*(3*c+2)+c+1)*i+(3*c+2)*b-g],c+1,1);
    end;
end; {$endregion}
// 39: ((c+1,c,c+1)_n,c)
procedure TFastLine.LineS39LBC; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  // TODO: optimization
  for i:=0 to a-1 do
    begin
      for j:=0 to b-1 do
        begin
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j+0+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*j+00000-g],c+1,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-1+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*j+c+001-g],c+0,1);
          FillByte(ln_arr2[p0-(3*b+1)*i-3*j-2+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*j+c*2+1-g],c+1,1);
        end;
      FillByte(ln_arr2[p0-(3*b+1)*i-3*b+g,r0+(b*(3*c+2)+c)*i+(3*c+2)*b-g],c,1);
    end;
end; {$endregion}

// (Solid line drawing) Рисование сплошной линии:
procedure TFastLine.LineSMN(const x0,y0,x1,y1:integer);                                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  dx_abs,dy_abs: longword;

label
  l1;

  procedure SetArgs; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    r0:=x0;
    p0:=y0;
    r1:=x1;
    p1:=y1;
  end; {$endregion}

begin
  dx    :=x1-x0;
  dy    :=y1-y0;
  dx_abs:=Abs(dx);
  dy_abs:=Abs(dy);
  if (dy_abs<<9<dx_abs*229) then
    begin
      if (dy>0) then {$region -fold}
        begin
          ln_kind_ptr:=@gcd_arr[dx_abs+dy*ln_arr_width].f_ln_kind;
          if (ln_kind_ptr^=0) or (ln_kind_ptr^=10) then
            goto l1
          else
            begin
              ln_arr0_ptr:=@ln_arr0[x0+y0*ln_arr_width];
              a          :=(ln_kind_ptr+1)^;
              b          :=(ln_kind_ptr+2)^;
              c          :=(ln_kind_ptr+3)^;
              {0°..-45°}
              if (dx>0) then
                begin
                  m1:=ln_arr_width+c+0;
                  m2:=ln_arr_width+c+1;
                  LineProc[ln_kind_ptr^];
                  Exit;
                end;
              {-135°..-180°}
              if (dx<0) then
                begin
                  m1:=ln_arr_width-c-0;
                  m2:=ln_arr_width-c-1;
                  LineProc[ln_kind_ptr^+20];
                  Exit;
                end;
            end;
        end; {$endregion}
      if (dy<0) then {$region -fold}
        begin
          ln_kind_ptr:=@gcd_arr[dx_abs-dy*ln_arr_width].f_ln_kind;
          if (ln_kind_ptr^=0) or (ln_kind_ptr^=10) then
            goto l1
          else
            begin
              ln_arr0_ptr:=@ln_arr0[x1+y1*ln_arr_width];
              a          :=(ln_kind_ptr+1)^;
              b          :=(ln_kind_ptr+2)^;
              c          :=(ln_kind_ptr+3)^;
              {-180°..-225°}
              if (dx<0) then
                begin
                  m1:=ln_arr_width+c+0;
                  m2:=ln_arr_width+c+1;
                  LineProc[ln_kind_ptr^];
                  Exit;
                end;
              {-315°..-360°}
              if (dx>0) then
                begin
                  m1:=ln_arr_width-c-0;
                  m2:=ln_arr_width-c-1;
                  LineProc[ln_kind_ptr^+20];
                  Exit;
                end;
            end;
        end; {$endregion}
      {Horizontal Line}
      if (dy=0) then {$region -fold}
        begin
          if (dx>0) then
            FillByte(ln_arr0[x0+y0*ln_arr_width],1+dx,1)
          else
            FillByte(ln_arr0[x1+y1*ln_arr_width],1-dx,1);
          Exit;
        end; {$endregion}
    end
  else
  if (dx_abs<<9<dy_abs*229) then
    begin
      if (dy>0) then {$region -fold}
        begin
          ln_kind_ptr:=@gcd_arr[dx_abs+dy*ln_arr_width].f_ln_kind;
          if (ln_kind_ptr^=0) or (ln_kind_ptr^=10) then
            goto l1
          else
            begin
              a:=(ln_kind_ptr+1)^;
              b:=(ln_kind_ptr+2)^;
              c:=(ln_kind_ptr+3)^;
              {-45°..-90°}
              if (dx>0) then
                begin
                  r0:=x0;
                  p0:=y0;
                  g :=r0-p0;
                  LineProc[ln_kind_ptr^+00];
                  Exit;
                end;
              {-90°..-135°}
              if (dx<0) then
                begin
                  r0:=x0;
                  p0:=y0;
                  g :=r0-p0;
                  LineProc[ln_kind_ptr^+20];
                  Exit;
                end;
              {Vertical Line Down}
              if (dx=0) then
                begin
                  FillByte(ln_arr2[x0,y0],dy,1);
                  Exit;
                end;
            end;
        end; {$endregion}
      if (dy<0) then {$region -fold}
        begin
          ln_kind_ptr:=@gcd_arr[dx_abs-dy*ln_arr_width].f_ln_kind;
          if (ln_kind_ptr^=0) or (ln_kind_ptr^=10) then
            goto l1
          else
            begin
              a:=(ln_kind_ptr+1)^;
              b:=(ln_kind_ptr+2)^;
              c:=(ln_kind_ptr+3)^;
              {-225°..-270°}
              if (dx<0) then
                begin
                  r0:=y1;
                  p0:=x1;
                  g :=00;
                  LineProc[ln_kind_ptr^+00];
                  Exit;
                end;
              {-270°..-315°}
              if (dx>0) then
                begin
                  r0:=y1;
                  p0:=x1;
                  g :=00;
                  LineProc[ln_kind_ptr^+20];
                  Exit;
                end;
              {Vertical Line Up}
              if (dx=0) then
                begin
                  FillByte(ln_arr2[x1,y1],-dy,1);
                  Exit;
                end;
            end;
        end; {$endregion}
    end
  else {$region -fold}
    begin
      l1:
      SetArgs;
      ln_arr0_ptr:=Unaligned(@ln_arr0[0]);
      LinePHL40(x0,y0,x1,y1);
      Exit;
    end; {$endregion}
end; {$endregion}
procedure TFastLine.LineSME(const x0,y0,x1,y1:integer; const proc_ptr_a,proc_ptr_b,proc_ptr_c:TProc0); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  LineSMN(x0,y0,x1,y1);
end; {$endregion}

{Fast line clipping}

// Sobkow-Pospisil-Yang algorithm:
procedure TFastLine.ClippedLine1(x0,y0,x1,y1:integer; const rct_clp:TPtRect; const proc1:TProc3 ; const proc2,proc3,proc4      :TProc0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  line_code: integer{byte}=0;

  procedure ClipLine    (                            var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    with ln_pos do
      begin
        x0:=v0;
        y0:=w0;
        x1:=v1;
        y1:=w1;
      end;
    if (proc1=Nil) and
       (proc2=Nil) and
       (proc3=Nil) and
       (proc4=Nil) then
      Exit;
    proc1(v0,w0,v1,w1,proc2,proc3,proc4);
  end; {$endregion}
  procedure Clip0_Left  (const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    w0+=Trunc(((w1-w0)*(custom_rect2.left-v0))/(v1-v0));
    v0:=custom_rect2.left;
  end; {$endregion}
  procedure Clip0_Top   (const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // inline induces SIGFPE ERROR in outer procedure
  begin
    v0+=Trunc(((v1-v0)*(custom_rect2.bottom-w0))/(w1-w0));
    w0:=custom_rect2.bottom;
  end; {$endregion}
  procedure Clip0_Right (const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    w0+=Trunc(((w1-w0)*(custom_rect2.right-v0))/(v1-v0));
    v0:=custom_rect2.right;
  end; {$endregion}
  procedure Clip0_Bottom(const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    v0+=Trunc(((v1-v0)*(custom_rect2.top-w0))/(w1-w0));
    w0:=custom_rect2.top;
  end; {$endregion}
  procedure Clip1_Left  (const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    w1+=Trunc(((w0-w1)*(custom_rect2.left-v1))/(v0-v1));
    v1:=custom_rect2.left;
  end; {$endregion}
  procedure Clip1_Top   (const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    v1+=Trunc(((v0-v1)*(custom_rect2.bottom-w1))/(w0-w1));
    w1:=custom_rect2.bottom;
  end; {$endregion}
  procedure Clip1_Right (const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    w1+=Trunc(((w0-w1)*(custom_rect2.right-v1))/(v0-v1));
    v1:=custom_rect2.right;
  end; {$endregion}
  procedure Clip1_Bottom(const custom_rect2:TPtRect; var v0,w0,v1,w1:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold} // ...
  begin
    v1+=Trunc(((v0-v1)*(custom_rect2.top-w1))/(w0-w1));
    w1:=custom_rect2.top;
  end; {$endregion}

begin
  {$region -fold}
  {Fast Clipping Algorithm}

   (*
    Алгоритм быстрого отсечения FC(Fast Clipping) Собкова-Поспишила-Янга
  (Sobkow-Pospisil-Yang), с кодированием линий. Отсекает отрезок, заданный
  координатами его точек (x0,y0), (x1,y1), по окну custom_rect.
    * Clip0_A - перемещение начальной точки (x0,y0) в точку пересечения отрезка
  со стороной A;
    * Clip1_A - перемещение конечной точки (x1,y1) в точку пересечения отрезка
  со стороной A;
    Схема кодирования концов отрезков:

                          1001    |  1000   |  1010
                                  |         |
                           0x9    |   0x8   |   0xA
                          _ _ _ _1| _ _ _ _2| _ _ _ _3
                                  |         |
                          0001    |  0000   |  0010
                                  |         |
                           0x1    |   0x0   |   0x2
                          _ _ _ _4| _ _ _ _5| _ _ _ _6
                                  |         |
                          0101    |  0100   |  0110
                                  |         |
                           0x5    |   0x4   |   0x6
                                 7|        8|        9

    Отрезок видим только в области 5, т.е. отрезок, координаты которого
  удовлетворяют условиям:

        Rect.Left < X < Rect.Right    и    Rect.Bottom < Y < Rect.Top,

  но поскольку в Lazarus-е координата Y отсчитывается от верхнего левого
  угла, то последнее неравенство перепишем как

                         Rect.Bottom > Y > Rect.Top,

  (Это обстоятельство также учтено в коде подпрограммы!!!)
    Каждая конечная точка отрезка V0V1 окажется с одной из этих областей.
  Комбинация кодов концов отрезка, называемая кодом линии, используется для
  определения возможных вариантов расположения отрезка и, следовательно,
  отсечения. Код линии формируется из кодов концов отрезка следующим образом:

                 LineCode(V0,V1) = (Code(V0) × 16) + Code(V1),

  здесь Code(V1) обозначает код конечной точки V1, Code(V0) × 16 означает сдвиг
  кода начальной точки V0 влево на 4 разряда.
    Так как каждый код может принимать одно из 9 значений, то всего имеется
  81 возможный вариант расположения отрезка.
   *)

  {Вычисление значения Code - кода отрезка.
  Биты 0-3 - для конечной точки(x1,y1), 4-7 - для начальной точки(x0,y0);}

  if (y1>rct_clp.Bottom) then
    line_code+=8
  else
    if (y1<rct_clp.Top) then
      line_code+=4;

  if (x1>rct_clp.Right) then
    line_code+=2
  else
    if (x1<rct_clp.Left) then
      line_code+=1;

  if (y0>rct_clp.Bottom) then
    line_code+=128
  else
    if (y0<rct_clp.Top) then
      line_code+=64;

  if (x0>rct_clp.Right) then
    line_code+=32
  else
    if (x0<rct_clp.Left) then
      line_code+=16;

  {Отсечение для каждого из 81-го случаев}
  case line_code of

    {Из центра}

    $00:
      begin
        ClipLine(x0,y0,x1,y1);
        Exit;
      end;
    $01:
      begin
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        ClipLine  (        x0,y0,x1,y1);
        Exit;
      end;
    $02:
      begin
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $04:
      begin
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $05:
      begin
        Clip1_Left    (rct_clp,x0,y0,x1,y1);
        if (y1<        rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $06:
      begin
        Clip1_Right   (rct_clp,x0,y0,x1,y1);
        if (y1<        rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $08:
      begin
        Clip1_Top(rct_clp,x0,y0,x1,y1);
        ClipLine (        x0,y0,x1,y1);
        Exit;
      end;
    $09:
      begin
        Clip1_Left (rct_clp,x0,y0,x1,y1);
        if (y1>     rct_clp.Bottom) then
          Clip1_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $0A:
      begin
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        if (y1>     rct_clp.Bottom) then
          Clip1_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;

    {Слева}

    $10:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        ClipLine  (        x0,y0,x1,y1);
        Exit;
      end;
    $11: Exit;                                                 // Отброшен
    $12:
      begin
        Clip0_Left (rct_clp,x0,y0,x1,y1);
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $14:
      begin
        Clip0_Left  (rct_clp,x0,y0,x1,y1);
        if (y0<      rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $15: Exit;                                                 // Отброшен
    $16:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        if (y0<    rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip1_Bottom (rct_clp,x0,y0,x1,y1);
        if (x1>       rct_clp.Right) then
          Clip1_Right(rct_clp,x0,y0,x1,y1);
        ClipLine     (        x0,y0,x1,y1);
        Exit;
      end;
    $18:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        if (y0>    rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip1_Top(rct_clp,x0,y0,x1,y1);
        ClipLine (        x0,y0,x1,y1);
        Exit;
      end;
    $19: Exit;                                                 // Отброшен
    $1A:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        if (y0>    rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip1_Top    (rct_clp,x0,y0,x1,y1);
        if (x1>       rct_clp.Right) then
          Clip1_Right(rct_clp,x0,y0,x1,y1);
        ClipLine     (        x0,y0,x1,y1);
        Exit;
      end;

    {Справа}

    $20:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $21:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        Clip1_Left (rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $22: Exit;                                                 // Отброшен
    $24:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0<     rct_clp.Top) then
          Exit;                                                 // Отброшен
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $25:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0<     rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        if (x1<      rct_clp.Left) then
          Clip1_Left(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $26: Exit;                                                 // Отброшен
    $28:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip1_Top  (rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $29:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip1_Top(rct_clp,x0,y0,x1,y1);
        if (x1<   rct_clp.Left) then
          Clip1_Left(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $2A: Exit;                                                 // Отброшен

    {Снизу}

    $40:
      begin
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $41:
      begin
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (x0<      rct_clp.Left) then
          Exit;                                                // Отброшен
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        if (y1<    rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $42:
      begin
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (x0>      rct_clp.Right) then
          Exit;                                                // Отброшен
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $44: Exit;                                                 // Отброшен
    $45: Exit;                                                 // Отброшен
    $46: Exit;                                                 // Отброшен
    $48:
      begin
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        Clip1_Top   (rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $49:
      begin
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (x0<      rct_clp.Left) then
          Exit;                                                // Отброшен
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        if (y1>    rct_clp.Bottom) then
          Clip1_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $4A:
      begin
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (x0>      rct_clp.Right) then
          Exit;                                                // Отброшен
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        if (y1>     rct_clp.Bottom) then
          Clip1_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;

    {Снизу слева}

    $50:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        if (y0<    rct_clp.Top) then
          Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $51: Exit;                                                 // Отброшен
    $52:
      begin
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        if (y1<     rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (x0<      rct_clp.Left) then
          Clip0_Left(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $54: Exit;                                                 // Отброшен
    $55: Exit;                                                 // Отброшен
    $56: Exit;                                                 // Отброшен
    $58:
      begin
        Clip1_Top(rct_clp,x0,y0,x1,y1);
        if (x1<   rct_clp.Left) then
          Exit;                                                // Отброшен
        Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (x0<      rct_clp.Left) then
          Clip0_Left(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $59: Exit;                                                 // Отброшен
    $5A:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        if (y0>    rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        if (y1<     rct_clp.Top) then
          Exit;                                                // Отброшен
        if (y0<        rct_clp.Top) then
          Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        if (y1>        rct_clp.Bottom) then
          Clip1_Top   (rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;

    {Снизу-справа}

    $60:
      begin
        Clip0_Right   (rct_clp,x0,y0,x1,y1);
        if (y0<        rct_clp.Top) then
          Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $61:
      begin
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        if (y1<    rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip0_Bottom (rct_clp,x0,y0,x1,y1);
        if (x0>       rct_clp.Right) then
          Clip0_Right(rct_clp,x0,y0,x1,y1);
        ClipLine     (        x0,y0,x1,y1);
        Exit;
      end;
    $62: Exit;                                                 // Отброшен
    $64: Exit;                                                 // Отброшен
    $65: Exit;                                                 // Отброшен
    $66: Exit;                                                 // Отброшен
    $68:
      begin
        Clip1_Top(rct_clp,x0,y0,x1,y1);
        if (x1>   rct_clp.Right) then
          Exit;                                                // Отброшен
        Clip0_Right   (rct_clp,x0,y0,x1,y1);
        if (y0<        rct_clp.Top) then
          Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $69:
      begin
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        if (y1<    rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Exit;                                                // Отброшен
        if (y1>        rct_clp.Bottom) then
          Clip1_Top   (rct_clp,x0,y0,x1,y1);
        if (y0<        rct_clp.Top) then
          Clip0_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $6A: ;                                                     // Отброшен

    {Сверху}

    $80:
      begin
        Clip0_Top(rct_clp,x0,y0,x1,y1);
        ClipLine (        x0,y0,x1,y1);
        Exit;
      end;
    $81:
      begin
        Clip0_Top(rct_clp,x0,y0,x1,y1);
        if (x0<   rct_clp.Left) then
          Exit;                                                // Отброшен
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        ClipLine  (        x0,y0,x1,y1);
        Exit;
      end;
    $82:
      begin
        Clip0_Top(rct_clp,x0,y0,x1,y1);
        if (x0>   rct_clp.Right) then
          Exit;                                                // Отброшен
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $84:
      begin
        Clip0_Top   (rct_clp,x0,y0,x1,y1);
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $85:
      begin
        Clip0_Top(rct_clp,x0,y0,x1,y1);
        if (x0<   rct_clp.Left) then
          Exit;                                                // Отброшен
        Clip1_Left    (rct_clp,x0,y0,x1,y1);
        if (y1<        rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $86:
      begin
        Clip0_Top(rct_clp,x0,y0,x1,y1);
        if (x0>   rct_clp.Right) then
          Exit;                                                // Отброшен
        Clip1_Right   (rct_clp,x0,y0,x1,y1);
        if (y1<        rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $88: Exit;                                                 // Отброшен
    $89: Exit;                                                 // Отброшен
    $8A: Exit;                                                 // Отброшен

    {Сверху-слева}

    $90:
      begin
        Clip0_Left (rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Clip0_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $91: Exit;                                                 // Отброшен
    $92:
      begin
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        if (y1>     rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip0_Top   (rct_clp,x0,y0,x1,y1);
        if (x0<      rct_clp.Left) then
          Clip0_Left(rct_clp,x0,y0,x1,y1);
        ClipLine    (        x0,y0,x1,y1);
        Exit;
      end;
    $94:
      begin
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        if (x1<      rct_clp.Left) then
          Exit;                                                // Отброшен
        Clip0_Left (rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Clip0_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $95: Exit;                                                 // Отброшен
    $96:
      begin
        Clip0_Left(rct_clp,x0,y0,x1,y1);
        if (y0<    rct_clp.Top) then
          Exit;                                                // Отброшен
        Clip1_Right(rct_clp,x0,y0,x1,y1);
        if (y1>     rct_clp.Bottom) then
          Exit;                                                // Отброшен
        if (y0>        rct_clp.Bottom) then
          Clip0_Top   (rct_clp,x0,y0,x1,y1);
        if (y1<        rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $98: Exit;                                                 // Отброшен
    $99: Exit;                                                 // Отброшен
    $9A: Exit;                                                 // Отброшен

    {Сверху-справа}

    $A0:
      begin
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Clip0_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $A1:
      begin
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        if (y1>    rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip0_Top    (rct_clp,x0,y0,x1,y1);
        if (x0>       rct_clp.Right) then
          Clip0_Right(rct_clp,x0,y0,x1,y1);
        ClipLine     (        x0,y0,x1,y1);
        Exit;
      end;
    $A2: Exit;                                                 // Отброшен
    $A4:
      begin
        Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        if (x1>      rct_clp.Right) then
          Exit;                                                // Отброшен
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0>     rct_clp.Bottom) then
          Clip0_Top(rct_clp,x0,y0,x1,y1);
        ClipLine   (        x0,y0,x1,y1);
        Exit;
      end;
    $A5:
      begin
        Clip1_Left(rct_clp,x0,y0,x1,y1);
        if (y1>    rct_clp.Bottom) then
          Exit;                                                // Отброшен
        Clip0_Right(rct_clp,x0,y0,x1,y1);
        if (y0<     rct_clp.Top) then
          Exit;                                                // Отброшен
        if (y1<        rct_clp.Top) then
          Clip1_Bottom(rct_clp,x0,y0,x1,y1);
        if (y0>        rct_clp.Bottom) then
          Clip0_Top   (rct_clp,x0,y0,x1,y1);
        ClipLine      (        x0,y0,x1,y1);
        Exit;
      end;
    $A6: Exit;                                                 // Отброшен
    $A8: Exit;                                                 // Отброшен
    $A9: Exit;                                                 // Отброшен
    $AA: Exit;                                                 // Отброшен

  end;
  {$endregion}
end; {$endregion}

// Matthes-Drakopoulos  algorithm:
procedure TFastLine.ClippedLine2(x0,y0,x1,y1:integer; const rct_clp:TPtRect; const proc1:TProc3 ; const proc2,proc3,proc4      :TProc0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y: array[0..1] of integer;
  i  : byte;
begin
  if ((not ((x0<rct_clp.left) and (x1<rct_clp.left))) and (not ((x0>rct_clp.right ) and (x1>rct_clp.right )))) and
     ((not ((y0<rct_clp.top ) and (y1<rct_clp.top ))) and (not ((y0>rct_clp.bottom) and (y1>rct_clp.bottom)))) then
    begin
      x[0]:=x0;
      y[0]:=y0;
      x[1]:=x1;
      y[1]:=y1;
      i   :=0;
      repeat
        begin
          if (x[i]<rct_clp.left) then
            begin
              x[i]:=rct_clp.left;
              y[i]:=Trunc(((y1-y0)*(rct_clp.left  -x0))/(x1-x0)+y0);
            end
          else
          if (x[i]>rct_clp.right) then
            begin
              x[i]:=rct_clp.right;
              y[i]:=Trunc(((y1-y0)*(rct_clp.right -x0))/(x1-x0)+y0);
            end;
          if (y[i]<rct_clp.top) then
            begin
              y[i]:=rct_clp.top;
              x[i]:=Trunc(((x1-x0)*(rct_clp.top   -y0))/(y1-y0)+x0);
            end
          else
          if (y[i]>rct_clp.bottom) then
            begin
              y[i]:=rct_clp.bottom;
              x[i]:=Trunc(((x1-x0)*(rct_clp.bottom-y0))/(y1-y0)+x0);
            end;
          i:=i+1;
        end;
      until (i>1);
      if (not ((x[0]<rct_clp.left ) and (x[1]<rct_clp.left ))) and
         (not ((x[0]>rct_clp.right) and (x[1]>rct_clp.right))) then
        proc1(x[0],y[0],x[1],y[1],proc2,proc3,proc4);
    end;
end; {$endregion}
procedure TFastLine.ClippedLine2(x0,y0,x1,y1:double ; const rct_clp:TPtRect; const proc1:TProc20; const proc2,proc3,proc4,proc5:TProc0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y     : array[0..1] of double;
  ff0,ff1 : integer;
  chk_bnds: boolean=False;

  procedure OrthoLine(var h0,h1:integer; const h2,h3:integer; prochv:TProc0); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    if (h1<h0) then
      Swap1(h0,h1);
    if (h0<h2) then
      begin
        if (h1<h2) then
          begin
            Exit;
          end;
        if (h1<h3) then
          begin
            h0:=h2;
            prochv;
            Exit;
          end;
        h0:=h2;
        h1:=h3-1;
        prochv;
        Exit;
      end;
    if (h0<h3) then
      begin
        if (h1<h3) then
          begin
            prochv;
            Exit;
          end;
        h1:=h3-1;
        prochv;
        Exit;
      end;
  end; {$endregion}

  function  CheckBounds: boolean;                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    Result:=((not ((x[0]<rct_clp.left) and (x[1]<rct_clp.left))) and (not ((x[0]>=rct_clp.right ) and (x[1]>=rct_clp.right )))) and
            ((not ((y[0]<rct_clp.top ) and (y[1]<rct_clp.top ))) and (not ((y[0]>=rct_clp.bottom) and (y[1]>=rct_clp.bottom))))
  end; {$endregion}

  procedure SetArgs;                                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x[0]:=x0;
    y[0]:=y0;
    x[1]:=x1;
    y[1]:=y1;
  end; {$endregion}

begin

  r0 :=Trunc(x0);
  p0 :=Trunc(y0);
  r1 :=Trunc(x1);
  p1 :=Trunc(y1);
  ff0:=r0;
  ff1:=p0;

  {horizontal line} {$region -fold}
  if (p0=p1) then
    begin
      if (r0=r1) then
        Exit;
      if (p0>=rct_clp.top) and (p0<rct_clp.bottom) then
        OrthoLine(r0,r1,rct_clp.left,rct_clp.right,proc2);
      Exit;
    end; {$endregion}

  {vertical   line} {$region -fold}
  if (r0=r1) then
    begin
      if (p0=p1) then
        Exit;
      if (r0>=rct_clp.left) and (r0<rct_clp.right) then
        OrthoLine(p0,p1,rct_clp.top,rct_clp.bottom,proc3);
      Exit;
    end; {$endregion}

  {regular    line} {$region -fold}
    begin
      SetArgs;
      if CheckBounds then
        begin

          GetLCoef0(x0,y0,x1,y1);

          {Nearly Horizontal Line} {$region -fold}
          if (Abs(dx_)>=Abs(dy_)) then
            begin
              if (x1<x0) then
                begin
                  ff0:=    r1 ;
                  Swap2(r0,r1);
                  Swap3(x0,x1);
                  Swap3(y0,y1);
                  SetArgs;
                end;
              GetLCoef1;
              if (y1>y0) then
                begin
                  if (x[0]<         rct_clp.left    ) then
                    begin
                      y[0]:=       (rct_clp.left-x0 )*k_+y0;
                       r0 :=        rct_clp.left;
                    end;
                  if (y[0]<         rct_clp.top     ) then
                       r0 :=Trunc(((rct_clp.top-1   )<<16-th+ONE_SHL_16_SUB_1)/tk)+ff0+1;
                  if (x[1]>=        rct_clp.right   ) then
                    begin
                      y[1]:=       (rct_clp.right-x0)*k_+y0;
                       r1 :=        rct_clp.right-1;
                    end;
                  if (y[1]>=        rct_clp.bottom  ) then
                       r1 :=Trunc(((rct_clp.bottom-1)<<16-th+ONE_SHL_16_SUB_1)/tk)+ff0;
                  if CheckBounds then
                    begin
                      chk_bnds:=True;
                      th      :=tk*r0+tb;
                      {if ((th>>16)=rct_clp.top-1) then
                        begin
                          r0+=1;
                          th+=tk;
                        end;}
                    end;
                end
              else
                begin
                  if (x[0]<         rct_clp.left    ) then
                    begin
                      y[0]:=       (rct_clp.left-x0 )*k_+y0;
                       r0 :=        rct_clp.left;
                    end;
                  if (y[0]>=        rct_clp.bottom  ) then
                       r0 :=Trunc(((rct_clp.bottom-1)<<16-th+ONE_SHL_16_SUB_1)/tk)+ff0+1;
                  if (x[1]>=        rct_clp.right   ) then
                    begin
                      y[1]:=       (rct_clp.right-x0)*k_+y0;
                       r1 :=        rct_clp.right-1;
                    end;
                  if (y[1]<         rct_clp.top     ) then
                       r1 :=Trunc(((rct_clp.top-1   )<<16-th+ONE_SHL_16_SUB_1)/tk)+ff0;
                  if CheckBounds then
                    begin
                      chk_bnds:=True;
                      th      :=tk*r0+tb;
                      {if (    ((tk*r1+tb)>>16)=rct_clp.top-1) then
                        r1:=Trunc(            (rct_clp.top<<16-th+ONE_SHL_16_SUB_1)/tk)+ff0;
                      if ((th>>16)=            rct_clp.bottom) then
                        begin
                          r0+=1;
                          th+=tk;
                        end;}
                    end;
                end;
              if chk_bnds then
                begin
                  {if (r1 =rct_clp.right) then
                      r1-=1;}
                  if IsPtInRct(r0,(tk*r0+tb)>>16,rct_clp) and
                     IsPtInRct(r1,(tk*r1+tb)>>16,rct_clp) then
                  proc4;
                end;
            end {$endregion}

          {Nearly Vertical   Line} {$region -fold}
          else
            begin
              if (y1<y0) then
                begin
                  ff1:=    p1 ;
                  Swap2(p0,p1);
                  Swap3(x0,x1);
                  Swap3(y0,y1);
                  SetArgs;
                end;
              GetLCoef2;
              if (x1>x0) then
                begin
                  if (x[0]<         rct_clp.left    ) then
                    begin
                      y[0]:=       (rct_clp.left-x0 )*k_+y0;
                       p0 :=Trunc(((rct_clp.left-1  )<<16-th+ONE_SHL_16_SUB_1)/tk)+ff1+1;
                    end;
                  if (y[0]<         rct_clp.top     ) then
                       p0 :=        rct_clp.top;
                  if (x[1]>=        rct_clp.right   ) then
                    begin
                      y[1]:=       (rct_clp.right-x0)*k_+y0;
                       p1 :=Trunc(((rct_clp.right-1 )<<16-th+ONE_SHL_16_SUB_1)/tk)+ff1;
                    end;
                  if (y[1]>=        rct_clp.bottom  ) then
                       p1 :=        rct_clp.bottom-1;
                  if CheckBounds then
                    begin
                      chk_bnds:=True;
                      th      :=tk*p0-tb;
                      {if ((th>>16)=rct_clp.left-1) then
                        begin
                          p0+=1;
                          th+=tk;
                        end;}
                    end;
                end
              else
                begin
                  if (x[0]>=        rct_clp.right   ) then
                    begin
                      y[0]:=       (rct_clp.right-x0)*k_+y0;
                       p0 :=Trunc(((rct_clp.right-1 )<<16-th+ONE_SHL_16_SUB_1)/tk)+ff1+1;
                    end;
                  if (y[0]<         rct_clp.top     ) then
                       p0 :=        rct_clp.top;
                  if (x[1]<         rct_clp.left    ) then
                    begin
                      y[1]:=       (rct_clp.left-x0 )*k_+y0;
                       p1 :=Trunc(((rct_clp.left-1  )<<16-th+ONE_SHL_16_SUB_1)/tk)+ff1;
                    end;
                  if (y[1]>=        rct_clp.bottom  ) then
                       p1 :=        rct_clp.bottom-1;
                  if CheckBounds then
                    begin
                      chk_bnds:=True;
                      th      :=tk*p0-tb;
                      {if (    ((tk*p1-tb)>>16)=rct_clp.left-1) then
                        p1:=Trunc(            (rct_clp.left<<16-th+ONE_SHL_16_SUB_1)/tk)+ff1;
                      if ((th>>16)=            rct_clp.right) then
                        begin
                          p0+=1;
                          th+=tk;
                        end;}
                    end;
                end;
              if chk_bnds then
                begin
                  {if (p1 =rct_clp.bottom) then
                      p1-=1;}
                  if IsPtInRct((tk*p0-tb)>>16,p0,rct_clp) and
                     IsPtInRct((tk*p1-tb)>>16,p1,rct_clp) then
                  proc5;
                end;
            end; {$endregion}

        end;
    end; {$endregion}

end; {$endregion}
procedure TFastLine.ClippedLine2(x0,y0,x1,y1:integer; const rct_clp:TPtRect                                                           ); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y: array[0..1] of integer;
  i  : byte;
begin
  if ((not ((x0<rct_clp.left) and (x1<rct_clp.left))) and (not ((x0>rct_clp.right ) and (x1>rct_clp.right )))) and
     ((not ((y0<rct_clp.top ) and (y1<rct_clp.top ))) and (not ((y0>rct_clp.bottom) and (y1>rct_clp.bottom)))) then
    begin
      x[0]:=x0;
      y[0]:=y0;
      x[1]:=x1;
      y[1]:=y1;
      i   :=0;
      repeat
        begin
          if (x[i]<rct_clp.left) then
            begin
              x[i]:=rct_clp.left;
              y[i]:=Trunc(((y1-y0)*(rct_clp.left  -x0))/(x1-x0)+y0);
            end
          else
          if (x[i]>rct_clp.right) then
            begin
              x[i]:=rct_clp.right;
              y[i]:=Trunc(((y1-y0)*(rct_clp.right -x0))/(x1-x0)+y0);
            end;
          if (y[i]<rct_clp.top) then
            begin
              y[i]:=rct_clp.top;
              x[i]:=Trunc(((x1-x0)*(rct_clp.top   -y0))/(y1-y0)+x0);
            end
          else
          if (y[i]>rct_clp.bottom) then
            begin
              y[i]:=rct_clp.bottom;
              x[i]:=Trunc(((x1-x0)*(rct_clp.bottom-y0))/(y1-y0)+x0);
            end;
          i:=i+1;
        end;
      until (i>1);
      if (not ((x[0]<rct_clp.left ) and (x[1]<rct_clp.left ))) and
         (not ((x[0]>rct_clp.right) and (x[1]>rct_clp.right))) then
        with ln_pos do
          begin
            x0:=x[0];
            y0:=y[0];
            x1:=x[1];
            y1:=y[1];
          end;
    end;
end; {$endregion}

// Fill buffer with anti-aliasing:
procedure TFastLine.FilBuffer(const rct_clp:TPtRect); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct: TPtRect;
begin
  with local_prop do
    if (clp_stl<>csResilientEdges) then
      begin
        with rct_clp do
          rct:=PtRct(left+1,top+1,right-1,bottom-1);
        ArrAdd(ln_arr0,
               ln_arr2,
               rct_clp,
               ln_arr_width,
               ln_arr_height);

        {Fill Buffer---------} {$region -fold}
        ArrFilProcArr[Byte(eds_bld_stl)](ln_arr0,
                                         bmp_dst_ptr,
                                         ln_arr_width,
                                         ln_arr_height,
                                         rct_clp,
                                         eds_col); {$endregion}

        {Border Anti-Aliasing} {$region -fold}
        if eds_aa then
          begin
            BorderCalc1 (ln_arr0,
                         aa_arr1,
                         ln_arr_width,
                         ln_arr_width,
                         rct,
                         aa_nz_arr_items_cnt);
            BorderCalc22(ln_arr0,
                         aa_arr1,
                         aa_arr2,
                         ln_arr_width,
                         ln_arr_width,
                         rct,
                         aa_line_cnt);
            BorderFill  (aa_arr2,
                         0,
                         0,
                         bmp_dst_ptr,
                         ln_arr_width,
                         aa_line_cnt,
                         eds_col,
                         args,
                         PPDec0ProcArr[pp_dec_2_proc_ind]);
          end; {$endregion}

      end;
end; {$endregion} {$endregion}

{$endregion}



(***************************** Fast text routines *****************************) {$region -fold}

{Init. part--} {$region -fold}
constructor TFastText.Create;                                                                                                               {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
destructor  TFastText.Destroy;                                                                                                               {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  self.Free;
  inherited Destroy;
end; {$endregion} {$endregion}

{$endregion}



(****************************** Points transform ******************************) {$region -fold}

// (Align points to horizontal line, from left to right): Выровнять точки по горизонтали, слева направо:
procedure PtsRawH        (var pts:TPtPosFArr; const start_ind,end_ind:TColor; const pts_dist:TColor);                                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {TODO}
end; {$endregion}
// (Align points to vertical line, from top to bottom): Выровнять точки по вертикали, сверху вниз:
procedure PtsRawV        (var pts:TPtPosFArr; const start_ind,end_ind:TColor; const pts_dist:TColor);                                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {TODO}
end; {$endregion}
// (Reset points position): Восстановить позицию точек:
procedure PtsRes         (const fst_pt_ptr1,fst_pt_ptr2:PPtPosF; const pts_cnt:TColor; const pt_pos_curr,pt_pos_prev:TPtPosF);                                        deprecated; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  fst_pt_ptr3: PPtPosF;
  i,n1,n2    : integer;
  m          : byte;
begin
  n1:=Trunc(pt_pos_curr.x)-Trunc(pt_pos_prev.x);
  n2:=Trunc(pt_pos_curr.y)-Trunc(pt_pos_prev.y);
  for i:=0 to Trunc(pts_cnt/4)-1 do
    begin
       fst_pt_ptr3      :=fst_pt_ptr1+i<<2;
      (fst_pt_ptr3+0)^.x+=n1;
      (fst_pt_ptr3+0)^.y+=n2;
      (fst_pt_ptr3+1)^.x+=n1;
      (fst_pt_ptr3+1)^.y+=n2;
      (fst_pt_ptr3+2)^.x+=n1;
      (fst_pt_ptr3+2)^.y+=n2;
      (fst_pt_ptr3+3)^.x+=n1;
      (fst_pt_ptr3+3)^.y+=n2;
    end;
  m:=pts_cnt mod 4;
  if (m<>0) then
    for i:=0 to m-1 do
      begin
        (fst_pt_ptr2+i)^.x+=n1;
        (fst_pt_ptr2+i)^.y+=n2;
      end;
end; {$endregion}
// (Points pivot) Ось точек:
procedure PtsPvt         (var   pvt:TPtPosF; var pts:TPtPosFArr; const pts_cnt:TColor);                                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr: PPtPosF;
  p      : TPtPosF;
  i      : integer;
begin
  if (pts=Nil) then
    Exit;
  p      :=Default(TPtPosF);
  pvt    :=Default(TPtPosF);
  pts_ptr:=Unaligned(@pts[0]);
  for i  :=0 to pts_cnt-1 do
    begin
      p.x+=(pts_ptr+i)^.x;
      p.y+=(pts_ptr+i)^.y;
    end;
  pvt.x  :=p.x/pts_cnt;
  pvt.y  :=p.y/pts_cnt;
end; {$endregion}
// (Points moving) Перемещение точек:
procedure PtsMov         (const pvt:TPtPos;  var pts:TPtPosFArr; const fst_ind,lst_ind:TColor);                                                                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr: PPtPosF;
  i      : integer;
begin
  if (pts=Nil) then
    Exit;
  pts_ptr:=Unaligned(@pts[fst_ind]);
  for i:=0 to lst_ind-fst_ind do
    begin
      pts_ptr^.x-=pvt.x;
      pts_ptr^.y-=pvt.y;
      Inc(pts_ptr);
    end;
end; {$endregion}
procedure PtsMov         (const pvt:TPtPos;  var rct:TPtRect);                                                                                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  rct.left  -=pvt.x;
  rct.top   -=pvt.y;
  rct.right -=pvt.x;
  rct.bottom-=pvt.y;
  rct.width :=rct.right -rct.left;
  rct.height:=rct.bottom-rct.top;
end; {$endregion}
procedure PtsMov         (const pvt:TPtPos;  var rct:TRect);                                                                                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  rct.left  -=pvt.x;
  rct.top   -=pvt.y;
  rct.right -=pvt.x;
  rct.bottom-=pvt.y;
  rct.width :=rct.right -rct.left;
  rct.height:=rct.bottom-rct.top;
end; {$endregion}
procedure PtsMov         (const pvt:TPtPos;  var rct:TPtRectF);                                                                                                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  rct.left  -=pvt.x;
  rct.top   -=pvt.y;
  rct.right -=pvt.x;
  rct.bottom-=pvt.y;
  rct.width :=rct.right -rct.left;
  rct.height:=rct.bottom-rct.top;
end; {$endregion}
procedure WndSht         (const outer_rect:TPtRect; const inner_rect:TPtPosFArr; var shift_power:integer; const mul:integer);                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m: integer;
begin
  m:=Max2(Trunc(inner_rect[1].x-
                inner_rect[0].x),
          Trunc(inner_rect[1].y-
                inner_rect[0].y));
  if (m>512) then
      shift_power:=Trunc(m/50);
  if (shift_power >Min3(outer_rect.width,
                       outer_rect.height)) then
      shift_power:=Min3(outer_rect.width,
                       outer_rect.height);
      shift_power*=mul>>4;
end; {$endregion}
procedure MDCalc         (var rct:TPtRectF; const mov_dir:TMovingDirection; const parallax_shift:TPtPosF);                                                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct do
    case mov_dir of
      mdNone:
        Exit;
      mdLeft:
        begin
          left +=parallax_shift.x;
          right+=parallax_shift.x;
          width:=right-left;
        end;
      mdRight:
        begin
          left -=parallax_shift.x;
          right-=parallax_shift.x;
          width:=right-left;
        end;
      mdUp:
        begin
          top   +=parallax_shift.y;
          bottom+=parallax_shift.y;
          height:=bottom-top;
        end;
      mdDown:
        begin
          top   -=parallax_shift.y;
          bottom-=parallax_shift.y;
          height:=bottom-top;
        end;
      mdLeftUp:
        begin
          left  +=parallax_shift.x;
          right +=parallax_shift.x;
          width :=right-left;
          top   +=parallax_shift.y;
          bottom+=parallax_shift.y;
          height:=bottom-top;
        end;
      mdRightUp:
        begin
          left  -=parallax_shift.x;
          right -=parallax_shift.x;
          width :=right-left;
          top   +=parallax_shift.y;
          bottom+=parallax_shift.y;
          height:=bottom-top;
        end;
      mdLeftDown:
        begin
          left  +=parallax_shift.x;
          right +=parallax_shift.x;
          width :=right-left;
          top   -=parallax_shift.y;
          bottom-=parallax_shift.y;
          height:=bottom-top;
        end;
      mdRightDown:
        begin
          left  -=parallax_shift.x;
          right -=parallax_shift.x;
          width :=right-left;
          top   -=parallax_shift.y;
          bottom-=parallax_shift.y;
          height:=bottom-top;
        end;
    end;
end; {$endregion}
// (Points scaling) Масштабирование точек:
procedure PtsScl         (const pvt:TPtPosF; var   pts    :TPtPosFArr;                       scl_mul:TPtPosF; const scl_dir:TSclDir; fst_ind:TColor=0; lst_ind:TColor=0); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr: PPtPosF;
  d      : TPtPosF;
  i      : integer;
begin
  if (pts=Nil) then
    Exit;
  if (scl_dir=sdNone) then
    Exit;
  if (scl_dir=sdDown) then
    scl_mul:=PtPosF(      (1/scl_mul.x),
                          (1/scl_mul.y));
  d        :=PtPosF(pvt.x*(1-scl_mul.x),
                    pvt.y*(1-scl_mul.y));
  pts_ptr  :=Unaligned(@pts[fst_ind]);
  for i:=0 to lst_ind-fst_ind do
    begin
      pts_ptr^.x:=scl_mul.x*pts_ptr^.x+d.x;
      pts_ptr^.y:=scl_mul.y*pts_ptr^.y+d.y;
      Inc(pts_ptr);
    end;
end; {$endregion}
procedure PtsScl         (const pvt:TPtPosF; var   rct    :TPtRectF  ;                       scl_mul:TPtPosF; const scl_dir:TSclDir                                    ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  d: TPtPosF;
begin
  if (scl_dir=sdNone) then
    Exit;
  if (scl_dir=sdDown) then
    scl_mul:=PtPosF(      (1/scl_mul.x),
                          (1/scl_mul.y));
  d        :=PtPosF(pvt.x*(1-scl_mul.x),
                    pvt.y*(1-scl_mul.y));
  with rct do
    begin
      left  :=left  *scl_mul.x+d.x;
      top   :=top   *scl_mul.y+d.y;
      right :=right *scl_mul.x+d.x;
      bottom:=bottom*scl_mul.y+d.y;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
procedure PtsScl         (const pvt:TPtPosF; const rct_src:TPtRect   ; var rct_dst:TPtRectF; scl_mul:TPtPosF; const scl_dir:TSclDir                                    ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  d: TPtPosF;
begin
  if (scl_dir=sdNone) then
    Exit;
  if (scl_dir=sdDown) then
    scl_mul:=PtPosF(      (1/scl_mul.x),
                          (1/scl_mul.y));
  d        :=PtPosF(pvt.x*(1-scl_mul.x),
                    pvt.y*(1-scl_mul.y));
  rct_dst  :=PtRctF(rct_src);
  with rct_dst do
    begin
      left  :=left  *scl_mul.x+d.x;
      top   :=top   *scl_mul.y+d.y;
      right :=right *scl_mul.x+d.x;
      bottom:=bottom*scl_mul.y+d.y;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
procedure PtsScl         (const pvt:TPtPosF; const rct_src:TPtRectF  ; var rct_dst:TPtRectF; scl_mul:TPtPosF; const scl_dir:TSclDir                                    ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  d: TPtPosF;
begin
  if (scl_dir=sdNone) then
    Exit;
  if (scl_dir=sdDown) then
    scl_mul:=PtPosF(      (1/scl_mul.x),
                          (1/scl_mul.y));
  d        :=PtPosF(pvt.x*(1-scl_mul.x),
                    pvt.y*(1-scl_mul.y));
  with rct_dst do
    begin
      left  :=rct_src.left  *scl_mul.x+d.x;
      top   :=rct_src.top   *scl_mul.y+d.y;
      right :=rct_src.right *scl_mul.x+d.x;
      bottom:=rct_src.bottom*scl_mul.y+d.y;
      width :=right-left;
      height:=bottom-top;
    end;
end; {$endregion}
function  GetDir1        (prev_pos,curr_pos,pvt:TPtPosF): TSclDir;                                                                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  dist  : double;
begin
  Result:=sdNone;
  dist  :=PtDistSqr(pvt.x,pvt.y,curr_pos.x,curr_pos.y)-
          PtDistSqr(pvt.x,pvt.y,prev_pos.x,prev_pos.y);
  if (dist>0) then
    Result:=sdUp
  else
  if (dist<0) then
    Result:=sdDown
  else
  if (dist=0) then
    Result:=sdNone;
end; {$endregion}
function  GetDir2        (prev_pos,curr_pos,pvt:TPtPosF): TSclDir;                                                                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=sdNone;
  if (curr_pos.x>prev_pos.x) then
    Result:=sdUp
  else
  if (curr_pos.x<prev_pos.x) then
    Result:=sdDown
  else
  if (curr_pos.x=prev_pos.x) then
    Result:=sdNone;
end; {$endregion}
procedure SetMul         (prev_pos,curr_pos,pvt:TPtPosF; var scl_mul:TPtPosF; const scl_dir:TSclDir);                                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  scl_mul:=PtPosF(DEFAULT_SCL_MUL,
                  DEFAULT_SCL_MUL);
  if (scl_dir=sdDown) then
    scl_mul:=PtPosF(1/scl_mul.x,
                    1/scl_mul.y);
end; {$endregion}
// (Points rotation) Вращение точек:
procedure GetRot         (const pvt:TPtPos    ;                          const angle:double; var c,s,v,w:double                         );                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SinCos(pi*(1+angle/180),s,c);
  v:=pvt.x*c-pvt.y*s+pvt.x;
  w:=pvt.y*c+pvt.x*s+pvt.y;
end; {$endregion}
procedure GetRot         (const pvt:TPtPos    ;                          const angle:double; var c,s,v,w:integer; const x,y    :integer );                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  c:=FloatToFixed(cos(pi*(1+angle/180)));
  s:=FloatToFixed(sin(pi*(1+angle/180)));
  v:=(pvt.x-x)*c-(pvt.y-y)*s+pvt.x<<16;
  w:=(pvt.y-y)*c+(pvt.x-x)*s+pvt.y<<16;
end; {$endregion}
procedure GetRot         (const pvt:TPtPosF   ;                          const angle:double; var c,s,v,w:double                         );                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SinCos(pi*(1+angle/180),s,c);
  v:=pvt.x*c-pvt.y*s+pvt.x;
  w:=pvt.y*c+pvt.x*s+pvt.y;
end; {$endregion}
procedure GetRotRound    (const pvt:TPtPos    ;                          const angle:double; var c,s,v,w:double;  const x,y    :integer );                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  v:=x;
  w:=y;
  c:=Tan(pi*(angle-45)/360);
  s:=Sin(pi*(angle-45)/180);
  v-=Round(w*c);
  w+=Round(v*s);
  v-=Round(w*c);
 {c   :=Round(Tan((pi*(1+angle/360))*ONE_SHL_16));
  s   :=Round(Sin((pi*(1+angle/180))*ONE_SHL_16));
  pt.y:= pt.y  +pt.x-pt.y*c*s  ;
  pt.x:=-pt.y*c-pt.y+pt.y*c*s*c;}
 {c:=FloatToFixed(cos(pi*(1+angle/180)));
  s:=FloatToFixed(sin(pi*(1+angle/180)));
  v:=(pvt.x-x)*c-(pvt.y-y)*s+pvt.x<<16;
  w:=(pvt.y-y)*c+(pvt.x-x)*s+pvt.y<<16;}
end; {$endregion}
procedure GetRotNotRound (const pvt:TPtPos    ;                          const angle:double; var c,s,v,w:double;  const x,y    :integer );                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  v:=x;
  w:=y;
  c:=Tan(pi*(angle-45)/360);
  s:=Sin(pi*(angle-45)/180);
  {v-={Round}(w*c);
  w+={Round}(v*s);
  v-={Round}(w*c);}

  //v:=x-y*c;
  w:=y+(x-y*c)*s;
  v:={x-y*c-(y+(x-y*c)*s)*c}{x-2*y*c-x*s*c+y*c*s*c}{x-2*y*c-x*s*c+y*c*s*c}x-(y<<1+(x-y*c)*s)*c;

 {c   :=Round(Tan((pi*(1+angle/360))*ONE_SHL_16));
  s   :=Round(Sin((pi*(1+angle/180))*ONE_SHL_16));
  pt.y:= pt.y  +pt.x-pt.y*c*s  ;
  pt.x:=-pt.y*c-pt.y+pt.y*c*s*c;}
 {c:=FloatToFixed(cos(pi*(1+angle/180)));
  s:=FloatToFixed(sin(pi*(1+angle/180)));
  v:=(pvt.x-x)*c-(pvt.y-y)*s+pvt.x<<16;
  w:=(pvt.y-y)*c+(pvt.x-x)*s+pvt.y<<16;}
end; {$endregion}
procedure GetRotNotRound2(const pvt:TPtPos    ;                          const angle:double; var c,s,v,w:integer; const x,y    :integer );                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  c:=Trunc(Tan(pi*(angle-45)/360)*65536);
  s:=Trunc(Sin(pi*(angle-45)/180)*65536);
  w:=(y<<48+(x-y*c)*s)>>48;
  v:={x-((x-y*c)*s+y<<1)*c}(x<<48-2*y*c-x*s*c+y*c*s*c)>>48;

 {c   :=Round(Tan((pi*(1+angle/360))*ONE_SHL_16));
  s   :=Round(Sin((pi*(1+angle/180))*ONE_SHL_16));
  pt.y:= pt.y  +pt.x-pt.y*c*s  ;
  pt.x:=-pt.y*c-pt.y+pt.y*c*s*c;}
 {c:=FloatToFixed(cos(pi*(1+angle/180)));
  s:=FloatToFixed(sin(pi*(1+angle/180)));
  v:=(pvt.x-x)*c-(pvt.y-y)*s+pvt.x<<16;
  w:=(pvt.y-y)*c+(pvt.x-x)*s+pvt.y<<16;}
end; {$endregion}
procedure PtsRot         (var   pts:TPtPosFArr; const pts_cnt:TColor;    const angle:double; var c,s,v,w:double;  const fst_ind:TColor=0);                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr: PPtPosF;
  dx,dy  : double ;
  i      : integer;
begin
  if (pts=Nil) then
    Exit;
  if (Trunc(angle) mod 360=0) then
    Exit;
  pts_ptr:=Unaligned(@pts[fst_ind]);
  for i:=0 to pts_cnt-fst_ind-1 do
    begin
      dx        :=pts_ptr^.x;
      dy        :=pts_ptr^.y;
      pts_ptr^.x:=-dx*c+dy*s+v;
      pts_ptr^.y:=-dy*c-dx*s+w;
      Inc(pts_ptr);
    end;
end; {$endregion}
function  PtsRot         (      rct:TPtRectF  ;                          const angle:double; var c,s,v,w:double;  const margin :TColor=1): TPtRectF;                      inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x0,x1,x2,x3: double ;
  y0,y1,y2,y3: double ;
  i          : integer;
begin
  if (Trunc(angle) mod 360=0) then
    Exit;
  with rct do
    begin
      x0:=-left  *c+top   *s+v;
      x1:=-right *c+top   *s+v;
      x2:=-right *c+bottom*s+v;
      x3:=-left  *c+bottom*s+v;
      y0:=-top   *c-left  *s+w;
      y1:=-top   *c-right *s+w;
      y2:=-bottom*c-right *s+w;
      y3:=-bottom*c-left  *s+w;
    end;
  with Result do
    begin
      left  :=Min1(Min1(x0,x1),Min1(x2,x3))-margin;
      top   :=Min1(Min1(y0,y1),Min1(y2,y3))-margin;
      right :=Max1(Max1(x0,x1),Max1(x2,x3))+margin;
      bottom:=Max1(Max1(y0,y1),Max1(y2,y3))+margin;
      width :=right -left;
      height:=bottom-top;
    end;
end; {$endregion}
function  PtsRot         (      rct:TRect     ;                          const angle:double; var c,s,v,w:double;  const margin :TColor=1): TRect;                         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x0,x1,x2,x3: double ;
  y0,y1,y2,y3: double ;
  i          : integer;
begin
  if (Trunc(angle) mod 360=0) then
    Exit;
  with rct do
    begin
      x0:=-left  *c+top   *s+v;
      x1:=-right *c+top   *s+v;
      x2:=-right *c+bottom*s+v;
      x3:=-left  *c+bottom*s+v;
      y0:=-top   *c-left  *s+w;
      y1:=-top   *c-right *s+w;
      y2:=-bottom*c-right *s+w;
      y3:=-bottom*c-left  *s+w;
    end;
  with Result do
    begin
      left  :=Trunc(Min1(Min1(x0,x1),Min1(x2,x3)))-margin;
      top   :=Trunc(Min1(Min1(y0,y1),Min1(y2,y3)))-margin;
      right :=Trunc(Max1(Max1(x0,x1),Max1(x2,x3)))+margin;
      bottom:=Trunc(Max1(Max1(y0,y1),Max1(y2,y3)))+margin;
      width :=right -left;
      height:=bottom-top;
    end;
end; {$endregion}
function  PtsRot         (      rct:TPtRect   ;                          const angle:double; var c,s,v,w:double;  const margin :TColor=1): TPtRect;                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x0,x1,x2,x3: double ;
  y0,y1,y2,y3: double ;
  i          : integer;
begin
  if (Trunc(angle) mod 360=0) then
    Exit;
  with rct do
    begin
      x0:=-left  *c+top   *s+v;
      x1:=-right *c+top   *s+v;
      x2:=-right *c+bottom*s+v;
      x3:=-left  *c+bottom*s+v;
      y0:=-top   *c-left  *s+w;
      y1:=-top   *c-right *s+w;
      y2:=-bottom*c-right *s+w;
      y3:=-bottom*c-left  *s+w;
    end;
  with Result do
    begin
      left  :=Trunc(Min1(Min1(x0,x1),Min1(x2,x3)))-margin;
      top   :=Trunc(Min1(Min1(y0,y1),Min1(y2,y3)))-margin;
      right :=Trunc(Max1(Max1(x0,x1),Max1(x2,x3)))+margin;
      bottom:=Trunc(Max1(Max1(y0,y1),Max1(y2,y3)))+margin;
      width :=right -left;
      height:=bottom-top;
    end;
end; {$endregion}
// (Points simplification) Точечное упрощение:
function  PtsSimplify0   (const pts_arr_ptr:PPtPosF; ind_arr_ptr:PColor; const pts_cnt:TColor; const angle   :double ): integer;                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ind_arr_ptr0: PColor;
  angle0      : double;
  i           : integer;
begin
  ind_arr_ptr0:=@ind_arr_ptr[0];
  ind_arr_ptr^:=0;
  angle0      :=0;
  for i:=0 to pts_cnt-2 do
    begin
          angle0+=180-GetAngle((pts_arr_ptr+i+0)^,(pts_arr_ptr+i+1)^,(pts_arr_ptr+i+2)^);
      if (angle0>=angle) then
        begin
          Inc(ind_arr_ptr);
          ind_arr_ptr^:=i+1;
          angle0      :=0;
        end;
    end;
  ind_arr_ptr^:=pts_cnt-1;
  Result      :=ind_arr_ptr-ind_arr_ptr0;
end; {$endregion}
function  PtsSimplify1   (const pts_arr_ptr:PPtPosF; ind_arr_ptr:PColor; const pts_cnt:TColor; const distance:integer): integer;                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ind_arr_ptr0: PColor;
  i           : integer;
begin
  ind_arr_ptr0:=@ind_arr_ptr[0];
  ind_arr_ptr^:=0;
  for i:=0 to pts_cnt-1 do
    begin
      if (PtDistSqr((pts_arr_ptr+ind_arr_ptr^)^,(pts_arr_ptr+i)^)>=sqr(distance)) then
        begin
          Inc(ind_arr_ptr);
          ind_arr_ptr^:=i;
        end;
    end;
  ind_arr_ptr^:=pts_cnt-1;
  Result      :=ind_arr_ptr-ind_arr_ptr0;
end; {$endregion}

{TODO}

{$endregion}



(************************** Miscellaneous primitives **************************) {$region -fold}

// Color info:
procedure SetColorInfo      (constref pix_col_:TColor; var color_info:TColorInfo );                                 inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with color_info do
    begin
      TRGBA(pix_col).r:=TRGBA(pix_col_).b;
      TRGBA(pix_col).g:=TRGBA(pix_col_).g;
      TRGBA(pix_col).b:=TRGBA(pix_col_).r;
    end;
end; {$endregion}
procedure SetColorInfo1     (constref pix_col_:TColor; var color_info:TColorInfo );                                 inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with color_info do
    begin
      pix_col:=pix_col_;
      {TRGBA(pix_col).r:=TRGBA(pix_col_).b;
      TRGBA(pix_col).g:=TRGBA(pix_col_).g;
      TRGBA(pix_col).b:=TRGBA(pix_col_).r;}
    end;
end; {$endregion}
procedure SetColorInfo2     (constref pix_col_:TColor; var color_info:TColorInfo; alpha1:byte=180; alpha2:byte=80); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with color_info do
    begin
      TRGBA(pix_col).r:=TRGBA(pix_col_).b;
      TRGBA(pix_col).g:=TRGBA(pix_col_).g;
      TRGBA(pix_col).b:=TRGBA(pix_col_).r;
        alpha1:=180;
      d_alpha1:=MAXBYTE-alpha1;
        alpha2:=80;
      d_alpha2:=MAXBYTE-alpha2;
    end;
end; {$endregion}
// Line segment:
function  LineS             (constref v0,w0,k ,b ,r:double; constref ln_kind:byte): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  d: double;
begin
  {
  y=k*x+b;
  b-w0=-k*v0;
  sqr(r)=sqr(y-w0)+sqr(x-v0);
  sqr(r)=sqr(k*x+b-w0)+sqr(x-v0)=sqr(k)*sqr(x)+2*(b-w0)*k*x+sqr(b-w0)+sqr(x)-2*v0*x+sqr(v0);
  (1+sqr(k))*sqr(x)+2*((b-w0)*k-v0)*x+sqr(b-w0)+sqr(v0)-sqr(r)=0;
  Det=4*(sqr((b-w0)*k-v0)-(1+sqr(k))*(sqr(b-w0)+sqr(v0)-sqr(r)))=4*( sqr(v0)*sqr(1+sqr(k))-(1+sqr(k))*sqr(v0)*sqr(k)-(1+sqr(k))*sqr(v0)+(1+sqr(k))*sqr(r))=4*(1+sqr(k))*(sqr(v0)*(1+sqr(k))-sqr(v0)*sqr(k)-sqr(v0)+sqr(r))=4*(1+sqr(k))*sqr(r);
  sqrt(Det)=2*r*sqrt(1+sqr(k));
  x=(-((b-w0)*k-v0)  (+/-)  sqrt(Det))/(1+sqr(k))=(v0*(1+sqr(k))  (+/-)  r*sqrt(1+sqr(k)))/(1+sqr(k))=v0  (+/-) (r/sqrt(1+k*k));
  }
  //Result:=Default(TLnPosF);
  with Result do
    begin
      if (r=0) then
        begin
          x0:=v0;
          y0:=w0;
          x1:=v0;
          y1:=w0;
          Exit;
        end;
      case ln_kind of
        //arbitrary line:
        0:
          begin
            d :=r*InvSqrt(1+k*k){r/sqrt(1+k*k)}; // only with garbage init. ON
            x0:=v0-d;
            y0:=w0-d*k;
            x1:=v0+d;
            y1:=w0+d*k;
          end;
        // vertical_line:
        1:
          begin
            x0:=v0;
            y0-=r;
            x1:=v0;
            y1+=r;
            Exit;
          end;
        // horizontal_line:
        2:
          begin
            x0-=r;
            y0:=w0;
            x1+=r;
            y1:=w0;
            Exit;
          end;
      end;
    end;
end; {$endregion}
function  LineS             (constref v0,w0,v1,w1,r:double                       ): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k,d: double;
begin
  with Result do
    begin
      if (r=0) then
        begin
          x0:=v0;
          y0:=w0;
          x1:=v0;
          y1:=w0;
          Exit;
        end;
      if (v0=v1) then
        begin
          x0:=v0;
          y0-=r;
          x1:=v0;
          y1+=r;
          Exit;
        end;
      if (w0=w1) then
        begin
          x0-=r;
          y0:=w0;
          x1+=r;
          y1:=w0;
          Exit;
        end;
      k :=(w0-w1)/(v0-v1);
      d :=r*InvSqrt(1+k*k){r/sqrt(1+k*k)}; // only with garbage init. ON
      x0:=v0-d;
      y0:=w0-d*k;
      x1:=v0+d;
      y1:=w0+d*k;
    end;
end; {$endregion}
function  LineS             (constref v0,w0,v1,w1,r:double; constref dir:shortint): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k,d: double;
begin
  with Result do
    begin
      if (r=0) then
        begin
          x:=v0;
          y:=w0;
          Exit;
        end;
      if (v0=v1) then
        begin
          x:=v0;
          y:=w0+r*dir;
          Exit;
        end;
      if (w0=w1) then
        begin
          x:=v0+r*dir;
          y:=w0;
          Exit;
        end;
      k:=(w0-w1)/(v0-v1);
      d:=r*InvSqrt(1+k*k){r/sqrt(1+k*k)}; // only with garbage init. ON
      x:=v0+dir*d;
      y:=w0+dir*d*k;
    end;
end; {$endregion}
// Line direction:
procedure LineD             (constref x0,y0,x1,y1:double ; var dir_x,dir_y:shortint); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (x1>x0) then
    begin
      if (y1=y0) then
        begin
          dir_x:=1;
          dir_y:=0;
          Exit;
        end;
      if (y1>y0) then
        begin
          dir_x:=1;
          dir_y:=1;
          Exit;
        end
      else
        begin
          dir_x:= 1;
          dir_y:=-1;
          Exit;
        end;
    end
  else
    begin
      if (x1=x0) then
        begin
          if (y1=y0) then
            begin
              dir_x:=0;
              dir_y:=0;
              Exit;
            end;
          if (y1>y0) then
            begin
              dir_x:=0;
              dir_y:=1;
              Exit;
            end
          else
            begin
              dir_x:= 0;
              dir_y:=-1;
              Exit;
            end;
        end;
      if (y1=y0) then
        begin
          dir_x:=-1;
          dir_y:= 0;
          Exit;
        end;
      if (y1>y0) then
        begin
          dir_x:=-1;
          dir_y:= 1;
          Exit;
        end
      else
        begin
          dir_x:=-1;
          dir_y:=-1;
          Exit;
        end;
    end;
end; {$endregion}
procedure LineD             (constref vec        :TLnPosF; var dir_x,dir_y:shortint); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with vec do
    if (x1>x0) then
      begin
        if (y1=y0) then
          begin
            dir_x:=1;
            dir_y:=0;
            Exit;
          end;
        if (y1>y0) then
          begin
            dir_x:=1;
            dir_y:=1;
            Exit;
          end
        else
          begin
            dir_x:= 1;
            dir_y:=-1;
            Exit;
          end;
      end
    else
      begin
        if (x1=x0) then
          begin
            if (y1=y0) then
              begin
                dir_x:=0;
                dir_y:=0;
                Exit;
              end;
            if (y1>y0) then
              begin
                dir_x:=0;
                dir_y:=1;
                Exit;
              end
            else
              begin
                dir_x:= 0;
                dir_y:=-1;
                Exit;
              end;
          end;
        if (y1=y0) then
          begin
            dir_x:=-1;
            dir_y:= 0;
            Exit;
          end;
        if (y1>y0) then
          begin
            dir_x:=-1;
            dir_y:= 1;
            Exit;
          end
        else
          begin
            dir_x:=-1;
            dir_y:=-1;
            Exit;
          end;
      end;
end; {$endregion}
// Monochrome regular line(width - 1 pixel):
procedure Line              (x0,y0,x1,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  y0_shift                        : integer;
  i,short_len,long_len,swp,dec_inc: integer;
  yLonger                         : boolean;
begin
  with color_info do
    begin
      yLonger  :=False;
      short_len:=y1-y0;
      long_len :=x1-x0;
      if (Abs(short_len)>Abs(long_len)) then
        begin
          swp      :=short_len;
          short_len:=long_len;
          long_len :=swp;
          yLonger  :=True;
        end;
      if (long_len=0) then
        dec_inc:=0
      else
        dec_inc:=Trunc((short_len<<16)/long_len);
      if (yLonger) then
        begin
          if (long_len>0) then
            begin
    	      long_len+=y0;
              i:=$8000+(x0<<16);
              y0_shift:=y0*bmp_dst_width;
              while (y0<=long_len) do
                begin
                  (bmp_dst_ptr+(i>>16)+y0_shift)^:=pix_col;
    	          i+=dec_inc;
                  Inc(y0);
                  Inc(y0_shift,bmp_dst_width);
                end;
              Exit;
            end;
          long_len+=y0;
          i:=$8000+(x0<<16);
          y0_shift:=y0*bmp_dst_width;
          while (y0>=long_len) do
            begin
              (bmp_dst_ptr+(i>>16)+y0_shift)^:=pix_col;
              i-=dec_inc;
              Dec(y0);
              Dec(y0_shift,bmp_dst_width);
            end;
          Exit;
        end;
      if (long_len>0) then
        begin
          long_len+=x0;
          i:=$8000+(y0<<16);
          while (x0<=long_len) do
            begin
              (bmp_dst_ptr+x0+(i>>16)*bmp_dst_width)^:=pix_col;
              i+=dec_inc;
              Inc(x0);
            end;
          Exit;
        end;
      long_len+=x0;
      i:=$8000+(y0<<16);
      while (x0>=long_len) do
        begin
          (bmp_dst_ptr+x0+(i>>16)*bmp_dst_width)^:=pix_col;
          i-=dec_inc;
          Dec(x0);
        end;
    end;
end; {$endregion}
procedure Line              (x0,y0,x1,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref val       :TColor    ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  y0_shift                        : integer;
  i,short_len,long_len,swp,dec_inc: integer;
  yLonger                         : boolean;
begin
  yLonger  :=False;
  short_len:=y1-y0;
  long_len :=x1-x0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
    end;
  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);
  if (yLonger) then
    begin
      if (long_len>0) then
        begin
          long_len+=y0;
          i:=$8000+(x0<<16);
          y0_shift:=y0*bmp_dst_width;
          while (y0<=long_len) do
            begin
              (bmp_dst_ptr+(i>>16)+y0_shift)^:=val;
              i+=dec_inc;
              Inc(y0);
              Inc(y0_shift,bmp_dst_width);
            end;
          Exit;
        end;
      long_len+=y0;
      i:=$8000+(x0<<16);
      y0_shift:=y0*bmp_dst_width;
      while (y0>=long_len) do
        begin
          (bmp_dst_ptr+(i>>16)+y0_shift)^:=val;
          i-=dec_inc;
          Dec(y0);
          Dec(y0_shift,bmp_dst_width);
        end;
      Exit;
    end;
  if (long_len>0) then
    begin
      long_len+=x0;
      i:=$8000+(y0<<16);
      while (x0<=long_len) do
        begin
          (bmp_dst_ptr+x0+(i>>16)*bmp_dst_width)^:=val;
          i+=dec_inc;
          Inc(x0);
        end;
      Exit;
    end;
  long_len+=x0;
  i:=$8000+(y0<<16);
  while (x0>=long_len) do
    begin
      (bmp_dst_ptr+x0+(i>>16)*bmp_dst_width)^:=val;
      i-=dec_inc;
      Dec(x0);
    end;
end; {$endregion}
procedure Line              (x0,y0,x1,y1:integer; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width:TColor; constref val       :byte      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  y0_shift                        : integer;
  i,short_len,long_len,swp,dec_inc: integer;
  yLonger                         : boolean;
begin
  yLonger  :=False;
  short_len:=y1-y0;
  long_len :=x1-x0;
  if (Abs(short_len)>Abs(long_len)) then
    begin
      swp      :=short_len;
      short_len:=long_len;
      long_len :=swp;
      yLonger  :=True;
    end;
  if (long_len=0) then
    dec_inc:=0
  else
    dec_inc:=Trunc((short_len<<16)/long_len);
  if (yLonger) then
    begin
      if (long_len>0) then
        begin
          long_len+=y0;
          i:=$8000+(x0<<16);
          y0_shift:=y0*bmp_dst_width;
          while (y0<=long_len) do
            begin
              (bmp_dst_ptr+(i>>16)+y0_shift)^:=val;
              i+=dec_inc;
              Inc(y0);
              Inc(y0_shift,bmp_dst_width);
            end;
          Exit;
        end;
      long_len+=y0;
      i:=$8000+(x0<<16);
      y0_shift:=y0*bmp_dst_width;
      while (y0>=long_len) do
        begin
          (bmp_dst_ptr+(i>>16)+y0_shift)^:=val;
          i-=dec_inc;
          Dec(y0);
          Dec(y0_shift,bmp_dst_width);
        end;
      Exit;
    end;
  if (long_len>0) then
    begin
      long_len+=x0;
      i:=$8000+(y0<<16);
      while (x0<=long_len) do
        begin
          (bmp_dst_ptr+x0+(i>>16)*bmp_dst_width)^:=val;
          i+=dec_inc;
          Inc(x0);
        end;
      Exit;
    end;
  long_len+=x0;
  i:=$8000+(y0<<16);
  while (x0>=long_len) do
    begin
      (bmp_dst_ptr+x0+(i>>16)*bmp_dst_width)^:=val;
      i-=dec_inc;
      Dec(x0);
    end;
end; {$endregion}
// Line segments intersection:
function LineSI             (x0,y0,x1,y1,v0,w0,v1,w1:double ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  a0,a1,b0,b1: boolean;}
begin
  {a0:=((x0-x1)*(w0-y1)<=(y0-y1)*(v0-x1));
  a1:=((x0-x1)*(w1-y1)<=(y0-y1)*(v1-x1));
  b0:=((v1-v0)*(y1-w0)<=(w1-w0)*(x1-v0));
  b1:=((v1-v0)*(y0-w0)<=(w1-w0)*(x0-v0));
  Result:=((a0 and (not a1)) or (a1 and (not a0))) and
          ((b0 and (not b1)) or (b1 and (not b0)));}
  Result:=(((x0-x1)*(w0-y1)-(y0-y1)*(v0-x1))*
           ((x0-x1)*(w1-y1)-(y0-y1)*(v1-x1))<=0) and
          (((v1-v0)*(y1-w0)-(w1-w0)*(x1-v0))*
           ((v1-v0)*(y0-w0)-(w1-w0)*(x0-v0))<=0);
end; {$endregion}
function LineSI             (x0,y0,x1,y1,v0,w0,v1,w1:integer): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  a0,a1,b0,b1: boolean;}
begin
  {a0:=((x0-x1)*(w0-y1)<=(y0-y1)*(v0-x1));
  a1:=((x0-x1)*(w1-y1)<=(y0-y1)*(v1-x1));
  b0:=((v1-v0)*(y1-w0)<=(w1-w0)*(x1-v0));
  b1:=((v1-v0)*(y0-w0)<=(w1-w0)*(x0-v0));
  Result:=((a0 and (not a1)) or (a1 and (not a0))) and
          ((b0 and (not b1)) or (b1 and (not b0)));}
  Result:=(((x0-x1)*(w0-y1)-(y0-y1)*(v0-x1))*
           ((x0-x1)*(w1-y1)-(y0-y1)*(v1-x1))<=0) and
          (((v1-v0)*(y1-w0)-(w1-w0)*(x1-v0))*
           ((v1-v0)*(y0-w0)-(w1-w0)*(x0-v0))<=0);
end; {$endregion}
// Line clipping:
function LineCF             (var x0,y0,x1,y1:double ; constref rct_clp:TPtRectF): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x: array[0..1] of double;
  y: array[0..1] of double;
  i: byte;
begin
  Result:=False;
  if ((not ((x0<rct_clp.left) and (x1<rct_clp.left))) and (not ((x0>rct_clp.right ) and (x1>rct_clp.right )))) and
     ((not ((y0<rct_clp.top ) and (y1<rct_clp.top ))) and (not ((y0>rct_clp.bottom) and (y1>rct_clp.bottom)))) then
    begin
      x[0]:=x0;
      y[0]:=y0;
      x[1]:=x1;
      y[1]:=y1;
      i   :=0;
      repeat
        begin
          if (x[i]<rct_clp.left) then
            begin
              x[i]:=rct_clp.left;
              y[i]:=((y1-y0)*(rct_clp.left  -x0))/(x1-x0)+y0;
            end
          else
          if (x[i]>rct_clp.right) then
            begin
              x[i]:=rct_clp.right;
              y[i]:=((y1-y0)*(rct_clp.right -x0))/(x1-x0)+y0;
            end;
          if (y[i]<rct_clp.top) then
            begin
              y[i]:=rct_clp.top;
              x[i]:=((x1-x0)*(rct_clp.top   -y0))/(y1-y0)+x0;
            end
          else
          if (y[i]>rct_clp.bottom) then
            begin
              y[i]:=rct_clp.bottom;
              x[i]:=((x1-x0)*(rct_clp.bottom-y0))/(y1-y0)+x0;
            end;
          i:=i+1;
        end;
      until (i>1);
      if (not ((x[0]<rct_clp.left ) and (x[1]<rct_clp.left ))) and
         (not ((x[0]>rct_clp.right) and (x[1]>rct_clp.right))) then
        begin
          Result:=True;
          x0    :=x[0];
          y0    :=y[0];
          x1    :=x[1];
          y1    :=y[1];
        end;
    end;
end; {$endregion}
function LineC              (var x0,y0,x1,y1:integer; constref rct_clp:TPtRect ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x: array[0..1] of integer;
  y: array[0..1] of integer;
  i: byte;
begin
  Result:=False;
  if ((not ((x0<rct_clp.left) and (x1<rct_clp.left))) and (not ((x0>rct_clp.right ) and (x1>rct_clp.right )))) and
     ((not ((y0<rct_clp.top ) and (y1<rct_clp.top ))) and (not ((y0>rct_clp.bottom) and (y1>rct_clp.bottom)))) then
    begin
      x[0]:=x0;
      y[0]:=y0;
      x[1]:=x1;
      y[1]:=y1;
      i   :=0;
      repeat
        begin
          if (x[i]<rct_clp.left) then
            begin
              x[i]:=rct_clp.left;
              y[i]:=Trunc(((y1-y0)*(rct_clp.left  -x0))/(x1-x0)+y0);
            end
          else
          if (x[i]>rct_clp.right) then
            begin
              x[i]:=rct_clp.right;
              y[i]:=Trunc(((y1-y0)*(rct_clp.right -x0))/(x1-x0)+y0);
            end;
          if (y[i]<rct_clp.top) then
            begin
              y[i]:=rct_clp.top;
              x[i]:=Trunc(((x1-x0)*(rct_clp.top   -y0))/(y1-y0)+x0);
            end
          else
          if (y[i]>rct_clp.bottom) then
            begin
              y[i]:=rct_clp.bottom;
              x[i]:=Trunc(((x1-x0)*(rct_clp.bottom-y0))/(y1-y0)+x0);
            end;
          i:=i+1;
        end;
      until (i>1);
      if (not ((x[0]<rct_clp.left ) and (x[1]<rct_clp.left ))) and
         (not ((x[0]>rct_clp.right) and (x[1]>rct_clp.right))) then
        begin
          Result:=True;
          x0    :=x[0];
          y0    :=y[0];
          x1    :=x[1];
          y1    :=y[1];
        end;
    end;
end; {$endregion}
// Monochrome horizontal line(width - 1 pixel):
function  LineHC            (var x0,y0,x1:integer; constref rct_clp:TPtRect): boolean;                                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_clp: array[0..7] of boolean;
  clp    : qword absolute arr_clp;
  x2     : integer;
begin
  Result:=True;
  if (y0<rct_clp.top) or (y0>=rct_clp.bottom) then
    begin
      Result:=False;
      Exit;
    end;
  if (x0>x1) then
    begin
      x2:=x1;
      x1:=x0;
      x0:=x2;
    end;
  arr_clp[00]:=(x0< rct_clp.left  );
  arr_clp[01]:=(x0>=rct_clp.left  ) and (x0<rct_clp.right);
  arr_clp[02]:=(x0>=rct_clp.right );
  arr_clp[03]:=(x1< rct_clp.left  );
  arr_clp[04]:=(x1>=rct_clp.left  ) and (x1<rct_clp.right);
  arr_clp[05]:=(x1>=rct_clp.right );
  arr_clp[06]:=False;
  arr_clp[07]:=False;
  case clp of
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000000000000000000001000000000000000000000001:
      begin
        Result:=False;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000000000000100000000000000000000000000000001:
      begin
        x0    :=rct_clp.left;
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000010000000000000000000000000000000000000001:
      begin
        x0    :=rct_clp.left;
        x1    :=rct_clp.right-1;
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000000000000100000000000000000000000100000000:
      begin
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000010000000000000000000000000000000100000000:
      begin
        x1    :=rct_clp.right-1;
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000010000000000000000000000010000000000000000:
      begin
        Result:=False;
        Exit;
      end;
  end;
end; {$endregion}
procedure LineH             (    x0,y0,x1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FillDWord((bmp_dst_ptr+x0+y0*bmp_dst_width)^,x1-x0+1,color_info.pix_col);
end; {$endregion}
procedure LineH             (    x0,y0,x1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref val       :TColor    ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FillDWord((bmp_dst_ptr+x0+y0*bmp_dst_width)^,x1-x0+1,val);
end; {$endregion}
procedure LineH             (    x0,y0,x1:integer; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width:TColor; constref val       :byte      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FillByte((bmp_dst_ptr+x0+y0*bmp_dst_width)^,x1-x0+1,val);
end; {$endregion}
// Monochrome vertical line(width - 1 pixel):
function  LineVC            (var x0,y0,y1:integer; constref rct_clp:TPtRect): boolean;                                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_clp: array[0..7] of boolean;
  clp    : qword absolute arr_clp;
  y2     : integer;
begin
  Result:=True;
  if (x0<rct_clp.left) or (x0>=rct_clp.right) then
    begin
      Result:=False;
      Exit;
    end;
  if (y0>y1) then
    begin
      y2:=y1;
      y1:=y0;
      y0:=y2;
    end;
  arr_clp[00]:=(y0< rct_clp.top   );
  arr_clp[01]:=(y0>=rct_clp.top   ) and (y0<rct_clp.bottom);
  arr_clp[02]:=(y0>=rct_clp.bottom);
  arr_clp[03]:=(y1< rct_clp.top   );
  arr_clp[04]:=(y1>=rct_clp.top   ) and (y1<rct_clp.bottom);
  arr_clp[05]:=(y1>=rct_clp.bottom);
  arr_clp[06]:=False;
  arr_clp[07]:=False;
  case clp of
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000000000000000000001000000000000000000000001:
      begin
        Result:=False;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000000000000100000000000000000000000000000001:
      begin
        y0    :=rct_clp.top;
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000010000000000000000000000000000000000000001:
      begin
        y0    :=rct_clp.top;
        y1    :=rct_clp.bottom-1;
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000000000000100000000000000000000000100000000:
      begin
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000010000000000000000000000000000000100000000:
      begin
        y1    :=rct_clp.bottom-1;
        Result:=True;
        Exit;
      end;
    {|e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   |e.b.   }
    %0000000000000000000000010000000000000000000000010000000000000000:
      begin
        Result:=False;
        Exit;
      end;
  end;
end; {$endregion}
procedure LineV             (    x0,y0,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_ptr: PInteger;
  i     : integer;
begin
  ln_ptr:=bmp_dst_ptr+x0+y0*bmp_dst_width;
  for i:=0 to y1-y0 do
    begin
      ln_ptr^:=color_info.pix_col;
      Inc(ln_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure LineV             (    x0,y0,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref val       :TColor    ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_ptr: PInteger;
  i     : integer;
begin
  ln_ptr:=bmp_dst_ptr+x0+y0*bmp_dst_width;
  for i:=0 to y1-y0 do
    begin
      ln_ptr^:=val;
      Inc(ln_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure LineV             (    x0,y0,y1:integer; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width:TColor; constref val       :byte      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  ln_ptr: PByte;
  i     : integer;
begin
  ln_ptr:=bmp_dst_ptr+x0+y0*bmp_dst_width;
  for i:=0 to y1-y0 do
    begin
      ln_ptr^:=val;
      Inc(ln_ptr,bmp_dst_width);
    end;
end; {$endregion}
// Monochrome anti-aliased line(width - 1 pixel):
procedure LineA             (    x0,y0,x1,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor;                           constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  dx,dy,dydx                                      : double;
  df,deltax,deltay,i,start,finish,dx_,dy_,loop_cnt: integer;
begin
  with color_info do
    begin
      deltax:=Abs(x1-x0);
      deltay:=Abs(y1-y0);
      {if (deltax=0) or (deltay=0) then
        Exit;}
      if (deltax>deltay) then
        begin
          if (y1>y0) then
            dydx:=-deltay/deltax
          else
            dydx:= deltay/deltax;
          if (x1<x0) then
            begin
              start :=x1;
              finish:=x0;
              dy    :=y1;
            end
          else
            begin
              start :=x0;
              finish:=x1;
              dy    :=y0;
              dydx  :=-dydx;
            end;
          for i:=start to finish do
            begin
              dy_:=Trunc (dy);
              df :=Trunc (MAXBYTE*(dy-   dy_)); // MAXBYTE*dy_0+MAXBYTE*loop*([deltay/deltax]+{deltay/deltax})=MAXBYTE*(dy_0+loop)+MAXBYTE*loop*{deltay/deltax}
              AlphaBlend1(bmp_dst_ptr+i+(dy_+0)*bmp_dst_width,pix_col,        df);
              AlphaBlend1(bmp_dst_ptr+i+(dy_+1)*bmp_dst_width,pix_col,MAXBYTE-df);
              dy+=dydx;
            end;
        end
      else
        begin
          if (x1>x0) then
            dydx:=-deltax/deltay
          else
            dydx:= deltax/deltay;
          if (y1<y0) then
            begin
              start :=y1;
              finish:=y0;
              dx    :=x1;
            end
          else
            begin
              start :=y0;
              finish:=y1;
              dx    :=x0;
              dydx  :=-dydx;
            end;
          loop_cnt:=start*bmp_dst_width;
          for i:=start to finish do
            begin
              dx_:=Trunc (dx);
              df :=Trunc (MAXBYTE*(dx-dx_));
              AlphaBlend1(bmp_dst_ptr+dx_+loop_cnt+0,pix_col,        df);
              AlphaBlend1(bmp_dst_ptr+dx_+loop_cnt+1,pix_col,MAXBYTE-df);
              Inc(loop_cnt,bmp_dst_width);
              dx+=dydx;
            end;
        end;
    end;
end; {$endregion}
procedure LineAC           ({var}x0,y0,x1,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_clp:TPtRect; constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (y0=y1) then
    begin
      // Line Clipping:
      if LineHC(x0,y0,x1,rct_clp) then
      // Line Drawing:
         LineH (x0,y0,x1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
    end
  else
    begin
      // Line Clipping:
      if LineC(x0,y0,x1,y1,rct_clp) then
      // Line Drawing:
         LineA(x0,y0,x1,y1,bmp_dst_ptr,bmp_dst_width,color_info);
    end;
end; {$endregion}
// Monochrome anti-aliased broken clipped line(width - 1 pixel):
procedure LineABC           (constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_clp:TPtRect; constref color_info:TColorInfo; constref shift:TPtPos; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr            : PPtPosF;
  x0,y0,x1,y1,i,d_ind: integer;
begin
  d_ind:=end_ind-start_ind;
  if (d_ind=0) then
    Exit;
  pts_ptr:=Unaligned(@pts[start_ind]);
  for i:=0 to d_ind-1 do
    begin
      x0:=Trunc((pts_ptr+0)^.x)+shift.x;
      y0:=Trunc((pts_ptr+0)^.y)+shift.y;
      x1:=Trunc((pts_ptr+1)^.x)+shift.x;
      y1:=Trunc((pts_ptr+1)^.y)+shift.y;
      if (y0=y1) then
        begin
          // Line Clipping:
          if LineHC(x0,y0,x1,rct_clp) then
            // Line Drawing:
            LineH(x0,y0,x1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        end
      else
        begin
          // Line Clipping:
          if LineC(x0,y0,x1,y1,rct_clp) then
            // Line Drawing:
            LineA(x0,y0,x1,y1,bmp_dst_ptr,bmp_dst_width,color_info);
        end;
      Inc(pts_ptr);
    end;
  if exp_ then
    begin
      pts_ptr:=Unaligned(@pts[start_ind]);
      x0     :=Trunc((pts_ptr+00000)^.x)+shift.x;
      y0     :=Trunc((pts_ptr+00000)^.y)+shift.y;
      x1     :=Trunc((pts_ptr+d_ind)^.x)+shift.x;
      y1     :=Trunc((pts_ptr+d_ind)^.y)+shift.y;
      if (y0=y1) then
        begin
          // Line Clipping:
          if LineHC(x0,y0,x1,rct_clp) then
            // Line Drawing:
            LineH(x0,y0,x1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        end
      else
        begin
          // Line Clipping:
          if LineC(x0,y0,x1,y1,rct_clp) then
            // Line Drawing:
            LineA(x0,y0,x1,y1,bmp_dst_ptr,bmp_dst_width,color_info);
        end;
    end;
end; {$endregion}
// Gradient(highlight) antialiased broken clipped line(width - 1 pixel):
procedure LineABCG          (constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_clp:TPtRect; var      color_info:TColorInfo; constref shift:TPtPos; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr              : PPtPosF;
  x0,y0,x1,y1,i,d_ind,p: integer;
  pix_col              : TColor;
begin
  d_ind:=end_ind-start_ind;
  if (d_ind=0) then
    Exit;
  p      :=0;
  pix_col:=color_info.pix_col;
  pts_ptr:=Unaligned(@pts[start_ind]);
  for i:=0 to d_ind-1 do
    begin
      x0:=Trunc((pts_ptr+0)^.x)+shift.x;
      y0:=Trunc((pts_ptr+0)^.y)+shift.y;
      x1:=Trunc((pts_ptr+1)^.x)+shift.x;
      y1:=Trunc((pts_ptr+1)^.y)+shift.y;
      SetColorInfo(Highlight2(pix_col,p),color_info);
      if (y0=y1) then
        begin
          // Line Clipping:
          if LineHC(x0,y0,x1,rct_clp) then
            // Line Drawing:
            LineH(x0,y0,x1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        end
      else
        begin
          // Line Clipping:
          if LineC(x0,y0,x1,y1,rct_clp) then
            // Line Drawing:
            LineA(x0,y0,x1,y1,bmp_dst_ptr,bmp_dst_width,color_info);
        end;
      Inc(p);
      Inc(pts_ptr);
    end;
  if exp_ then
    begin
      pts_ptr:=Unaligned(@pts[start_ind]);
      x0     :=Trunc((pts_ptr+00000)^.x)+shift.x;
      y0     :=Trunc((pts_ptr+00000)^.y)+shift.y;
      x1     :=Trunc((pts_ptr+d_ind)^.x)+shift.x;
      y1     :=Trunc((pts_ptr+d_ind)^.y)+shift.y;
      SetColorInfo(Highlight2(pix_col,p),color_info);
      if (y0=y1) then
        begin
          // Line Clipping:
          if LineHC(x0,y0,x1,rct_clp) then
            // Line Drawing:
            LineH(x0,y0,x1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        end
      else
        begin
          // Line Clipping:
          if LineC(x0,y0,x1,y1,rct_clp) then
            // Line Drawing:
            LineA(x0,y0,x1,y1,bmp_dst_ptr,bmp_dst_width,color_info);
        end;
    end;
end; {$endregion}
// Equidistant line(width - 1 pixel):
function  LineE1            (constref v0,w0,v1,w1,rad:double): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k,d,l0,l1: double;
begin
  with Result do
    begin
      if (v1=v0) then
        begin
          x0:=v0-rad;
          y0:=w0;
          x1:=x0;
          y1:=w1;
          Exit;
        end
      else
        begin
          if (w1=w0) then
            begin
              x0:=v0;
              y0:=w0-rad;
              x1:=v1;
              y1:=y0;
              Exit;
            end;
          k :=(w1-w0)/(v1-v0);
          d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
          l0:=rad*d*k;
          l1:=rad*d  ;
          x0:=v0-l0;
          y0:=w0+l1;
          x1:=v1-l0;
          y1:=w1+l1;
        end;
    end;
end; {$endregion}
function  LineE2            (constref v0,w0,v1,w1,rad:double): TLnPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k,d,l0,l1: double;
begin
  with Result do
    begin
      if (v1=v0) then
        begin
          x0:=v0+rad;
          y0:=w0;
          x1:=x0;
          y1:=w1;
          Exit;
        end
      else
        begin
          if (w1=w0) then
            begin
              x0:=v0;
              y0:=w0+rad;
              x1:=v1;
              y1:=y0;
              Exit;
            end;
          k :=(w1-w0)/(v1-v0);
          d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
          l0:=rad*d*k;
          l1:=rad*d  ;
          x0:=v0+l0;
          y0:=w0-l1;
          x1:=v1+l0;
          y1:=w1-l1;
        end;
    end;
end; {$endregion}
// Equidistant curve for anti-aliased broken clipped line(width - 1 pixel):
procedure LineABCE          (constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_clp:TPtRect; constref color_info:TColorInfo; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    {if (Abs(x1-x0){*(x1-x0)}+Abs(y1-y0){*(y1-y0)}<2) then
      begin
        Inc(pts_ptr);
        Continue;
      end;}
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=x1-rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          LineA(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        v0:=x0+rad;
        w0:=y0;
        v1:=x1+rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          LineA(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          LineA(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          LineA(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            bmp_dst_width,
            rct_clp,
            color_info.pix_col);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (end_ind-start_ind>0) then
    CircProc(d_ind);
end; {$endregion}
// Equidistant curve for not anti-aliased broken clipped line(width - 1 pixel):
procedure LineBCE           (constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_clp:TPtRect; constref color_info:TColorInfo; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    {if (Abs(x1-x0){*(x1-x0)}+Abs(y1-y0){*(y1-y0)}<2) then
      begin
        Inc(pts_ptr);
        Continue;
      end;}
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=x1-rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        v0:=x0+rad;
        w0:=y0;
        v1:=x1+rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            bmp_dst_width,
            rct_clp,
            color_info.pix_col);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (end_ind-start_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE           (constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_clp:TPtRect; constref val       :TColor    ; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=x1-rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        v0:=x0+rad;
        w0:=y0;
        v1:=x1+rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            bmp_dst_width,
            rct_clp,
            val);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (end_ind-start_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE           (constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width:TColor; constref rct_clp:TPtRect; constref val       :byte      ; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=x1-rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        v0:=x0+rad;
        w0:=y0;
        v1:=x1+rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            bmp_dst_width,
            rct_clp,
            val);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (end_ind-start_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE           (constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_clp:TPtRect;                                 constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  pt_ind     : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0    :=Trunc((pts_ptr+i)^.x)+shift.x;
    y0    :=Trunc((pts_ptr+i)^.y)+shift.y;
    x1    :=Trunc((pts_ptr+j)^.x)+shift.x;
    y1    :=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=x1-rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0:=x0+rad;
        w0:=y0;
        v1:=x1+rad;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            bmp_dst_width,
            rct_clp,
            pt_ind);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    begin
      pt_ind:=start_ind+i+1;
      LineProc(0,1);
    end;
  pts_ptr :=pts_ptr1;
  if exp_ then
    begin
      pt_ind:=-(start_ind+1);
      LineProc(0,d_ind);
    end;
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    begin
      pt_ind:=start_ind+i+1;
      CircProc(i);
    end;
  pts_ptr :=pts_ptr1;
  if (end_ind-start_ind>0) then
    begin
      pt_ind:=end_ind+1;
      CircProc(d_ind);
    end;
end; {$endregion}
// Equidistant curve for not anti-aliased broken clipped line(width - 2 pixel):
procedure LineBCE2          (constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_clp:TPtRect; constref color_info:TColorInfo; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end;
        v0:=x0+rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end;
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info);
              end;
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info);
              end;
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end;
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info);
          end;
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            bmp_dst_width,
            rct_clp,
            color_info.pix_col);
    if (rad>1) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-1,
              bmp_dst_ptr,
              bmp_dst_width,
              rct_clp,
              color_info.pix_col);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (d_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE2          (constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_clp:TPtRect; constref val       :TColor    ; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
        v0:=x0+rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end;
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end;
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            bmp_dst_width,
            rct_clp,
            val);
    if (rad>1) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-1,
              bmp_dst_ptr,
              bmp_dst_width,
              rct_clp,
              val);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (d_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE2          (constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width:TColor; constref rct_clp:TPtRect; constref val       :byte      ; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
        v0:=x0+rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end;
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,val);
              end;
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,val);
          end;
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            bmp_dst_width,
            rct_clp,
            val);
    if (rad>1) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-1,
              bmp_dst_ptr,
              bmp_dst_width,
              rct_clp,
              val);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (d_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE2          (constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_clp:TPtRect;                                 constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  pts_ptr2   : PPtPosF;
  pts_ptr_str: PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  pt_ind     : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0-rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end;
        v0:=x0+rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end;
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
              end;
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            if (Abs(w1-w0)<Abs(v1-v0)) then
              begin
                w0+=1;
                w1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
              end
            else
              begin
                v0+=1;
                v1+=1;
                if LineHC(v0,w0,v1,rct_clp) then
                  // Line Drawing:
                  LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
              end;
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end;
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end;
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            bmp_dst_width,
            rct_clp,
            pt_ind);
    if (rad>1) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-1,
              bmp_dst_ptr,
              bmp_dst_width,
              rct_clp,
              pt_ind);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (d_ind>0) then
    CircProc(d_ind);
end; {$endregion}
// Equidistant curve for not anti-aliased broken clipped line(width - 3 pixel):
procedure LineBCE3          (constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_clp:TPtRect; constref color_info:TColorInfo; constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0+rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        v0+=1;
        v1+=1;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        v0-=2;
        v1-=2;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        v0:=x0-rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        v0+=1;
        v1+=1;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        v0-=2;
        v1-=2;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            w0+=1;
            w1+=1;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            w0-=2;
            w1-=2;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            w0+=1;
            w1+=1;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            w0-=2;
            w1-=2;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );

        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            w0-=2;
            w1-=2;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
          end;

        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            w0-=2;
            w1-=2;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
            v0-=2;
            v1-=2;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,color_info.pix_col);
          end;

      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            bmp_dst_width,
            rct_clp,
            color_info.pix_col);
    if (rad>1) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-1,
              bmp_dst_ptr,
              bmp_dst_width,
              rct_clp,
              color_info.pix_col);
    if (rad>2) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-2,
              bmp_dst_ptr,
              bmp_dst_width,
              rct_clp,
              color_info.pix_col);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    LineProc(0,1);
  pts_ptr :=pts_ptr1;
  if exp_ then
    LineProc(0,d_ind);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    CircProc(i);
  pts_ptr :=pts_ptr1;
  if (d_ind>0) then
    CircProc(d_ind);
end; {$endregion}
procedure LineBCE3          (constref pts:TPtPosFArr; constref start_ind,end_ind:TColor; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_clp:TPtRect;                                 constref shift:TPtPos; constref rad:TColor; exp_:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr    : PPtPosF;
  pts_ptr1   : PPtPosF;
  i,d_ind    : integer;
  x0,y0,x1,y1: integer;
  v0,w0,v1,w1: integer;
  l0,l1      : integer;
  pt_ind     : integer;
  k,d        : double;

  procedure LineProc(constref i,j:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    x0:=Trunc((pts_ptr+i)^.x)+shift.x;
    y0:=Trunc((pts_ptr+i)^.y)+shift.y;
    x1:=Trunc((pts_ptr+j)^.x)+shift.x;
    y1:=Trunc((pts_ptr+j)^.y)+shift.y;
    if (x1=x0) then
      begin
        v0:=x0+rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0+=1;
        v1+=1;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0-=2;
        v1-=2;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0:=x0-rad;
        w0:=y0;
        v1:=v0;
        w1:=y1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0+=1;
        v1+=1;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        v0-=2;
        v1-=2;
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
      end
    else
      begin
        if (y1=y0) then
          begin
            v0:=x0;
            w0:=y0+rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            w0+=1;
            w1+=1;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            w0-=2;
            w1-=2;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            v0:=x0;
            w0:=y0-rad;
            v1:=x1;
            // Line Clipping:
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            w0+=1;
            w1+=1;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            w0-=2;
            w1-=2;
            if LineHC(v0,w0,v1,rct_clp) then
              // Line Drawing:
              LineH(v0,w0,v1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            Inc(pts_ptr);
            Exit;
          end;
        k :=(y1-y0)/(x1-x0);
        d :=InvSqrt(1+k*k){1/sqrt(1+k*k)}; // only with garbage init. ON
        l0:=Trunc(rad*d*k);
        l1:=Trunc(rad*d  );
        v0:=x0-l0;
        w0:=y0+l1;
        v1:=x1-l0;
        w1:=y1+l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            w0-=2;
            w1-=2;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end;
        v0:=x0+l0;
        w0:=y0-l1;
        v1:=x1+l0;
        w1:=y1-l1;
        // Line Clipping:
        if LineC(v0,w0,v1,w1,rct_clp) then
          // Line Drawing:
          Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
        if (Abs(w1-w0)<Abs(v1-v0)) then
          begin
            w0+=1;
            w1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            w0-=2;
            w1-=2;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end
        else
          begin
            v0+=1;
            v1+=1;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
            v0-=2;
            v1-=2;
            if LineC(v0,w0,v1,w1,rct_clp) then
              // Line Drawing:
              Line(v0,w0,v1,w1,bmp_dst_ptr,bmp_dst_width,pt_ind);
          end;
      end;
    Inc(pts_ptr);
  end; {$endregion}

  procedure CircProc(constref i  :integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  {var
    a,x,n: integer;}
  begin
    {if rad<(n>>1)+2 then
      Exit;
    if Odd(n) then
      a:=1
    else
      a:=0;
    for x:=-(n>>1) to (n>>1)-a do
      CircleC
      (
        Trunc((pts_ptr+i)^.x)+shift.x,
        Trunc((pts_ptr+i)^.y)+shift.y,
        rad+x,
        bmp_dst_ptr,
        rct_clp,
        bmp_dst_width,
        pt_ind
      );}
    CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
            Trunc((pts_ptr+i)^.y)+shift.y,
            rad,
            bmp_dst_ptr,
            bmp_dst_width,
            rct_clp,
            pt_ind);
    if (rad>1) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-1,
              bmp_dst_ptr,
              bmp_dst_width,
              rct_clp,
              pt_ind);
    if (rad>2) then
      CircleC(Trunc((pts_ptr+i)^.x)+shift.x,
              Trunc((pts_ptr+i)^.y)+shift.y,
              rad-2,
              bmp_dst_ptr,
              bmp_dst_width,
              rct_clp,
              pt_ind);
  end; {$endregion}

begin
  d_ind:=end_ind-start_ind;
  if (d_ind<=0) then
    Exit;
  pts_ptr1:=Unaligned(@pts[start_ind]);
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    begin
      pt_ind:=start_ind+i+1;
      LineProc(0,1);
    end;
  pts_ptr :=pts_ptr1;
  if exp_ then
    begin
      pt_ind:=-(start_ind+1);
      LineProc(0,d_ind);
    end;
  pts_ptr :=pts_ptr1;
  for i:=0 to d_ind-1 do
    begin
      pt_ind:=start_ind+i+1;
      CircProc(i);
    end;
  pts_ptr :=pts_ptr1;
  if (end_ind-start_ind>0) then
    begin
      pt_ind:=end_ind+1;
      CircProc(d_ind);
    end;
end; {$endregion}
// Monochrome resilient line(width - 1 pixel):
procedure LineR0            (constref x0,y0,x1,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; const rct_clp:TPtRect; constref color_info:TColorInfo; constref seg_cnt   :TColor);          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,dx,dy: double;
  i        : integer;
begin
  if (seg_cnt<=1) then
    Exit;
  x :=x0;
  y :=y0;
  {dx:=Abs(x1-x0)/seg_cnt;
  dy:=Abs(y1-y0)/seg_cnt;}

  if (x1>x0) then
    begin
      dx:=(x1-x0)/seg_cnt;
      if  (y1>y0) then
        begin
          dy:=(y1-y0)/seg_cnt;
          for i:=0 to seg_cnt-2 do
            begin
              x+=dx;
              y+=dy;
              Point(Trunc(x),
                    Trunc(y),
                    bmp_dst_ptr,
                    bmp_dst_width,
                    rct_clp,
                    color_info);
            end;
        end
      else
        begin
          dy:=(y0-y1)/seg_cnt;
          for i:=0 to seg_cnt-2 do
            begin
              x+=dx;
              y-=dy;
              Point(Trunc(x),
                    Trunc(y),
                    bmp_dst_ptr,
                    bmp_dst_width,
                    rct_clp,
                    color_info);
            end;
        end;
    end
  else
    begin
      dx:=(x0-x1)/seg_cnt;
      if  (y1>y0) then
        begin
          dy:=(y1-y0)/seg_cnt;
          for i:=0 to seg_cnt-2 do
            begin
              x-=dx;
              y+=dy;
              Point(Trunc(x),
                    Trunc(y),
                    bmp_dst_ptr,
                    bmp_dst_width,
                    rct_clp,
                    color_info);
            end;
        end
      else
        begin
          dy:=(y0-y1)/seg_cnt;
          for i:=0 to seg_cnt-2 do
            begin
              x-=dx;
              y-=dy;
              Point(Trunc(x),
                    Trunc(y),
                    bmp_dst_ptr,
                    bmp_dst_width,
                    rct_clp,
                    color_info);
            end;
        end;
    end;
  {if (x1>x0) then
    begin
      if (y1>y0) then
        for i:=1 to seg_cnt-1 do
          Point(Trunc(x0+dx*i),
                Trunc(y0+dy*i),
                bmp_dst_ptr,
                bmp_dst_width,
                color_info)
      else
        for i:=1 to seg_cnt-1 do
          Point(Trunc(x0+dx*i),
                Trunc(y0-dy*i),
                bmp_dst_ptr,
                bmp_dst_width,
                color_info);
    end
  else
    begin
      if (y1>y0) then
        for i:=1 to seg_cnt-1 do
          Point(Trunc(x0-dx*i),
                Trunc(y0+dy*i),
                bmp_dst_ptr,
                bmp_dst_width,
                color_info)
      else
        for i:=1 to seg_cnt-1 do
          Point(Trunc(x0-dx*i),
                Trunc(y0-dy*i),
                bmp_dst_ptr,
                bmp_dst_width,
                color_info);
    end;}
  {if (x1>x0) then
    begin
      if (y1>y0) then
        for i:=0 to seg_cnt-2 do
          begin
            x+=dx;
            y+=dy;
            Point(Trunc(x),
                  Trunc(y),
                  bmp_dst_ptr,
                  bmp_dst_width,
                  color_info);
          end
      else
        for i:=0 to seg_cnt-2 do
          begin
            x+=dx;
            y-=dy;
            Point(Trunc(x),
                  Trunc(y),
                  bmp_dst_ptr,
                  bmp_dst_width,
                  color_info);
          end;
    end
  else
    begin
      if (y1>y0) then
        for i:=0 to seg_cnt-2 do
          begin
            x-=dx;
            y+=dy;
            Point(Trunc(x),
                  Trunc(y),
                  bmp_dst_ptr,
                  bmp_dst_width,
                  color_info);
          end
      else
        for i:=0 to seg_cnt-2 do
          begin
            x-=dx;
            y-=dy;
            Point(Trunc(x),
                  Trunc(y),
                  bmp_dst_ptr,
                  bmp_dst_width,
                  color_info);
          end;
    end;}
end; {$endregion}
function  LineR1            (constref x0,y0,x1,y1:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; const rct_clp:TPtRect; constref color_info:TColorInfo; constref seg_length:TColor): TPtPosF; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,dx,dy,k,line_length_sqr: double;
  i,seg_cnt                  : integer;
begin
  {line_length_sqr:=PtDistSqr(x0,y0,x1,y1);
  seg_cnt        :=Trunc(sqrt(line_length_sqr)/seg_length);
  if (seg_cnt<=1) then
    Exit;
      x:=x0;
      y:=y0;
  k:=(y1-y0)/                                     // angle=Arctan(k)=Arccos(dx/dy);
     (x1-x0);                                     // cos(arctan(k))=dx/dy;
  dx:=sqrt(sqr(seg_length)/(1+cos(arctan(k))));   // sqr(dx)=sqr(dy)*cos(arctan(k))=(sqr(seg_length)-sqr(dx))*cos(arctan(k));
  dy:=sqrt(line_length_sqr-sqr(dx));              // sqr(dx)=sqr(seg_length)/(1+cos(arctan(k)));
  Result.x:=dx;
  Result.y:=dy;}
  {if (x1>x0) then
    begin
      if (y1>y0) then
        for i:=0 to 0{seg_cnt-1} do
          begin
            x+=dx;
            y+=dy;
            Point(Trunc(x),
                  Trunc(y),
                  bmp_dst_ptr,
                  bmp_dst_width,
                  color_info);
          end
      else
        for i:=0 to 0{seg_cnt-1} do
          begin
            x+=dx;
            y-=dy;
            Point(Trunc(x),
                  Trunc(y),
                  bmp_dst_ptr,
                  bmp_dst_width,
                  color_info);
          end;
    end
  else
    begin
      if (y1>y0) then
        for i:=0 to 0{seg_cnt-1} do
          begin
            x-=dx;
            y+=dy;
            Point(Trunc(x),
                  Trunc(y),
                  bmp_dst_ptr,
                  bmp_dst_width,
                  color_info);
          end
      else
        for i:=0 to 0{seg_cnt-1} do
          begin
            x-=dx;
            y-=dy;
            Point(Trunc(x),
                  Trunc(y),
                  bmp_dst_ptr,
                  bmp_dst_width,
                  color_info);
          end;
    end;}
end; {$endregion}
// Line grid(width - 1 pixel):
procedure Grid              (const x,y:integer; const bmp_dst_ptr:PInteger; const bmp_dst_width:TColor; const rct_clp:TPtRect; const color_info:TColorInfo; const arr_cell_width,arr_cell_height,cnt_x,cnt_y:TColor); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to cnt_y do
    LineAC(x,
           y+arr_cell_height*i,
           x+arr_cell_width *cnt_x,
           y+arr_cell_height*i,
           bmp_dst_ptr,
           bmp_dst_width,
           rct_clp,
           color_info);
  for i:=0 to cnt_x do
    LineAC(x+arr_cell_width *i,
           y,
           x+arr_cell_width *i,
           y+arr_cell_height*cnt_y,
           bmp_dst_ptr,
           bmp_dst_width,
           rct_clp,
           color_info);
end; {$endregion}
// Point:
procedure Point             (const x,y:integer; const bmp_dst_ptr:PInteger; const bmp_dst_width:TColor;                        const color_info:TColorInfo);                                 inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pixel_ptr: PInteger;
begin
  with color_info do
    begin
      {$ifndef win64}
      AlphaBlend128P0(MSK7_128,(bmp_dst_ptr+(x-1)+bmp_dst_width*(y-1))^, pix_col,alpha1,alpha2,bmp_dst_width);
                               (bmp_dst_ptr+(x-0)+bmp_dst_width*(y-0))^:=pix_col;
      {$else}
      {pixel_ptr:=bmp_dst_ptr+(x-1)+bmp_dst_width*(y-1);
      pixel_ptr^:=                                     Highlight2((pixel_ptr-1*bmp_dst_width)^,10);

      Inc(pixel_ptr);
      pixel_ptr^:=                                     Highlight2((pixel_ptr-1*bmp_dst_width)^,20);

      Inc(pixel_ptr);
      pixel_ptr^:=                                     Highlight2((pixel_ptr-1*bmp_dst_width)^,10);

      Inc(pixel_ptr,bmp_dst_width-2);
      pixel_ptr^:=                                     Highlight2((pixel_ptr-3*bmp_dst_width)^,05);

      Inc(pixel_ptr);
      pixel_ptr^:=                                     Highlight2((pixel_ptr-3*bmp_dst_width)^,10);

      Inc(pixel_ptr);
      pixel_ptr^:=                                     Highlight2((pixel_ptr-3*bmp_dst_width)^,05);

      Inc(pixel_ptr,bmp_dst_width-2);
      pixel_ptr^:=                                     Darken2   ((pixel_ptr-5*bmp_dst_width)^,05);

      Inc(pixel_ptr);
      pixel_ptr^:=                                     Darken2   ((pixel_ptr-5*bmp_dst_width)^,10);

      Inc(pixel_ptr);
      pixel_ptr^:=                                     Darken2   ((pixel_ptr-5*bmp_dst_width)^,05);}

      pixel_ptr:=bmp_dst_ptr+(x-1)+bmp_dst_width*(y-1);
      AlphaBlend1(pixel_ptr,pix_col,alpha1);                    //TRGBA(pixel_ptr^).a:=alpha1;//$FF;
      Inc(pixel_ptr);                                           //                            //
      AlphaBlend1(pixel_ptr,pix_col,{PByte(@alpha1+9)^}alpha2); //TRGBA(pixel_ptr^).a:=alpha2;//$FF;
      Inc(pixel_ptr);                                           //                            //
      AlphaBlend1(pixel_ptr,pix_col,alpha1);                    //TRGBA(pixel_ptr^).a:=alpha1;//$FF;
      Inc(pixel_ptr,bmp_dst_width-2);                           //                            //
      AlphaBlend1(pixel_ptr,pix_col,{PByte(@alpha1+9)^}alpha2); //TRGBA(pixel_ptr^).a:=alpha2;//$FF;
      Inc(pixel_ptr);                                           //                            //
      pixel_ptr^:=pix_col;                                      //TRGBA(pixel_ptr^).a:=$FF;   //$FF;
      Inc(pixel_ptr);                                           //                            //
      AlphaBlend1(pixel_ptr,pix_col,{PByte(@alpha1+9)^}alpha2); //TRGBA(pixel_ptr^).a:=alpha2;//$FF;
      Inc(pixel_ptr,bmp_dst_width-2);                           //                            //
      AlphaBlend1(pixel_ptr,pix_col,alpha1);                    //TRGBA(pixel_ptr^).a:=alpha1;//$FF;
      Inc(pixel_ptr);                                           //                            //
      AlphaBlend1(pixel_ptr,pix_col,{PByte(@alpha1+9)^}alpha2); //TRGBA(pixel_ptr^).a:=alpha2;//$FF;
      Inc(pixel_ptr);                                           //                            //
      AlphaBlend1(pixel_ptr,pix_col,alpha1);                    //TRGBA(pixel_ptr^).a:=alpha1;//$FF;
      {$endif}
    end;
end; {$endregion}
procedure Point             (const x,y:integer; const bmp_dst_ptr:PInteger; const bmp_dst_width:TColor; const rct_clp:TPtRect; const color_info:TColorInfo);                                 inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pixel_ptr: PInteger;
begin
  with rct_clp do
    {begin
      if (x<left) then
        Exit;
      if (x>right-2) then
        Exit;
      if (y<top) then
        Exit;
      if (y>bottom-2) then
        Exit;
    end;}
    if (x-1>left  ) and
       (x+1<right ) and
       (y-1>top   ) and
       (y+1<bottom) then
  Point(x,y,bmp_dst_ptr,bmp_dst_width,color_info);
end; {$endregion}
procedure Point             (const x,y:integer; const bmp_dst_ptr:PInteger; const bmp_dst_width:TColor; const rct_clp:TPtRect; const color_info:TColorInfo; const alpha_fade:byte);          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pixel_ptr: PInteger;
begin
  with rct_clp,color_info do
    if (x-1>left  ) and
       (x+1<right ) and
       (y-1>top   ) and
       (y+1<bottom) then
      begin
        pixel_ptr:=bmp_dst_ptr+(x-1)+bmp_dst_width*(y-1);
        AlphaBlendDec1(pixel_ptr,pix_col,alpha2 ,alpha_fade);
        Inc(pixel_ptr);
        AlphaBlendDec1(pixel_ptr,pix_col,alpha1 ,alpha_fade);
        Inc(pixel_ptr);
        AlphaBlendDec1(pixel_ptr,pix_col,alpha2 ,alpha_fade);
        Inc(pixel_ptr,bmp_dst_width-2);
        AlphaBlendDec1(pixel_ptr,pix_col,alpha1 ,alpha_fade);
        Inc(pixel_ptr);
        AlphaBlendDec1(pixel_ptr,pix_col,MAXBYTE,alpha_fade);
        Inc(pixel_ptr);
        AlphaBlendDec1(pixel_ptr,pix_col,alpha1 ,alpha_fade);
        Inc(pixel_ptr,bmp_dst_width-2);
        AlphaBlendDec1(pixel_ptr,pix_col,alpha2 ,alpha_fade);
        Inc(pixel_ptr);
        AlphaBlendDec1(pixel_ptr,pix_col,alpha1 ,alpha_fade);
        Inc(pixel_ptr);
        AlphaBlendDec1(pixel_ptr,pix_col,alpha2 ,alpha_fade);
    end;
end; {$endregion}
function  PointCollDraw     (const x,y:integer;                             const bmp_src_width:TColor; const rct_clp:TPtRect; var   bmp_src:T1Byte1Arr                          ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  Result:=False;
  with rct_clp do
    if (x>left  ) and
       (x<right ) and
       (y>top   ) and
       (y<bottom) then
      begin
        if (bmp_src[x+bmp_src_width*y]=0) then
          begin
            Result:=False;
            bmp_src[x+bmp_src_width*y]:=1;
          end
        else
          Result:=True;
      end;
end; {$endregion}
function  PointCollDraw     (const x,y:integer;                             const bmp_src_width:TColor; const rct_clp:TPtRect; const bmp_src:T1Byte1Arr;    const b:byte         ): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct_clp do
    if (x>left  ) and
       (x<right ) and
       (y>top   ) and
       (y<bottom) then
      Result:=(bmp_src[x+bmp_src_width*y]<>0);
end; {$endregion}
// Rectangle:
procedure SetRctDupId       (var sln_prop_var:TCurveProp); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      dup_pts_id.arr[0]:=pts_rct_tns_left  ;
      dup_pts_id.arr[1]:=pts_rct_tns_top   ;
      dup_pts_id.arr[2]:=pts_rct_tns_right ;
      dup_pts_id.arr[3]:=pts_rct_tns_bottom;
      dup_pts_id.arr[4]:=pts_rct_inn_width ;
      dup_pts_id.arr[5]:=pts_rct_inn_height;
    end;
end; {$endregion}
procedure SetEdsWidth       (var sln_prop_var:TCurveProp); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      eds_width_half:=Trunc(eds_width/2);
      if Odd(eds_width) then
        eds_width_odd:=0
      else
        eds_width_odd:=1;
    end;
end; {$endregion}
procedure SetRctWidth       (var sln_prop_var:TCurveProp); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      pts_rct_width      :=pts_rct_tns_left +
                           pts_rct_tns_right+
                           pts_rct_inn_width;
      pts_rct_width__half:=pts_rct_width>>1;
      pts_rct_width__odd :=Byte(not Odd(pts_rct_width));
      pts_width:=pts_rct_width;
    end;
end; {$endregion}
procedure SetRctHeight      (var sln_prop_var:TCurveProp); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      pts_rct_height     :=pts_rct_tns_top   +
                           pts_rct_tns_bottom+
                           pts_rct_inn_height;
      pts_rct_height_half:=pts_rct_height>>1;
      pts_rct_height_odd :=Byte(not Odd(pts_rct_height));
      pts_height         :=pts_rct_height;
    end;
end; {$endregion}
procedure SetRctValues      (var sln_prop_var:TCurveProp); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      rct_val_arr[0]:=-(pts_rct_inn_width >>1)-pts_rct_tns_left+pts_rct_width__odd;
      rct_val_arr[1]:=-(pts_rct_inn_height>>1)-pts_rct_tns_top +pts_rct_height_odd;
      rct_val_arr[2]:=+(pts_rct_inn_height>>1)+1;
      rct_val_arr[3]:=-(pts_rct_inn_height>>1)                 +pts_rct_height_odd;
      rct_val_arr[4]:=+(pts_rct_inn_width >>1)+1;
    end;
end; {$endregion}
procedure Rectangle         (constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width,bmp_dst_height:TColor; constref rct_dst:TPtRect; constref sln_prop_var:TCurveProp                                   ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      // rct_top:
      PPFloodFill(bmp_dst_ptr,
                  bmp_dst_width,
                  ClippedRct(rct_dst,
                             PtBounds(x+rct_val_arr[0],
                                      y+rct_val_arr[1],
                                      pts_rct_width,
                                      pts_rct_tns_top)),
                  pts_col_inv);
      // rct_bottom:
      PPFloodFill(bmp_dst_ptr,
                  bmp_dst_width,
                  ClippedRct(rct_dst,
                             PtBounds(x+rct_val_arr[0],
                                      y+rct_val_arr[2],
                                      pts_rct_width,
                                      pts_rct_tns_bottom)),
                  pts_col_inv);
      // rct_left:
      PPFloodFill(bmp_dst_ptr,
                  bmp_dst_width,
                  ClippedRct(rct_dst,
                             PtBounds(x+rct_val_arr[0],
                                      y+rct_val_arr[3],
                                      pts_rct_tns_left,
                                      pts_rct_inn_height)),
                  pts_col_inv);
      // rct_right:
      PPFloodFill(bmp_dst_ptr,
                  bmp_dst_width,
                  ClippedRct(rct_dst,
                             PtBounds(x+rct_val_arr[4],
                                      y+rct_val_arr[3],
                                      pts_rct_tns_right,
                                      pts_rct_inn_height)),
                  pts_col_inv);
    end;
end; {$endregion}
procedure Rectangle         (constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width,bmp_dst_height:TColor; constref rct_dst:TPtRect; constref sln_prop_var:TCurveProp; constref PPFloodFillProc:TProc4  ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      // rct_top:
      PPFloodFillProc(bmp_dst_ptr,
                      bmp_dst_width,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[0],
                                          y+rct_val_arr[1],
                                          pts_rct_width,
                                          pts_rct_tns_top)));
      // rct_bottom:
      PPFloodFillProc(bmp_dst_ptr,
                      bmp_dst_width,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[0],
                                          y+rct_val_arr[2],
                                          pts_rct_width,
                                          pts_rct_tns_bottom)));
      // rct_left:
      PPFloodFillProc(bmp_dst_ptr,
                      bmp_dst_width,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[0],
                                          y+rct_val_arr[3],
                                          pts_rct_tns_left,
                                          pts_rct_inn_height)));
      // rct_right:
      PPFloodFillProc(bmp_dst_ptr,
                      bmp_dst_width,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[4],
                                          y+rct_val_arr[3],
                                          pts_rct_tns_right,
                                          pts_rct_inn_height)));
    end;
end; {$endregion}
procedure Rectangle         (constref x,y:integer; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width,bmp_dst_height:TColor; constref rct_dst:TPtRect; constref sln_prop_var:TCurveProp; constref PPFloodFillProc:TProc4_1); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_prop_var do
    begin
      // rct_top:
      PPFloodFillProc(bmp_dst_ptr,
                      bmp_dst_width,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[0],
                                          y+rct_val_arr[1],
                                          pts_rct_width,
                                          pts_rct_tns_top)));
      // rct_bottom:
      PPFloodFillProc(bmp_dst_ptr,
                      bmp_dst_width,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[0],
                                          y+rct_val_arr[2],
                                          pts_rct_width,
                                          pts_rct_tns_bottom)));
      // rct_left:
      PPFloodFillProc(bmp_dst_ptr,
                      bmp_dst_width,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[0],
                                          y+rct_val_arr[3],
                                          pts_rct_tns_left,
                                          pts_rct_inn_height)));
      // rct_right:
      PPFloodFillProc(bmp_dst_ptr,
                      bmp_dst_width,
                      ClippedRct(rct_dst,
                                 PtBounds(x+rct_val_arr[4],
                                          y+rct_val_arr[3],
                                          pts_rct_tns_right,
                                          pts_rct_inn_height)));
    end;
end; {$endregion}
procedure Rectangle         (                      constref bmp_dst_ptr:PInteger; constref bmp_dst_width,bmp_dst_height:TColor; constref rct_dst:TPtRect; constref col:TColor                                                ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_prop: TCurveProp;
begin
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  with rct_prop do
    begin
      pts_col           :=col;
      pts_col_inv       :=SetColorInv(col);
      pts_rct_tns_left  :=1;
      pts_rct_tns_top   :=1;
      pts_rct_tns_right :=1;
      pts_rct_tns_bottom:=1;
      pts_rct_inn_width :=rct_dst.width ;
      pts_rct_inn_height:=rct_dst.height;
      SetRctWidth (rct_prop);
      SetRctHeight(rct_prop);
      SetRctValues(rct_prop);
      Rectangle
      (
        rct_dst.left+rct_dst.width >>1-pts_rct_width__odd,
        rct_dst.top +rct_dst.height>>1-pts_rct_height_odd,
        bmp_dst_ptr,
        bmp_dst_width,
        bmp_dst_height,
        PtBounds
        (
          rct_dst.left  -1,
          rct_dst.top   -1,
          rct_dst.right +1,
          rct_dst.bottom+1
        ),
        rct_prop
      );
    end;
end; {$endregion}
procedure Rectangle         (x0,y0,x1,y1 :integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width               :TColor; constref rct_dst:TPtRect; constref col:TColor                                                ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x0_clp,y0_clp,x1_clp,y1_clp:integer;
begin
  x0_clp:=x0;
  y0_clp:=y0;
  x1_clp:=x1;
  if LineHC(x0_clp,y0_clp,x1_clp,rct_dst) then
     LineH (x0_clp,y0_clp,x1_clp,bmp_dst_ptr,bmp_dst_width,col);
  x0_clp:=x0;
  y1_clp:=y1;
  x1_clp:=x1;
  if LineHC(x0_clp,y1_clp,x1_clp,rct_dst) then
     LineH (x0_clp,y1_clp,x1_clp,bmp_dst_ptr,bmp_dst_width,col);
  x0_clp:=x0;
  y0_clp:=y0;
  y1_clp:=y1;
  if LineVC(x0_clp,y0_clp,y1_clp,rct_dst) then
     LineV (x0_clp,y0_clp,y1_clp,bmp_dst_ptr,bmp_dst_width,col);
  x1_clp:=x1;
  y0_clp:=y0;
  y1_clp:=y1;
  if LineVC(x1_clp,y0_clp,y1_clp,rct_dst) then
     LineV (x1_clp,y0_clp,y1_clp,bmp_dst_ptr,bmp_dst_width,col);
end; {$endregion}
// Rhombus:
procedure Rombus            (constref x,y:integer;       constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor;                           constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {TODO}
end; {$endregion}
// Circle drawing(midpoint algorithm):
procedure Circle            (constref x0,y0,rad:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor;                           constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p   : PInteger;
  x,x1: integer;
  y,y1: integer;
  err : integer;
begin
  p   :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x   :=rad;
  y   :=0;
  err :=0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      (p+y-x1)^:=color_info.pix_col;
      (p+x-y1)^:=color_info.pix_col;
      (p+x+y1)^:=color_info.pix_col;
      (p+y+x1)^:=color_info.pix_col;
      (p-y+x1)^:=color_info.pix_col;
      (p-x+y1)^:=color_info.pix_col;
      (p-x-y1)^:=color_info.pix_col;
      (p-y-x1)^:=color_info.pix_col;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure Circle            (constref x0,y0,rad:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor;                           constref val       :TColor    ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p   : PInteger;
  x,x1: integer;
  y,y1: integer;
  err : integer;
begin
  p   :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x   :=rad;
  y   :=0;
  err :=0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      (p+y-x1)^:=val;
      (p+x-y1)^:=val;
      (p+x+y1)^:=val;
      (p+y+x1)^:=val;
      (p-y+x1)^:=val;
      (p-x+y1)^:=val;
      (p-x-y1)^:=val;
      (p-y-x1)^:=val;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure Circle            (constref x0,y0,rad:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor                                                          ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p   : PByte;
  x,x1: integer;
  y,y1: integer;
  err : integer;
begin
  p   :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x   :=rad;
  y   :=0;
  err :=0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      (p+y-x1)^+=1;
      (p+x-y1)^+=1;
      (p+x+y1)^+=1;
      (p+y+x1)^+=1;
      (p-y+x1)^+=1;
      (p-x+y1)^+=1;
      (p-x-y1)^+=1;
      (p-y-x1)^+=1;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure Circle            (constref x0,y0,rad:integer; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width:TColor;                           constref val       :byte      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p   : PByte;
  x,x1: integer;
  y,y1: integer;
  err : integer;
begin
  p   :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x   :=rad;
  y   :=0;
  err :=0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      (p+y-x1)^:=val;
      (p+x-y1)^:=val;
      (p+x+y1)^:=val;
      (p+y+x1)^:=val;
      (p-y+x1)^:=val;
      (p-x+y1)^:=val;
      (p-x-y1)^:=val;
      (p-y-x1)^:=val;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure Circle            (constref x0,y0,rad:integer; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width:TColor                                                          ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p   : PByte;
  x,x1: integer;
  y,y1: integer;
  err : integer;
begin
  p   :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x   :=rad;
  y   :=0;
  err :=0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      (p+y-x1)^+=1;
      (p+x-y1)^+=1;
      (p+x+y1)^+=1;
      (p+y+x1)^+=1;
      (p-y+x1)^+=1;
      (p-x+y1)^+=1;
      (p-x-y1)^+=1;
      (p-y-x1)^+=1;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure CircleC           (constref x0,y0,rad:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_clp:TPtRect; constref color_info:TColorInfo); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p          : PInteger;
  x,x1       : integer;
  y,y1       : integer;
  err        : integer;
  c0,c1,c2,c3: integer;
begin
  p  :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x  :=rad;
  y  :=0;
  err:=0;
  c0 := rct_clp.left  -x0;
  c1 := rct_clp.right -x0;
  c2 :=-rct_clp.top   +y0;
  c3 :=-rct_clp.bottom+y0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      if (y>=+c0) and (y<+c1) then
        begin
          if (x<=+c2) and (x>+c3) then
             (p+y-x1)^:=color_info.pix_col; //(x0+y)+(y0-x)*arr_dst_width
          if (x>=-c2) and (x<-c3) then
             (p+y+x1)^:=color_info.pix_col; //(x0+y)+(y0+x)*arr_dst_width
        end;
      if (x>=+c0) and (x<+c1) then
        begin
          if (y<=+c2) and (y>+c3) then
             (p+x-y1)^:=color_info.pix_col; //(x0+x)+(y0-y)*arr_dst_width
          if (y>=-c2) and (y<-c3) then
             (p+x+y1)^:=color_info.pix_col; //(x0+x)+(y0+y)*arr_dst_width
        end;
      if (y<=-c0) and (y>-c1) then
        begin
          if (x>=-c2) and (x<-c3) then
             (p-y+x1)^:=color_info.pix_col; //(x0-y)+(y0+x)*arr_dst_width
          if (x<=+c2) and (x>+c3) then
             (p-y-x1)^:=color_info.pix_col; //(x0-y)+(y0-x)*arr_dst_width
        end;
      if (x<=-c0) and (x>-c1) then
        begin
          if (y>=-c2) and (y<-c3) then
             (p-x+y1)^:=color_info.pix_col; //(x0-x)+(y0+y)*arr_dst_width
          if (y<=+c2) and (y>+c3) then
             (p-x-y1)^:=color_info.pix_col; //(x0-x)+(y0-y)*arr_dst_width
        end;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure CircleC           (constref x0,y0,rad:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_clp:TPtRect; constref val       :TColor    ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  p          : PInteger;
  rad2       : integer;
  f          : integer;
  d_x        : integer;
  d_y        : integer;
  x,x1       : integer;
  y,y1       : integer;
  c0,c1,c2,c3: integer;
begin
  p   :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  rad2:=rad-1;
  f   := 1-rad2;
  d_x := 0;
  d_y :=-(rad2<<1);
  x   :=0;
  y   :=rad2;
  c0  := rct_clp.left  -x0;
  c1  := rct_clp.right -x0;
  c2  :=-rct_clp.top   +y0;
  c3  :=-rct_clp.bottom+y0;
  (p+rad2*bmp_dst_width)^:=val;
  (p-rad2*bmp_dst_width)^:=val;
  (p+rad2              )^:=val;
  (p-rad2              )^:=val;
  while (x<y) do
    begin
      if (f>=0) then
        begin
          Dec(y);
          d_y+=2;
          f  +=d_y;
        end;
      Inc(x);
      d_x+=2;
      f  +=d_x+1;
      x1 :=x*bmp_dst_width;
      y1 :=y*bmp_dst_width;
      (p+x+y1)^:=val;
      (p-x+y1)^:=val;
      (p+x-y1)^:=val;
      (p-x-y1)^:=val;
      (p+y+x1)^:=val;
      (p-y+x1)^:=val;
      (p+y-x1)^:=val;
      (p-y-x1)^:=val;
    end;}
var
  p          : PInteger;
  x,x1       : integer;
  y,y1       : integer;
  err        : integer;
  c0,c1,c2,c3: integer;
begin
  p  :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x  :=rad;
  y  :=0;
  err:=0;
  c0 := rct_clp.left  -x0;
  c1 := rct_clp.right -x0;
  c2 :=-rct_clp.top   +y0;
  c3 :=-rct_clp.bottom+y0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      if (y>=+c0) and (y<+c1) then
        begin
          if (x<=+c2) and (x>+c3) then
             (p+y-x1)^:=val; //(x0+y)+(y0-x)*arr_dst_width
          if (x>=-c2) and (x<-c3) then
             (p+y+x1)^:=val; //(x0+y)+(y0+x)*arr_dst_width
        end;
      if (x>=+c0) and (x<+c1) then
        begin
          if (y<=+c2) and (y>+c3) then
             (p+x-y1)^:=val; //(x0+x)+(y0-y)*arr_dst_width
          if (y>=-c2) and (y<-c3) then
             (p+x+y1)^:=val; //(x0+x)+(y0+y)*arr_dst_width
        end;
      if (y<=-c0) and (y>-c1) then
        begin
          if (x>=-c2) and (x<-c3) then
             (p-y+x1)^:=val; //(x0-y)+(y0+x)*arr_dst_width
          if (x<=+c2) and (x>+c3) then
             (p-y-x1)^:=val; //(x0-y)+(y0-x)*arr_dst_width
        end;
      if (x<=-c0) and (x>-c1) then
        begin
          if (y>=-c2) and (y<-c3) then
             (p-x+y1)^:=val; //(x0-x)+(y0+y)*arr_dst_width
          if (y<=+c2) and (y>+c3) then
             (p-x-y1)^:=val; //(x0-x)+(y0-y)*arr_dst_width
        end;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure CircleC           (constref x0,y0,rad:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_clp:TPtRect                                ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p          : PInteger;
  x,x1       : integer;
  y,y1       : integer;
  err        : integer;
  c0,c1,c2,c3: integer;
begin
  p  :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x  :=rad;
  y  :=0;
  err:=0;
  c0 := rct_clp.left  -x0;
  c1 := rct_clp.right -x0;
  c2 :=-rct_clp.top   +y0;
  c3 :=-rct_clp.bottom+y0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      if (y>=+c0) and (y<+c1) then
        begin
          if (x<=+c2) and (x>+c3) then
             (p+y-x1)^+=1; //(x0+y)+(y0-x)*arr_dst_width
          if (x>=-c2) and (x<-c3) then
             (p+y+x1)^+=1; //(x0+y)+(y0+x)*arr_dst_width
        end;
      if (x>=+c0) and (x<+c1) then
        begin
          if (y<=+c2) and (y>+c3) then
             (p+x-y1)^+=1; //(x0+x)+(y0-y)*arr_dst_width
          if (y>=-c2) and (y<-c3) then
             (p+x+y1)^+=1; //(x0+x)+(y0+y)*arr_dst_width
        end;
      if (y<=-c0) and (y>-c1) then
        begin
          if (x>=-c2) and (x<-c3) then
             (p-y+x1)^+=1; //(x0-y)+(y0+x)*arr_dst_width
          if (x<=+c2) and (x>+c3) then
             (p-y-x1)^+=1; //(x0-y)+(y0-x)*arr_dst_width
        end;
      if (x<=-c0) and (x>-c1) then
        begin
          if (y>=-c2) and (y<-c3) then
             (p-x+y1)^+=1; //(x0-x)+(y0+y)*arr_dst_width
          if (y<=+c2) and (y>+c3) then
             (p-x-y1)^+=1; //(x0-x)+(y0-y)*arr_dst_width
        end;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure CircleC           (constref x0,y0,rad:integer; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width:TColor; constref rct_clp:TPtRect; constref val       :byte      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p          : PByte;
  x,x1       : integer;
  y,y1       : integer;
  err        : integer;
  c0,c1,c2,c3: integer;
begin
  p  :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x  :=rad;
  y  :=0;
  err:=0;
  c0 := rct_clp.left  -x0;
  c1 := rct_clp.right -x0;
  c2 :=-rct_clp.top   +y0;
  c3 :=-rct_clp.bottom+y0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      if (y>=+c0) and (y<+c1) then
        begin
          if (x<=+c2) and (x>+c3) then
             (p+y-x1)^:=val; //(x0+y)+(y0-x)*arr_dst_width
          if (x>=-c2) and (x<-c3) then
             (p+y+x1)^:=val; //(x0+y)+(y0+x)*arr_dst_width
        end;
      if (x>=+c0) and (x<+c1) then
        begin
          if (y<=+c2) and (y>+c3) then
             (p+x-y1)^:=val; //(x0+x)+(y0-y)*arr_dst_width
          if (y>=-c2) and (y<-c3) then
             (p+x+y1)^:=val; //(x0+x)+(y0+y)*arr_dst_width
        end;
      if (y<=-c0) and (y>-c1) then
        begin
          if (x>=-c2) and (x<-c3) then
             (p-y+x1)^:=val; //(x0-y)+(y0+x)*arr_dst_width
          if (x<=+c2) and (x>+c3) then
             (p-y-x1)^:=val; //(x0-y)+(y0-x)*arr_dst_width
        end;
      if (x<=-c0) and (x>-c1) then
        begin
          if (y>=-c2) and (y<-c3) then
             (p-x+y1)^:=val; //(x0-x)+(y0+y)*arr_dst_width
          if (y<=+c2) and (y>+c3) then
             (p-x-y1)^:=val; //(x0-x)+(y0-y)*arr_dst_width
        end;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
procedure CircleC           (constref x0,y0,rad:integer; constref bmp_dst_ptr:PByte   ; constref bmp_dst_width:TColor; constref rct_clp:TPtRect                                ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p          : PByte;
  x,x1       : integer;
  y,y1       : integer;
  err        : integer;
  c0,c1,c2,c3: integer;
begin
  p  :=@bmp_dst_ptr[x0+y0*bmp_dst_width];
  x  :=rad;
  y  :=0;
  err:=0;
  c0 := rct_clp.left  -x0;
  c1 := rct_clp.right -x0;
  c2 :=-rct_clp.top   +y0;
  c3 :=-rct_clp.bottom+y0;
  while (x>=y) do
    begin
      x1:=x*bmp_dst_width;
      y1:=y*bmp_dst_width;
      if (y>=+c0) and (y<+c1) then
        begin
          if (x<=+c2) and (x>+c3) then
             (p+y-x1)^+=1; //(x0+y)+(y0-x)*arr_dst_width
          if (x>=-c2) and (x<-c3) then
             (p+y+x1)^+=1; //(x0+y)+(y0+x)*arr_dst_width
        end;
      if (x>=+c0) and (x<+c1) then
        begin
          if (y<=+c2) and (y>+c3) then
             (p+x-y1)^+=1; //(x0+x)+(y0-y)*arr_dst_width
          if (y>=-c2) and (y<-c3) then
             (p+x+y1)^+=1; //(x0+x)+(y0+y)*arr_dst_width
        end;
      if (y<=-c0) and (y>-c1) then
        begin
          if (x>=-c2) and (x<-c3) then
             (p-y+x1)^+=1; //(x0-y)+(y0+x)*arr_dst_width
          if (x<=+c2) and (x>+c3) then
             (p-y-x1)^+=1; //(x0-y)+(y0-x)*arr_dst_width
        end;
      if (x<=-c0) and (x>-c1) then
        begin
          if (y>=-c2) and (y<-c3) then
             (p-x+y1)^+=1; //(x0-x)+(y0+y)*arr_dst_width
          if (y<=+c2) and (y>+c3) then
             (p-x-y1)^+=1; //(x0-x)+(y0-y)*arr_dst_width
        end;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
// Wave search:
function CircleW            (constref x0,y0,rad:integer; constref arr_dst:TPtPos3Arr; constref arr_dst_width:TColor;                           var pt:TPtPosF): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p     : PPtPos3;
  x,x1  : integer;
  y,y1  : integer;
  err   : integer;
begin
  Result:=False;
  p     :=Unaligned(@arr_dst[x0+y0*arr_dst_width]);
  x     :=rad;
  y     :=0;
  err   :=0;
  while (x>=y) do
    begin
      x1:=x*arr_dst_width;
      y1:=y*arr_dst_width;
      if ((p+y-x1)^.obj_ind<>-1) then //(x0+y)+(y0-x)*arr_dst_width
        begin
          pt    :=PtPosF(x0+y,y0-x);
          Result:=True;
          Exit;
        end;
      if ((p+x-y1)^.obj_ind<>-1) then //(x0+x)+(y0-y)*arr_dst_width
        begin
          pt    :=PtPosF(x0+x,y0-y);
          Result:=True;
          Exit;
        end;
      if ((p+x+y1)^.obj_ind<>-1) then //(x0+x)+(y0+y)*arr_dst_width
        begin
          pt    :=PtPosF(x0+x,y0+y);
          Result:=True;
          Exit;
        end;
      if ((p+y+x1)^.obj_ind<>-1) then //(x0+y)+(y0+x)*arr_dst_width
        begin
          pt    :=PtPosF(x0+y,y0+x);
          Result:=True;
          Exit;
        end;
      if ((p-y+x1)^.obj_ind<>-1) then //(x0-y)+(y0+x)*arr_dst_width
        begin
          pt    :=PtPosF(x0-y,y0+x);
          Result:=True;
          Exit;
        end;
      if ((p-x+y1)^.obj_ind<>-1) then //(x0-x)+(y0+y)*arr_dst_width
        begin
          pt    :=PtPosF(x0-x,y0+y);
          Result:=True;
          Exit;
        end;
      if ((p-x-y1)^.obj_ind<>-1) then //(x0-x)+(y0-y)*arr_dst_width
        begin
          pt    :=PtPosF(x0-x,y0-y);
          Result:=True;
          Exit;
        end;
      if ((p-y-x1)^.obj_ind<>-1) then //(x0-y)+(y0-x)*arr_dst_width
        begin
          pt    :=PtPosF(x0-y,y0-x);
          Result:=True;
          Exit;
        end;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
function CircleWC           (constref x0,y0,rad:integer; constref arr_dst:TPtPos3Arr; constref arr_dst_width:TColor; constref rct_clp:TPtRect; var pt:TPtPosF): boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  p          : PPtPos3;
  x,x1       : integer;
  y,y1       : integer;
  err        : integer;
  c0,c1,c2,c3: integer;
begin
  Result:=False;
  p     :=Unaligned(@arr_dst[x0+y0*arr_dst_width]);
  x     :=rad;
  y     :=0;
  err   :=0;
  c0    := rct_clp.left  -x0;
  c1    := rct_clp.right -x0;
  c2    :=-rct_clp.top   +y0;
  c3    :=-rct_clp.bottom+y0;
  while (x>=y) do
    begin
      x1:=x*arr_dst_width;
      y1:=y*arr_dst_width;
      if (y>=+c0) and (y<+c1) then
        begin
          if (x<=+c2) and (x>+c3) and ((p+y-x1)^.obj_ind<>-1) then //(x0+y)+(y0-x)*arr_dst_width
            begin
              pt    :=PtPosF(x0+y,y0-x);
              Result:=True;
              Exit;
            end;
          if (x>=-c2) and (x<-c3) and ((p+y+x1)^.obj_ind<>-1) then //(x0+y)+(y0+x)*arr_dst_width
            begin
              pt    :=PtPosF(x0+y,y0+x);
              Result:=True;
              Exit;
            end;
        end;
      if (x>=+c0) and (x<+c1) then
        begin
          if (y<=+c2) and (y>+c3) and ((p+x-y1)^.obj_ind<>-1) then //(x0+x)+(y0-y)*arr_dst_width
            begin
              pt    :=PtPosF(x0+x,y0-y);
              Result:=True;
              Exit;
            end;
          if (y>=-c2) and (y<-c3) and ((p+x+y1)^.obj_ind<>-1) then //(x0+x)+(y0+y)*arr_dst_width
            begin
              pt    :=PtPosF(x0+x,y0+y);
              Result:=True;
              Exit;
            end;
        end;
      if (y<=-c0) and (y>-c1) then
        begin
          if (x>=-c2) and (x<-c3) and ((p-y+x1)^.obj_ind<>-1) then //(x0-y)+(y0+x)*arr_dst_width
            begin
              pt    :=PtPosF(x0-y,y0+x);
              Result:=True;
              Exit;
            end;
          if (x<=+c2) and (x>+c3) and ((p-y-x1)^.obj_ind<>-1) then //(x0-y)+(y0-x)*arr_dst_width
            begin
              pt    :=PtPosF(x0-y,y0-x);
              Result:=True;
              Exit;
            end;
        end;
      if (x<=-c0) and (x>-c1) then
        begin
          if (y>=-c2) and (y<-c3) and ((p-x+y1)^.obj_ind<>-1) then //(x0-x)+(y0+y)*arr_dst_width
            begin
              pt    :=PtPosF(x0-x,y0+y);
              Result:=True;
              Exit;
            end;
          if (y<=+c2) and (y>+c3) and ((p-x-y1)^.obj_ind<>-1) then //(x0-x)+(y0-y)*arr_dst_width
            begin
              pt    :=PtPosF(x0-x,y0-y);
              Result:=True;
              Exit;
            end;
        end;
      if (err<=0) then
        begin
          y  +=1;
          err+=y<<1+1;
        end;
      if (err>0) then
        begin
          x  -=1;
          err-=x<<1+1;
        end;
    end;
end; {$endregion}
// Circle floodFill:
procedure CircleFloodFill0  (constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam    :TColor; constref pow      :byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  rad1_sqr :=rad1*rad1;
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) and (PRGBA(pixel_ptr)^.a<>1) then
            begin
              AlphaBlend1(pixel_ptr,color_info.pix_col,255-pow)
                         {Highlight1 (pixel_ptr^,pow)};
              pixel_ptr^:=pixel_ptr^ or ONE_SHL_24;
            end;
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleFloodFill1  (constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam    :TColor; constref pow      :byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  rad1_sqr :=rad1*rad1;
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) and (PRGBA(pixel_ptr)^.a<>1) then
            begin
              AlphaBlend1(pixel_ptr,color_info.pix_col,Max(255-pow,((diam-1)*dist_sqr)>>8{Trunc((diam-1)*dist_sqr/255)}));
              pixel_ptr^:=pixel_ptr^ or ONE_SHL_24;
            end;
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleFloodFill2  (constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam    :TColor; constref pow      :byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  rad1_sqr :=rad1*rad1;
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) then
            AlphaBlend1(pixel_ptr,color_info.pix_col,Max(255-pow,((diam-1)*dist_sqr)>>8{Trunc((diam-1)*dist_sqr/255)})); // BlurRGBDec(pixel_ptr,bmp_dst_width,Max(pow,((diam-1)*dist_sqr)>>8));
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
// Spotlight:
procedure SqrtArr0Init      (const w:integer=3840; const h:integer=2160); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;

  function SqrtArr0Length(w_,h_:integer): integer; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    Result:=2*w_*(w_-1)+sqr(h_-1)+1;
  end; {$endregion}

begin
  SetLength(sqrt_arr0,Min2(SqrtArr0Length(w,h),SqrtArr0Length(3840,2160)));
  for i:=0 to Length(sqrt_arr0)-1 do
    sqrt_arr0[i]:=sqrt(i);
end; {$endregion}
procedure CircleHighlight000(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam    :TColor; constref pow      :byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  a_m_div_r: double;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  rad1_sqr :=rad1*rad1;
  a_m_div_r:=pow /rad1;
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr; //     f =i*(i-rad2<<1)+d_sqr=i*(i-2*x+2*rct_dst.left)+sqr(j-y+rct_dst.top)+sqr(x-rct_dst.left)
          if (dist_sqr<rad1_sqr) then    // max(f)=(rct_dst.width-1)*(rct_dst.width-1+2*rct_dst.left)+sqr(rct_dst.height-1+rct_dst.top)+sqr(bmp_dst_width-rct_dst.left)<=sqr(bmp_dst_width-1)+sqr(bmp_dst_height-1)+sqr(bmp_dst_width)=2*bmp_dst_width*(bmp_dst_width-1)+1+sqr(bmp_dst_height-1)
            AdditiveDec1(pixel_ptr,color_info.pix_col,Trunc(a_m_div_r*sqrt_arr0[dist_sqr])-pow);
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleHighlight001(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam    :TColor; constref pow      :byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  a_m_div_r: double;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  rad1_sqr :=rad1*rad1;
  a_m_div_r:=pow /rad1;
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) then
            AlphaBlend1(pixel_ptr,color_info.pix_col,Trunc(a_m_div_r*sqrt_arr0[dist_sqr])-pow);
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleHighlight002(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam    :TColor; constref pow      :byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  a_m_div_r: double;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  rad1_sqr :=rad1*rad1;
  a_m_div_r:=pow /rad1;
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) then
            InverseDec1(pixel_ptr,Trunc(a_m_div_r*sqrt_arr0[dist_sqr])-pow);
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleHighlight003(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam    :TColor; constref pow      :byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  a_m_div_r: double;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  rad1_sqr :=rad1*rad1;
  a_m_div_r:=pow /rad1;
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) then
            Highlight1(pixel_ptr,pow-Trunc(a_m_div_r*sqrt_arr0[dist_sqr]));
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleHighlight004(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam    :TColor; constref pow      :byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  a_m_div_r: double;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  rad1_sqr :=rad1*rad1;
  a_m_div_r:=pow /rad1;
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) then
            Darken1(pixel_ptr,pow-Trunc(a_m_div_r*sqrt_arr0[dist_sqr]));
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleHighlight005(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam    :TColor; constref pow      :byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  a_m_div_r: double;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  rad1_sqr :=rad1*rad1;
  a_m_div_r:=pow /rad1;
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) then
            GrayscaleRDec1(pixel_ptr,pow-Trunc(a_m_div_r*sqrt_arr0[dist_sqr]));
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleHighlight006(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam    :TColor; constref pow      :byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  a_m_div_r: double;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  rad1_sqr :=rad1*rad1;
  a_m_div_r:=pow /rad1;
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) then
            GrayscaleGDec1(pixel_ptr,pow-Trunc(a_m_div_r*sqrt_arr0[dist_sqr]));
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleHighlight007(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam    :TColor; constref pow      :byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  a_m_div_r: double;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  rad1_sqr :=rad1*rad1;
  a_m_div_r:=pow /rad1;
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) then
            GrayscaleBDec1(pixel_ptr,pow-Trunc(a_m_div_r*sqrt_arr0[dist_sqr]));
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleHighlight008(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam    :TColor; constref pow      :byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  a_m_div_r: double;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  rad1_sqr :=rad1*rad1;
  a_m_div_r:=pow /rad1;
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) then
            ColorizeRDec1(pixel_ptr,Trunc(a_m_div_r*sqrt_arr0[dist_sqr])-pow,pow);
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleHighlight009(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam    :TColor; constref pow      :byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  a_m_div_r: double;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  rad1_sqr :=rad1*rad1;
  a_m_div_r:=pow /rad1;
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) then
            ColorizeGDec1(pixel_ptr,Trunc(a_m_div_r*sqrt_arr0[dist_sqr])-pow,pow);
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleHighlight010(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam    :TColor; constref pow      :byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  a_m_div_r: double;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  rad1_sqr :=rad1*rad1;
  a_m_div_r:=pow /rad1;
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) then
            ColorizeBDec1(pixel_ptr,Trunc(a_m_div_r*sqrt_arr0[dist_sqr])-pow,pow);
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleHighlight011(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam    :TColor; constref pow      :byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  a_m_div_r: double;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  rad1_sqr :=rad1*rad1;
  a_m_div_r:=pow /rad1;
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) then
            BlurRGB4Dec(pixel_ptr,bmp_dst_width,Trunc(a_m_div_r*sqrt_arr0[dist_sqr])-pow);
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleHighlight100(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam,mrg:TColor; constref pow1,pow2:byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  a_m_div_r: double;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad1_sqr2: integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  if (mrg>=rad1) then
    Exit;
  rad1_sqr :=sqr  (rad1      );
  rad1_sqr2:=sqr  (rad1-  mrg);
  a_m_div_r:=pow1/(rad1-4*mrg);
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr; //     f =i*(i-rad2<<1)+d_sqr=i*(i-2*x+2*rct_dst.left)+sqr(j-y+rct_dst.top)+sqr(x-rct_dst.left)
          if (dist_sqr<rad1_sqr) then    // max(f)=(rct_dst.width-1)*(rct_dst.width-1+2*rct_dst.left)+sqr(rct_dst.height-1+rct_dst.top)+sqr(bmp_dst_width-rct_dst.left)<=sqr(bmp_dst_width-1)+sqr(bmp_dst_height-1)+sqr(bmp_dst_width)=2*bmp_dst_width*(bmp_dst_width-1)+1+sqr(bmp_dst_height-1)
            begin
              if (dist_sqr>=rad1_sqr2) then
                AdditiveDec1(pixel_ptr,color_info.pix_col,Trunc(a_m_div_r*sqrt_arr0[dist_sqr])-pow1)
              else
                AdditiveDec1(pixel_ptr,color_info.pix_col,255-pow2);
            end;
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleHighlight101(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam,mrg:TColor; constref pow1,pow2:byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  a_m_div_r: double;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad1_sqr2: integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  if (mrg>=rad1) then
    Exit;
  rad1_sqr :=sqr  (rad1      );
  rad1_sqr2:=sqr  (rad1-  mrg);
  a_m_div_r:=pow1/(rad1-4*mrg);
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) then
            begin
              if (dist_sqr>=rad1_sqr2) then
                AlphaBlend1(pixel_ptr,color_info.pix_col,Trunc(a_m_div_r*sqrt_arr0[dist_sqr])-pow1)
              else
                AlphaBlend1(pixel_ptr,color_info.pix_col,255-pow2);
            end;
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleHighlight102(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam,mrg:TColor; constref pow1,pow2:byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  a_m_div_r: double;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad1_sqr2: integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  if (mrg>=rad1) then
    Exit;
  rad1_sqr :=sqr  (rad1      );
  rad1_sqr2:=sqr  (rad1-  mrg);
  a_m_div_r:=pow1/(rad1-4*mrg);
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) then
            begin
              if (dist_sqr>=rad1_sqr2) then
                InverseDec1(pixel_ptr,Trunc(a_m_div_r*sqrt_arr0[dist_sqr])-pow1)
              else
                InverseDec1(pixel_ptr,255-pow2);
            end;
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleHighlight103(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam,mrg:TColor; constref pow1,pow2:byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  a_m_div_r: double;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad1_sqr2: integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  if (mrg>=rad1) then
    Exit;
  rad1_sqr :=sqr  (rad1      );
  rad1_sqr2:=sqr  (rad1-  mrg);
  a_m_div_r:=pow1/(rad1-4*mrg);
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) then
            begin
              if (dist_sqr>=rad1_sqr2) then
                Highlight1(pixel_ptr,pow1-Trunc(a_m_div_r*sqrt_arr0[dist_sqr]))
              else
                Highlight1(pixel_ptr,pow2-255);
            end;
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleHighlight104(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam,mrg:TColor; constref pow1,pow2:byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  a_m_div_r: double;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad1_sqr2: integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  if (mrg>=rad1) then
    Exit;
  rad1_sqr :=sqr  (rad1      );
  rad1_sqr2:=sqr  (rad1-  mrg);
  a_m_div_r:=pow1/(rad1-4*mrg);
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) then
            begin
              if (dist_sqr>=rad1_sqr2) then
                Darken1(pixel_ptr,pow1-Trunc(a_m_div_r*sqrt_arr0[dist_sqr]))
              else
                Darken1(pixel_ptr,pow2-255);
            end;
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleHighlight105(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam,mrg:TColor; constref pow1,pow2:byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  a_m_div_r: double;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad1_sqr2: integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  if (mrg>=rad1) then
    Exit;
  rad1_sqr :=sqr  (rad1      );
  rad1_sqr2:=sqr  (rad1-  mrg);
  a_m_div_r:=pow1/(rad1-4*mrg);
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) then
            begin
              if (dist_sqr>=rad1_sqr2) then
                GrayscaleRDec1(pixel_ptr,pow1-Trunc(a_m_div_r*sqrt_arr0[dist_sqr]))
              else
                GrayscaleRDec1(pixel_ptr,pow2-255);
            end;
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleHighlight106(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam,mrg:TColor; constref pow1,pow2:byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  a_m_div_r: double;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad1_sqr2: integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  if (mrg>=rad1) then
    Exit;
  rad1_sqr :=sqr  (rad1      );
  rad1_sqr2:=sqr  (rad1-  mrg);
  a_m_div_r:=pow1/(rad1-4*mrg);
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) then
            begin
              if (dist_sqr>=rad1_sqr2) then
                GrayscaleGDec1(pixel_ptr,pow1-Trunc(a_m_div_r*sqrt_arr0[dist_sqr]))
              else
                GrayscaleGDec1(pixel_ptr,pow2-255);
            end;
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleHighlight107(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam,mrg:TColor; constref pow1,pow2:byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  a_m_div_r: double;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad1_sqr2: integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  if (mrg>=rad1) then
    Exit;
  rad1_sqr :=sqr  (rad1      );
  rad1_sqr2:=sqr  (rad1-  mrg);
  a_m_div_r:=pow1/(rad1-4*mrg);
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) then
            begin
              if (dist_sqr>=rad1_sqr2) then
                GrayscaleBDec1(pixel_ptr,pow1-Trunc(a_m_div_r*sqrt_arr0[dist_sqr]))
              else
                GrayscaleBDec1(pixel_ptr,pow2-255);
            end;
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleHighlight108(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam,mrg:TColor; constref pow1,pow2:byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  a_m_div_r: double;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad1_sqr2: integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  if (mrg>=rad1) then
    Exit;
  rad1_sqr :=sqr  (rad1      );
  rad1_sqr2:=sqr  (rad1-  mrg);
  a_m_div_r:=pow1/(rad1-4*mrg);
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) then
            begin
              if (dist_sqr>=rad1_sqr2) then
                ColorizeRDec1(pixel_ptr,Trunc(a_m_div_r*sqrt_arr0[dist_sqr])-pow1,pow1)
              else
                ColorizeRDec1(pixel_ptr,255-pow2,pow2);
            end;
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleHighlight109(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam,mrg:TColor; constref pow1,pow2:byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  a_m_div_r: double;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad1_sqr2: integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  if (mrg>=rad1) then
    Exit;
  rad1_sqr :=sqr  (rad1      );
  rad1_sqr2:=sqr  (rad1-  mrg);
  a_m_div_r:=pow1/(rad1-4*mrg);
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) then
            begin
              if (dist_sqr>=rad1_sqr2) then
                ColorizeGDec1(pixel_ptr,Trunc(a_m_div_r*sqrt_arr0[dist_sqr])-pow1,pow1)
              else
                ColorizeGDec1(pixel_ptr,255-pow2,pow2);
            end;
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleHighlight110(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam,mrg:TColor; constref pow1,pow2:byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  a_m_div_r: double;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad1_sqr2: integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  if (mrg>=rad1) then
    Exit;
  rad1_sqr :=sqr  (rad1      );
  rad1_sqr2:=sqr  (rad1-  mrg);
  a_m_div_r:=pow1/(rad1-4*mrg);
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) then
            begin
              if (dist_sqr>=rad1_sqr2) then
                ColorizeBDec1(pixel_ptr,Trunc(a_m_div_r*sqrt_arr0[dist_sqr])-pow1,pow1)
              else
                ColorizeBDec1(pixel_ptr,255-pow2,pow2);
            end;
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
procedure CircleHighlight111(constref x,y:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_out:TPtRect; constref color_info:TColorInfo; constref diam,mrg:TColor; constref pow1,pow2:byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst  : TPtRect;
  pixel_ptr: PInteger;
  a_m_div_r: double;
  d_width  : integer;
  i,j      : integer;
  rad1     : integer;
  rad1_sqr : integer;
  rad1_sqr2: integer;
  rad2     : integer;
  rad2_sqr : integer;
  rad3     : integer;
  dist_sqr : integer;
  d_sqr    : integer;
begin
  if (diam=0) then
    Exit;
  rad1     :=diam>>1;
  if (mrg>=rad1) then
    Exit;
  rad1_sqr :=sqr  (rad1      );
  rad1_sqr2:=sqr  (rad1-  mrg);
  a_m_div_r:=pow1/(rad1-4*mrg);
  rct_dst  :=ClippedRct(rct_out,PtRct(x-rad1,y-rad1,x+rad1,y+rad1));
  if (rct_dst.width=0) or (rct_dst.height=0) then
    Exit;
  rad2     :=x            -rct_dst.left;
  rad2_sqr :=rad2*rad2;
  rad3     :=y            -rct_dst.top;
  d_width  :=bmp_dst_width-rct_dst.width;
  pixel_ptr:=bmp_dst_ptr  +rct_dst.left+rct_dst.top*bmp_dst_width;
  for j:=0 to rct_dst.height-1 do
    begin
      d_sqr:=sqr(j-rad3)+rad2_sqr;
      for i:=0 to rct_dst.width-1 do
        begin
          dist_sqr:=i*(i-rad2<<1)+d_sqr;
          if (dist_sqr<rad1_sqr) then
            begin
              if (dist_sqr>=rad1_sqr2) then
                BlurRGB4Dec(pixel_ptr,bmp_dst_width,Trunc(a_m_div_r*sqrt_arr0[dist_sqr])-pow1)
              else
                BlurRGB4Dec(pixel_ptr,bmp_dst_width,255-pow2);
            end;
          Inc(pixel_ptr);
        end;
      Inc(pixel_ptr,d_width);
    end;
end; {$endregion}
// Transparent text:
procedure SetTextInfo       (                      constref dst_canvas:TCanvas; constref height_:integer=27; constref font_color:TColor=$006C754A; constref font_name:string='AR CENA'; constref font_charset:TFontCharSet=ANSI_CHARSET; constref font_quality:TFontQuality=fqAntialiased; constref pen_mode:TFPPenMode=pmXor; constref brush_style:TFPBrushStyle=bsClear); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with dst_canvas do
    begin
      Font .height :=height_; // 5*(1<<(Trunc(ln(height)/ln(2))-3))<=pixel count on height<5*(1<<(Trunc(ln(height)/ln(2))-2))
    //Font .size   :=height_;
      Font .color  :=font_color;
      Font .charset:=font_charset;
      Font .name   :=font_name;
      Font .quality:=font_quality;
      Pen  .mode   :=pen_mode;
      Brush.style  :=brush_style;
    end;
end; {$endregion}
procedure Text              (constref x,y:integer; constref dst_canvas:TCanvas; constref text_:string);                                                                                                                                                                                                                                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  dst_canvas.TextOut(x,y,text_);
end; {$endregion}
// ...
procedure TextGrid          (constref x,y:integer; constref dst_canvas:TCanvas; const arr_cell_width,arr_cell_height,cnt_x,cnt_y:TColor);                                                                                                                                                                                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for j:=0 to cnt_y-1 do
    for i:=0 to cnt_x-1 do
      dst_canvas.TextOut(x+arr_cell_width*i,y+arr_cell_height*j,IntToStr(i)+' ; '+IntToStr(j));
end; {$endregion}

{$endregion}



(********************************** Blitters **********************************) {$region -fold}

// Get bitmap handle:
function  GetBmpHandle  (bmp:Graphics.TBitmap): PInteger{pointer}; inline; {$region -fold}
var
  bmp_info: TBitmapInfo;
begin
  bmp_info.bmiHeader.biSize       :=SizeOf(BitmapInfo.bmiHeader);
  bmp_info.bmiHeader.biWidth      :=bmp.Width;
  bmp_info.bmiHeader.biHeight     :=-bmp.Height; // BitMap.Height will invert image on axis X
  bmp_info.bmiHeader.biPlanes     :=1;
  bmp_info.bmiHeader.biBitCount   :=32;
  bmp_info.bmiHeader.biCompression:=BI_RGB;
  bmp.Handle                      :=CreateDIBSection(bmp.Canvas.Handle,bmp_info,DIB_RGB_COLORS,GetBmpHandle,0,0);
end; {$endregion}
procedure GLBitmapInit  (tex_id:TColor; bmp:Graphics.TBitmap; b:boolean); inline; {$region -fold}
begin
  if (not b) then
    glDisable(GL_TEXTURE_2D)
  else
    begin
      glEnable     (GL_TEXTURE_2D);
      glGenTextures(1,@tex_id);
      glBindTexture(GL_TEXTURE_2D,tex_id);
    end;
end; {$endregion}
// Drawing of GL canvas:
procedure CnvDraw0      (left,top,right,bottom:GLfloat; const bmp_dst_ptr:PInteger; const bmp_dst_width,bmp_dst_height:integer                                                              ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
  glTexImage2D   (GL_TEXTURE_2D,0,GL_RGBA,bmp_dst_width,bmp_dst_height,0,32993,GL_UNSIGNED_BYTE,bmp_dst_ptr);
    glBegin      (GL_QUADS);
      glTexCoord2f(0.0,0.0); glVertex2f(left ,top   );
      glTexCoord2f(1.0,0.0); glVertex2f(right,top   );
      glTexCoord2f(1.0,1.0); glVertex2f(right,bottom);
      glTexCoord2f(0.0,1.0); glVertex2f(left ,bottom);
    glEnd;
end; {$endregion}
procedure CnvDraw1      (const bmp_dst_ptr:PInteger; const bmp_dst_width,bmp_dst_height:integer                                                              ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i    : integer;
  d0,d1: double;
begin

//glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
//glLoadIdentity;
//glDrawPixels(bmp_dst_width,bmp_dst_height,32993{swap channels: GL_RGBA=$1908 to GL_BGRA=32993},GL_UNSIGNED_BYTE,bmp_dst_ptr);
//glEnable       (GL_TEXTURE_2D);
//glTexImage2D   (GL_TEXTURE_2D,0,GL_RGBA{3},bmp_dst_width,bmp_dst_height,0,32993{swap channels: GL_RGBA=$1908 to GL_BGRA=32993},GL_UNSIGNED_BYTE,bmp_dst_ptr);
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
 {glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST{GL_LINEAR});
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S    ,GL_CLAMP  {GL_REPEAT});
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T    ,GL_CLAMP  {GL_REPEAT});}
 {glEnable       (GL_COLOR_LOGIC_OP);
  glLogicOp      (GL_COPY_INVERTED);}
 {glEnable       (GL_BLEND);
  glBlendFunc    (GL_ONE_MINUS_DST_COLOR,GL_ZERO);}
  glTexImage2D   (GL_TEXTURE_2D,0,GL_RGBA{3},bmp_dst_width,bmp_dst_height,0,32993{swap channels: GL_RGBA=$1908 to GL_BGRA=32993},GL_UNSIGNED_BYTE,bmp_dst_ptr);
//glEnable       (GL_COLOR_LOGIC_OP);
//glLogicOp      (GL_COPY_INVERTED);
    glBegin      (GL_QUADS);

      //          ( rct_left , rct_top   )
      glTexCoord2f( 0.0      , 0.0       );
      glVertex2f  (-1.0      , 1.0       );

      //          ( rct_right, rct_top   )
      glTexCoord2f( 1.0      , 0.0       );
      glVertex2f  ( 1.0      , 1.0       );

      //          ( rct_right, rct_bottom)
      glTexCoord2f( 1.0      , 1.0       );
      glVertex2f  ( 1.0      ,-1.0       );

      //          ( rct_left , rct_bottom)
      glTexCoord2f( 0.0      , 1.0       );
      glVertex2f  (-1.0      ,-1.0       );

    glEnd;

  {glBegin(GL_LINES);
  Randomize;
  for i:=0 to 100000-1 do
    begin
      glVertex2f(-Random(100),-Random(100));
      glVertex2f( Random(100), Random(100));
    end;
  glEnd;}

  {Randomize;
  glBegin(GL_QUADS);
    for i:=0 to 100000-1 do
      begin
        glTexCoord2f ( 0.0 , 0.0      );
        glVertex3f   (-1/(Random(100)+1), 1/(Random(100)+1), 0.0);
        glTexCoord2f ( 1.0 , 0.0      );
        glVertex3f   ( 1/(Random(100)+1), 1/(Random(100)+1), 0.0);
        glTexCoord2f ( 1.0 , 1.0      );
        glVertex3f   ( 1/(Random(100)+1),-1/(Random(100)+1), 0.0);
        glTexCoord2f ( 0.0 , 1.0      );
        glVertex3f   (-1/(Random(100)+1),-1/(Random(100)+1), 0.0);
      end;
  glEnd;}

end; {$endregion}
procedure CnvDraw2      (const bmp_dst_ptr:PInteger; const bmp_dst_width,bmp_dst_height:integer; const alpha_pow:single=1.0; const pixel_format:GLInt=GL_RGBA); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
  glTexImage2D   (GL_TEXTURE_2D,0,pixel_format,bmp_dst_width,bmp_dst_height,0,32993{swap channels: GL_RGBA=$1908 to GL_BGRA=32993},GL_UNSIGNED_BYTE,bmp_dst_ptr);
  glEnable (GL_BLEND);
  glColor4f(1.0,1.0,1.0,alpha_pow);
  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
  glBegin(GL_QUADS);
    glTexCoord2f ( 0.0, 0.0);
    glVertex2f   (-1.0, 1.0);
    glTexCoord2f ( 1.0, 0.0);
    glVertex2f   ( 1.0, 1.0);
    glTexCoord2f ( 1.0, 1.0);
    glVertex2f   ( 1.0,-1.0);
    glTexCoord2f ( 0.0, 1.0);
    glVertex2f   (-1.0,-1.0);
  glEnd;
  glDisable(GL_BLEND);
end; {$endregion}
// GL camera pos.:
procedure GLCameraSetPos(x,y:GLfloat; const bmp_dst_width,bmp_dst_height:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  //glClear(GL_COLOR_BUFFER_BIT);

  // Включаем матрицу проекции
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity;

  // Ортографическая проекция
  gluOrtho2D(0,bmp_dst_width,0,bmp_dst_height);

  // Включаем матрицу модели
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity;

  // Смещение камеры
  glTranslatef(x,y,0);
end; {$endregion}
// (Store color channel into integer array) Сохранить цветовой канал в целочисленный массив:
procedure BmpToArr      (const bmp_src_ptr:PInteger; var bmp_dst_ptr:PInteger; const bmp_src_width,bmp_src_height:TColor; var bmp_dst_width,bmp_dst_height:TColor; const bmp_src_rct:TPtRect; var arr_dst:TColorArr); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  bmp_src_rct_clp: TPtRect;
begin
  with bmp_src_rct_clp do
    begin
      bmp_src_rct_clp:=ClippedRct(PtBounds(0,0,bmp_src_width,bmp_src_height),bmp_src_rct);
      SetLength(arr_dst,width*height);
      bmp_dst_ptr:=Unaligned(@arr_dst[0]);
      if (width=bmp_src_width) and (height=bmp_src_height) then
        Move(bmp_src_ptr^,(@arr_dst[0])^,(width*height)<<2)
      else
        BitBlt2(bmp_src_ptr,bmp_dst_ptr,bmp_src_width,width,0,0,bmp_src_rct_clp);
      bmp_dst_width :=width;
      bmp_dst_height:=height;
    end;
end; {$endregion}
// Copy one canvas to another:
procedure CnvToCnv      (rct_dst:TPtRect; cnv_dst,cnv_src:TCanvas; copy_mode:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {$ifdef Windows}
  BitBlt
  (
    cnv_dst.Handle,
    rct_dst.left,
    rct_dst.top,
    rct_dst.width,
    rct_dst.height,
    cnv_src.Handle,
    0,
    0,
    copy_mode
  );
  {StretchBlt
  (
    cnv_dst.Handle,
    rct_dst.left,
    rct_dst.top,
    rct_dst.width,
    rct_dst.height,
    cnv_src.Handle,
    0,
    0,
    rct_dst.width,
    rct_dst.height,
    copy_mode
  );}
  {$else}
  cnv_dst.CopyMode:=copy_mode;
  cnv_dst.CopyRect
  (
    Rect
    (
      rct_dst.left,
      rct_dst.top,
      rct_dst.right,
      rct_dst.bottom
    ),
    cnv_src,
    Rect(0,0,rct_dst.width,rct_dst.height)
  );
  {$endif}
end; {$endregion}
procedure BmpToBmp2     (const bmp_src_ptr,bmp_dst_ptr:PInteger ; const bmp_src_width,bmp_dst_width:integer; const clp_rct:TPtRect; const inn_wnd_mrg_:integer                                                                             ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  BitBlt1(bmp_src_ptr,
          bmp_dst_ptr,
          bmp_src_width,
          bmp_dst_width,
          clp_rct.left  -inn_wnd_mrg_,
          clp_rct.top   -inn_wnd_mrg_,
          clp_rct.width +inn_wnd_mrg_<<1,
          clp_rct.height+inn_wnd_mrg_<<1,
          clp_rct.left  -inn_wnd_mrg_,
          clp_rct.top   -inn_wnd_mrg_);
end; {$endregion}
// Blitter0:
procedure BitBlt0       (var   arr_src                :TColorArr; const                                                      rct_src_width,rct_src_height,rct_dst_left,rct_dst_top:integer                                                 ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  arr_med       : TColorArr;
  arr_med_ptr   : PInteger;
  arr_src_ptr   : PInteger;
  bits_per_line : integer;
  y             : integer;
  arr_src_width : integer;
  arr_src_height: integer;
begin
  arr_src_width := rct_dst_left+rct_src_width;
  arr_src_height:= rct_dst_top +rct_src_height;
  SetLength     (  arr_med,    (rct_src_width*rct_src_height));
  arr_med       := arr_src;
  SetLength     (  arr_src     ,arr_src_width*arr_src_height);
  FillDWord     ((@arr_src[0])^,arr_src_width*arr_src_height,0);
  arr_med_ptr   :=@arr_med[00000000000000000000000000000000000000];
  arr_src_ptr   :=@arr_src[rct_dst_left+rct_dst_top*arr_src_width];
  bits_per_line := rct_src_width<<2;
  for y:=0 to rct_src_height-1 do
    begin
      Move(arr_med_ptr^,arr_src_ptr^,bits_per_line);
      Inc (arr_med_ptr,rct_src_width);
      Inc (arr_src_ptr,arr_src_width);
    end;
  SetLength(arr_med,0);
end; {$endregion}
// Blitter1:
procedure BitBlt1       (const bmp_src_ptr,bmp_dst_ptr:PInteger ; const bmp_src_width,bmp_dst_width,                                                      rct_dst_left,rct_dst_top:integer; const rct_src:TPtRect                          ); inline;                                {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  bits_per_line: integer;
  x,y          : integer;
begin
  bits_per_line:=rct_src.width<<2;
  src_pixel_ptr:=@bmp_src_ptr[rct_src.left+rct_src.top*bmp_src_width];
  dst_pixel_ptr:=@bmp_dst_ptr[rct_dst_left+rct_dst_top*bmp_dst_width];
  for y:=0 to rct_src.height-1 do
    begin
      {for x:=0 to rct_src.width-1 do
        if ((src_pixel_ptr+x)^>>24)=MAXBYTE then
            (dst_pixel_ptr+x)^:=
            (src_pixel_ptr+x)^;}
      Move(src_pixel_ptr^,dst_pixel_ptr^,bits_per_line);
      Inc (src_pixel_ptr,bmp_src_width);
      Inc (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure BitBlt1       (const bmp_src_ptr,bmp_dst_ptr:PInteger ; const bmp_src_width,bmp_dst_width,rct_src_left,rct_src_top,rct_src_width,rct_src_height,rct_dst_left,rct_dst_top:integer                                                 ); inline;                                {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  bits_per_line: integer;
  x,y          : integer;
begin
  src_pixel_ptr:=@bmp_src_ptr[rct_src_left+rct_src_top*bmp_src_width];
  dst_pixel_ptr:=@bmp_dst_ptr[rct_dst_left+rct_dst_top*bmp_dst_width];
  bits_per_line:=rct_src_width<<2;
  for y:=0 to    rct_src_height-1 do
    begin
     {for x:=0 to rct_src_width-1 do
          (dst_pixel_ptr+x)^:=
          (src_pixel_ptr+x)^ and color_level_arr[4];}
      Move(src_pixel_ptr^,dst_pixel_ptr^,bits_per_line);
      Inc (src_pixel_ptr,bmp_src_width);
      Inc (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
// Blitter1(x-axis inverted):
procedure BitBlt1X      (const bmp_src_ptr,bmp_dst_ptr:PInteger ; const bmp_src_width,bmp_dst_width,                                                      rct_dst_left,rct_dst_top:integer; const rct_src:TPtRect                          ); inline;                                {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  src_pixel_ptr:=@bmp_src_ptr[rct_src.left+rct_src.top*bmp_src_width                ];
  dst_pixel_ptr:=@bmp_dst_ptr[rct_dst_left+rct_dst_top*bmp_dst_width+rct_src.width-1];
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
         (dst_pixel_ptr-x)^:=
         (src_pixel_ptr+x)^;
      Inc(src_pixel_ptr,bmp_src_width);
      Inc(dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure BitBlt1X      (const bmp_src_ptr,bmp_dst_ptr:PInteger ; const bmp_src_width,bmp_dst_width,rct_src_left,rct_src_top,rct_src_width,rct_src_height,rct_dst_left,rct_dst_top:integer                                                 ); inline;                                {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  x,y              : integer;
begin
  src_pixel_ptr:=@bmp_src_ptr[rct_src_left+rct_src_top*bmp_src_width                ];
  dst_pixel_ptr:=@bmp_dst_ptr[rct_dst_left+rct_dst_top*bmp_dst_width+rct_src_width-1];
  for y:=0 to    rct_src_height-1 do
    begin
     for x:=0 to rct_src_width-1 do
         (dst_pixel_ptr-x)^:=
         (src_pixel_ptr+x)^;
      Inc(src_pixel_ptr,bmp_src_width);
      Inc(dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
// Blitter1(y-axis inverted):
procedure BitBlt1Y      (const bmp_src_ptr,bmp_dst_ptr:PInteger ; const bmp_src_width,bmp_dst_width,                                                      rct_dst_left,rct_dst_top:integer; const rct_src:TPtRect                          ); inline;                                {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  bits_per_line: integer;
  x,y          : integer;
begin
  bits_per_line:=rct_src.width<<2;
  src_pixel_ptr:=@bmp_src_ptr[rct_src.left+ rct_src.top                  *bmp_src_width];
  dst_pixel_ptr:=@bmp_dst_ptr[rct_dst_left+(rct_dst_top+rct_src.height-1)*bmp_dst_width];
  for y:=0 to rct_src.height-1 do
    begin
      Move(src_pixel_ptr^,dst_pixel_ptr^,bits_per_line);
      Inc (src_pixel_ptr,bmp_src_width);
      Dec (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure BitBlt1Y      (const bmp_src_ptr,bmp_dst_ptr:PInteger ; const bmp_src_width,bmp_dst_width,rct_src_left,rct_src_top,rct_src_width,rct_src_height,rct_dst_left,rct_dst_top:integer                                                 ); inline;                                {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  bits_per_line: integer;
  x,y          : integer;
begin
  src_pixel_ptr:=@bmp_src_ptr[rct_src_left+ rct_src_top                  *bmp_src_width];
  dst_pixel_ptr:=@bmp_dst_ptr[rct_dst_left+(rct_dst_top+rct_src_height-1)*bmp_dst_width];
  bits_per_line:=rct_src_width<<2;
  for y:=0 to    rct_src_height-1 do
    begin
      Move(src_pixel_ptr^,dst_pixel_ptr^,bits_per_line);
      Inc (src_pixel_ptr,bmp_src_width);
      Dec (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
// Blitter1(xy-axis inverted):
procedure BitBlt1XY     (const bmp_src_ptr,bmp_dst_ptr:PInteger ; const bmp_src_width,bmp_dst_width,                                                      rct_dst_left,rct_dst_top:integer; const rct_src:TPtRect                          ); inline;                                {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  src_pixel_ptr:=@bmp_src_ptr[rct_src.left+ rct_src.top                  *bmp_src_width                ];
  dst_pixel_ptr:=@bmp_dst_ptr[rct_dst_left+(rct_dst_top+rct_src.height-1)*bmp_dst_width+rct_src.width-1];
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
         (dst_pixel_ptr-x)^:=
         (src_pixel_ptr+x)^;
      Inc(src_pixel_ptr,bmp_src_width);
      Dec(dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure BitBlt1XY     (const bmp_src_ptr,bmp_dst_ptr:PInteger ; const bmp_src_width,bmp_dst_width,rct_src_left,rct_src_top,rct_src_width,rct_src_height,rct_dst_left,rct_dst_top:integer                                                 ); inline;                                {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  x,y              : integer;
begin
  src_pixel_ptr:=@bmp_src_ptr[rct_src_left+ rct_src_top                  *bmp_src_width                ];
  dst_pixel_ptr:=@bmp_dst_ptr[rct_dst_left+(rct_dst_top+rct_src_height-1)*bmp_dst_width+rct_src_width-1];
  for y:=0 to    rct_src_height-1 do
    begin
     for x:=0 to rct_src_width-1 do
         (dst_pixel_ptr-x)^:=
         (src_pixel_ptr+x)^;
      Inc(src_pixel_ptr,bmp_src_width);
      Dec(dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
// Blitter2:
procedure BitBlt2       (const bmp_src_ptr,bmp_dst_ptr:PInteger ; const bmp_src_width,bmp_dst_width,                                                      rct_dst_left,rct_dst_top:integer; const rct_src:TPtRect                          ); inline;                                {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  d_width1     := bmp_src_width-rct_src.width;
  d_width2     := bmp_dst_width-rct_src.width;
  src_pixel_ptr:=@bmp_src_ptr[rct_src.left+rct_src.width-1+(rct_src.top+rct_src.height-1)*bmp_src_width];
  dst_pixel_ptr:=@bmp_dst_ptr[rct_dst_left+rct_src.width-1+(rct_dst_top+rct_src.height-1)*bmp_dst_width];
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
              dst_pixel_ptr^:=
              src_pixel_ptr^;
          Dec(src_pixel_ptr);
          Dec(dst_pixel_ptr);
        end;
      Dec    (src_pixel_ptr,d_width1);
      Dec    (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
procedure BitBlt2       (const bmp_src_ptr,bmp_dst_ptr:PInteger ; const bmp_src_width,bmp_dst_width,rct_src_left,rct_src_top,rct_src_width,rct_src_height,rct_dst_left,rct_dst_top:integer                                                 ); inline;                                {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  d_width1         := bmp_src_width-rct_src_width;
  d_width2         := bmp_dst_width-rct_src_width;
  src_pixel_ptr    :=@bmp_src_ptr[rct_src_left+rct_src_width-1+(rct_src_top+rct_src_height-1)*bmp_src_width];
  dst_pixel_ptr    :=@bmp_dst_ptr[rct_dst_left+rct_src_width-1+(rct_dst_top+rct_src_height-1)*bmp_dst_width];
  for y:=0 to rct_src_height-1 do
    begin
      for x:=0 to rct_src_width-1 do
        begin
              dst_pixel_ptr^:=
              src_pixel_ptr^ {and color_level_arr[4]};
          Dec(src_pixel_ptr);
          Dec(dst_pixel_ptr);
        end;
      Dec    (src_pixel_ptr,d_width1);
      Dec    (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
// Blitter3:
procedure BitBlt3       (const bmp_src_ptr,bmp_dst_ptr:PInteger ; const bmp_src_width,bmp_dst_width,                                                      rct_dst_left,rct_dst_top:integer; const rct_src:TPtRect; transparent_color:TColor); inline;                                {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  d_width1     := bmp_src_width-rct_src.width;
  d_width2     := bmp_dst_width-rct_src.width;
  src_pixel_ptr:=@bmp_src_ptr[rct_src.left+rct_src.width-1+(rct_src.top+rct_src.height-1)*bmp_src_width];
  dst_pixel_ptr:=@bmp_dst_ptr[rct_dst_left+rct_src.width-1+(rct_dst_top+rct_src.height-1)*bmp_dst_width];
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        begin
          if (src_pixel_ptr^<>transparent_color) then
              dst_pixel_ptr^:=src_pixel_ptr^;
          Dec(src_pixel_ptr);
          Dec(dst_pixel_ptr);
        end;
      Dec    (src_pixel_ptr,d_width1);
      Dec    (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}
procedure BitBlt3       (const bmp_src_ptr,bmp_dst_ptr:PInteger ; const bmp_src_width,bmp_dst_width,rct_src_left,rct_src_top,rct_src_width,rct_src_height,rct_dst_left,rct_dst_top:integer;                        transparent_color:TColor); inline;                                {$region -fold}
var
  src_pixel_ptr    : PInteger;
  dst_pixel_ptr    : PInteger;
  d_width1,d_width2: integer;
  x,y              : integer;
begin
  d_width1         := bmp_src_width-rct_src_width;
  d_width2         := bmp_dst_width-rct_src_width;
  src_pixel_ptr    :=@bmp_src_ptr[rct_src_left+rct_src_width-1+(rct_src_top+rct_src_height-1)*bmp_src_width];
  dst_pixel_ptr    :=@bmp_dst_ptr[rct_dst_left+rct_src_width-1+(rct_dst_top+rct_src_height-1)*bmp_dst_width];
  for y:=0 to rct_src_height-1 do
    begin
      for x:=0 to rct_src_width-1 do
        begin
          if (src_pixel_ptr^<>transparent_color) then
              dst_pixel_ptr^:=
              src_pixel_ptr^;
          Dec(src_pixel_ptr);
          Dec(dst_pixel_ptr);
        end;
      Dec    (src_pixel_ptr,d_width1);
      Dec    (dst_pixel_ptr,d_width2);
    end;
end; {$endregion}

{$endregion}



(****************************** Image transform *******************************) {$region -fold}

// Scale:
procedure SqrtArr1Init(const arr_length :integer=10000 ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  SetLength(sqrt_arr1,arr_length);
  for i:=0 to Length(sqrt_arr1)-1 do
    sqrt_arr1[i]:=FloatToFixed(sqrt(i/Length(sqrt_arr1)));
end; {$endregion}
procedure ImgSclDown0 (const bmp_src_ptr:PInteger; const bmp_dst_ptr:PInteger; const bmp_dst_width,bmp_dst_height:TColor; const ker_w,ker_h:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  bmp_src_ptr2    : PInteger;
  bmp_src_ptr3    : PInteger;
  bmp_dst_ptr2    : PInteger;
  ker_prod_inv    : double;
  ker_prod_inv_   : integer;
  ker_prod        : integer;
  ker_h_prod      : integer;
  ker_w_int       : integer;
  ker_h_int       : integer;
  d_width_ker     : integer;
  width_j_prod    : integer;
  w,h             : integer;
  x,y             : integer;
  i,j             : integer;
  r,g,b           : integer;
  x_mul_ker_w     : integer;
  y_mul_ker_h_prod: integer;
begin
  ker_w_int       :=ker_w-1;
  ker_h_int       :=ker_h-1;
  ker_prod        :=ker_w*ker_h;
  ker_prod_inv    :=1/ker_prod;
  ker_prod_inv_   :=FloatToFixed(ker_prod_inv);
  ker_h_prod      :=ker_h*bmp_dst_width;
  w               :=Trunc(bmp_dst_width /ker_w)-1;
  h               :=Trunc(bmp_dst_height/ker_h)-1;
  d_width_ker     :=bmp_dst_width-w-1;
  bmp_src_ptr2    :=bmp_src_ptr;
  bmp_dst_ptr2    :=bmp_dst_ptr;
  y_mul_ker_h_prod:=0;
  for y:=0 to h do
    begin
      x_mul_ker_w:=0;
      for x:=0 to w do
        begin
          bmp_src_ptr3:=Unaligned(bmp_src_ptr2+x_mul_ker_w+y_mul_ker_h_prod);
          width_j_prod:=0;
          r           :=0;
          g           :=0;
          b           :=0;
          for j:=0 to ker_h_int do
            begin
              bmp_src_ptr3+=width_j_prod;
              for i:=0 to ker_w_int do
                begin
                  r+=PRGBA(bmp_src_ptr3)^.r;
                  g+=PRGBA(bmp_src_ptr3)^.g;
                  b+=PRGBA(bmp_src_ptr3)^.b;
                  Inc(bmp_src_ptr3);
                end;
              Inc(width_j_prod,bmp_dst_width);
            end;
          bmp_dst_ptr2^:=RGB((r*ker_prod_inv_)>>16{Trunc(r*ker_prod_inv)},
                             (g*ker_prod_inv_)>>16{Trunc(g*ker_prod_inv)},
                             (b*ker_prod_inv_)>>16{Trunc(b*ker_prod_inv)});
          Inc(bmp_dst_ptr2);
          Inc(x_mul_ker_w,ker_w);
        end;
      Inc(bmp_dst_ptr2,d_width_ker);
      Inc(y_mul_ker_h_prod,ker_h_prod);
    end;
end; {$endregion}
procedure ImgSclDown1 (fast_img_data_ptr:PFastImageData); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_area          : TPtPosF;
  fip_scale_data_var: TFIPScaleData1;
  bmp_bkgnd_ptr2    : PInteger;
  bmp_color_ptr2    : PInteger;
  d0,d1,d2,d3       : double;
  x,y,h0,h1         : integer;
  b0                : boolean;
begin
  with fast_img_data_ptr^,fip_scale_data_var do
    begin
      m0            :=scl_mul.x*rct_ent_f.left+(1-scl_mul.x)*pvt0.x;
      m1            :=scl_mul.y*rct_ent_f.top +(1-scl_mul.y)*pvt0.y;
      bmp_color_ptr2:=bmp_color_ptr;
      for y:=0 to rct_ent.height-1 do
        begin
          d1        :=scl_mul.y*y;
          h1        :=Trunc  (d1+m1);
          pix_area.y:=(h1+1)-(d1+m1);
          h1        *=bmp_bkgnd_width;
          if (pix_area.y<scl_mul.y) then
            begin
              d2:=sqrt(          pix_area.y)*ONE_SHL_16;
              d3:=sqrt(scl_mul.y-pix_area.y)*ONE_SHL_16;
              for x:=0 to rct_ent.width-1 do
                begin
                  d0            :=scl_mul.x*x;
                  h0            :=Trunc  (d0+m0);
                  pix_area.x    :=(h0+1)-(d0+m0);
                  b0            :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x  :=scl_mul.x;
                  bmp_bkgnd_ptr2:=bmp_bkgnd_ptr+h0+h1;
                    ScalePix128B(MSK2_128,(bmp_bkgnd_ptr2+0)^,bmp_color_ptr2^,Trunc(sqrt(          pix_area.x)*d2),Trunc(sqrt(          pix_area.x)*d3),bmp_bkgnd_width);
                  if b0 then
                    ScalePix128B(MSK2_128,(bmp_bkgnd_ptr2+1)^,bmp_color_ptr2^,Trunc(sqrt(scl_mul.x-pix_area.x)*d2),Trunc(sqrt(scl_mul.x-pix_area.x)*d3),bmp_bkgnd_width);
                  Inc(bmp_color_ptr2);
                end;
            end
          else
            begin
              d2:=sqrt(scl_mul.y)*ONE_SHL_16;
              for x:=0 to rct_ent.width-1 do
                begin
                  d0            :=scl_mul.x*x;
                  h0            :=Trunc  (d0+m0);
                  pix_area.x    :=(h0+1)-(d0+m0);
                  b0            :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x  :=scl_mul.x;
                  bmp_bkgnd_ptr2:=bmp_bkgnd_ptr+h0+h1;
                  ScalePix128A(MSK2_128,bmp_bkgnd_ptr2^,bmp_color_ptr2^,Trunc(sqrt(pix_area.x)*d2),Trunc(sqrt(scl_mul.x-pix_area.x)*d2),b0);
                  Inc(bmp_color_ptr2);
                end;
            end;
        end;
    end;
end; {$endregion}
// m0=0, m1=0:
procedure ImgSclDown2 (fast_img_data_ptr:PFastImageData); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_area          : TPtPosF;
  fip_scale_data_var: TFIPScaleData1;
  bmp_bkgnd_ptr2    : PInteger;
  bmp_color_ptr2    : PInteger;
  d0,d1,d2,d3       : double;
  x,y,h0,h1         : integer;
  b0                : boolean;
begin
  with fast_img_data_ptr^,fip_scale_data_var do
    begin
      bmp_color_ptr2:=bmp_color_ptr;
      d1            :=-scl_mul.y;
      for y:=0 to rct_ent.height-1 do
        begin
          d1        +=scl_mul.y;
          h1        :=Trunc  (d1);
          pix_area.y:=(h1+1)-(d1);
          h1        *=bmp_bkgnd_width;
          d0        :=-scl_mul.x;
          if (pix_area.y<scl_mul.y) then
            begin
              d2:=(          pix_area.y)*Length(sqrt_arr1);
              d3:=(scl_mul.y-pix_area.y)*Length(sqrt_arr1);
              for x:=0 to rct_ent.width-1 do
                begin
                  d0            +=scl_mul.x;               // f     =sqrt((1-Frac(d0))*(1-Frac(d1)));
                  h0            :=Trunc  (d0);             // min(f)=sqrt((1-Frac(scl_mul.x*(rct_ent.width-1)))*(1-Frac(scl_mul.y*(rct_ent.height-1))));
                  pix_area.x    :=(h0+1)-(d0);             // max(f)=1;
                  b0            :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x  :=scl_mul.x;
                  bmp_bkgnd_ptr2:=bmp_bkgnd_ptr+h0+h1;
                    ScalePix128B(MSK2_128,(bmp_bkgnd_ptr2+0)^,bmp_color_ptr2^,sqrt_arr1[Trunc((          pix_area.x)*d2)],sqrt_arr1[Trunc((          pix_area.x)*d3)],bmp_bkgnd_width);
                  if b0 then
                    ScalePix128B(MSK2_128,(bmp_bkgnd_ptr2+1)^,bmp_color_ptr2^,sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d3)],bmp_bkgnd_width);
                  Inc(bmp_color_ptr2);
                end;
            end
          else
            begin
              d2:=scl_mul.y*Length(sqrt_arr1);
              for x:=0 to rct_ent.width-1 do
                begin
                  d0            +=scl_mul.x;
                  h0            :=Trunc  (d0);
                  pix_area.x    :=(h0+1)-(d0);
                  b0            :=(pix_area.x<scl_mul.x);
                  if (not b0) then
                    pix_area.x  :=scl_mul.x;
                  bmp_bkgnd_ptr2:=bmp_bkgnd_ptr+h0+h1;
                  ScalePix128A(MSK2_128,bmp_bkgnd_ptr2^,bmp_color_ptr2^,sqrt_arr1[Trunc(pix_area.x*d2)],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*d2)],b0);
                  Inc(bmp_color_ptr2);
                end;
            end;
        end;
    end;
end; {$endregion}
// m0=0, m1=0, scl_mul.x=1:
procedure ImgSclDown3 (fast_img_data_ptr:PFastImageData); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_area          : TPtPosF;
  fip_scale_data_var: TFIPScaleData1;
  bmp_color_ptr2    : PInteger;
  d1,d2,d3          : double;
  x,y,h1            : integer;
begin
  with fast_img_data_ptr^,fip_scale_data_var do
    begin
      bmp_color_ptr2:=bmp_color_ptr;
      for y:=0 to rct_ent.height-1 do
        begin
          d1        :=scl_mul.y*y;
          h1        :=Trunc  (d1);
          pix_area.y:=(h1+1)-(d1);
          h1        *=bmp_bkgnd_width;
          if (pix_area.y<scl_mul.y) then
            begin
              d2:=(          pix_area.y)*Length(sqrt_arr1);
              d3:=(scl_mul.y-pix_area.y)*Length(sqrt_arr1);
              for x:=0 to rct_ent.width-1 do
                begin
                  pix_area.x:=1;
                  ScalePix128B(MSK2_128,(bmp_bkgnd_ptr+x+h1)^,bmp_color_ptr2^,sqrt_arr1[Trunc(d2)],sqrt_arr1[Trunc(d3)],bmp_bkgnd_width);
                  Inc(bmp_color_ptr2);
                end;
            end
          else
            begin
              d2:=scl_mul.y*Length(sqrt_arr1);
              for x:=0 to rct_ent.width-1 do
                begin
                  pix_area.x:=1;
                  ScalePix128A(MSK2_128,(bmp_bkgnd_ptr+x+h1)^,bmp_color_ptr2^,sqrt_arr1[Trunc(d2)],0,False);
                  Inc(bmp_color_ptr2);
                end;
            end;
        end;
    end;
end; {$endregion}
// m0=0, m1=0, scl_mul.y=1:
procedure ImgSclDown4 (fast_img_data_ptr:PFastImageData); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pix_area          : TPtPosF;
  fip_scale_data_var: TFIPScaleData1;
  bmp_bkgnd_ptr2    : PInteger;
  bmp_color_ptr2    : PInteger;
  d0                : double;
  x,y,h0,h1         : integer;
  b0                : boolean;
begin
  with fast_img_data_ptr^,fip_scale_data_var do
    begin
      bmp_color_ptr2:=bmp_color_ptr;
      for y:=0 to rct_ent.height-1 do
        begin
          h1:=y*bmp_bkgnd_width;
          d0:=-scl_mul.x;
          for x:=0 to rct_ent.width-1 do
            begin
              d0        +=scl_mul.x;
              h0        :=Trunc  (d0);
              pix_area.x:=(h0+1)-(d0);
              b0        :=(pix_area.x<scl_mul.x);
              if (not b0) then
                pix_area.x  :=scl_mul.x;
              bmp_bkgnd_ptr2:=bmp_bkgnd_ptr+h0+h1;
              ScalePix128A(MSK2_128,bmp_bkgnd_ptr2^,bmp_color_ptr2^,sqrt_arr1[Trunc(pix_area.x*Length(sqrt_arr1))],sqrt_arr1[Trunc((scl_mul.x-pix_area.x)*Length(sqrt_arr1))],b0);
              Inc(bmp_color_ptr2);
            end;
        end;
    end;
end; {$endregion}
// Rotate:
procedure ImgRotLoop0 (                  const rct_src        :TPtRect;       bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_dst_width,d_width,c,s,v,w,lt,tp,rt,bt:integer; const mask_alpha:TColor                                                                              ); inline; deprecated; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,i,j: integer;
begin
  for j:=0 to rct_src.height-1 do
    begin
      x:=v+j*s;
      y:=w-j*c;
      for i:=0 to rct_src.width-1 do
        begin
              bmp_dst_ptr[(x>>16)+(y>>16)*bmp_dst_width]:=
              bmp_src_ptr^;
          Inc(bmp_src_ptr);
          x-=c;
          y-=s;
        end;
      Inc(bmp_src_ptr,d_width);
    end;
end; {$endregion}
procedure ImgRotLoop1 (                  const rct_src        :TPtRect;       bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_dst_width,d_width,c,s,v,w,lt,tp,rt,bt:integer; const mask_alpha:TColor                                                                              ); inline; deprecated; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,i,j: integer;
begin
  for j:=0 to rct_src.height-1 do
    begin
      x:=v+j*s;
      y:=w-j*c;
      for i:=0 to rct_src.width-1 do
        begin
          if (x>lt) and (x<rt) and (y>tp) and (y<bt) then
              bmp_dst_ptr[(x>>16)+(y>>16)*bmp_dst_width]:=
              bmp_src_ptr^;
          Inc(bmp_src_ptr);
          x-=c;
          y-=s;
        end;
      Inc(bmp_src_ptr,d_width);
    end;
end; {$endregion}
procedure ImgRotLoop2 (                  const rct_src        :TPtRect;       bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_dst_width,d_width,c,s,v,w,lt,tp,rt,bt:integer; const mask_alpha:TColor                                                                              ); inline; deprecated; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,i,j: integer;
begin
  for j:=0 to rct_src.height-1 do
    begin
      x:=v+j*s;
      y:=w-j*c;
      for i:=0 to rct_src.width-1 do
        begin
              bmp_dst_ptr[(x>>16)+(y>>16)*bmp_dst_width]:=
             (bmp_src_ptr^ and NT_BIT_MASK_ALPHA2)+mask_alpha; //bmp_src_ptr^<<8>>8+mask_alpha;
          Inc(bmp_src_ptr);
          x-=c;
          y-=s;
        end;
      Inc(bmp_src_ptr,d_width);
    end;
end; {$endregion}
procedure ImgRotLoop3 (                  const rct_src        :TPtRect;       bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_dst_width,d_width,c,s,v,w,lt,tp,rt,bt:integer; const mask_alpha:TColor                                                                              ); inline; deprecated; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,i,j: integer;
begin
  for j:=0 to rct_src.height-1 do
    begin
      x:=v+j*s;
      y:=w-j*c;
      for i:=0 to rct_src.width-1 do
        begin
          if (x>lt) and (x<rt) and (y>tp) and (y<bt) then
              bmp_dst_ptr[(x>>16)+(y>>16)*bmp_dst_width]:=
             (bmp_src_ptr^ and NT_BIT_MASK_ALPHA2)+mask_alpha; //bmp_src_ptr^<<8>>8+mask_alpha;
          Inc(bmp_src_ptr);
          x-=c;
          y-=s;
        end;
      Inc(bmp_src_ptr,d_width);
    end;
end; {$endregion}
procedure ImgRotLoop4 (                  const rct_src        :TPtRect;       bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_dst_width,d_width,c,s,v,w,lt,tp,rt,bt:integer; const mask_alpha:TColor                                                                              ); inline; deprecated; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,i,j: integer;
begin
  for j:=0 to rct_src.height-1 do
    begin
      x:=v+j*s;
      y:=w-j*c;
      for i:=0 to rct_src.width-1 do
        begin
          bmp_dst_ptr[(x>>16)+(y>>16)*bmp_dst_width]:=mask_alpha;
          x-=c;
          y-=s;
        end;
    end;
end; {$endregion}
procedure ImgRotLoop5 (                  const rct_src        :TPtRect;       bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_dst_width,d_width,c,s,v,w,lt,tp,rt,bt:integer; const mask_alpha:TColor                                                                              ); inline; deprecated; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  x,y,i,j: integer;
begin
  for j:=0 to rct_src.height-1 do
    begin
      x:=v+j*s;
      y:=w-j*c;
      for i:=0 to rct_src.width-1 do
        begin
          if (x>lt) and (x<rt) and (y>tp) and (y<bt) then
            bmp_dst_ptr[(x>>16)+(y>>16)*bmp_dst_width]:=mask_alpha;
          x-=c;
          y-=s;
        end;
    end;
end; {$endregion}
procedure ImgRot1     (const pvt:TPtPos; const rct_src,rct_clp:TPtRect; const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const angle:double; const x,y :integer; const add_alpha_mask:byte; var bounding_rct:TPtRect; const mask_alpha:TColor); inline; deprecated; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst     : TPtRect;
  rct_src1    : TPtRect;
  rct_src2    : TPtRect;
  bmp_src_ptr2: PInteger;
  c           : double =0.0;
  s           : double =0.0;
  v           : double =0.0;
  w           : double =0.0;
  c2          : integer=000;
  s2          : integer=000;
  v2          : integer=000;
  w2          : integer=000;
  r,k,d_width : integer;
  lt,tp,rt,bt : integer;
  b           : byte   =001;
begin

  {} {$region -fold}
  if (Trunc(angle) mod 360=0) then
    begin
      rct_src1:=PtRct
      (
        x,
        y,
        x+rct_src.width,
        y+rct_src.height
      );
      rct_dst :=ClippedRct(rct_clp,rct_src1) ;
      if (rct_dst.width=0) or (rct_dst.height=0) then
        Exit;
      r       :=rct_src.width -(rct_dst.right -rct_dst.left);
      k       :=rct_src.height-(rct_dst.bottom-rct_dst.top );
      rct_src2:=PtRct
      (
        rct_src.left+r,
        rct_src.top +k,
        rct_src.right ,
        rct_src.bottom
      );
      BitBlt1
      (
        bmp_src_ptr,
        bmp_dst_ptr,
        bmp_src_width,
        bmp_dst_width,
        rct_dst.left,
        rct_dst.top,
        rct_src2
      );
      Exit;
    end; {$endregion}

  {} {$region -fold}
  GetRot
  (
    PtPos
    (
      x-rct_src.left+pvt.x,
      y-rct_src.top +pvt.y
    ),
    angle,
    c,
    s,
    v,
    w
  ); {$endregion}

  {} {$region -fold}
  b:=1;
  bounding_rct:=ClippedRctB
  (
    rct_clp,
    PtsRot
    (
      PtRct
      (
        x,
        y,
        x-rct_src.left+rct_src.right,
        y-rct_src.top +rct_src.bottom
      ),
      angle,
      c,
      s,
      v,
      w
    ),
    b
  ); {$endregion}

  {} {$region -fold}
  if (b=2) then
    Exit
  else
    begin
      GetRot
      (
        PtPos
        (
          x-rct_src.left+pvt.x,
          y-rct_src.top +pvt.y
        ),
        angle,
        c2,
        s2,
        v2,
        w2,
        x,
        y
      );
      lt          :=rct_clp.left  <<16;
      rt          :=rct_clp.right <<16;
      tp          :=rct_clp.top   <<16;
      bt          :=rct_clp.bottom<<16;
      d_width     :=bmp_src_width-rct_src.width;
      bmp_src_ptr2:=Unaligned(bmp_src_ptr+rct_src.left+rct_src.top*bmp_dst_width);
    end;
  {
  add_alpha_mask values:
  0: copy source to destination without mask;
  1: add mask to alpha channel of destination;
  2: fill destination with specifed value
  }
  case add_alpha_mask of
    0:
      begin
        if (b=0) then
          ImgRotLoop0(rct_src,bmp_src_ptr2,bmp_dst_ptr,bmp_dst_width,d_width,c2,s2,v2,w2,lt,tp,rt,bt,mask_alpha)
        else
          ImgRotLoop1(rct_src,bmp_src_ptr2,bmp_dst_ptr,bmp_dst_width,d_width,c2,s2,v2,w2,lt,tp,rt,bt,mask_alpha);
      end;
    1:
      begin
        if (b=0) then
          ImgRotLoop2(rct_src,bmp_src_ptr2,bmp_dst_ptr,bmp_dst_width,d_width,c2,s2,v2,w2,lt,tp,rt,bt,mask_alpha)
        else
          ImgRotLoop3(rct_src,bmp_src_ptr2,bmp_dst_ptr,bmp_dst_width,d_width,c2,s2,v2,w2,lt,tp,rt,bt,mask_alpha);
      end;
    2:
      begin
        if (b=0) then
          ImgRotLoop4(rct_src,bmp_src_ptr2,bmp_dst_ptr,bmp_dst_width,d_width,c2,s2,v2,w2,lt,tp,rt,bt,mask_alpha)
        else
          ImgRotLoop5(rct_src,bmp_src_ptr2,bmp_dst_ptr,bmp_dst_width,d_width,c2,s2,v2,w2,lt,tp,rt,bt,mask_alpha);
      end;
  end; {$endregion}

end; {$endregion}
procedure ImgRot2     (const pvt:TPtPos; const rct_src,rct_clp:TPtRect; const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const angle:double; const x,y,inn_wnd_mrg,bmp_src_height:integer                                                    ); inline; deprecated; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_dst        : TPtRect;
  rct_src1       : TPtRect;
  rct_src2       : TPtRect;
  rct_src3       : TPtRect;
  bmp_src_ptr2   : PInteger;
  c              : double=0.0;
  s              : double=0.0;
  v              : double=0.0;
  w              : double=0.0;
  x_,y_          : double;
  i,j,r,k,d_width: integer;
  b              : byte;
  v2,w2,ssx,ssy,ssw,ssh,addy,xx,yy,L2,T2,R2,B2,sx,sy,dx,dy,sw,sh,dw,SinA,CosA: integer;
begin
  {if (Trunc(angle) mod 360=0) then
    begin
      rct_src1:=PtRct
      (
        x,
        y,
        x+rct_src.width,
        y+rct_src.height
      );
      rct_dst :=ClippedRct(rct_clp,rct_src1) ;
      if (rct_dst.width=0) or (rct_dst.height=0) then
        Exit;
      r       :=rct_src.width -(rct_dst.right -rct_dst.left);
      k       :=rct_src.height-(rct_dst.bottom-rct_dst.top );
      rct_src2:=PtRct
      (
        rct_src.left+r,
        rct_src.top +k,
        rct_src.right ,
        rct_src.bottom
      );
      BitBlt1
      (
        bmp_src_ptr,
        bmp_dst_ptr,
        bmp_src_width,
        bmp_dst_width,
        rct_dst.left-pvt.x,
        rct_dst.top -pvt.y,
        rct_src2
      );
      Exit;
    end;
  GetRot
  (
    PtPos
    (
      x-rct_src.left+pvt.x,
      y-rct_src.top +pvt.y
    ),
    angle,
    c,
    s,
    v,
    w
  );
  rct_src3:=ClippedRctB
  (
    rct_clp,
    PtsRot
    (
      PtRct
      (
        x,
        y,
        x-rct_src.left+rct_src.right,
        y-rct_src.top +rct_src.bottom
      ),
      angle,
      c,
      s,
      v,
      w
    ),
    b
  );
  if (b=2) then
    Exit
  else
    begin
      sx  :=pvt.x                                 ;
      sy  :=pvt.y                                 ;
      sw  :=bmp_src_width                         ;
      sh  :=bmp_src_height                        ;
      dx  :=x                                     ;
      dy  :=y                                     ;
      dw  :=bmp_dst_width                         ;
      L2  :=rct_src3.left                         ;
      T2  :=rct_src3.top                          ;
      R2  :=rct_src3.right                        ;
      B2  :=rct_src3.bottom                       ;
      CosA:=Round( cos(pi*(1+angle/180)+pi)*65536);
      SinA:=Round(-sin(pi*(1+angle/180)+pi)*65536);
      ssx :=(sx<<16)-(dx-L2)*CosA                 ;
      ssy :=(sy<<16)-(dx-L2)*SinA                 ;
      ssw := sw<<16                               ;
      ssh := sh<<16                               ;
      addy:= T2*dw                                ;
      T2  -= dy                                   ;
      B2  -= dy                                   ;
      xx  :=ssx-T2*SinA                           ;
      yy  :=ssy+T2*CosA                           ;
    end;
  if (b=0) then
    begin
      for j:=T2 to B2 do
        begin
          xx:=ssx-j*SinA;
          yy:=ssy+j*CosA;
          for i:=L2 to R2 do
            begin
              if ((xx>=0) and (xx<ssw) and (yy>=0) and (yy<ssh)) then
              {if (i>=rct_clp.left) and (i<(rct_clp.right -1)) and
                 (yy>>16>=rct_clp.top ) and (yy>>16<(rct_clp.bottom-1)) then}
                (bmp_dst_ptr+addy+i)^:={clGreen}(bmp_src_ptr+sw*(yy>>16)+(xx>>16))^;
              xx+=CosA;
              yy+=SinA;
            end;
          addy+=dw;
        end;
    end
  else
  if (b=1) then
    begin
      for j:=T2 to B2 do
        begin
          xx:=ssx-j*SinA;
          yy:=ssy+j*CosA;
          for i:=L2 to R2 do
            begin
              if ((xx>=0) and (xx<ssw) and (yy>=0) and (yy<ssh)) then
              {if (i>=rct_clp.left) and (i<(rct_clp.right -1)) and
                 (yy>>16>=rct_clp.top ) and (yy>>16<(rct_clp.bottom-1)) then}
                (bmp_dst_ptr+addy+i)^:={clGreen}(bmp_src_ptr+sw*(yy>>16)+(xx>>16))^;
              xx+=CosA;
              yy+=SinA;
            end;
          addy+=dw;
        end;
    end;}
end; {$endregion}

{$endregion}



(****************************** Post-processing *******************************) {$region -fold}

//
procedure PPBlurProcInit;                                                                                                                                                                                                                                                                                                                     {$region -fold}
begin

  {RGB}
  PPBlurProcArr[00]:=Unaligned(@BlurRGBProc0);
  PPBlurProcArr[01]:=Unaligned(@BlurRGBProc1);
  PPBlurProcArr[02]:=Unaligned(@BlurRGBProc2);
  PPBlurProcArr[03]:=Unaligned(@BlurRGBProc3);
  PPBlurProcArr[04]:=Unaligned(@BlurRGBProc4);
  PPBlurProcArr[05]:=Unaligned(@BlurRGBProc5);
  PPBlurProcArr[06]:=Unaligned(@BlurRGBProc6);
  PPBlurProcArr[07]:=Unaligned(@BlurRGBProc7);
  PPBlurProcArr[08]:=Unaligned(@BlurRGBProc8);

  {RRB}
  PPBlurProcArr[10]:=Unaligned(@BlurRRBProc0);
  PPBlurProcArr[11]:=Unaligned(@BlurRRBProc1);
  PPBlurProcArr[12]:=Unaligned(@BlurRRBProc2);
  PPBlurProcArr[13]:=Unaligned(@BlurRRBProc3);
  PPBlurProcArr[14]:=Unaligned(@BlurRRBProc4);
  PPBlurProcArr[15]:=Unaligned(@BlurRRBProc5);
  PPBlurProcArr[16]:=Unaligned(@BlurRRBProc6);
  PPBlurProcArr[17]:=Unaligned(@BlurRRBProc7);
  PPBlurProcArr[18]:=Unaligned(@BlurRRBProc8);

  {RGR}
  PPBlurProcArr[20]:=Unaligned(@BlurRGRProc0);
  PPBlurProcArr[21]:=Unaligned(@BlurRGRProc1);
  PPBlurProcArr[22]:=Unaligned(@BlurRGRProc2);
  PPBlurProcArr[23]:=Unaligned(@BlurRGRProc3);
  PPBlurProcArr[24]:=Unaligned(@BlurRGRProc4);
  PPBlurProcArr[25]:=Unaligned(@BlurRGRProc5);
  PPBlurProcArr[26]:=Unaligned(@BlurRGRProc6);
  PPBlurProcArr[27]:=Unaligned(@BlurRGRProc7);
  PPBlurProcArr[28]:=Unaligned(@BlurRGRProc8);

  {GGB}
  PPBlurProcArr[30]:=Unaligned(@BlurGGBProc0);
  PPBlurProcArr[31]:=Unaligned(@BlurGGBProc1);
  PPBlurProcArr[32]:=Unaligned(@BlurGGBProc2);
  PPBlurProcArr[33]:=Unaligned(@BlurGGBProc3);
  PPBlurProcArr[34]:=Unaligned(@BlurGGBProc4);
  PPBlurProcArr[35]:=Unaligned(@BlurGGBProc5);
  PPBlurProcArr[36]:=Unaligned(@BlurGGBProc6);
  PPBlurProcArr[37]:=Unaligned(@BlurGGBProc7);
  PPBlurProcArr[38]:=Unaligned(@BlurGGBProc8);

  {RGG}
  PPBlurProcArr[40]:=Unaligned(@BlurRGGProc0);
  PPBlurProcArr[41]:=Unaligned(@BlurRGGProc1);
  PPBlurProcArr[42]:=Unaligned(@BlurRGGProc2);
  PPBlurProcArr[43]:=Unaligned(@BlurRGGProc3);
  PPBlurProcArr[44]:=Unaligned(@BlurRGGProc4);
  PPBlurProcArr[45]:=Unaligned(@BlurRGGProc5);
  PPBlurProcArr[46]:=Unaligned(@BlurRGGProc6);
  PPBlurProcArr[47]:=Unaligned(@BlurRGGProc7);
  PPBlurProcArr[48]:=Unaligned(@BlurRGGProc8);

  {BGB}
  PPBlurProcArr[50]:=Unaligned(@BlurBGBProc0);
  PPBlurProcArr[51]:=Unaligned(@BlurBGBProc1);
  PPBlurProcArr[52]:=Unaligned(@BlurBGBProc2);
  PPBlurProcArr[53]:=Unaligned(@BlurBGBProc3);
  PPBlurProcArr[54]:=Unaligned(@BlurBGBProc4);
  PPBlurProcArr[55]:=Unaligned(@BlurBGBProc5);
  PPBlurProcArr[56]:=Unaligned(@BlurBGBProc6);
  PPBlurProcArr[57]:=Unaligned(@BlurBGBProc7);
  PPBlurProcArr[58]:=Unaligned(@BlurBGBProc8);

  {RBB}
  PPBlurProcArr[60]:=Unaligned(@BlurRBBProc0);
  PPBlurProcArr[61]:=Unaligned(@BlurRBBProc1);
  PPBlurProcArr[62]:=Unaligned(@BlurRBBProc2);
  PPBlurProcArr[63]:=Unaligned(@BlurRBBProc3);
  PPBlurProcArr[64]:=Unaligned(@BlurRBBProc4);
  PPBlurProcArr[65]:=Unaligned(@BlurRBBProc5);
  PPBlurProcArr[66]:=Unaligned(@BlurRBBProc6);
  PPBlurProcArr[67]:=Unaligned(@BlurRBBProc7);
  PPBlurProcArr[68]:=Unaligned(@BlurRBBProc8);

  {RRR}
  PPBlurProcArr[70]:=Unaligned(@BlurRRRProc0);
  PPBlurProcArr[71]:=Unaligned(@BlurRRRProc1);
  PPBlurProcArr[72]:=Unaligned(@BlurRRRProc2);
  PPBlurProcArr[73]:=Unaligned(@BlurRRRProc3);
  PPBlurProcArr[74]:=Unaligned(@BlurRRRProc4);
  PPBlurProcArr[75]:=Unaligned(@BlurRRRProc5);
  PPBlurProcArr[76]:=Unaligned(@BlurRRRProc6);
  PPBlurProcArr[77]:=Unaligned(@BlurRRRProc7);
  PPBlurProcArr[78]:=Unaligned(@BlurRRRProc8);

  {GGG}
  PPBlurProcArr[80]:=Unaligned(@BlurGGGProc0);
  PPBlurProcArr[81]:=Unaligned(@BlurGGGProc1);
  PPBlurProcArr[82]:=Unaligned(@BlurGGGProc2);
  PPBlurProcArr[83]:=Unaligned(@BlurGGGProc3);
  PPBlurProcArr[84]:=Unaligned(@BlurGGGProc4);
  PPBlurProcArr[85]:=Unaligned(@BlurGGGProc5);
  PPBlurProcArr[86]:=Unaligned(@BlurGGGProc6);
  PPBlurProcArr[87]:=Unaligned(@BlurGGGProc7);
  PPBlurProcArr[88]:=Unaligned(@BlurGGGProc8);

  {BBB}
  PPBlurProcArr[90]:=Unaligned(@BlurBBBProc0);
  PPBlurProcArr[91]:=Unaligned(@BlurBBBProc1);
  PPBlurProcArr[92]:=Unaligned(@BlurBBBProc2);
  PPBlurProcArr[93]:=Unaligned(@BlurBBBProc3);
  PPBlurProcArr[94]:=Unaligned(@BlurBBBProc4);
  PPBlurProcArr[95]:=Unaligned(@BlurBBBProc5);
  PPBlurProcArr[96]:=Unaligned(@BlurBBBProc6);
  PPBlurProcArr[97]:=Unaligned(@BlurBBBProc7);
  PPBlurProcArr[98]:=Unaligned(@BlurBBBProc8);

end; {$endregion}
procedure PPDec0ProcInit;                                                                                                                                                                                                                                                                                                                     {$region -fold}
begin
  PPDec0ProcArr[00]:=Unaligned(@AlphablendDec0);
  PPDec0ProcArr[01]:=Unaligned(@AdditiveDec0  );
  PPDec0ProcArr[02]:=Unaligned(@AlphablendDec0);
  PPDec0ProcArr[03]:=Unaligned(@InverseDec0   );
  PPDec0ProcArr[04]:=Unaligned(@HighlightDec0 );
  PPDec0ProcArr[05]:=Unaligned(@DarkenDec0    );
  PPDec0ProcArr[06]:=Unaligned(@GrayscaleRDec0);
  PPDec0ProcArr[07]:=Unaligned(@GrayscaleGDec0);
  PPDec0ProcArr[08]:=Unaligned(@GrayscaleBDec0);
  PPDec0ProcArr[09]:=Unaligned(@AlphablendDec0);
  PPDec0ProcArr[10]:=Unaligned(@ColorizeRDec0 );
  PPDec0ProcArr[11]:=Unaligned(@ColorizeGDec0 );
  PPDec0ProcArr[12]:=Unaligned(@ColorizeBDec0 );
end; {$endregion}
procedure ArrFilProcInit;                                                                                                                                                                                                                                                                                                                     {$region -fold}
begin
  ArrFilProcArr[00]:=Unaligned(@ArrFilProc00);
  ArrFilProcArr[01]:=Unaligned(@ArrFilProc01);
  ArrFilProcArr[02]:=Unaligned(@ArrFilProc02);
  ArrFilProcArr[03]:=Unaligned(@ArrFilProc03);
  ArrFilProcArr[04]:=Unaligned(@ArrFilProc04);
  ArrFilProcArr[05]:=Unaligned(@ArrFilProc05);
  ArrFilProcArr[06]:=Unaligned(@ArrFilProc06);
  ArrFilProcArr[07]:=Unaligned(@ArrFilProc07);
  ArrFilProcArr[08]:=Unaligned(@ArrFilProc08);
  ArrFilProcArr[09]:=Unaligned(@ArrFilProc09);
  ArrFilProcArr[10]:=Unaligned(@ArrFilProc10);
  ArrFilProcArr[11]:=Unaligned(@ArrFilProc11);
  ArrFilProcArr[12]:=Unaligned(@ArrFilProc12);
  ArrFilProcArr[13]:=Unaligned(@ArrFilProc13);
  ArrFilProcArr[14]:=Unaligned(@ArrFilProc14);
  ArrFilProcArr[15]:=Unaligned(@ArrFilProc15);
  ArrFilProcArr[16]:=Unaligned(@ArrFilProc16);
  ArrFilProcArr[17]:=Unaligned(@ArrFilProc17);
  ArrFilProcArr[18]:=Unaligned(@ArrFilProc18);
  ArrFilProcArr[19]:=Unaligned(@ArrFilProc19);
  ArrFilProcArr[20]:=Unaligned(@ArrFilProc20);
  ArrFilProcArr[21]:=Unaligned(@ArrFilProc21);
  ArrFilProcArr[22]:=Unaligned(@ArrFilProc22);
  ArrFilProcArr[23]:=Unaligned(@ArrFilProc23);
  ArrFilProcArr[24]:=Unaligned(@ArrFilProc24);
  ArrFilProcArr[25]:=Unaligned(@ArrFilProc25);
end; {$endregion}
// (Flood fill) Заливка:
procedure PPFloodFillAdd     (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect                                                                                                                                                                           ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
         (dst_pixel_ptr+x)^+=1;
      Inc(dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPFloodFillSub     (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect                                                                                                                                                                           ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
         (dst_pixel_ptr+x)^-=1;
      Inc(dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPFloodFill        (                   const             bmp_dst_ptr:PByte;    const               bmp_dst_width:TColor; const         rct_dst:TPtRect                                                                                                                                                                           ); {$region -fold}
var
  dst_pixel_ptr: PByte;
  y            : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      FillByte(dst_pixel_ptr^,rct_dst.width,1);
      Inc     (dst_pixel_ptr ,bmp_dst_width  );
    end;
end; {$endregion}
procedure PPFloodFill        (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect;                            const col:TColor                               ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  y            : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      FillDWord(dst_pixel_ptr^,rct_dst.width,col);
      Inc      (dst_pixel_ptr ,bmp_dst_width    );
    end;
end; {$endregion}
procedure PPFloodFill        (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect;                            const col:TColor; flood_fill_inc :boolean      ); {$region -fold}
var
  dst_pixel_ptr    : PInteger;
  y,bmp_dst_width_ : integer;
    rct_dst_height_: integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  bmp_dst_width_:=bmp_dst_width<<1;
  if flood_fill_inc then
    begin
      dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+(rct_dst.top+0)*bmp_dst_width;
      if Odd(rct_dst.height) then
        rct_dst_height_:=rct_dst.height>>1
      else
        rct_dst_height_:=rct_dst.height>>1-1;
    end
  else
    begin
      dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+(rct_dst.top+1)*bmp_dst_width;
      if not Odd(rct_dst.height) then
        rct_dst_height_:=rct_dst.height>>1
      else
        rct_dst_height_:=rct_dst.height>>1-1;
    end;
  for y:=0 to rct_dst_height_ do
    begin
      FillDWord(dst_pixel_ptr^,rct_dst.width,col);
      Inc      (dst_pixel_ptr ,bmp_dst_width_   );
    end;
end; {$endregion}
procedure PPFloodFill        (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const rct_dst_width,rct_dst_height,first_pix_pos:integer; const col:TColor                               ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  pix          : integer;
  x,y          : integer;
begin
  if (rct_dst_width <=0) or
     (rct_dst_height<=0) then
    Exit;
  pix          :=RGB(TRGBA(col).b,
                     TRGBA(col).g,
                     TRGBA(col).r);
  dst_pixel_ptr:=bmp_dst_ptr+first_pix_pos;
  for y:=0 to rct_dst_height-1 do
    begin
      FillDWord(dst_pixel_ptr^,rct_dst_width,pix);
      Inc      (dst_pixel_ptr ,bmp_dst_width    );
    end;
end; {$endregion}
// (Write alpha channel to area(all pixels)) установить альфа-канал всем пикселям области:
procedure PPWriteAlpha       (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect;                                              const alpha    :byte         ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  alpha_mask   : TColor;
begin
  alpha_mask:=alpha<<24;
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
         (dst_pixel_ptr+x)^:=((dst_pixel_ptr+x)^ and NT_BIT_MASK_ALPHA2)+alpha_mask;
      Inc(dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
// (Additive) Аддитивное смешивание:
procedure PPAdditive         (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect;                            const col:TColor                               ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        Additive1(dst_pixel_ptr+x,col);
      Inc        (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPAdditive         (                   const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const rct_src,rct_dst:TPtRect                                                                                                                                                                           ); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_src.width <=0) or
     (rct_src.height<=0) then
    Exit;
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  src_pixel_ptr:=bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        Additive2(dst_pixel_ptr+x,
                 (src_pixel_ptr+x)^);
      Inc        (src_pixel_ptr,bmp_src_width);
      Inc        (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPAdditiveX        (                   const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const rct_src,rct_dst:TPtRect                                                                                                                                                                           ); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_src.width <=0) or
     (rct_src.height<=0) then
    Exit;
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  src_pixel_ptr:=bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width+rct_src.width-1;
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        Additive2(dst_pixel_ptr-x,
                 (src_pixel_ptr+x)^);
      Inc        (src_pixel_ptr,bmp_src_width);
      Inc        (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPAdditiveY        (                   const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const rct_src,rct_dst:TPtRect                                                                                                                                                                           ); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_src.width <=0) or
     (rct_src.height<=0) then
    Exit;
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  src_pixel_ptr:=bmp_src_ptr+rct_src.left+ rct_src.top                  *bmp_src_width;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+(rct_dst.top+rct_src.height-1)*bmp_dst_width;
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        Additive2(dst_pixel_ptr+x,
                 (src_pixel_ptr+x)^);
      Inc        (src_pixel_ptr, bmp_src_width);
      Inc        (dst_pixel_ptr,-bmp_dst_width);
    end;
end; {$endregion}
procedure PPAdditiveXY       (                   const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const rct_src,rct_dst:TPtRect                                                                                                                                                                           ); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_src.width <=0) or
     (rct_src.height<=0) then
    Exit;
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  src_pixel_ptr:=bmp_src_ptr+rct_src.left+ rct_src.top                  *bmp_src_width;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+(rct_dst.top+rct_src.height-1)*bmp_dst_width+rct_src.width-1;
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        Additive2(dst_pixel_ptr-x,
                 (src_pixel_ptr+x)^);
      Inc        (src_pixel_ptr, bmp_src_width);
      Inc        (dst_pixel_ptr,-bmp_dst_width);
    end;
end; {$endregion}
procedure PPAdditiveDec      (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect;                            const col:TColor; const pow      :byte=64      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        AdditiveDec1(dst_pixel_ptr+x,col,pow);
      Inc           (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPAdditiveDec      (                   const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const rct_src,rct_dst:TPtRect;                                              const pow      :byte=64      ); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_src.width <=0) or
     (rct_src.height<=0) then
    Exit;
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  src_pixel_ptr:=bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        AdditiveDec1(dst_pixel_ptr+x,
                    (src_pixel_ptr+x)^,pow);
      Inc           (src_pixel_ptr,bmp_src_width);
      Inc           (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPAdditiveDecX     (                   const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const rct_src,rct_dst:TPtRect;                                              const pow      :byte=64      ); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_src.width <=0) or
     (rct_src.height<=0) then
    Exit;
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  src_pixel_ptr:=bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width+rct_src.width-1;
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        AdditiveDec1(dst_pixel_ptr-x,
                    (src_pixel_ptr+x)^,pow);
      Inc           (src_pixel_ptr,bmp_src_width);
      Inc           (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPAdditiveDecY     (                   const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const rct_src,rct_dst:TPtRect;                                              const pow      :byte=64      ); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_src.width <=0) or
     (rct_src.height<=0) then
    Exit;
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  src_pixel_ptr:=bmp_src_ptr+rct_src.left+ rct_src.top                  *bmp_src_width;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+(rct_dst.top+rct_src.height-1)*bmp_dst_width;
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        AdditiveDec1(dst_pixel_ptr+x,
                    (src_pixel_ptr+x)^,pow);
      Inc           (src_pixel_ptr, bmp_src_width);
      Inc           (dst_pixel_ptr,-bmp_dst_width);
    end;
end; {$endregion}
procedure PPAdditiveDecXY    (                   const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const rct_src,rct_dst:TPtRect;                                              const pow      :byte=64      ); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_src.width <=0) or
     (rct_src.height<=0) then
    Exit;
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  src_pixel_ptr:=bmp_src_ptr+rct_src.left+ rct_src.top                  *bmp_src_width;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+(rct_dst.top+rct_src.height-1)*bmp_dst_width+rct_src.width-1;
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        AdditiveDec1(dst_pixel_ptr-x,
                    (src_pixel_ptr+x)^,pow);
      Inc           (src_pixel_ptr, bmp_src_width);
      Inc           (dst_pixel_ptr,-bmp_dst_width);
    end;
end; {$endregion}
// (AlphaBlend) Полупрозрачность:
procedure PPAlphaBlend       (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect;                            const col:TColor; const pow      :byte=64      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  d_alpha      : byte;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  d_alpha      :=MAXBYTE-pow;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        AlphaBlend1(dst_pixel_ptr+x,col,d_alpha);
      Inc          (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPAlphaBlend       (                   const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const rct_src,rct_dst:TPtRect;                                              const pow      :byte=64      ); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  d_alpha      : byte;
begin
  if (rct_src.width <=0) or
     (rct_src.height<=0) then
    Exit;
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  d_alpha      :=MAXBYTE-pow;
  src_pixel_ptr:=bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        AlphaBlend1(dst_pixel_ptr+x,
                   (src_pixel_ptr+x)^,d_alpha);
      Inc          (src_pixel_ptr,bmp_src_width);
      Inc          (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPAlphaBlendX      (                   const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const rct_src,rct_dst:TPtRect;                                              const pow      :byte=64      ); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  d_alpha      : byte;
begin
  if (rct_src.width <=0) or
     (rct_src.height<=0) then
    Exit;
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  d_alpha      :=MAXBYTE-pow;
  src_pixel_ptr:=bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width+rct_src.width-1;
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        AlphaBlend1(dst_pixel_ptr-x,
                   (src_pixel_ptr+x)^,d_alpha);
      Inc          (src_pixel_ptr,bmp_src_width);
      Inc          (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPAlphaBlendY      (                   const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const rct_src,rct_dst:TPtRect;                                              const pow      :byte=64      ); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  d_alpha      : byte;
begin
  if (rct_src.width <=0) or
     (rct_src.height<=0) then
    Exit;
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  d_alpha      :=MAXBYTE-pow;
  src_pixel_ptr:=bmp_src_ptr+rct_src.left+ rct_src.top                  *bmp_src_width;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+(rct_dst.top+rct_src.height-1)*bmp_dst_width;
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        AlphaBlend1(dst_pixel_ptr+x,
                   (src_pixel_ptr+x)^,d_alpha);
      Inc          (src_pixel_ptr, bmp_src_width);
      Inc          (dst_pixel_ptr,-bmp_dst_width);
    end;
end; {$endregion}
procedure PPAlphaBlendXY     (                   const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const rct_src,rct_dst:TPtRect;                                              const pow      :byte=64      ); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  d_alpha      : byte;
begin
  if (rct_src.width <=0) or
     (rct_src.height<=0) then
    Exit;
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  d_alpha      :=MAXBYTE-pow;
  src_pixel_ptr:=bmp_src_ptr+rct_src.left+ rct_src.top                  *bmp_src_width;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+(rct_dst.top+rct_src.height-1)*bmp_dst_width+rct_src.width-1;
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        AlphaBlend1(dst_pixel_ptr-x,
                   (src_pixel_ptr+x)^,d_alpha);
      Inc          (src_pixel_ptr, bmp_src_width);
      Inc          (dst_pixel_ptr,-bmp_dst_width);
    end;
end; {$endregion}
// (Inverse) Инверсия:
procedure PPInverse          (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect                                                                                                                                                                           ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        Inverse1(dst_pixel_ptr+x);
      Inc       (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPInverseDec       (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect;                                              const pow      :byte=64      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        InverseDec1(dst_pixel_ptr+x,pow);
      Inc          (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
// (HighLight) Подсветка:
procedure PPHighlight        (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect;                                              const pow      :byte=64      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        Highlight1(dst_pixel_ptr+x,pow);
      Inc         (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPHighlightLimit   (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect;                                              const pow      :byte=64      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if Boolean(PixCmp0(dst_pixel_ptr+x,pow)) then
          Highlight1      (dst_pixel_ptr+x,pow);
      Inc                 (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
// (Darken) Затемнение:
procedure PPDarken           (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect;                                              const pow      :byte=64      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        Darken1(dst_pixel_ptr+x,pow);
      Inc      (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPDarkenLimit      (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect;                                              const pow      :byte=64      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if Boolean(PixCmp1(dst_pixel_ptr+x,pow)) then
          Darken1         (dst_pixel_ptr+x,pow);
      Inc                 (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
// (GrayscaleR) Серый оттенок: красный канал:
procedure PPGrayscaleR       (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect                                                                                                                                                                           ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        GrayscaleR1(dst_pixel_ptr+x);
      Inc          (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPGrayscaleRDec    (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect;                                              const pow      :byte=64      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        GrayscaleRDec1(dst_pixel_ptr+x,pow);
      Inc             (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
// (GrayscaleG) Серый оттенок: зеленый канал:
procedure PPGrayscaleG       (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect                                                                                                                                                                           ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        GrayscaleG1(dst_pixel_ptr+x);
      Inc          (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPGrayscaleGDec    (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect;                                              const pow      :byte=64      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        GrayscaleGDec1(dst_pixel_ptr+x,pow);
      Inc             (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
// (GrayscaleB) Серый оттенок: синий   канал:
procedure PPGrayscaleB       (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect                                                                                                                                                                           ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        GrayscaleB1(dst_pixel_ptr+x);
      Inc          (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPGrayscaleBDec    (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect;                                              const pow      :byte=64      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        GrayscaleBDec1(dst_pixel_ptr+x,pow);
      Inc             (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
// (Monochrome noise) Монохромный шум:
procedure PPMonoNoise        (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect;                            const col:TColor                               ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if Odd((dst_pixel_ptr+x)^) then
               (dst_pixel_ptr+x)^:=col;
      Inc      (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPMonoNoiseDec     (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect;                            const col:TColor; const pow      :byte=64      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  d_alpha      : byte;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  d_alpha      :=MAXBYTE-pow;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        if Odd      ((dst_pixel_ptr+x)^) then
          AlphaBlend1(dst_pixel_ptr+x,col,d_alpha);
      Inc            (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
// (Random noise) Разноцветный шум:
procedure RandArrInit        (                   const             arr_length :integer=10000                                                                                                                                                                                                                                               ); {$region -fold}
var
  i: integer;
begin
  SetLength(rand_arr,arr_length);
  for i:=0 to Length(rand_arr)-1 do
    rand_arr[i]:=Random(255);
end; {$endregion}
procedure PPRandNoise        (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect; const PPRandNoiseProc:TProc23;                     pow1,pow2:byte         ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y,arr_ind  : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  pow2:=Min(pow2,6);
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      arr_ind:=Random(Length(rand_arr)-rct_dst.width);
      for x:=0 to rct_dst.width-1 do
        PPRandNoiseProc(dst_pixel_ptr+x,arr_ind+x,pow1,pow2);
      Inc              (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
// (Blur) Размытие:
procedure PPBlur             (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect; const PPBlurProc     :TProc8; const border_filter:TBorderFilter=efNotTiled); {$region -fold}
var
  pixel_ptr: PInteger;
  x,y      : integer;
  {
  pixel_ptr0,pixel_ptr1,pixel_ptr2,pixel_ptr3,pixel_ptr4: PInteger;
  r0,r1,r2,r3,r4,r5,r6,r7,r8                            : byte;
  g0,g1,g2,g3,g4,g5,g6,g7,g8                            : byte;
  b0,b1,b2,b3,b4,b5,b6,b7,b8                            : byte;
  r,g,b                                                 : byte;
  }
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;

  {Tiled Blur} {$region -fold}
  {
  d_width:=bmp_dst_width-rct_dst.width;

  // left -top    pixel
  pixel_ptr0:=Unaligned(bmp_dst_ptr+rct_dst.left+                bmp_dst_width* rct_dst.top                  );
  // right-top    pixel
  pixel_ptr1:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.width-1+bmp_dst_width* rct_dst.top                  );
  // left -bottom pixel
  pixel_ptr2:=Unaligned(bmp_dst_ptr+rct_dst.left+                bmp_dst_width*(rct_dst.top+rct_dst.height-1));
  // right-bottom pixel
  pixel_ptr3:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.width-1+bmp_dst_width*(rct_dst.top+rct_dst.height-1));

  pixel_ptr4:=pixel_ptr0;

  {Borders-------------} {$region -fold}

  case border_filter of

    efNotTiled:
      begin

        {Left-Top Pixel----} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top);
        pixel_ptr4^:=RGB((Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+1)^)+Red  ((pixel_ptr4+bmp_dst_width+0)^)+Red  ((pixel_ptr4+bmp_dst_width+1)^))>>2,
                         (Green((pixel_ptr4+0)^)+Green((pixel_ptr4+1)^)+Green((pixel_ptr4+bmp_dst_width+0)^)+Green((pixel_ptr4+bmp_dst_width+1)^))>>2,
                         (Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+1)^)+Blue ((pixel_ptr4+bmp_dst_width+0)^)+Blue ((pixel_ptr4+bmp_dst_width+1)^))>>2); {$endregion}

        {Right-Top Pixel---} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.width-1+bmp_dst_width*rct_dst.top);
        pixel_ptr4^:=RGB((Red  ((pixel_ptr4-1)^)+Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+bmp_dst_width-1)^)+Red  ((pixel_ptr4+bmp_dst_width+0)^))>>2,
                         (Green((pixel_ptr4-1)^)+Green((pixel_ptr4+0)^)+Green((pixel_ptr4+bmp_dst_width-1)^)+Green((pixel_ptr4+bmp_dst_width+0)^))>>2,
                         (Blue ((pixel_ptr4-1)^)+Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+bmp_dst_width-1)^)+Blue ((pixel_ptr4+bmp_dst_width+0)^))>>2); {$endregion}

        {Left-Bottom Pixel-} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*(rct_dst.top+rct_dst.height-1));
        pixel_ptr4^:=RGB((Red  ((pixel_ptr4-bmp_dst_width+0)^)+Red  ((pixel_ptr4-bmp_dst_width+1)^)+Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+1)^))>>2,
                         (Green((pixel_ptr4-bmp_dst_width+0)^)+Green((pixel_ptr4-bmp_dst_width+1)^)+Green((pixel_ptr4+0)^)+Green((pixel_ptr4+1)^))>>2,
                         (Blue ((pixel_ptr4-bmp_dst_width+0)^)+Blue ((pixel_ptr4-bmp_dst_width+1)^)+Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+1)^))>>2); {$endregion}

        {Right-Bottom Pixel} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.width-1+bmp_dst_width*(rct_dst.top+rct_dst.height-1));
        pixel_ptr4^:=RGB((Red  ((pixel_ptr4-bmp_dst_width-1)^)+Red  ((pixel_ptr4-bmp_dst_width+0)^)+Red  ((pixel_ptr4-1)^)+Red  ((pixel_ptr4+0)^))>>2,
                         (Green((pixel_ptr4-bmp_dst_width-1)^)+Green((pixel_ptr4-bmp_dst_width+0)^)+Green((pixel_ptr4-1)^)+Green((pixel_ptr4+0)^))>>2,
                         (Blue ((pixel_ptr4-bmp_dst_width-1)^)+Blue ((pixel_ptr4-bmp_dst_width+0)^)+Blue ((pixel_ptr4-1)^)+Blue ((pixel_ptr4+0)^))>>2); {$endregion}

        {Top Line----------} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+1+bmp_dst_width*rct_dst.top);
        for i:=0 to rct_dst.width-3 do
          begin
            pixel_ptr4^:=RGB(Trunc((Red  ((pixel_ptr4-1)^)+Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+1)^)+Red  ((pixel_ptr4+bmp_dst_width-1)^)+Red  ((pixel_ptr4+bmp_dst_width+0)^)+Red  ((pixel_ptr4+bmp_dst_width+1)^))/6),
                             Trunc((Green((pixel_ptr4-1)^)+Green((pixel_ptr4+0)^)+Green((pixel_ptr4+1)^)+Green((pixel_ptr4+bmp_dst_width-1)^)+Green((pixel_ptr4+bmp_dst_width+0)^)+Green((pixel_ptr4+bmp_dst_width+1)^))/6),
                             Trunc((Blue ((pixel_ptr4-1)^)+Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+1)^)+Blue ((pixel_ptr4+bmp_dst_width-1)^)+Blue ((pixel_ptr4+bmp_dst_width+0)^)+Blue ((pixel_ptr4+bmp_dst_width+1)^))/6));
            Inc(pixel_ptr4);
          end; {$endregion}

        {Left Line---------} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+bmp_dst_width*(rct_dst.top+1));
        for j:=0 to rct_dst.height-3 do
          begin
            pixel_ptr4^:=RGB(Trunc((Red  ((pixel_ptr4-bmp_dst_width)^)+Red  ((pixel_ptr4-bmp_dst_width+1)^)+Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+1)^)+Red  ((pixel_ptr4+bmp_dst_width+0)^)+Red  ((pixel_ptr4+bmp_dst_width+1)^))/6),
                             Trunc((Green((pixel_ptr4-bmp_dst_width)^)+Green((pixel_ptr4-bmp_dst_width+1)^)+Green((pixel_ptr4+0)^)+Green((pixel_ptr4+1)^)+Green((pixel_ptr4+bmp_dst_width+0)^)+Green((pixel_ptr4+bmp_dst_width+1)^))/6),
                             Trunc((Blue ((pixel_ptr4-bmp_dst_width)^)+Blue ((pixel_ptr4-bmp_dst_width+1)^)+Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+1)^)+Blue ((pixel_ptr4+bmp_dst_width+0)^)+Blue ((pixel_ptr4+bmp_dst_width+1)^))/6));
            Inc(pixel_ptr4,bmp_dst_width);
          end; {$endregion}

        {Right Line--------} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.width-1+bmp_dst_width*(rct_dst.top+1));
        for j:=0 to rct_dst.height-3 do
          begin
            pixel_ptr4^:=RGB(Trunc((Red  ((pixel_ptr4-bmp_dst_width-1)^)+Red  ((pixel_ptr4-bmp_dst_width+0)^)+Red  ((pixel_ptr4-1)^)+Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+bmp_dst_width-1)^)+Red  ((pixel_ptr4+bmp_dst_width+0)^))/6),
                             Trunc((Green((pixel_ptr4-bmp_dst_width-1)^)+Green((pixel_ptr4-bmp_dst_width+0)^)+Green((pixel_ptr4-1)^)+Green((pixel_ptr4+0)^)+Green((pixel_ptr4+bmp_dst_width-1)^)+Green((pixel_ptr4+bmp_dst_width+0)^))/6),
                             Trunc((Blue ((pixel_ptr4-bmp_dst_width-1)^)+Blue ((pixel_ptr4-bmp_dst_width+0)^)+Blue ((pixel_ptr4-1)^)+Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+bmp_dst_width-1)^)+Blue ((pixel_ptr4+bmp_dst_width+0)^))/6));
            Inc(pixel_ptr4,bmp_dst_width);
          end; {$endregion}

        {Bottom Line-------} {$region -fold}
        pixel_ptr4 :=Unaligned(bmp_dst_ptr+rct_dst.left+1+bmp_dst_width*(rct_dst.top+rct_dst.height-1));
        for i:=0 to rct_dst.width-3 do
          begin
            pixel_ptr4^:=RGB(Trunc((Red  ((pixel_ptr4-bmp_dst_width-1)^)+Red  ((pixel_ptr4-bmp_dst_width+0)^)+Red  ((pixel_ptr4-bmp_dst_width+1)^)+Red  ((pixel_ptr4-1)^)+Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+1)^))/6),
                             Trunc((Green((pixel_ptr4-bmp_dst_width-1)^)+Green((pixel_ptr4-bmp_dst_width+0)^)+Green((pixel_ptr4-bmp_dst_width+1)^)+Green((pixel_ptr4-1)^)+Green((pixel_ptr4+0)^)+Green((pixel_ptr4+1)^))/6),
                             Trunc((Blue ((pixel_ptr4-bmp_dst_width-1)^)+Blue ((pixel_ptr4-bmp_dst_width+0)^)+Blue ((pixel_ptr4-bmp_dst_width+1)^)+Blue ((pixel_ptr4-1)^)+Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+1)^))/6));
            Inc(pixel_ptr4);
          end; {$endregion}

      end;

    efTiled:  {TODO}
      begin

        {Left-Top Pixel----} {$region -fold}
        pixel_ptr4 :=Unaligned(@bmp_dst_ptr[rct_dst.left+bmp_dst_width*rct_dst.top]);
        pixel_ptr4^:=RGB((Red  ((pixel_ptr4+0)^)+Red  ((pixel_ptr4+1)^)+Red  ((pixel_ptr4+bmp_dst_width+0)^)+Red  ((pixel_ptr4+bmp_dst_width+1)^))>>2,
                         (Green((pixel_ptr4+0)^)+Green((pixel_ptr4+1)^)+Green((pixel_ptr4+bmp_dst_width+0)^)+Green((pixel_ptr4+bmp_dst_width+1)^))>>2,
                         (Blue ((pixel_ptr4+0)^)+Blue ((pixel_ptr4+1)^)+Blue ((pixel_ptr4+bmp_dst_width+0)^)+Blue ((pixel_ptr4+bmp_dst_width+1)^))>>2); {$endregion}
        {r0:=pixel_ptr3^{shr 0};
        g0:=pixel_ptr3^ shr 8 ;
        b0:=pixel_ptr3^ shr 16;
        r1:=pixel_ptr2^{shr 0};
        g1:=pixel_ptr2^ shr 8 ;
        b1:=pixel_ptr2^ shr 16;
        Inc(pixel_ptr2);
        r2:=pixel_ptr2^{shr 0};
        g2:=pixel_ptr2^ shr 8 ;
        b2:=pixel_ptr2^ shr 16;
        r3:=pixel_ptr1^{shr 0};
        g3:=pixel_ptr1^ shr 8 ;
        b3:=pixel_ptr1^ shr 16;
        r4:=pixel_ptr0^{shr 0};
        g4:=pixel_ptr0^ shr 8 ;
        b4:=pixel_ptr0^ shr 16;
        Inc(pixel_ptr0);
        r5:=pixel_ptr0^{shr 0};
        g5:=pixel_ptr0^ shr 8 ;
        b5:=pixel_ptr0^ shr 16;
        Inc(pixel_ptr1,bmp_dst_width);
        r6:=pixel_ptr1^{shr 0};
        g6:=pixel_ptr1^ shr 8 ;
        b6:=pixel_ptr1^ shr 16;
        Inc(pixel_ptr0,bmp_dst_width-1);
        r7:=pixel_ptr0^{shr 0};
        g7:=pixel_ptr0^ shr 8 ;
        b7:=pixel_ptr0^ shr 16;
        Inc(pixel_ptr0);
        r8:=pixel_ptr0^{shr 0};
        g8:=pixel_ptr0^ shr 8 ;
        b8:=pixel_ptr0^ shr 16;
        Dec(pixel_ptr0,bmp_dst_width+1); // Reset left -top    pixel pointer
        Dec(pixel_ptr1,bmp_dst_width);   // Reset right-top    pixel pointer
        Dec(pixel_ptr2);                 // Reset left -bottom pixel pointer
        r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
        g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
        b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
        pixel_ptr0^:=RGB(r,g,b); {$endregion}}

        {Right-Top Pixel---} {$region -fold}
        Dec(pixel_ptr3);
        r0:=pixel_ptr3^>>00;
        g0:=pixel_ptr3^>>08;
        b0:=pixel_ptr3^>>16;
        Inc(pixel_ptr3);
        r1:=pixel_ptr3^>>00;
        g1:=pixel_ptr3^>>08;
        b1:=pixel_ptr3^>>16;
        r2:=pixel_ptr2^>>00;
        g2:=pixel_ptr2^>>08;
        b2:=pixel_ptr2^>>16;
        Dec(pixel_ptr1);
        r3:=pixel_ptr1^>>00;
        g3:=pixel_ptr1^>>08;
        b3:=pixel_ptr1^>>16;
        Inc(pixel_ptr1);
        r4:=pixel_ptr1^>>00;
        g4:=pixel_ptr1^>>08;
        b4:=pixel_ptr1^>>16;
        r5:=pixel_ptr0^>>00;
        g5:=pixel_ptr0^>>08;
        b5:=pixel_ptr0^>>16;
        Inc(pixel_ptr1,bmp_dst_width-1);
        r6:=pixel_ptr1^>>00;
        g6:=pixel_ptr1^>>08;
        b6:=pixel_ptr1^>>16;
        Inc(pixel_ptr1);
        r7:=pixel_ptr1^>>00;
        g7:=pixel_ptr1^>>08;
        b7:=pixel_ptr1^>>16;
        Inc(pixel_ptr0,bmp_dst_width);
        r8:=pixel_ptr0^>>00;
        g8:=pixel_ptr0^>>08;
        b8:=pixel_ptr0^>>16;
        Dec(pixel_ptr0,bmp_dst_width); // Reset left -top pixel pointer
        Dec(pixel_ptr1,bmp_dst_width); // Reset right-top pixel pointer
        r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
        g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
        b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
        pixel_ptr1^:=RGB(r,g,b); {$endregion}

        {Left-Bottom Pixel-} {$region -fold}
        Dec(pixel_ptr3,bmp_dst_width);
        r0:=pixel_ptr3^>>00;
        g0:=pixel_ptr3^>>08;
        b0:=pixel_ptr3^>>16;
        Dec(pixel_ptr2,bmp_dst_width);
        r1:=pixel_ptr2^>>00;
        g1:=pixel_ptr2^>>08;
        b1:=pixel_ptr2^>>16;
        Inc(pixel_ptr2);
        r2:=pixel_ptr2^>>00;
        g2:=pixel_ptr2^>>08;
        b2:=pixel_ptr2^>>16;
        Inc(pixel_ptr3,bmp_dst_width);
        r3:=pixel_ptr3^>>00;
        g3:=pixel_ptr3^>>08;
        b3:=pixel_ptr3^>>16;
        Inc(pixel_ptr2,bmp_dst_width-1);
        r4:=pixel_ptr2^>>00;
        g4:=pixel_ptr2^>>08;
        b4:=pixel_ptr2^>>16;
        Inc(pixel_ptr2);
        r5:=pixel_ptr2^>>00;
        g5:=pixel_ptr2^>>08;
        b5:=pixel_ptr2^>>16;
        r6:=pixel_ptr1^>>00;
        g6:=pixel_ptr1^>>08;
        b6:=pixel_ptr1^>>16;
        r7:=pixel_ptr0^>>00;
        g7:=pixel_ptr0^>>08;
        b7:=pixel_ptr0^>>16;
        Inc(pixel_ptr0);
        r8:=pixel_ptr0^>>00;
        g8:=pixel_ptr0^>>08;
        b8:=pixel_ptr0^>>16;
        Dec(pixel_ptr0); // Reset left-top    pixel pointer
        Dec(pixel_ptr2); // Reset left-bottom pixel pointer
        r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
        g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
        b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
        pixel_ptr2^:=RGB(r,g,b); {$endregion}

        {Right-Bottom Pixel} {$region -fold}
        Dec(pixel_ptr3,bmp_dst_width+1);
        r0:=pixel_ptr3^>>00;
        g0:=pixel_ptr3^>>08;
        b0:=pixel_ptr3^>>16;
        Inc(pixel_ptr3);
        r1:=pixel_ptr3^>>00;
        g1:=pixel_ptr3^>>08;
        b1:=pixel_ptr3^>>16;
        Dec(pixel_ptr2,bmp_dst_width);
        r2:=pixel_ptr2^>>00;
        g2:=pixel_ptr2^>>08;
        b2:=pixel_ptr2^>>16;
        Inc(pixel_ptr3,bmp_dst_width-1);
        r3:=pixel_ptr3^>>00;
        g3:=pixel_ptr3^>>08;
        b3:=pixel_ptr3^>>16;
        Inc(pixel_ptr3);
        r4:=pixel_ptr3^>>00;
        g4:=pixel_ptr3^>>08;
        b4:=pixel_ptr3^>>16;
        Inc(pixel_ptr2,bmp_dst_width);
        r5:=pixel_ptr2^>>00;
        g5:=pixel_ptr2^>>08;
        b5:=pixel_ptr2^>>16;
        Dec(pixel_ptr1);
        r6:=pixel_ptr1^>>00;
        g6:=pixel_ptr1^>>08;
        b6:=pixel_ptr1^>>16;
        Inc(pixel_ptr1);
        r7:=pixel_ptr1^>>00;
        g7:=pixel_ptr1^>>08;
        b7:=pixel_ptr1^>>16;
        r8:=pixel_ptr0^>>00;
        g8:=pixel_ptr0^>>08;
        b8:=pixel_ptr0^>>16;
        r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
        g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
        b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
        pixel_ptr3^:=RGB(r,g,b); {$endregion}

        {Top Line----------} {$region -fold}
        for i:=1 to rct_dst.width-2 do
          begin
            r0:=pixel_ptr2^>>00;
            g0:=pixel_ptr2^>>08;
            b0:=pixel_ptr2^>>16;
            Inc(pixel_ptr2);
            r1:=pixel_ptr2^>>00;
            g1:=pixel_ptr2^>>08;
            b1:=pixel_ptr2^>>16;
            Inc(pixel_ptr2);
            r2:=pixel_ptr2^>>00;
            g2:=pixel_ptr2^>>08;
            b2:=pixel_ptr2^>>16;
            r3:=pixel_ptr0^>>00;
            g3:=pixel_ptr0^>>08;
            b3:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r4:=pixel_ptr0^>>00;
            g4:=pixel_ptr0^>>08;
            b4:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r5:=pixel_ptr0^>>00;
            g5:=pixel_ptr0^>>08;
            b5:=pixel_ptr0^>>16;
            Inc(pixel_ptr0,bmp_dst_width-2);
            r6:=pixel_ptr0^>>00;
            g6:=pixel_ptr0^>>08;
            b6:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r7:=pixel_ptr0^>>00;
            g7:=pixel_ptr0^>>08;
            b7:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r8:=pixel_ptr0^>>00;
            g8:=pixel_ptr0^>>08;
            b8:=pixel_ptr0^>>16;
            Dec(pixel_ptr0,bmp_dst_width+1);
            Dec(pixel_ptr2);
            r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
            g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
            b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
            pixel_ptr0^:=RGB(r,g,b);
          end;
        Dec(pixel_ptr0,rct_dst.width-2); // Reset left-top    pixel pointer
        Dec(pixel_ptr2,rct_dst.width-2); // Reset left-bottom pixel pointer
        {$endregion}

        {Left Line---------} {$region -fold}
        for j:=1 to rct_dst.height-2 do
          begin
            r0:=pixel_ptr1^>>00;
            g0:=pixel_ptr1^>>08;
            b0:=pixel_ptr1^>>16;
            r1:=pixel_ptr0^>>00;
            g1:=pixel_ptr0^>>08;
            b1:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r2:=pixel_ptr0^>>00;
            g2:=pixel_ptr0^>>08;
            b2:=pixel_ptr0^>>16;
            Inc(pixel_ptr1,bmp_dst_width);
            r3:=pixel_ptr1^>>00;
            g3:=pixel_ptr1^>>08;
            b3:=pixel_ptr1^>>16;
            Inc(pixel_ptr0,bmp_dst_width-1);
            r4:=pixel_ptr0^>>00;
            g4:=pixel_ptr0^>>08;
            b4:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r5:=pixel_ptr0^>>00;
            g5:=pixel_ptr0^>>08;
            b5:=pixel_ptr0^>>16;
            Inc(pixel_ptr1,bmp_dst_width);
            r6:=pixel_ptr1^>>00;
            g6:=pixel_ptr1^>>08;
            b6:=pixel_ptr1^>>16;
            Inc(pixel_ptr0,bmp_dst_width-1);
            r7:=pixel_ptr0^>>00;
            g7:=pixel_ptr0^>>08;
            b7:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r8:=pixel_ptr0^>>00;
            g8:=pixel_ptr0^>>08;
            b8:=pixel_ptr0^>>16;
            Dec(pixel_ptr0,bmp_dst_width+1);
            Dec(pixel_ptr1,bmp_dst_width);
            r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
            g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
            b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
            pixel_ptr0^:=RGB(r,g,b);
          end;
        Dec(pixel_ptr0,bmp_dst_width*(rct_dst.height-2)); // Reset left -top pixel pointer
        Dec(pixel_ptr1,bmp_dst_width*(rct_dst.height-2)); // Reset right-top pixel pointer
        {$endregion}

        {Right Line--------} {$region -fold}
        Dec(pixel_ptr1);
        for j:=1 to rct_dst.height-2 do
          begin
            r0:=pixel_ptr1^>>00;
            g0:=pixel_ptr1^>>08;
            b0:=pixel_ptr1^>>16;
            Inc(pixel_ptr1);
            r1:=pixel_ptr1^>>00;
            g1:=pixel_ptr1^>>08;
            b1:=pixel_ptr1^>>16;
            r2:=pixel_ptr0^>>00;
            g2:=pixel_ptr0^>>08;
            b2:=pixel_ptr0^>>16;
            Inc(pixel_ptr1,bmp_dst_width-1);
            r3:=pixel_ptr1^>>00;
            g3:=pixel_ptr1^>>08;
            b3:=pixel_ptr1^>>16;
            Inc(pixel_ptr1);
            r4:=pixel_ptr1^>>00;
            g4:=pixel_ptr1^>>08;
            b4:=pixel_ptr1^>>16;
            Inc(pixel_ptr0,bmp_dst_width);
            r5:=pixel_ptr0^>>00;
            g5:=pixel_ptr0^>>08;
            b5:=pixel_ptr0^>>16;
            Inc(pixel_ptr1,bmp_dst_width-1);
            r6:=pixel_ptr1^>>00;
            g6:=pixel_ptr1^>>08;
            b6:=pixel_ptr1^>>16;
            Inc(pixel_ptr1);
            r7:=pixel_ptr1^>>00;
            g7:=pixel_ptr1^>>08;
            b7:=pixel_ptr1^>>16;
            Inc(pixel_ptr0,bmp_dst_width);
            r8:=pixel_ptr0^>>00;
            g8:=pixel_ptr0^>>08;
            b8:=pixel_ptr0^>>16;
            Dec(pixel_ptr0,bmp_dst_width);
            Dec(pixel_ptr1,bmp_dst_width);
            r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
            g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
            b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
            pixel_ptr1^:=RGB(r,g,b);
            Dec(pixel_ptr1);
          end;
        Dec(pixel_ptr0,bmp_dst_width*(rct_dst.height-2));   // Reset left -top pixel pointer
        Dec(pixel_ptr1,bmp_dst_width*(rct_dst.height-2)-1); // Reset right-top pixel pointer
        {$endregion}

        {Bottom Line-------} {$region -fold}
        Dec(pixel_ptr2,bmp_dst_width);
        for i:=1 to rct_dst.width-2 do
          begin
            r0:=pixel_ptr2^>>00;
            g0:=pixel_ptr2^>>08;
            b0:=pixel_ptr2^>>16;
            Inc(pixel_ptr2);
            r1:=pixel_ptr2^>>00;
            g1:=pixel_ptr2^>>08;
            b1:=pixel_ptr2^>>16;
            Inc(pixel_ptr2);
            r2:=pixel_ptr2^>>00;
            g2:=pixel_ptr2^>>08;
            b2:=pixel_ptr2^>>16;
            Inc(pixel_ptr2,bmp_dst_width-2);
            r3:=pixel_ptr2^>>00;
            g3:=pixel_ptr2^>>08;
            b3:=pixel_ptr2^>>16;
            Inc(pixel_ptr2);
            r4:=pixel_ptr2^>>00;
            g4:=pixel_ptr2^>>08;
            b4:=pixel_ptr2^>>16;
            Inc(pixel_ptr2);
            r5:=pixel_ptr2^>>00;
            g5:=pixel_ptr2^>>08;
            b5:=pixel_ptr2^>>16;
            r6:=pixel_ptr0^>>00;
            g6:=pixel_ptr0^>>08;
            b6:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r7:=pixel_ptr0^>>00;
            g7:=pixel_ptr0^>>08;
            b7:=pixel_ptr0^>>16;
            Inc(pixel_ptr0);
            r8:=pixel_ptr0^>>00;
            g8:=pixel_ptr0^>>08;
            b8:=pixel_ptr0^>>16;
            Dec(pixel_ptr2);
            r :=Trunc((r0+r1+r2+r3+r4+r5+r6+r7+r8)/9);
            g :=Trunc((g0+g1+g2+g3+g4+g5+g6+g7+g8)/9);
            b :=Trunc((b0+b1+b2+b3+b4+b5+b6+b7+b8)/9);
            pixel_ptr2^:=RGB(r,g,b);
            Dec(pixel_ptr0);               // Reset left-top    pixel pointer
            Dec(pixel_ptr2,bmp_dst_width); // Reset left-bottom pixel pointer
          end;
        Dec(pixel_ptr0,rct_dst.width-2); // Reset left-top    pixel pointer
        Inc(pixel_ptr2,d_width+2);       // Reset left-bottom pixel pointer
        {$endregion}

      end;

  end; {$endregion}
  }
  {Inner Rectangle Area}
  {
  blur_type:
    00: {Fast----}
    01: {g to r--}
    02: {b to r--}
    03: {r to g--}
    04: {b to g--}
    05: {r to b--}
    06: {g to b--}
    07: {b,g to r}
    08: {r,b to g}
    09: {r,g to b}
    10: {Slow----}
  } {$endregion}

  pixel_ptr:=bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        PPBlurProc(pixel_ptr+x,bmp_dst_width);
      Inc         (pixel_ptr  ,bmp_dst_width);
    end;
end; {$endregion}
procedure PPBlurLeft         (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect; const PPBlurProc     :TProc8                                              ); {$region -fold}
var
  pixel_ptr : PInteger;
  pixel_ptr0: PInteger;
  x,y       : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  pixel_ptr :=bmp_dst_ptr+rct_dst.left+rct_dst.width-1+bmp_dst_width*rct_dst.top;
  pixel_ptr0:=pixel_ptr;
  for x:=0 to rct_dst.width-1 do
    begin
      pixel_ptr:=pixel_ptr0;
      for y:=0 to rct_dst.height-1 do
        PPBlurProc(pixel_ptr+y*bmp_dst_width,bmp_dst_width);
      Dec(pixel_ptr0);
    end;
end; {$endregion}
procedure PPBlurRight        (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect; const PPBlurProc     :TProc8                                              ); {$region -fold}
var
  pixel_ptr : PInteger;
  pixel_ptr0: PInteger;
  x,y       : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  pixel_ptr :=bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top;
  pixel_ptr0:=pixel_ptr;
  for x:=0 to rct_dst.width-1 do
    begin
      pixel_ptr:=pixel_ptr0;
      for y:=0 to rct_dst.height-1 do
        PPBlurProc(pixel_ptr+y*bmp_dst_width,bmp_dst_width);
      Inc(pixel_ptr0);
    end;
end; {$endregion}
procedure PPBlurUp           (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect; const PPBlurProc     :TProc8                                              ); {$region -fold}
var
  pixel_ptr : PInteger;
  pixel_ptr0: PInteger;
  x,y       : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  pixel_ptr :=bmp_dst_ptr+rct_dst.left+bmp_dst_width*(rct_dst.top+rct_dst.height-1);
  pixel_ptr0:=pixel_ptr;
  for y:=0 to rct_dst.height-1 do
    begin
      pixel_ptr:=pixel_ptr0;
      for x:=0 to rct_dst.width-1 do
        PPBlurProc(pixel_ptr+x,bmp_dst_width);
      Dec(pixel_ptr0,bmp_dst_width);
    end;
end; {$endregion}
procedure PPBlurDown         (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect; const PPBlurProc     :TProc8                                              ); {$region -fold}
var
  pixel_ptr : PInteger;
  pixel_ptr0: PInteger;
  x,y       : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  pixel_ptr :=bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top;
  pixel_ptr0:=pixel_ptr;
  for y:=0 to rct_dst.height-1 do
    begin
      pixel_ptr:=pixel_ptr0;
      for x:=0 to rct_dst.width-1 do
        PPBlurProc(pixel_ptr+x,bmp_dst_width);
      Inc(pixel_ptr0,bmp_dst_width);
    end;
end; {$endregion}
procedure PPBlurDec          (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect; const PPBlurDecProc  :TProc19;               const alpha    :byte         ); {$region -fold}
var
  pixel_ptr: PInteger;
  x,y      : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  pixel_ptr:=bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        PPBlurDecProc(pixel_ptr+x,bmp_dst_width,alpha);
      Inc            (pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPBlurRGB9         (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect; const blur_type      :TBlurType=btRGB                                     ); {$region -fold}
var
  pixel_ptr : PInteger;
  pixel_ptr2: PInteger;
  x,y       : integer;
begin
  if (rct_dst.width <=1) or
     (rct_dst.height<=1) then
    Exit;
  pixel_ptr:=bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top;
  for y:=0 to rct_dst.height-1 do
    for x:=0 to rct_dst.width-1 do
      begin
        pixel_ptr2:=pixel_ptr+x+y*bmp_dst_width;
        if (x=0) then
          begin
            if (y=0) then
              PPBlurProcArr[10*Byte(blur_type)+0](pixel_ptr2,bmp_dst_width)
            else
            if (y>0) and (y<rct_dst.height-1) then
              PPBlurProcArr[10*Byte(blur_type)+3](pixel_ptr2,bmp_dst_width)
            else
            if (y=rct_dst.height-1) then
              PPBlurProcArr[10*Byte(blur_type)+6](pixel_ptr2,bmp_dst_width);
          end
        else
        if (x>0) and (x<rct_dst.width-1) then
          begin
            if (y=0) then
              PPBlurProcArr[10*Byte(blur_type)+1](pixel_ptr2,bmp_dst_width)
            else
            if (y>0) and (y<rct_dst.height-1) then
              PPBlurProcArr[10*Byte(blur_type)+4](pixel_ptr2,bmp_dst_width)
            else
            if (y=rct_dst.height-1) then
              PPBlurProcArr[10*Byte(blur_type)+7](pixel_ptr2,bmp_dst_width);
          end
        else
        if (x=rct_dst.width-1) then
          begin
            if (y=0) then
              PPBlurProcArr[10*Byte(blur_type)+2](pixel_ptr2,bmp_dst_width)
            else
            if (y>0) and (y<rct_dst.height-1) then
              PPBlurProcArr[10*Byte(blur_type)+5](pixel_ptr2,bmp_dst_width)
            else
            if (y=rct_dst.height-1) then
              PPBlurProcArr[10*Byte(blur_type)+8](pixel_ptr2,bmp_dst_width);
          end;
      end;
end; {$endregion}
// (Color correction) Цветокоррекция:
procedure PPColorCorrectionM0(ColorizeM:TProc17; const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect;                                              const pow      :byte=32      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        ColorizeM(dst_pixel_ptr+x,pow);
      Inc        (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPColorCorrectionP0(ColorizeP:TProc17; const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect;                                              const pow      :byte=32      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        ColorizeP(dst_pixel_ptr+x,pow);
      Inc        (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPColorCorrectionM0(ColorizeM:TProc17; const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const rct_src,rct_dst:TPtRect;                                              const pow      :byte=32      ); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_src.width <=0) or
     (rct_src.height<=0) then
    Exit;
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  src_pixel_ptr:=bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_src.height-1-1 do
    begin
      for x:=0 to rct_src.width-1 do
        if         ((src_pixel_ptr+x)^>>24<>0) then
          ColorizeM (dst_pixel_ptr+x,pow);
      Inc           (src_pixel_ptr,bmp_src_width);
      Inc           (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPColorCorrectionP0(ColorizeP:TProc17; const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const rct_src,rct_dst:TPtRect;                                              const pow      :byte=32      ); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_src.width <=0) or
     (rct_src.height<=0) then
    Exit;
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  src_pixel_ptr:=bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        if         ((src_pixel_ptr+x)^>>24<>0) then
          ColorizeP (dst_pixel_ptr+x,pow);
      Inc           (src_pixel_ptr,bmp_src_width);
      Inc           (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPColorCorrectionM1(ColorizeM:TProc18; const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const rct_src,rct_dst:TPtRect;                                              const pow      :byte=32      ); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_src.width <=0) or
     (rct_src.height<=0) then
    Exit;
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  src_pixel_ptr:=bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_src.height-1-1 do
    begin
      for x:=0 to rct_src.width-1 do
        if         ((src_pixel_ptr+x)^>>24=MAXBYTE) then
          ColorizeM (dst_pixel_ptr+x,0,pow)
        else
        if         ((src_pixel_ptr+x)^>>24<MAXBYTE) and
                   ((src_pixel_ptr+x)^>>24>0) then
          ColorizeM (dst_pixel_ptr+x,
          MAXBYTE-  (src_pixel_ptr+x)^>>24,pow);
      Inc           (src_pixel_ptr,bmp_src_width);
      Inc           (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPColorCorrectionP1(ColorizeP:TProc18; const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const rct_src,rct_dst:TPtRect;                                              const pow      :byte=32      ); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
begin
  if (rct_src.width <=0) or
     (rct_src.height<=0) then
    Exit;
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  src_pixel_ptr:=bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_src.height-1 do
    begin
      for x:=0 to rct_src.width-1 do
        if         ((src_pixel_ptr+x)^>>24=MAXBYTE) then
          ColorizeP (dst_pixel_ptr+x,0,pow)
        else
        if         ((src_pixel_ptr+x)^>>24<MAXBYTE) and
                   ((src_pixel_ptr+x)^>>24>0) then
          ColorizeP (dst_pixel_ptr+x,
          MAXBYTE-  (src_pixel_ptr+x)^>>24,pow);
      Inc           (src_pixel_ptr,bmp_src_width);
      Inc           (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
// (Vertical gradient) Вертикальный градиент:
procedure PPGrVMonochrome    (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect; grad_prop:TGradProp                                                                                                                                                      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  y            : integer;
begin
  with grad_prop do
    begin
      if (rct_dst.width <=0) or
         (rct_dst.height<=0) then
        Exit;
      dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
      for y:=0 to rct_dst.height-1 do
        begin
          FillDWord(dst_pixel_ptr^,
                    rct_dst.width,
                    RGB(y_grad_rng_div_vec.b>>16,
                        y_grad_rng_div_vec.g>>16,
                        y_grad_rng_div_vec.r>>16));
          Inc      (dst_pixel_ptr ,bmp_dst_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
        end;
    end;
end; {$endregion}
procedure PPGrVAdditive      (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect; grad_prop:TGradProp                                                                                                                                                      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  pix_row_val  : TColor;
begin
  with grad_prop do
    begin
      if (rct_dst.width <=0) or
         (rct_dst.height<=0) then
        Exit;
      dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
      for y:=0 to rct_dst.height-1 do
        begin
          pix_row_val:=RGBA(y_grad_rng_div_vec.r>>16,
                            y_grad_rng_div_vec.g>>16,
                            y_grad_rng_div_vec.b>>16,
                            y_grad_rng_div_vec.a>>16);
          for x:=0 to rct_dst.width-1 do
            AdditiveDec2(dst_pixel_ptr+x,pix_row_val);
          Inc           (dst_pixel_ptr,bmp_dst_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure PPGrVAdditive      (                   const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const rct_src,rct_dst:TPtRect; grad_prop:TGradProp                                                                                                                                                      ); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  pow          : byte;
begin
  with grad_prop do
    begin
      if (rct_src.width <=0) or
         (rct_src.height<=0) then
        Exit;
      if (rct_dst.width <=0) or
         (rct_dst.height<=0) then
        Exit;
      src_pixel_ptr:=bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width;
      dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
      for y:=0 to rct_dst.height-1 do
        begin
          pow:=y_grad_rng_div_vec.a>>16;
          for x:=0 to rct_dst.width-1 do
            AdditiveDec1(dst_pixel_ptr+x,
                        (src_pixel_ptr+x)^,pow);
          Inc           (src_pixel_ptr,bmp_src_width);
          Inc           (dst_pixel_ptr,bmp_dst_width);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure PPGrVAdditiveX     (                   const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const rct_src,rct_dst:TPtRect; grad_prop:TGradProp                                                                                                                                                      ); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  pow          : byte;
begin
  with grad_prop do
    begin
      if (rct_src.width <=0) or
         (rct_src.height<=0) then
        Exit;
      if (rct_dst.width <=0) or
         (rct_dst.height<=0) then
        Exit;
      src_pixel_ptr:=bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width;
      dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
      for y:=0 to rct_dst.height-1 do
        begin
          pow:=y_grad_rng_div_vec.a>>16;
          for x:=0 to rct_dst.width-1 do
            AdditiveDec1(dst_pixel_ptr-x,
                        (src_pixel_ptr+x)^,pow);
          Inc           (src_pixel_ptr,bmp_src_width);
          Inc           (dst_pixel_ptr,bmp_dst_width);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure PPGrVAdditiveY     (                   const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const rct_src,rct_dst:TPtRect; grad_prop:TGradProp                                                                                                                                                      ); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  pow          : byte;
begin
  with grad_prop do
    begin
      if (rct_src.width <=0) or
         (rct_src.height<=0) then
        Exit;
      if (rct_dst.width <=0) or
         (rct_dst.height<=0) then
        Exit;
      src_pixel_ptr:=bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width;
      dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
      for y:=0 to rct_dst.height-1 do
        begin
          pow:=y_grad_rng_div_vec.a>>16;
          for x:=0 to rct_dst.width-1 do
            AdditiveDec1(dst_pixel_ptr+x,
                        (src_pixel_ptr+x)^,pow);
          Inc           (src_pixel_ptr, bmp_src_width);
          Inc           (dst_pixel_ptr,-bmp_dst_width);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure PPGrVAdditiveXY    (                   const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const rct_src,rct_dst:TPtRect; grad_prop:TGradProp                                                                                                                                                      ); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  pow          : byte;
begin
  with grad_prop do
    begin
      if (rct_src.width <=0) or
         (rct_src.height<=0) then
        Exit;
      if (rct_dst.width <=0) or
         (rct_dst.height<=0) then
        Exit;
      src_pixel_ptr:=bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width;
      dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
      for y:=0 to rct_dst.height-1 do
        begin
          pow:=y_grad_rng_div_vec.a>>16;
          for x:=0 to rct_dst.width-1 do
            AdditiveDec1(dst_pixel_ptr-x,
                        (src_pixel_ptr+x)^,pow);
          Inc           (src_pixel_ptr, bmp_src_width);
          Inc           (dst_pixel_ptr,-bmp_dst_width);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure PPGrVAlphablend    (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect; grad_prop:TGradProp                                                                                                                                                      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  pix_row_val  : TColor;
  pow          : byte;
begin
  with grad_prop do
    begin
      if (rct_dst.width <=0) or
         (rct_dst.height<=0) then
        Exit;
      dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
      for y:=0 to rct_dst.height-1 do
        begin
          pix_row_val:=RGBA(y_grad_rng_div_vec.b>>16,
                            y_grad_rng_div_vec.g>>16,
                            y_grad_rng_div_vec.r>>16,
                            y_grad_rng_div_vec.a>>16);
          pow        :=MAXBYTE-TRGBA(pix_row_val).a;
          for x:=0 to rct_dst.width-1 do
            AlphaBlendDec1(dst_pixel_ptr+x,pix_row_val,pow,0);
          Inc             (dst_pixel_ptr,bmp_dst_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure PPGrVAlphablend    (                   const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const rct_src,rct_dst:TPtRect; grad_prop:TGradProp                                                                                                                                                      ); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  pow          : byte;
begin
  with grad_prop do
    begin
      if (rct_src.width <=0) or
         (rct_src.height<=0) then
        Exit;
      if (rct_dst.width <=0) or
         (rct_dst.height<=0) then
        Exit;
      src_pixel_ptr:=bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width;
      dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
      for y:=0 to rct_dst.height-1 do
        begin
          pow:=MAXBYTE-(y_grad_rng_div_vec.a>>16);
          for x:=0 to rct_dst.width-1 do
            AlphaBlendDec1(dst_pixel_ptr+x,
                          (src_pixel_ptr+x)^,pow,0);
          Inc             (src_pixel_ptr,bmp_src_width);
          Inc             (dst_pixel_ptr,bmp_dst_width);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure PPGrVAlphablendX   (                   const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const rct_src,rct_dst:TPtRect; grad_prop:TGradProp                                                                                                                                                      ); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  pow          : byte;
begin
  with grad_prop do
    begin
      if (rct_src.width <=0) or
         (rct_src.height<=0) then
        Exit;
      if (rct_dst.width <=0) or
         (rct_dst.height<=0) then
        Exit;
      src_pixel_ptr:=bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width;
      dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
      for y:=0 to rct_dst.height-1 do
        begin
          pow:=MAXBYTE-(y_grad_rng_div_vec.a>>16);
          for x:=0 to rct_dst.width-1 do
            AlphaBlendDec1(dst_pixel_ptr-x,
                          (src_pixel_ptr+x)^,pow,0);
          Inc             (src_pixel_ptr,bmp_src_width);
          Inc             (dst_pixel_ptr,bmp_dst_width);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure PPGrVAlphablendY   (                   const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const rct_src,rct_dst:TPtRect; grad_prop:TGradProp                                                                                                                                                      ); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  pow          : byte;
begin
  with grad_prop do
    begin
      if (rct_src.width <=0) or
         (rct_src.height<=0) then
        Exit;
      if (rct_dst.width <=0) or
         (rct_dst.height<=0) then
        Exit;
      src_pixel_ptr:=bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width;
      dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
      for y:=0 to rct_dst.height-1 do
        begin
          pow:=MAXBYTE-(y_grad_rng_div_vec.a>>16);
          for x:=0 to rct_dst.width-1 do
            AlphaBlendDec1(dst_pixel_ptr+x,
                          (src_pixel_ptr+x)^,pow,0);
          Inc             (src_pixel_ptr, bmp_src_width);
          Inc             (dst_pixel_ptr,-bmp_dst_width);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure PPGrVAlphablendXY  (                   const bmp_src_ptr,bmp_dst_ptr:PInteger; const bmp_src_width,bmp_dst_width:TColor; const rct_src,rct_dst:TPtRect; grad_prop:TGradProp                                                                                                                                                      ); {$region -fold}
var
  src_pixel_ptr: PInteger;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  pow          : byte;
begin
  with grad_prop do
    begin
      if (rct_src.width <=0) or
         (rct_src.height<=0) then
        Exit;
      if (rct_dst.width <=0) or
         (rct_dst.height<=0) then
        Exit;
      src_pixel_ptr:=bmp_src_ptr+rct_src.left+rct_src.top*bmp_src_width;
      dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
      for y:=0 to rct_dst.height-1 do
        begin
          pow:=MAXBYTE-(y_grad_rng_div_vec.a>>16);
          for x:=0 to rct_dst.width-1 do
            AlphaBlendDec1(dst_pixel_ptr-x,
                          (src_pixel_ptr+x)^,pow,0);
          Inc             (src_pixel_ptr, bmp_src_width);
          Inc             (dst_pixel_ptr,-bmp_dst_width);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure PPGrVInverse       (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect; grad_prop:TGradProp                                                                                                                                                      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  pow          : byte;
begin
  with grad_prop do
    begin
      if (rct_dst.width <=0) or
         (rct_dst.height<=0) then
        Exit;
      dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
      for y:=0 to rct_dst.height-1 do
        begin
          pow:=y_grad_rng_div_vec.a>>16;
          for x:=0 to rct_dst.width-1 do
            InverseDec1(dst_pixel_ptr+x,pow);
          Inc          (dst_pixel_ptr,bmp_dst_width);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure PPGrV16            (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect; grad_prop:TGradProp; Proc16:TProc16                                       ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  pow          : byte;
begin
  with grad_prop do
    begin
      if (rct_dst.width <=0) or
         (rct_dst.height<=0) then
        Exit;
      dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
      for y:=0 to rct_dst.height-1 do
        begin;
          pow:=MAXBYTE-(y_grad_rng_div_vec.a>>16);
          for x:=0 to rct_dst.width-1 do
            Proc16(dst_pixel_ptr+x,0,pow);
          Inc     (dst_pixel_ptr,bmp_dst_width);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure PPGrV17            (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect; grad_prop:TGradProp; Proc17:TProc17                                       ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  pow          : byte;
begin
  with grad_prop do
    begin
      if (rct_dst.width <=0) or
         (rct_dst.height<=0) then
        Exit;
      dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
      for y:=0 to rct_dst.height-1 do
        begin
          pow:=MAXBYTE-(y_grad_rng_div_vec.a>>16);
          for x:=0 to rct_dst.width-1 do
            Proc17(dst_pixel_ptr+x,pow);
          Inc     (dst_pixel_ptr,bmp_dst_width);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure PPGrVMonoNoise     (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect; grad_prop:TGradProp                                                                                                                                                      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  pix_row_val  : TColor;
begin
  with grad_prop do
    begin
      if (rct_dst.width <=0) or
         (rct_dst.height<=0) then
        Exit;
      dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
      for y:=0 to rct_dst.height-1 do
        begin
          pix_row_val:=RGBA(y_grad_rng_div_vec.r>>16,
                            y_grad_rng_div_vec.g>>16,
                            y_grad_rng_div_vec.b>>16,
                            y_grad_rng_div_vec.a>>16);
          for x:=0 to rct_dst.width-1 do
            if Odd((dst_pixel_ptr+x)^) then
                   (dst_pixel_ptr+x)^:=pix_row_val;
          Inc      (dst_pixel_ptr,bmp_dst_width);
          Inc(y_grad_rng_div_vec.r,grad_rng_div_vec.r);
          Inc(y_grad_rng_div_vec.g,grad_rng_div_vec.g);
          Inc(y_grad_rng_div_vec.b,grad_rng_div_vec.b);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure PPGrV18            (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect; grad_prop:TGradProp; Proc18:TProc18                                       ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  pow          : byte;
begin
  with grad_prop do
    begin
      if (rct_dst.width <=0) or
         (rct_dst.height<=0) then
        Exit;
      dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
      for y:=0 to rct_dst.height-1 do
        begin
          pow:=y_grad_rng_div_vec.a>>16;
          for x:=0 to rct_dst.width-1 do
            Proc18(dst_pixel_ptr+x,pow,0);
          Inc     (dst_pixel_ptr,bmp_dst_width);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure PPGrV19            (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect; grad_prop:TGradProp; Proc19:TProc19                                       ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  pow          : byte;
begin
  with grad_prop do
    begin
      if (rct_dst.width <=0) or
         (rct_dst.height<=0) then
        Exit;
      dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
      for y:=0 to rct_dst.height-1 do
        begin
          pow:=y_grad_rng_div_vec.a>>16;
          for x:=0 to rct_dst.width-1 do
            Proc19(dst_pixel_ptr+x,bmp_dst_width,pow);
          Inc     (dst_pixel_ptr,bmp_dst_width);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
procedure PPGrVContrast      (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect; grad_prop:TGradProp                                                                                                                                                      ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  pix_const_val: TColor;
  contrast_pow : integer;
  pow          : byte;
begin
  with grad_prop do
    begin
      if (rct_dst.width <=0) or
         (rct_dst.height<=0) then
        Exit;
      pix_const_val:=RGB(128,128,128);
      dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
      for y:=0 to rct_dst.height-1 do
        begin
          pow:=y_grad_rng_div_vec.a>>16;
          contrast_pow:=FloatToFixed(1+(MAXBYTE-pow)/10);
          for x:=0 to rct_dst.width-1 do
             (dst_pixel_ptr+x)^:=ContrastDec1(
             (dst_pixel_ptr+x)^,pix_const_val,pow,contrast_pow);
          Inc(dst_pixel_ptr,bmp_dst_width);
          Inc(y_grad_rng_div_vec.a,grad_rng_div_vec.a);
        end;
    end;
end; {$endregion}
// (Contrast) Контрастность:
procedure PPContrast1        (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect;                                              const pow      :byte=64      ); {$region -fold}
var
  contrast_pow : double;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  r,g,b        : byte;
  pow2         : shortint;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  r   :=128;
  g   :=128;
  b   :=128;
  pow2:=pow;
  if (pow2>0) then
    contrast_pow:=1+(pow2/10)
  else
    contrast_pow:=1-(Sqrt(-pow2)/10);
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        Contrast1(dst_pixel_ptr+x,r,g,b,contrast_pow);
      Inc        (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
procedure PPContrast2        (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect;                                              const pow      :byte=64      ); {$region -fold}
var
  contrast_pow : double;
  dst_pixel_ptr: PInteger;
  x,y          : integer;
  r,g,b        : byte;
  r_,g_,b_     : longword;
  pow2         : shortint;
begin
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  r_           :=0;
  g_           :=0;
  b_           :=0;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          Inc(r_,TRGBA((dst_pixel_ptr+x)^).r);
          Inc(g_,TRGBA((dst_pixel_ptr+x)^).g);
          Inc(b_,TRGBA((dst_pixel_ptr+x)^).b);
        end;
      Inc              (dst_pixel_ptr,bmp_dst_width);
    end;
  r:=Trunc(r_/(rct_dst.width*rct_dst.height));
  g:=Trunc(g_/(rct_dst.width*rct_dst.height));
  b:=Trunc(b_/(rct_dst.width*rct_dst.height));
  pow2:=pow;
  if (pow2>0) then
    contrast_pow:=1+(pow2/10)
  else
    contrast_pow:=1-(Sqrt(-pow2)/10);
  dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        Contrast1(dst_pixel_ptr+x,r,g,b,contrast_pow);
      Inc        (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
// (Gamma) Гамма:
{0.0<pow<7.0}
procedure PowArrInit         (                   const digits_cnt             :byte=2                                                                                                                                                       ); {$region -fold}
var
  i,j,k,arr_length: integer;
  min_pow         : double=GAMMA_MIN;
  max_pow         : double=GAMMA_MAX;
begin
  k         :=10**digits_cnt;
  arr_length:=Trunc(max_pow*k);
  SetLength(pow_arr,arr_length);
  for i:=0 to arr_length-1 do
    pow_arr[i,0]:=Trunc(min_pow);
  for i:=0 to arr_length-1 do
    for j:=1 to 255 do
      pow_arr[i,j]:=Round(255*((j/255)**(k/i)));
end; {$endregion}
procedure PPGamma            (                   const             bmp_dst_ptr:PInteger; const               bmp_dst_width:TColor; const         rct_dst:TPtRect;                                              const pow      :double       ); {$region -fold}
var
  dst_pixel_ptr: PInteger;
  x,y,pow2     : integer;
begin
  if (pow<=0.0) or
     (pow>=7.0) then
    Exit;
  if (rct_dst.width <=0) or
     (rct_dst.height<=0) then
    Exit;
  pow2         :=GammaPrecalc(pow);
  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width;
  for y:=0 to rct_dst.height-1 do
    begin
      for x:=0 to rct_dst.width-1 do
        Gamma(dst_pixel_ptr+x,pow2);
      Inc    (dst_pixel_ptr,bmp_dst_width);
    end;
end; {$endregion}
{Test FX}
procedure PPTest0            (const arr_src_ptr,arr_dst_ptr:PInteger; const arr_src_width,arr_dst_width:TColor; const rct_dst:TPtRect         ); {$region -fold}
var
  color_info           : TColorInfo;
  arr_src_ptr2         : PInteger;
  arr_dst_ptr2         : PInteger;
  d_width1,d_width2,x,y: integer;
  val1                 : integer=$00000000;//$000000FF;
  val2                 : integer=$00FFFFFF;//$0000FFFF;
begin
  d_width1             :=                         arr_src_width- rct_dst.width;
  d_width2             :=                         arr_dst_width- rct_dst.width;
  arr_src_ptr2         :=arr_src_ptr+rct_dst.left+arr_src_width*(rct_dst.top{+1});
  arr_dst_ptr2         :=arr_dst_ptr+rct_dst.left+arr_dst_width*(rct_dst.top{+1});

  SetColorInfo2(clGreen,color_info);

  for y:=0 to rct_dst.height-1{3} do
    begin
      for x:=0 to rct_dst.width-1 do
        begin
          {
          if (TRGBA(arr_src_ptr2^).a{=}<>0) then
            begin
              if {((arr_src_ptr2-arr_src_width)^>=val1) and
                 ((arr_src_ptr2-arr_src_width)^<=val2) and}
           (TRGBA((arr_src_ptr2-arr_src_width)^).a{<>}<>0) then

                    CircleHighlight02(x+rct_dst.left,y+rct_dst.top+0,arr_dst_ptr,arr_dst_width,rct_dst,color_info,17,255);
                  //Point            (x+rct_dst.left,y+rct_dst.top+0,arr_dst_ptr,arr_dst_width,rct_dst,color_info);
                  //Highlight1((arr_dst_ptr2-arr_dst_width),200);//(arr_dst_ptr2-arr_dst_width)^:=clGreen;
                  //BlurRGB9   (arr_dst_ptr2-arr_dst_width,arr_dst_width);

              if {((arr_src_ptr2+arr_src_width)^>=val1) and
                 ((arr_src_ptr2+arr_src_width)^<=val2) and}
           (TRGBA((arr_src_ptr2+arr_src_width)^).a{<>}<>0) then

                    CircleHighlight02(x+rct_dst.left,y+rct_dst.top+2,arr_dst_ptr,arr_dst_width,rct_dst,color_info,17,255);
                  //Point            (x+rct_dst.left,y+rct_dst.top+2,arr_dst_ptr,arr_dst_width,rct_dst,color_info);
                  //Highlight1((arr_dst_ptr2+arr_dst_width),200);//(arr_dst_ptr2+arr_dst_width)^:=clGreen;
                  //BlurRGB9   (arr_dst_ptr2+arr_dst_width,arr_dst_width);

              if {((arr_src_ptr2-0000000000001)^>=val1) and
                 ((arr_src_ptr2-0000000000001)^<=val2) and}
           (TRGBA((arr_src_ptr2-0000000000001)^).a{<>}<>0) then

                    CircleHighlight02(x+rct_dst.left-1,y+rct_dst.top+1,arr_dst_ptr,arr_dst_width,rct_dst,color_info,17,255);
                  //Point            (x+rct_dst.left-1,y+rct_dst.top+1,arr_dst_ptr,arr_dst_width,rct_dst,color_info);
                  //Highlight1((arr_dst_ptr2-0000000000001),200);//(arr_dst_ptr2-0000000000001)^:=clGreen;
                  //BlurRGB9   (arr_dst_ptr2-0000000000001,arr_dst_width);

              if {((arr_src_ptr2+0000000000001)^>=val1) and
                 ((arr_src_ptr2+0000000000001)^<=val2) and}
           (TRGBA((arr_src_ptr2+0000000000001)^).a{<>}<>0) then

                    CircleHighlight02(x+rct_dst.left+1,y+rct_dst.top+1,arr_dst_ptr,arr_dst_width,rct_dst,color_info,17,255);
                  //Point            (x+rct_dst.left+1,y+rct_dst.top+1,arr_dst_ptr,arr_dst_width,rct_dst,color_info);
                  //Highlight1((arr_dst_ptr2+0000000000001),200);//(arr_dst_ptr2+0000000000001)^:=clGreen;
                  //BlurRGB9   (arr_dst_ptr2+0000000000001,arr_dst_width);

            end;
          }
          if (TRGBA(arr_src_ptr2^).a<>0) then
            begin
              //CircleHighlight05(x+rct_dst.left,y+rct_dst.top{+1},arr_dst_ptr,arr_dst_width,rct_dst,color_info,17,255);
              //CircleHighlight00(x+rct_dst.left,y+rct_dst.top{+1},arr_dst_ptr,arr_dst_width,rct_dst,color_info,17,255);
              CircleHighlight004(x+rct_dst.left,y+rct_dst.top{+1},arr_dst_ptr,arr_dst_width,rct_dst,color_info,17,200);
              CircleHighlight004(x+rct_dst.left,y+rct_dst.top{+1},arr_dst_ptr,arr_dst_width,rct_dst,color_info,05,255);
              CircleHighlight002(x+rct_dst.left,y+rct_dst.top{+1},arr_dst_ptr,arr_dst_width,rct_dst,color_info,17,255{Byte(F_MainForm.TB_Test0.Position)}{255});

            end;
          Inc(arr_src_ptr2);
          Inc(arr_dst_ptr2);
        end;
      Inc(arr_src_ptr2,d_width1);
      Inc(arr_dst_ptr2,d_width2);
    end;
end; {$endregion}
procedure TestArrInit        (const bmp_dst_ptr            :PInteger; const bmp_dst_width              :TColor; const rct_dst:TPtRect; rad2__:TColor=03; rad3__:TColor=03); {$region -fold}
var
  x,y: integer;
begin
  if Length(test_arr)=0 then
    begin
      test_arr_width :=Trunc(rct_dst.width /rad2__);
      test_arr_height:=Trunc(rct_dst.height/rad2__);
      SetLength(test_arr,test_arr_width*test_arr_height);
      test_arr_ptr   :=@test_arr[0];
    end;
  for y:=0 to test_arr_height-1 do
    for x:=0 to test_arr_width-1 do
      (test_arr_ptr+x+test_arr_width*y)^:=(bmp_dst_ptr+rad2__*x-rad3__>>1+rct_dst.left+bmp_dst_width*(rad2__*y-rad3__>>1+rct_dst.top))^;
end; {$endregion}
procedure PPTest1            (const bmp_dst_ptr            :PInteger; const bmp_dst_width              :TColor; const rct_dst,rct_dst3:TPtRect; rad1__:TColor; pow__:byte); {$region -fold}
var
  rct_dst2     : TPtRect;
  color_info   : TColorInfo;
  dst_pixel_ptr: PInteger;
  x,y,i,j      : integer;
  val          : TRGBA2;
  rad1         : TColor=11;
  rad2         : TColor=03;
  rad3         : TColor=03;

  procedure CircleHighlight001(constref x_,y_:integer; constref bmp_dst_ptr_:PInteger; constref bmp_dst_width_:TColor; constref rct_out_:TPtRect; constref color_info_:TColorInfo; constref diam_    :TColor; constref pow_      :byte); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  var
    rct_dst_  : TPtRect;
    pixel_ptr_: PInteger;
    a_m_div_r_: double;
    d_width_  : integer;
    i_,j_     : integer;
    rad1_     : integer;
    rad1_sqr_ : integer;
    rad2_     : integer;
    rad2_sqr_ : integer;
    rad3_     : integer;
    dist_sqr_ : integer;
    d_sqr_    : integer;

    pow_2     : byte;
  begin
    if (diam_=0) then
      Exit;
    rad1_     :=diam_>>1;
    rad1_sqr_ :=rad1_*rad1_;
    a_m_div_r_:=pow_ /rad1_;
    rct_dst_  :=ClippedRct(rct_out_,PtRct(x_-rad1_,y_-rad1_,x_+rad1_,y_+rad1_));
    if (rct_dst_.width=0) or (rct_dst_.height=0) then
      Exit;
    rad2_     :=x_            -rct_dst_.left;
    rad2_sqr_ :=rad2_*rad2_;
    rad3_     :=y_            -rct_dst_.top;
    d_width_  :=bmp_dst_width_-rct_dst_.width;
    pixel_ptr_:=bmp_dst_ptr_  +rct_dst_.left+rct_dst_.top*bmp_dst_width_;
    for j_:=0 to rct_dst_.height-1 do
      begin
        d_sqr_:=sqr(j_-rad3_)+rad2_sqr_;
        for i_:=0 to rct_dst_.width-1 do
          begin
            dist_sqr_:=i_*(i_-rad2_<<1)+d_sqr_;
            if (dist_sqr_<rad1_sqr_) then
              //if (TRGBA(pixel_ptr_^).a<>0) then
                begin
                  //pow_2:=Trunc(a_m_div_r_*sqrt_arr0[dist_sqr_])-pow_;
                  //if (pow_2>200) then
                    AlphaBlend1(pixel_ptr_,color_info_.pix_col,{pow_2}Trunc(a_m_div_r_*sqrt_arr0[dist_sqr_])-pow_);
                  //TRGBA(pixel_ptr_^).a:=1;
                end;
            Inc(pixel_ptr_);
          end;
        Inc(pixel_ptr_,d_width_);
      end;
  end; {$endregion}

begin
  if (rct_dst.width<=0) or (rct_dst.height<=0) then
    Exit;
  color_info   :=Default(TColorInfo);
  TRGBA(color_info.pix_col).b:=$FF;

  dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top;
  for y:=0 to Trunc(rct_dst.height/rad2)-1 do
    begin
      for x:=0 to Trunc(rct_dst.width/rad2)-1 do
        begin
          {val               :=Default(TRGBA2);
          for i:=0 to rad3-1 do
            for j:=0 to rad3-1 do
              begin
                TRGBA2(val).r+=TRGBA((bmp_dst_ptr+rad2*x-rad3>>1-rad2>>1+j+rct_dst.left+bmp_dst_width*(rad2*y-rad3>>1-rad2>>1+i+rct_dst.top))^).r;
                TRGBA2(val).g+=TRGBA((bmp_dst_ptr+rad2*x-rad3>>1-rad2>>1+j+rct_dst.left+bmp_dst_width*(rad2*y-rad3>>1-rad2>>1+i+rct_dst.top))^).g;
                TRGBA2(val).b+=TRGBA((bmp_dst_ptr+rad2*x-rad3>>1-rad2>>1+j+rct_dst.left+bmp_dst_width*(rad2*y-rad3>>1-rad2>>1+i+rct_dst.top))^).b;
              end;
          TRGBA(color_info.pix_col).r:=Trunc(TRGBA2(val).r/sqr(rad3));
          TRGBA(color_info.pix_col).g:=Trunc(TRGBA2(val).g/sqr(rad3));
          TRGBA(color_info.pix_col).b:=Trunc(TRGBA2(val).b/sqr(rad3));}
          TRGBA(color_info.pix_col).r:=TRGBA((bmp_dst_ptr+rad2*x-rad3>>1+rct_dst.left+bmp_dst_width*(rad2*y-rad3>>1+rct_dst.top))^).r;
          TRGBA(color_info.pix_col).g:=TRGBA((bmp_dst_ptr+rad2*x-rad3>>1+rct_dst.left+bmp_dst_width*(rad2*y-rad3>>1+rct_dst.top))^).g;
          TRGBA(color_info.pix_col).b:=TRGBA((bmp_dst_ptr+rad2*x-rad3>>1+rct_dst.left+bmp_dst_width*(rad2*y-rad3>>1+rct_dst.top))^).b;
          //if x+test_arr_width*y<Length(test_arr) then
          //color_info.pix_col:=(test_arr_ptr+x+test_arr_width*y)^;
          {rct_dst2:=ClippedRct(rct_dst,
                               PtRct(rad2*x-rad3>>1-rad2>>1+rct_dst3.left-1,
                                     rad2*y-rad3>>1-rad2>>1+rct_dst3.top -1,
                                     rad2*x-rad3>>1+rad2>>1+rct_dst3.left+1,
                                     rad2*y-rad3>>1+rad2>>1+rct_dst3.top +1));}
         //color_info.pix_col:=Random($00FFFFFF);
         {CircleFloodFill2}
          CircleHighlight001(rad2*x-rad3>>1+rct_dst.left,
                             rad2*y-rad3>>1+rct_dst.top,
                             bmp_dst_ptr,
                             bmp_dst_width,
                             {rct_dst2}rct_dst3,
                             color_info,
                             rad1__,
                             pow__);
          {PPFloodFill(bmp_dst_ptr,
                      bmp_dst_width,
                      rct_dst2{rct_dst3},
                      color_info.pix_col);}
        end;
      //Inc(dst_pixel_ptr,rad2*bmp_dst_width);
    end;

  {dst_pixel_ptr:=bmp_dst_ptr+rct_dst.left+bmp_dst_width*rct_dst.top;
  for y:=0 to Trunc(rct_dst.height/(2*rad2))-1 do
    begin
      for x:=0 to Trunc(rct_dst.width/(2*rad2))-1 do
        begin
          TRGBA(color_info.pix_col).r:=TRGBA((bmp_dst_ptr+2*rad2*x-2*(rad3>>1)+rct_dst.left+bmp_dst_width*(2*rad2*y-2*(rad3>>1)+rct_dst.top))^).r;
          TRGBA(color_info.pix_col).g:=TRGBA((bmp_dst_ptr+2*rad2*x-2*(rad3>>1)+rct_dst.left+bmp_dst_width*(2*rad2*y-2*(rad3>>1)+rct_dst.top))^).g;
          TRGBA(color_info.pix_col).b:=TRGBA((bmp_dst_ptr+2*rad2*x-2*(rad3>>1)+rct_dst.left+bmp_dst_width*(2*rad2*y-2*(rad3>>1)+rct_dst.top))^).b;
          rct_dst2:=ClippedRct(rct_dst,
                               PtRct(2*rad2*x-2*(rad3>>1)-2*(rad2>>1)+rct_dst.left-1,
                                     2*rad2*y-2*(rad3>>1)-2*(rad2>>1)+rct_dst.top -1,
                                     2*rad2*x-2*(rad3>>1)+2*(rad2>>1)+rct_dst.left+1,
                                     2*rad2*y-2*(rad3>>1)+2*(rad2>>1)+rct_dst.top +1));
          CircleHighlight011(2*rad2*x-2*(rad3>>1)+rct_dst.left,
                             2*rad2*y-2*(rad3>>1)+rct_dst.top,
                             bmp_dst_ptr,
                             bmp_dst_width,
                             rct_dst2{rct_dst},
                             color_info,
                             2*rad1,
                             255);
        end;
      Inc(dst_pixel_ptr,2*rad2*bmp_dst_width);
    end;}

end; {$endregion}
procedure PPTest2            (const bmp_dst_ptr            :PInteger; const bmp_dst_width              :TColor; const rct_dst,rct_dst3:TPtRect; rad1__:TColor; pow__:byte; t:byte); {$region -fold}
var
  color_info   : TColorInfo;
  shiftx,shifty: integer;
  x,y,i,j      : integer;
  rad2         : TColor=03;
  rad3         : TColor=03;
begin
  if (rct_dst.width<=0) or (rct_dst.height<=0) then
    Exit;
  shiftx:=rct_dst.left-rad3>>1;
  shifty:=rct_dst.top -rad3>>1;
  for y:=0 to Trunc(Trunc(rct_dst.height/rad2)/2)-1 do
    begin
      j:=2*y+t;
      for x:=0 to Trunc(Trunc(rct_dst.width/rad2)/2)-1 do
        begin
          i:=2*x+t;
          color_info.pix_col:=(bmp_dst_ptr+rad2*i+shiftx+bmp_dst_width*(rad2*j+shifty))^;
          CircleHighlight001(rad2*i+shiftx,
                             rad2*j+shifty,
                             bmp_dst_ptr,
                             bmp_dst_width,
                             rct_dst3,
                             color_info,
                             rad1__,
                             pow__);
        end;
    end;
end; {$endregion}

{$endregion}

end.
